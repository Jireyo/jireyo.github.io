---
title: JVM上篇:内存与垃圾回收
categories:
 - [八股,Java,JVM]
date: 2023-01-23 13:55:59
tag:
 - JVM
 - 八股
---

# 一、JVM与Java体系
- JVM只关心字节码文件
- 虚拟机是对物理计算机的模仿
- JVM是运行在操作系统之上的，不直接与硬件交互
![](Pasted-image-20230123140012.png)
## JVM整体结构
![](Pasted-image-20230123140104.png)
## Java代码执行顺序
![](Pasted-image-20230123140118.png)
## JVM架构模型
Java编译器输入的指令流基本上是一种**基于栈的指令集架构**，另外一种指令集架构则是**基于寄存器的指令集架构**。
- 栈式架构
实现更简单，不需要硬件支持，指令集更小，跨平台
- 寄存器架构
指令集架构则完全依赖硬件，可移植性差

## JVM生命周期
Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

**执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。**

### 虚拟机退出的情况
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统用现错误而导致Java虚拟机进程终止
- 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
- 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。
总结：一个正常执行完毕，两个错误终止，两个手动终止。

# 二、类加载子系统
## 类加载器与类加载过程
![](Pasted-image-20230123140856.png)
- 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。
- **ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。**
- 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）
### 加载阶段
1. 通过类的全限定名定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

{% note primary %}
这里注意，加载阶段就完成了方法区数据结构的装载和Class对象的生成，但此时还没有进行类初始化，即此时类中的字段还没有初始化。
{% endnote %}

#### 补充：class文件来源
- 本地
- 网络
- 动态代理，动态生成
- 压缩包
- JSP
- 数据库
- 加密文件

### 链接阶段
- **验证（Verify）**：
	- 目的在子确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
	- 主要包括四种验证，**文件格式验证，元数据验证，字节码验证，符号引用验证**。
- **准备（Prepare）**：
	- 为类变量分配内存并且设置该类变量的默认初始值，即零值。
	- **这里不包含用final修饰的static，因为final static在编译的时候就会分配了，准备阶段会显式初始化；**
	- **这里不会为实例变量分配初始化**，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
- **解析（Resolve）**：
	- 将常量池内的**符号引用转换为直接引用**的过程。
	- 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。符号引用就是一组符号来描述所引用的目标。
	- 符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

### 初始化阶段
- **初始化阶段就是执行类构造器方法`<clinit>()`的过程。**
- 该阶段是javac编译器自动收集类中的所有**类变量**的赋值动作和**静态代码**块中的语句合并而来。
- 若该类具有父类，JVM会保证子类的`<clinit>()`执行前，父类的`<clinit>()`已经执行完毕。
- 虚拟机必须保证一个类的`<clinit>()`方法在多线程下被同步加锁。

{% note primary %}
- 加载阶段负责把字节码的二进制文件加载到方法区，并根据字节码在堆中生成class对象
- 链接阶段负责检验class文件的正确性、为类的变量分配内存并设置默认值（0值）、解析时将符号应用转换为直接引用。
- 初始化负责对类变量、static块执行赋值。
{% endnote %}

## 类加载器分类
- 分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。
- Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。
![](Pasted-image-20230123144137.png)
### 自带的加载器
**启动类加载器（引导类加载器，Bootstrap ClassLoader）**
- **这个类加载使用C/C++语言实现的，嵌套在JVM内部。**
- 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类
- **并不继承自ava.lang.ClassLoader，没有父加载器。**
- **加载扩展类和应用程序类加载器，并指定为他们的父类加载器。**
- 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

{% note primary %}
- 引导类加载器不继承ClassLoader；其他类都继承该抽象类，被称为自定义类加载器。
{% endnote %}

**扩展类加载器（Extension ClassLoader）**
- Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
- 派生于ClassLoader类
- 父类加载器为**启动类加载器**
- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的`jre/1ib/ext`子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

**应用程序类加载器（系统类加载器，AppClassLoader）**
- java语言编写，由sun.misc.LaunchersAppClassLoader实现
- 派生于ClassLoader类
- 父类加载器为**扩展类加载器**
- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
- 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
- 通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器

### 用户自定义加载器
为什么要自定义类加载器？
- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄漏

{% note primary %}
具体到类加载过程中的步骤，其可以加密（防止源码泄漏），可以扩展加载的源（如网络），可以修改类的加载方式并隔离加载类（热部署）。
{% endnote %}

实现步骤：
- JDK1.2之前，继承ClassLoader，覆盖loadClass方法。
- JDK1.2之后，继承ClassLoader，覆盖findClass方法（其被loadClass方法调用）。
- 没有复杂需求时，直接继承URLClassLoader，避免自己编写findClass。
![](Pasted-image-20230123144950.png)

### 获取ClassLoader方法
- clazz.getClassLoader()
- Thread.currentThread().getContextClassLoader() //上下文线程的加载器
- ClassLoader.getSystemClassLoader() //系统类加载器
- DriverManager.getCallerClassLoader() //调用者的加载器

## 双亲委派机制
- Java虚拟机对class文件采用的是**按需加载**的方式
- 加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

**原理**
![](Pasted-image-20230123145155.png)
具体实现在loadClass()方法中。

## 其他
**如何判断两个class对象是否相同**
在JVM中表示两个class对象是否为同一个类存在两个必要条件：
- 类的完整类名必须一致，包括包名。
- 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。

**对类加载器的引用**
- JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。
- 如果一个类型是由用户类加载器加载的，那么**JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中**。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。
{% note primary %}
不同类加载器加载的对象解析需要其在同一个域。
{% endnote %}

**主动使用与被动使用**
对类的成员的调用：
- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 初始化一个类的子类
规范：
- 反射（比如：Class.forName（"com.atguigu.Test"））
- Java虚拟机启动时被标明为**启动类**的类
- JDK 7 开始提供的动态语言支持：  
    java.lang.invoke.MethodHandle实例的解析结果  
    REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

除了以上七种情况，其他使用Java类的方式都被看作是对**类的被动使用**，都不会导致**类的初始化**。

# 三、运行时数据区
![](Pasted-image-20230123145718.png)


灰色的为单独线程私有的，红色的为多个线程共享的。即：
- 每个线程：独立包括程序计数器、栈、本地栈。
- 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

PS：JVM允许一个应用有多个线程并行的执行。在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。

## JVM系统线程
- 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。
- 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。
- GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。
- 编译线程：这种线程在运行时会将字节码编译成到本地代码。
- 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。

{% note primary %}
可以理解为JVM后台运行的线程，其中虚拟机线程是管理其他线程的线程，其令JVM达到安全点才调用执行一些操作，如Stop-the-world，线程栈收集，线程挂起，偏向锁撤销。
{% endnote %}

## 程序计数器(PC寄存器)
JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。
![](Pasted-image-20230123150208.png)
作用：
PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。
- 它是一块很小的内存空间，几乎可以忽略不记。也是**运行速度最快的存储区域**。
- 在JVM规范中，**每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。**
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；**或者，如果是在执行native方法，则是未指定值（undefined）**。

{% note primary %}
每个线程都拥有一个PC计数器，相互隔离（私有），标识当前线程的执行点，这样执行引擎就会执行该地址代码。
{% endnote %}

**为什么使用PC寄存器记录当前线程的执行地址呢？**
CPU可能会分片执行，切换线程后需要知道从哪里开始执行。

## 虚拟机栈
Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。
- **每个线程在创建时都会创建一个虚拟机栈**，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。
- 生命周期和线程一致
- 主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。
- JVM对栈的操作仅有，出栈，入栈。

Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
- `StackOverflowError`，超过设定的栈容量
- `OutOfMemoryError`，整体内存空间不足。

**设置大小方法:
- **`-Xss`

### 栈的存储单位
- 栈中的数据都是以**栈帧（Stack Frame）的格式存在**。
- 栈帧**先进后出**，一个线程只有一个活动栈帧，这个栈帧被称为**当前栈帧（Current Frame）**，与当前栈帧相对应的方法就是**当前方法（Current Method）**，定义这个方法的类就是**当前类（Current Class）**。

Java方法有两种返回函数的方式：
- 一种是正常的函数返回，使用return指令；
- 另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

### 栈帧中的内容
- **局部变量表（Local Variables）**
- **操作数栈（operand Stack）（或表达式栈）**
- 动态链接（DynamicLinking）（或指向运行时常量池的方法引用）
- 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
- 一些附加信息

#### 局部变量表
- 定义为一个**数字数组**，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。
- **局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
##### Slot
- 局部变量表，最基本的存储单元是Slot（变量槽）
- 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。
- 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。
- 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。
- **byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。**
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个slot上
- **如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。**（比如：访问long或doub1e类型变量）
- 如果当前帧是由**构造方法或者实例方法**创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。

![](Pasted-image-20230123151728.png)
另外，Slot空间可以被复用，如某些局部变量超出作用域后，新的局部变量可以复用该位置。

##### 静态变量与局部变量的对比
Static：类变量表有两次初始化的机会：
- 第一次是在“链接阶段中的准备阶段”，执行系统初始化，对类变量设置零值。
- 另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。

局部变量表：不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

#### 操作数栈
每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）
{% note primary %}
虚拟机栈指的就是整个线程栈，线程栈分若干个栈帧，栈帧中又有操作数栈，**主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**。
{% endnote %}
![](Pasted-image-20230123152330.png)

PS：每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。

**如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新PC寄存器中下一条需要执行的字节码指令。

我们说Java虚拟机的**解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈。

##### 栈顶缓存(Top Of Stack Caching)技术
操作数是存储在内存中的，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**

#### 动态链接
动态链接、方法返回地址、附加信息有时被一起称为帧数据区。

每一个栈帧内部都包含一个**指向运行时常量池中该栈帧所属方法的引用**。通过这个引用，可以实现动态链接。

![](Pasted-image-20230123154403.png)

{% note primary %}
现有动态链接，再有栈帧！
比如，现在某对象A在方法A0中调用对象B的一个方法B0，字节码文件如下：
invokeVirtual B0

此时虚拟机会根据操作数栈顶的对象类型，根据**字符串**查找其方法中类元信息中的**方法入口**。
但是每次调用方法都扫描查找一次类信息是很繁琐的，在方法区的运行时常量池中，直接保存了字符串与方法入口地址的对应关系（直接引用），这个对应关系也叫类B的Vtable。
{% endnote %}

比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，**动态链接的作用就是为了将这些符号引用转换位调用方法的直接引用**。

{% note primary %}
个人理解：某个方法A可能会调用其他方法B，在执行引擎遇到调用其他方法的语句如invokeVirtual时，需要找到方法B的入口。
而栈帧中保存了一个指针，指向了方法B符号在运行时常量池中的位置，再通过运行时常量池，实现将符号引用转化为直接引用。
{% endnote %}
#### 方法返回地址
存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：
- 正常执行完成
- 出现未处理的异常，非正常退出

无论通过哪种方式退出，**在方法退出后都返回到该方法被调用的位置**。
- 方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。
- 通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。
正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。


### 方法的调用
#### 静态链接
目标方法在编译期可知，且运行期保持不变时。对应**早期绑定**，调用非虚方法。
#### 动态链接
被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用。对应**晚期绑定**，调用虚方法。

#### 方法绑定
绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

#### 虚方法与非虚方法
如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

```java
//普通方法调用
invokestatic：调用静态方法，解析阶段确定唯一方法版本
invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本
invokevirtual：调用所有虚方法
invokeinterface：调用接口方法

//动态方法调用
invokedynamic：动态解析出需要调用的方法，然后执行
```

**其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。**

`invokedynamic`在JAVA7中才出现，但没有直接生成该指令，在JAVA8中的Lambda表达式可以生成`invokedynamic`

#### 虚方法表
也就是前面动态链接中提到的Vtable，每个类都有一个这样的虚方法表存在于方法区，便于查找方法的真实入口。

#### 方法重写
1. 根据操作数栈顶元素的实际对象类型寻找方法
2. 找到后使用权限校验，通过则调用，不通过则报异常
3. 找不到则根据继承关系循环进行1，2步
4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。

### 问题
- 方法中定义的局部变量是否线程安全？
具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。

## 本地方法接口和本地方法栈
### 本地方法
native修饰的方法
主要用于与外部环境、操作系统交互，调用C语言实现的方法等。

### 本地方法栈
实现本地方法的管理调用，也是每个线程持有一个。
![](Pasted-image-20230129213758.png)
#### 调用过程
这个图有点问题
- 本地方法入栈后，执行引擎会调用本地方法库执行本地方法。
- **本地方法接口**则是**本地方法访问虚拟机内部数据**的接口。

#### 权限
当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。

并不是所有JVM都支持本地方法。
**在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。**

## 堆
### 堆空间结构
Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区
![](Pasted-image-20230129214614.png)
Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间
![](Pasted-image-20230129214618.png)

**堆空间大小设置**
- "-Xms"用于表示堆区的起始内存，等价于`-XX:InitialHeapSize`
- "-Xmx"则用于表示堆区的最大内存，等价于`-XX:MaxHeapSize`
默认Xms:电脑内存/64
默认Xmx:电脑内存/4

### 年轻代
![](Pasted-image-20230129215125.png)
- 可以设置新生代/老年代占比：默认`-XX:NewRatio=2`
- 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，可以使用`-XX:SurvivorRatio`
- 可以使用`-Xmn`设置新生代最大内存大小。

### 对象分配过程
#### 小对象分配原则
- `Eden`出生，一次MinorGC后进入`Survivor`
- 15次（使用-XX:MaxTenuringThreshold=N调整）Survivor移动后进入`Old`。
- `Old`若被MajorGC可能会清理，若无法保存则报OOM。

#### 其他分配原则
- 大对象直接分配到老年代（尽量避免程序中出现过多的大对象）
- 动态对象年龄判断：如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到`MaxTenuringThreshold`中要求的年龄。
- 空间分配担保（-XX:HandlerPromotionFailure），开启时：
	- MinorGC前检查老年代是否有连续空间容纳新生代的对象空间。
		- 若有，则可以执行MinorGC
		- 若无，检查是否开启空间分配担保`-XX:HandlePromotionFailure`
			- 若开启，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。
				- 若大于，则进行一次MinorGC（有风险）
				- 若小于，FullGC
			- 否则，FullGC
{% note primary %}
为什么需要空间担保：
minorGC时可能直接将大量Survivor区对象直接放入Old区，此时需要Old区保证能接受这些对象，若老年代剩余空间>新生代所有对象大小，则肯定可以接受。若空间<对象大小，则可以根据之前的回收情况预估实际进入老年代的对象大小，判断是否需要据此进行冒险的MinorGC，以避免盲目的FullGC。
**JDK7及以后已经弃用。此后，默认会进行冒险行为，否则FullGC。**
{% endnote %}

#### TLAB
Thread Local Allocation Buffer，堆是所有线程共享的，因此也是线程不安全的。TLAB表示JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。
可以通过`-XX:UseTLAB`决定是否开启TLAB，通过`-XX:TLABWasteTargetPercent`决定TLAB占用Eden空间的大小。


### Minor GC，MajorGC、Full GC
GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。
- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
	- 新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集
	- 老年代收集（Major GC / Old GC）：只是老年代的圾收集。
		- 目前，只有CMSGC会有单独收集老年代的行为。
		- 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
	- 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。
		- 目前，只有G1 GC会有这种行为
- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。

### 触发机制
#### MinorGC
Eden满，需要清理Eden，STW。
![](Pasted-image-20230129220927.png)
#### MajorGC/FullGC
Old区不够用时发生，Major发生总是伴随着MinorGC，但不绝对，STW。

#### FullGC
1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

要尽量避免FullGC，其耗时太长。

### 堆是分配对象的唯一选择吗？
#### 逃逸分析
当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。

JDK6u23后默认开启逃逸分析，此前需要
- 选项“`-XX:+DoEscapeAnalysis`"显式开启逃逸分析
- 通过选项“`-XX:+PrintEscapeAnalysis`"查看逃逸分析的筛选结果

#### 代码优化
- 栈上分配：对象不发生方法逃逸。
- 同步省略：对象不发生线程逃逸（其他线程不访问该对象），也叫**锁消除**。
- 标量替换：将对象结构体（聚合量）替换为一个个属性（标量，基本类型）。使用`-XX:EliminateAllocations`开启。

逃逸分析不成熟，因为分析性能不一定优于优化性能。
**Hotspot中的所有对象都建立在堆上。**

{% note primary %}
JDK7前，字符串常量池在永久代上，后来永久代被元空间取代，而字符串常量池迁移到堆中，符合了所有对象都建立在堆上的结论。
{% endnote %}

## 方法区
### 概念
方法区是一个独立于java堆的内存空间。
![](Pasted-image-20230131114507.png)
前面的概念中有提到，方法区只是一个逻辑上的概念。在JDK8之前，方法区由永久代实现，JDK8之后，方法区由元空间实现，其独立于java堆空间，直接使用本地内存（但是也可能报OOM，本地内存的大小也是有限的）。

### 内存大小
#### jdk7及以前
- 初始：`-XX:Permsize`
- 最大：`-XX:MaxPermsize`

#### jdk8之后
- 初始：`-XX:MetaspaceSize`
- 最大：`-XX:MaxMetaspaceSize`(设置为-1则不受限制)

### 存储什么
#### 类型信息
1. 这个类型的修饰符（public，abstract，final的某个子集）
2. 这个类型的完整有效名称（全名=包名.类名）
3. 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）
4. 这个类型直接接口的一个有序列表

#### 域（Field）信息
1. 域修饰符（public，private，protected，static，final，volatile，transient的某个子集）
2. 域类型
3. 域名称

#### 方法（Method）信息
1. 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
2. 方法的返回类型（或void）
3. 方法名称
4. 方法参数的数量和类型（按顺序）
5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
6. 异常表（abstract和native方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

{% note primary %}
简而言之，我们java文件中写的内容基本都会保存到方法区中。
{% endnote %}

#### 对于static/final
- 若符号由static修饰，说明是类变量，在类的加载过程中生成。
- 若符号由static final修饰，说明是常量，在编译时即完成分配。

#### 运行时常量池
![](Pasted-image-20230131120156.png)
##### 常量池
常量池也称静态常量池，每个类的字节码文件（.class）中都具有一个常量池表，其描述了各种**字面量**与**类、域、方法**的**符号引用**。
而常量池中一般存储有：
- 字段复用
	- 数量值
	- 字符串值
- 类及成员
	- 类引用
	- 字段引用
	- 方法引用

##### 运行时常量池
- 运行时常量池（Runtime Constant Pool）是方法区的一部分。
- 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用。**这部分内容将在类加载后存放到方法区的运行时常量池中**，**一个类加载到 JVM 中后对应一个运行时常量池**。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为**真实地址**。

#### 字符串常量池
**字符串常量池是全局**的，里面存储的是字符串对象，而不是字面量。
```java
//根据常量池的字面量在准备阶段赋值
static final String = "Hello world"
//属于引用类型，在初始化阶段赋值
static final String str = new String("Hello world");
```


{% note primary %}
- 常量池存在于Class文件中，表现为 序号（"#1"） 到 字面量（"java/lang/Object"）的映射
- 运行时常量池存在于方法区，表现为 序号（"#1"）到 字面量（基本类型） 或 真实地址的映射。
- 常量池在类的加载过程的**链接阶段**的**解析阶段**，会将常量池中的字面量解析为真实地址。
{% endnote %}

### 方法区的演进细节
| JDK1.6及之前 | 有永久代（permanet），静态变量存储在永久代上                                                     |
| ------------ | ------------------------------------------------------------------------------------------------ |
| JDK1.7       | 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中                          |
| JDK1.8       | 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 |
{% note primary %}
- 字符串常量池移动到了堆中，但运行时常量池依然在元空间。
- 元空间中可能持有字符串的引用。
{% endnote %}

#### 为什么要使用元空间
- 永久代大小不应限制，使用元空间使用本地内存
- 永久代很难调优，GC起来很困难，类的卸载条件很苛刻。

#### StringTable为何换位置
字符串的创建和回收是很频繁的，放在永久代不宜回收（只有FullGC），而放在堆中可以及时回收。

#### 静态变量存放在哪
虚拟机规范要求将class相关信息放置于方法区中，但没有限制方法区的实现，所以HotSpot选择将静态变量随着class对象一起放在堆中。

#### 方法区GC
方法区主要回收常量池中废弃的常量和不再使用的类型。
- 常量：不再被使用即可回收。
- 类型：
	- 所有对象已经回收
	- 所有对该类的引用已经被回收
	- 对于的类加载器已经被回收
满足类型的回收条件也只是允许回收，并不是必然的。

### 直接内存
元空间使用直接内存，NIO（Native IO）时也可以使用直接内存
#### 非直接内存
使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。
#### 直接内存
使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。
直接内存可以通过`MaxDirectMemorySize`设置，不指定时与-Xmx参数一致。

# 四、对象的实例化过程
## 对象实例化
- new：最常见的方式、Xxx的静态方法，XxxBuilder/XxxFactory的静态方法
- Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public
- Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求
- 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()
- 使用序列化：从文件中、从网络中获取一个对象的二进制流
- 第三方库 Objenesis

{% note primary %}
- new，类，构造器的构造方法是一般的生成新对象方法。
- clone和序列化是复制对象的方法。
- 第三方库
{% endnote %}
## 创建对象的步骤
1. 判断对象对应的类是否加载、链接、初始化
	- 元空间查找
	- 失败，双亲委派加载（classloader+包名+类名）
	- 失败，抛出异常
2. 为对象分配内存（具体如何分配取决于java堆的GC功能）
	- 有规整的内存（使用指针碰撞法时）
	- 内存不规整（需要维护一个空闲列表）
3. 处理并发问题：保证更新的原子性
4. 初始化分配到的内存（所有对象赋默认值，0值）
5. 设置对象的对象头
6. init方法初始化（显示、代码块，构造器）

## 对象内存布局
![](Pasted-image-20230131130349.png)
### 对象头
对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度。
#### 运行时元数据
详情见JUC
- 哈希值（HashCode）
- GC分代年龄
- 锁状态标志
- 线程持有的锁
- 偏向线程ID
- 翩向时间戳

#### 类型指针
指向类元数据InstanceKlass，确定该对象所属的类型。

### 实例数据（Instance Data）
- 相同宽度的字段总是被分配在一起
- 父类中定义的变量会出现在子类之前
- 如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙

### 对齐填充（Padding）
不是必须的，也没有特别的含义，仅仅起到占位符的作用

## 对象访问
有以下两种模式
### 句柄访问
![](Pasted-image-20230131130511.png)
优点在于，若对象被移动只需要修改句柄池

### 直接指针
![](Pasted-image-20230131130542.png)
HotSpot采用这种方式，访问快速。

# 五、执行引擎
## 概述
执行引擎属于JVM的下层，里面包括**解释器、及时编译器、垃圾回收器**
![](Pasted-image-20230131130915.png)
执行引擎的任务就是将字节码指令解释/编译成本地平台上的本地机器指令。

工作流程：执行引擎执行PC寄存器指向的指令，PC寄存器指向下一条指令。

## 编译与执行过程
![](Pasted-image-20230131131115.png)
1. Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：
![](Pasted-image-20230131131132.png)
2. Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示
![](Pasted-image-20230131131139.png)
### 解释器与编译器
解释器：对字节码逐行解释成机器码并执行。
编译器：
- 前端编译器：将java代码编译成class字节码文件
- 后端编译器（JIT编译器）：将源代码直接编译成机器语言。

java是一门半解释半编译的语言。

## 指令基本概念
### 机器码
二进制指令，与CPU相关

### 指令与指令集
将二进制指令使用mov,inc等人类可读的方式表示。不同机器上指令对应的机器码可能不同。每个平台所支持的所有指令，称之为对应平台的指令集。即指令的集合。如-86，ARM

### 汇编语言
用助记符代替机器指令的操作码，使用汇编语言编写的程序需要翻译成机器指令码才能被识别、执行。

### 高级语言
高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍然**需要把程序解释和编译成机器的指令码**。
一般都是高级指令翻译成汇编语言，然后翻译成机器指令才能被执行。

## 解释器
为了实现跨平台，没有采用静态编译生成机器指令，而是生成class文件，由解释器实现跨平台。

### 解释器分类
1. 字节码解释器：纯软件代码模拟字节码执行。
2. 模板解释器：每一条字节码和一个模板函数相关联。

HotSpotVM中，解释器由Interpreter模块和Code模块构成。
- Interpreter模块：实现了解释器的核心功能
- Code模块：用于管理HotSpot VM在运行时生成的本地机器指令

{% note primary %}
Interpreter模块可以将字节码翻译为机器码，Code则管理字节码对机器码的映射。
{% endnote %}

### 现状
基于解释器执行已经沦落为低效的代名词
为了解决该问题，JVM平台支持一种叫作即时编译的技术（JIT），将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可。

## JIT编译器
JIT编译器属于后端编译器，将字节码翻译为机器码，是一种即时编译器。
HopSpot VM使用了**解释器和即时编译器并存的架构**。

有了JIT，为什么还要解释器？
- 快启动
- 编译器无法优化程序时，解释器是逃生门

### 分类
JIT的编译器还分为了两种，分别是C1和C2。
开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：
- `-client`：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。
- `-server`：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。
- **分层编译（Tiered Compilation）策略**：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。
Java7后，就算开启-server模式也会默认使用分层编译。

#### C1
C1编译器上主要有方法内联、去虚拟化、冗余消除。
- 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
- 去虚拟化：对唯一的实现类进行内联
- 冗余消除：在运行期间把一些不会执行的代码折叠掉

#### C2
C2的优化主要是在全局层面，做逃逸分析
- 标量替换：用标量值代替聚合对象的属性值
- 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
- 同步消除：清除同步操作，通常指synchronized

## HopSpotJVM执行方式
解释器先发生作用，即时编译器根据热点探测将有价值的字节码编译为本地机器指令。
- JIT编译器是**后端运行时编译器**（Just In Time Compiler）,将字节码编译成本地机器指令。
- AOT编译器是**静态提前编译器**（Ahead Of Time），将java文件编译成本地机器指令。

### 热点代码及探测
#### 热点代码
一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”。因而可以通过JIT编译器编译为本地机器指令，这种方式叫做栈上替换，或称为OSR（On Stack Replacement）编译。

#### 热点探测功能
HotSpot使用的热点探测方式是**基于计数器**的热点探测。

HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为**方法调用计数器**（Invocation Counter）和**回边计数器**（Back Edge Counter）。
- 方法调用计数器用于统计方法的调用次数。
- 回边计数器则用于统计方法内循环体执行的循环次数。

#### 计数器
Client模式下默认1500次，Server模式下默认10000次。
可以通过`-XX:CompileThreshold`来人为设定阈值。

如果发现**方法调用计数器和回边计数器之和**超过了阈值，则会提交JIT即时编译请求。

#### 热点衰退
方法调用计数器统计的并**不是方法被调用的绝对次数**，而是一个相对的执行频率，即一段时间之内方法被调用的次数。
当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的**衰减（Counter Decay）**，而这段时间就称为此方法统计的**半衰周期（Counter Half Life Time）**
热点衰退在GC时顺便进行，可以使用`-XX:-UseCounterDecay`设置关闭热点衰减，使用`-XX:CounterHalfLifeTime`参数设置半衰周期的时间，单位是秒。


### HotSpotVM 可以设置程序执行方法
缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：
- `-Xint`：完全采用解释器模式执行程序；
- `-Xcomp`：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行

- `-Xmixed`：采用解释器+即时编译器的混合模式共同执行程序。

# 六、StringTable
## String的特点
- 字符串
- final，不可继承
- String实现了Serializable接口：表示字符串是支持序列化的。
- String实现了Comparable接口：表示string可以比较大小
- String在jdk8及以前内部定义了`final char[] value`用于存储字符串数据。JDK9时改为`byte[]`。

## 为什么修改String底层
原因：`char[]`数组中大多数char属于Latin-1字符，使用1byte即可表示，但char需要2byte，空间浪费。

改进：为String提供两种字符集使用（Latin-1或UTF-16）。

## StringPool
String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。

使用`-XX:StringTablesize`可设置StringTable的长度
- 在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求
- 在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求
- 在JDK8中，设置StringTable长度的话，1009是可以设置的最小值

## 内存分配
### 字符
- 直接使用双引号声明出来的String对象会直接存储在**常量池**中。
- 如果不是用双引号声明的String对象，可以使用String提供的intern()方法。
- 使用new，生成的对象在堆中，不入池。

### 字符串常量池
Java 6及以前，字符串常量池存放在永久代
Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内
Java 8元空间，字符串常量池在堆内。

## 字符串操作
### 创建
- `String str ="ab" + "cd"`创建了1个对象，因为"ab"+"cd"会被编译器优化，只在常量池创建一个"abcd"并返回。
- `String str = new String("123")`创建了2个对象，一个"123"在字符串常量池，一个new String在堆中，返回堆中对象。
### 拼接
- **常量(final)与常量(final)**的拼接结果在常量池，原理是编译期优化
- **只要其中有一个是变量**，结果就在堆中。变量拼接的原理是StringBuilder
- 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

#### 优化拼接
- 尽量使用StringBuilder.append()
- 可以在初始化时，指定StringBuilder的capacity，减少扩容次数。

### intern()
语义是：返回常量池中的相同字符串。
- 如果池中本身存在该String对象，则直接返回池中对象。
- 否则，将该对象添加到池中，并返回该String对象。

#### JDK6->JDK7/8
```
String s = new String("1");
s.intern();
String s2 = "1";
String s3 = new String("1") + new String("1");
s3.intern();
String s4 = "11";
```

![](Pasted-image-20230131224322.png)
![](Pasted-image-20230131224329.png)

JDK1.6中，放入池时：
- 若池中有，则不放入，返回已有的池中对象。
- 若没有，则将对象**复制一份**，放入池中，返回池中对象。

JDK1.7后，放入池时：
- 若池中有，则不放入，返回已有的池中对象。
- 若没有，则将对象的**引用地址复制一份**，放入池中，返回引用地址对象。

简单讲，JDK7后的方式，省去了复制对象的开销。

## G1垃圾处理器去重String
1. 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象
2. 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。然后对队列中的元素进行去重处理。
3. 使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。
4. 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
5. 如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。

# 七、垃圾回收
## 垃圾回收概念
### 早期
**垃圾**：垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

早期C/C++，需要开发人员手动释放内存，若存在疏忽则会永久产生内存泄漏。

### Java垃圾回收
Java堆是垃圾收集器的工作重点
- 频繁收集Young区
- 较少收集Old区
- 基本不收集Perm区（元空间）

### 对象finalization机制
- finalize() 方法允许在子类中被重写，**用于在对象被回收时进行资源释放**。
- 不要手动调用，应该由垃圾处理器调用
	- 调用可能使对象复活
	- 执行时间无保证，取决于GC线程
- finalize()只能被调用一次，也就是说一个对象最多复活一次。

## 垃圾回收相关算法
### 标记阶段
判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**。

#### 引用计数算法
对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
优点：
- 实现简单，判断效率高。
缺点：
- 增加了对象的字段
- 加减法时间开销
- **无法处理循环引用**
Python使用引用计数算法，通过弱引用解决循环引用的问题。

#### 可达性分析算法
这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）
##### 思路
- 可达性分析算法是以**根对象集合**（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链**（Reference Chain）

##### GCRoot
栈上引用
- 虚拟机栈上引用对象
- 本地方法栈上引用对象

方法区引用
- 类静态属性
- 常量引用（String Table等）

其他引用
- 同步锁对象
- 虚拟机内部对象（class对象）
- 本地代码缓存等

当然还要考虑GC的作用空间：对于young空间的某对象A，存在着被old空间的对象B引用的情况，因此old空间的对象也需要考虑到GCRoots集合中。


#### 判断对象是否可回收
由于finalize的存在，对象有三种状态。
- 可触及
- 可复活
- 不可触及

标记过程：
1. 若无引用，进行一次标记
2. 若无finalize或finalize已经被执行过，进行二次标记，为不可触及。
3. 若有finalize，加入F-Queue队列等待Finalizer线程执行finalize方法。
4. 随后GC对F-Queue进行标记，看是否可触及，可触及则移出队列，否则移出并标记为不可触及。

### 清除阶段
目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）
#### 标记清除算法
![](Pasted-image-20230131231730.png)
- 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
- 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收

缺点
- 效率不高
- STW
- 碎片

#### 复制算法
![](Pasted-image-20230131231822.png)
优点
- 不需要标记清除，直接复制可达对象，高效
- 无碎片
缺点
- 空间消耗大

##### 应用场景
- Survivor区

#### 标记-压缩（整理）算法
![](Pasted-image-20230131232037.png)
优化了复制算法，使用原本的内存进行移动。

**指针碰撞**
指这种通过指针记录空闲空间的起始点，为新对象分配内存时可以直接分配。

优点
- 相对标记清除，使用了指针碰撞
- 相对复制算法，不耗多余内存

缺点
- 效率比复制低（时间换空间）
- 移动对象时，若对象被其他对象引用，需要调整引用地址（与复制算法相同）
- STW


### 分代收集算法
对不同生命周期的对象采取不同的收集方式，以便提高回收效率。即，实际上的GC采用的是分代收集，其根据收集区域使用不同的收集方式。
- 年轻代（Young Gen），空间不大，复制算法效率最高。
- 老年代（Tenured Gen），不同GC的处理方式不同。

### 增量收集算法与分区算法
#### 增量收集
为了避免STW，GC线程与用户线程交替进行，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。

缺点：线程上下文切换造成总吞吐量下降。

#### 分区
将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。
![](Pasted-image-20230131233426.png)

## 垃圾回收相关概念
### System.gc()
提醒JVM进行FullGC,不保证立刻生效。

### 内存溢出与内存泄露
- 内存溢出：内存超了
	- 超出设置，可以调整
	- 超出机器内存上限
- 内存泄漏：存在不再使用的对象无法被回收
	- 例子：单例模式，资源未close
可以说内存泄漏是内存溢出的元凶之一。

### STW
标记过程（枚举GC Roots）需要STW，因为分析工作必须在一个快照中进行，否则准确性无法保证。

### 垃圾回收的并行与并发
- 并发，指的是多个事情，在同一时间段内同时发生了。
- 并行，指的是多个事情，在同一时间点上同时发生了，只在多核CPU存在。

#### 对于垃圾回收
并行（*Parallel*）：**多条GC线程**同时执行GC。
串行（*Serial*）：**单GC线程**执行GC。
并发（*Concurrent*）：**用户线程与GC线程**交替执行。

一次GC可能同时具有并行、并发的特性。

### 安全点
只有在特定的位置才能STW，这些位置称为安全点。如果安全点过少，GC频率会很低。

中断方式：
- 抢先式中断（已经不再使用），让所有线程在安全点中断。
- 主动式中断，线程运行到安全点后主动询问是否需要中断。

### 安全区域
安全点具有盲区，如果线程无法走到安全点（如Sleep或Block），也应该有中断的机会。
安全区域：**指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。**
因此，也可以把Safe Region看做是被扩展了的Safepoint。

执行时，若线程处于SaveRegion，则可以忽略该线程。当线程走出SaveRegion时，需要判断GC是否结束，若未结束则需要等待。

### 引用
#### 概念
在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。
除强引用外，其他3种引用均可以在java.lang.ref包中找到它们
分类：
- 强引用（StrongReference）：引用赋值，不回收。
- 软引用（SoftReference）：内存不够（将要溢出前）时进行回收
- 弱引用（WeakReference）：GC时后回收
- 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

#### 强引用
- 不回收，内存泄漏的主要原因之一。
- 可以直接访问目标对象。

#### 软引用（SoftReference）
- 内存不足即回收。
- 主要用于高速缓存。
软引用回收时，GC会选择性的将软引用放进一个**引用队列**。

#### 弱引用（Weak Reference）
- 发现即回收。
- GC时发现弱引用即回收。
- 也可用于缓存
比软引用回收更容易，更快。

**会被回收的是WeakReference对象持有的对象，WeakReference本身并不会被回收。**

```java
String hello = new String("value");
WeakReference<String> WeakReference = new WeakReference<>(hello);
//此时不会回收，因为该String被hello强引用持有。
System.gc();
hello = new String("value2");
//此时，new String("value")被回收。
System.gc();
```

#### 虚引用（Phantom Reference）
为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知：
```java
Object obj = new Object(); // 声明强引用
ReferenceQueue phantomQueue = new ReferenceQueue();
PhantomReference<Object> sf = new PhantomReference<>(obj, phantomQueue);
obj = null;
```
虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。
{% note primary %}
简而言之，将对象放入虚引用后得到的引用sf没有任何作用。
但当Object被回收时，phantomQueue会被添加一个虚引用，表示对象已被回收。
{% endnote %}

#### 终结器引用
在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象。

{% note primary %}
由此可见，引用总是伴随着引用队列，JVM根据队列依次对引用进行处理。
{% endnote %}

## 垃圾回收器
### 分类
按线程数分，可以分为**串行垃圾回收器**和**并行垃圾回收器**。
按照工作模式分，可以分为**并发式垃圾回收器**和**独占式垃圾回收器**。
按碎片处理方式分，可分为**压缩式垃圾回收器**和**非压缩式垃圾回收器**。
按工作的内存区间分，又可分为**年轻代垃圾回收器**和**老年代垃圾回收器**。

### GC性能指标
- 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- 内存占用：Java堆区所占的内存大小。
- 快速：一个对象从诞生到被回收所经历的时间。

主要抓住两点：**吞吐量（总效率）、暂停时间（用户体验）**
现在标准：**在最大吞吐量优先的情况下，降低停顿时间**

### 经典垃圾回收器
![](Pasted-image-20230201143734.png)
按线程和工作模式分：
- 串行回收器：Serial、Serial Old
- 并行回收器：ParNew、Parallel Scavenge、Parallel old
- 并发回收器：CMS、G1
按内存区分：
- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1；

#### 组合关系
![](Pasted-image-20230201143826.png)
- 红色虚线是JDK8已经被移除的GC
- 绿色虚线是JDK14中弃用的组合
- 蓝色框CMS GC已被删除


#### 查看
我们选择的只是对具体应用最合适的收集器。
`-XX:+PrintCommandLineFlags`可以查看默认参数。

#### Serial回收器
**Serial GC**：STW，单线程，复制算法
**Serial Old GC**：STW，单线程，标记-压缩算法。

{% note primary %}
根据新老年代需求给出的最土味的算法。
{% endnote %}

##### 评价
Serial Old是Client模式下的默认回收器。
简单高效，但单线程不太行，对于web应用不可接受，已经不用了。

#### ParNew回收器
只回收新生代
**ParNew**：STW，多线程，复制算法
{% note primary %}
相对Serial回收器的多线程版本
{% endnote %}

##### 评价
单CPU下不如串行，可以设置线程数。

#### Parallel回收器
**Parallel Scavenge**：STW，多线程，复制算法
**Parallel Old**：STW，多线程，标记压缩
{% note primary %}
Parallel Scavenge相比于ParNew，回收的目标是**最大的吞吐量**，因此其可控制吞吐量，自适应调节。比较适合**批处理**。
{% endnote %}

##### 评价
JDK8的Server模式下的默认回收器，可以设置线程数和垃圾收集器最大停顿时间，吞吐量，以及设置自适应调节策略。

#### CMS回收器：低延迟
![](Pasted-image-20230201145934.png)
只回收老年代，是第一款并发收集器，用户线程与GC线程同时工作。
**CMS（Concurrent Mark Sweep）**：STW，单/多线程，标记-清除算法
##### 工作过程
- 初始标记：STW，标记GCRoots以及其直接关联到的对象。
- 并发标记：根据GCRoots直接关联对象遍历对象图。
- 重新标记：STW，修正由于并发标记期间用户线程造成的变化。
- 并发清理：清除标记删除的对象，释放内存。
由于并发标记和并发清理最耗费时间，采用并发的方式，整体回收停顿很低。

另外，由于并发标记，清理中用户线程仍在跑，需要提前进行CMS回收才能防止OOM，一般是当堆内存使用率达到某一阈值时，便开始进行回收。
由于标记清除，会产生内存碎片，只能通过**空闲列表**分配内存。

##### 评价
- 并发收集，低延迟
- 会产生内存碎片，低延迟但吞吐量不行。
- 无法处理浮动垃圾（并发标记期间产生的新垃圾）

可以设置触发阈值，JDK9中标记过时，JDK14中已经删除。

#### G1（Garbage First）回收器
官方给G1设定的目标是在**延迟可控的情况下获得尽可能高的吞吐量**，所以才担当起“全功能收集器”的重任与期望。只所以叫G1回收器是因为其优先回收垃圾最多的空间。
![](Pasted-image-20230201151459.png)
##### 特点
- 并行性：STW，多线程回收
- 并发性：部分工作可以与应用程序交替进行
- 分代：依然保持分代，但不要求连续空间，同时回收年轻代和老年代。
- 空间整合：Region之间复制算法，整体使用标记压缩，都避免内存碎片。
- 延迟：可以只回收一个Region，优先回收价值最大的Region。

##### 缺点
- 不能碾压CMS，运行负担更大，小内存应用上CMS更好，大内存引用上G1更好。（6-8G左右）

##### 调优
G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：
- 第一步：开启G1垃圾收集器
- 第二步：设置堆的最大内存
- 第三步：设置最大的停顿时间
- 当然也可以设置并发标记线程数和触发阈值。
提供三种垃圾回收模式：Young GC，Mixed GC，Full GC。

##### 分区
![](Pasted-image-20230201151944.png)
- Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了找连续H区有时必须FullGC。
- 对每个Region内部使用指针碰撞方式分配空间（标记压缩）

##### 回收过程
![](Pasted-image-20230201152200.png)
- 年轻代GC（Young GC）
- 老年代并发标记过程（Concurrent Marking）
- 混合回收（Mixed GC） 
- 全局GC（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）

##### Remembered Set
一个对象可能被不同区域引用，**Remembered Set是所有分代收集器避免全局扫描的关键**。

G1的实现细节：
每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；
然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；
如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
![](Pasted-image-20230201152820.png)

更具体的：
- Card Table
	- 表中的每个entry覆盖512Byte的内存空间
	- 当对应的内存空间发生改变时（如赋值操作的时候，会将该对象所在卡片标记），标记为dirty
- RememberSet（RSet）
	- 指向Card Table中对应的entry
	- 可找到具体内存区域

当更新Region1的某指针时，会将Card标记为dirty，然后把Card存入Dirty Card Queue，这是因为RSet存在多线程竞争写入问题。

{% note primary %}
即，将对象赋予给一个引用时，检查引用与对象是否在同一个region，若不在，则在对象所在region的remember set上记录对象被引用信息，最后在回收该区域时，将remember set上的对象也加入GCRoots。
{% endnote %}

##### Young GC
![](Pasted-image-20230201153244.png)
触发：当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
回收范围：Eden区和Survivor区。
执行原理：STW，多线程，复制算法
过程：
1. 扫描root
2. 更新rset（将Dirty Card Queue中的Card全部处理）
3. 处理rset
4. 复制对象
5. 处理引用（存活对象的地址发送变化）

##### Conconrrent Mark
触发：堆内存达到45%时触发。
回收范围：Eden和Survivor区（触发一次Young GC）
过程：
1. 初始标记阶段：STW，扫描GCRoots，并触发一次Young GC（不一定立即执行）。
2. 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。**这一过程必须在YoungGC之前完成。**
3. 并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
4. 再次标记（Remark）：STW，修正并发标记的问题。
5. 独占清理（cleanup）：STW，计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集
6. 并发清理阶段：识别并清理完全空闲的区域。

##### Mixed GC
触发：并发标记结束后
回收范围：整个Young Region（Eden，Survivor），部分的Old Region(默认为1/8，但分段执行8次)。
过程：
并发标记结束后，全垃圾的region已经被回收，部分垃圾的region已经被计算。使用和年轻代一样的方法GC即可。
备注：
- 可以设置垃圾阈值，默认一个region只有垃圾占65%时才回收。
- 可以设置允许的垃圾阈值，当整堆中垃圾小于其时，不进行MixedGC。

##### Full GC
触发：以上方式无法正常工作（并发处理过程完成前空间耗尽）。
回收范围：整堆
特点：STW

##### 建议
年轻代大小
- 避免使用`-Xmn`或`-XX:NewRatio`等相关选项显式设置年轻代大小
- 固定年轻代的大小会覆盖暂停时间目标
暂停时间目标不要太过严苛
- G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间
- 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。
回收器选择：官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。

{% note primary %}
G1回收器，三种清理模式：
- YoungGC：全程STW，根据GCRoots直接处理Young Region，注意rset的处理，region间复制算法。
- MixedGC：
	- STW扫描全局GCRoots压入扫描栈，并触发YoungGC
	- 根区域扫描，即根据Survivor区找Old区的对象，也压入扫描栈，需要YGC之前完成。 
	- 并发标记，根据扫描栈扫描对象。
	- STW修正标记，处理没处理的write barrier，即新出现的引用变化，但与CMS不同，这里的扫描范围只扫描SATB（snapshot-at-the-beginning），比CMS快。
	- STW计算区域属性
	- 并发清理完全为空的区域
	- 分段（默认8段）清理各区域。
- FullGC
{% endnote %}
