---
title: Redis第6章（缓存问题）
categories:
 - [八股,Redis,基础]
date: 2023-01-05 01:05:37
tag:
 - Redis
 - 八股
---

# 缓存问题

- 缓存穿透
- 缓存穿击
- 缓存雪崩
- 缓存污染（或者满了）
- 缓存和数据库一致性

## 缓存穿透
### 问题
缓存穿透是指**缓存和数据库中都没有的数据**。
缓存不命中则会一直请求数据库，数据库查不到，又无法写入缓存。
### 解决
- 禁止非法请求，如校验参数合法性
- 数据库取不到的数据，在redis中置为key-null，防止大量数据库请求
- bloomfilter，判断key是否在容器中

## 缓存击穿
### 问题
缓存击穿是指**缓存中没有但数据库中有的数据**（单一过期）
缓存过期导致大量针对该过期数据的请求段时间发生。
### 解决
- 设置数据永不过期
- 接口限流、熔断
- 互斥锁

## 缓存雪崩
### 问题
缓存雪崩是指缓存中**数据大批量到过期时间，而查询数据量巨大**（大量同时过期）
### 解决
- 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
- 设置热点数据永远不过期。

## 缓存污染
部分数据缓存后**使用率低**，占用内存。

### 最大缓存设置
**建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销**。

### 新数据进入redis
当新数据进入redis时，如果内存不足怎么办？
- Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。
- 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。

### 淘汰策略
通过`max-memory`配置设置淘汰策略
Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。

**怎么理解呢**？主要看分三类看：
- 不淘汰
    - noeviction （v4.0后默认的）
- 对设置了过期时间的数据中进行淘汰
    - 随机：volatile-random
    - ttl：volatile-ttl
    - lru：volatile-lru
    - lfu：volatile-lfu
-   全部数据进行淘汰
    - 随机：allkeys-random
    - lru：allkeys-lru
    - lfu：allkeys-lfu

具体而言：
1. noeviction
写满了就停止服务。
2. volatile-random
对会过期的键随机删除
3. volatile-ttl
对即将过期的时间进行排序，删除
4. volatile-lru(last-recently-used)
对最后使用时间进行排序，删除最后一次使用较早的数据
5. volatile-lfu（4.0后新增）
对使用次数进行排序，删除最少使用的数据
6. allkeys-random
7. allkeys-lru
8. allkeys-lfu

{% note primary %}
淘汰策略 不是 过期清理策略，其不太关心键是否已经过期，只将是否设置了过期、过期时间作为筛选的范围。
volatile的挑选范围是`所有可能过期的数据`。
allkeys的挑选范围是`所有数据`。
{% endnote %}

#### 具体实现细节
- redis每个数据都会记录最后访问的时间戳（redisObject的lru字段，24位时间戳）和最近使用次数（只有开启LFU时才记录，字段变成lfu，16位时间戳+8位访问次数）。
- LRU淘汰时：
	- 随机选N个数据（可以通过maxmemory-samples设置）
	- 排序lru字段
	- 淘汰lru最小的数据
- LFU淘汰时：
	- 根据访问次数筛选（lru字段后8bit）
	- 淘汰访问次数最低的数据（次数相同则比较最后使用时间，前16bit）

>8bit只能记录255次使用，到达后LFU会退化为LRU，因此有策略控制lfu的增长。

`lfu-log-factor`，有新访问时，只有满足一定算法条件时才count++
`lfu-decay-time`，有新访问时，会按照算法对count进行衰减。

## 数据库和缓存一致性
一般流程：
![](Pasted-image-20230105015406.jpg)
缓存与数据库必然存在不一致情况：
1.先写数据库，再删除redis，后者的删除可能未执行
2.先删除redis，再写数据库，后者还未执行redis可能就又刷新了。

### 同步模式
#### Cache Aside Pattern
**写后失效缓存**
读时：
- **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- **命中**：应用程序从cache中取数据，取到后返回。
写时：
- **更新**：先把数据存到数据库中，成功后，再让缓存失效。

#### Read/Write Through Pattern
应用程序不直接接触数据库，由缓存代理该过程。
相比Cache Aside模式：
读时：
- **失效**：都会查找数据库然后同步到缓存，但Read Pattern会先缓存再返回。
写时：
- **更新**：Write Pattern会先**更新**缓存再写数据库，最后返回。
![](Pasted-image-20230105020042.png)


#### Write Behind Caching Pattern
更新时只更新缓存，定期异步批量更新数据库。
![](Pasted-image-20230105023335.png)
性能高，但数据一致性弱，实现较复杂，要判断哪些需要持久化。

### 如何解决一致性问题
#### 无法解决的问题
以Cache Aside Pattern为例：
读操作（失效时）：1.查找数据库 2.更新缓存
写操作：1.修改数据库 2.失效缓存

同步进行读、写时，若读写先后完成了对数据库的查询、修改，此时写操作先失效缓存导致读操作将旧信息更新到了缓存。
即 读1->写1->写2->读2

该事件这个概率较低，其只发生在读时失效且刚好有并发写操作，且写操作较慢且需要锁表，读操作一般肯定已经完成，所以这个概率会很低。当然最好还是为缓存设置过期时间。

#### 缓存更新失效
解决写操作第二步：失效缓存因为异常导致没有执行的问题
##### 方案1：队列+重试
![](Pasted-image-20230105024206.png)
优点：队列解决了缓存更新失败的问题
缺点：对代码的侵入量大，影响服务速度

方案2：队列+重试+非业务代码做异步更新缓存
![](Pasted-image-20230105181554.png)
由非业务代码读取mysql的操作，然后更新缓存。
优点：不侵入业务
缺点：同步速度慢
例子：canal