---
title: Redis第4章（事件与事物）
categories:
 - [八股,Redis,基础]
date: 2023-01-03 23:08:31
tag:
 - Redis
 - 八股
---
# 事件机制

>所谓事件机制，指的是Redis 接受客户端的请求并响应（文件事件） 和 执行定时任务（时间事件） 的机制。

该事件库处理下面两类事件：
- **文件事件**(file event)：用于处理 Redis 服务器和客户端之间的网络IO。
- **时间事件**(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。

{% note primary %}
文件事件指交互性事件，时间事件指定时类执行事件。
{% endnote %}

![](Pasted-image-20230104015729.png)

`aeEventLoop`是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。

## 文件事件

文件事件处理器使用**IO多路复用技术**，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。

Redis 是单线程主要是指 **Redis 的网络 IO 和键值对读写是由一个线程来完成的**。采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

Redis 使用的IO多路复用技术主要有：`select`、`epoll`、`evport`和`kqueue`等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如`ae_select.c`，`ae_epoll.c`， `ae_kqueue.c`等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。

![](Pasted-image-20230104020000.png)

{% note primary %}
这里还没学，暂时理解为netty、ae_event(Redis使用的)等是异步处理IO复用的应用框架，底层的实现库是与操作系统的具体实现有关。
{% endnote %}

### 文件事件处理器
![](Pasted-image-20230104020123.png)
I/O多路复用程序监听多个套接字（客户端），当需要套接字IO时，产生一个文件事件，Redis将这些就绪的文件事件放在一个队列中（fired就绪事件表），然后文件事件处理器会有序、同步、单个的执行一个个文件事件。

某客户端请求流程如下：
![](Pasted-image-20230104020550.png)

### Redis IO多路复用模型
![](Pasted-image-20230104020629.jpg)
{% note primary %}
这里理解为epoll是一个操作系统内核机制，其监听了3个FD（套接字），当发生事件时，事件入列，然后逐个出列调用函数。
{% endnote %}

## 时间事件
Redis 的时间事件分为以下两类：
- **定时事件**：让一段程序在指定的时间之后执行一次。
- **周期性事件**：让一段程序每隔指定时间就执行一次。

一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：也就是说时间处理器处理某个事件后，判断其需不需要过一段时间再次执行。
![](Pasted-image-20230104022102.png)
所有事件时间放在一个无序链表中，时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件并调用相应事件处理器。

>一般Redis服务器只使用serverCron一个时间事件，这个事件用于更新服务器各类统计数据，清理键值，整理客户端连接，尝试AOF或RDB，同步数据，心跳检测等。总之，Redis会周期性的执行这个函数。

## aeEventLoop实现

Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。具体过程是其会调用aeCreateEventLoop函数：
- 创建该aeEventLoop对象。
- 初始化文件事件表内容
- 初始化时间事件表
- 调用aeApiCreate函数创建epoll实例，初始化apidata
具体实现不细看了，逻辑图如下
![](Pasted-image-20230104024156.png)
# 事务机制

## Redis事务
Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。
### 相关命令
- `MULTI` ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。
- `EXEC`：执行事务中的所有操作命令。
- `DISCARD`：取消事务，放弃执行事务块中的所有命令。
- `WATCH`：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。
- `UNWATCH`：取消WATCH对所有key的监视。

### 错误处理
- 语法错误：若存在语法错误，整个事务不会被执行。
- 类型错误：若在执行时发送Redis类型错误，该条命令失败，但其他命令正常执行。

### 乐观锁实现
WATCH命令为Redis事务提供了CAS的行为：
当执行了WATCH命令监视某键后，在执行时发现与WATCH时相比，键值发生了变化，则回滚事务。最后会取消监控。
![](Pasted-image-20230104025042.png)
### 事物执行步骤
- MULTI开始
- 入队
- 执行
![](Pasted-image-20230104025058.png)

### 分布式锁实现
redis悲观锁又称为分布式锁，主要是为了防止数据被其他客户改变。
```shell
setnx lock-key value
```
通过以上命令可以设置分布式锁(key=lock-key)：
- 若设置成功，会返回值，拥有控制权。
- 若设置失败，无返回值，需要排队等待。
期间其他客户无法操作lock-key。
操作完毕后通过**del操作释放锁**。

### 分布式锁改良
使用expire为lock-key设置过期时间，防止忘记或程序中断导致忘记释放锁


## 深入理解
### Redis不支持回滚？
redis只会因语法错误（主要指类型错误这种无法提前检测的命令）而失败，这个错误是在编程时应该避免的。

### ACID？
- 原子性*atomicity*
有观点认为Redis没有原子性，因为其不支持运行期回滚，但Redis官方的理解如下：
**Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。**这个过程并不保证执行成功。
- 一致性*consistency*
Redis能保证命令失败的情况下回滚（普通语法错误、WATCH锁），能保证一致性。
- 隔离性*Isolation*
**单线程**的本质保证了隔离性（不会被其他客户端打断）
- 持久性*Durability*
**redis事务是不保证持久性的**，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。

## 其他实现
- **基于Lua脚本**，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。
- **基于中间标记变量**，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。

# 删除策略
>删除作为一个redis事件，也放在本章一起阐述。

使用`TTL`可以查看键的生命状态：
- xx为时效数据
- 1为永久有效数据
- 2为已经过期或不存在的数据

## 常见的删除策略
1. 定时删除：定时任务，到时即删除
2. 惰性删除：访问时删除，调用expireIfNeeded函数
3. 定期删除：定期清理，serverCron()中会执行删除。

{% note success %}
redis使用的是**惰性删除**和**定期删除**
{% endnote %}

{% note primary %}
对于RDB，其不会记录已经删除的键
对于AOF，键过期后会在文件后面加上DEL key的命令。
{% endnote %}

### 存储格式
![](Pasted-image-20230105004950.png)

这个格式不是redisObject的格式，而是redis数据库的一个格式。
redisDB结构中expires保存了所有的键过期信息。
![](Pasted-image-20230105010244.png)
