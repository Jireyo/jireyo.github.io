

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#727679">
  <meta name="author" content="Jin">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、数据类型与结构基本数据结构：String、List、Set、Zset、Hash高级数据结构：Bitmap、Geo、HyberLogLog、Stream redisObjecttype和encoding共同实现了redis对象的多态处理。 123456789101112typedef struct redisObject &amp;#123;    &#x2F;&#x2F; 类型    unsigned type:4;">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis复习">
<meta property="og:url" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Jin&#39;s Blog">
<meta property="og:description" content="一、数据类型与结构基本数据结构：String、List、Set、Zset、Hash高级数据结构：Bitmap、Geo、HyberLogLog、Stream redisObjecttype和encoding共同实现了redis对象的多态处理。 123456789101112typedef struct redisObject &amp;#123;    &#x2F;&#x2F; 类型    unsigned type:4;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230103190014.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cadf797496816eb343a19c2451437f1e.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/a3b1f6235cf0587115b21312fe60289c.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/f46cbe347f65ded522f1cc3fd8dba549.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/c5fb0a602d4caaca37ff0357f05b0abf.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2fedbc9cd4cb7236c302d695686dd478.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/e84b052381e240eeb8cc97d6b729968b.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323223354.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323215824.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/98987d9417b2bab43087f45fc959d32a.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/t_70-20230309231944807.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235505.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235714.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000231.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000718.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323234744.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/ea4f7e86baf2435af3999e5cd38b6a26.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/03eacec67cc58ff8d5819d0872ddd41e.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2db4831516b9a8b79f833cf0593c1f12.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165951.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324172724.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/86b0046c2622b2c4bda697f9bc0f5b28.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/8febac10b14bed16cb96d1d944cd08da.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/454a8228a6549176ad7e0484fba3c92b.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/6e3db3ba2f829ddc14237f5c7c00e7ce.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cc208c2931b4e889d1a58cb655537767.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/1cc7401143e79383ead96582ac11b615.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165034.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165054.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164739.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164801.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2ee2280e9f59b6b4879ebdec6eb0cf52.webp">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.webp">
<meta property="article:published_time" content="2023-01-06T10:32:37.000Z">
<meta property="article:modified_time" content="2023-06-18T07:05:03.377Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="概念整理">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230103190014.png">
  
  
  
  <title>Redis复习 - Jin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong style="color: #fff;">Jin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                归档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-06 18:32" pubdate>
          2023年1月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          100 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis复习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、数据类型与结构"><a href="#一、数据类型与结构" class="headerlink" title="一、数据类型与结构"></a>一、数据类型与结构</h1><p>基本数据结构：String、List、Set、Zset、Hash<br>高级数据结构：Bitmap、Geo、HyberLogLog、Stream</p>
<h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><p>type和encoding共同实现了redis对象的多态处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230103190014.png" srcset="/img/loading.gif" lazyload></p>
<p><em>对象共享</em><br>redis也有常量池，存了命令返回值（”OK”）和10000以内整数，但不是所有对象都共享，否则复杂度较高，用其换取内存不划算。</p>
<p><em>引用计数</em><br>refCount引用计数归零后可被回收</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><em>编码</em><br>有三种编码类型：int、embstr、raw，其中字符串内容的字节超过一定阈值（不同版本阈值不一样）时使用raw。<br>int：long对象，与RedisObject一起分配内存。<br>embstr：SDS对象，与RedisObject一起分配内存，不可变（<strong>只读</strong>）。<br>raw：SDS对象，与RedisObject分开分配内存，可变。</p>
<p><em>限制</em><br>value最多容纳512M。</p>
<p><em>应用</em><br>缓存对象，计数，<strong>分布式锁</strong>（SETNX实现「key不存在才插入」，同时设置过期时间PX），Session（分布式环境下去同一个Redis）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET lock_key unique_value NX PX 10000<br></code></pre></td></tr></table></figure>
<p>优点：高性能，实现方便，避免单点故障<br>缺点：超时时间不好设置（解决：使用守护线程续约枷锁）、异步复制可能导致不可靠。</p>
<h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>简单动态字符串（simple dynamic string,SDS）</p>
<p><em>组成</em><br><code>len</code>(字符串长度)+<code>alloc</code>(分配的字节数)+<code>flags</code>(类型标志)+<code>buf[]</code>(数据)<br><code>alloc-len</code>可以得到剩余空间的大小，作为是否需要扩容的依据。</p>
<p><em>优点</em></p>
<ul>
<li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li>
<li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li>
<li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul>
<li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。<ul>
<li>小于1MB时，翻倍扩容</li>
<li>大于1MB时，多给1MB空间</li>
</ul>
</li>
<li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li>
</ul>
</li>
<li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li>
<li><strong>动态分配内存</strong>：节省空间，还会禁止编译器做优化对齐。</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>按插入顺序排序。</p>
<p><em>编码</em><br>List 类型的底层数据结构是由<strong>双向链表</strong>或<strong>压缩列表</strong>实现的（元素个数小于512个且都小于64字节时使用压缩链表，否则使用双向链表。）<br>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 <strong>Quicklist</strong> 实现了。</p>
<p><em>应用</em><br>消息队列（不支持消费组）</p>
<ul>
<li>为避免消费者循环读取，提供了阻塞式读取。</li>
<li>若要处理重复信息：需要为每个消息打上全局ID。</li>
<li>消费者读取时将其存在另一个待完成list（备份）中。</li>
</ul>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cadf797496816eb343a19c2451437f1e.webp" srcset="/img/loading.gif" lazyload><br>dup、free、match是可以自定义实现的函数。</p>
<p><em>优点</em><br>在于访问&#x2F;添加头节点尾节点快<br><em>缺点</em><br>在内存碎片多且浪费大</p>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/a3b1f6235cf0587115b21312fe60289c.webp" srcset="/img/loading.gif" lazyload><br><em>组成</em></p>
<ul>
<li>zlbytes，记录整个压缩列表占用内存字节数（整个内存）；</li>
<li>zltail，记录压缩列表「尾部」节点距离起始地址由多少字节（entryN起始位置，便于查找），也就是列表尾的偏移量；</li>
<li>zllen，记录压缩列表包含的节点数量；</li>
<li>zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p><em>Entry组成</em></p>
<ul>
<li>prevlen，上一个节点的长度（占用1字节或5字节：以254字节为分界）</li>
<li>encoding，指定类型为字符串或整数以及其长度（整数占1字节，字符串占1&#x2F;2&#x2F;5字节）。</li>
<li>data，实际数据</li>
</ul>
<p><em>特点</em></p>
<ul>
<li>每个entry保存了本entry长度和前一个entry的长度，便于逆向搜索</li>
<li>每个entry的类型根据实际长度灵活变化</li>
</ul>
<p><em>优点</em><br>省空间</p>
<p><em>缺点</em></p>
<ul>
<li>entry内容变化时会改变prelen，prelen因此也变化长度，可能需要<strong>连锁更新</strong>；</li>
<li>节点数量过多时，搜索缓慢</li>
</ul>
<h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/f46cbe347f65ded522f1cc3fd8dba549.webp" srcset="/img/loading.gif" lazyload><br>双向链表 + 压缩列表（控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题）。</p>
<h4 id="ListPack"><a href="#ListPack" class="headerlink" title="ListPack"></a>ListPack</h4><p>Redis7.0中取代了压缩列表<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/c5fb0a602d4caaca37ff0357f05b0abf.webp" srcset="/img/loading.gif" lazyload><br>整体结构：相比压缩列表，少了尾部指针。<br>Entry结构：相比压缩列表，len放在末尾标识本entry长度，同样可以倒序。<br>暂未使用。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><em>编码</em><br><strong>压缩列表</strong>（元素个数小于512个，所有值小于64字节）或<strong>哈希表</strong></p>
<p><em>应用</em><br>缓存对象</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><code>dict</code> -&gt; <code>dictht</code> -&gt; <code>dictEntry[]</code><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2fedbc9cd4cb7236c302d695686dd478.webp" srcset="/img/loading.gif" lazyload></p>
<p><em>rehash</em><br>触发条件：</p>
<ol>
<li>负载因子大于1且没有bgsave或bgrewriteaof任务。</li>
<li>负载因子大于5时。<br>过程：</li>
<li>正常过程写入<code>ht1</code>中。</li>
<li>扩容时，为<code>ht2</code>赋予一个长度为2倍<code>ht1</code>的哈希表。</li>
<li>逐步迁移数据。</li>
<li>释放「ht1」，并使用「ht2」替换「ht1」。</li>
</ol>
<p><em>渐进式rehash</em></p>
<ul>
<li>给「ht2」分配空间</li>
<li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作（查找时先找old再找new，新增时直接添加在new上）之外，还会顺序将「ht1」中索引位置上的所有 key-value 迁移到「ht2」上；</li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「ht1」的所有 key-value 迁移到「ht2」，从而完成 rehash 操作。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>无序集合，成员唯一。</p>
<p><em>编码</em><br>整数集合（元素数量不超过512）或哈希表</p>
<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p><em>组成</em></p>
<ul>
<li><code>encoding</code>：标识整数的类型（int16、int32、int64）；</li>
<li><code>length</code>：记录压缩列表「尾部」节点距离起始地址由多少字节（entryN起始位置，便于查找），也就是列表尾的偏移量；</li>
<li><code>contents[]</code>：记录压缩列表包含的节点。</li>
</ul>
<p><em>升级</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/e84b052381e240eeb8cc97d6b729968b.webp" srcset="/img/loading.gif" lazyload><br><strong>节省内存资源</strong>。且不支持降级。</p>
<p><em>应用</em><br>点赞、共同关注</p>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>权重排序</p>
<p><em>编码</em><br><strong>压缩列表（小于128个元素，且元素小于64B）</strong> 或 <strong>跳表（加哈希表）</strong></p>
<p><em>应用</em><br>排行榜</p>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>注意跳表是结合了dict结构使用的，但dict主要起常数时间获取权重的作用。<br><em>结构</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323223354.png" srcset="/img/loading.gif" lazyload><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323215824.png" srcset="/img/loading.gif" lazyload><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.webp" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>zskiplistNode：其包含ele（数据），score（权重），backward（前一个节点指针，便于后序遍历），zskiplistLevel数组；</li>
<li>zskipLevel：记录了指向节点的指针和距离；</li>
<li>zskipList：记录头尾指针、链表长度、最大层数。</li>
</ol>
<p><em>设计细节</em><br>查询</p>
<ul>
<li>为了实现快速跳跃，从<strong>头节点的最高层</strong>开始搜索：发现目标节点在该节点之后（目标权重更高或权重相同但键更大），继续同层搜索，否则降层搜索。<br>层次</li>
<li>相邻两层的节点数量的比例会影响跳表的查询性能，理想的比例是1:2，但会带来调整开销，所以选择随机生成每层的节点数：循环生成一个<code>[0,1]</code>的随机数，其小于0.25则加一层，直到大于0.25。最高为64层。</li>
<li>头节点不保存数据，64层。</li>
</ul>
<p><em>为什么使用跳表而不是红黑树？</em></p>
<ol>
<li>范围查找跳表更方便，找到端点后遍历即可，红黑树还要想办法中序遍历。</li>
<li>内存占比上，每个节点的指针更少。</li>
<li>算法实现更简单，不需要调整。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>String：int&#x2F;SDS(embstr，raw)</li>
<li>List：ziplist&#x2F;linkedlist -&gt; quicklist(3.2) -&gt; ListPack</li>
<li>Hash：ziplist&#x2F;dict</li>
<li>Set：intset&#x2F;dict</li>
<li>Zset：ziplist&#x2F;skip</li>
</ul>
<p>list，hash，set，Zset都试图使用<strong>压缩列表</strong>（排序的压缩列表或整数集合）来处理数量小于512&#x2F;512&#x2F;512&#x2F;128个且大小都小于64字节的元素集合，否则使用高级数据结构。</p>
<h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>统计01<br><em>原理</em><br>string，二进制字节数组</p>
<p><em>应用</em><br>签到统计</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>不精确的去重计数，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数。</p>
<p><em>应用</em><br>日活</p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>保存经纬度</p>
<p><em>编码</em><br>Zset</p>
<p><em>应用</em><br>打车</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>消息队列（基于内存的不可靠版）</p>
<p><em>特点</em></p>
<ul>
<li>可自动生成不重复、<strong>递增</strong>的id（eg：时间戳-序号）。</li>
<li>有消费组，组内消费者为竞争关系。</li>
<li>每个消费组维护一个pending_ids，保证可靠性。只有消费者回复ACK后才将其标记为完成，消费者宕机重启后可查看未处理完的消息。</li>
<li>其他消费组也可以将目标消费者<strong>超时未处理</strong>的消息转移到自己的pending列表</li>
<li>死信，转发一定次数后都无法被消费者处理的消息，可输出XDEL。</li>
</ul>
<p><em>与专业消息队列的差别</em></p>
<ul>
<li>redis基于内存，宕机时磁盘中不是最新数据，主从切换时同理。专业消息队列基于集群，有多个副本。</li>
<li>redis基于内存，可能OOM，而Kafka和RabbitMQ基于磁盘</li>
</ul>
<p><em>Stream会丢消息吗？</em></p>
<ul>
<li>生产者处理好与队列的ACK确认就，不会发生丢失。</li>
<li>消费者将消息处理完成后再XACK，不会发送丢失。</li>
<li>中间件会丢消息吗？会，AOF时没完成写盘，或主从复制切换。</li>
</ul>
<p><em>Stream能处理消息挤压吗？</em><br>Stream能指定最大长度，超出后旧消息会被删除。而传统MQ则会存在内存中。</p>
<h3 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h3><p>发布订阅是redis开放的一个通讯功能，消息队列stream是对其可靠性的补充。<br><em>两种发布&#x2F;订阅模式</em></p>
<ul>
<li>基于频道(Channel)的发布&#x2F;订阅：频道以哈希表结构保存，订阅同一频道的消费者以链表保存，发布的消息只发布给对于频道的消费者。</li>
<li>基于模式(pattern)的发布&#x2F;订阅：模式以链表结构保存，发布消息时，对每个模式进行表达式对比，然后选择发送。</li>
</ul>
<p><em>发布订阅方式（只适合即时通讯场景）为什么不能做消息队列</em></p>
<ul>
<li>不具有数据持久化</li>
<li>不保存历史信息</li>
<li>消息挤压时，消费者可能被强制断开</li>
</ul>
<h1 id="二、持久化"><a href="#二、持久化" class="headerlink" title="二、持久化"></a>二、持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><em>流程</em><br>主线程阻塞进行或子线程后台进行，使用COW技术应对主线程的修改。</p>
<p><em>执行策略</em></p>
<ul>
<li>主动执行：<ul>
<li>save&#x2F;bgsave</li>
</ul>
</li>
<li>自动执行：<ul>
<li>定时触发：<code>save m n</code>，m秒有n条发生变化</li>
<li>主从复制</li>
<li>执行debug reload重新加载redis，bgsave操作</li>
<li>shutdown命令</li>
</ul>
</li>
</ul>
<p><em>特点</em></p>
<ul>
<li>文件小，且加载速度快。</li>
<li>全量快照，执行缓慢，实时性差。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><em>流程</em><br>主线程先执行命令，成功后写入aof_buf<strong>内核</strong>缓冲区，aof_buf根据策略刷新到磁盘。</p>
<p><em>写回策略</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/98987d9417b2bab43087f45fc959d32a.webp" srcset="/img/loading.gif" lazyload><br>底层：在不同的时间点调用<code>fsync()</code>函数。（请求将内核缓冲区内容立刻刷盘）</p>
<p><em>重写机制</em><br>会使用<em>bgrewriteaof</em>后台重写：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/t_70-20230309231944807.webp" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>fork子进程（复制虚拟页表，<strong>第一次阻塞</strong>）</li>
<li>主线程同时需要完成写内存，写aof缓存（仍正常刷盘在原文件上），写aof重写缓存（方便后续追加在重写文件上）</li>
<li>使用CopyOnWrite技术（复制物理内存，<strong>第二次阻塞</strong>，如果修改的是bigkey，则阻塞更久）和解决一致性；</li>
<li>子线程完成rewrite，发送<strong>信号</strong>（<strong>第三次阻塞</strong>），通知主线程追加aof命令和改名<strong>原子覆盖</strong>。</li>
</ul>
<p><em>重写触发</em></p>
<ul>
<li>当前文件大小超过上次重写后的百分之多少。</li>
<li>当前文件大小超过设置大小。</li>
</ul>
<h2 id="RDB和AOF混合持久化"><a href="#RDB和AOF混合持久化" class="headerlink" title="RDB和AOF混合持久化"></a>RDB和AOF混合持久化</h2><p><em>开启</em></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">aof-<span class="hljs-keyword">use</span>-rdb-preamble yes<br></code></pre></td></tr></table></figure>

<p><em>流程</em><br>AOF文件：前半部分记录RDB内容，后半部分记录AOF部分。本质是通过 <strong>AOF 后台重写</strong>触发完成的，会重新生成RDB内容，并将期间产生的AOF部分添加在AOF文件后面。</p>
<p><em>加载流程</em><br>优先加载AOF，不存在再加载RDB。</p>
<h2 id="big-key"><a href="#big-key" class="headerlink" title="big key"></a>big key</h2><p><em>Big Key的影响</em></p>
<ul>
<li>客户端超时</li>
<li>网络阻塞</li>
<li>DEL阻塞</li>
<li>内存分布不均匀</li>
<li>AOF日志：刷盘阻塞耗时</li>
<li>AOF重写：快速触发重写，拷贝大虚拟页表阻塞耗时，如果对big key写，COW的物理内存复制也阻塞耗时。</li>
</ul>
<p>寻找Big Key</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --bigkeys<br></code></pre></td></tr></table></figure>

<p><em>避免Big Key</em></p>
<ul>
<li>拆分big key</li>
</ul>
<p>删除Big Key</p>
<ul>
<li>对其的删除使用unlink，异步延迟释放内存。</li>
<li>分批次删除</li>
</ul>
<p><em>Linux开启内存大页</em><br>会允许以2MB为单位分配内存，会导致小数据修改也要在COW中拷贝大页。</p>
<h1 id="三、事件机制"><a href="#三、事件机制" class="headerlink" title="三、事件机制"></a>三、事件机制</h1><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.webp" srcset="/img/loading.gif" lazyload><br><em>Redis事件处理模型</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235505.png" srcset="/img/loading.gif" lazyload></p>
<p><code>aeEventLoop</code>是事件驱动的核心，同时管理<strong>文件事件</strong>和<strong>时间时间</strong>。</p>
<p><em>Redis与IO多路复用</em><br>redis支持select、epoll、kqueue等技术，适配操作系统实现。</p>
<p><em>Redis文件事件</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235714.png" srcset="/img/loading.gif" lazyload><br>使用<strong>Redis文件事件处理器</strong>实现<strong>连接应答</strong>、<strong>请求处理</strong>、<strong>响应处理</strong>等事件的分发。</p>
<p><em>Redis时间事件</em><br>时间事件执行器运行时，遍历整个时间事件<strong>无序链表</strong>，查找已经到达的时间事件并调用相应事件处理器。</p>
<ul>
<li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li>
<li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li>
</ul>
<blockquote>
<p>Redis一般只使用<code>serverCron</code>时间事件，用于统计，删除过期键，RDB，AOF，同步，心跳等，周期执行</p>
</blockquote>
<p><em>实现</em><br>初始化函数<code>initServer</code>创建了aeEventLoop对象，初始化文件、时间事件表，创建epoll实例。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000231.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h1><p><em>语句</em><br><code>MULTI</code>开启事务，<code>EXEC</code>执行事务，<code>DISCARD</code>取消事务。</p>
<p><em>回滚</em><br>Redis不支持回滚：</p>
<ul>
<li>若出现语法错误，整个事务不执行。</li>
<li>若出现类型错误，错误语句执行失败，其他语句依然执行。</li>
</ul>
<p><em>ACID</em><br>A：<strong>官方认为支持</strong>原子性，要么全执行要么全不执行（不保证每个语句都执行成功）。<br>C：<strong>支持</strong>，WATCH锁<br>I：<strong>支持</strong>，单线程<br>D：<strong>不支持</strong>，AOF刷盘时机 ，RDB间隔都可能丢数据。</p>
<p><em>乐观锁</em></p>
<ul>
<li><code>WATCH KEY</code>：在<code>MULTI</code>前执行，在<code>EXEC</code>时若发现KEY被修改，则不会执行事务。</li>
<li><code>UNWATCH</code>：取消对所有key的监视。</li>
</ul>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000718.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="五、删除策略和淘汰策略"><a href="#五、删除策略和淘汰策略" class="headerlink" title="五、删除策略和淘汰策略"></a>五、删除策略和淘汰策略</h1><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p><em>设置过期时间</em><br><code> expire key 100</code></p>
<p><em>过期判断</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323234744.png" srcset="/img/loading.gif" lazyload><br>redis会将会过期的键放在过期字典（key:expire）中，get key时，先在字典中搜索，看是否存在以及是否过期。</p>
<p><em>删除策略</em></p>
<ul>
<li>定时删除</li>
<li>定期删除（定期删除行为会在ServerCron函数中执行）</li>
<li>惰性删除</li>
</ul>
<p>Redis 选择「<strong>惰性删除+定期删除</strong>」这两种策略配和使用</p>
<blockquote>
<p>对于RDB，其不会记录已经删除的键<br> 对于AOF文件，键过期后会在文件后面加上DEL key的命令，重写时则不会记录该key。</p>
</blockquote>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p><em>内存淘汰策略</em></p>
<ol>
<li>noeviction：写满了就停止服务。</li>
<li>volatile-ttl：对即将过期的时间进行排序，删除</li>
<li>volatile-random：对会过期的键随机删除</li>
<li>volatile-lru(last-recently-used)：对最后使用时间进行排序，删除最后一次使用较早的数据</li>
<li>volatile-lfu（4.0后新增）：对使用次数进行排序，删除最少使用的数据</li>
<li>allkeys-random</li>
<li>allkeys-lru</li>
<li>allkeys-lfu</li>
</ol>
<p><em>redis实现lru&#x2F;lfu淘汰</em><br>lru模式：最近最少使用，用redisObject的lru字段（24位记录时间戳）记录，会造成<strong>缓存污染</strong><br>lfu模式：最近最不常用，用redisObject的lru字段（16位记录时间戳，8位记录访问次数，会衰减）。<br>随机选一批数据，排序。</p>
<p><em>原理</em><br>新数据进入redis时，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，则执行淘汰算法。</p>
<h1 id="六、高可用"><a href="#六、高可用" class="headerlink" title="六、高可用"></a>六、高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><em>作用</em></p>
<ul>
<li>数据冗余 -&gt; 故障恢复</li>
<li>负载均衡</li>
<li>读写分离</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><em>初次建立连接（全量复制）</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/ea4f7e86baf2435af3999e5cd38b6a26.webp" srcset="/img/loading.gif" lazyload><br>注意点：</p>
<ul>
<li><strong>psync</strong>请求可以和aof刷盘的fsync联合记忆</li>
<li><strong>runID</strong>和复制进度<strong>offset</strong>。</li>
<li>最后发送<strong>replcation buffer</strong>。</li>
</ul>
<p><em>命令传播</em><br>长连接！<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/03eacec67cc58ff8d5819d0872ddd41e.webp" srcset="/img/loading.gif" lazyload></p>
<p><em>再次连接（增量复制）</em><br>注意：</p>
<ul>
<li><strong>repl_backlog_buffer</strong>，「环形」缓冲区。</li>
<li><strong>replication offset</strong>，标记缓冲区的同步进度。<ul>
<li>主服务器使用 <code>master_repl_offset</code> 来记录自己「_写_」到的位置。</li>
<li>从服务器使用 <code>slave_repl_offset</code> 来记录自己「_读_」到的位置。</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2db4831516b9a8b79f833cf0593c1f12.webp" srcset="/img/loading.gif" lazyload><br>若<code>slave_repl_offset</code>在<code>repl_backlog_buffer</code>中，则会将增量数据写入<code>replication buffer</code>，继续传播。否则，全量复制。</p>
<blockquote>
<p>可适当调节repl_backlog_buffer避免频繁全量复制。</p>
</blockquote>
<p><em>心跳机制</em><br>主节点：10秒ping一次从节点。<br>从节点：1秒发送一次replconf ack{offset}上报存活和当前复制进度。</p>
<p><em>过期key</em><br>主节点发送DEL KEY指令给从节点。<br>Redis3.2版本后，从节点也会判断过期数据。</p>
<p><em>replication buffer 、repl backlog buffer</em></p>
<ul>
<li>一个主节点只分配一个 repl backlog buffer，满了之后覆盖。</li>
<li>每个从节点分配一个replication buffer，满了之后断开连接并删除该buffer，等待从节点重连后全量复制。</li>
</ul>
<h3 id="主从复制优化"><a href="#主从复制优化" class="headerlink" title="主从复制优化"></a>主从复制优化</h3><p><em>数据不一致</em><br>优化网络环境，集群扩展负载能力，检测并断开网络过于差的节点。</p>
<p><em>减少切换的数据丢失</em></p>
<ul>
<li>异步复制，主节点宕机后恢复：<ul>
<li><code>min-slaves-max-lag x</code>参数，主节点要求至少要有一个从节点与主节点的同步进度小于x秒，否则禁止写数据。</li>
</ul>
</li>
<li>异步复制，主节点宕机后成为从节点 <strong>（脑裂）</strong>：<ul>
<li><code>min-slaves-to-write x</code>参数，主节点至少要有x个从节点，否则禁止写数据。</li>
<li><code>min-slaves-max-lag x</code>参数，主节点要求至少要有一个从节点与主节点的同步进度小于x秒，否则禁止写数据。</li>
</ul>
</li>
</ul>
<blockquote>
<p>都是在宕机是禁止对原节点的写入，通过队列缓存等待恢复或直接写入新节点。</p>
</blockquote>
<p><em>故障自动切换</em><br>哨兵可以完成故障发现、转移、停止。</p>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p><em>哨兵的作用</em></p>
<ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<p><em>哨兵集群构建</em></p>
<ul>
<li>哨兵一般至少为3个，应该为奇数个，<code>quorum</code>一般设置成<code>哨兵数量/2+1</code>。</li>
<li>通过主节点的<code>__sentinel__:hello</code>频道完成哨兵直接的互相发现与连接。</li>
<li>通过每10s一次的消息头部请求，获取主节点和从节点的基本信息，实现对从节点的连接。</li>
</ul>
<p><em>监控</em></p>
<ol>
<li>首个发现哨兵A将其标记为<strong>主观下线</strong>，并询问其他哨兵是否下线。</li>
<li>当哨兵A收集到达到<code>quorum</code>数量的赞成票时，将其标记为<strong>客观下线</strong>。</li>
<li>做出<strong>客观下线判定的哨兵</strong>就是执行故障转移的Leader候选人，Leader候选人需要拿到达到<code>quorum</code>数量且达到<code>哨兵数量/2+1</code>数量的赞成票才能当选（Raft选举算法）。</li>
</ol>
<p><em>Raft选举算法</em><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6998470783831900197">Raft选举算法</a><br>概念：</p>
<ul>
<li>Raft定义了三种角色：<strong>领导者（Leader）</strong>、<strong>跟随者（Follower）</strong> 和 <strong>候选人（Candidate）</strong>。跟随者发现领导者掉线时（收不到leader的心跳）成为候选人。</li>
<li>节点属性：<ul>
<li>任期：相当于版本号，过期的任期请求是无用的</li>
<li>跟随节点ID：即给谁投票或现在跟随谁</li>
</ul>
</li>
<li>超时计时器：<ul>
<li>选举超时时间：发现leader掉线时随机延迟一段时间选举，防止多节点同时候选</li>
<li>投票超时时间：收集投票时间的倒计时，结束时统计票数</li>
<li>竞选等待超时时间：选举失败后且没有其他领导者诞生时，等待一段时间再次选举</li>
</ul>
</li>
</ul>
<p>实现：</p>
<ul>
<li>RPC通讯，只有数据追加请求（心跳）和投票请求（投票）</li>
<li>任期保证了节点不会使用受到的过期消息，并会跟随最新的任期</li>
<li>多领导人同时选举时，每个节点只会对一个版本号的投票请求投出一次票。</li>
</ul>
<blockquote>
<p>更详细内容见分布式算法专题。</p>
</blockquote>
<p><em>故障转移与通知</em></p>
<ol>
<li>挑选新主节点，优先级如下：<ul>
<li>其中，网络状况不好指：与主节点的断连超过10次以上的从节点</li>
</ul>
</li>
</ol>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B.webp" srcset="/img/loading.gif" lazyload><br>2. 对新主发送<code>SLAVEOF no one</code>，对其他节点发送<code>SLAVEOF 新主节点</code>命令<br>3. 通知客户故障转移，通过哨兵的<code>+switch-master</code>频道订阅<br>4. 若后续旧主节点上线，也对其发送<code>SLAVEOF 新主节点</code>命令</p>
<h2 id="集群机制"><a href="#集群机制" class="headerlink" title="集群机制"></a>集群机制</h2><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165951.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><em>hash slot</em><br>redis cluster有16384（2的14次方，bitmap压缩，2kB大小既可以描述）个槽，每个节点管理部分槽。</p>
<p><em>hash tags</em><br>只使用<code>&#123;&#125;</code>的部分计算hash，实现key的定向存放。</p>
<p><em>分配方案</em></p>
<ul>
<li><code>cluster create</code>创建时平均分配</li>
<li><code>cluster meet</code>扩容后手动分配</li>
</ul>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p><em>cluster nodes</em><br>每个节点维护必要的信息：</p>
<ul>
<li>该节点的node id，slots，版本号，连接状态</li>
<li>其他节点的node id，ip，port，slots，master id，版本号，连接状态（最后一次ping，pong的响应时间）</li>
</ul>
<p><em>cluster bus</em><br>node通过<code>10000+port</code>端口与其他节点建立连接。</p>
<p><em>集群拓扑</em><br>redis集群是一个全网拓扑，节点之间两两相连。</p>
<p><em>cluster handshake</em><br>node通过cluster bus监听消息：</p>
<ul>
<li>ping messgae：心跳消息，收到该消息后肯定回复pong消息。<ul>
<li>若是集群成员，则处理ping消息中携带的gossip信息，识别可能的新节点。</li>
<li>若不是集群成员，则丢弃该消息。</li>
</ul>
</li>
<li>meet message：发现消息，收到该消息后将消息源视为集群的一部分</li>
<li>ping message：交换消息，收到集群内其他节点的gossip消息后，将消息中的新节点视为集群的一部分。</li>
</ul>
<p><em>请求重定向</em></p>
<ul>
<li>MOVED重定向：槽不命中时返回MOVED重定向</li>
<li>ACK重定向：槽命中但找不到key，且槽在迁移中，则返回ASK重定向</li>
</ul>
<p><em>SMART客户端</em><br>通过<code>cluster slots</code>命令获取集群的slots信息，自主计算key所在节点并访问，失败时随机访问节点，并更新slots缓存。</p>
<h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p><strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。</strong></p>
<p><em>为什么不使用发布订阅</em><br>消息量太大，消耗带宽。（可以使用bloom过滤器优化）</p>
<p><em>节点结构</em><br>epoch表示版本</p>
<p><em>gossip消息类型</em><br>ping、pong、meet、failover四种基本类型。另外有<strong>广播通知</strong>，不同于gossip，会发送，使用于标记客观下线，故障恢复请求和故障恢复完成。</p>
<p><em>心跳发送</em></p>
<ul>
<li>每次Cron向所有未建立链接的节点发送ping或meet。</li>
<li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li>
<li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li>
<li>收到ping或meet，立即回复pong</li>
</ul>
<p><em>心跳处理</em><br>1.新节点加入：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324172724.png" srcset="/img/loading.gif" lazyload></p>
<p>2.slots、master slave、fail等信息的更新与传播。</p>
<p><em>故障检测</em><br>节点状态：<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p>
<ol>
<li><strong>主节点A</strong>检测到<strong>主节点B</strong>下线，将<strong>疑似下线</strong>该消息保存到其维护的字典中<code>节点B的clusterNode</code>结构的<code>fail_reports</code>链表中，通过gossip协议传播。</li>
<li><strong>主节点C</strong>收到<strong>主节点A</strong>的gossip消息，也对其进行检查，标记和传播。</li>
<li>传播到某<strong>主节点D</strong>时，主节点D判断其已经下线，且发现已经有半数以上<strong>主节点</strong>认为节点B疑似下线，则<strong>主节点D</strong>将其标记为<strong>已下线状态</strong>，并发送<strong>广播通知</strong>。</li>
</ol>
<p><em>故障恢复</em></p>
<ol>
<li>各从节点接受到其主节点客观下线的<strong>广播通知</strong></li>
<li>各从节点将epoch+1并发送failover requsest<strong>广播通知</strong></li>
<li>其他主节点响应并投票，对相同epoch只投一次票</li>
<li>获得超过半数投票后，某从节点当选，并发送failover complete<strong>广播通知</strong></li>
</ol>
<blockquote>
<p>可见集群中，各个主节点充当了哨兵的作用，完成下线判断和投票。</p>
</blockquote>
<h3 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h3><p><em>节点加入集群</em><br>加入集群后节点默认为主节点，但无slot</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster meet ip:port<br>redis-cli --cluster add-node ip:port<br></code></pre></td></tr></table></figure>

<p><em>将节点设置为从节点</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster replicate 4b339ad25b4884c2ff6de8a8ec2bc8766f8faf0b<br></code></pre></td></tr></table></figure>

<p><em>手动迁移</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster reshard 192.168.100.100:8001<br></code></pre></td></tr></table></figure>

<p><em>缩容</em><br>判断下线节点类型，若是主节点，则先将其迁移后将其标记为待下线，最后将下线主节点的从节点指向其他主节点。</p>
<h1 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h1><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。<strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>大量缓存数据同时过期</strong>，或<strong>Redis宕机</strong>，导致对数据库的大量请求并引起一连串的连锁反应。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h4><p>首先过期的主要目的是为了实现数据的更新。</p>
<ul>
<li>大量：<strong>接口限流或熔断</strong> 或 <strong>互斥锁</strong>（一次只允许一个请求构建缓存，防止对数据库的大量请求，记得设置超时时间）。</li>
<li>同时：<strong>设置均匀的过期时间</strong>。</li>
<li>过期：<ul>
<li><strong>后台更新缓存</strong>：不设置过期时间，数据发送变化时后台主动更新缓存，但可能出现内存紧张发生淘汰，解决方法有：<ul>
<li>后台定时检测key是否被淘汰。</li>
<li>淘汰时以消息队列通知后台更新，并暂时返回空。</li>
</ul>
</li>
<li><strong>双key</strong>：使用两个key，主key会过期方便更新，备key则临时应付主键过期时的请求。应用程序发现主key过期则访问备key，并触发主备key的更新（也要配合互斥锁实现更新）。</li>
</ul>
</li>
</ul>
<h4 id="Redis故障宕机"><a href="#Redis故障宕机" class="headerlink" title="Redis故障宕机"></a>Redis故障宕机</h4><ul>
<li><strong>服务熔断</strong>或<strong>请求限流</strong></li>
<li>构建Redis高可用集群（主从）</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>某个热点数据过期</strong>，导致对数据库的大量请求并引起一连串的连锁反应。</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul>
<li>大量：<strong>接口限流或熔断</strong>、互斥锁方案</li>
<li>不设置过期时间，后台异步更新缓存及其过期时间</li>
</ul>
<blockquote>
<p>接口限流和熔断和互斥锁几乎是万金油机制</p>
</blockquote>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致对数据库大量请求。</p>
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul>
<li>限制非法请求，检查请求参数</li>
<li>缓存空值或默认值</li>
<li>布隆过滤器快速判定是否命中缓存</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><em>组成</em><br>位图数组 + N个哈希函数</p>
<p><em>标记步骤</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/86b0046c2622b2c4bda697f9bc0f5b28.webp" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ul>
<p><em>查询步骤</em><br>计算N个hash值并取模，判断这些位是否都为1：</p>
<ul>
<li>全1不代表一定存在</li>
<li>存在0代表一定不存在</li>
</ul>
<p><em>哈希冲突</em><br><strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，redis中一定就不存在这个数据</strong>。</p>
<blockquote>
<p>更详细内容见大数据处理算法专题。</p>
</blockquote>
<h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>并发问题和行为不执行都可能导致缓存的不一致性。</p>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>主动更新在<strong>并发写</strong>时存在不一致问题，如下：</p>
<ul>
<li>先更新数据库，再更新缓存</li>
</ul>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/8febac10b14bed16cb96d1d944cd08da.webp" srcset="/img/loading.gif" lazyload><br><strong>无法保证一致性。</strong></p>
<ul>
<li>先更新缓存，再更新数据库</li>
</ul>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/454a8228a6549176ad7e0484fba3c92b.webp" srcset="/img/loading.gif" lazyload><br><strong>无法保证一致性。</strong></p>
<h3 id="更新删除策略"><a href="#更新删除策略" class="headerlink" title="更新删除策略"></a>更新删除策略</h3><p>更新数据库并删除缓存在<strong>并发读、写</strong>时存在不一致问题，如下：</p>
<h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/6e3db3ba2f829ddc14237f5c7c00e7ce.webp" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>先删除缓存，再更新数据库</li>
</ul>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cc208c2931b4e889d1a58cb655537767.webp" srcset="/img/loading.gif" lazyload><br><strong>无法保证一致性。</strong></p>
<ul>
<li>先更新数据库，再删除缓存</li>
</ul>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/1cc7401143e79383ead96582ac11b615.webp" srcset="/img/loading.gif" lazyload><br><strong>无法保证一致性。</strong><br>虽然仍可能存在不一致性，但发生的概率较低：</p>
<ul>
<li>请求A更新缓存只发送在缓存未命中的情况（可能键恰好失效）。</li>
<li>缓存的写速度远快于数据库写入，请求A的写缓存行为几乎不会发生在请求B完成删除缓存之后。</li>
</ul>
<div class="note note-primary">
            <p><strong>先更新数据库，后删除缓存</strong>是可行的，虽然不能完全保证一致性，但可以接受。</p>
          </div>

<h3 id="缓存代理模式（使用较少）"><a href="#缓存代理模式（使用较少）" class="headerlink" title="缓存代理模式（使用较少）"></a>缓存代理模式（使用较少）</h3><h4 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165034.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="Write-Behind-Caching-Pattern（异步缓存写入）"><a href="#Write-Behind-Caching-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Caching Pattern（异步缓存写入）"></a>Write Behind Caching Pattern（异步缓存写入）</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165054.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><em>主动更新策略</em><br>主动更新策略能更好的保证实时性和命中率，但存在并发问题，解决方案：</p>
<ul>
<li>使用分布式锁，只允许一个请求更新缓存</li>
<li>使用较短的过期时间，即使存在过期数据也快速刷新</li>
</ul>
<p><em>更新删除策略</em></p>
<ul>
<li>延迟双删：更新数据库前<strong>删除缓存</strong>，更新数据库后<strong>睡眠</strong>一小段时间，再执行一次<strong>删除缓存</strong>。</li>
</ul>
<p><em>执行失败</em><br>「先更新数据库， 再删除缓存」行为中，删除缓存可能未得到执行。</p>
<h3 id="解决强一致性问题"><a href="#解决强一致性问题" class="headerlink" title="解决强一致性问题"></a>解决强一致性问题</h3><p>由于更新删除策略中删除缓存可能得不到执行，需要优化流程：<br><em>方案1：队列+重试</em><br>将删除缓存行为加入到消息队列保证其得到执行。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164739.png" srcset="/img/loading.gif" lazyload></p>
<p><em>方案2：队列+重试+非业务代码异步更新</em><br>使用数据库更新日志binlog，中间件（Canal 中间件，阿里巴巴开源）提取key并执行缓存删除，这中间也需要使用消息队列保证执行成功，但可以使用非业务代码完成这个操作。</p>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164801.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2ee2280e9f59b6b4879ebdec6eb0cf52.webp" srcset="/img/loading.gif" lazyload></p>
<h1 id="八、常见"><a href="#八、常见" class="headerlink" title="八、常见"></a>八、常见</h1><p><em>什么是Redis?</em><br>nosql，基于内存，数据格式为键值对，单线程。</p>
<p><em>Redis 和 Memcached 有什么区别？</em><br>都基于内存。但redis可以持久化、集群。</p>
<p><em>为什么Redis可以做缓存？</em><br>高性能、高并发。</p>
<p><em>单线程？</em></p>
<ul>
<li>处理文件事件是主线程单线程完成。</li>
<li>关闭文件、AOF 刷盘、lazyfree等操作都由子线程异步完成。</li>
<li>之前使用单线程，因为CPU不是性能瓶颈；6.0后使用了多线程，因为网络上开始出现瓶颈。</li>
</ul>
<p><em>为什么单线程模型如此快？</em></p>
<ul>
<li>内存</li>
<li>无锁</li>
<li>I&#x2F;O多路复用</li>
</ul>
<p><em>如何实现延迟队列？</em><br>zset记录目标延迟时间，业务循环处理，对比score和当前时间得到range，取出任务。</p>
<p><em>管道？</em><br>管道技术（Pipeline）是客户端提供的一种批处理技术。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.webp" srcset="/img/loading.gif" lazyload></p>
<p><em>分布式锁？</em></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET lock_key unique_value NX PX 10000 <br></code></pre></td></tr></table></figure>
<p>由于异步复制导致<strong>不可靠</strong>，官方提供了RedLock算法：</p>
<ol>
<li>记录开始时间t1。</li>
<li>为所有redis加锁，加锁超时（几十毫秒）则判定失败。</li>
<li>成功加了N&#x2F;2+1的锁时，获取时间t2，判断总耗时。</li>
<li>若总耗时也通过检测，则计算有效时间，若<code>过期时间-耗时&lt;0</code>则释放锁。（此时已经没有时间完成业务了）。</li>
</ol>
<p>即：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功，此时判断这个锁是否还有时间可用，不可用则释放。</p>
<blockquote>
<p>lua脚本可以原子执行</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/" class="category-chain-item">概念整理</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/" class="category-chain-item">数据库DB</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/" class="category-chain-item">Redis</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/" class="category-chain-item">Redis复习</a>
  
  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/">#概念整理</a>
      
        <a href="/tags/Redis/">#Redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis复习</div>
      <div>http://example.com/2023/01/06/概念整理/数据库DB/Redis/Redis复习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/" title="Java第1章（面向对象）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java第1章（面向对象）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/" title="Redis第7章（性能监控）">
                        <span class="hidden-mobile">Redis第7章（性能监控）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.7/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo-api-lime.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/fluid-extention.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
