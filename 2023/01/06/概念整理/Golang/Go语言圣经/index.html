

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#727679">
  <meta name="author" content="Jin">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、基础目录介绍  Go的主要项目文件在其安装目录下，我们称之为GOROOT。 Go的其他库文件在GOPATH中，该文件的作用类似Maven的全局仓库。（在GOPATH时代，其无法作为全局仓库，所以我们的项目也只能放在GOPATH下的src文件夹下。）    pkg 其中pkg下面以下三个文件夹。 XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64,">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言圣经">
<meta property="og:url" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/index.html">
<meta property="og:site_name" content="Jin&#39;s Blog">
<meta property="og:description" content="一、基础目录介绍  Go的主要项目文件在其安装目录下，我们称之为GOROOT。 Go的其他库文件在GOPATH中，该文件的作用类似Maven的全局仓库。（在GOPATH时代，其无法作为全局仓库，所以我们的项目也只能放在GOPATH下的src文件夹下。）    pkg 其中pkg下面以下三个文件夹。 XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/fb0b9eb90e638a7f0a7754691a22349.jpg">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231026212947.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231102224111.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231112234228.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231112235416.png">
<meta property="og:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231221162213.png">
<meta property="article:published_time" content="2023-01-06T11:00:55.000Z">
<meta property="article:modified_time" content="2024-05-17T13:29:07.197Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="概念整理">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/fb0b9eb90e638a7f0a7754691a22349.jpg">
  
  
  
  <title>Go语言圣经 - Jin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong style="color: #fff;">Jin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                归档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Go语言圣经"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-06 19:00" pubdate>
          2023年1月6日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          48k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          404 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Go语言圣经</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><em>目录介绍</em></p>
<ol>
<li>Go的主要项目文件在其安装目录下，我们称之为<code>GOROOT</code>。</li>
<li>Go的其他库文件在<code>GOPATH</code>中，该文件的作用类似Maven的全局仓库。（在<code>GOPATH</code>时代，其无法作为全局仓库，所以我们的项目也只能放在GOPATH下的src文件夹下。）</li>
</ol>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/fb0b9eb90e638a7f0a7754691a22349.jpg" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>pkg 其中pkg下面以下三个文件夹。<ul>
<li>XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。</li>
<li>&#x3D;&#x3D;mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置&#x3D;&#x3D;</li>
<li>sumdb: go get命令缓存下载的checksum数据存放的位置，主要起小版本管理的作用</li>
</ul>
</li>
</ul>
<p><em>GOPATH与GOMOD</em></p>
<ul>
<li>过去（GOPATH）：项目都在GOPATH下src中，外部引入的库（第三方）也在src包路径下才可以使用。</li>
<li>现在（GOMOD）：项目可以在任意地方，项目下的mod起依赖版本管理作用，GOPATH中 pkg&#x2F;mod放第三方库</li>
</ul>
<p><em>语法特性</em><br>不需要分号结尾：Go会自动在符合条件的语句结尾加分号，因此其也有以下使用限制</p>
<ul>
<li>函数的左括号必须跟着函数名，不能单起一行</li>
<li><code>x + y</code>等运算符场景，只能在 + 后换行而不能在 + 前换行。</li>
</ul>
<h1 id="二、程序结构"><a href="#二、程序结构" class="headerlink" title="二、程序结构"></a>二、程序结构</h1><p><em>命名规则</em><br>一个名字必须以一个字母（Unicode字母）或下划线开头。<br>Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。<br>一个函数的声明由一个<code>func</code>、<code>函数名字</code>、<code>参数列表</code>、<code>可选的返回值列表</code>和包含函数定义的<code>函数体</code>组成。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p><em>变量关键字</em><br>变量声明使用<code>const</code>或<code>var</code>，函数体外的变量是<strong>包可见</strong>的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 变量声明方式(“类型”或“=表达式”两个部分可以省略其中的一个,如果初始化表达式被省略，那么将用零值（或nil）初始化该变量。)</span><br><span class="hljs-keyword">var</span> 变量名字 类型 = 表达式<br><span class="hljs-comment">// 多变量类型多值初始化</span><br><span class="hljs-keyword">var</span> i, j, k <span class="hljs-type">int</span>                 <span class="hljs-comment">// int, int, int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;four&quot;</span> <span class="hljs-comment">// bool, float64, string</span><br></code></pre></td></tr></table></figure>
<p><em>简短变量</em><br>在<strong>函数内部</strong>，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 :&#x3D; 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 简短变量声明</span><br>t := <span class="hljs-number">0.0</span><br><span class="hljs-comment">// 变量交换</span><br>i,j = j,i<br></code></pre></td></tr></table></figure>
<blockquote>
<p>请记住“:&#x3D;”是一个变量声明语句，而“&#x3D;”是一个变量赋值操作。</p>
</blockquote>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>一个指针的值是另一个<strong>变量的地址</strong>。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">1</span>  <br>p := &amp;x         <span class="hljs-comment">// p, of type *int, points to x  </span><br>*p = <span class="hljs-number">2</span>          <span class="hljs-comment">// equivalent to x = 2</span><br></code></pre></td></tr></table></figure>
<p>使用<code>&amp;</code>获取<strong>变量的指针</strong>，使用<code>*</code>获取<strong>指针所指的变量的值</strong>。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231026212947.png" srcset="/img/loading.gif" lazyload></p>
<p>另一个创建变量的方法是调用内建的<code>new</code>函数。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后<strong>返回变量地址</strong>，即返回的指针类型为<code>*T</code>。</p>
<blockquote>
<p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p>
</blockquote>
<h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p><em>生命周期</em></p>
<ul>
<li>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。</li>
<li>局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</li>
</ul>
<p><em>可达性算法</em><br>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>
<p><em>内存分配</em><br>编译器会<strong>自动选择在栈上还是在堆上分配局部变量的存储空间</strong>，其取决于变量是否发生了<strong>方法逃逸</strong>。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul>
<li>自增和自减：是一种语句，而不是表达式，因此<code>x = i++</code>之类的表达式是错误的</li>
<li>元组赋值：另一种形式的赋值语句，它允许同时更新多个变量的值：<code>x, y = y, x</code></li>
<li>错误返回：部分函数会用额外的返回值来表达某种错误类型，例如os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok：<code>f, err = os.Open(&quot;foo.txt&quot;)</code></li>
<li>隐式赋值：<code>medals := []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;</code></li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span>    <span class="hljs-comment">// 摄氏温度</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span> <span class="hljs-comment">// 华氏温度</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123; <span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>) &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>类型声明语句一般出现在包一级，因此<strong>如果新创建的类型名字的首字符大写</strong>，则在包外部也可以使用。</li>
<li>即使两种类型有着相同的底层类型，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。</li>
<li>对于每一个类型T，都有一个对应的类型转换操作<code>T(x)</code>，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。</li>
</ul>
<h2 id="包与文件"><a href="#包与文件" class="headerlink" title="包与文件"></a>包与文件</h2><p>在Go语言中，每个源文件都是以包的声明语句开始，用来指明包的名字，一个简单的规则是：<strong>如果一个名字是大写字母开头的，那么该名字是包导出的</strong>（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>
<p><em>可见性</em></p>
<ul>
<li>包间：导入包后，包内的大写成员将通过类似<code>包名.成员名</code>的形式访问。</li>
<li>包内：在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。</li>
</ul>
<p><em>注释</em><br>在package语句前应该标注包的注释，若有多个注释则会自动合并，若注释太复杂则需要单独使用<code>doc.go</code>文件来表达。</p>
<p><em>包的初始化</em></p>
<ul>
<li>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</li>
<li>对于在包级别声明的变量：<ul>
<li>简单的赋值：用表达式初始化</li>
<li>复杂的赋值：用特殊的<code>init</code>初始化函数来简化初始化工作。<strong>每个文件都可以包含多个<code>init</code>初始化函数</strong></li>
</ul>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><em>作用域</em><br>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p>
<p><em>变量作用域</em><br><strong>声明语句</strong>对应的词法域决定了<strong>作用域范围</strong>的大小。如果变量名在内部和外部的块分别声明过，则内部块的声明首先被找到。</p>
<p><em>声明顺序</em><br>在<strong>包级别</strong>，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p>
<p><em>初始化</em><br><code>:=</code>总是会创建新的变量而忽略外部变量，因此若想在函数中对函数外的变量赋值，最好使用 <code>=</code>。</p>
<h1 id="三、基础数据类型"><a href="#三、基础数据类型" class="headerlink" title="三、基础数据类型"></a>三、基础数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p><em>类型特点</em></p>
<ul>
<li>Unicode字符rune类型是和int32等价的类型</li>
<li>同样byte也是uint8类型的等价类型</li>
<li>无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳<strong>指针</strong>。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</li>
</ul>
<p><em>运算符</em><br><code>&amp;^</code> 位清空（AND NOT）</p>
<p><em>运算规则</em><br>一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，且<strong>算术和逻辑运算的二元操作中必须是相同的类型</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> apples <span class="hljs-type">int32</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> oranges <span class="hljs-type">int16</span> = <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> compote <span class="hljs-type">int</span> = apples + oranges <span class="hljs-comment">// compile error</span><br><br><span class="hljs-keyword">var</span> compote = <span class="hljs-type">int</span>(apples) + <span class="hljs-type">int</span>(oranges)<br></code></pre></td></tr></table></figure>

<p><em>进制表达</em><br>任何大小的整数字面值都<strong>可以用以0开始的八进制格式书写</strong>，例如0666；或<strong>用以0x或0X开头的十六进制格式书写</strong>，例如0xdeadbeef。十六进制数字可以用大写或小写字母。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">o := <span class="hljs-number">0666</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o) <span class="hljs-comment">// &quot;438 666 0666&quot;</span><br>x := <span class="hljs-type">int64</span>(<span class="hljs-number">0xdeadbeef</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]x %#[1]x %#[1]X\n&quot;</span>, x)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>请注意fmt的两个使用技巧：<br>通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的<code>[1]</code>副词告诉Printf函数再次使用第一个操作数。第二，%后的<code>#</code>副词告诉Printf在用<code>%o、%x、%X</code>输出时生成0、0x或0X前缀。</p>
</blockquote>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><em>注意点</em><br>通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大。</p>
<p><em>打印</em><br>用<code>Printf</code>函数的<code>%g</code>参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用<code>%e</code>（带指数）或<code>%f</code>的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 打印精度是小数点后3个小数精度和8个字符宽度</span><br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">8</span>; x++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;x = %d e^x = %8.3f \n&quot;</span>, x, math.Exp(<span class="hljs-type">float64</span>(x)))<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>其他特别数</em><br>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> z <span class="hljs-type">float64</span><br>fmt.Println(z, -z, <span class="hljs-number">1</span>/z, <span class="hljs-number">-1</span>/z, z/z) <span class="hljs-comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span><br></code></pre></td></tr></table></figure>

<p>函数<code>math.IsNaN</code>用于测试一个数是否是非数<code>NaN</code>，<code>math.NaN</code>则返回非数对应的值。虽然可以用<code>math.NaN</code>来表示一个非法的结果，但是测试一个结果是否是非数<code>NaN</code>则是充满风险的，因为<code>NaN</code>和任何数都是不相等的（类似MySQL的IS NULL）</p>
<h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go语言提供了两种精度的复数类型：<code>complex64</code>和<code>complex128</code>，分别对应<code>float32</code>和<code>float64</code>两种浮点数精度。内置的complex函数用于构建复数，内建的<code>real</code>和<code>imag</code>函数分别返回复数的实部和虚部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1+2i</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 3+4i</span><br>fmt.Println(<span class="hljs-built_in">real</span>(x*y))           <span class="hljs-comment">// &quot;-5&quot;</span><br>fmt.Println(<span class="hljs-built_in">imag</span>(x*y))           <span class="hljs-comment">// &quot;10&quot;</span><br><span class="hljs-comment">// 也可以用自然方式书写</span><br>x := <span class="hljs-number">1</span> + <span class="hljs-number">2i</span><br></code></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><em>赋值</em><br>一个字符串是一个<strong>不可改变</strong>的字节序列，默认UTF8，相关操作如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello, world&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s))     <span class="hljs-comment">// 返回字符串的 字节数量</span><br>fmt.Println(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">7</span>]) <span class="hljs-comment">// 返回对应所有下的字节</span><br>fmt.Println(s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]) <span class="hljs-comment">// 基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串（与原字符串共享底层内存，且不可变）。</span><br></code></pre></td></tr></table></figure>
<p>多行字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">`line1</span><br><span class="hljs-string">line2</span><br><span class="hljs-string">line3</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure>

<p><em>Unicode</em><br>Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。由于Go语言字符串使用UTF8表示，因此不能根据字符串长度判断字符的数量。<br>Go提供了utf8包来实现Unicode的解析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;你好，世界&quot;</span>  <br>fmt.Println(utf8.RuneCountInString(s)) <span class="hljs-comment">// &quot;5&quot; s的字符数量  </span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); &#123;  <br>    r, size := utf8.DecodeRuneInString(s[i:]) <span class="hljs-comment">// 从索引i开始解析一个字符，r为字符对应的utf8值，size为字符对应的字节数  </span><br>    fmt.Printf(<span class="hljs-string">&quot;%d\t%c\n&quot;</span>, i, r)              <span class="hljs-comment">// %d表示整数索引i的值，%c将字符utf8解析为字符表达  </span><br>    i += size  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了方便的遍历字符，可以使用range，其隐式的处理了字符解析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;Hello, 世界&quot;</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Java中，JDK8的String的底层为<code>char[]</code>数组，采用了UTF16编码，JDK9的String底层为<code>buye[]</code>数组，默认采用UTF8编码。<br>由于一个char无法表达<code>non-BMP</code>字符（需要32位），因此一个char并不一定能表达一个字符。</p>
</blockquote>
<p><em>rune</em><br>UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune数组可能更方便，因为rune大小一致，支持数组索引和方便切割。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;你好，世界&quot;</span>  <br>runes := []<span class="hljs-type">rune</span>(s)  <span class="hljs-comment">// string -&gt; []rune</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> runes &#123;  <br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(r)) <span class="hljs-comment">// rune 转 string打印</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果对应码点的字符是无效的，则用<code>\uFFFD</code>无效字符作为替换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">1234567</span>)) <span class="hljs-comment">// &quot;?&quot;</span><br></code></pre></td></tr></table></figure>

<p><em>字符串和Byte切片</em><br>bytes、strings、strconv和unicode包提供了很多基础的API：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// strings</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(a []<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// bytes</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(b, subslice []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> [][]<span class="hljs-type">byte</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(s [][]<span class="hljs-type">byte</span>, sep []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span><br></code></pre></td></tr></table></figure>

<p>bytes包还提供了Buffer类型（类似StringBuffer）用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intsToString</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> buf bytes.Buffer<br>    buf.WriteByte(<span class="hljs-string">&#x27;[&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>            buf.WriteString(<span class="hljs-string">&quot;, &quot;</span>)<br>        &#125;<br>        fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, v)<br>    &#125;<br>    buf.WriteByte(<span class="hljs-string">&#x27;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(intsToString([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)) <span class="hljs-comment">// &quot;[1, 2, 3]&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><em>定义</em><br>常量表达式的值在编译期计算，而不是在运行期。常量间的所有算术运算、逻辑运算和比较运算的结果也是常量。</p>
<p>每种常量的潜在类型都是基础类型：boolean、string或数字。一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。</p>
<p><em>声明</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 普通声明</span><br><span class="hljs-keyword">const</span> PI=<span class="hljs-number">3.14</span><br><span class="hljs-comment">// 批量声明</span><br><span class="hljs-keyword">const</span> (<br>    e  = <span class="hljs-number">2.71828182845904523536028747135266249775724709369995957496696763</span><br>    pi = <span class="hljs-number">3.14159265358979323846264338327950288419716939937510582097494459</span><br>)<br><span class="hljs-comment">// 类型常量 time.Duration类型的常量</span><br><span class="hljs-keyword">const</span> noDelay time.Duration = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p><em>初始化省略</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-number">1</span><br>    b<br>    c = <span class="hljs-number">2</span><br>    d<br>)<br>fmt.Println(a, b, c, d) <span class="hljs-comment">// &quot;1 1 2 2&quot;</span><br></code></pre></td></tr></table></figure>

<p><em>iota 常量生成器</em><br>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，<strong>在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一</strong>，如下例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>    Sunday Weekday = <span class="hljs-literal">iota</span><br>    Monday<br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br></code></pre></td></tr></table></figure>

<p><em>无类型常量</em><br>go中有部分常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型<strong>更高精度的算术运算</strong>；你可以认为至少有256bit的运算精度。有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>
<ul>
<li>通过<strong>延迟明确常量的具体类型</strong>，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如Pi常量可以被赋予各类型变量</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">float32</span> = math.Pi<br><span class="hljs-keyword">var</span> y <span class="hljs-type">float64</span> = math.Pi<br><span class="hljs-keyword">var</span> z <span class="hljs-type">complex128</span> = math.Pi<br></code></pre></td></tr></table></figure>

<ul>
<li>除法运算符&#x2F;会<strong>根据操作数的类型生成对应类型的结果</strong>。因此，不同写法的常量除法表达式可能对应不同的结果：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">212</span><br>fmt.Println((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)     <span class="hljs-comment">// &quot;100&quot;; (f - 32) * 5 is a float64</span><br>fmt.Println(<span class="hljs-number">5</span> / <span class="hljs-number">9</span> * (f - <span class="hljs-number">32</span>))     <span class="hljs-comment">// &quot;0&quot;;   5/9 is an untyped integer, 0</span><br></code></pre></td></tr></table></figure>

<ul>
<li>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被<strong>隐式转换</strong>为对应的类型，如果转换合法的话：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">3</span> + <span class="hljs-number">0i</span> <span class="hljs-comment">// untyped complex -&gt; float64</span><br>f = <span class="hljs-number">2</span>                  <span class="hljs-comment">// untyped integer -&gt; float64</span><br>f = <span class="hljs-number">1e123</span>              <span class="hljs-comment">// untyped floating-point -&gt; float64</span><br>f = <span class="hljs-string">&#x27;a&#x27;</span>                <span class="hljs-comment">// untyped rune -&gt; float64</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。</p>
</blockquote>
<h1 id="四、复合数据类型"><a href="#四、复合数据类型" class="headerlink" title="四、复合数据类型"></a>四、复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><em>介绍</em><br>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。<br><strong>因为数组的长度是固定的，因此在Go语言中很少直接使用数组</strong>。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活。</p>
<p><em>基本操作</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> <span class="hljs-comment">//声明数组</span><br><span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(a) <span class="hljs-comment">//获取数组长度</span><br><br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-keyword">var</span> q [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// r[2] = 0</span><br><span class="hljs-comment">//省略长度，长度根据初始化的值来计算</span><br>q := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// “...”处值会根据初始化值数量自动填充</span><br><br><span class="hljs-comment">// 指定索引的初始化</span><br>symbol := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;€&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;￡&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;￥&quot;</span>&#125; <span class="hljs-comment">// 初始化顺序不受限制</span><br>fmt.Println(RMB, symbol[RMB]) <span class="hljs-comment">// &quot;3 ￥&quot;</span><br><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, v)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><em>数组声明注意事项</em><br>在 Go 语言中，数组的长度必须是一个常量。这意味着，在定义数组时，必须明确指定数组的长度，且长度必须是在编译时就能确定的常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 合法</span><br><span class="hljs-keyword">const</span> size = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> a [size]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 非法</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a [n]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 如果需要动态指定数组长度，需要使用make函数，这里生产的是一个切片</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br></code></pre></td></tr></table></figure>

<p><em>数组作为函数参数</em><br>当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以<strong>函数参数变量接收的是一个复制的副本</strong>，并不是原始调用的变量。因为函数参数传递的机制导致<strong>传递大的数组类型将是低效</strong>的，并且<strong>对数组参数的任何的修改都是发生在复制的数组</strong>上，并不能直接修改调用时原始的数组变量。<br>为了解决这个问题，可以使用指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(ptr *[32]<span class="hljs-type">byte</span>)</span></span> &#123;<br>    *ptr = [<span class="hljs-number">32</span>]<span class="hljs-type">byte</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p><em>切片概念</em></p>
<ul>
<li>一个slice由三个部分构成：指针（底层数组）、长度和容量。</li>
<li>切片是长度没有限制的数组，类似Java中的ArrayList。</li>
<li>切片的声明与数组类似，<strong>区别在于不会声明长度，也不会使用省略号代替</strong>。</li>
<li>切片之间可以共享底层数组<ul>
<li>可以基于数组创建切片<code>s=a[1:2]</code>，切片的左右指针应该在原数组的范围内。</li>
<li>可以基于切片创建切片<code>s2=s1[1:100]</code>，新切片的范围可以比原切片大，但是新切片的左右指针仍应该在底层数组的范围内。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>字符串</code>和<code>[]byte</code>类型也可以做切面</p>
</blockquote>
<p><em>切片特性</em></p>
<ul>
<li>切片不可以使用<code>==</code>判断所有元素是否全等（只有<code>[]byte</code>可以通过<code>bytes.Equal()</code>函数判断）</li>
<li>切片变量可以与 <code>nil</code>比较：<code>summer == nil</code></li>
</ul>
<p><em>切片零值</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建nil切片</span><br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span>    <span class="hljs-comment">// len(s) == 0, s == nil，零值切片</span><br>s = <span class="hljs-literal">nil</span>        <span class="hljs-comment">// len(s) == 0, s == nil，零值切片</span><br>s = []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// len(s) == 0, s == nil，零值切片</span><br><br><span class="hljs-comment">// 0值切片</span><br>s = []<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-comment">// len(s) == 0, s != nil，长度为0的切片</span><br></code></pre></td></tr></table></figure>
<p>除了文档已经明确说明的地方，<strong>所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice</strong>。</p>
<p><em>make函数</em><br>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>)<br><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>) <span class="hljs-comment">// same as make([]T, cap)[:len]</span><br></code></pre></td></tr></table></figure>

<p><em>append函数</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// append可以修改slice[len]的值，如果len == cap，则会创建一个新的切片</span><br>stack = <span class="hljs-built_in">append</span>(stack, v) <span class="hljs-comment">// push v</span><br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span><br><span class="hljs-comment">// 删除slice中间元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-built_in">copy</span>(slice[i:], slice[i+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-comment">// 如果不需要保持原顺序，可以用最后一个元素替换原元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    slice[i] = slice[<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>切片作为函数参数</em><br>函数参数的复制机制是值拷贝，而如<strong>切片&#x2F;哈希</strong>这样的高级数据结构所持有的是底层数据结构的指针，拷贝时也拷贝的是指针，即底层数据结构的地址，因此<strong>使用这些数据类型作为函数参数时不需要使用指针即可实现内存共享</strong>。<br>结构体也是如此，如果结构体的某字段类型是某个数据类型的指针，再函数传递过程中发生复制时，复制的也是该字段的地址，从而实现对原结构体变量的修改。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><em>map创建</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个map</span><br>age := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>) <span class="hljs-comment">// mapping from strings to ints</span><br><span class="hljs-comment">// 创建一个</span><br>age := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;alice&quot;</span>:   <span class="hljs-number">31</span>,<br>    <span class="hljs-string">&quot;charlie&quot;</span>: <span class="hljs-number">34</span>,<br>&#125;<br><span class="hljs-comment">// 创建空的map的表达式是</span><br>age := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p><em>map使用</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// put</span><br>ages[<span class="hljs-string">&quot;alice&quot;</span>] = <span class="hljs-number">32</span><br><span class="hljs-comment">// remove，安全操作，即使ages中不存在alice也不会报错</span><br><span class="hljs-built_in">delete</span>(ages, <span class="hljs-string">&quot;alice&quot;</span>) <span class="hljs-comment">// remove element ages[&quot;alice&quot;]</span><br><span class="hljs-comment">// get，安全操作，ages中不包含bob时默认返回零值</span><br>ages[<span class="hljs-string">&quot;bob&quot;</span>] = ages[<span class="hljs-string">&quot;bob&quot;</span>]+<span class="hljs-number">1</span><br><span class="hljs-comment">// += 和 ++ 也可以用于map</span><br>ages[<span class="hljs-string">&quot;bob&quot;</span>]++<br><br><span class="hljs-comment">// 遍历，安全操作，map为nil时不遍历</span><br><span class="hljs-keyword">for</span> name, age := <span class="hljs-keyword">range</span> ages &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%s\t%d\n&quot;</span>, name, age)<br>&#125;<br><br><span class="hljs-comment">// 判断是否存在key</span><br>age,ok := ages[<span class="hljs-string">&quot;bob&quot;</span>] <span class="hljs-comment">// 返回的ok是一个布尔值，返回元素是否真正存在</span><br></code></pre></td></tr></table></figure>

<p><em>map注意点</em></p>
<ul>
<li><strong>禁止对map元素取址</strong>，因为map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</li>
<li>查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是<strong>向一个nil值的map存入元素将导致一个panic异常</strong>（但可以向一个nil值的slice存入元素）</li>
</ul>
<p><em>set数据结构</em><br>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能：<code>map[string]bool</code>。</p>
<p><em>key值的要求</em><br>由于Go不像Java使用HashCode判断元素所属桶，也不存在equals的对象通用方法，一般需要手动为对象实现一个ID函数<code>k</code>作为key，确保只有<code>x</code>和<code>y</code>相等时<code>k(x) == k(y)</code>才成立。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><em>结构体操作</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明结构体</span><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    ID        <span class="hljs-type">int</span><br>    Name      <span class="hljs-type">string</span><br>    Address   <span class="hljs-type">string</span><br>    DoB       time.Time<br>    Position  <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 声明结构体变量</span><br><span class="hljs-keyword">var</span> employee Eployee<br><span class="hljs-comment">// 操作属性</span><br>employee.Salary = <span class="hljs-number">5000</span><br><span class="hljs-comment">// 通过指针操作属性，也可以简化（语法糖）</span><br><span class="hljs-keyword">var</span> prt = &amp;employee<br>*prt.Salary = <span class="hljs-number">6000</span> &lt;==&gt; prt.Salary = <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果要在函数内部修改结构体成员的话，用<strong>指针传入</strong>是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</li>
<li>函数往往<strong>返回结构体变量的指针</strong>而不是结构体变量，因为返回结构体变量时会对原变量进行复制并返回，导致性能开销。</li>
</ul>
</blockquote>
<p><em>结构体特点</em></p>
<ul>
<li>结构体成员中，以大写字母开头的就是导出的</li>
<li>命名为<code>S</code>的结构体不可以拥有类型为<code>S</code>的成员（聚合的值不能包含它自身），但可以拥有类型为<code>*S</code>的成员。</li>
<li>结构体的零值是每个成员都是零值</li>
</ul>
<p><em>结构体创建</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">int</span> &#125;<br><span class="hljs-comment">// 按照顺序填入成员的初始值</span><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-comment">// 指定成员值</span><br>p := Point&#123;X:<span class="hljs-number">1</span>,Y:<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>无论是顺序还是指定初始化成员，都不可能初始化非导出的成员</p>
</blockquote>
<p><em>结构体比较</em><br>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用<code>==</code>或<code>!=</code>运算符进行比较。相等比较运算符&#x3D;&#x3D;将比较两个结构体的每个成员。</p>
<p><em>结构体嵌入和匿名成员</em></p>
<ul>
<li>匿名成员：只声明一个成员对应的数据类型而不指名成员的名字，匿名成员的数据类型必须是<strong>命名的类型</strong>或<strong>指向一个命名的类型的指针</strong>。</li>
<li>结构体嵌入：对于匿名成员，可以认为其嵌入了结构体，可以<strong>直接访问叶子属性</strong>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>    Point <span class="hljs-comment">// 匿名成员</span><br>    Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>    Circle <span class="hljs-comment">// 匿名成员</span><br>    Spokes <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> w Wheel<br>w.X = <span class="hljs-number">8</span>            <span class="hljs-comment">// equivalent to w.Circle.Point.X = 8</span><br></code></pre></td></tr></table></figure>

<p>但是，结构体创建过程无法使用匿名成员的语法，只能使用以下语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">w = Wheel&#123;Circle&#123;Point&#123;<span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">20</span>&#125;<br><br>w = Wheel&#123;<br>    Circle: Circle&#123;<br>        Point:  Point&#123;X: <span class="hljs-number">8</span>, Y: <span class="hljs-number">8</span>&#125;,<br>        Radius: <span class="hljs-number">5</span>,<br>    &#125;,<br>    Spokes: <span class="hljs-number">20</span>, <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>匿名成员拥有隐式的名字（就是<strong>类型名</strong>），两个相同类型的匿名成员也会导致歧义和成员冲突。且匿名成员的可见性与该成员类的可见性一致（因为匿名成员的名字与成员类的名字完全一样，大小写也一样）</p>
          </div>

<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p><em>json包基本使用</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// other =&gt; json，返回一个[]byte，没有缩进</span><br>data, err := json.Marshal(movies)<br><span class="hljs-comment">// other =&gt; json，返回一个[]byte，有缩进，两个参数分别代表每个json的前缀和每层的缩进</span><br>data, err := json.MarshalIndent(movies, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;    &quot;</span>)<br><span class="hljs-comment">// 结构体中配置json后的属性名</span><br>Year  <span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;released&quot;`</span><br>Color <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;color,omitempty&quot;`</span><br><br><span class="hljs-comment">// json =&gt; other</span><br><span class="hljs-keyword">type</span> titles []<span class="hljs-keyword">struct</span>&#123; Title <span class="hljs-type">string</span> &#125; <span class="hljs-comment">// 声明了一个结构体切片，且声明了该结构体的成员</span><br><span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;titles); <span class="hljs-comment">// 将data反序列化到titles数组地址中</span><br></code></pre></td></tr></table></figure>

<p><em>流式解码器</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从resp.Body流解码JSON数据到result地址中</span><br>json.NewDecoder(resp.Body).Decode(&amp;result);<br></code></pre></td></tr></table></figure>

<h2 id="文本和HTML模板"><a href="#文本和HTML模板" class="headerlink" title="文本和HTML模板"></a>文本和HTML模板</h2><p><em>text&#x2F;template</em><br>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。action会触发一些其他行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义模板</span><br><span class="hljs-keyword">const</span> templ = <span class="hljs-string">`&#123;&#123;.TotalCount&#125;&#125; issues:</span><br><span class="hljs-string">	&#123;&#123;range .Items&#125;&#125;----------------------------------------</span><br><span class="hljs-string">	Number: &#123;&#123;.Number&#125;&#125;</span><br><span class="hljs-string">	User:   &#123;&#123;.User.Login&#125;&#125;</span><br><span class="hljs-string">	Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;</span><br><span class="hljs-string">	Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days</span><br><span class="hljs-string">	&#123;&#123;end&#125;&#125;`</span><br><br><span class="hljs-comment">// 生成模板对象</span><br>report, err := template.New(<span class="hljs-string">&quot;report&quot;</span>). <span class="hljs-comment">// 创建并返回一个模板report  </span><br>                Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;). <span class="hljs-comment">// 为模板注入函数</span><br>                Parse(templ)                                 <span class="hljs-comment">// 分析目标模板</span><br><span class="hljs-comment">// 执行模板</span><br>report.Execute(os.Stdout, result) <span class="hljs-comment">//指定输出，和输入</span><br></code></pre></td></tr></table></figure>

<p><em>html&#x2F;template</em><br><code>html/template</code>模板包使用和<code>text/template</code>包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以<strong>避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题</strong>。这个特性还可以避免一些长期存在的安全问题，比如通过生成<strong>HTML注入攻击</strong>，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><em>new函数</em><br>在 golang 中 new 是另外一种创建变量的方式。通过 new(T) 可以创建 T 类型的变量(这里 T 表示类型)，初始值为 T 类型的零值，返回值为其地址(地址类型是 <code>*T</code>)。使用 new 创建一个变量和先通过 var 初始化一个变量，然后对这个变量取地址没什么不同，唯一的区别是，<strong>通过 new 函数不需要引入变量名称，所以使用上更加简洁、便利</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://books.studygolang.com/gopl-zh/ch5/ch5-01.html">https://books.studygolang.com/gopl-zh/ch5/ch5-01.html</a></p>
<h1 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p><em>声明</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(parameter-list)</span></span> (result-list) &#123;<br>    body<br>&#125;<br><span class="hljs-comment">// 相同类型的形参可以一起声明，如x,y</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hypot</span><span class="hljs-params">(x,y <span class="hljs-type">float64</span>)</span></span> &#123;<br>	<span class="hljs-keyword">return</span> math.Sqrt(x*x + y*y)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>函数的签名</em><br>函数的类型被称为函数的签名。如果两个函数<strong>形式参数列表</strong>和<strong>返回值列表</strong>中的<strong>变量类型一一对应</strong>，那么这两个函数被认为有相同的类型或签名。<br>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此<strong>形参和返回值的变量名对于函数调用者而言没有意义</strong>。<br><strong>注意：Go语言不支持函数的重载，即不允许同时声明具有相同名称但参数不同的函数，即使他们的签名并不同，其目的是为了让Go保持足够的简单。</strong></p>
<div class="note note-primary">
            <p>实参通过<strong>值的方式传递</strong>，因此<strong>函数的形参是实参的拷贝</strong>。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如<strong>指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改</strong>。</p>
          </div>

<blockquote>
<p>个人理解：变量名是地址的别名，用于值类型；指针是地址的直接引用，属于引用类型。</p>
</blockquote>
<p><em>多返回值</em><br>在Go中，一个函数可以返回多个值，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 指定多个返回值的类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiReturn</span><span class="hljs-params">()</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;error message!&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 也可以连续声明，并赋予返回值变量名。且可以在函数中使用返回值变量（默认0值）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Size</span><span class="hljs-params">(rect image.Rectangle)</span></span> (width, height <span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiReturn</span><span class="hljs-params">()</span></span> (i, j <span class="hljs-type">int</span>) &#123;<br>	i = <span class="hljs-number">1</span> <span class="hljs-comment">// 可以直接为返回值变量赋值</span><br>	j = <span class="hljs-number">2</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-comment">// equals return i,j</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>准确的变量名可以传达函数返回值的含义，但也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息。</p>
</blockquote>
<h2 id="函数错误"><a href="#函数错误" class="headerlink" title="函数错误"></a>函数错误</h2><p><em>错误定义</em></p>
<ul>
<li>大部分函数无法确保成功执行，因为错误的原因超出了程序员的控制（如IO错误）。</li>
<li>对于将运行失败看作预期结果的函数，会返回一个额外的返回值来传递错误（bool 或 error）</li>
<li>error是一个接口，该类型可以为nil 和 non-nil，当其为nil时代表有错误发生。</li>
</ul>
<blockquote>
<p>Go语言认为错误不同于异常，<strong>错误是预期内的而异常是预期外的</strong>。该设计原因是对于某个应该被处理的错误，将错误以异常的形式抛出会混乱对错误的描述，导致大量的无用信息。</p>
</blockquote>
<p><em>错误处理策略</em></p>
<ol>
<li>直接返回原错误或封装一次后返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url,err) <span class="hljs-comment">// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>重试策略</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// eg:</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WaitForServer</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">const</span> timeout = <span class="hljs-number">1</span> * time.Minute<br>    deadline := time.Now().Add(timeout)<br>    <span class="hljs-keyword">for</span> tries := <span class="hljs-number">0</span>; time.Now().Before(deadline); tries++ &#123;<br>        _, err := http.Head(url)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// success</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;server not responding (%s);retrying…&quot;</span>, err)<br>        time.Sleep(time.Second &lt;&lt; <span class="hljs-type">uint</span>(tries)) <span class="hljs-comment">// exponential back-off</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;server %s failed to respond after %s&quot;</span>, url, timeout)<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>输出错误信息并结束程序</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// eg：</span><br><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err)<br>    os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatalf(<span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err) <span class="hljs-comment">// 打印后退出</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p>
</blockquote>
<ol start="4">
<li>只记录错误信息，程序继续执行</li>
<li>直接忽略掉错误</li>
</ol>
<h2 id="函数值与匿名函数"><a href="#函数值与匿名函数" class="headerlink" title="函数值与匿名函数"></a>函数值与匿名函数</h2><p><em>函数值定义</em></p>
<ul>
<li>可以使用类似变量的方式声明、使用函数；</li>
<li>函数值属于引用变量，零值为nil；</li>
<li>函数值之间不能比较，也不能作为map的key。<strong>因为函数是有状态</strong>的，参见匿名函数的例子，其涉及到闭包技术。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个函数值</span><br>f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> n * n&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><em>匿名函数</em><br>函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。函数字面量允许我们在使用函数时，再定义它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squares</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        x++<br>        <span class="hljs-keyword">return</span> x * x<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := squares() <span class="hljs-comment">// f为一个匿名函数</span><br>    fmt.Println(f()) <span class="hljs-comment">// &quot;1&quot;</span><br>    fmt.Println(f()) <span class="hljs-comment">// &quot;4&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 匿名函数递归使用前必须声明为一个变量，否则无法递归使用（因为生成函数值时变量还不存在）</span><br>visitAll := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span> &#123;<br>    visitAll(m[item]) <span class="hljs-comment">// compile error: undefined: visitAll</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>迭代变量陷阱</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码要求先创建若干文件，并将删除该文件的函数存储，随后统一执行</span><br><span class="hljs-comment">// 下面代码是正确的，其正确的使用临时变量代替循环变量传入函数值</span><br><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> tempDirs() &#123;<br>    dir := dir <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> necessary!</span><br>    os.MkdirAll(dir, <span class="hljs-number">0755</span>) <span class="hljs-comment">// creates parent directories too</span><br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dir)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">for</span> _, rmdir := <span class="hljs-keyword">range</span> rmdirs &#123;<br>    rmdir() <span class="hljs-comment">// clean up</span><br>&#125;<br><br><span class="hljs-comment">// 下面代码是错误的，因为循环变量i也会被传入函数值</span><br><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>dirs := tempDirs()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dirs); i++ &#123;<br>    os.MkdirAll(dirs[i], <span class="hljs-number">0755</span>) <span class="hljs-comment">// OK</span><br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dirs[i]) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码中<code>dir := dir</code>是必要的，因为：</p>
<ul>
<li>匿名函数的函数值记录的是循环变量的内存地址，而不是其创建时刻的值。</li>
<li>循环中循环变量共享相同的循环内存地址。</li>
</ul>
<h2 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h2><p><em>可变参数函数</em><br>参数数量可变的函数称为可变参数函数。在声明可变参数函数时，需要在参数列表的<strong>最后一个参数类型</strong>之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>        total += val<br>    &#125;<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在函数体中，vals被看作是类型为<code>[] int</code>的切片，但可变参数函数和以切片作为参数的函数不同：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">([]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// &quot;func(...int)&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, g) <span class="hljs-comment">// &quot;func([]int)&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h2><p><em>deferred定义</em><br>在调用普通函数或方法前加上<strong>关键字defer</strong>，就完成了defer所需要的语法，相当于<code>finally</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">title</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    resp, err := http.Get(url)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> resp.Body.Close()<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。<strong>通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放</strong>。释放资源的defer应该直接跟在请求资源的语句后。</p>
<p><em>其他特点</em></p>
<ul>
<li>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。</li>
<li>不要忘记defer语句后的<code>()</code>，其保证指定的函数在方法退出时执行，并且其可以使用返回值，并<strong>修改返回值</strong>（无论是基本类型还是引用类型）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">double</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Printf(<span class="hljs-string">&quot;double(%d) = %d\n&quot;</span>, x,result) &#125;()<br>    <span class="hljs-keyword">return</span> x + x<br>&#125;<br>_ = double(<span class="hljs-number">4</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> (a <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// return 2</span><br>    a = <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">// last execute</span><br>       a = <span class="hljs-number">2</span>  <br>    &#125;()  <br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <br>       a = <span class="hljs-number">3</span>  <br>    &#125;()  <br>    <span class="hljs-keyword">return</span> a  <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>同一函数中的多个defer语句的函数会<strong>由下至上</strong>的执行。</li>
<li>循环体中的defer语句只会在所有循环执行完毕后执行，如果需要在循环内执行，需要将循环的语句提取成一个单独的函数。</li>
</ul>
<h2 id="Panic与Recover"><a href="#Panic与Recover" class="headerlink" title="Panic与Recover"></a>Panic与Recover</h2><p><em>Panic异常</em><br>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。此外，直接调用内置的panic函数也会引发panic异常；<br><em>Panic异常后</em><br>一般而言，当panic异常发生时，程序会<strong>中断运行</strong>，并立即执行在该goroutine中被延迟的函数（<strong>defer 机制</strong>）。随后，程序崩溃并输出日志信息。日志信息包括panic value（错误信息）和函数调用的堆栈跟踪信息。</p>
<p><em>Panic的使用场景</em><br>由于panic会引起程序的崩溃，因此panic一般用于<strong>严重错误</strong>，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。<br>在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I&#x2F;O操作都应该被优雅的处理，<strong>最好的处理方式，就是使用Go的错误机制</strong>。</p>
<p><em>JAVA与GO的异常对比</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231102224111.png" srcset="/img/loading.gif" lazyload></p>
<p><em>Recovery捕获Panic</em><br>如果在<code>deferred函数</code>中调用了<code>内置函数recover</code>，并且<code>定义该defer语句的函数</code>发生了panic异常，recover会使程序从panic中恢复，并返回<code>panic value</code>，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> (s *Syntax, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 从recover()获取异常信息</span><br>            err = fmt.Errorf(<span class="hljs-string">&quot;internal error: %v&quot;</span>, p) <span class="hljs-comment">// 这里将其以error的方式返回，实现了panic捕获</span><br>        &#125;<br>    &#125;()<br>    <span class="hljs-comment">// ...parser...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>不应该试图去恢复其他包引起的panic，也不应该恢复所有的panic，安全的做法是有选择性的recover，即只恢复应该被恢复的panic异常，</p>
<blockquote>
<p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。</p>
</blockquote>
<h1 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h1><h2 id="方法基础"><a href="#方法基础" class="headerlink" title="方法基础"></a>方法基础</h2><p><em>方法定义</em><br>在函数声明时，在其<strong>函数名之前放上一个变量</strong>，即是一个方法，当于<strong>为这种类型定义了一个独占的函数</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><span class="hljs-comment">// traditional function</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span></span> <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><span class="hljs-comment">// same thing, but as a method of the Point type</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(Distance(p, q)) <span class="hljs-comment">// &quot;5&quot;, function call，调用的是包级别函数</span><br>fmt.Println(p.Distance(q))  <span class="hljs-comment">// &quot;5&quot;, method call，调用的是结构体的方法</span><br></code></pre></td></tr></table></figure>

<p><em>使用规则</em></p>
<ul>
<li>Go语言中，能够给任意类型定义方法，包括切面、基础数据类型等；</li>
<li>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名。</li>
</ul>
<h2 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h2><p><em>基于指针对象的方法</em><br>如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>    p.X *= factor<br>    p.Y *= factor<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该方法的名字是：<code>(*Point).ScaleBy</code>，因为如果没有括号的话可能被理解为<code>*(Point.ScaleBy)</code>。</p>
<p><em>使用规则</em></p>
<ul>
<li>在现实的程序里，一般会<strong>约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器</strong>，即使是那些并不需要这个指针接收器的函数。</li>
<li>在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> P *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(P)</span></span> f() &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// compile error: invalid receiver type</span><br></code></pre></td></tr></table></figure>
<ul>
<li>Go语法糖可以避免我们每次调用指针对象方法时先将对象转指针，但这只是方法调用时的语法糖，仍需要注意声明方法时接收器是指针类型与非指针类型两者的区别（涉及接收器是否拷贝以及一些封装调用）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">r := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-comment">// 天然写法与等效写法</span><br>(&amp;r).ScaleBy(<span class="hljs-number">2</span>)  &lt;==&gt; r.ScaleBy(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 但对于其他封装好的调用，无法通过原类型使用指针类型方法：</span><br>fmt.Println(x) <span class="hljs-comment">// 调用x方法的String而不是*x方法的String</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Nil 也可以作为指针类型被合法接受。</li>
</ul>
<h2 id="内嵌结构体方法"><a href="#内嵌结构体方法" class="headerlink" title="内嵌结构体方法"></a>内嵌结构体方法</h2><p><em>内嵌结构体方法</em><br>类似于内嵌结构体中外部结构体可以直接访问内部结构体的成员，外部结构体也可以直接调用内部结构体的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 内部结构体</span><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><span class="hljs-comment">// 内部结构体方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> xaddY() <span class="hljs-type">float64</span> &#123;<br>	<span class="hljs-keyword">return</span> p.X + p.Y<br>&#125;<br><span class="hljs-comment">// 外部结构体</span><br><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br>	Point<br>	Color color.RGBA<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;<br>	cp := ColoredPoint&#123;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, red&#125;<br>	<span class="hljs-comment">// !!可以直接调用内部结构体函数</span><br>	cp.xaddY()<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从实现的角度来看，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法。</p>
<blockquote>
<p>内嵌结构体方法的调用很像JAVA中子类调用父类方法一样，但这是错误的理解。通过为子结构体定义方法能更好的解耦一个结构体的各部分，而内嵌结构体方法则是一种为了方便调用子结构体方法的语法糖。</p>
</blockquote>
<p><em>内嵌结构体方法注意事项</em></p>
<ul>
<li>子结构体的方法访问不到父结构体的字段。</li>
<li>当编译器解析一个选择器到方法时，它会首先去找直接定义在这个类型里的方法，然后再找的内嵌字段们引入的方法，调用的优先级是层序迭代遍历，如果同一层中有两个同名方法，即存在二义性，此时编译器会报错，即：<ul>
<li>如果类型和内嵌字段都引入了相同的方法，会优先调用类型自身的方法</li>
<li>如果同级的若干个内嵌字段都引入了相同的方法，并试图使用匿名方式调用，则编译器会报错。</li>
</ul>
</li>
</ul>
<p><em>方法值</em><br>方法可以被从对象中取出调用，即<strong>方法值</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义p,q结构体变量</span><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-comment">// 从p变量中获取函数调用</span><br>distanceFromP := p.Distance        <span class="hljs-comment">// method value</span><br>fmt.Println(distanceFromP(q))      <span class="hljs-comment">// &quot;5&quot;</span><br></code></pre></td></tr></table></figure>
<p>该<strong>方法值</strong>绑定了原对象。</p>
<p><em>表达式</em><br>如果希望方法值不绑定对象，而是可以选择对象进行调用，则需要使用<strong>表达式</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>distance := Point.Distance   <span class="hljs-comment">// method expression</span><br>fmt.Println(distance(p, q))  <span class="hljs-comment">// &quot;5&quot;</span><br></code></pre></td></tr></table></figure>
<p>表达式的参数会比原方法多一个，其第一个参数用于指定接收器（与JAVA中的反射Method有点类似）</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><em>封装定义</em><br>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。</p>
<p><em>方法可见性</em><br>大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而<strong>如果我们想要封装一个对象，我们必须将其定义为一个struct</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>    words []<span class="hljs-type">uint64</span> <span class="hljs-comment">// 禁止其他包操作底层数组</span><br>&#125;<br><br><span class="hljs-keyword">type</span> IntSet []<span class="hljs-type">uint64</span> <span class="hljs-comment">// 允许其他包操作底层数组</span><br></code></pre></td></tr></table></figure>

<p><em>Go的set与get</em><br>只用来访问或修改内部变量的函数被称为setter或者getter，在命名一个getter方法时，我们通常会省略掉前面的Get前缀。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> log<br><span class="hljs-keyword">type</span> Logger <span class="hljs-keyword">struct</span> &#123;<br>    flags  <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">// 省略get前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span></span> Flags() <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span></span> SetFlags(flag <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure>

<h1 id="七、接口"><a href="#七、接口" class="headerlink" title="七、接口"></a>七、接口</h1><h2 id="接口基础"><a href="#接口基础" class="headerlink" title="接口基础"></a>接口基础</h2><p><em>接口定义</em><br>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接口也可以组合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader <span class="hljs-comment">// Reader接口</span><br>    Writer <span class="hljs-comment">// Writer接口</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>接口的实现</em><br>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。（不需要定义一个具体类型和它实现的接口之间的关系。）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br><span class="hljs-comment">// 只要是实现了接口方法，都可以被赋值</span><br>w = os.Stdout           <span class="hljs-comment">// OK: *os.File has Write method</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)   <span class="hljs-comment">// OK: *bytes.Buffer has Write method</span><br><br><span class="hljs-comment">// 同上</span><br><span class="hljs-keyword">var</span> rwc io.ReadWriteCloser<br>rwc = os.Stdout         <span class="hljs-comment">// OK: *os.File has Read, Write, Close methods</span><br><br><span class="hljs-comment">// 因为ReadWriteCloser聚合了Writer，可以将rwc赋值给w</span><br>w = rwc <span class="hljs-comment">// OK: io.ReadWriteCloser has Write method</span><br><span class="hljs-comment">// 但w不能赋值给rwc</span><br>rwc = w <span class="hljs-comment">// compile error: io.Writer lacks Close method</span><br></code></pre></td></tr></table></figure>

<p><em>指针类型对接口的实现</em><br>类型是否实现了接口取决于该类型是否实现了对应方法，但应当注意到指针类型所定义的方法不属于该类型，即<strong>如果只是指针类型实现了接口，该类型本身并没有实现该接口</strong>。（能通过类型变量调用指针接口只是语法糖）</p>
<p><em>空接口</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-comment">// 可以将任意一个值赋给空接口类型。</span><br>any = <span class="hljs-literal">true</span><br>any = <span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure>

<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p><em>接口类型的结构</em><br>接口类型零值：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231112234228.png" srcset="/img/loading.gif" lazyload></p>
<p><em>接口类型</em><br>一个接口值<strong>基于它的动态类型</strong>被描述为空或非空，随着为其赋值，其type和value会随之改变：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创造一个空值接口</span><br><span class="hljs-keyword">var</span> w io.Writer <span class="hljs-comment">// 此处，io.Writer的默认type为nil，而不是io.Writer</span><br>w == <span class="hljs-literal">nil</span> <span class="hljs-comment">// true</span><br>w = os.Stdout <span class="hljs-comment">// 修改w的Type为*os.File，修改w的value为一个os.File的指针</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// 修改w的Type为*byte.Buffer，修改w的value为bytes.Buffer的指针</span><br>w = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 重置type和value为nil</span><br></code></pre></td></tr></table></figure>

<p><em>接口值比较</em><br>接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的<code>==</code>操作相等。<br>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic。</p>
<p><em>包含nil指针的接口不是nil接口</em><br><strong>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的！</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buf *bytes.Buffer <span class="hljs-comment">// 对于这个接口值的声明，其value为nil，但动态类型type是*bytes.Buffer的（因为选择了具体接口的指针为类型）</span><br>buf == <span class="hljs-literal">nil</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231112235416.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a>sort.Interface接口</h2><p><em>sort.Interface</em><br>sort包内置的提供了根据一些排序函数来对任何序列排序的功能。Go语言的<code>sort.Sort</code>函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型<code>sort.Interface</code>来指定通用的排序算法和可能被排序到的序列类型之间的约定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<br><br><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    Len() <span class="hljs-type">int</span><br>    Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> <span class="hljs-comment">// i, j are indices of sequence elements</span><br>    Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>reverse</em><br>如果需要倒序排列，我们不需要重新对接口进行实现。sort包提供了<code>sort.Reverse</code>函数值，通过将一个实现了<code>sort.Interface</code>的结构体传入该函数，会构造一个<code>sort.reverse</code>结构体的对象。<br>该结构体通过内嵌隐式的实现了<code>Len</code>和<code>Swap</code>方法，并重写了<code>Less</code>函数，因此其也是一个<code>sort.Interface</code>，可以对其调用<code>sort.Sort</code>实现逆序排序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用</span><br>sort.Sort(sort.Reverse(byArtist(tracks)))<br><br><span class="hljs-comment">// 源码</span><br><span class="hljs-keyword">package</span> sort<br><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span>&#123; Interface &#125; <span class="hljs-comment">// that is, sort.Interface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> r.Interface.Less(j, i) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span></span> Interface &#123; <span class="hljs-keyword">return</span> reverse&#123;data&#125; &#125;<br></code></pre></td></tr></table></figure>

<p><em>Int切片排序</em><br><code>[]int</code>并没有实现<code>sort.Interface</code>接口，sort包为其提供了特殊的排序版本，以及对其的包装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">// 整数排序</span><br>sort.Ints(values)<br><span class="hljs-comment">// 包装后倒序排序</span><br>sort.Sort(sort.Reverse(sort.IntSlice(values)))<br></code></pre></td></tr></table></figure>

<h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a>http.Handler接口</h2><p><em>handler接口</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><span class="hljs-comment">// handler接口，可以将该接口的实现传入ListenAndServe函数</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><span class="hljs-comment">// ListenAndServe主函数，绑定server地址和handler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 某个实现该接口的类：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>	<span class="hljs-comment">// 根据url判断如何返回值</span><br>    <span class="hljs-keyword">switch</span> req.URL.Path &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/list&quot;</span>:<br>	    <span class="hljs-comment">// 返回匹配的handler结果</span><br>        fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, <span class="hljs-string">&quot;toy&quot;</span>, <span class="hljs-number">50</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/price&quot;</span>:<br>        fmt.Fprintf(w, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-number">30</span>)<br>    <span class="hljs-keyword">default</span>:<br>	    <span class="hljs-comment">// 匹配失败，返回404</span><br>        w.WriteHeader(http.StatusNotFound) <span class="hljs-comment">// 404</span><br>        <span class="hljs-comment">// 等效于</span><br>        <span class="hljs-comment">// http.Error(w, msg, http.StatusNotFound) // 404</span><br>        fmt.Fprintf(w, <span class="hljs-string">&quot;no such page: %s\n&quot;</span>, req.URL)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>ServeMux</em><br>可以使用<code>ServerMux</code>实现了<code>http.Handler</code>接口，且其自身可以做路径和处理器的匹配：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;<br>    mux := http.NewServeMux()<br>    mux.Handle(<span class="hljs-string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))<br>    mux.Handle(<span class="hljs-string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, mux))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>http.HandlerFunc</code>是一个转换器，传入一个函数值，其会对函数进行转换，使其实现统一的方法<code>ServeHTTP</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;<br>    f(w, r)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了简化转化的步骤，也可以直接调用<code>mux.HandleFunc</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;<br>    http.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)<br>    http.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h2><p><em>error接口</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>errors包</em><br>errors包提供了New函数用于快速的创建一个error——<code>*errorString</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125; &#125;<br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123; text <span class="hljs-type">string</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.text &#125;<br></code></pre></td></tr></table></figure>

<p><em>fmt.Errorf</em><br>fmt提供了更方便的Errors.New函数，来返回一个<code>*errorString</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.New(Sprintf(format, args...))<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>Errno</em><br>Errno是一个实现error的数字类型，会从字符串表中返回一个标准的Unix平台错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> syscall<br><span class="hljs-keyword">type</span> Errno <span class="hljs-type">uintptr</span> <span class="hljs-comment">// operating system error code</span><br><span class="hljs-keyword">var</span> errors = [...]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-number">1</span>:   <span class="hljs-string">&quot;operation not permitted&quot;</span>,   <span class="hljs-comment">// EPERM</span><br>    <span class="hljs-number">2</span>:   <span class="hljs-string">&quot;no such file or directory&quot;</span>, <span class="hljs-comment">// ENOENT</span><br>    <span class="hljs-number">3</span>:   <span class="hljs-string">&quot;no such process&quot;</span>,           <span class="hljs-comment">// ESRCH</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-type">int</span>(e) &amp;&amp; <span class="hljs-type">int</span>(e) &lt; <span class="hljs-built_in">len</span>(errors) &#123;<br>        <span class="hljs-keyword">return</span> errors[e]<br>    &#125;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;errno %d&quot;</span>, e)<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span> = syscall.Errno(<span class="hljs-number">2</span>)<br>fmt.Println(err.Error()) <span class="hljs-comment">// &quot;no such file or directory&quot;</span><br>fmt.Println(err)         <span class="hljs-comment">// &quot;no such file or directory&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><em>类型断言</em><br>通过<code>变量.(类型)</code>可以判断其是否为对应类型：如果是，则将其以该类型的形式返回；如果不是，则抛出panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>f := w.(*os.File)      <span class="hljs-comment">// success: f == os.Stdout</span><br></code></pre></td></tr></table></figure>
<p>如果<strong>类型断言使用的是一个接口而不是实际类型</strong>，则会判断该变量是否实现了该接口：如果是，则将其以该接口的形式返回；如果不是，则抛出panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>rw := w.(io.ReadWriter) <span class="hljs-comment">// success: *os.File has both Read and Write</span><br>w = <span class="hljs-built_in">new</span>(ByteCounter)<br>rw = w.(io.ReadWriter) <span class="hljs-comment">// panic: *ByteCounter has no Read method</span><br></code></pre></td></tr></table></figure>
<p>如果变量为nil，则其始终会失败并抛出panic。</p>
<blockquote>
<p>类型断言相当于java的类型强转：a &#x3D; (A)b</p>
</blockquote>
<p><em>多返回值类型断言</em><br>如果类型断言出现在一个预期有两个结果的赋值操作中，这个操作<strong>不会在失败的时候发生panic</strong>，而是返回额外的一个结果，该结果是一个标识成功与否的布尔值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer = os.Stdout<br>f, ok := w.(*os.File)      <span class="hljs-comment">// success:  ok, f == os.Stdout</span><br>b, ok := w.(*bytes.Buffer) <span class="hljs-comment">// failure: !ok, b == nil</span><br></code></pre></td></tr></table></figure>

<p><em>if语句连用</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> w, ok := w.(*os.File); ok &#123;<br>    <span class="hljs-comment">//原来的变量名重用，其实是声明了一个同名的新的本地变量，外层原来的w不会被改变</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>基于类型断言区别错误类型</em><br>以文件IO异常为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPermission</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// PathError是一个Error，其封装了一个底层Error，并提供了相关的信息，其有点类似Java的子类</span><br><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>    Op   <span class="hljs-type">string</span><br>    Path <span class="hljs-type">string</span><br>    Err  <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用类型断言：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> pe, ok := err.(*PathError); ok &#123;<br>        err = pe.Err<br>    &#125;<br>    <span class="hljs-keyword">return</span> err == syscall.ENOENT || err == ErrNotExist<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>基于类型断言查看接口</em><br>对于一个类型，希望其调用一个函数时根据是否做了更详细的实现而做出不同的行为，可以使用类型断言，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关键方法（可以认为是手动实现的多态函数调用）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeString</span><span class="hljs-params">(w io.Writer, s <span class="hljs-type">string</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">type</span> stringWriter <span class="hljs-keyword">interface</span> &#123;<br>        WriteString(<span class="hljs-type">string</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果w还实现了WriteString方法，则优先调用该方法</span><br>    <span class="hljs-keyword">if</span> sw, ok := w.(stringWriter); ok &#123;<br>        <span class="hljs-keyword">return</span> sw.WriteString(s) <span class="hljs-comment">// avoid a copy</span><br>    &#125;<br>    <span class="hljs-comment">// 否则，调用io.Writer的默认方法</span><br>    <span class="hljs-keyword">return</span> w.Write([]<span class="hljs-type">byte</span>(s)) <span class="hljs-comment">// allocate temporary copy</span><br>&#125;<br><br><span class="hljs-comment">// 使用，w是一个io.Writer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w io.Writer, contentType <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> _, err := writeString(w, <span class="hljs-string">&quot;Content-Type: &quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="类型分支"><a href="#类型分支" class="headerlink" title="类型分支"></a>类型分支</h2><p><em>接口被以两种不同的方式使用</em></p>
<ul>
<li>表达实现该接口的具体类型之间的相似性（有共同的方法名），重点在于方法。</li>
<li>利用接口值可以持有各种具体类型值得能力，将其视作一些类型的联合，类似子类型多态。</li>
</ul>
<p><em>利用接口值进行类型分支</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqlQuote</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">int</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">uint</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b, ok := x.(<span class="hljs-type">bool</span>); ok &#123;<br>        <span class="hljs-keyword">if</span> b &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TRUE&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FALSE&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s, ok := x.(<span class="hljs-type">string</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> sqlQuoteString(s) <span class="hljs-comment">// (not shown)</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected type %T: %v&quot;</span>, x, x))<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 也可以使用switch，只有接口值才能使用.(type)关键词获取其实现类型。</span><br><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:       <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>, <span class="hljs-type">uint</span>: <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:      <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>不同于JAVA，这里如果只想执行匹配成功的case时不需要在每个case内加break。</p>
</blockquote>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul>
<li>一般情况下，不要为了仅有一个实现的类型创建接口，这种接口是不必要的抽象。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</li>
<li>例外情况下，例如接口和接口的具体实现存在于两个包中，则可以使用一个只被一个单一具体类型实现的接口。接口是解耦包的好方式。</li>
</ul>
<h1 id="八、Goroutines和Channels"><a href="#八、Goroutines和Channels" class="headerlink" title="八、Goroutines和Channels"></a>八、Goroutines和Channels</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p><em>goroutines</em><br>在Go语言中，每一个并发的执行单元叫作一个goroutine。新的goroutine会用go语言来创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> f()<br></code></pre></td></tr></table></figure>

<p><em>main goroutine</em><br>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。</p>
<p><em>注意匿名函数</em><br>注意匿名函数中的迭代陷阱：匿名函数的函数值记录的是循环变量的<strong>内存地址</strong>，而<strong>不是其创建时刻的值</strong>。且循环中循环变量共享相同的循环内存地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 正确的方式</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br>	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br>		thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> correct!</span><br>	&#125;(f) <span class="hljs-comment">// 这里将f显示的传递给了函数，这样函数值中本身就记录了当下的f</span><br>&#125;<br><br><span class="hljs-comment">// 错误的方式</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>	    <span class="hljs-comment">// 试图使用匿名函数隐式调用外部变量，但外部变量因为迭代可能已经发生了变化</span><br>        thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p><em>channels</em><br>channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。<br>每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为<code>chan int</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// ch has type &#x27;chan int&#x27;</span><br><span class="hljs-comment">// 使用channel发送</span><br>ch &lt;- x<br><span class="hljs-comment">// 使用channel接受</span><br>x = &lt;-ch<br><span class="hljs-comment">// 空接受，忽略返回值</span><br>&lt;-ch<br></code></pre></td></tr></table></figure>

<p><em>channel的关闭</em><br>channel支持关闭操作，关闭后关于channel的所有<strong>发送操作都会导致panic异常</strong>，但<strong>已经发送成功的数据依然可以被接受</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure>
<p>当一个被关闭的channel中已经发送的数据都被成功接收后，<strong>后续的接收操作将不再阻塞</strong>，它们会立即返回一个零值。但如果本身业务的返回值就可能为0，则可能导致无法判断管道是否关闭，因此接受操作也存在变体形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x, ok := &lt;-ch<br></code></pre></td></tr></table></figure>

<p><em>不带缓存的channels</em><br>基于无缓存的channels对于发送者和接收者都是阻塞的，前者需要满足 <strong>消息被接受</strong> 后才能继续执行，后者需要满足 <strong>接受到消息</strong> 才能继续执行。因此，缓存Channels有时候也被称为<strong>同步Channels</strong>。<br>有时候通讯的事实和发生的时刻十分重要，当我们更希望强调通讯发生的时刻时，我们将它称为<strong>消息事件</strong>，这些消息事件可能并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，此时可以使用<code>ch &lt;- 1</code>这种简单的表达来发送信号。</p>
<p><em>串联的channels</em><br>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（<strong>pipeline</strong>）。<br><strong>可使用for循环持续获取管道数据，其会在管道关闭时退出</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> in &#123;<br>	out &lt;- x * x<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br></code></pre></td></tr></table></figure>

<p><em>单方向的channels</em><br>一般我们会将channel作为参数传入goroutine的函数，而当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。<br>为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别<strong>用于只发送或只接收的channel</strong>。类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// chan&lt;- int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123;<br>        out &lt;- x<br>    &#125;<br>    <span class="hljs-built_in">close</span>(out)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>带缓存的channels</em><br>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<p>对于基于缓存的channel，<strong>发送&#x2F;接受操作</strong>只会在<strong>缓存已满&#x2F;缓存已空</strong>的情况下阻塞。</p>
<p><em>goroutines泄漏</em><br>如果由于无阻塞条件始终无法达成（例如在无缓存情况下goroutines的数据没有线程接受）导致其永远卡住，这种情况被称为goroutines泄漏。和垃圾变量不同，<strong>泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的</strong>。</p>
<h2 id="并发的循环"><a href="#并发的循环" class="headerlink" title="并发的循环"></a>并发的循环</h2><p><em>sync.WaitGroup</em><br>waitgroup是一个计数器，可以认为其是一个<code>CountDownLatch</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个计数器</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 添加n个计数，本质类似于初始化</span><br>wg.Add(n)<br><span class="hljs-comment">// 减少一个计数，可以认为是wg.Add(-1)</span><br>wg.Done()<br><span class="hljs-comment">// 阻塞，当wg计数为0时释放</span><br>wg.Wait()<br></code></pre></td></tr></table></figure>
<p>一般Add必须在其他goroutine开启前调用，如果放在goroutine中，则无法判断是Add后Done，还是goroutine还没有开始执行。</p>
<p><em>案例：感知并发的结束</em><br>主线程通过信号量感知所有goroutine执行完毕</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.为了使程序感知到所有goroutine执行完毕，可以使用wg</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails6</span><span class="hljs-params">(filenames &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    sizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>)<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> f := <span class="hljs-keyword">range</span> filenames &#123;<br>	    <span class="hljs-comment">// 1.每一个worker routine开启前，新增一个wg信号</span><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// worker</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            thumb, _ := thumbnail.ImageFile(f)<br>            info, _ := os.Stat(thumb)<br>            sizes &lt;- info.Size()<br>        &#125;(f)<br>    &#125;<br>    <br>	<span class="hljs-comment">// 执行到此处时，Add肯定执行完毕了，但worker并没有全部执行完成</span><br>    <span class="hljs-comment">// closer 线程，等待所有worker执行完成后关闭channel</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        wg.Wait()<br>        <span class="hljs-comment">// 3.关闭管道</span><br>        <span class="hljs-built_in">close</span>(sizes)<br>    &#125;()<br><br>	<span class="hljs-comment">// 2.循环获取channel内的数据</span><br>    <span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>    <span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> sizes &#123;<br>        total += size<br>    &#125;<br>    <span class="hljs-comment">// 4.结束主线程循环，返回结果</span><br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>案例：BFS扫描并发</em><br>实现BFS的并发，每出现一个新的待扫描节点则向主线程新增一个信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 以下实现了一个并发的 BFS</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span> <span class="hljs-comment">// number of pending sends to worklist</span><br>    <span class="hljs-comment">// 信号初始化为1</span><br>    n++<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<br>    <span class="hljs-comment">// 首次调用接受 启动参数 n-- 到0</span><br>    <span class="hljs-comment">// 后续每处理一个需要迭代的过程则将n--</span><br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>	    <span class="hljs-comment">// 处理一个迭代信息</span><br>        list := &lt;-worklist<br>        <span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<br>	        <span class="hljs-comment">// 每有一个下一个迭代信息，令n++，要求主函数为其增加一次迭代调用</span><br>			n++<br>			<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-type">string</span>)</span></span> &#123;<br>				worklist &lt;- crawl(link)<br>			&#125;(link)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 迭代结束</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><em>基于select语句的多路复用</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> x := &lt;-ch2:<br>    <span class="hljs-comment">// ...use x...</span><br><span class="hljs-keyword">case</span> ch3 &lt;- y:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用一次select只会响应就绪的case：</p>
<ul>
<li>如果都不满足且没有default，则会阻塞，直到有事件触发。（一个没有任何case的select语句写作select{}，会永远地等待下去。）</li>
<li>如果存在多个case同时就绪时，则随机选择一个执行。</li>
</ul>
<p><em>time.Tick函数</em></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">// 生成一个<span class="hljs-built_in">tick</span> 的channel，同时生成一个goroutine定时向<span class="hljs-built_in">tick</span>中发信号（不会停止）<br><span class="hljs-built_in">tick</span> := <span class="hljs-built_in">time</span>.Tick(<span class="hljs-number">1</span> * <span class="hljs-built_in">time</span>.Second)<br><span class="hljs-comment"></span><br><span class="hljs-comment">// 生成一个ticker，其是对tick的封装，可以通过ticker.C接受定时信号，也可以手动停止</span><br>ticker := <span class="hljs-built_in">time</span>.NewTicker(<span class="hljs-number">1</span> * <span class="hljs-built_in">time</span>.Second)<br>&lt;-ticker.C<br>ticker.Stop()<br></code></pre></td></tr></table></figure>

<p><em>处理零值channel</em><br>channel的零值是nil，对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。<br>因此，我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。</p>
<h2 id="并发的退出"><a href="#并发的退出" class="headerlink" title="并发的退出"></a>并发的退出</h2><p><em>并发的退出</em><br>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，这样会导致goroutine之间的共享变量落在未定义的状态上。<br>因此，令goroutine退出方法有：</p>
<ul>
<li>单goroutine：向chan发送一个信号通知goroutine停止运行；</li>
<li>多goroutine：利用select的机制和chan的关闭机制实现广播通知。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goroutine循环 select</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-comment">// 1.正常工作时，done中无数据，不走该case</span><br>    <span class="hljs-comment">// 2.当done被关闭后，可以从done中取到0值，因此select会触发该case</span><br>    <span class="hljs-keyword">case</span> &lt;-done:<br>        <span class="hljs-comment">// 清除资源占用后退出</span><br>        <span class="hljs-comment">// do sth</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>	    <span class="hljs-comment">// 正常执行</span><br>        <span class="hljs-comment">// do sth</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>案例：令多个goroutine退出</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printString</span><span class="hljs-params">(string1 <span class="hljs-type">string</span>, done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>	times := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> &#123;<br>		time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> &lt;-done:<br>			<span class="hljs-comment">// 返回退出</span><br>			<span class="hljs-comment">// do sth，释放资源，在当前代码下可能无法被完全执行</span><br>			<span class="hljs-keyword">return</span><br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-built_in">println</span>(string1 + <span class="hljs-string">&quot;:第&quot;</span> + strconv.Itoa(times) + <span class="hljs-string">&quot;次&quot;</span>)<br>		&#125;<br>		times++<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>	<span class="hljs-keyword">go</span> printString(<span class="hljs-string">&quot;hello1&quot;</span>, done)<br>	<span class="hljs-keyword">go</span> printString(<span class="hljs-string">&quot;hello2&quot;</span>, done)<br>	time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>	<span class="hljs-comment">// 关闭goroutines</span><br>	<span class="hljs-built_in">close</span>(done)<br>	<span class="hljs-comment">// 需要注意，这里close后主线程直接结束，无法保证goroutine的完成了资源的释放</span><br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Go中，<code>main</code>函数的退出是程序结束的标志。一旦<code>main</code>函数完成执行（包括通过<code>return</code>、<code>panic</code>或正常的函数结束），整个程序就会退出，而不会等待其他未完成的goroutine。<br>因此想要让goroutine正确的关闭，必须保证主函数的关闭时机在其他goroutine正确结束后，一般的方法有：使用sync.WaitGroup感知子函数正确退出后再退出。</p>
<h2 id="Goroutines与线程"><a href="#Goroutines与线程" class="headerlink" title="Goroutines与线程"></a>Goroutines与线程</h2><p><em>动态栈</em><br>一个goroutine的栈和OS线程不太一样的是，其大小并不是固定的，而是根据需要动态地伸缩。其最大值有1GB，比传统的固定大小的线程栈要大得多。</p>
<p><em>Goroutine调度</em><br>Go的运行时包含了其自己的调度器，其使用了一些技术，如m:n调度等。<br>Go调度器并不是一个硬件定时器，而是而是被Go语言“建筑”本身进行调度的，由于这种调度方式不需要进入内核的上下文，所以调度一个goroutine比调度一个OS线程代价要低得多</p>
<p><em>GOMAXPROCS</em><br>Go的调度器使用了一个叫GOMAXPROCS的变量决定有多少个操作系统的线程同时执行Go代码，其默认值为运行机器上的CPU的核心数。</p>
<p><em>Goroutine没有ID号</em><br>goroutine没有可以被程序员获取到的身份（id）的概念。因为thread-local总是被不合理的滥用。而Go的设计认为一个函数的行为应该仅由自己的参数所决定，而不是由其所运行在的线程所决定。</p>
<h1 id="九、基于共享变量的并发"><a href="#九、基于共享变量的并发" class="headerlink" title="九、基于共享变量的并发"></a>九、基于共享变量的并发</h1><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p><em>竞争条件</em><br>竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。<br><em>数据竞争</em><br>这个程序包含了一个特定的竞争条件，叫作数据竞争。无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。<br><em>避免数据竞争</em></p>
<ol>
<li>不要写变量</li>
<li>避免从多个goroutine访问变量</li>
<li>允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“<strong>互斥</strong>”</li>
</ol>
<h2 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a>sync.Mutex互斥锁</h2><p><em>sync.Mutex</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>	<span class="hljs-comment">// 互斥锁</span><br>    mu sync.Mutex<br>    balance <span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Lock和Unlock之间的代码段叫做临界区。</p>
<p><em>Mutex的不可重入性</em><br>Mutex<strong>不可重入</strong>，其理念是确保共享变量在程序执行时的关键点上能够保证不变性：当一个goroutine获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（即没有其他代码块正在读写共享变量）<br>通用的解决方案是将函数分离，内部存在一个不使用锁的函数，对外暴露一个使用锁的函数，由其调用内部函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对外暴露</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    deposit(amount)<br>&#125;<br><span class="hljs-comment">// 内部使用（不需要重入）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123; balance += amount &#125;<br></code></pre></td></tr></table></figure>

<h2 id="sync-RWMutex读写锁"><a href="#sync-RWMutex读写锁" class="headerlink" title="sync.RWMutex读写锁"></a>sync.RWMutex读写锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.RWMutex<br><span class="hljs-keyword">var</span> balance <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-comment">// 读锁的加锁</span><br>    mu.RLock()<br>    <span class="hljs-comment">// 读锁的解锁</span><br>    <span class="hljs-keyword">defer</span> mu.RUnlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p>channel、mutex除了功能性的语义，还有<strong>内存同步</strong>的语义：</p>
<ul>
<li>通道（<code>channel</code>）的操作在内部包含了适当的内存屏障，以确保在发送和接收操作之间的正确同步，保证数据的可见性。</li>
<li>锁（<code>sync.Mutex</code>）不仅提供了互斥，也提供了内存屏障的作用。当一个 goroutine 通过 <code>mu.Lock()</code> 获取锁，并通过 <code>mu.Unlock()</code> 释放锁时，这确保了在锁内执行的所有操作对其他goroutine是可见的。</li>
</ul>
<h2 id="sync-Once惰性初始化"><a href="#sync-Once惰性初始化" class="headerlink" title="sync.Once惰性初始化"></a>sync.Once惰性初始化</h2><p><em>并发初始化问题</em><br>类似JAVA单例模式中的初始化，Go语言中的惰性初始化也会遇到并发问题。<br>在JAVA中，一般通过synchronize关键词即可实现方法的串行访问，考虑到锁的消耗，可以考虑双重校验锁的实现方式，避免后续每次访问都加锁。<br>在Go语言中，没有提供synchronize关键词，因此可以利用锁来手动实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 双重校验锁</span><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> instance *SingletonObject<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *SingletonObject &#123;<br>	<span class="hljs-keyword">if</span> instance == <span class="hljs-literal">nil</span> &#123;<br>		mu.Lock()<br>		<span class="hljs-keyword">defer</span> mu.Unlock()<br>		<span class="hljs-keyword">if</span> instance == <span class="hljs-literal">nil</span> &#123;<br>			instance = &amp;SingletonObject&#123;&#125;<br>		&#125;<br>	&#125;<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>sync.Once</em><br>在 Go 语言中，<code>sync.Once</code> 是一个提供了一个简单的方法来确保某个函数在程序运行期间只被执行一次，其通过内部机制保证了<strong>线程安全</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> once sync.Once<br><span class="hljs-keyword">var</span> instance *SingletonObject<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *SingletonObject &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        instance = &amp;SingletonObject&#123;&#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure>
<p>与JAVA的双重校验锁相比，其无需用户手动处理锁，无需用户使用volatile关键词保证属性的可见性，其隐藏了更多的细节。</p>
<h2 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h2><p><em>竞争检查器</em><br>go提供了竞争检查器（the race detector），只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。<br>另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对<code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code>等等的调用。<br>这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。</p>
<p><em>使用注意点</em></p>
<ul>
<li>竞争检查器只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。</li>
<li>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存。</li>
</ul>
<h2 id="并发的非阻塞缓存"><a href="#并发的非阻塞缓存" class="headerlink" title="并发的非阻塞缓存"></a>并发的非阻塞缓存</h2><p><em>基于锁的缓存</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>    res   result<br>    ready <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// closed when res is ready</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br>    <span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>    f     Func<br>    mu    sync.Mutex <span class="hljs-comment">// guards cache</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>    memo.mu.Lock()<br>    e := memo.cache[key]<br>    <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// This is the first request for this key.</span><br>        <span class="hljs-comment">// This goroutine becomes responsible for computing</span><br>        <span class="hljs-comment">// the value and broadcasting the ready condition.</span><br>        e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>        memo.cache[key] = e<br>        memo.mu.Unlock()<br><br>        e.res.value, e.res.err = memo.f(key)<br><br>        <span class="hljs-built_in">close</span>(e.ready) <span class="hljs-comment">// broadcast ready condition</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// This is a repeat request for this key.</span><br>        memo.mu.Unlock()<br><br>        &lt;-e.ready <span class="hljs-comment">// wait for ready condition</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> e.res.value, e.res.err<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>基于通道</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A request is a message requesting that the Func be applied to key.</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    key      <span class="hljs-type">string</span><br>    response <span class="hljs-keyword">chan</span>&lt;- result <span class="hljs-comment">// the client wants a single result</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span>&#123; requests <span class="hljs-keyword">chan</span> request &#125;<br><span class="hljs-comment">// New returns a memoization of f.  Clients must subsequently call Close.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br>    memo := &amp;Memo&#123;requests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> request)&#125;<br>    <span class="hljs-keyword">go</span> memo.server(f)<br>    <span class="hljs-keyword">return</span> memo<br>&#125;<br><br><span class="hljs-comment">// 客户请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    response := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)<br>    memo.requests &lt;- request&#123;key, response&#125;<br>    res := &lt;-response<br>    <span class="hljs-keyword">return</span> res.value, res.err<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Close() &#123; <span class="hljs-built_in">close</span>(memo.requests) &#125;<br><br><br><span class="hljs-comment">// 服务端</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> server(f Func) &#123;<br>    cache := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)<br>    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> memo.requests &#123;<br>        e := cache[req.key]<br>        <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// This is the first request for this key.</span><br>            e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>            cache[req.key] = e<br>            <span class="hljs-keyword">go</span> e.call(f, req.key) <span class="hljs-comment">// call f(key)</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> e.deliver(req.response)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> call(f Func, key <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-comment">// Evaluate the function.</span><br>    e.res.value, e.res.err = f(key)<br>    <span class="hljs-comment">// Broadcast the ready condition.</span><br>    <span class="hljs-built_in">close</span>(e.ready)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> deliver(response <span class="hljs-keyword">chan</span>&lt;- result) &#123;<br>    <span class="hljs-comment">// Wait for the ready condition.</span><br>    &lt;-e.ready<br>    <span class="hljs-comment">// Send the result to the client.</span><br>    response &lt;- e.res<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="十、包"><a href="#十、包" class="headerlink" title="十、包"></a>十、包</h1><p><em>包导入</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)<br></code></pre></td></tr></table></figure>
<p>如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。</p>
<p><em>包声明</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 包声明</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>)<br></code></pre></td></tr></table></figure>

<p>通常来说，默认的包名就是包导入路径名的最后一段，因此<strong>即使两个包的导入路径不同，它们依然可能有一个相同的包名</strong>。但也有例外场景：</p>
<ol>
<li>main包的导入路径是无关紧要的，名字为main的包的目的是给go build构建一个命令信息。</li>
<li><code>_test.go</code>为后缀的Go源文件（译注：前面必须有其它的字符，因为以<code>_</code>或<code>.</code>开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以<code>_test</code>为后缀名的。所有以<code>_test</code>为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。</li>
<li>一些依赖版本号的管理工具会在<strong>导入路径后追加版本号</strong>信息，例如“gopkg.in&#x2F;yaml.<strong>v2</strong>”。这种情况下包的名字并不包含版本号后缀，而是yaml。</li>
</ol>
<p><em>包导入</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;crypto/rand&quot;</span><br>    mrand <span class="hljs-string">&quot;math/rand&quot;</span> <span class="hljs-comment">// 取别名以避免冲突</span><br>)<br></code></pre></td></tr></table></figure>
<p>选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。</p>
<p><em>匿名导入</em><br>允许包的匿名导入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;image/png&quot;</span><br></code></pre></td></tr></table></figure>
<p>这样导入的包无法被显示使用，但会计算包级变量的初始化表达式和执行导入包的init初始化函数。</p>
<p><em>包命名</em><br>包名要简短、易懂、一般采用单数形式（除非要与具体类型区分）</p>
<p><em>包工具</em></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 下载包<br>go get ...<br><br><span class="hljs-regexp">//</span> 构建包<br>go build target_package<br><br><span class="hljs-regexp">//</span> 查看包文档<br>go doc time<br>godoc -http :<span class="hljs-number">8000</span> <span class="hljs-regexp">//</span> 查看包文档并显示到<span class="hljs-number">8000</span>端口<br><br><span class="hljs-regexp">//</span> 查询可用包的信息<br>go list ...<br><span class="hljs-regexp">//</span> 通过-json可以展示更完整的元数据<br>go list package -json<br></code></pre></td></tr></table></figure>

<p><em>内部包</em><br>Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。<br>这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。</p>
<h1 id="十一、测试"><a href="#十一、测试" class="headerlink" title="十一、测试"></a>十一、测试</h1><p><em>go_test</em><br>所有以<code>_test.go</code>为后缀名的源文件在执行go build时不会被构建成包的一部分。</p>
<p><em>测试函数</em><br>每个测试函数必须导入testing包。测试函数有如下的签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过外部测试包，可以防止包的循环依赖：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231221162213.png" srcset="/img/loading.gif" lazyload></p>
<p><em>测试覆盖率</em></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 测试包覆盖率（通过为函数生成切面实现），并输出到控制台</span><br>go <span class="hljs-keyword">test</span> -<span class="hljs-keyword">run</span>=Coverage -coverprofile=c.<span class="hljs-keyword">out</span> target_package<br></code></pre></td></tr></table></figure>

<p><em>基准测试</em></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 测试对应的函数，.代表所有<br>go test -bench=.<br></code></pre></td></tr></table></figure>

<p><em>剖析</em></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">go <span class="hljs-keyword">test</span> -cpuprofile=<span class="hljs-meta">cpu</span><span class="hljs-number">.</span><span class="hljs-keyword">out</span><br>go <span class="hljs-keyword">test</span> -blockprofile=block<span class="hljs-number">.</span><span class="hljs-keyword">out</span><br>go <span class="hljs-keyword">test</span> -memprofile=mem<span class="hljs-number">.</span><span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure>
<ul>
<li>CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。</li>
<li>堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。</li>
<li>阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</li>
</ul>
<p><em>示例函数</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleIsPalindrome</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(IsPalindrome(<span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>))<br>    fmt.Println(IsPalindrome(<span class="hljs-string">&quot;palindrome&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>
<p>示例函数没有函数参数和返回值。</p>
<ol>
<li>根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身。</li>
<li>在<code>go test</code>执行测试的时候也会运行示例函数测试。</li>
</ol>
<h1 id="十二、反射"><a href="#十二、反射" class="headerlink" title="十二、反射"></a>十二、反射</h1><h2 id="reflect-Type-和-reflect-Value"><a href="#reflect-Type-和-reflect-Value" class="headerlink" title="reflect.Type 和 reflect.Value"></a>reflect.Type 和 reflect.Value</h2><p><em>reflect.Type</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取一个对象的反射类型（具体类型）</span><br>t := reflect.TypeOf(<span class="hljs-number">3</span>)  <span class="hljs-comment">// a reflect.Type</span><br>fmt.Println(t.String()) <span class="hljs-comment">// &quot;int&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// %T可以代表类型</span><br></code></pre></td></tr></table></figure>

<p><em>reflect.Value</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取一个对象的值反射</span><br>v := reflect.ValueOf(<span class="hljs-number">3</span>) <span class="hljs-comment">// a reflect.Value</span><br>fmt.Println(v)          <span class="hljs-comment">// &quot;3&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, v)   <span class="hljs-comment">// &quot;3&quot;</span><br>fmt.Println(v.String()) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> &quot;&lt;int Value&gt;&quot;,String方法只返回值类型</span><br><span class="hljs-comment">// 对值调用Type获取对应的reflect.Type</span><br>t := v.Type()           <span class="hljs-comment">// a reflect.Type</span><br><br><span class="hljs-comment">// 将值反射重新包装成对象interface&#123;&#125;</span><br>v := reflect.ValueOf(<span class="hljs-number">3</span>) <span class="hljs-comment">// a reflect.Value</span><br>x := v.Interface()      <span class="hljs-comment">// an interface&#123;&#125;</span><br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formatAtom</span><span class="hljs-params">(v reflect.Value)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">switch</span> v.Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Invalid:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;invalid&quot;</span><br>    <span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,<br>        reflect.Int32, reflect.Int64:<br>        <span class="hljs-keyword">return</span> strconv.FormatInt(v.Int(), <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,<br>        reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br>        <span class="hljs-keyword">return</span> strconv.FormatUint(v.Uint(), <span class="hljs-number">10</span>)<br>    <span class="hljs-comment">// ...floating-point and complex cases omitted for brevity...</span><br>    <span class="hljs-keyword">case</span> reflect.Bool:<br>        <span class="hljs-keyword">return</span> strconv.FormatBool(v.Bool())<br>    <span class="hljs-keyword">case</span> reflect.String:<br>        <span class="hljs-keyword">return</span> strconv.Quote(v.String())<br>    <span class="hljs-keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:<br>        <span class="hljs-keyword">return</span> v.Type().String() + <span class="hljs-string">&quot; 0x&quot;</span> +<br>            strconv.FormatUint(<span class="hljs-type">uint64</span>(v.Pointer()), <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">// reflect.Array, reflect.Struct, reflect.Interface</span><br>        <span class="hljs-keyword">return</span> v.Type().String() + <span class="hljs-string">&quot; value&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="通过reflect-Value修改值"><a href="#通过reflect-Value修改值" class="headerlink" title="通过reflect.Value修改值"></a>通过reflect.Value修改值</h2><p><em>reflect.Value地址</em><br>有一些reflect.Values是可取地址的；其它一些则不可以。考虑以下的声明语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">2</span>                   <span class="hljs-comment">// value   type    variable?</span><br>a := reflect.ValueOf(<span class="hljs-number">2</span>)  <span class="hljs-comment">// 2       int     no</span><br>b := reflect.ValueOf(x)  <span class="hljs-comment">// 2       int     no</span><br>c := reflect.ValueOf(&amp;x) <span class="hljs-comment">// &amp;x      *int    no</span><br>d := c.Elem()            <span class="hljs-comment">// 2       int     yes (x)</span><br></code></pre></td></tr></table></figure>
<p>其中,a、b只是2的拷贝副本，c是x的指针的拷贝副本，但由于其值指向的是一个地址，我们通过对c解引用，可以得到一个可取地址的<code>reflect.Value</code>。</p>
<div class="note note-primary">
            <p>个人理解：</p><ul><li><code>a</code> 和 <code>b</code> 是提供值的内容信息，它们没有提供实际对象的位置信息，所以你不能获取它们的地址。</li><li><code>c</code> 是x的位置信息的拷贝，通过对c使用解引用，可以得到其位置，即目标实体d。</li></ul><ol><li>**<code>reflect.ValueOf(x)</code>**：当你直接对 <code>x</code> 使用 <code>reflect.ValueOf(x)</code>，你得到的是 <code>x</code> 的一个副本的反射值。这个副本是不可寻址的，意味着你不能通过这个反射值修改原始变量 <code>x</code> 的值。这是因为反射机制在这种情况下仅提供了 <code>x</code> 值的一个快照。</li><li>**<code>reflect.ValueOf(&amp;x).Elem()</code>**：当你先对 <code>x</code> 的地址 <code>&amp;x</code> 使用 <code>reflect.ValueOf(&amp;x)</code>，然后调用 <code>Elem()</code> 方法，你实际上是获取了 <code>x</code> 的地址的反射值，然后通过 <code>Elem()</code> 方法访问这个地址所指向的实际值。在这种情况下，你得到的反射值 <code>d</code> 是可寻址的，意味着你可以通过 <code>d</code> 来修改 <code>x</code> 的值。这是因为 <code>d</code> 直接引用了 <code>x</code>，而不是它的一个副本。</li></ol>
          </div>

<p><strong>所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的。</strong><br>我们可以通过调用reflect.Value的CanAddr方法来判断其是否可以被取地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(c.CanAddr()) <span class="hljs-comment">// &quot;false&quot;</span><br>fmt.Println(d.CanAddr()) <span class="hljs-comment">// &quot;true&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>每当我们通过指针间接地获取的reflect.Value都是可取地址的，即使开始的是一个不可取地址的Value。</strong><br>例如，slice的索引表达式<code>e[i]</code>将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。以此类推，<code>reflect.ValueOf(e).Index(i)</code>对应的值也是可取地址的，即使原始的<code>reflect.ValueOf(e)</code>不支持也没有关系。</p>
<p><em>reflect.Value访问变量</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">2</span><br>d := reflect.ValueOf(&amp;x).Elem()   <span class="hljs-comment">// d refers to the variable x</span><br>px := d.Addr().Interface().(*<span class="hljs-type">int</span>) <span class="hljs-comment">// px := &amp;x</span><br>*px = <span class="hljs-number">3</span>                           <span class="hljs-comment">// x = 3</span><br>fmt.Println(x)                    <span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></td></tr></table></figure>
<p>或者，不使用指针，而是通过调用可取地址的reflect.Value的reflect.Value.Set方法来更新对应的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">d.Set(reflect.ValueOf(<span class="hljs-number">4</span>))<br>fmt.Println(x) <span class="hljs-comment">// &quot;4&quot;</span><br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>个人理解：</p><ol><li><strong>获取保险箱的钥匙</strong>：<code>reflect.ValueOf(&amp;x).Elem()</code> 相当于你拿到了一个可以打开保险箱的特殊钥匙（<code>d</code>）。这个钥匙让你能够接触并改变保险箱里的内容。</li><li><strong>准备要放进去的新内容</strong>：<code>reflect.ValueOf(4)</code> 就像你准备了新的物品（这里是数字 <code>4</code>），并把它放在一个特殊的容器里，这个容器能够和保险箱的钥匙（<code>d</code>）兼容。</li><li><strong>使用钥匙和特殊容器来更新保险箱的内容</strong>：<code>d.Set()</code> 方法就像是你使用钥匙打开保险箱，然后用准备好的特殊容器中的新物品（数字 <code>4</code>）来替换保险箱里原来的内容。</li></ol>
          </div>

<p>相当于为一个reflect.Value设置一个reflect.Value，实现底层数据的替换。</p>
<p><em>Set方法</em><br>Set方法将在运行时执行和编译时进行类似的可赋值性约束的检查。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 编译检查</span><br>d.Set(reflect.ValueOf(<span class="hljs-type">int64</span>(<span class="hljs-number">5</span>))) <span class="hljs-comment">// panic: int64 is not assignable to int</span><br><br>x := <span class="hljs-number">2</span><br>b := reflect.ValueOf(x)<br>b.Set(reflect.ValueOf(<span class="hljs-number">3</span>)) <span class="hljs-comment">// panic: Set using unaddressable value</span><br><br><span class="hljs-comment">// 其他设置方法</span><br>d := reflect.ValueOf(&amp;x).Elem()<br>d.SetInt(<span class="hljs-number">3</span>)<br>fmt.Println(x) <span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></td></tr></table></figure>
<p>Set方法总是尽可能地完成任务。以SetInt为例，只要变量是某种类型的有符号整数就可以工作，即使是一些命名的类型、甚至只要底层数据类型是有符号整数就可以，而且如果对于变量类型值太大的话会被自动截断。<br>但需要谨慎的是：对于一个引用interface{}类型的reflect.Value调用SetInt会导致panic异常，即使那个interface{}变量对于整数类型也不行。</p>
<p><em>CanSet</em><br>CanAddr方法并不能正确反映一个变量是否是可以被修改的。方法CanSet是用于检查对应的reflect.Value是否是可取地址并可被修改的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(fd.CanAddr(), fd.CanSet()) <span class="hljs-comment">// &quot;true false&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="获取结构体标签"><a href="#获取结构体标签" class="headerlink" title="获取结构体标签"></a>获取结构体标签</h2><p><em>根据请求解析结构体</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 属性值的string和reflectValue的映射</span><br>fields := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]reflect.Value)<br>v := reflect.ValueOf(ptr).Elem() <span class="hljs-comment">// the struct variable </span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>	fieldInfo := v.Type().Field(i) <span class="hljs-comment">// a reflect.StructField</span><br>	tag := fieldInfo.Tag           <span class="hljs-comment">// a reflect.StructTag</span><br>	name := tag.Get(<span class="hljs-string">&quot;http&quot;</span>)<br>	<span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>		name = strings.ToLower(fieldInfo.Name)<br>	&#125;<br>	fields[name] = v.Field(i)<br>&#125;<br><br><span class="hljs-comment">// 从req.Form中提取值，并赋值给fileds的value</span><br><span class="hljs-keyword">for</span> name, values := <span class="hljs-keyword">range</span> req.Form &#123;<br>	f := fields[name]<br>	<span class="hljs-keyword">if</span> !f.IsValid() &#123;<br>		<span class="hljs-keyword">continue</span> <span class="hljs-comment">// ignore unrecognized HTTP parameters</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> values &#123;<br>		<span class="hljs-keyword">if</span> f.Kind() == reflect.Slice &#123;<br>			elem := reflect.New(f.Type().Elem()).Elem()<br>			<span class="hljs-keyword">if</span> err := populate(elem, value); err != <span class="hljs-literal">nil</span> &#123;<br>				<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, name, err)<br>			&#125;<br>			f.Set(reflect.Append(f, elem))<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">if</span> err := populate(f, value); err != <span class="hljs-literal">nil</span> &#123;<br>				<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, name, err)<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="显示类型的方法"><a href="#显示类型的方法" class="headerlink" title="显示类型的方法"></a>显示类型的方法</h2><p><em>Method方法</em><br>reflect.Type和reflect.Value都提供了一个Method方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">t := v.Type() <span class="hljs-comment">// reflect.Type</span><br>v := reflect.ValueOf(x) <span class="hljs-comment">// reflect.Value</span><br>t.Method(i) <span class="hljs-comment">// 返回一个reflect.Method结构体，该结构体描述t的第i个方法的名称和类型</span><br>v.Method(i) <span class="hljs-comment">// 返回一个reflect.Value表示对于的值</span><br></code></pre></td></tr></table></figure>

<h1 id="底层编程"><a href="#底层编程" class="headerlink" title="底层编程"></a>底层编程</h1><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><p><em>unsafe.Sizeof</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br>fmt.Println(unsafe.Sizeof(<span class="hljs-type">float64</span>(<span class="hljs-number">0</span>))) <span class="hljs-comment">// &quot;8&quot;</span><br></code></pre></td></tr></table></figure>
<p><code>unsafe.Sizeof</code>函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式。<br>注意：</p>
<ul>
<li>Sizeof不会对表达式进行求值。</li>
<li>Sizeof函数返回的大小只包括数据结构中固定的部分</li>
</ul>
<blockquote>
<p>Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编译器可以随意地重新排列每个字段的内存位置。</p>
</blockquote>
<p><em>unsafe.Alignof</em><br><code>unsafe.Alignof</code> 函数返回对应参数的类型需要对齐的倍数。和 Sizeof 类似， Alignof 也是返回一个常量表达式，对应一个常量。</p>
<p><em>unsafe.offsetof</em><br><code>unsafe.Offsetof</code> 函数的参数必须是一个字段 <code>x.f</code>，然后返回 <code>f</code> 字段相对于 <code>x</code> 起始地址的偏移量，包括可能的空洞。</p>
<p><em>unsafe.Pointer</em><br><code>unsafe.Pointer</code>是特别定义的一种指针类型,，它可以包含任意类型变量的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">f <span class="hljs-type">float64</span><br>temp := unsafe.Pointer(&amp;f) <span class="hljs-comment">//将&amp;f转化为unsafe.Pointer</span><br>temp2 := (*<span class="hljs-type">uint64</span>)temp <span class="hljs-comment">// 将unsafe.Pointer转化为*T指针</span><br></code></pre></td></tr></table></figure>

<p><strong>注意区别</strong></p>
<ul>
<li>不可以直接通过<code>*p</code>来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。</li>
<li><code>unsafe.Pointer</code>指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。</li>
<li>一个<code>unsafe.Pointer</code>指针也可以被转化为<code>uintptr</code>类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。</li>
<li>将<code>unsafe.Pointer</code>指针转为原生数字，然后再转回为<code>unsafe.Pointer</code>类型指针的操作是不安全，因为GC会对内存进行整理，导致对象的地址发送变化，此时<code>unsafe.Pointer</code>会被更新，但<code>uintptr</code>不会。</li>
</ul>
<h2 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#cgo CFLAGS: -I/usr/include</span><br><span class="hljs-comment">#cgo LDFLAGS: -L/usr/lib -lbz2</span><br><span class="hljs-comment">#include &lt;bzlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">bz_stream* bz2alloc() &#123; return calloc(1, sizeof(bz_stream)); &#125;</span><br><span class="hljs-comment">int bz2compress(bz_stream *s, int action,</span><br><span class="hljs-comment">                char *in, unsigned *inlen, char *out, unsigned *outlen);</span><br><span class="hljs-comment">void bz2free(bz_stream* s) &#123; free(s); &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> writer <span class="hljs-keyword">struct</span> &#123;<br>    w      io.Writer <span class="hljs-comment">// underlying output stream</span><br>    stream *C.bz_stream<br>    outbuf [<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>]<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-comment">// NewWriter returns a writer for bzip2-compressed streams.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWriter</span><span class="hljs-params">(out io.Writer)</span></span> io.WriteCloser &#123;<br>    <span class="hljs-keyword">const</span> blockSize = <span class="hljs-number">9</span><br>    <span class="hljs-keyword">const</span> verbosity = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> workFactor = <span class="hljs-number">30</span><br>    w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;<br>    C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)<br>    <span class="hljs-keyword">return</span> w<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实并没有一个叫C的包，但是<code>import &quot;C&quot;</code>语句会让Go编译程序在编译之前先运行cgo工具，该工具会生成一个临时包，该包将包含所有需要在Go语言中访问的C语言的函数或类型。<br>cgo工具通过以某种特殊的方式调用本地的C编译器来发现在Go源文件导入声明前的注释中包含的C头文件中的内容。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/" class="category-chain-item">概念整理</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Go/" class="category-chain-item">Go</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Go/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/" class="category-chain-item">Go语言圣经</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/">#概念整理</a>
      
        <a href="/tags/Go/">#Go</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Go语言圣经</div>
      <div>http://example.com/2023/01/06/概念整理/Golang/Go语言圣经/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/06/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/DDD%E5%BB%BA%E6%A8%A1/DDD%E5%BB%BA%E6%A8%A1/" title="DDD建模语言圣经">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">DDD建模语言圣经</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go-API/" title="Go-API">
                        <span class="hidden-mobile">Go-API</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.7/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo-api-lime.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/fluid-extention.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
