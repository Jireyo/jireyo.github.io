

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#727679">
  <meta name="author" content="Jin">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、数组数组本身性质数组本身的索引的具有信息量，对于很多数组类题目要求时间复杂度O(n)，常量空间复杂度的问题，可以考虑把遍历信息保存在数组内部：  对数组指定索引做标记：加负号； 将数组元素与指定索引元素做交换；  例题41. 缺失的第一个正数442. 数组中重复的数据  标记出现了的数的正负号 将出现了的数交换到对于索引上  数组排序数组中的排序有以下功能：  相同的数字在一起，实现去重 连续">
<meta property="og:type" content="article">
<meta property="og:title" content="算法专题（数组）">
<meta property="og:url" content="http://example.com/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/index.html">
<meta property="og:site_name" content="Jin&#39;s Blog">
<meta property="og:description" content="一、数组数组本身性质数组本身的索引的具有信息量，对于很多数组类题目要求时间复杂度O(n)，常量空间复杂度的问题，可以考虑把遍历信息保存在数组内部：  对数组指定索引做标记：加负号； 将数组元素与指定索引元素做交换；  例题41. 缺失的第一个正数442. 数组中重复的数据  标记出现了的数的正负号 将出现了的数交换到对于索引上  数组排序数组中的排序有以下功能：  相同的数字在一起，实现去重 连续">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Pasted-image-20230209172457.png">
<meta property="article:published_time" content="2023-02-08T08:53:22.000Z">
<meta property="article:modified_time" content="2023-02-18T16:00:29.488Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数组">
<meta property="article:tag" content="字符串">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/Pasted-image-20230209172457.png">
  
  
  
  <title>算法专题（数组） - Jin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong style="color: #fff;">Jin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                归档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法专题（数组）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-08 16:53" pubdate>
          2023年2月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          125 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法专题（数组）</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="数组本身性质"><a href="#数组本身性质" class="headerlink" title="数组本身性质"></a>数组本身性质</h2><p>数组本身的索引的具有信息量，对于很多数组类题目要求时间复杂度O(n)，常量空间复杂度的问题，可以考虑把遍历信息保存在数组内部：</p>
<ul>
<li>对数组指定索引做标记：加负号；</li>
<li>将数组元素与指定索引元素做交换；</li>
</ul>
<p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></p>
<ol>
<li>标记出现了的数的正负号</li>
<li>将出现了的数交换到对于索引上</li>
</ol>
<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>数组中的排序有以下功能：</p>
<ul>
<li>相同的数字在一起，实现去重</li>
<li>连续的数字在一起，可以查看连续序列</li>
<li>两个排序数组对比可以快速比较重合数（使用双指针）</li>
<li>利用排序可以快速筛选结果</li>
</ul>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a><br>本质是硬解，但通过排序保证第一个元素永远不重复，还可以通过一些手段减枝。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a><br>建立绝对值和索引的映射，根据绝对值排序，根据索引取真实值。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/">2171. 拿出最少数目的魔法豆</a><br>拿出最少的数目 &#x3D; 留下最多的数目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumRemoval</span><span class="hljs-params">(<span class="hljs-type">int</span>[] beans)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> beans.length;<br>        Arrays.sort(beans);<br>        <span class="hljs-comment">//max表示最多留下的豆子的数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//sum表示所有豆子数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum += beans[i];<br>            max = Math.max(max,(<span class="hljs-type">long</span>)beans[i] * (n-i));<br>        &#125;<br>        <span class="hljs-comment">//最少拿走的豆子 = 总豆子数 - 最多留下的豆子数。</span><br>        <span class="hljs-keyword">return</span> sum-max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="禁止排序"><a href="#禁止排序" class="headerlink" title="禁止排序"></a>禁止排序</h3><p>对于要求n时间复杂度的数组，优先考虑能否利用数组性质保存遍历结果，否则可以通过set等集合保存遍历结果<br><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>对于数组中的滑动窗口首先要注意问题的转化：</p>
<ul>
<li>对于<strong>从数组左右两端操作的问题能否转化为对数组中的一个滑动窗口</strong>的问题，如《将x减到0的最小操作数》</li>
<li>对于窗口内信息的计算能否转化为对窗口两端存储数据的相减，如使用<strong>预处理</strong>方式处理每个元素左边&#x2F;右边的状态，如《爱生气的书店老板》</li>
<li>差分数组常用于区域<strong>翻转</strong>问题：如将某个数组的一部分翻转（修改正负号或1&#x2F;0变换），判断相邻数的情况。</li>
</ul>
<h3 id="静态滑动窗口"><a href="#静态滑动窗口" class="headerlink" title="静态滑动窗口"></a>静态滑动窗口</h3><p>窗口大小不变。<br>每次滑动伴随元素的新增和删除，一般需要维护窗口的性质：</p>
<ul>
<li>维护窗口内字符数量等统计信息的：使用如hash，数组等的数据结构维护；</li>
<li>维护窗口内最大值，最小值的：使用单调队列（LinkedList结构）。</li>
</ul>
<blockquote>
<p>使用数组维护数量时注意：<br>全大&#x2F;小写字符计数：使用<code>int[26]</code>，char-‘a’或-‘A’<br>大小写都有：使用<code>int[58]</code>，char-‘A’<br>全字符：使用<code>int[128]</code></p>
</blockquote>
<h4 id="维护窗口统计信息"><a href="#维护窗口统计信息" class="headerlink" title="维护窗口统计信息"></a>维护窗口统计信息</h4><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串</a><br>可以使用一个数维护重复值，一个Hash&#x2F;数组维护字符的数量<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a><br>使用预处理数组记录可能获得的顾客<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p>
<ol>
<li>使用计数法，并且不收缩滑动窗口。</li>
<li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li>
</ol>
<h4 id="维护窗口最大值"><a href="#维护窗口最大值" class="headerlink" title="维护窗口最大值"></a>维护窗口最大值</h4><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a><br>右指针元素比队列尾部大则先循环pollLast再OfferLast，即将移出的左指针元素刚好等于队头时pollFirst<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将x减到0的最小操作数</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a><br>使用有序集合维护窗口的最大值和最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Long&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">ceiling</span> <span class="hljs-operator">=</span> set.ceiling((<span class="hljs-type">long</span>) nums[i] - (<span class="hljs-type">long</span>) t);<br>            <span class="hljs-keyword">if</span> (ceiling != <span class="hljs-literal">null</span> &amp;&amp; ceiling &lt;= (<span class="hljs-type">long</span>) nums[i] + (<span class="hljs-type">long</span>) t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            set.add((<span class="hljs-type">long</span>) nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                set.remove((<span class="hljs-type">long</span>) nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>回顾TreeMap的API<br>map.ceilingEntry(key)		&#x2F;&#x2F;刚好或大于该key的Entry<br>map.floorEntry(key)			&#x2F;&#x2F;刚好或小于该key的Entry<br>map.firstEntry(key)			&#x2F;&#x2F;最小的Entry<br>map.lastEntry(key)			&#x2F;&#x2F;最大的Entry<br>HashSet同理。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-median/">480. 滑动窗口中位数</a><br>通过大堆+小堆的堆顶实现取中位数，然后维护有效元素的平衡<br>移出元素时：</p>
<ul>
<li>直接使用remove(Priority提供了这个方法)</li>
<li>用HashMap记录过期元素，延迟删除堆顶元素</li>
</ul>
<h4 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h4><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K连续位的最小翻转次数</a></p>
<blockquote>
<p>假设从index&#x3D;0开始判断，每次翻转只翻转index之后长度为k的区域</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minKBitFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>	    <span class="hljs-comment">//d[x]记录了A[x]相对A[x-1]翻转了多少次，即d[i] = re[i]-re[i-1]</span><br>	    <span class="hljs-comment">//那么第i个数的旋转次数为re[i] = d[0]+d[1]+...+d[i]</span><br>	    <span class="hljs-comment">//只需要维护re[i]，即可直到每个位置是否还需要翻转</span><br>        <span class="hljs-type">int</span>[] d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> count= <span class="hljs-number">0</span> ,sumReA= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>	        <span class="hljs-comment">//sumReA表示当前i位旋转的次数</span><br>            sumReA +=d[i];<br>            <span class="hljs-comment">//若当前旋转结果为0，则需要以当前索引为窗口头部进行一次旋转</span><br>            <span class="hljs-keyword">if</span>(((sumReA&amp;<span class="hljs-number">1</span>)^A[i]) ==<span class="hljs-number">0</span>)&#123;<br>	            <span class="hljs-comment">//若后续已经不能旋转了，说明无法实现</span><br>                <span class="hljs-keyword">if</span>(i+K&gt;A.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//当前位旋转。</span><br>                <span class="hljs-comment">//d[i]+=1; 可省略，后续用不到</span><br>                <span class="hljs-comment">//i+K相对i+K-1少旋转一次</span><br>                d[i+K]-=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//由于d[i]+=1，修正sumReA</span><br>                sumReA+=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//结果++</span><br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="动态滑动窗口"><a href="#动态滑动窗口" class="headerlink" title="动态滑动窗口"></a>动态滑动窗口</h3><p>动态滑动窗口会在合适的时候扩张：</p>
<ul>
<li>使用双指针做窗口条件判断，每循环一次右指针向右扩展一单位，然后考虑左边界的情况。</li>
<li>使用动态规划的方法维护窗口性质，本质就是用数组保存右指针在某处时的窗口状态。</li>
</ul>
<p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a><br>不满足要求后，不根据奇偶判断状态，而是根据上一个序列顺序判断，省去一次遍历，不符合要求时，左指针 &#x3D;&#x3D; 右指针<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a><br>先找到区间，该区间的右扩展全部满足条件，然后收缩左端，每收缩一次计算一次以当前左指针为子数组左端能够得到的子数组数目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> answer=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//abc 的计数</span><br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">//窗口左沿</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//窗口右沿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;end&lt;s.length();end++)&#123;<br>            <span class="hljs-type">char</span> charAtEnd=s.charAt(end);<br>            count[charAtEnd-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">while</span>(count[<span class="hljs-number">0</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">2</span>]&gt;=<span class="hljs-number">1</span>)&#123;<br>                answer+=s.length()-end;<br>                <span class="hljs-type">char</span> charAtStart=s.charAt(start);<br>                count[charAtStart-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                start++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a><br>动态滑动窗口+有序集合</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a><br>自己做时总想记录特殊字符的位置，实现快速搜索，实际上直接遍历过去速度更快。另外，数组总是比hash更方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-comment">//t中出现字符记录</span><br>    <span class="hljs-type">int</span>[] time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> t.length();<br><br>    <span class="hljs-comment">//结果记录</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length()+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;need;i++)&#123;<br>        mark[t.charAt(i)] = <span class="hljs-literal">true</span>;<br>        time[t.charAt(i)]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>        time[s.charAt(i)]--;<br>        <span class="hljs-keyword">if</span>(mark[s.charAt(i)]&amp;&amp;time[s.charAt(i)]&gt;=<span class="hljs-number">0</span>)&#123;<br>            need--;<br>        &#125;<br>        <span class="hljs-comment">//若满足条件，收缩左侧到刚好不满足条件，并计算值</span><br>        <span class="hljs-keyword">if</span>(need == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(need == <span class="hljs-number">0</span>)&#123;<br>                time[s.charAt(start)]++;<br>                <span class="hljs-keyword">if</span>(mark[s.charAt(start)]&amp;&amp;time[s.charAt(start)]&gt;<span class="hljs-number">0</span>)&#123;<br>                    need++;<br>                &#125;<br>                start++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i-start+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(l&lt;length)&#123;<br>                left = start-<span class="hljs-number">1</span>;<br>                right = i+<span class="hljs-number">1</span>;<br>                length = l;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(length == s.length()+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(left,right);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a><br>动态规划：由于每个状态只依赖前一个状态，所以也可以使用变量代替。<br>同时计算最小、最大和的情况即可，主要排除计算最小和时选择了所有数字的情况。</p>
<h3 id="子数组与问题转化"><a href="#子数组与问题转化" class="headerlink" title="子数组与问题转化"></a>子数组与问题转化</h3><p>一般我们有如下定义：<br><strong>子数组</strong>：连续的子数组。<br><strong>子序列</strong>：不连续的子数组。</p>
<p>求满足要求子数组的问题一般分两类解决方案：</p>
<ul>
<li>滑动窗口</li>
<li>问题转化<ul>
<li><strong>恰好问题转化为最大-最大</strong></li>
<li><strong>求最长满足条件的子数组长度问题可以不缩小窗口</strong></li>
<li><strong>元素抵消</strong></li>
</ul>
</li>
<li>动态规划（见动态规划章节）</li>
</ul>
<p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">795. 区间子数组个数</a><br>问题转化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">return</span> count(A, R) - count(A, L-<span class="hljs-number">1</span>);<br>    &#125;<br>	<span class="hljs-comment">//计算最大值小于bound的子数组个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> bound)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: A) &#123;<br>            cur = x &lt;= bound ? cur + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            ans += cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a><br>问题转化 + 动态滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//把恰好问题转化为最大-最大</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysWithKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>);<br>    &#125;<br>	<span class="hljs-comment">//子数组中存在不同整数数量最大为k的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-comment">//记录窗口中元素数量</span><br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 里不同整数的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>        <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>	        <span class="hljs-comment">//添加right元素</span><br>            <span class="hljs-keyword">if</span> (freq[A[right]] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>            freq[A[right]]++;<br>            right++;<br>            <span class="hljs-comment">//若不再满足条件，收缩左端</span><br>            <span class="hljs-keyword">while</span> (count &gt; K) &#123;<br>                freq[A[left]]--;<br>                <span class="hljs-keyword">if</span> (freq[A[left]] == <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献，解释一下，相当于[left,right-1]区间满足count == K，此时以right-1为右节点，向左延申到left，有right-left个数（right-1是因为本轮的right加过1了）</span><br>            res += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a><br>以右指针为目标字符，只需要考虑维护这个最大长度，不用缩短区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> len;<br>        &#125;<br>        <span class="hljs-type">char</span>[] array = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	    <span class="hljs-comment">//maxCount表示在满足条件的区间内出现过的最多的相同字符数量，即maxCount+k 一般等于 当前窗口大小。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">while</span>(right&lt;len)&#123;<br>	        <span class="hljs-comment">//右端字符数量更新</span><br>            freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            <span class="hljs-comment">//看右端字符数量是否超过了历史最多相同字符数量，</span><br>            maxCount = Math.max(maxCount,freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>            right++;<br>            <span class="hljs-comment">//如果区间内右端字符数量+可修改的字符数量比区间小，说明这个区间无法满足条件，左端需要移动来满足条件，这里没有使用where。</span><br>            <span class="hljs-keyword">if</span>(maxCount+k&lt;right-left)&#123;<br>                freq[array[left]-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//确认当前区间的大小</span><br>            res = Math.max(right-left,res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/A1NYOS/">剑指 Offer II 011. 0 和 1 个数相同的子数组</a><br>使用状态量表示1和0数量的差别，通过预处理可以找到匹配的字符串，这里使用HashMap记录相同状态出现的最左索引更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        map.put(counter, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                counter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.containsKey(counter)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> map.get(counter);<br>                maxLength = Math.max(maxLength, i - prevIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(counter, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-good-indices/">2420. 找到所有好下标</a><br>双指针左右遍历，使用两个数组分别记录连续递增&#x2F;减数量。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p>
<ol>
<li>使用计数法，并且不收缩滑动窗口。</li>
<li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li>
</ol>
<h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p>一般为事件在指定时间&#x2F;坐标必然发生&#x2F;结束，需要计算重合情况。<br><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></p>
<ol>
<li>可以使用<strong>优先队列</strong>，将所有会议的开始，结束按时间发送顺序排列，然后遍历处理。</li>
<li>由于题目只要求最多同时需要多少间，因此可以只用<strong>最小堆</strong>记录结束时间，然后采用延迟删除策略。</li>
<li>创建会议开始，结束时间的有序数组，使用双指针。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></p>
<ul>
<li>在插入区间的左侧且无交集的区间可以直接添加。</li>
<li>在插入区间的右侧且无交集的区间也可以直接添加。</li>
<li>其他情况表示有交集，合并方式是取最左和最右侧。<ul>
<li>合并可能多次发生，在多次合并后应该确保合并区间被添加。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//表示是否</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">placed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>	        <span class="hljs-comment">// 在插入区间的右侧且无交集</span><br>            <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; right) &#123;<br>                <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>                <span class="hljs-keyword">if</span> (!placed) &#123;<br>                    ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>                    placed = <span class="hljs-literal">true</span>;                    <br>                &#125;<br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                <span class="hljs-comment">// 在插入区间的左侧且无交集</span><br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 与插入区间有交集，计算它们的并集</span><br>                left = Math.min(left, interval[<span class="hljs-number">0</span>]);<br>                right = Math.max(right, interval[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>        <span class="hljs-keyword">if</span> (!placed) &#123;<br>            ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ansList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ansList.size(); ++i) &#123;<br>            ans[i] = ansList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/">LeetCode讲解</a></p>
<blockquote>
<p>树状数组是一种很巧妙的数据结构，通过树状数组可以很方便的解决<strong>前缀和</strong>问题和<strong>单点更新</strong>。</p>
</blockquote>
<p><img src="/Pasted-image-20230209172457.png" srcset="/img/loading.gif" lazyload><br>树状数组的本质是一种通过 树状组织 数组区间和 的数据结构 可以在更新数组节点时依次更新树结构，方便前缀和的查询。</p>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p>得到二进制数x的最低位1的值。相当于计算出了该数在二进制下的粒度&#x2F;最小单位。</p>
<ul>
<li>节点依次减去其最小二进制单位即得到求和所需的节点</li>
<li>节点加上其最小二进制单位即可得到其父节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="前缀和查询"><a href="#前缀和查询" class="headerlink" title="前缀和查询"></a>前缀和查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从右到左查询</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>	    <span class="hljs-comment">//从节点开始逐一加上前面的节点</span><br>        sum += tree[i];<br>        i -= lowbit(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>比如现在要求前6项的和，6的二进制为0110，可分解为0010+0100，对应的是2+4，可以使用C4+C6来表达这个前6项的和。</p>
<h4 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从节点本身开始更新父节点</span><br>    <span class="hljs-keyword">while</span> (i &lt;= len) &#123;<br>	    tree[i] += delta;<br>	    i += lowbit(i);<br>	&#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>树状数组最小索引为1</strong>，所以创建时长度要+1。然后为每个索引初始化数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FenwickTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-built_in">this</span>.len = nums.length + <span class="hljs-number">1</span>;<br>    tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        update(i, nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a><br>本题很容易想到从右到左遍历，但如何维护右边所有数字的值的大小和数量是一个问题。</p>
<ul>
<li>先使用有序集合，对所有元素进行排序，得到每个元素大小对应的树状数组索引排名并使用Hash记录。(树状数组的索引是连续的，但索引所代表的值大小不需要连续，只需要保持大小关系即可。)</li>
<li>从右到左遍历，通过元素大小获取在树状数组下的索引后，获取值，并更新。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queries-on-a-permutation-with-key/">1409. 查询带键的排列</a></p>
<ul>
<li>扩充数组长度并使用树状数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] processQueries(<span class="hljs-type">int</span>[] queries, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(m + n);<br>        <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            pos[i] = n + i;<br>            bit.update(n + i, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pos[queries[i]];<br>            bit.update(cur, -<span class="hljs-number">1</span>);<br>            ans[i] = bit.query(cur);<br>            cur = n - i;<br>            pos[queries[i]] = cur;<br>            bit.update(cur, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br>  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += a[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            a[x] += dt;<br>            x += lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ways-to-make-a-fair-array/">1664. 生成平衡数组的方案数</a><br>预处理奇数和偶数之和数组，然后枚举删除点。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-good-meals/">1711. 大餐计数</a><br>Hash记录数量，简单遍历即可，每道餐品与前面餐品匹配，不会出现重复情况。</p>
<blockquote>
<p>int MOD &#x3D; (int)1e9+7;</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-subarrays-having-even-product/">2495. 乘积为偶数的子数组数</a><br>只要子数组中有偶数，乘积就为偶数，计算以偶数作为结尾的数组即可。</p>
<div class="note note-primary">
            <p>总结：</p><ol><li>看排序能不能改善计算！</li><li>看问题能不能转化<ul><li>如最多与最少的转化</li><li>两侧与中间区间的转化</li><li><strong>恰好</strong>与<strong>最大-最大</strong>的转化</li><li>是否能使用预处理数组</li></ul></li><li>对于滑动窗口<ul><li>是否一定要缩小窗口</li><li>统计满足条件的子数组时，以左&#x2F;右端点作为开始&#x2F;结束点。</li></ul></li></ol>
          </div>

<hr>
<h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>字符串的很多题目与数组的处理方式类似，因为字符串本身就是一个字符数组。</p>
<div class="note note-success">
            <p>本篇主要为利用双指针移动判定条件解决问题。<br>对于子序列、回文等问题见动态规划篇。</p>
          </div>

<h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p><em>例题</em><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a><br>将具有相同元素的单词分类，对各个字符串分别使用字符数组排序，将排序后的单词作为key做对比。</p>
<h2 id="语义解释"><a href="#语义解释" class="headerlink" title="语义解释"></a>语义解释</h2><p>一般使用双指针，对于计算类需要灵活应用栈，滑动窗口等方法解决。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a><br>类似于操作数栈，但带有正负号，且记录上一次的符号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将遇到的数压栈，碰到乘除时出栈计算再压栈，记录每个数前面的符号。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//第一个数前符号为正</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">preSign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>	        <span class="hljs-comment">//若是数字，则当前数变化</span><br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>                num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">//若是符号，说明当前数字可以入栈了</span><br>            <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>	            <span class="hljs-comment">//根据符号选择入栈的真实值</span><br>                <span class="hljs-keyword">switch</span> (preSign) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        stack.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        stack.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        stack.push(stack.pop() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stack.push(stack.pop() / num);<br>                &#125;<br>                preSign = s.charAt(i);<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            ans += stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a><br>可以正向使用栈遍历，然后对比栈；<br>也可以逆向遍历，双指针一次完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> S.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> T.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">skipS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>	        <span class="hljs-comment">//从右往左移动到第一个有效字符，注意，若没有有效字符了，会变成负数，从而终止。</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipS++;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipS--;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (T.charAt(j) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipT++;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipT--;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//两者都有有效字符，则比较</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            <span class="hljs-comment">//至少有一个已经没有字符了，如果另外一个还有字符，则返回false，当然如果都小于0，可以返回true，但不用写这个逻辑了。</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="比较问题"><a href="#比较问题" class="headerlink" title="比较问题"></a>比较问题</h3><p>一般是双指针，但可以注意循环策略。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/long-pressed-name/">925. 长按键入</a><br>判断对比结束是比较难的，这里以i指针作为考察，如果遍历完成后，i指针指向了字符串末尾就算对比成功。<br>此外，return false包含了很多失败情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLongPressedName</span><span class="hljs-params">(String name, String typed)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; typed.length()) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; name.length() &amp;&amp; name.charAt(i) == typed.charAt(j)) &#123;<br>                i++;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; typed.charAt(j) == typed.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == name.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>到这种双指针对比的问题，很容易遇到很多边界条件，如一个结束了另外一个没结束要接着判断边界等情况：<br>1）<code>while(index1&lt;n1 &amp;&amp; index2&lt;n2)</code>，常规思路，还需要额外判断两者是否到达结束点。<br>2）在一个指针的循环体内判断另一个指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1)&#123;<br>	<span class="hljs-keyword">if</span>(index2&lt;n2)&#123;<br>		<span class="hljs-comment">//代码</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）通过if处理都在界内的情况，然后处理有指针不在界内的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1 || index2&lt;n2)&#123;<br>	<span class="hljs-keyword">if</span>(index1&lt;n1 &amp;&amp; index2&lt;n2)&#123;<br>		<span class="hljs-comment">//代码，</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
          </div>

<h3 id="轮转问题"><a href="#轮转问题" class="headerlink" title="轮转问题"></a>轮转问题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSubstringInWraproundString</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (p.charAt(i) - p.charAt(i - <span class="hljs-number">1</span>) + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 字符之差为 1 或 -25</span><br>                ++k;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k = <span class="hljs-number">1</span>;<br>            &#125;<br>            dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = Math.max(dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>], k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了去重，求以每个字符为结尾的数组长度最大为多少，最后求和。</p>
<blockquote>
<p>z-a相连问题，即两字符之间的差为1或-25，可以将其转化为以下式子：<br>（p.charAt(i) - p.charAt(i - 1) + 26) % 26 &#x3D;&#x3D; 1<br>因为25与-1相差26，将符号修正后对26求余时结果肯定一样。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></p>
<blockquote>
<p>轮转问题一般可以考虑扩充原<strong>数组&#x2F;字符</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFlipedString</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-keyword">if</span>(s2.length() != n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1+s1;<br>        <span class="hljs-keyword">return</span> s3.contains(s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="字符串替换-x2F-编码"><a href="#字符串替换-x2F-编码" class="headerlink" title="字符串替换&#x2F;编码"></a>字符串替换&#x2F;编码</h2><p>一般题目为允许&#x2F;必须替换字符串中的某些字符，以达到某种条件。<br>滑动窗口类题型可见上文，下面为<strong>规律题</strong>：<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/1-bit-and-2-bit-characters/">717. 1 比特与 2 比特字符</a></p>
<ol>
<li>正向推理：遇到0走一格，遇到1走两格，判断最后一次走的是几格。</li>
<li>反向推理：<ul>
<li>如果结尾前为0，则必然为true</li>
<li>如果结尾前是1，则必然为11<ul>
<li>这个11的前面只能接着放11或0结尾的字符，所以判断结尾0到倒数第二个0中间1的个数是否为偶数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a><br>由题可知：<br>L可以与右侧的X交换，R可以与左侧的X交换，但L不可以跨越R。<br>即L可以右移，R可以左移，L和R的顺序不能改变。<br>那么可以忽略X，如果找到对应的L，原始L应该在变化后的L的左侧，原始R应该在变化后的R的右侧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (start.charAt(i) != end.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> start.charAt(i);<br>                <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; i &lt; j) || (c == <span class="hljs-string">&#x27;R&#x27;</span> &amp;&amp; i &gt; j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                i++;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (end.charAt(j) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="category-chain-item">算法整理</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="category-chain-item">算法专题</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
        <a href="/tags/%E6%95%B0%E7%BB%84/">#数组</a>
      
        <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">#字符串</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法专题（数组）</div>
      <div>http://example.com/2023/02/08/算法整理/算法专题/算法专题（数组与字符串）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/" title="算法专题（动态规划）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法专题（动态规划）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/" title="计算机网络-IP">
                        <span class="hidden-mobile">计算机网络-IP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.7/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo-api-lime.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/fluid-extention.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
