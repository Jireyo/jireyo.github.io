

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#727679">
  <meta name="author" content="Jin">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、DFS与BFS例题79. 单词搜索简单的搜索，注意终止条件的写法，由于不需要记录路径，所以不需要使用回溯，成功时直接返回即可。 419. 甲板上的战舰DFS，也可以只找左上角块统计。 248. 中心对称数 III思路：  长度为0的对称数为{null}; 长度为1的对称数为{0,1,8}; 在s的基础上，左右扩充{0+s+0,1+s+1,6+s+9,8+s+8,9+s+6};  1234567">
<meta property="og:type" content="article">
<meta property="og:title" content="算法专题（DFS与BFS）">
<meta property="og:url" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/index.html">
<meta property="og:site_name" content="Jin&#39;s Blog">
<meta property="og:description" content="一、DFS与BFS例题79. 单词搜索简单的搜索，注意终止条件的写法，由于不需要记录路径，所以不需要使用回溯，成功时直接返回即可。 419. 甲板上的战舰DFS，也可以只找左上角块统计。 248. 中心对称数 III思路：  长度为0的对称数为{null}; 长度为1的对称数为{0,1,8}; 在s的基础上，左右扩充{0+s+0,1+s+1,6+s+9,8+s+8,9+s+6};  1234567">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190007.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190717.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233121.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233756.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012352.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012728.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012433.png">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228202925.jpg">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228211251.png">
<meta property="article:published_time" content="2023-02-10T06:03:01.000Z">
<meta property="article:modified_time" content="2023-11-28T06:11:35.903Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="DFS">
<meta property="article:tag" content="BFS">
<meta property="article:tag" content="回溯算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190007.png">
  
  
  
  <title>算法专题（DFS与BFS） - Jin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong style="color: #fff;">Jin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                归档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法专题（DFS与BFS）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-10 14:03" pubdate>
          2023年2月10日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          198 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法专题（DFS与BFS）</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、DFS与BFS"><a href="#一、DFS与BFS" class="headerlink" title="一、DFS与BFS"></a>一、DFS与BFS</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a><br>简单的搜索，注意终止条件的写法，由于不需要记录路径，所以不需要使用回溯，成功时直接返回即可。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/battleships-in-a-board/">419. 甲板上的战舰</a><br>DFS，也可以只找左上角块统计。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/strobogrammatic-number-iii/">248. 中心对称数 III</a><br>思路：</p>
<ul>
<li>长度为0的对称数为{null};</li>
<li>长度为1的对称数为{0,1,8};</li>
<li>在s的基础上，左右扩充{0+s+0,1+s+1,6+s+9,8+s+8,9+s+6};</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strobogrammaticInRange</span><span class="hljs-params">(String low, String high)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=high.length();<br>        <span class="hljs-type">int</span> n=low.length();<br>		<span class="hljs-comment">//如果m == n，直接取所有该长度的对称数，然后判断范围。</span><br>        <span class="hljs-keyword">if</span>(m-n==<span class="hljs-number">0</span>)&#123;<br>           List&lt;String&gt; res=helper(n,n);<br>           <span class="hljs-keyword">for</span>(String s :res)&#123;<br>           <span class="hljs-keyword">if</span>(Long.parseLong(s)&gt;=Long.parseLong(low)&amp;&amp;Long.parseLong(s)&lt;=Long.parseLong(high)) sum++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-comment">//遍历长度为n-&gt;m的所有对称数，注意判断范围</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m; i&gt;=n; i--)&#123;<br>                List&lt;String&gt; res=helper(i,i);<br>                <span class="hljs-keyword">for</span>(String s :res)&#123;<br>                <span class="hljs-keyword">if</span>(Long.parseLong(s)&gt;=Long.parseLong(low)&amp;&amp;Long.parseLong(s)&lt;=Long.parseLong(high)) sum++;<br>               &#125;    <br>            &#125;<br>         <br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-comment">// helper(n,m)求长度为n的对称数</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span>&#123;<br>        <span class="hljs-comment">// 第一步：判断输入或者状态是否合法，可省略</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        if(n&lt;0 || m&lt;0 || n&gt;m)&#123;</span><br><span class="hljs-comment">            throw  new IllegalArgumentException(&quot;invalid input&quot;);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        **/</span><br>        <span class="hljs-comment">// 第二步：初始状态</span><br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>));<br>        <span class="hljs-comment">// 第三步：获取子问题答案</span><br>        List&lt;String&gt; list = helper(n-<span class="hljs-number">2</span>, m);<br>        <span class="hljs-comment">// 第四步：在子问题上，添加字符</span><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list)&#123;<br>            <span class="hljs-keyword">if</span> (n!=m) res.add(<span class="hljs-string">&quot;0&quot;</span>+s+<span class="hljs-string">&quot;0&quot;</span>);<br>                <span class="hljs-comment">// n=m时，表示最外层处理。</span><br>                <span class="hljs-comment">// 例如：原始需求n=m=2, &#x27;00&#x27;不合法</span><br>                <span class="hljs-comment">// 若原始需求n=m=4, 内层循环n=2,m=4,&#x27;00&#x27;;最外层循环，n=m=4时，&#x27;1001&#x27;  </span><br>            res.add(<span class="hljs-string">&quot;1&quot;</span>+s+<span class="hljs-string">&quot;1&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;6&quot;</span>+s+<span class="hljs-string">&quot;9&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;8&quot;</span>+s+<span class="hljs-string">&quot;8&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;9&quot;</span>+s+<span class="hljs-string">&quot;6&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-knight-moves/">1197. 进击的骑士</a><br>在一定范围外只允许逼近目标的尝试。</p>
<h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>用于寻找两数的公约数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> x % y;<br>	<span class="hljs-keyword">while</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>	  x = y;<br>	  y = remainder;<br>	  remainder = x % y;<br>	&#125;<br>	<span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过取余操作求公约数。</p>
<p><em>证明</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs math">令 a = kb + r，即r = a - kb<br>左右同时除a，b的最大公约数d：<br>r/d = a/d - kb/d<br>可知r/d为整数，即d也是r的约数。<br>问题由求a,b的最大公约数变成求b,r的最大公约数。<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/water-and-jug-problem/">365. 水壶问题</a><br><em>1. DFS&#x2F;BFS</em><br>分析情形，每次的操作共6种：装满x水壶、倒空x水壶、x水壶倒入y水壶、装满y水壶、倒空y水壶、y水壶倒入x水壶；递归寻找结果。<br>DFS中减枝：</p>
<ul>
<li>不装已经慢了的水壶</li>
<li>不倒已经空了的水壶</li>
<li>不到达已经到达了的状态（将两水壶的水量处理成int使用set保存）</li>
</ul>
<p><em>2. 贝祖定理</em><br>每次操作只会让水量增加x，增加y，减少x，或减少y，如果装一个不满水桶或倒一个不满水桶呢？</p>
<ul>
<li>两个桶不可能同时有水且不满（每个操作后必然有水桶满或空），因此只有以下几种状态：<ol>
<li>2个空水桶</li>
<li>2个满水桶</li>
<li>1个满水桶，1个空水桶</li>
<li>1个不满水桶，1个空水桶</li>
<li>1个不满水桶，1个满水桶</li>
</ol>
</li>
<li>对于1、2、3状态，不需要考虑，对于4，5状态，没有必要对一个不满进行装满或倒空，其结果等效于1、2、3状态。</li>
<li>因此每次有效操作，只会让水量增加x，增加y，减少x，或减少y。</li>
</ul>
<p>即问题转化是否有a,b满足：ax+by&#x3D;z<br>根据贝祖定理，只有z是x，y的最大公约数的倍数时，该式子才成立。所以问题转化为求x,y最小公约数，可以使用辗转相除法解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canMeasureWater</span><span class="hljs-params">(<span class="hljs-type">int</span> jug1Capacity, <span class="hljs-type">int</span> jug2Capacity, <span class="hljs-type">int</span> targetCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span>(targetCapacity&gt;jug1Capacity+jug2Capacity) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> gcd(jug1Capacity,jug2Capacity);<br>        <span class="hljs-keyword">return</span> targetCapacity%temp == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> x%y;<br>        <span class="hljs-keyword">while</span>(r != <span class="hljs-number">0</span>)&#123;<br>            x = y;<br>            y = r;<br>            r = x%y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>将树视为一个无向图，则任意两节点之间，都存在距离（两节点直连则距离为1），两节点节点之间的最长距离，就是这棵树的直径。<br>求树直径的方法主要为：2次DFS&#x2F;BFS（1次找直径的一个端点，1次找另一个端点）。<br>证明：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AC__dream/article/details/119101320">CSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树</a><br>BFS&#x2F;DFS求直径端点，同时记录路径，便于找直径的中点（1个节点或2个节点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">//根据边的信息，创建图结构</span><br>        List&lt;List&lt;Integer&gt;&gt; edgeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            edgeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge:edges)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">1</span>];<br>            edgeList.get(x).add(y);<br>            edgeList.get(y).add(x);<br>        &#125;<br>        <span class="hljs-comment">//parent数组记录了遍历时节点之间路径</span><br>        <span class="hljs-type">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">//直径的第一个端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> mostDeepNode(edgeList,<span class="hljs-number">0</span>,n,parent);<br>        <span class="hljs-comment">//复位parent</span><br>        Arrays.fill(parent,-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//直径的第二个端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> mostDeepNode(edgeList,x,n,parent);<br>        <span class="hljs-comment">//将直径的路径从parent中取出</span><br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(y != -<span class="hljs-number">1</span>)&#123;<br>            path.add(y);<br>            y = parent[y];<br>        &#125;<br>        <span class="hljs-comment">//取路径中点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> path.size();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans.add(path.get(length/<span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">if</span>(length%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            ans.add(path.get((length-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//bfs求直径端点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mostDeepNode</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>[] parent)</span>&#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.add(root);<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        visited[root] =<span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            temp = deque.poll();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:list.get(temp))&#123;<br>                <span class="hljs-keyword">if</span>(!visited[next])&#123;<br>                    visited[next] = <span class="hljs-literal">true</span>;<br>                    parent[next] = temp;<br>                    deque.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a><br>先建立数字与字母<code>Map&lt;Integer,List&lt;Character&gt;&gt;</code>，使用一个<code>StringBuilder</code>，每层做循环，添加和删除末尾，当长度达到要求时返回一个记录并保存。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a><br>记录左右括号的数量作为参数传递，左括号数量-右括号数量&gt;&#x3D;0时才能加右括号。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p>
<blockquote>
<p>注意复制list的方法：构造函数<code>new ArrayList&lt;T&gt;(Collection&lt;T&gt;)</code></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索 II</a><br>要一次实现对每个单词的匹配，就不要有方向的寻找路径，而是枚举路径，只要判断出有一个单词之后就不会再核对这个路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯，不要对每个单词单独遍历，太慢超时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[][] board;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] _board, String[] words)</span> &#123;<br>        board = _board;<br>        m = board.length; n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (String w : words) set.add(w);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;<br>                sb.append(board[i][j]);<br>                dfs(i, j, sb);<br>                vis[i][j] = <span class="hljs-literal">false</span>;<br>                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, StringBuilder sb)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (set.contains(sb.toString())) &#123;<br>            ans.add(sb.toString());<br>            set.remove(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> i + d[<span class="hljs-number">0</span>], dy = j + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span> || dx &gt;= m || dy &lt; <span class="hljs-number">0</span> || dy &gt;= n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[dx][dy]) <span class="hljs-keyword">continue</span>;<br>            vis[dx][dy] = <span class="hljs-literal">true</span>;<br>            sb.append(board[dx][dy]);<br>            dfs(dx, dy, sb);<br>            vis[dx][dy] = <span class="hljs-literal">false</span>;<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></p>
<ul>
<li>使用列数组，主对角线数组，副对角线数组保存每一列，对角线已经被使用的情况。</li>
<li>逐行遍历，每行逐一尝试当前可以填入的位置，并对该位置作出限制，递归，实现摆放后，返回一个结果。</li>
<li>过程中只需要记录各行中摆放的位置<code>List</code>，最后根据这个生成棋盘<code>char[][]</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></p>
<ul>
<li>通过行数组，列数组，块数组，各使用一个int采用状态压缩的方式对后续填写作出限制。</li>
<li>将所有空棋放入一个list中，逐个选择，对选择出的棋子位置，遍历所有可能的选择，遇到成功即可返回true。（本质上是暴力尝试，遇到死局会返回）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></p>
<ul>
<li>遇到数字则直接填入</li>
<li>遇到字母则先填入，然后回溯尝试字母的大（小）写</li>
</ul>
<blockquote>
<p>Character.isDigit(char c); 判断字符是数字；<br>Character.isLetter(char c); 判断字符是字母；</p>
<ul>
<li>小写字母(a-&gt;z)的ASCII，97-&gt;122;</li>
<li>大写字母(A-&gt;Z)的ASCII，65-&gt;90;</li>
<li>可见之间隔了32，因此若要进行大小写转换，可以以90为界限，加减32即可。</li>
<li>若要保存数字+字母，使用<code>int[128]</code>即可</li>
<li>若只保存字母，使用<code>int[58]</code>即可，索引为<code>c-&#39;A&#39;</code>。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a><br>注意题目，同一个元素不能以相同的身份出现在一个组合中。<br>采取先排序，然后剪枝的方法，避免全排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//全局记录答案</span><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><span class="hljs-comment">//记录元素是否使用，用于回溯</span><br><span class="hljs-type">boolean</span>[] used;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>	<span class="hljs-comment">//先排序</span><br>	Arrays.sort(candidates);<br>	used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>	dfs(<span class="hljs-number">0</span>,candidates,target,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//当前索引，距离target还差多少</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,List&lt;Integer&gt; list)</span>&#123;<br>	<span class="hljs-comment">//找到一个结果</span><br>	<span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>		res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list));<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">//如果已经超过阈值/索引到达末尾/当前待选 == 上一个待选，且上一个没选，剪枝。</span><br>	<span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span> || index&gt;=candidates.length || index&gt;<span class="hljs-number">0</span>&amp;&amp;candidates[index]==candidates[index-<span class="hljs-number">1</span>]&amp;&amp;used[index-<span class="hljs-number">1</span>] ==<span class="hljs-literal">false</span>)&#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> candidates[index];<br>	list.add(temp);<br>	used[index] = <span class="hljs-literal">true</span>;<br>	dfs(index+<span class="hljs-number">1</span>,candidates,target-temp,list);<br>	list.remove(list.size()-<span class="hljs-number">1</span>);<br>	used[index] = <span class="hljs-literal">false</span>;<br>	dfs(index+<span class="hljs-number">1</span>,candidates,target,list);<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-primary">
            <p>将本题与火柴题对比：<br>相同点在于，根据题目的要求，判断能否走下去只取决于状态，不取决于选择顺序（实际上，顺序在dp和dfs中就做过枚举处理），只要有一种顺序方案成功，这个状态就是成功的。因此这两题如果要使用dp方法做，都不需要保存某物品作为最后一个选择时的情形，即维度只有状态。</p><p>比较dp和dfs的区别：</p><ul><li>dp时（转移方程是反向思维），对于某个状态s，<strong>枚举</strong>上一个状态s1，即可得知该状态是否可达。最后列举到最后状态<code>dp[(1&lt;&lt;n)-1]</code>即可得知结果。</li><li>dfs+回溯时（转移方程是正向思维），通过初始状态，<strong>枚举</strong>可选择的火柴，寻找后续状态的可行性。</li><li>因为枚举的方向不同，所以dfs判断无法到达结果后，可以直接剪枝，dp则会遍历所有的情况。</li><li>本题显然需要剪枝，使用dfs较好，且在结果中要返回该方案本身，回溯更好处理。</li></ul>
          </div>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a><br>排序去重，注意剪枝的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        n = nums.length;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//索引，上一个索引是否使用，当前状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span> lastUsed,List&lt;Integer&gt; cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里注意，要先允许跳过该位置</span><br>        dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>,cur);<br>        <span class="hljs-comment">//然后再判断该位置能否选择，从而剪枝</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] &amp;&amp; !lastUsed) <span class="hljs-keyword">return</span>;<br>        cur.add(nums[i]);<br>        dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>,cur);<br>        cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-tile-possibilities/">1079. 活字印刷</a><br>与子集2对比：</p>
<ul>
<li>对于子集而言，元素的顺序是无关紧要的，只要数量上不重复就是唯一子集，而本处的序列需要考虑元素的选择顺序</li>
</ul>
<p>先不考虑重复的情况下：</p>
<ul>
<li>对于子集的枚举，只需要逐一判断每个元素是否选择，并记录状态即可。是一个单根节点的问题。</li>
<li>对于子序列的枚举，还要针对下一个元素选择哪一个&#x2F;或不选进行遍历，如下图所示。</li>
</ul>
<p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190007.png" srcset="/img/loading.gif" lazyload><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190717.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>dfs，排序剪枝头，通过排序+顺序遍历保证了每次使用一个字母时，使用的是最左侧的该字母。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilePossibilities</span><span class="hljs-params">(String tiles)</span> &#123;<br>        <span class="hljs-comment">//题目中字母序列不同与子序列，是无序的。</span><br>        <span class="hljs-comment">//为了去重，排序</span><br>        n = tiles.length();<br>        s = tiles.toCharArray();<br>        Arrays.sort(s);<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[j] || (j&gt;<span class="hljs-number">0</span> &amp;&amp; s[j] == s[j-<span class="hljs-number">1</span>] &amp;&amp; !visited[j-<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;<br>            visited[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//每次添加字符后，必然得到一个未见过的序列。</span><br>            res++;<br>            dfs(i+<span class="hljs-number">1</span>);<br>            visited[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>统计各字母个数，每次从26个字母中选择，而不是从剩余元素（可能有重复字母）中选择。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-distinct-islands/">694. 不同岛屿的数量</a><br>利用回溯序列固定形状。</p>
<h1 id="三、图"><a href="#三、图" class="headerlink" title="三、图"></a>三、图</h1><p>图的题目主要为各个节点之间相互连接的问题，常常需要结合dfs，bfs，探索相邻点得到答案。</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>拓扑排序中没有环，是一个无环图。</li>
</ul>
<h3 id="常见的处理方式"><a href="#常见的处理方式" class="headerlink" title="常见的处理方式"></a>常见的处理方式</h3><h4 id="正向思维-x2F-BFS"><a href="#正向思维-x2F-BFS" class="headerlink" title="正向思维&#x2F;BFS"></a>正向思维&#x2F;BFS</h4><p>节点之间有前后依赖关系，可以先统计每个节点的入度：</p>
<ul>
<li>将入度为0的节点放入队列中</li>
<li>逐一取出队列中节点，取出节点A时消去所有依赖节点A的节点B们的一个入度，如果某节点入度为0，表示其已经可以被消去，入队。</li>
<li>循环出队的过程</li>
</ul>
<h4 id="逆向思维-x2F-DFS"><a href="#逆向思维-x2F-DFS" class="headerlink" title="逆向思维&#x2F;DFS"></a>逆向思维&#x2F;DFS</h4><p>每个节点有三种状态：未搜索，搜索中，搜索完毕。类似JVM回收三色标记，本质上是先将出度为0的节点标记完成：</p>
<ul>
<li>对任意一个节点开始进行搜索直接&#x2F;间接依赖该节点的若干节点，并将该节点标记为<strong>搜索中</strong>：</li>
<li>搜索该节点的临近节点DFS，当某节点和直接&#x2F;间接依赖该节点的若干节点都<strong>搜索完毕</strong>后，该节点才能标至为<strong>搜索完毕</strong>。</li>
<li>利用拓扑排序中没有环的性质，从任意一点开始搜索，都不会搜索回自己，即在dfs时不可能遇到一个<strong>搜索中</strong>的节点，可以据此判断拓扑排序是否成立。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a><br>正向&#x2F;逆向思维均可。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">210. 课程表 Ⅱ</a><br>为了获取课程学习顺序，使用正向思维。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a><br>出度和入度倒置就可以了。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/alien-dictionary/">269. 火星词典</a><br>本题的难点：</p>
<ul>
<li>如何记录优先级：可以拓扑排序！</li>
<li>由于题目不允许任何非法排序：<ul>
<li>不可以有前缀相同但更长的单词（字典规则）</li>
<li>对于游离的节点，本题允许对其排序，所以直接将其作为入度为0的节点处理即可，如果不允许，还需要额外处理。<ul>
<li>如果不允许出现游离节点，可以在统计后判断哪些节点，既没有出度也没有入度。</li>
</ul>
</li>
<li>不能有环（非法顺序）。<ul>
<li>对于环问题，会使拓扑排序提前结束（环上的节点入度永远不可能为0），可以比较<strong>总节点数</strong>和在<strong>排序链上的节点数</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>本题有 出度详细统计 和 入度数量统计 作为全局变量，可以灵活判断是否初始化这两个变量来顺便实现统计：<ul>
<li>如本题利用出度详细统计，统计了全部节点数量。</li>
<li>如果遇到要处理游离节点的问题：<ul>
<li>如果想要找到游离节点：可以在完成图建立后，统计入度为0中出度为空的节点。</li>
<li>如果只想忽视游离节点：可以只对有入度和出度的节点做并集统计，游离节点则不在这两者中，具体而言，选择根节点时，在所有有出度的节点中寻找入度为0或不存在的即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//记录出边</span><br>    Map&lt;Character,List&lt;Character&gt;&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//记录入度</span><br>    Map&lt;Character,Integer&gt; in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//是否合法</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-comment">//初始化出边，入度不能初始化（有的字母无法判断任何顺序关系，不能认为其在最前面）</span><br>        <span class="hljs-keyword">for</span>(String word:words)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.length();i++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                edges.putIfAbsent(c,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Character&gt;());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//比较字符串，添加字符顺序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n &amp;&amp; valid;i++)&#123;<br>            compare(words[i-<span class="hljs-number">1</span>],words[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!valid)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//字符队列</span><br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//所有有出边的字符</span><br>        Set&lt;Character&gt; letterSet = edges.keySet();<br>        <span class="hljs-comment">//遍历这些有出边的字符，如果其没有入度，则可以作为根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> u : letterSet) &#123;<br>            <span class="hljs-keyword">if</span> (!in.containsKey(u)) &#123;<br>                deque.offer(u);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            sb.append(c);<br>            List&lt;Character&gt; neigh = edges.get(c);<br>            <span class="hljs-keyword">for</span>(Character c2:neigh)&#123;<br>                in.put(c2,in.get(c2)-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(in.get(c2) == <span class="hljs-number">0</span>)&#123;<br>                    deque.offerLast(c2);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.length() == edges.size() ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>        <br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1,String s2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(s1.length(),s2.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s1.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s2.charAt(i);<br>            <span class="hljs-keyword">if</span>(s1.charAt(i) != s2.charAt(i))&#123;<br>                edges.get(c1).add(c2);<br>                in.put(c2,in.getOrDefault(c2,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == len &amp;&amp; s1.length()&gt;s2.length())&#123;<br>            valid = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fpTFWP/">LCR 112. 矩阵中的最长递增路径</a></p>
<h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>参考题目<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cracking-the-safe/">753. 破解保险箱</a><br><em>分析：</em><br>最优解肯定是对于一个初始密码000，每次只在后面添加一个数字就可以得到一个新密码，如<code>0[001]</code>，可见影响下一个密码选项的是当前密码除第一位的数。我们视这样的数为一个节点。我们可以从00节点开始，它可以选择0，1两个后续数，整个密码像一个滑动窗口模型。</p>
<p><em>欧拉回路：</em><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233121.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul>
<li>每个节点都有若干的出度（下一步选项），因此也有若干的入度（对称性）。</li>
</ul>
<p><em>推论：</em><br>从某个节点开始遍历，一定可以恰好回到该节点。（因为第一个出度给出去了，最后一个入度会回到这个点。对于本题，我们只需要保证，通过一次遍历能够遍历到所有节点即可。）</p>
<h3 id="常见处理方式"><a href="#常见处理方式" class="headerlink" title="常见处理方式"></a>常见处理方式</h3><h4 id="Hierholzer-算法（倒序）"><a href="#Hierholzer-算法（倒序）" class="headerlink" title="Hierholzer 算法（倒序）"></a>Hierholzer 算法（倒序）</h4><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233756.png" srcset="/img/loading.gif" lazyload><br><em>代码实现：</em><br>节点可能会重复，但路径（也就是密码，比节点多一位）永远不会重复，通过记录密码就可以防止走重复的路径，从000开始搜索密码。</p>
<ul>
<li>有一个很重要的技巧，就是dfs之后再添加该节点：<ul>
<li>在某个节点状态Node下，可能有多个下次可成功密码。</li>
<li>在尝试下一个密码A成功时，并不能保证这个路径可以遍历所有路径，如果沿着这条路走到原点，并顺序添加路径到sb上，则sb的末尾不再是该节点Node，因此无法尝试另一个密码B。</li>
<li>我们可以倒序添加路径到sb上，先把v-&gt;u的路径以u-&gt;v的方式保存在sb上，此时v即可继续尝试下一个密码。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-type">int</span> highest;<br>    <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>	    <span class="hljs-comment">//最高位的单位，若n=3，highest=100</span><br>        highest = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-comment">//从00开始搜索</span><br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//ans，填充若干个0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>	<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>	    <span class="hljs-comment">//下一个可选择的字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; k; ++x) &#123;<br>	        <span class="hljs-comment">//下一个尝试密码</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nei</span> <span class="hljs-operator">=</span> node * <span class="hljs-number">10</span> + x;<br>            <span class="hljs-comment">//如果这个密码没有被尝试过</span><br>            <span class="hljs-keyword">if</span> (!seen.contains(nei)) &#123;<br>	            <span class="hljs-comment">//则将该节点添加到已见过的密码</span><br>                seen.add(nei);<br>                <span class="hljs-comment">//搜索该节点</span><br>                dfs(nei % highest);<br>                <span class="hljs-comment">//最后将该字符添加到sb末尾，所以sb是倒序的，最后结尾时加00。</span><br>                ans.append(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012352.png" srcset="/img/loading.gif" lazyload><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012728.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="贪心（顺序）"><a href="#贪心（顺序）" class="headerlink" title="贪心（顺序）"></a>贪心（顺序）</h4><p>我们选择”00”作为起始点。但是每次要选择添加的数字时，从大数字开始（即从 k-1遍历到 00）。这样可以尽可能晚地回到起始点。</p>
<ul>
<li>很显然，一直添加最小值0，会快速回到起始点。</li>
<li>事实上，Hierholzer算法中，下一个可选择字符是从小到达遍历的，所以从程序顺序角度看肯定会尽可能早的遍历回起点，因此要做倒序，先把最后这一段添加到sb中，再看其他未走过的路径。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span>&#123;<br>     <span class="hljs-comment">//map记录一个节点当前剩余的最大出边，最大为K-1。</span><br>     Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-comment">//所有节点的所有路径之和</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">kn</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(k,n);<span class="hljs-comment">//路径总数量</span><br>     <span class="hljs-comment">//一个节点有n-1个数字</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">kn_1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(k,n-<span class="hljs-number">1</span>);<span class="hljs-comment">//结点总数量</span><br>     <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>     <span class="hljs-comment">//初始结点为000...</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>         ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>     &#125;<br>     <span class="hljs-comment">//如果密码长度为1，没有出入度，单纯枚举</span><br>     <span class="hljs-keyword">if</span>(ans.length() == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; k; i++)&#123;<br>             ans.append(i);<br>         &#125;<br>         <span class="hljs-keyword">return</span> ans.toString();<br>     &#125;<br>     <span class="hljs-comment">//遍历所有的路</span><br>     <span class="hljs-keyword">while</span> (kn != <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-comment">//获取当前节点</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> ans.substring(ans.length() - n + <span class="hljs-number">1</span>, ans.length());<br>         <span class="hljs-comment">//初始化节点</span><br>         <span class="hljs-keyword">if</span>(!map.containsKey(substring)) map.put(substring,k-<span class="hljs-number">1</span>);<br>         <span class="hljs-comment">//将当前节点的最大边添加到结果中</span><br>         ans.append(map.get(substring));<br>         <span class="hljs-comment">//删除当前节点的最大边</span><br>         map.put(substring,map.get(substring) - <span class="hljs-number">1</span>);<br>         kn--;<br>     &#125;<br>     <span class="hljs-keyword">return</span> ans.toString();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012433.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br>	<span class="hljs-type">int</span>[] parent;<br>	<span class="hljs-type">int</span>[] size;<br>	<span class="hljs-type">int</span> setCount;<br>	<span class="hljs-type">int</span> n;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>		<span class="hljs-built_in">this</span>.n = n;<br>		<span class="hljs-built_in">this</span>.setCount = n;<br>		<span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>		<span class="hljs-built_in">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>		Arrays.fill(size,<span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>			parent[i] = i;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>		<span class="hljs-keyword">return</span> parent[x] == x?x:(parent[x] = root(parent[x]));<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>		x = root(x);<br>		y = root(y);<br>		<span class="hljs-keyword">if</span>(x == y)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>			x = x^y;<br>			y = x^y;<br>			x = x^y;<br>		&#125;<br>		parent[y] = x;<br>		size[x] += size[y];<br>		setCount--;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>		<span class="hljs-keyword">return</span> root(x) == root(y);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></p>
<ol>
<li>染色，将两个连接的元素标上不同的颜色，如果遇到颜色冲突，则说明无法形成二分图。</li>
<li>并查集，通过</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-maximum-minimum-value/">1102. 得分最高的路径</a></p>
<ol>
<li>遍历：使用<code>boolean[][]</code>记录已经访问过的路径+dfs回溯，携带路径上的最小值，到达终点时更新答案。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] DIRECTIONS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumMinimumPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//右侧为首尾中最小值，表示想要走通能够遇到的最小值，最大也只能为right。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(grid,m,n,mid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(pass == <span class="hljs-literal">true</span>)&#123;<br>                left = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=n||visited[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(grid[x][y]&lt;mid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(x == m-<span class="hljs-number">1</span> &amp;&amp; y == n-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] direction:DIRECTIONS)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> x + direction[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> y + direction[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dfs(grid,m,n,mid,x1,y1))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>二分：通过限制最小分数min，并判断只能走比min分数大的方块时到达终点的可行性。</li>
<li>并查集：为每个边赋予分数（两个节点中较大的），然后按照分数从大到小激活点（与已经激活的点相连接），直到首节点和尾节点相连。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a><br>并查集逐渐添加边解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> heights.length;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights[<span class="hljs-number">0</span>].length;<br>	List&lt;<span class="hljs-type">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i * n + j;<br>			<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>				edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j])&#125;);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>				edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - <span class="hljs-number">1</span>, id, Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>])&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>	edges.sort((a,b) -&gt; a[<span class="hljs-number">2</span>]-b[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">	Collections.sort(edges, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="hljs-comment">		public int compare(int[] edge1, int[] edge2) &#123;</span><br><span class="hljs-comment">			return edge1[2] - edge2[2];</span><br><span class="hljs-comment">		&#125;</span><br><span class="hljs-comment">	&#125;);</span><br><span class="hljs-comment">**/</span><br>	<span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(m * n);<br>	<span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], v = edge[<span class="hljs-number">2</span>];<br>		uf.unite(x, y);<br>		<span class="hljs-keyword">if</span> (uf.connected(<span class="hljs-number">0</span>, m * n - <span class="hljs-number">1</span>)) &#123;<br>			ans = v;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands-ii/">305. 岛屿数量 II</a></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul>
<li>场景：Dijkstra算法主要用于解决带权重的有向图，权重只能为正值，是经典的求<strong>单源最短路径</strong>的一种方法。</li>
<li>思路：Dijkstra算法采用的是一种贪心的策略：<ul>
<li>创建数组记录每个点到源点的距离</li>
<li>创建一个优先队列，放入源点的邻点，按照与源点的距离从小到大排列</li>
<li>每次取出距离源点最近的点，该点到源点的距离即为最终距离，此时还需要标记该点为已完成，如果优先队列中后续遇到该点则忽略（肯定是距离更远的路径）</li>
<li>计算该点的邻点在以该点为桥梁时距离源点的距离，将这些点加入优先队列。（点可能在此阶段被重复加入优先队列）</li>
<li>一直执行直到优先队列为空</li>
</ul>
</li>
<li>复杂度：时间根据遍历最近点的方案（使用遍历时最大为n^2，使用二叉堆时最小为nlogn）；空间（n）；</li>
</ul>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><ul>
<li>场景：Floyd算法可以解决带负权重边（不能解决负权回路）的问题，是经典的求<strong>多源最短路径</strong>的一种方法。</li>
<li>思路：<ul>
<li>有以下两个对称矩阵：<ul>
<li>两点之间最短距离矩阵D</li>
<li>两点之间最短距离所经过的中介点矩阵P</li>
</ul>
</li>
<li>通过遍历各个点为中介点，看是否能其他点之间缩短距离，缩短后更新D、P。</li>
</ul>
</li>
<li>复杂度：时间（n^3），空间（n^2）；</li>
</ul>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>对于无向有权图，寻找一个所有点连通而路径权重最小的图。</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><ul>
<li>思路：从任一节点开始搜索，每次选择距离当前集合最近的点加入集合，已经搜过的不重复搜，直到所有节点都完成搜索。</li>
<li>复杂度：O(n^2)</li>
</ul>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><ul>
<li>思路：将所有边按照权重从小到大排列，每次取最小权重且两顶点当前不在一个集合的边，直到所有节点连接。</li>
<li>复杂度：O(n+mlogm)，排序(mlogm)加出栈(n)。</li>
</ul>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></p>
<ol>
<li>dfs配合visited数组秒杀。</li>
<li>并查集也可以</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a><br>贪心做法容易预先填入，后面因为冲突而无法处理的情况。<br>这里可以先把所有边统计起来，每个花园只影响比其编号大的花园的选择限制（通过位运算标记），这样后面的选择肯定不会干涉已经选择了的花园。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] gardenNoAdj(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] paths) &#123;<br>        <span class="hljs-type">int</span>[] canPicks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        HashMap&lt;Integer,Set&lt;Integer&gt;&gt; connected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] path:paths)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> end;<br>                end = start;<br>                start = temp;<br>            &#125;<br>            connected.putIfAbsent(start,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>            connected.get(start).add(end);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">canPick</span> <span class="hljs-operator">=</span> canPicks[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(((canPick&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                    ans[i-<span class="hljs-number">1</span>] = j+<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(connected.get(i) != <span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:connected.get(i))&#123;<br>                            canPicks[next] |= <span class="hljs-number">1</span>&lt;&lt;j;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/">1059. 从始点到终点的所有路径</a><br>注意代码严谨性！</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-maze-ii/">505. 迷宫 II</a><br>使用Dijkstra迭代长度，确定单源最远距离</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// floyd</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[] ans = &#123;Integer.MAX_VALUE / <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span>[][] mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(mp[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] eg : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> eg[<span class="hljs-number">0</span>], to = eg[<span class="hljs-number">1</span>], weight = eg[<span class="hljs-number">2</span>];<br>            mp[from][to] = mp[to][from] = weight;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            mp[k][k] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    mp[i][j] = Math.min(mp[i][j], mp[i][k] + mp[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (mp[i][j] &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= ans[<span class="hljs-number">0</span>]) &#123;<br>                ans[<span class="hljs-number">0</span>] = cnt;<br>                ans[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dijkstra</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[] ans = &#123;Integer.MAX_VALUE / <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span>[][] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">int</span>[][] mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(dis[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>            Arrays.fill(mp[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] eg : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> eg[<span class="hljs-number">0</span>], to = eg[<span class="hljs-number">1</span>], weight = eg[<span class="hljs-number">2</span>];<br>            mp[from][to] = mp[to][from] = weight;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dis[i][i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 循环n次，寻找最近的点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 寻找距离i最近的节点t</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (!vis[i][k] &amp;&amp; (t == -<span class="hljs-number">1</span> || dis[i][k] &lt; dis[i][t])) &#123;<br>                        t = k;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 使用该节点更新所有与t临近的点k与i的距离</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>                    dis[i][k] = Math.min(dis[i][k], dis[i][t] + mp[t][k]);<br>                &#125;<br>                <span class="hljs-comment">// 将t标记为搜索完成</span><br>                vis[i][t] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (dis[i][j] &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= ans[<span class="hljs-number">0</span>]) &#123;<br>                ans[<span class="hljs-number">0</span>] = cnt;<br>                ans[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="四、前缀树"><a href="#四、前缀树" class="headerlink" title="四、前缀树"></a>四、前缀树</h1><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>	<span class="hljs-comment">//可以使用数组</span><br>    <span class="hljs-keyword">public</span> Trie[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br>	<span class="hljs-comment">//也可以使用hash</span><br>	<span class="hljs-comment">//public Map&lt;?,Trie&gt; children = new HashMap&lt;&gt;();</span><br><br>	<span class="hljs-comment">//可以记录本节点是一个单词结束点，也可以记录本节点所对应的单词等</span><br>    <span class="hljs-comment">//boolean isEnd = null;</span><br>    <span class="hljs-comment">//public String word = null;</span><br><br>	<span class="hljs-comment">//获取指定字符的节点</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br>	<span class="hljs-comment">//插入单词</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>)<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            node = node.children[<span class="hljs-type">char</span>];<br>        &#125;<br>        <span class="hljs-comment">//node.isEnd = true;</span><br>        <span class="hljs-comment">//node.word = word;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-squares/">425. 单词方块</a></p>
<ul>
<li>先根据题目集合建立字典树（每个节点都记录当前字符串）</li>
<li>单词方块中的单词数量 &#x3D; 题目中单词的长度</li>
<li>建立方块数组，枚举第一个单词<ul>
<li>在前面单词的限制下得到后续单词的前缀，利用前缀树快速判断是否存在该前缀，若不存在直接返回，若存在则继续枚举。</li>
<li>直到填满方块，返回。</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228202925.jpg" srcset="/img/loading.gif" lazyload></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-pairs/">336. 回文对</a><br>分析：<br>对于两个单词(word1+word2)组成回文对，有三种情况：</p>
<ul>
<li>情形1：word1.length&gt;word2.length，此时应该满足，word1的前段与word2成回文，word1剩余长度自成回文。</li>
<li>情形2：word1.length&lt;word2.length，此时应该满足，word2的后段与word1成回文，word2前面部分自成回文。</li>
<li>情形3：word1.length &#x3D;&#x3D; word2.length，此时可以考虑为前面情况的特殊情况。</li>
</ul>
<p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228211251.png" srcset="/img/loading.gif" lazyload><br>思路：</p>
<ul>
<li>为了比较回文，先为所有单词<strong>逆序</strong>构建字典树。同时记录每个单词的末尾是否为回文。</li>
<li>顺序遍历单词，在字典树中寻找<ul>
<li>为了处理情况1，word1的字符每走一步，判断一次word1后半段是否为回文，若是，则看这时有哪些word2（节点的words列表）。</li>
<li>为了处理情况2，word1的字符遍历结束时，看该节点是否有后缀的回文串。</li>
<li>情况3，可包含在情况1或2中解决。(节点的prefix列表)。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">palindromePairs</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-comment">// 字典树的插入，注意维护每个节点上的两个列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>	        <span class="hljs-comment">//倒序单词</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rev</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(words[i]).reverse().toString();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-comment">//如果本单词本身就是回文串，则将根节点的前缀列表上添加i</span><br>            <span class="hljs-keyword">if</span> (isPalindrome(rev.substring(<span class="hljs-number">0</span>))) cur.suffixs.add(i);<br>            <span class="hljs-comment">//插入单词</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; rev.length(); j++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> rev.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">null</span>) cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>                cur = cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-comment">//如果倒序单词的后缀是回文串，则说明原单词的前缀是回文串</span><br>                <span class="hljs-keyword">if</span> (isPalindrome(rev.substring(j+<span class="hljs-number">1</span>))) cur.suffixs.add(i);<br>            &#125;<br>            <span class="hljs-comment">//最后在该节点的word列表中添加i</span><br>            cur.words.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 用以存放答案的列表</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//枚举单词</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//枚举字符</span><br>            <span class="hljs-keyword">for</span> ( ;j &lt; word.length(); j++) &#123;<br>                <span class="hljs-comment">// 到j位置，后续字符串若是回文对，则在该节点位置上所有单词都可以与words[i]构成回文对 即 word+words[i]是回文对</span><br>                <span class="hljs-keyword">if</span>(isPalindrome(word.substring(j))) <br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : cur.words) <br>                        <span class="hljs-keyword">if</span> (k != i) ans.add(Arrays.asList(i,k));<br>                <span class="hljs-comment">// </span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>                cur = cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br><br>            &#125;<br>            <span class="hljs-comment">// words[i]遍历完了，现在找所有大于words[i]长度且符合要求的单词，suffixs列表就派上用场了:)</span><br>            <span class="hljs-keyword">if</span> (j == word.length()) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : cur.suffixs) <br>                    <span class="hljs-keyword">if</span> (k != i) ans.add(Arrays.asList(i,k));<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>    <span class="hljs-comment">//  判断一个字符串是否是回文字符串</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String w)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = w.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (w.charAt(i) != w.charAt(j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++; j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> Node[] children;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; words;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; suffixs;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-built_in">this</span>.words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.suffixs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>反转String的API：<code>new StringBuilder(string).reverse.toString()</code></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 字典树前序遍历</span><br>        <span class="hljs-comment">// 当前节点，也是字典的第一个单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        k--;<br>        <span class="hljs-comment">// 找第k个</span><br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取当前节点的子节点数量，子节点的值上限为n</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> getSteps(curr, n);<br>            <span class="hljs-keyword">if</span> (steps &lt;= k) &#123;<br>                k -= steps;<br>                curr++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curr = curr * <span class="hljs-number">10</span>;<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> curr, <span class="hljs-type">long</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> curr;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> curr;<br>        <span class="hljs-comment">// 只要最左侧的节点还满足要求，就继续求层次和</span><br>        <span class="hljs-keyword">while</span> (first &lt;= n) &#123;<br>            <span class="hljs-comment">// 本层的节点数量</span><br>            steps += Math.min(last, n) - first + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 下一层的头节点和尾节点数量</span><br>            first = first * <span class="hljs-number">10</span>;<br>            last = last * <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="category-chain-item">算法整理</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="category-chain-item">算法专题</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
        <a href="/tags/DFS/">#DFS</a>
      
        <a href="/tags/BFS/">#BFS</a>
      
        <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">#回溯算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法专题（DFS与BFS）</div>
      <div>http://example.com/2023/02/10/算法整理/算法专题/算法专题（DFS与BFS）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/" title="算法专题（链表）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法专题（链表）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/" title="算法专题（树）">
                        <span class="hidden-mobile">算法专题（树）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.7/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo-api-lime.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/fluid-extention.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
