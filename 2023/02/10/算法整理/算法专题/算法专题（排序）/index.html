

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#727679">
  <meta name="author" content="Jin">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、基础参考LeetBook 冒泡排序1.思路每个数与后一个数比较，如果逆序则交换，故每次可冒出一个最大值，经过n次操作得到有序数组 2.基本实现12345678910111213141516public static void bubbleSort(int[] arr) &amp;#123;    for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="算法专题（排序）">
<meta property="og:url" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/index.html">
<meta property="og:site_name" content="Jin&#39;s Blog">
<meta property="og:description" content="一、基础参考LeetBook 冒泡排序1.思路每个数与后一个数比较，如果逆序则交换，故每次可冒出一个最大值，经过n次操作得到有序数组 2.基本实现12345678910111213141516public static void bubbleSort(int[] arr) &amp;#123;    for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/Pasted-image-20230313102458.png">
<meta property="article:published_time" content="2023-02-10T07:13:27.000Z">
<meta property="article:modified_time" content="2023-07-30T08:52:01.958Z">
<meta property="article:author" content="Jin">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/Pasted-image-20230313102458.png">
  
  
  
  <title>算法专题（排序） - Jin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong style="color: #fff;">Jin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                归档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法专题（排序）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-10 15:13" pubdate>
          2023年2月10日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          220 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法专题（排序）</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/sort-algorithms/eu039h/">参考LeetBook</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h3><p>每个数与后一个数比较，如果逆序则交换，故每次可冒出一个最大值，经过n次操作得到有序数组</p>
<h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>                swap(arr, j, j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 交换元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-升级"><a href="#3-升级" class="headerlink" title="3.升级"></a>3.升级</h3><ul>
<li>有时整个数组已经有序了，不需要排n次，应该直接返回。  </li>
<li>有时数组的后半段已经有序了，不需要反复对比到结尾，应该直接进入下一个循环。</li>
</ul>
<h3 id="4-处理"><a href="#4-处理" class="headerlink" title="4.处理"></a>4.处理</h3><ul>
<li>记录每次循环是否发生过交换，若没有则直接返回。 </li>
<li>记录每次循环最后一个发生交换的索引，下次循环只需要遍历到这个索引，该索引后面的数组已经有序。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">swapped</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 最后一个没有经过排序的元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">indexOfLastUnsortedElement</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 上次发生交换的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">swappedIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (swapped) &#123;<br>        swapped = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>                swap(arr, i, i + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 表示发生了交换</span><br>                swapped = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 更新交换的位置</span><br>                swappedIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span><br>        indexOfLastUnsortedElement = swappedIndex;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 交换元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h3><p>每次遍历，然后把最小的放到最前面。<br>与冒泡有点相似，不过冒泡是每次循环中每次对比都做交换，选择排序一个循环只做一次交换。</p>
<h3 id="2-基本实现-1"><a href="#2-基本实现-1" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> minIndex;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最小值的下标</span><br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将最小元素交换至首位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><ul>
<li>每次同时记录最大，最小值，减半循环次数</li>
</ul>
<h3 id="4-处理-1"><a href="#4-处理-1" class="headerlink" title="4.处理"></a>4.处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> minIndex, maxIndex;<br>    <span class="hljs-comment">// i 只需要遍历一半</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length / <span class="hljs-number">2</span>; i++) &#123;<br>        minIndex = i;<br>        maxIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最小值的下标</span><br>                minIndex = j;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最大值的下标</span><br>                maxIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成</span><br>        <span class="hljs-keyword">if</span> (minIndex == maxIndex) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 将最小元素交换至首位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>        <span class="hljs-comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。</span><br>        <span class="hljs-keyword">if</span> (maxIndex == i) maxIndex = minIndex;<br>        <span class="hljs-comment">// 将最大元素交换至末尾</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span> - i;<br>        temp = arr[lastIndex];<br>        arr[lastIndex] = arr[maxIndex];<br>        arr[maxIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>一般而言，冒泡排序是稳定的，选择排序是不稳定的。</p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1.思路"></a>1.思路</h3><p>把一个新的数插入到原先的有序数组中<br>插入排序有两种写法：</p>
<ul>
<li>交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</li>
<li>移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。</li>
</ul>
<h3 id="2-基本写法"><a href="#2-基本写法" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//交换法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// j 记录当前数字下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>            swap(arr, j, j - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 更新当前数字下标</span><br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br><br><span class="hljs-comment">//移动法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-优化-1"><a href="#3-优化-1" class="headerlink" title="3.优化"></a>3.优化</h3><p>移动法本身就是一种优化，不需要每次都交换，一直把比当前数大的数往后移动就好了。</p>
<blockquote>
<p>稳定</p>
</blockquote>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="1.思路"></a>1.思路</h3><p>对插入排序的一种优化，将数组拆分分别做插入排序，不断缩减分组的间隔。<br><em>原理</em></p>
<div class="note note-primary">
            <p>希尔排序与 O(n^2)级排序算法的本质区别：<br>排序算法本质上就是一个消除逆序对的过程。如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对。反过来说，基于交换元素的排序算法要想突破 O(n^2)级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>
          </div>

<p><em>重要性质</em><br>D(k+1)间隔有序的序列，结果D(k)间隔排序后们仍然是D(k+1)间隔有序的：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137355984">证明</a></p>
<h3 id="2-基本写法-1"><a href="#2-基本写法-1" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 间隔序列，在希尔排序中我们称之为增量序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 分组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">groupStartIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;<br>            <span class="hljs-comment">// 插入排序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> groupStartIndex + gap; currentIndex &lt; arr.length; currentIndex += gap) &#123;<br>                <span class="hljs-comment">// currentNumber 站起来，开始找位置</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[currentIndex];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> currentIndex - gap;<br>                <span class="hljs-keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;<br>                    <span class="hljs-comment">// 向后挪位置</span><br>                    arr[preIndex + gap] = arr[preIndex];<br>                    preIndex -= gap;<br>                &#125;<br>                <span class="hljs-comment">// currentNumber 找到了自己的位置，坐下</span><br>                arr[preIndex + gap] = currentNumber;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-优化-2"><a href="#3-优化-2" class="headerlink" title="3.优化"></a>3.优化</h3><ul>
<li>对于计算机而言，连续的访问数组元素更加快捷</li>
<li>增量序列：增量序列的选择会极大地影响希尔排序的效率。增量序列如果选得不好，希尔排序的效率可能比插入排序效率还要低，常用序列有Hibbard，Knuth，Sedgewick等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSortByKnuth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 找到当前数组需要用到的 Knuth 序列中的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxKnuthNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (maxKnuthNumber &lt;= arr.length / <span class="hljs-number">3</span>) &#123;<br>        maxKnuthNumber = maxKnuthNumber * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 增量按照 Knuth 序列规则依次递减</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> maxKnuthNumber; gap &gt; <span class="hljs-number">0</span>; gap = (gap - <span class="hljs-number">1</span>) / <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// currentNumber 站起来，开始找位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">// 该组前一个数字的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;<br>                <span class="hljs-comment">// 向后挪位置</span><br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap;<br>            &#125;<br>            <span class="hljs-comment">// currentNumber 找到了自己的位置，坐下</span><br>            arr[preIndex + gap] = currentNumber;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其平均时间复杂度为n到n^2之间，普遍认为其最好时间复杂度为n^1.3。一般可以认为其是一个nlogn的的排序算法。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="1.思路"></a>1.思路</h3><p><strong>构建大顶堆 &amp; 调整堆</strong><br>构建大顶堆有两种方式：</p>
<ul>
<li>方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求；</li>
<li>方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求，<strong>更为常用</strong>。</li>
</ul>
<h3 id="2-基本实现-2"><a href="#2-基本实现-2" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 构建初始大顶堆</span><br>    buildMaxHeap(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 将最大值交换到数组最后</span><br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">// 调整剩余数组，使其满足大顶堆</span><br>        maxHeapify(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 构建初始大顶堆</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        maxHeapify(arr, i, arr.length);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maxHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>    <span class="hljs-comment">// 左子结点下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右子结点下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-comment">// 与左子树结点比较</span><br>    <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;<br>        largest = l;<br>    &#125;<br>    <span class="hljs-comment">// 与右子树结点比较</span><br>    <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;<br>        largest = r;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-comment">// 将最大值交换为根结点</span><br>        swap(arr, i, largest);<br>        <span class="hljs-comment">// 再次调整交换数字后的大顶堆</span><br>        maxHeapify(arr, largest, heapSize);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>初始化建堆的时间复杂度为 O(n)<br>重建堆的时间复杂度为 O(nlogn)<br>堆排序总的时间复杂度为 O(nlogn)<br><strong>不稳定</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><p>从数组中取出一个数，称之为基数（pivot）。遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。</p>
<h3 id="2-基本写法-2"><a href="#2-基本写法-2" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 如果区域内的数字少于 2 个，退出递归</span><br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将数组分区，并获得中间值的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> partition(arr, start, end);<br>    <span class="hljs-comment">// 对左边区域快速排序</span><br>    quickSort(arr, start, middle - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 对右边区域快速排序</span><br>    quickSort(arr, middle + <span class="hljs-number">1</span>, end);<br>&#125;<br><span class="hljs-comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 取第一个数为基数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[start];<br>    <span class="hljs-comment">// 从第二个数开始分区</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 找到第一个大于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;<br>        <span class="hljs-comment">// 找到第一个小于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;<br>        <span class="hljs-comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            exchange(arr, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span><br>    <span class="hljs-keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;<br>    <span class="hljs-comment">// 将基数和轴交换</span><br>    exchange(arr, start, right);<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>也可以双指针</p>
</blockquote>
<p>平均时间复杂度为 O(nlogn)<br>最坏的时间复杂度为O(n^2)<br>空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为O(logn)~O(n)，平均空间复杂度为 O(logn)。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="1.思路"></a>1.思路</h3><p>两个数组合并成有序数组可以使用双指针的方式，那么我们可以从以1为数组长度开始合并，最后合成一个有序数组。</p>
<h3 id="2-基本实现-3"><a href="#2-基本实现-3" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span>[] result = mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将结果拷贝到 arr 数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对 arr 的 [start, end] 区间归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>    <span class="hljs-comment">// 只剩下一个数字，停止拆分，返回单个数字组成的数组</span><br>    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;arr[start]&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 拆分左边区域</span><br>    <span class="hljs-type">int</span>[] left = mergeSort(arr, start, middle);<br>    <span class="hljs-comment">// 拆分右边区域</span><br>    <span class="hljs-type">int</span>[] right = mergeSort(arr, middle + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-comment">// 合并左右区域</span><br>    <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-优化-3"><a href="#3-优化-3" class="headerlink" title="3.优化"></a>3.优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, result);<br>&#125;<br><br><span class="hljs-comment">// 对 arr 的 [start, end] 区间归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] result)</span> &#123;<br>    <span class="hljs-comment">// 只剩下一个数字，停止拆分</span><br>    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间</span><br>    mergeSort(arr, start, middle, result);<br>    <span class="hljs-comment">// 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间</span><br>    mergeSort(arr, middle + <span class="hljs-number">1</span>, end, result);<br>    <span class="hljs-comment">// 合并左右区域到 result 的 [start, end] 区间</span><br>    merge(arr, start, end, result);<br>&#125;<br><br><span class="hljs-comment">// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] result)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> end1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 用来遍历数组的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> start2;<br>    <span class="hljs-keyword">while</span> (index1 &lt;= end1 &amp;&amp; index2 &lt;= end) &#123;<br>        <span class="hljs-keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;<br>            result[index1 + index2 - start2] = arr[index1++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[index1 + index2 - start2] = arr[index2++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将剩余数字补到结果数组之后</span><br>    <span class="hljs-keyword">while</span> (index1 &lt;= end1) &#123;<br>        result[index1 + index2 - start2] = arr[index1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (index2 &lt;= end) &#123;<br>        result[index1 + index2 - start2] = arr[index2++];<br>    &#125;<br>    <span class="hljs-comment">// 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较</span><br>    <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>        arr[start] = result[start++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 logn 次，每层执行的比较次数都约等于 n 次，所以时间复杂度是&#x3D;&#x3D;O(nlogn)。</p>
<p>分析归并的过程可知，归并排序是一种稳定的排序算法。</p>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>归并排序的过程必然可以消除逆序对，且不会进行多余的交换，因此可以从其入手，通过求数组某一范围内的逆序对个数，排序后归并，再次求逆序对个数。</p>
<p><strong>数组中的逆序对</strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> mergeSort(nums);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">return</span> mergeSort(nums, result, <span class="hljs-number">0</span>, length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span>[] result,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == end) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> mergeSort(nums,result,start,middle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightCount</span> <span class="hljs-operator">=</span> mergeSort(nums,result,middle+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mergeCount</span> <span class="hljs-operator">=</span> merge(nums,result,start,end);<br>        <span class="hljs-keyword">return</span> leftCount+mergeCount+rightCount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span>[] result,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> middle+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> start2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(index1&lt;=middle &amp;&amp; index2&lt;=end)&#123;<br>            <span class="hljs-keyword">if</span>(nums[index1]&lt;=nums[index2])&#123;<br>                result[index1+index2-start2] = nums[index1++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[index1+index2-start2] = nums[index2++];<br>                count += middle-index1+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index1&lt;=middle)&#123;<br>            result[index1+index2-start2] = nums[index1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index2&lt;=end)&#123;<br>            result[index1+index2-start2] = nums[index2++];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;i++)&#123;<br>            nums[i] = result[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="1-思路-6"><a href="#1-思路-6" class="headerlink" title="1.思路"></a>1.思路</h3><p>统计每个数的大小和出现的次数，然后按从小到大排列。</p>
<h3 id="2-基本实现-4"><a href="#2-基本实现-4" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 判空及防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定计数范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[range];<br>    <span class="hljs-comment">// 遍历 arr 中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span><br>        counting[element - min]++;<br>    &#125;<br>    <span class="hljs-comment">// 记录前面比自己小的数字的总数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">preCounts</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; range; i++) &#123;<br>        <span class="hljs-comment">// 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。</span><br>        counting[i] = preCounts;<br>        <span class="hljs-comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span><br>        preCounts += counting[i];<br>    &#125;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// counting[element - min] 表示此元素在结果数组中的下标</span><br>        result[counting[element - min]] = element;<br>        <span class="hljs-comment">// 更新 counting[element - min]，指向此元素的下一个下标</span><br>        counting[element - min]++;<br>    &#125;<br>    <span class="hljs-comment">// 将结果赋值回 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-优化-4"><a href="#3-优化-4" class="headerlink" title="3.优化"></a>3.优化</h3><p>在计算元素在最终结果数组中的下标位置这一步，不是计算初始下标位置，而是计算最后一个下标位置。最后倒序遍历 arr 数组，逐个将 arr 中的元素放到最终位置上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定计数范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[range];<br>    <span class="hljs-comment">// 遍历 arr 中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span><br>        counting[element - min]++;<br>    &#125;<br><br>	<span class="hljs-comment">//关键</span><br>    <span class="hljs-comment">// 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可</span><br>    counting[<span class="hljs-number">0</span>]--;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; range; i++) &#123;<br>        <span class="hljs-comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1</span><br>        <span class="hljs-comment">// 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。</span><br>        counting[i] += counting[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-comment">// 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span><br>        result[counting[arr[i] - min]] = arr[i];<br>        <span class="hljs-comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span><br>        counting[arr[i] - min]--;<br>    &#125;<br>    <span class="hljs-comment">// 将结果赋值回 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计数排序的时间复杂度为 O(n + k)，k 表示数据的范围大小。<br>用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 O(n + k)。</p>
<blockquote>
<p>计数排序只适用于数据范围不大的场景，否则count数组会很大。如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p>
</blockquote>
<blockquote>
<p>计数排序凭什么能够突破 O(nlogn)的下界呢？<br>如果基于比较来进行排序，无论怎么优化都无法突破 O(nlog n)的下界。计数排序和基于比较的排序算法相比，根本区别就在于：它不是基于比较的排序算法，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。</p>
</blockquote>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="1-思路-7"><a href="#1-思路-7" class="headerlink" title="1.思路"></a>1.思路</h3><p>类似于计数排序，但是每次只计算数值特定位数（基数）的出现次数和大小，这样，从低位往高位循环排列，最后就可以得到一个有序的数组。</p>
<h3 id="2-基本实现-5"><a href="#2-基本实现-5" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><ul>
<li>「最低位优先法」，简称 <code>LSD (Least significant digital)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找出最长的数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-keyword">if</span> (Math.abs(value) &gt; max) &#123;<br>            max = Math.abs(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算最长数字的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigitLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        maxDigitLength++;<br>        max /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">19</span>];<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigitLength; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-comment">// 下标调整</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> value / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            counting[radix]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; counting.length; j++) &#123;<br>            counting[j] += counting[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 使用倒序遍历的方式完成计数排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 下标调整</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[j] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            result[--counting[radix]] = arr[j];<br>        &#125;<br>        <span class="hljs-comment">// 计数排序完成后，将结果拷贝回 arr 数组</span><br>        System.arraycopy(result, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, arr.length);<br>        <span class="hljs-comment">// 将计数数组重置为 0</span><br>        Arrays.fill(counting, <span class="hljs-number">0</span>);<br>        dev *= <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>因为此处考虑了加入负数的排序，所以基数应该为-9~9，共19位数，所以创建一个19长度的count数组。求出绝对值最大的数的长度后，按照这个长度进行循环的计数排序并重置数组。</p>
</blockquote>
<ul>
<li>「最高位优先法」，简称 <code>MSD (Most significant digital)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(value) &gt; max) &#123;<br>                max = Math.abs(value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算最大长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDigitLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            maxDigitLength++;<br>            max /= <span class="hljs-number">10</span>;<br>        &#125;<br>        radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxDigitLength);<br>    &#125;<br><br>    <span class="hljs-comment">// 对 arr 数组中的 [start, end] 区间进行基数排序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == end || position == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 使用计数排序对基数进行排序</span><br>        <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">19</span>];<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[end - start + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, position - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// MSD, 从最高位开始</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[i] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            counting[radix]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; counting.length; j++) &#123;<br>            counting[j] += counting[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 拷贝 counting，用于待会的递归</span><br>        <span class="hljs-type">int</span>[] countingCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[counting.length];<br>        System.arraycopy(counting, <span class="hljs-number">0</span>, countingCopy, <span class="hljs-number">0</span>, counting.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> end; i &gt;= start; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[i] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            result[--counting[radix]] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">// 计数排序完成后，将结果拷贝回 arr 数组</span><br>        System.arraycopy(result, <span class="hljs-number">0</span>, arr, start, result.length);<br>        <span class="hljs-comment">// 对 [start, end] 区间内的每一位基数进行递归排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; counting.length; i++) &#123;<br>            radixSort(arr, i == <span class="hljs-number">0</span> ? start : start + countingCopy[i - <span class="hljs-number">1</span>], start + countingCopy[i] - <span class="hljs-number">1</span>, position - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 O(n + k)，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。</p>
<p>所以基数排序的时间复杂度为&#x3D;&#x3D;O(d(n + k))&#x3D;&#x3D;(d 表示最长数字的位数，k 表示每个基数可能的取值范围大小)。<br>使用的空间和计数排序是一样的，空间复杂度为 &#x3D;&#x3D;O(n + k)&#x3D;&#x3D;（k 表示每个基数可能的取值范围大小）。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="1-思路-8"><a href="#1-思路-8" class="headerlink" title="1.思路"></a>1.思路</h3><p>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶;遍历数组，将每个数字装入桶中;对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等;最后按照顺序将所有桶内的数字合并起来。</p>
<blockquote>
<p>桶排序在实际工作中的应用较少，不仅因为它需要借助于其他排序算法，还因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。</p>
</blockquote>
<h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h3><p>这两个因素会直接影响到桶排序的内存和效率：<br><strong>桶的数量</strong>：桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。具体设置多少个桶需要根据实际情况决定。</p>
<p><strong>桶的数据结构</strong>：如果将桶的数据结构设置为数组，那么每个桶的长度必须设置为待排序数组的长度，因为我们需要做好最坏的打算，即所有的数字都被装入了同一个桶中，所以这种方案的空间复杂度会很高。</p>
<ul>
<li>以数组作为桶</li>
</ul>
<p>默认以原数组的长度作为桶数组的长度，但这样很可能会造成大量的空间浪费。因此可以对此做优化，声明时所有的数组都为空，当需要添加数字时，不断扩容，并加入新数字。完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 判空及防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定取值范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min;<br>    <span class="hljs-comment">// 设置桶的数量，这里我们设置为 100 个，可以根据实际情况修改。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketAmount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 桶和桶之间的间距</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> range * <span class="hljs-number">1.0</span> / (bucketAmount - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 用二维数组来装桶，第一个维度是桶的编号，第二个维度是桶中的数字。初始化长度为 0</span><br>    <span class="hljs-type">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bucketAmount][];<br>    <span class="hljs-comment">// 装桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-comment">// 找到 value 属于哪个桶</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((value - min) / gap);<br>        buckets[index] = add(buckets[index], value);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 对每个桶内的数字进行单独排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketAmount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">null</span> || buckets[i].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 这里需要结合其他排序算法，例如：插入排序</span><br>        insertSort(buckets[i]);<br>        <span class="hljs-comment">// 排序完成后将桶内的结果收集起来</span><br>        System.arraycopy(buckets[i], <span class="hljs-number">0</span>, arr, index, buckets[i].length);<br>        index += buckets[i].length;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 数组扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] add(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> num) &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num&#125;;<br>    <span class="hljs-type">int</span>[] newArr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>    newArr[arr.length] = num;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>以链表为桶，则创建一个：<code>HashMap&lt;Integer,Integer&gt;</code>，链表不需要扩容，但排序慢，一般采用插入排序。</li>
<li>折中的方案:装桶时用链表，桶内排序用数组。</li>
</ul>
<h3 id="3-复杂度-1"><a href="#3-复杂度-1" class="headerlink" title="3.复杂度"></a>3.复杂度</h3><ul>
<li>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 O(n)，空间复杂度 O(1)。</li>
<li>第二步：装桶的过程需要遍历一轮数组，时间复杂度 O(n)，空间复杂度与桶的数量以及数据结构有关，设桶的数量为 k，如果使用 k 个长度为 n 的数组作为桶，则空间复杂度为 O(kn)，如果采用 ArrayList 或 LinkedList 来装桶，或者采用初始长度为 0 ，装桶时不断扩容的数组，则空间复杂度为 O(n)。</li>
<li>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 n&#x2F;k，如果采用 O(n^2)级排序算法，则每个桶内排序的时间复杂度为 O((n&#x2F;k)^2)，所有桶完成排序的时间复杂度为 O(k(n&#x2F;k)^2，即 O(n^2 &#x2F; k)。<ul>
<li>如果采用O(nlogn) 级排序算法，每个桶内排序的时间复杂度 O((n&#x2F;k) log (n&#x2F;k))，所有桶完成排序的时间复杂度为 O(k(n&#x2F;k) log (n&#x2F;k))，即 O(n log (n&#x2F;k))。</li>
<li>在桶的数量合适的情况下，时间复杂度 O(n^2 &#x2F; k)和 O(nlog(n&#x2F;k)) 都约等于 O(n)。</li>
<li>桶内排序的空间复杂度也和具体的排序算法有关，O(1)O(1) 或者 O(n)O(n)。</li>
</ul>
</li>
<li>第四步：如果采用 LinkedList 转 <code>int[]</code> 再排序这种方式，由于转换过程需要一轮遍历，所以会增加O(n)的时间复杂度和O(n)的空间复杂度。</li>
</ul>
<p><strong>综上可知，桶排序的时间复杂度为 O(n)，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 O(n log n) 级的排序算法快。空间复杂度为 O(n)。</strong></p>
<div class="note note-primary">
            <p>个人理解，这里复杂度为n的方法都是利用了数字本身的性质，即每个待比较的对象都是利用数字进行比较，这个数字是一个绝对且具有传递性（x&gt;y,y&gt;z，则x&gt;z）的属性，所以我们可以直接根据该属性为对象排到其相应的位置。</p>
          </div>

<h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>n2</td>
<td>1</td>
<td>稳定（取决于实现）</td>
</tr>
<tr>
<td>选择</td>
<td>n2</td>
<td>1</td>
<td>不稳定（另开一个数组时稳定）</td>
</tr>
<tr>
<td>插入</td>
<td>n2</td>
<td>1</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔</td>
<td>nlogn</td>
<td>1</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆</td>
<td>nlogn</td>
<td>1</td>
<td>不稳定</td>
</tr>
<tr>
<td>快排</td>
<td>nlogn</td>
<td>logn</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并</td>
<td>nlogn</td>
<td>n</td>
<td>稳定</td>
</tr>
<tr>
<td>计数</td>
<td>n+k</td>
<td>n+k</td>
<td>稳定</td>
</tr>
<tr>
<td>基数</td>
<td>d(n+k)</td>
<td>n+k</td>
<td>稳定</td>
</tr>
<tr>
<td>桶</td>
<td>n</td>
<td>n</td>
<td>稳定</td>
</tr>
</tbody></table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>swap(int[] arr,int l,int r)</code>其中l和r不能相等，否则相当于与自己异或，等于0。</p>
<h1 id="三、工业级排序"><a href="#三、工业级排序" class="headerlink" title="三、工业级排序"></a>三、工业级排序</h1><h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><h2 id="1-总体流程"><a href="#1-总体流程" class="headerlink" title="1.总体流程"></a>1.总体流程</h2><p><code>Arrays</code> 类中有很多个 <code>sort</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">long</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">long</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">short</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">short</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">char</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">char</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">byte</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">byte</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">float</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">float</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">double</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">double</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(Object[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(Object[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(T[], Comparator)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(T[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, Comparator)</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这些 sort 函数可以分为两类：</p>
<ul>
<li>对基本类型的排序（int、long、short、char、byte、float、double），对基本类型的排序是通过调用对应的 <code>DualPivotQuicksort.sort()</code> 函数完成的。</li>
<li>对非基本类型的排序（Object、T），对非基本类型的排序采用的是 TimSort 或者归并排序，在 JDK 1.7 之前，默认采用归并排序，JDK 1.7 及之后，默认采用 TimSort。</li>
<li>但可以通过设置 JVM 参数 <code>-Djava.util.Arrays.useLegacyMergeSort=true</code> 继续使用归并排序。</li>
</ul>
</blockquote>
<h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2.基本类型"></a>2.基本类型</h2><p><code>dualPivotQuicksort</code>源码很长，是Arrays.sort在处理基本类型的排序时的实现。<br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/Pasted-image-20230313102458.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h3><p><code>TimSort</code>的主要思想是：通过遍历数组，将数组拆分成若干个单调递增的子数组。每一块称为一个 run。拆分完成后，再将 run 两两合并起来。<br><code>TimSort</code> 在对<strong>部分有序</strong>的数组进行排序时，速度很快。因为整个数组可以拆分成少量的 run 小块，将其合并即可完成排序。我们称这一类只能被拆分成少量 run 小块的数组是「高度结构化」的 (<strong>highly structured</strong>)。</p>
<p>在拆分 run 小块的过程中，有两个条件会<strong>停止调用 TimSort</strong>：</p>
<ul>
<li>连续相同的数字的数量到达了33个：</li>
<li>排序时以 k 为索引遍历整个数组，比较相邻数字的大小关系：<ul>
<li>如果数字在递增，记录下此 run 小块</li>
<li>如果数字在递减，记录下此 run 小块，并翻转这部分子数组</li>
<li>如果数字相等，记录下此 run 小块，并判断连续相等的数字是否达到了 MAX_RUN_LENGTH 个，如果达到了 <code>MAX_RUN_LENGTH</code>，则不再使用 TimSort，改为调用 sort(int[] a, int left, int right, boolean leftmost) (leftMost参数)函数进行排序。<br>  在这个被调用的方法中，有对重复数字过多时的排序改进。</li>
</ul>
</li>
<li>run的块数量达到了<code>MAX_RUN_COUNT</code>(67)，如果run块的数量超过了67，说明其并不是高度结构化数据，不适合TimSort。</li>
</ul>
<div class="note note-primary">
            <p>总结：timsort是对归并算法的优化，通过将归并的分块变成直接使用数组中的递增，递减数组。但若这样的分块过多或重复数字过多，则退化成其他排序方法。</p>
          </div>

<h3 id="插入排序-amp-双插入排序"><a href="#插入排序-amp-双插入排序" class="headerlink" title="插入排序 &amp; 双插入排序"></a>插入排序 &amp; 双插入排序</h3><p>首先仍然是判断数组长度，如果小于 INSERTION_SORT_THRESHOLD（它的值是 47），则采用插入排序算法或双插入排序算法进行排序。如果数据量达到了 47，则采用双轴快排算法进行排序。这是因为<strong>插入排序在数据量小的时候，排序性能比较好</strong>。</p>
<p><strong>leftMost</strong>表示当前排序的数据范围是否是待排序区间的最左端。如果是最左端，则采用插入排序算法对其排序，否则采用双插入排序的算法进行排序。</p>
<p>插入排序和双插入排序的区别是（以排升序为例）：</p>
<ul>
<li>插入排序时，每次从待排序的数字中取一个数字，将其插入到前方已经有序的数组中。（移动法）</li>
<li>双插入排序时，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。</li>
</ul>
<blockquote>
<p>当前排序的数据范围如果不是待排序区间最左端，则保证left-1不越界，且left-1的数值一定比left及其右边的小，从而保证插入排序不会越界。</p>
<p>双轴快排会把数组分为左中右三个区域，分区之后，左边区域的任何一个数字都小于中间区域，中间区域的任何一个数字都小于右边区域，所以每个待排序区间的前一个数字都承担了「哨兵」的职责。</p>
<p>这也正是 <code>leftMost</code> 参数存在的意义：<strong>因为最左端区间没有「哨兵」，所以只有对非最左端区间排序时，才能采用这种不做边界检查的双插入排序</strong>。</p>
</blockquote>
<h3 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h3><p>双轴快排每轮选取两个轴 pivot1、pivot2 (pivot1 &lt; pivot2)，然后以两个轴为分界，将数组分为左中右三个区域。交换三个区域内的数字，使得三个区域分别属于区间 <code>(-∞, pivot1)</code>、<code>[pivot1, pivot2]</code>、<code>(pivot2, +∞)</code>。然后再对左中右区域不断重复此过程，直至排序完成。</p>
<p>通过从中间位置往前和往后分别走两次数组长度的 1&#x2F;7步长，取到了5个备选轴的下标：e1、e2、e3、e4、e5。</p>
<p>选择第二、四个数做轴，如果五个备选轴中，出现了相等元素，用单轴进行分区。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote>
<ol>
<li><p>当数组长度达到 286 ，并且不存在较多连续相等元素，并且「高度结构化」时，采用类似 TimSort 的算法进行排序。<br>其中用到的 TimSort 思想是：先拆分出单调递增的 run 小块，然后将 run 小块两两合并完成排序，合并时原数组和辅助数组会交替合并。</p>
</li>
<li><p>当数组长度小于 INSERTION_SORT_THRESHOLD（即 47）时，采用插入排序或双插入排序。<br>其中，双插入排序的思想是，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。</p>
</li>
<li><p>否则，采用双轴快排进行排序。双轴快排的思想是：每轮选取两个轴 <code>pivot1、pivot2,(pivot1 &lt; pivot2)</code>，然后以两个轴为分界，将数组分为左中右三个区域。交换三个区域内的数字，使得三个区域分别属于区间<code> (-∞, pivot1)、[pivot1, pivot2]、(pivot2, +∞)</code>。然后再对左中右区域不断重复此过程，直至排序完成。<br>分区后，如果中间区域过大（大于数组长度的 4&#x2F;7），则将中间区域再次分成三个区域： <code>[pivot1, pivo1]</code>、<code>(pivot1, pivot2)</code>、<code>[pivot2,pivot2]</code>，只让 <code>(pivot1, pivot2)</code> 区间参与下一轮双轴快排。(可能是因为认为边界元素重复多)<br>如果整个数组中存在较多的相等元素，则不再取两个轴，而是只取一个轴，按照 <code>(-∞, pivot)、[pivot, pivot]、(pivot, +∞)</code>，<code>(−∞,pivot)、[pivot,pivot]、(pivot,+∞)</code> 进行分区。然后对左右两个区域不断重复此过程，直至排序完成。</p>
</li>
</ol>
</blockquote>
<h1 id="三、排序-x2F-二分搜索问题"><a href="#三、排序-x2F-二分搜索问题" class="headerlink" title="三、排序&#x2F;二分搜索问题"></a>三、排序&#x2F;二分搜索问题</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a><br>计数后堆排序解决。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a><br>以任意一点为节点，其左右两侧必然有一侧是单调递增的。考察看目标数在不在这个范围内。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a><br>元素的右上角相当于一个二叉搜索树的根节点。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-sort/">280. 摆动排序</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-sort-ii/">324. 摆动排序 II</a></p>
<ol>
<li>先排序，将数组分前后两段（前段长度 &#x3D;&#x3D; 后段 或 ＞ 后段），错位插入。</li>
<li>对于Ⅱ，注意，如果某个中位数的重复次数等于数组的长度，可能会导致错位插入，如果想要得到排序，此时中位数应该在最终序列的头部或尾部。因此应该将两个数组倒置，这样如果前端有中位数一定在最后序列的头部。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a><br>双堆</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p>
<ol>
<li>堆</li>
<li>快排，并剪枝</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p>
<ol>
<li>利用归并排序，每次归并两个线段时，可以通过索引判断这个数的逆序对。</li>
<li>离散化树状数组：一个逆序对，即一个数字后面有多少个比该数小的元素，如果采用从后往前填入，则可以很方便的查询逆序对。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, tmp, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-comment">//对原数进行排序，找到每一个值在树状数组中的索引+1。</span><br>        Arrays.sort(tmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            nums[i] = Arrays.binarySearch(tmp, nums[i]) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 建立树状数组</span><br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>	        <span class="hljs-comment">//从后开始搜索每一个原值在树状数组中的位置，并添加比该值大的数。</span><br>            ans += bit.query(nums[i] - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//添加该数</span><br>            bit.update(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += tree[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            ++tree[x];<br>            x += lowbit(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a><br>二分搜索，遇到相等的值</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素</a><br>对于任意一个数，其左上角部分的元素肯定是比该数小的。</p>
<ol>
<li>归并排序，直接对各行进行归并，找到第k个即可返回。</li>
<li>从右上角开始应用二叉搜索树的性质找分界线。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a><br>相当于寻找第k小的数（k&#x3D;(m+n)&#x2F;2 || k&#x3D;(m+n+1)&#x2F;2）。<br>可以先将两个数组的前k个数都取出来，然后每次淘汰某个数组中k&#x2F;2的人。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLength</span> <span class="hljs-operator">=</span> length1 + length2;<br>        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midIndex</span> <span class="hljs-operator">=</span> totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> median;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midIndex1</span> <span class="hljs-operator">=</span> totalLength / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">return</span> median;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKthElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><br><span class="hljs-comment">         * 这里的 &quot;/&quot; 表示整除</span><br><span class="hljs-comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><br><span class="hljs-comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="hljs-comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><br><span class="hljs-comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><br><span class="hljs-comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kthElement</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-keyword">if</span> (index1 == length1) &#123;<br>                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index2 == length2) &#123;<br>                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Math.min(nums1[index1], nums2[index2]);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> k / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newIndex1</span> <span class="hljs-operator">=</span> Math.min(index1 + half, length1) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newIndex2</span> <span class="hljs-operator">=</span> Math.min(index2 + half, length2) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot1</span> <span class="hljs-operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-subarray-ii/">644. 子数组最大平均数 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMaxAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//求数组的极值</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">max_val</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">min_val</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n: nums) &#123;<br>            max_val = Math.max(max_val, n);<br>            min_val = Math.min(min_val, n);<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (error &gt; <span class="hljs-number">0.00001</span>) &#123;<br>            <span class="hljs-comment">//取中值，放入nums中验证</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (max_val + min_val) * <span class="hljs-number">0.5</span>;<br>            <span class="hljs-comment">//如果平均值可能大于等于mid，则令左侧为mid，否则另右侧为mid（不可-1，这是一个浮点数二分）</span><br>            <span class="hljs-keyword">if</span> (check(nums, mid, k))&#123;<br>                min_val = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                max_val = mid;<br>            &#125;<br>            <span class="hljs-comment">//计算目标本轮相对上一轮的调整值</span><br>            error = Math.abs(max_val - min_val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (max_val + min_val) * <span class="hljs-number">0.5</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//验证平均值是否可以大于等于mid，如果能，则返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">double</span> mid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, prev = <span class="hljs-number">0</span>, min_sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)<br>            sum += nums[i] - mid;<br>        <span class="hljs-keyword">if</span> (sum &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            sum += nums[i] - mid;<br>            prev += nums[i - k] - mid;<br>            min_sum = Math.min(prev, min_sum);<br>            <span class="hljs-keyword">if</span> (sum &gt;= min_sum)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="category-chain-item">算法整理</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/" class="category-chain-item">算法专题</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
      
        <a href="/tags/%E6%8E%92%E5%BA%8F/">#排序</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法专题（排序）</div>
      <div>http://example.com/2023/02/10/算法整理/算法专题/算法专题（排序）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/" title="算法专题（数学）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法专题（数学）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/" title="算法专题（贪心）">
                        <span class="hidden-mobile">算法专题（贪心）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.7/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo-api-lime.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/fluid-extention.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
