

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#727679">
  <meta name="author" content="Jireyo">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、基本概念概念超文本传输协议，HyperText Transfer Protocol。  协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。 传输：HTTP 协议是一个双向协议。 超文本：超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络-HTTP">
<meta property="og:url" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/index.html">
<meta property="og:site_name" content="Jireyo&#39;s Blog">
<meta property="og:description" content="一、基本概念概念超文本传输协议，HyperText Transfer Protocol。  协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。 传输：HTTP 协议是一个双向协议。 超文本：超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%BC%93%E5%AD%98etag.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E9%93%BE.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/tls1.2and1.3-1.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/25-HTTP2.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224430.png">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224926.png">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/stream.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206191054.png">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/push.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206210341.png">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206211242.png">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206225705.png">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.webp">
<meta property="og:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.webp">
<meta property="og:image" content="http://example.com/Pasted%20image%2020230207112106.png">
<meta property="og:image" content="http://example.com/Pasted%20image%2020230207113622.png">
<meta property="article:published_time" content="2023-02-06T08:16:01.000Z">
<meta property="article:modified_time" content="2023-02-07T14:54:44.120Z">
<meta property="article:author" content="Jireyo">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.webp">
  
  
  
  <title>计算机网络-HTTP - Jireyo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong style="color: #fff;">Jireyo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                归档
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络-HTTP"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-06 16:16" pubdate>
          2023年2月6日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          107 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机网络-HTTP</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>超文本传输协议，<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p>
<ul>
<li>协议：HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</li>
<li>传输：HTTP 协议是一个<strong>双向协议</strong>。</li>
<li>超文本：<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li>
</ul>
<p>总结：<br><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.webp" srcset="/img/loading.gif" lazyload><br><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。<br><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 </li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h2 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h2><ul>
<li>Accept: 可接受的数据格式</li>
<li>Host 字段：服务器域名</li>
<li>Connection 字段：使用长连接<br>  即复用同一个TCP连接，HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li>
<li>Content-Length 字段：数据长度，为了解决粘包</li>
<li>Content-Type：本次数据格式</li>
<li>Content-Encoding：数据的压缩方法</li>
</ul>
<h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>get：语义是获取资源（可放入body也可放入url）<br>post：语义是操作资源（请求参数放入body）</p>
<h3 id="GET和POST方法都是安全和幂等的吗？"><a href="#GET和POST方法都是安全和幂等的吗？" class="headerlink" title="GET和POST方法都是安全和幂等的吗？"></a>GET和POST方法都是安全和幂等的吗？</h3><p>安全：不破坏服务器资源<br>幂等：多次执行结果不变</p>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>（可做缓存）。</li>
<li><strong>POST</strong> <strong>方法不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。（<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>）。</li>
</ul>
<blockquote>
<p>实际上开发者也可以不遵守这个规定。</p>
</blockquote>
<h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><p>本地缓存的方式有：<strong>强制缓存和协商缓存</strong>。</p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>HTTP响应头可以表示资源的缓存时间：</p>
<ul>
<li><code>Cache-Control</code>，是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>其中，<strong>Cache-Control 的优先级高于 Expires</strong>了。<br>强制缓存：只要不过期，肯定直接返回。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%BC%93%E5%AD%98etag.webp" srcset="/img/loading.gif" lazyload><br>协商缓存：<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p>
<p>实现方法：<br>方法一：时间戳</p>
<ul>
<li>响应头中的<code>Last-Modified</code>：资源最后的修改时间</li>
<li>请求头中的<code>If-Modified-Since</code>：告诉服务器上次接受资源的时间</li>
</ul>
<p>即客户端接受到第一次访问的数据中发现有<code>Last-Modified</code>字段，再次请求时会携带<code>If-Modified-Since</code>字段（值为<code>Last-Modified</code>），服务器通过判断<code>Last-Modified</code>是否过期判断回复最新结果200还是无修改304。</p>
<p>方法二：E-tag</p>
<ul>
<li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的 <code>If-None-Match</code>：告诉服务器上次接受资源的ID。</li>
</ul>
<p>原理相同。<br>由于方法一的时间戳可能背篡改导致不可靠，主要使用方法二，且<strong>Etag 的优先级更高</strong>。</p>
<p><strong>Etag的优点</strong>：</p>
<ol>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ol>
<div class="note note-primary">
            <p>这些Last-Modified的缺点与TCP连接的TW-REUSE开启之后使用时间戳的缺点类似。</p>
          </div>

<p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p>
<h1 id="二、HTTP特性"><a href="#二、HTTP特性" class="headerlink" title="二、HTTP特性"></a>二、HTTP特性</h1><p>到目前为止，HTTP 常见到版本有 <code>HTTP/1.1</code>，<code>HTTP/2.0</code>，<code>HTTP/3.0</code>，不同版本的 HTTP 特性是不一样的。</p>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>HTTP 最突出的优点是「简单(格式简单)、灵活和易于扩展（在应用层请求头和响应头可扩展）、应用广泛和跨平台」。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>长连接</li>
<li>管道网络传输，解决了请求的对头阻塞。</li>
</ul>
<h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<h5 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h5><p>在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>
<p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.webp" srcset="/img/loading.gif" lazyload></p>
<p><strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。<br>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。<br><strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="传输上"><a href="#传输上" class="headerlink" title="传输上"></a>传输上</h4><ul>
<li>数据量大</li>
<li>响应阻塞</li>
</ul>
<h4 id="安全性上"><a href="#安全性上" class="headerlink" title="安全性上"></a>安全性上</h4><ul>
<li>无状态：无状态使服务器不用记忆http状态，但关联性操作会比较麻烦。可使用cookie技术解决。</li>
<li>明文传输：信息容易被爬</li>
<li>不安全：<ul>
<li>明文导致密码泄露</li>
<li>假网站</li>
<li>无法证明报文完整性</li>
</ul>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="与HTTP的区别"><a href="#与HTTP的区别" class="headerlink" title="与HTTP的区别"></a>与HTTP的区别</h3><ul>
<li>HTTPS 则解决 <strong>HTTP 不安全</strong>的缺陷，在TCP和HTTP网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h3 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h3><p>窃听、篡改、冒充</p>
<h3 id="HTTPS解决的方法"><a href="#HTTPS解决的方法" class="headerlink" title="HTTPS解决的方法"></a>HTTPS解决的方法</h3><ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>采用「混合加密」的方式的原因：</p>
<ul>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
</ul>
<div class="note note-primary">
            <p>对称加密：就是一个密钥加密，并使用同一个密钥解密。<br>非对称加密：一个密钥加密，必须由另一个密钥解密。</p><p>其中非对称加密一般分公钥和私钥，这两个钥匙可以双向加解密。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；（防窃听）</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。（防冒充）</li></ul>
          </div>

<h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p><strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>。（防修改）</p>
<p><strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p>
<div class="note note-primary">
            <p>摘要只保证正文未被修改，不保证正文真伪。</p>
          </div>

<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>数字签名算法</strong>，使用<strong>非对称加密算法</strong>加密哈希值（摘要）。</p>
<p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.webp" srcset="/img/loading.gif" lazyload></p>
<p>由于中间人无法将数据使用私钥加密，其伪造的hash无法被公钥解密，所以可以得知数据被人替换过了。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>摘要和签名算法已经保证了数据不会被篡改和不被冒充。<br>但实现过程中存在漏洞：公钥的获取，客户端需要根据公钥来识别数字签名。</p>
<p><strong>数字证书认证机构</strong>CA：</p>
<ul>
<li>服务器可以将自己的公钥注册到CA机构，CA使用私钥将其加密后颁发数字证书。</li>
<li>客户端根据服务器发送的证书和公钥，将其使用CA公钥解开对比即可得知其是否得到了CA的信任。</li>
</ul>
<p>验证流程：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp" srcset="/img/loading.gif" lazyload></p>
<h3 id="TLS握手阶段"><a href="#TLS握手阶段" class="headerlink" title="TLS握手阶段"></a>TLS握手阶段</h3><p>SSL&#x2F;TLS 协议基本流程：</p>
<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
</ul>
<p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a>。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp" srcset="/img/loading.gif" lazyload></p>
<p>TLS 协议建立的详细流程：<br><em>1. ClientHello</em><br>客户端向服务器发送以下信息（明文）：<br>（1）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。<br>（2）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p>
<p><em>2. SeverHello</em><br>服务器回应的内容有如下内容（明文）：<br>（1）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。<br>（2）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</p>
<p><em>3.客户端回应</em><br>验证CA证书，取出公钥，并使用公钥加密（服务器公钥加密）：<br>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>
<p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
<blockquote>
<p>由于使用服务器公钥加密，所以只有服务器可以解密得知pre-master-key，即第三个随机数中间人无法获取。</p>
</blockquote>
<p><em>4. 服务器的最后回应</em><br>计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p>
<blockquote>
<p>第三、四次握手只有第三次握手传了第三个随机数，剩下的两个内容类似TCP握手协议中的FIN，ACK确认。</p>
</blockquote>
<h3 id="TLS握手算法"><a href="#TLS握手算法" class="headerlink" title="TLS握手算法"></a>TLS握手算法</h3><p>不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p>
<h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的。<br>过程：与上面的过程相同。<br><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。一旦服务端的私钥泄漏了，过去被第三方截获的所有TLS通讯密文都会被破解。</p>
<h4 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h4><p>ECDHE 密钥协商算法是 DH 算法演进过来的。</p>
<h5 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h5><p>DH算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.webp" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>底数a和模数p是离散对数的公共参数，也就说是公开的。</li>
<li>b是真数（私钥），i是对数（公钥）。</li>
<li>知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</li>
</ul>
<h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>通讯双方各自根据自己的私钥，使用固定算法得到自己的公钥并交换。<br>根据得到的对方公钥，和自己的私钥计算，双方此时得到相同的密钥。<br>（这个算法具有交换律）</p>
<h5 id="DHE"><a href="#DHE" class="headerlink" title="DHE"></a>DHE</h5><p>根据私钥生成的方式，DH 算法分为两种实现：</p>
<ul>
<li>static DH 算法，这个是已经被废弃了；</li>
<li>DHE 算法，现在常用的；</li>
</ul>
<p>static DH不具有前向安全性，后者表示每次动态生成密钥。</p>
<h5 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h5><p>为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。利用了ECC 椭圆曲线特性。</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p><strong>在TLS第四次握手前，客户端就已经发送了加密的 HTTP 数据，即ECDHE相比RSA握手过程省去了一个消息往返的时间</strong>。</p>
<ul>
<li>第一次握手与RSA类似</li>
<li>第二次握手新增了选择椭圆曲线和基点，动态生成了私钥和公钥，同时使用<strong>RSA签名算法</strong>给公钥签名并发送。</li>
<li>第三次握手验证CA后根据椭圆信息也生成私钥和公钥，并回复公钥。</li>
<li>第四次握手类似，回复确认过程没问题即可。</li>
</ul>
<div class="note note-primary">
            <ul><li>ECDHE每次动态生成密钥和公钥，支持前向保密。</li><li>客户端可以在三次握手后就开始传输数据</li><li>在 TLS 第2次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li><li>依然使用了RSA算法，服务端使用了static私钥签名曲线公钥，用于保证发送的公钥不被篡改。</li></ul>
          </div>

<h4 id="证书校核"><a href="#证书校核" class="headerlink" title="证书校核"></a>证书校核</h4><p>颁发和校核流程：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp" srcset="/img/loading.gif" lazyload><br>信任链：<br>我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.webp" srcset="/img/loading.gif" lazyload><br>验证链：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E9%93%BE.webp" srcset="/img/loading.gif" lazyload></p>
<p>为何不直接由Root CA验证：<br><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p>
<h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p><em>SSL&#x2F;TLS</em>：SSL 是 “_Secure Sockets Layer_” 的缩写，中文叫做「安全套接层」。其标准化之后的名称改为 TLS（ “_Transport Layer Security_” ），即「传输层安全协议」。</p>
<p>_TLS1.3_：TLS1.3相对TLS1.2做了优化，其只需要<strong>3次</strong>握手：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/tls1.2and1.3-1.webp" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</li>
<li>由于省去算法协商，直接互相交换使用相同算法计算过的公钥即完成了交换和计算，从而只需要3次握手（1RTT）。</li>
<li>重连时，使用Ticket技术优化的话可以在0RTT内完成重连(<strong>会话恢复机制</strong>)。</li>
</ul>
<h3 id="HTTPS的应用数据是如何保证完整性的？"><a href="#HTTPS的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS的应用数据是如何保证完整性的？"></a>HTTPS的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p>
<ul>
<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>
<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li>
</ul>
<p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp" srcset="/img/loading.gif" lazyload></p>
<p>具体过程如下：</p>
<ul>
<li>切割消息并压缩。</li>
<li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>通过对称密码进行加密。</li>
<li>加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>
</ul>
<p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p>
<h3 id="HTTPS一定可靠吗？"><a href="#HTTPS一定可靠吗？" class="headerlink" title="HTTPS一定可靠吗？"></a>HTTPS一定可靠吗？</h3><p>如前面说的，HTTPS中CA部分是为了防止冒充，但这里中间人自己有证书，从而实现了服务代理。但这种证书其实是非法的，只要用户不主动接受非法证书，否则是不会出现问题的。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.webp" srcset="/img/loading.gif" lazyload></p>
<p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p>
<h3 id="如何避免被抓包"><a href="#如何避免被抓包" class="headerlink" title="如何避免被抓包"></a>如何避免被抓包</h3><ol>
<li>不点击允许非法证书（中间人攻击）</li>
<li>HTTPS双向认证，即服务端也要验证客户端信息。</li>
</ol>
<h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><strong>HTTP&#x2F;2协议是基于HTTPS的。</strong><br>其兼容了老版本的HTTP&#x2F;1.1，即其仍使用http表示明文，https表示加密，而浏览器和服务器可以在背后实现协议升级。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/25-HTTP2.webp" srcset="/img/loading.gif" lazyload></p>
<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>主动推送</li>
</ul>
<div class="note note-primary">
            <p>2个特点压缩信息，2个特点加强传输。</p>
          </div>

<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p>
<p>使用<code>HPAKC</code>算法，维护一张头信息表，为每个头信息生成一个id号，以后就可以只传id。</p>
<h4 id="HPAK算法"><a href="#HPAK算法" class="headerlink" title="HPAK算法"></a>HPAK算法</h4><ul>
<li>静态字典：有61种固定id和对应含义；</li>
<li>动态字典：自行构建动态表，发送一次后，双方都会更新自己的动态表（一个id保存本次所有Header字段），下次可以只发id；<ul>
<li>动态表生效前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。因此会造成内存占用过大，服务器一般会配置参数限制动态表大小，达到数量后关闭HTTP&#x2F;2连接来释放内存。</li>
</ul>
</li>
<li>Huffman 编码（压缩算法）；</li>
</ul>
<p>另外由于使用二进制表达，也不需要冒号空格和末尾的<code>\r\n</code>作为分隔符了，改用表示字符串长度（Value Length）来分割 Index 和 Value，一个Header字段：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224430.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>头信息和数据体都直接为二进制格式，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp" srcset="/img/loading.gif" lazyload><br>这样解析数据时，可以直接解析二进制文件。</p>
<h4 id="二进制帧结构"><a href="#二进制帧结构" class="headerlink" title="二进制帧结构"></a>二进制帧结构</h4><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224926.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>帧长度后面的一个字节是表示<strong>帧的类型</strong>，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类。</li>
<li>帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息，比如：</li>
</ul>
<h3 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h3><p>HTTP&#x2F;1.1使用<strong>请求-响应</strong>模型，因此会产生对头阻塞。<br>HTTP&#x2F;2引入了Stream概念，使多个stream复用一个TCP连接：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/stream.webp" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>1 个 TCP 连接包含多个 Stream。<br>1 个 Stream 里可以包含多个 Message。<br>1 个 Message 对应 HTTP&#x2F;1 中的1个请求或响应，可以包含多个Frame</p>
</blockquote>
<p>每个HTTP请求（Message）都有独一无二的<strong>SteamID</strong>，这样接受端可以通过StreamID将多个Frame有序组装成一个HTTP消息。</p>
<ul>
<li>不同StreamID是可以乱序发送的。</li>
<li>相同Stream的frame必须有序发送。</li>
</ul>
<p>HTTP&#x2F;2 还可以对每个 Stream 设置不同<strong>优先级</strong>，在枕头中的标志位展示。</p>
<p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.webp" srcset="/img/loading.gif" lazyload></p>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID也是有区别的：</p>
<ul>
<li>客户端建立的Stream必须是奇数号。</li>
<li>服务器建立的Stream必须是偶数号。</li>
</ul>
<p>如下：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206191054.png" srcset="/img/loading.gif" lazyload><br>应用有：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/push.webp" srcset="/img/loading.gif" lazyload><br>主动推送css文件。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>还是存在队头阻塞问题，问题出在TCP层面。</li>
</ul>
<h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><ul>
<li><strong>使用UDP，解决了TCP的阻塞问题。</strong></li>
<li>然后使用<strong>QUIC协议</strong>实现UDP可靠传输。</li>
</ul>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>特点：</p>
<ul>
<li>无队头阻塞</li>
<li>更快的连接建立</li>
<li>连接迁移</li>
</ul>
<p><em>1、无队头阻塞</em><br>多路复用，类似HTTP&#x2F;2的stream，但不受限于TCP了。<br><strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。<br>这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响（TCP）。</p>
<p><em>2、更快的连接建立</em><br>HTTP&#x2F;3 在传输数据前需要 QUIC 协议3次握手，需要 1 RTT。握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>
<p>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，其内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 <strong>TLS&#x2F;1.3</strong>，因此仅需 <strong>1 个 RTT</strong> 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.webp" srcset="/img/loading.gif" lazyload><br>对于第二次连接，应用数据包+QUIC(TLS+连接信息)，可以实现0-RTT。</p>
<p>以下是TCP+TLS1.2，TCL+TLS1.3，QUIC三种情况在首次和再次需要的RTT时间：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206210341.png" srcset="/img/loading.gif" lazyload></p>
<div class="note note-primary">
            <p><strong>RTT是针对客户端建立连接耗时。</strong><br>TCP+TLS1.2：</p><ul><li>首次：TCP三次握手+TLS四次握手（TCP第三次握手合并，最后合并为6个）：3RTT</li><li>再次：TCP三次握手+TLS两次握手（TCP第三次握手合并，TLS使用Session技术，合并为4个）：2RTT<br>TCP+TLS1.3:</li><li>首次：TCP三次握手+TLS三次握手（TCP第三次握手合并，合并为5个）：2RTT</li><li>再次：TCP三次握手+TLS零次握手（TLS使用Ticket技术，合并为3个）：1RTT<br>QUIC+TLC1.3：</li><li>首次：QUIC三次握手+TLS三次握手（全程合并，为3个）：1RTT</li><li>再次：QUIC一次握手+TLS零次握手（QUIC和TLS使用Ticket技术，合并为1个）：0RTT</li></ul><p>RTT记忆：32,21,10。</p>
          </div>

<p><em>3、连接迁移</em><br>四元组确定一个独立的<strong>TCP</strong>连接。<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206211242.png" srcset="/img/loading.gif" lazyload><br><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。</p>
<p>QUIC 协议没通过<strong>连接 ID</strong> 来标记通信的两个端点。只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，达到了<strong>连接迁移</strong>的功能。</p>
<blockquote>
<p>QUIC比较新，而又是基于 UDP 实现的，如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p>
</blockquote>
<h4 id="帧格式对比"><a href="#帧格式对比" class="headerlink" title="帧格式对比"></a>帧格式对比</h4><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206225705.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>类型：大体上分为数据帧和控制帧两大类，Headers 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</li>
<li>压缩：头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。</li>
<li>相比HTTP&#x2F;2，HTTP&#x2F;3的静态扩大了，动态表的解码方式不同，QPACK解决了该问题：使用两个特殊的单向流，实现字典的请求同步和响应。</li>
</ul>
<blockquote>
<p>动态表具有时序性，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。</p>
</blockquote>
<h1 id="三、HTTP1-1优化"><a href="#三、HTTP1-1优化" class="headerlink" title="三、HTTP1.1优化"></a>三、HTTP1.1优化</h1><p>我们可以从下面这三种优化思路来优化 HTTP&#x2F;1.1 协议：</p>
<ul>
<li>_尽量避免发送 HTTP 请求_；</li>
<li>_在需要发送 HTTP 请求时，考虑如何减少请求次数_；</li>
<li>_减少服务器的 HTTP 响应的数据大小_；</li>
</ul>
<h2 id="避免发送HTTP请求"><a href="#避免发送HTTP请求" class="headerlink" title="避免发送HTTP请求"></a>避免发送HTTP请求</h2><p>本地缓存：将请求url作为key，响应作为value保存到本地磁盘上。</p>
<ul>
<li>根据<code>Cache-Control</code>或<code>Expires</code>请求头实现强制缓存。</li>
<li>根据<code>Last_Modified</code>或<code>Ttag</code>请求头实现协商缓存。</li>
</ul>
<h2 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h2><ul>
<li>_减少重定向请求次数_；</li>
<li>_合并请求_；</li>
<li>_延迟发送请求_；</li>
</ul>
<h3 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h3><p><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.webp" srcset="/img/loading.gif" lazyload><br><strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong><br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.webp" srcset="/img/loading.gif" lazyload><br>代理服务器已知重定向规则后，直接实现代理访问：<br><img src="/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.webp" srcset="/img/loading.gif" lazyload></p>
<h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>多个小请求合并成大请求，body一样但避免了header重复。</p>
<p>另外，HTTP&#x2F;1.1的管道模式默认不开启，即存在请求队头阻塞问题，浏览器的处理方式是多开几个TCP连接一起访问，所以合并请求也可以减少TCP连接的数量。</p>
<h3 id="延迟发送请求"><a href="#延迟发送请求" class="headerlink" title="延迟发送请求"></a>延迟发送请求</h3><p>即懒加载。</p>
<h2 id="减少HTTP响应的数据大小"><a href="#减少HTTP响应的数据大小" class="headerlink" title="减少HTTP响应的数据大小"></a>减少HTTP响应的数据大小</h2><p><strong>压缩</strong>的方式一般分为 2 种，分别是：</p>
<ul>
<li>_无损压缩_；</li>
<li>_有损压缩_；</li>
</ul>
<h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Encoding: gzip, deflate, br<br></code></pre></td></tr></table></figure>
<h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>q表示质量引子。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: audio/*; q=<span class="hljs-number">0</span>.<span class="hljs-number">2</span>, audio/basic<br></code></pre></td></tr></table></figure>

<h3 id="增量数据"><a href="#增量数据" class="headerlink" title="增量数据"></a>增量数据</h3><p>对于视频和声音等，可以使用增量数据的方式表示后续帧。<br>对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p>
<div class="note note-primary">
            <p>记忆总结：</p><ul><li>数量上不发</li><li>数量上少发</li><li>大小上减少</li></ul>
          </div>

<h1 id="四、HTTPS优化"><a href="#四、HTTPS优化" class="headerlink" title="四、HTTPS优化"></a>四、HTTPS优化</h1><h2 id="性能消耗"><a href="#性能消耗" class="headerlink" title="性能消耗"></a>性能消耗</h2><p>产生性能消耗的两个环节：</p>
<ul>
<li>第一个环节， TLS 协议握手过程；</li>
<li>第二个环节，握手后的对称加密报文传输。</li>
</ul>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p><strong>HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</strong>，可以选择对应指令优化的CPU。</p>
<h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><ul>
<li>软件升级：Linux系统内核升级</li>
<li>协议优化：<ul>
<li>ECDHE密钥交换，客户端不用等第四次握手就可以发送消息。</li>
<li>TLS升级1.3，1RTT即完成握手。</li>
</ul>
</li>
</ul>
<h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><h4 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h4><p>相同强度下，椭圆曲线（ECDSA）证书比RSA证书密钥长度更短</p>
<h4 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h4><p>减少验证链的过程。</p>
<p>CRL：证书吊销列表（_Certificate Revocation List_）<br>即快速失败策略，会越来越大，也不好维护，已经不再使用。<br>OCSP：在线证书状态协议（_Online Certificate Status Protocol_），<strong>向CA发送请求查询，返回有效状态</strong>。</p>
<h5 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h5><p>服务器向CA周期性查询证书状态，并缓存经过<strong>签名</strong>结果。<br>客户端发起连接请求时，服务器把响应结果回复给客户端。<br>由于<strong>签名</strong>的存在，服务器无法篡改。</p>
<div class="note note-primary">
            <p>即把客户端CA验证变成了服务端统一验证。</p>
          </div>

<h2 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h2><ul>
<li>第一种叫 Session ID，1RTT；</li>
<li>第二种叫 Session Ticket，1RTT；</li>
<li>第三种叫 Pre-shared Key，0RTT；</li>
</ul>
<h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p><strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>。</p>
<p>缺点是占用内存（空间换时间），且不一定会命中上次访问过地服务器。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p><strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。<br>客户端缓存Ticket，下次连接时发送，服务器直接解密校验。</p>
<p>缺点是要确保每台服务器的加解密方式一样，且不具有前向安全性。</p>
<h3 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h3><p>对于<strong>重连 TLS1.3</strong>只需要 0 RTT，原理与Ticket类似，但其重连时会直接把Ticket和HTTP一起发送给服务端。</p>
<h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>中间人获取Session ID&#x2F;Ticket后模拟客户端不断请求。因此，要对<strong>对会话密钥设定一个合理的过期时间</strong>，并只对安全请求使用会话重用。</p>
<h1 id="五、RPC协议"><a href="#五、RPC协议" class="headerlink" title="五、RPC协议"></a>五、RPC协议</h1><h2 id="TCP存在的问题"><a href="#TCP存在的问题" class="headerlink" title="TCP存在的问题"></a>TCP存在的问题</h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。<br>由于TCP是<strong>基于字节流</strong>的，字节之间没有边界，会造成<strong>粘包问题</strong>。因此，一般使用TCP时，还需要自定义一些信息，如消息头中标记长度，从而取出正确的数据。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。<br>主要思想是像调用本地方法一样调用远程方法。<br><img src="/Pasted%20image%2020230207112106.png" srcset="/img/loading.gif" lazyload><br>有非常多款式的 RPC 思想的实现，比如比较有名的<code>gRPC</code>，<code>thrift</code>。虽然大部分 RPC 协议底层使用 TCP，但实际上<strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p>
<h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><h3 id="存在"><a href="#存在" class="headerlink" title="存在"></a>存在</h3><ul>
<li>为什么有了HTTP还要RPC：RPC在HTTP前诞生</li>
<li>为什么有了RPC还要HTTP：B&#x2F;S架构的诞生，需要统一协议。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul>
<li>HTTP访问需要<strong>IP</strong>和<strong>端口</strong>。</li>
<li>RPC访问时，可以找中间服务获取IP等信息。</li>
</ul>
<p>本质上区别不大。</p>
<h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><ul>
<li>RPC和HTTP1.1一样，有长连接</li>
<li>RPC和HTTP一样，可以存在连接池</li>
</ul>
<h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>RPC定制化程度更高，序列化协议的体积更小，因此<strong>性能</strong>也更好。</p>
<blockquote>
<p>当然上面说的 HTTP，其实<strong>特指的是现在主流使用的 HTTP&#x2F;1.1</strong>，<code>HTTP/2</code> 在前者的基础上做了很多改进，所以<strong>性能可能比很多 RPC 协议还要好</strong>，甚至连 <code>gRPC</code> 底层都直接用的 <code>HTTP/2</code>。</p>
</blockquote>
<h1 id="六、WebSocket"><a href="#六、WebSocket" class="headerlink" title="六、WebSocket"></a>六、WebSocket</h1><h2 id="服务器主动推送消息的方式"><a href="#服务器主动推送消息的方式" class="headerlink" title="服务器主动推送消息的方式"></a>服务器主动推送消息的方式</h2><ul>
<li>HTTP不断轮询：轮询存在间隔，有卡顿，浪费资源。</li>
<li>长轮询:即将超时时间设置的很长，出现响应后才回复（扫码）</li>
<li>WebSocket</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>HTTP&#x2F;1.1，使用了半双工的方式（请求-响应）。</p>
<h3 id="建立WebSocket连接"><a href="#建立WebSocket连接" class="headerlink" title="建立WebSocket连接"></a>建立WebSocket连接</h3><p>1）浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p>
<ul>
<li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是继续用普通 HTTP 协议进行交互。</li>
<li>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：即浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<br><span class="hljs-symbol">Upgrade:</span> WebSocket<br><span class="hljs-keyword">Sec</span>-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n<br></code></pre></td></tr></table></figure></li>
</ul>
<p>2）服务器接受到消息后，如果也想升级成WebSocket协议，则走WebSocket 握手流程，同时根据客户端生成的base64码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols\r\n<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>WebSocket\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade\r\n<br></code></pre></td></tr></table></figure>

<p>3）浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p>
<h3 id="WebSocket消息格式"><a href="#WebSocket消息格式" class="headerlink" title="WebSocket消息格式"></a>WebSocket消息格式</h3><p>数据包在WebSocket中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。<br><img src="/Pasted%20image%2020230207113622.png" srcset="/img/loading.gif" lazyload><br><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p>
<ul>
<li>等于 1 ，是指text类型（<code>string</code>）的数据包</li>
<li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li>
<li>等于 8 ，是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p>
<ul>
<li>既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit 或 7+64bit。</code></li>
<li>根据最前面7bit的数值绝对，若为126则实际上为<code>16bit</code>，127则实际上为<code>64bit</code>。</li>
</ul>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p>
<p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%85%AB%E8%82%A1/" class="category-chain-item">八股</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-chain-item">计算机网络</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%85%AB%E8%82%A1/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%85%AB%E8%82%A1/">#八股</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络-HTTP</div>
      <div>http://example.com/2023/02/06/计算机网络-HTTP/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jireyo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/" title="计算机网络-TCP">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络-TCP</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/03/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/" title="JUC第5章（线程池）">
                        <span class="hidden-mobile">JUC第5章（线程池）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.7/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://twikoo-api-lime.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
              Fluid.plugins.imageCaption(imgSelector);
              Fluid.plugins.fancyBox(imgSelector);
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
