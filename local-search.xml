<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis第5章（高可用）</title>
    <link href="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <url>/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p></blockquote><p><strong>主从复制的作用</strong>主要包括：<br>性能上：</p><ul><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>稳定性上：</li><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><p>读写分离：</p><ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>分类：</p><ul><li>全量复制</li><li>增量复制</li></ul><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104040638.jpg"><br><strong>第一阶段</strong>：主从库间建立连接、协商同步的过程。</p><ul><li>从节点发送psync命令，其应该包含主库的runId和offset，但这是初次复制，所以发送的runId&#x3D;?,offset&#x3D;-1。</li><li>主节点回复FULLRESYNC，并携带runId和offset，告诉从节点自身信息。<br><strong>第二阶段</strong>：主库将所有数据同步给从库。</li><li>主库执行bgsave，将其发送给RDB。</li><li>从库接受到RDB时，先清空数据库，再加载RDB。</li><li>主库在这一阶段会把新的写命令记录在repl buffer中。<br><strong>第三阶段</strong>：主库发送期间同步期间产生的新的写命令。<div class="note note-primary">            <p>注意这里的repl buffer，前面讲AOF持久化时，也有一个aof_buffer，用于记录<strong>重写</strong>时的新写入命令。</p>          </div></li></ul><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><blockquote><p>每次都全量复制的开销过大。</p></blockquote><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104041537.jpg"></p><p><code>repl_backlog_buffer</code>：环形缓冲区，用于记录写命令（会覆盖）。</p><p><code>replication buffer</code>：每个client连上Redis后，<strong>Redis都会分配一个client buffer</strong>，所有数据交互都是通过这个buffer进行的。Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。</p><h4 id="全量复制还是增量复制？"><a href="#全量复制还是增量复制？" class="headerlink" title="全量复制还是增量复制？"></a>全量复制还是增量复制？</h4><p>从库会记录自己的<code>slave_repl_offset</code>，恢复连接时，从库会通过<code>psync</code>发送自己的offset，主库根据这个offset判断进行增量还是全量复制。（如果<code>repl_backlog_buffer</code>的<code>slave_repl_offset</code>已经被覆盖，进全量复制）。</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="主服务器持久化与安全性"><a href="#主服务器持久化与安全性" class="headerlink" title="主服务器持久化与安全性"></a>主服务器持久化与安全性</h3><ul><li>主从复制时，主服务器强烈建议开启持久化。</li><li>若主节点没有开启持久化，又开启了自动重启，重启后主节点数据库为空，而从节点对其进行全量复制，会导致从节点数据也被删除。</li><li>所以，若主节点没有开启持久化，应该禁止自动重启。</li></ul><h3 id="为什么主从全量复制使用RDB而不使用AOF"><a href="#为什么主从全量复制使用RDB而不使用AOF" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF"></a>为什么主从全量复制使用RDB而不使用AOF</h3><ul><li>RDB文件很小，适合传输</li><li>RDB加载很快，适合恢复</li><li>AOF使用不当，会严重影响Redis性能</li></ul><h3 id="无磁盘复制模式"><a href="#无磁盘复制模式" class="headerlink" title="无磁盘复制模式"></a>无磁盘复制模式</h3><p>主服务器磁盘速度较低时，RDB会带来一些负担，<strong>无磁盘复制模式</strong>是指：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。<br>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><h3 id="从库的从库"><a href="#从库的从库" class="headerlink" title="从库的从库"></a>从库的从库</h3><p>对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。<br>通过“主 - 从 - 从”模式可以<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。<br><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104045116.jpg"><br>后续的写同步也可以级联传播。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="延迟与不一致问题"><a href="#延迟与不一致问题" class="headerlink" title="延迟与不一致问题"></a>延迟与不一致问题</h4><p><strong>优化</strong>：优化网络环境、舍弃大延迟从节点，使用集群扩展读负载能力。</p><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><p>单机redis的删除策略</p><ul><li><strong>惰性删除</strong>：客户端查询数据时才判断是否过期，过期则删除</li><li><strong>定期删除</strong>：服务器定时任务删除过期数据<br>主从复制时，从节点不主动删除，而是由主节点控制从节点删除（保证数据一致性），但由于主节点不会立即删除过期数据，客户端在从节点上容易读到过期数据。<br><strong>解决</strong>：Redis3.2中，从节点也会判断数据过期。</li></ul><h4 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h4><p>主&#x2F;从节点发生故障时，要及时切换客户端的Redis连接。</p><ul><li>手动：响应慢，容易出错</li><li>监控程序：实现复杂<div class="note note-primary">            <p>使用哨兵即可解决这个问题。</p>          </div></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第4章（事件与事物）</title>
    <link href="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>所谓事件机制，指的是Redis 接受客户端的请求并响应（文件事件） 和 执行定时任务（时间事件） 的机制。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><div class="note note-primary">            <p>文件事件指交互性事件，时间事件指定时类执行事件。</p>          </div><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104015729.png"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p><p>Redis 是单线程主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>。采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。</p><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020000.png"></p><div class="note note-primary">            <p>这里还没学，暂时理解为netty、ae_event(Redis使用的)等是异步处理IO复用的应用框架，底层的实现库是与操作系统的具体实现有关。</p>          </div><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020123.png"><br>I&#x2F;O多路复用程序监听多个套接字（客户端），当需要套接字IO时，产生一个文件事件，Redis将这些就绪的文件事件放在一个队列中（fired就绪事件表），然后文件事件处理器会有序、同步、单个的执行一个个文件事件。</p><p>某客户端请求流程如下：<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020550.png"></p><h3 id="Redis-IO多路复用模型"><a href="#Redis-IO多路复用模型" class="headerlink" title="Redis IO多路复用模型"></a>Redis IO多路复用模型</h3><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020629.jpg"></p><div class="note note-primary">            <p>这里理解为epoll是一个操作系统内核机制，其监听了3个FD（套接字），当发生事件时，事件入列，然后逐个出列调用函数。</p>          </div><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis 的时间事件分为以下两类：</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：也就是说时间处理器处理某个事件后，判断其需不需要过一段时间再次执行。<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104022102.png"><br>所有事件时间放在一个无序链表中，时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件并调用相应事件处理器。</p><blockquote><p>一般Redis服务器只使用serverCron一个时间事件，这个事件用于更新服务器各类统计数据，清理键值，整理客户端连接，尝试AOF或RDB，同步数据，心跳检测等。总之，Redis会周期性的执行这个函数。</p></blockquote><h2 id="aeEventLoop实现"><a href="#aeEventLoop实现" class="headerlink" title="aeEventLoop实现"></a>aeEventLoop实现</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。具体过程是其会调用aeCreateEventLoop函数：</p><ul><li>创建该aeEventLoop对象。</li><li>初始化文件事件表内容</li><li>初始化时间事件表</li><li>调用aeApiCreate函数创建epoll实例，初始化apidata<br>具体实现不细看了，逻辑图如下<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104024156.png"></li></ul><h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li><code>MULTI</code> ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li><code>EXEC</code>：执行事务中的所有操作命令。</li><li><code>DISCARD</code>：取消事务，放弃执行事务块中的所有命令。</li><li><code>WATCH</code>：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li><code>UNWATCH</code>：取消WATCH对所有key的监视。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>语法错误：若存在语法错误，整个事务不会被执行。</li><li>类型错误：若在执行时发送Redis类型错误，该条命令失败，但其他命令正常执行。</li></ul><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p>WATCH命令为Redis事务提供了CAS的行为：<br>当执行了WATCH命令监视某键后，在执行时发现与WATCH时相比，键值发生了变化，则回滚事务。最后会取消监控。<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025042.png"></p><h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><ul><li>MULTI开始</li><li>入队</li><li>执行<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025058.png"></li></ul><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="Redis不支持回滚？"><a href="#Redis不支持回滚？" class="headerlink" title="Redis不支持回滚？"></a>Redis不支持回滚？</h3><p>redis只会因语法错误（主要指类型错误这种无法提前检测的命令）而失败，这个错误是在编程时应该避免的。</p><h3 id="ACID？"><a href="#ACID？" class="headerlink" title="ACID？"></a>ACID？</h3><ul><li>原子性<em>atomicity</em><br>有观点认为Redis没有原子性，因为其不支持运行期回滚，但Redis官方的理解如下：<br><strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。</strong>这个过程并不保证执行成功。</li><li>一致性<em>consistency</em><br>Redis能保证命令失败的情况下回滚（普通语法错误、WATCH锁），能保证一致性。</li><li>隔离性<em>Isolation</em><br><strong>单线程</strong>的本质保证了隔离性（不会被其他客户端打断）</li><li>持久性<em>Durability</em><br><strong>redis事务是不保证持久性的</strong>，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</li></ul><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><ul><li><strong>基于Lua脚本</strong>，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li><strong>基于中间标记变量</strong>，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第3章（持久化）</title>
    <link href="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/"/>
    <url>/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="持久化：RDB和AOF机制详解"><a href="#持久化：RDB和AOF机制详解" class="headerlink" title="持久化：RDB和AOF机制详解"></a>持久化：RDB和AOF机制详解</h2><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(<em>Redis DataBase</em>)持久化</h3><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><blockquote><p><strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><code>save</code>命令：由主线程执行，会造成长时间阻塞。</li><li><code>bgsave</code>命令：fork子线程执行，阻塞只发生在fork阶段。</li></ul><p><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103211303.png"></p><p>具体流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，<strong>那么主进程直接返回</strong>；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子<strong>替换</strong>旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_相关选项）。</li></ul><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>由以下4种触发情况</p><ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul><p><strong>相关配置</strong><br><code>stop-writes-on-bgsave-error</code>：bgsave错误时暂停主线程，主要目的是让运维人员排查问题<br><code>rdbcompression</code>：启用LZF压缩算法<br><code>rdbchecksum</code>：64位CRC冗余校验编码，可以验证RDB的完整性。</p><h4 id="深入RDB"><a href="#深入RDB" class="headerlink" title="深入RDB"></a>深入RDB</h4><ul><li><p><strong>并发问题？</strong><br><a href="https://zhuanlan.zhihu.com/p/339437815#:~:text=%20Redis%E4%B8%AD%E6%89%A7%E8%A1%8CBGSAVE%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90RDB%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E8%B0%83%E7%94%A8Linux%E4%B8%AD%E7%9A%84fork%20%28%29%E5%91%BD%E4%BB%A4%EF%BC%8CLinux%E4%B8%8B%E7%9A%84fork,%28%29%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%BA%86copy-on-write%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9B%20fork%20%28%29%E4%B9%8B%E5%90%8E%EF%BC%8Ckernel%E6%8A%8A%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E6%9D%83%E9%99%90%E9%83%BD%E8%AE%BE%E4%B8%BAread-only%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%8C%87%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%82%20%E5%BD%93%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%83%BD%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E3%80%82">Copy-on-Write</a><br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103215527.jpg"><br>如果主线程需要进行写操作，则将写操作部分的数据块复制，对新的副本进行修改，这样保证了bgsave子进程可见的数据的一致性（即bgsave开始时的快照）</p></li><li><p><strong>若服务崩溃怎么办？</strong><br>bgsave的temp文件在生成之前不会覆盖旧的dump。</p></li><li><p><strong>能否尽可能快的RDB</strong>?<br>快照过快会导致fork大量阻塞主线程，且磁盘空间是有限的。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li><strong>LZF压缩算法，文件体积远小于内存</strong></li><li>加载速度比AOF快</li></ul></li><li>缺点<ul><li><strong>实时性不够</strong></li><li><strong>开销大</strong></li><li>版本兼容</li><li>RDB文件无法手动修改</li></ul></li></ul><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append only file)持久化"></a>AOF(<em>append only file</em>)持久化</h3><p>执行写命令时，<strong>先写内存，后写日志</strong>。<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220350.jpg"></p><blockquote><p>目的：</p><ol><li>避免额外检查，执行成功才写日志</li><li>不阻塞当前写操作<br>风险：</li><li>完成写内存后中断，日志缺失</li><li>主线程写磁盘压力过大</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220620.jpg"></li><li><strong>AOF重写</strong> Redis通过创建一个新的AOF文件来替换现有的AOF。</li></ul><div class="note note-primary">            <p>aof_buf缓存写命令，触发写回时将aof_buf中命令一次写入磁盘</p>          </div><p><strong>相关配置</strong><br><code>appendfsync</code>：主要用于设置“真正执行”操作命令向AOF文件中同步的策略，支持always、everysec、no，默认为everysec。<br><code>no-appendfsync-on-rewrite</code>：<strong>重写</strong>时不再记录新命令<br><code>auto-aof-rewrite-percentage</code>：当前AOF文件超过上次重写AOF文件大小的百分之多少后开始重写。<br><code>auto-aof-rewrite-min-size</code>：当前AOF文件超过设置大小时开始重写</p><h4 id="深入AOF重写"><a href="#深入AOF重写" class="headerlink" title="深入AOF重写"></a>深入AOF重写</h4><ul><li><strong>AOF重写会阻塞吗</strong>？<br>重写时会fork主线程，由后台进程bgrewriteaof完成，fork时会阻塞主线程。</li><li><strong>何时重写</strong>？<br>auto-aof-rewrite-percentage和auto-aof-rewrite-min-size</li><li><strong>并发问题</strong>？<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103221653.jpg"><br>重写时:</li><li>redis原始数据会通过copy on write机制拷贝</li><li>服务器写入新数据时，会将新数据同时写入两个aof_buf缓存区（当持久化策略为always时，则是写入磁盘和一个aof_buf缓冲），<strong>子线程</strong>完成重写后通知主线程，<strong>主线程</strong>会把aof重写缓冲区的命令追加到aof文件中。最后文件改名，保证原子性。</li></ul><blockquote><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会<strong>拷贝父进程的页表</strong>，即<strong>虚实映射关系</strong>（虚拟内存和物理内存的映射索引表），而<strong>不会拷贝物理内存</strong>。这个拷贝会消耗大量cpu资源，并且<strong>拷贝完成前会阻塞主线程</strong>，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p></blockquote><ul><li><p><strong>重写时有哪些阻塞</strong>？</p><ul><li>fork</li><li>主线程bigkey写入，操作系统需要创建页面副本并拷贝原有数据。</li><li>主线程追加写入aof</li></ul></li><li><p><strong>为什么AOF不复用原AOF文件</strong>？</p><ul><li>父子同时写一个文件产生竞争，影响父进程性能</li><li>若重写失败会造成污染</li></ul></li></ul><h3 id="RDB和AOF混合方式"><a href="#RDB和AOF混合方式" class="headerlink" title="RDB和AOF混合方式"></a>RDB和AOF混合方式</h3><p>在Redis4.0提出，简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志<strong>记录这期间</strong>的所有命令操作。<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222843.jpg"></p><ul><li>RDB不用过快执行，同时AOF也不会过大</li></ul><h3 id="持久化恢复"><a href="#持久化恢复" class="headerlink" title="持久化恢复"></a>持久化恢复</h3><p>重启redis即可恢复<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222858.png"><br>AOF优先级更高，因为其数据更完整。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第2章（对象机制）</title>
    <link href="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><blockquote><p>前面介绍了Redis的基本数据类型，针对这些数据类型有着不同的底层实现。</p></blockquote><p>对象模型：<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190013.png"></p><blockquote><p>Redis对象有不同的数据类型，而一个数据类型可能有多种实现方式（编码类型），根据value的情况灵活变化。<br>编码类型作为一种类型标识，告诉了Redis应该如何解析这个对象，不同编码类型也有不同的底层数据结构实现。</p></blockquote><p>Redis对象机制作用：<br><strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.<br><strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><h1 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190705.png"></p><ul><li>type标识了数据所属的基本类型</li><li>encoding标识了数据类型对于的编码</li><li>LRU记录了数据的最后访问时间和访问次数</li><li>refcount记录了对象被引计数</li><li>ptr指向真实的底层数据结构</li></ul><div class="note note-primary">            <p>redisObject保存了Redis服务器需要维护的对象信息，包括数据结构类型和编码（用于多态解析），LRU（LFU）和refcount（淘汰机制），ptr指向底层数据结构。</p>          </div><h2 id="命令检查与多态"><a href="#命令检查与多态" class="headerlink" title="命令检查与多态"></a>命令检查与多态</h2><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103191229.png"></p><div class="note note-success">            <p>type判断命令是否正确，encoding判断如何执行命令</p>          </div><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>redis一般会把一些常见值放入共享对象中：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192218.png"><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。<br>像整数集合和压缩列表这些将数据保存在数据结构内的则无法使用。</p></blockquote></li></ul><blockquote><p>为什么不共享其他数据结构：<br>复杂度较高，消耗CPU，用其换取内存不划算。</p></blockquote><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h1 id="底层数据对象"><a href="#底层数据对象" class="headerlink" title="底层数据对象"></a>底层数据对象</h1><h2 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h2><p><strong>简单动态字符串（simple dynamic string,SDS</strong>）的存在是为了尽可能的节省存储可见，只为对象分配其需要的空间大小。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192512.png"></p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的<strong>头部</strong>, 分别如下:<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192821.png"><br>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的<code>\0</code>, 剩余的字节数。</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><div class="note note-primary">            <p>实际SDS的长度为 头部+alloc+尾部。<br>len为<code>buf[]</code>中的有效长度，即有效字符串长度。</p>          </div><h3 id="为何使用SDS"><a href="#为何使用SDS" class="headerlink" title="为何使用SDS"></a>为何使用SDS</h3><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li></ul><blockquote><p>在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p></blockquote><h2 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h2><p>ziplist是一个特殊编码的双向列表，其可以存储字符串或整数，操作的时间复杂度为O(1)，每次操作都需要重新分配ziplist的内存。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103194043.png"></p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p>一般</p><ul><li><code>prevlen</code>：前一个entry的大小</li><li><code>encoding</code>：表示当前entry类型和长度</li><li><code>entry-data</code>:存储entry标识的数据<br>特殊<br>类型为int时，<code>encoding</code>和<code>entry-data</code>合并在一起表示，没有<code>entry-data</code>。</li></ul><p><strong>prevlen</strong><br>前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度。<br>如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><p><strong>encoding编码</strong><br>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；<br>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><h3 id="为什么ZipList省内存"><a href="#为什么ZipList省内存" class="headerlink" title="为什么ZipList省内存"></a>为什么ZipList省内存</h3><p>根据数据类型灵活变化编码规则，使用encoding标识entry类型和大小，是。<br>因为是双端列表，为了解决遍历问题，使用prevlen字段方便倒序遍历。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不预留空间，每次写操作都需要重新分配内存。<br>节点扩容可能导致后续所有prevlen字段扩容。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>是一个以ziplist为节点的双端链表结构。</p><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下</li></ul><h3 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103200220.png"></p><ul><li><p><code>quicklist.fill</code>影响ziplist的长度，数值为负数时限制ziplist最大长度，为正数时限制ziplist的entry数量。</p></li><li><p><code>quicklist.compress</code>影响zl字段指向的对象的类型，0标识指向ziplist，1表示链表的头尾节点不压缩，2标识头尾各2各节点不压缩，其他为压缩后的quicklistLZF。</p></li><li><p><code>quicklistNode.encoding</code>，标识本链表节点是否压缩，1表示没压缩，2表示压缩了。</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压。如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><h2 id="字典-x2F-哈系表-Dict"><a href="#字典-x2F-哈系表-Dict" class="headerlink" title="字典&#x2F;哈系表 - Dict"></a>字典&#x2F;哈系表 - Dict</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103201159.png"></p><h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul><li>哈希算法：使用hash函数计算key的哈希值，使用sizemask与第一步得到的hash值，计算索引。</li><li>哈希冲突：链地址法</li><li>扩容&#x2F;缩容：<ul><li>rehash，扩展时创建两倍大小的hash表，缩小时则创建缩小一倍的新哈希表。</li><li>重新计算索引</li><li>迁移所有键值对，然后释放内存</li></ul></li><li>扩容条件：<ol><li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</li><li>ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</li></ol></li><li>渐进式rehash<br>  分多次完成rehash迁移，此时查找会在新旧两个哈希表上找，但是新增只会在新哈希表上新增。</li></ul><h2 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202006.png"></p><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><div class="note note-primary">            <p>可见intset就是一个排序的数组。</p>          </div><p>contents中每个元素的数据类型由encoding决定，当有数字的值超出范围时，集合需要升级，其会：</p><ul><li>扩展整数集合底层数组的可见大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上。（需要继续维持底层数组的有序性质不变）。</li><li>最后改变encoding的值，length+1。</li></ul><p>但intset不会降级，这是没必要的开销。</p><h2 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h2><p>跳表在redis中只用在zset数据类型中，其保证查找删除添加等操作在对数的期望时间内完成。</p><p>原理示例：<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202637.png"></p><p>内存布局：<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202658.png"></p><p><strong>zskiplist的核心设计要点</strong></p><ul><li><strong>头节点</strong>不持有任何数据, 且其<code>level[]</code>的长度为32。</li><li><strong>每个结点</strong><ul><li><code>ele</code>字段，持有数据，是sds类型</li><li><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li><code>level</code>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段<ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在<code>level[]</code>中的索引为X, 则其forward字段指向的结点, 其<code>level[]</code>字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1</li></ul></li></ul></li></ul><h3 id="为什么不用平衡树或者哈希表"><a href="#为什么不用平衡树或者哈希表" class="headerlink" title="为什么不用平衡树或者哈希表"></a>为什么不用平衡树或者哈希表</h3><p>hash无序，无法进行范围查找，平衡数的范围搜索也很复杂，子树的调整也很复杂。</p><h1 id="redis对象与编码-底层结构-对应关系"><a href="#redis对象与编码-底层结构-对应关系" class="headerlink" title="redis对象与编码(底层结构)对应关系"></a>redis对象与编码(底层结构)对应关系</h1><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203244.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串长度不能超过512M。</strong></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li><code>int 编码</code>：保存的是可以用 long 类型表示的整数值。</li><li><code>embstr 编码</code>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><code>raw 编码</code>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203355.png"><br>embstr少一次分配空间，但其为只读,修改时要重新分配一次raw空间。</p><p>ps:<strong>Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型</strong>。</p><ul><li><strong>编码的转换</strong><blockquote><p>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。<br>对于embstr编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p></blockquote></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>按<strong>数值进行操作的数据</strong>，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>quicklist</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203823.png"></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h3><p>ziplist和hashtable</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><ul><li>ziplist</li><li>dict<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204020.png"></li></ul><p>使用ziplist时，新的键值对作为entry插入list尾部。<br>使用hashtable编码时，使用dict。</p><p><strong>编码转换</strong><br>和上面列表对象使用 ziplist 编码一样，当<strong>同时满足下面两个条件</strong>时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节<br>不能满足这两个条件的时候使用 hashtable 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>hash类型下的value只能存储字符串</li><li>每个hash可以存储2^32-1个键值对</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="编码-3"><a href="#编码-3" class="headerlink" title="编码"></a>编码</h3><p>intset或hashtable</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204842.png"></p><p><strong>编码转换</strong><br>当集合同时满足以下两个条件时，使用intset编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512<br>不能满足这两个条件的就使用hashtable编码。第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="编码-4"><a href="#编码-4" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 skiplist(ziplist+dict)</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p>ziplist<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205150.png"></p><p>skiplist(ziplist+dict)<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205236.png"><br>字典可以快速查找成员，但无序，跳表可以快速执行范围查找，将两者结合共同实现有序集合。</p><p><strong>编码转换</strong><br>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。<br>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第1章（数据类型与结构）</title>
    <link href="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <url>/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis知识体系"><a href="#一、Redis知识体系" class="headerlink" title="一、Redis知识体系"></a>一、Redis知识体系</h1><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230191017.png"></p><h1 id="二、Redis概念与基础"><a href="#二、Redis概念与基础" class="headerlink" title="二、Redis概念与基础"></a>二、Redis概念与基础</h1><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。</li><li>数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>持久化：AOF&#x2F;RDB</li><li>发布订阅：Subscribe</li><li>分布式：RedisCluster</li><li>redis为每个服务提供有16个数据库，编号从0到15，默认为0号数据库</li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>热点数据的缓存</li><li>限时任务的运用</li><li>计数器</li><li>分布式锁</li><li>延时操作</li><li>排行榜</li><li>点赞</li></ul><h1 id="三、Redis基础数据类型"><a href="#三、Redis基础数据类型" class="headerlink" title="三、Redis基础数据类型"></a>三、Redis基础数据类型</h1><blockquote><p>Redis所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p></blockquote><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230200246.jpg"></p><div class="note note-primary">            <p><strong>String</strong>也可以是整数和浮点数，支持自增和自减操作。<br><strong>Zset</strong>说是set，实际上结构类似hash，其保存了<strong>字符串成员</strong>和<strong>浮点分数</strong>之间的映射关系。</p>          </div><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>GET,SET,INCR,DECR,INCRBY,DECRBY</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>缓存常用信息，计数器，session.</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis用双端链表实现List。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>LPUSH,LPOP,<strong>LRANGE</strong>(获取范围内元素),LINDEX(获取索引元素)</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>时间轴微博，消息队列（按照时间先后排序的场景）</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序集合，成员唯一。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p>SADD,<strong>SCARD</strong>(获取成员数),SMEMERS(返回所有成员),SISMEMBER(判断是否为成员)</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>文章标签，不需要时间排序的点赞、收藏等。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>field -&gt; value，适合存储对象</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><p>HSET,HGET,HGETALL,HDEL</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>缓存查询信息，适合存储结构体。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>成员唯一。通过了压缩列表和跳跃表两种数据结构实现。<br>压缩列表：提高了存储效率，特殊编码的双向链表。<br>跳跃表：快速查找，删除，添加（对数时间内）</p><div class="note note-primary">            <p>操作时按照跳跃表找到指定位置对数据进行修改，存储时以压缩列表形式存储。</p>          </div><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>ZADD,ZRANGE,ZREM</p><h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>排行榜</p><h1 id="四、Redis特殊类型结构"><a href="#四、Redis特殊类型结构" class="headerlink" title="四、Redis特殊类型结构"></a>四、Redis特殊类型结构</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构</p></blockquote><p>基数统计，可以理解为高性能的set，但精确度有限（0.81% 标准误差）。<br>基数指的是set中每一个不重复的元素，其可以解决海量数据统计的问题，其优势在于存储消耗的空间很小。</p><h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfadd key1 a b c  #创建第一组元素<br>pfcount key1 #统计元素个数<br>pfmerge key3 key1 key2 #合并key1,key2到key3<br></code></pre></td></tr></table></figure><h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><p>每日访问IP数，在线用户数等</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>位存储，使用位记录 0，1两个状态。</p><h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">setbit key 0 1  #设置第0位为1<br>getbit key 0 #获取第0位<br>bitcount key #求1的数量<br></code></pre></td></tr></table></figure><h3 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h3><p>记录每条的打卡情况</p><h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了!</p></blockquote><h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">geoadd china:city(相当于key) 118 32 beijing(相当于value对象)#即可以为一个区域添加多个点<br>geopos china:city beijing<br>geodist china:city beijing shenyang m #以M为单位求两地距离<br>georadius china:city 110 30 1000 km #求中国城市中，以110，30为中心，1000km为半径范围内所有城市。<br>geohash china:city beijing #较少使用,返回hash字符串<br></code></pre></td></tr></table></figure><h3 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h3><p>附近的人code</p><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>底层实现是Zset，其将经纬度转换为一个分数保存在其中。</p><h1 id="五、消息队列Steam"><a href="#五、消息队列Steam" class="headerlink" title="五、消息队列Steam"></a>五、消息队列Steam</h1><p>借鉴了Kafka，是一种消息队列的实现。</p><blockquote><p>Redis的消息队列实现很多：</p><ul><li>Pub&#x2F;Sub，缺点：丢失的消息无法持久化。</li><li>List，缺点：不支持多播，持久化。</li></ul></blockquote><p>消息队列设计<br><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230213704.png"></p><h2 id="Stream结构"><a href="#Stream结构" class="headerlink" title="Stream结构"></a>Stream结构</h2><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230214054.png"></p><ul><li><code>Stream</code>：一种数据结构，每个Stream有一个唯一的名称，也就是key。</li><li><code>Comsumer Group</code>消费组：一个消费组有多个消费者，他们之间是<strong>竞争关系</strong></li><li><code>pending_ids</code>消费者状态变量：维护了消费者尚未确认的id。</li></ul><div class="note note-primary">            <p>对于每一条消息都要确保其被消费，或者确定这是一个投递不出去的坏消息（死信）。所以需要对<strong>每个消费者</strong>维护一个<strong>pending_ids</strong>，表示这个消息已经交给它处理，但它还没有完成对该消息的确认（ack）。</p><p>而对于<strong>每个消费组</strong>，则需要一个指针维护其最后一次读取到的消息id（<strong>Last_dilivered_id</strong>）。</p>          </div><p>另外，每个消息都有独一无二的ID，默认为时间戳，格式为1527846880572-5，当毫秒不够用时，使用<code>-</code>后面的数标注该消息是本毫秒的第几个消息。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>即不使用消费组的情况下进行消费。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xread count 2 streams key 0-0 #读取两条消息<br>xread block 0 count 1 streams key $ #阻塞读取队列最后的消息<br></code></pre></td></tr></table></figure><p>block 0表示永远阻塞，直到消息到，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil。</p><blockquote><p>独立消费不会自动维护last_read指针，需要用户自己记住最后消息ID，下次将其作为参数传递即可继续消费。</p></blockquote><h2 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h2><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230231440.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为”已处理”</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息<br>具体使用见<a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html">消费组命令使用</a></li></ul><p>xreadgroup也可以阻塞等待，读取后，消息进入消费者的pending_ids，当消费者回复xack时，将这个消息从其pending_ids消除。</p><div class="note note-primary">            <p>消费时，需要传入流名称、消费组名称、消费者名称3个参数。<br>ACK时，需要传入流名称、消费组名称、消息id。<br>可见回复时，不需要具体定位到消费者，因为redis本身就知道某个消息id属于消费组中的哪个消费者。</p>          </div><h2 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h2><p><code>Xinfo</code>命令可以查看stream的基本信息，如：</p><ul><li>XINFO STREAM keyName</li><li>XINFO GROUPS keyName</li><li>XINFO CONSUMERS keyName groupName</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>实时通讯、大数据分析、异地数据备份。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个<strong>64位整型</strong>（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>Redis生成的ID是单调递增有序的。若服务器时间错误，Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号）。</p><h3 id="消费者崩溃带来的会不会消息丢失问题"><a href="#消费者崩溃带来的会不会消息丢失问题" class="headerlink" title="消费者崩溃带来的会不会消息丢失问题?"></a>消费者崩溃带来的会不会消息丢失问题?</h3><p>Pending列表可以记录已读取但未ack的消息。<br>命令<code>XPENDIING</code>用来获消费组或消费内消费者的未处理完毕的消息。</p><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>其保证消费者恢复时，可重新从pending列表中取消息处理。</p><h3 id="消费者彻底宕机后如何转移给其它消费者处理？"><a href="#消费者彻底宕机后如何转移给其它消费者处理？" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理？"></a>消费者彻底宕机后如何转移给其它消费者处理？</h3><p>使用<code>XCLAIM</code>将目标消费者和消息ID转移到自己的pending列表中，同时需要提供<strong>IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p><h3 id="坏消息问题，Dead-Letter，死信问题"><a href="#坏消息问题，Dead-Letter，死信问题" class="headerlink" title="坏消息问题，Dead Letter，死信问题"></a>坏消息问题，Dead Letter，死信问题</h3><p>delivery counter，反复转给各个消费者时会累加，当到达临界值时将该消息视为死信，此时可以处理该消息，一般删除即可，XDEL。</p><h1 id="六、发布订阅详解"><a href="#六、发布订阅详解" class="headerlink" title="六、发布订阅详解"></a>六、发布订阅详解</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis有两种发布&#x2F;订阅模式：</p><ul><li>基于频道(Channel)的发布&#x2F;订阅</li><li>基于模式(pattern)的发布&#x2F;订阅</li></ul><h2 id="基于频道的发布和订阅"><a href="#基于频道的发布和订阅" class="headerlink" title="基于频道的发布和订阅"></a>基于频道的发布和订阅</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">publish channel:1 hi #发布消息<br><br>subscribe channel:1 #订阅频道，随后进入订阅状态<br></code></pre></td></tr></table></figure><p>处于订阅状态下客户端不能使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>和<code>punsubscribe</code>这四个属于”发布&#x2F;订阅”之外的命令，否则会报错。</p><h2 id="基于模式-pattern-的发布-x2F-订阅"><a href="#基于模式-pattern-的发布-x2F-订阅" class="headerlink" title="基于模式(pattern)的发布&#x2F;订阅"></a>基于模式(pattern)的发布&#x2F;订阅</h2><p>如果有某个&#x2F;某些模式和这个频道匹配的话，那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。<br><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-6.svg"><br>通配符中<code>?</code>表示1个占位符，<code>*</code>表示任意个占位符(包括0)，<code>?*</code>表示1个以上占位符。</p><ul><li>psubscribe可以重复订阅一个频道，会收到多条消息。</li><li>subscribe和psubscribe是相互独立的，接受到消息时也会有区别。</li><li>使用punsubscribe只能退订通过psubscribe命令订阅的规则。</li></ul><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="基于频道"><a href="#基于频道" class="headerlink" title="基于频道"></a>基于频道</h3><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-4.svg"></p><ul><li>订阅时，将客户端添加到对应channel的list中</li><li>发布时，订阅到channel，发送给List中所有客户端。</li></ul><h3 id="基于模式"><a href="#基于模式" class="headerlink" title="基于模式"></a>基于模式</h3><ul><li>订阅时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。<br><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-10.svg"></li><li>发布时，遍历pubsubPattern，逐一对比看是否要发送。</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第6章（应用层）</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-968c1bcea54ea1f4.webp"><br>例子：<br><strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong>，该应用还涉及到域名到IP地址的转换，由属于<strong>应用层范畴的域名系统DNS</strong>完成。<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4e9858624d4835ae.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c1c3868fb5e127b1.webp"></p><h1 id="二、两种组织方式"><a href="#二、两种组织方式" class="headerlink" title="二、两种组织方式"></a>二、两种组织方式</h1><h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-bbfb139bb8ffd796.webp"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-598b1158f5c33a11.webp"></p><div class="note note-primary">            <p>www,email,ftp为C&#x2F;S架构。</p>          </div><h1 id="三、动态主机配置协议DHCP"><a href="#三、动态主机配置协议DHCP" class="headerlink" title="三、动态主机配置协议DHCP"></a>三、动态主机配置协议DHCP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>DHCP</strong>使用了C&#x2F;S方式：</p><ul><li>主机在启动时向DHCP服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li><li>基于UDP工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><h4 id="发现报文"><a href="#发现报文" class="headerlink" title="发现报文"></a>发现报文</h4><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong>，其中包含<strong>事务ID</strong>，<strong>DHCP客户端的MAC地址</strong></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-6f9a9715f8b1c74a.webp"></p><blockquote><p>报文包括：</p><ul><li><strong>源IP地址</strong>：0.0.0.0，这是因为主机目前还未分配到IP地址。</li><li><strong>目的地址</strong>：广播地址255.255.255.255。</li><li><strong>MAC地址</strong>：主机MAC地址。</li></ul></blockquote><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送。</p><h4 id="提供报文"><a href="#提供报文" class="headerlink" title="提供报文"></a>提供报文</h4><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03ecd6d2838d4274.webp"></p><blockquote><p>报文包括</p><ul><li><strong>事务ID</strong>：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的。</li><li><strong>配置信息</strong>：IP地址、子网掩码、地址租期、默认网关、DNS服务器</li><li><strong>源IP地址</strong>：发送DHCP提供报文的DHCP服务器的IP</li><li><strong>目的地址</strong>：因为目的主机还没分配到IP，所以使用广播地址</li></ul></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-009b1e9a88976880.webp"></p><blockquote><p>报文包括<br><strong>事务ID</strong><br><strong>MAC地址</strong><br><strong>接受的IP地址</strong><br><strong>提供此租约的DHCP服务器端的IP地址</strong><br><strong>源IP地址</strong>：0.0.0.0<br><strong>目的地址</strong>：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们作为自己的DHCP服务器。</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文。</p><h4 id="确认报文"><a href="#确认报文" class="headerlink" title="确认报文"></a>确认报文</h4><p><strong>DHCP服务端将广播发送DHCP确认报文（DHCP ACK）</strong><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-35c9002bba766476.webp"></p><blockquote><p>报文包括：<br>源地址：DHCP服务器1的IP地址<br>目的地址：广播地址</p></blockquote><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong>，<strong>在使用前还会进行ARP检测</strong>。<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-044fb99d76bd279c.webp"></p><h4 id="剩余流程"><a href="#剩余流程" class="headerlink" title="剩余流程"></a>剩余流程</h4><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a01eacfba40e9098.webp"></p><div class="note note-primary">            <p>由于确认客户端的IP地址前，其都没有IP地址，所以DHCP借用IP的过程中报文的目的IP都是广播，服务器的源IP地址都是自身IP地址，客户端IP地址为默认0.0.0.0。</p><p>客户端请求IP是一个4握手过程。前2个握手用于服务端和客户端明确对方的存在并给客户端一个Offer。后2个握手就是客户端确定这个Offer的过程。</p><p>第三个握手，虽然是广播，但其他的DHCP服务器是不会接受的，因为事物ID不符。</p><p>到达0.5倍租用期时，客户端会主动续租，若超过了租用期，则停止使用这个IP地址。</p>          </div><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-33c64efac75f0ad2.webp"></p><p>由于网络之间存在广播域，主机的广播消息可能无法送达DHCP服务器，可为路由器配置DHCP中继代理服务，路由器会将接受到的DHCP报文转发到DHCP服务器。</p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-37d8836f5ed85036.webp"></p><h1 id="四、域名系统DNS"><a href="#四、域名系统DNS" class="headerlink" title="四、域名系统DNS"></a>四、域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8dc45fb61122f775.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-31a3076fe8055379.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4655232a57435f63.webp"></p><blockquote><p>名称相同的域名等级未必相同。</p></blockquote><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c2350ce866abf74e.webp"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-aae45d426ec7fa49.webp"></p><div class="note note-primary">            <p>递归查询的过程是链式调用，最后将域名对应的IP地址返回给主机。<br>迭代查询的过程是由本地域名服务器作为请求主体，迭代查询各级服务器IP。</p>          </div><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-d2652511b6f2280d.webp"></p><div class="note note-primary">            <p>本地域名服务器使用高速缓存减少DNS查询次数，但需要保证正确性，所以对于每一项缓存都有倒计时，超时的记录会被删除。<br>同时，主机也需要做缓存（多级缓存），启动时便向本地域名服务器获取域名和IP的数据库信息，必要时再询问服务器。</p>          </div><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-93d3fbaa54195112.webp"></p><h1 id="五、文件传送协议FTP"><a href="#五、文件传送协议FTP" class="headerlink" title="五、文件传送协议FTP"></a>五、文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-df91fe396712c633.webp"></p><h2 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h2><p>FTP采用了C&#x2F;S方式，监听熟知端口（21）。</p><h3 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-885981a43745ae55.webp"></p><div class="note note-primary">            <p>主动、被动指的是数据通道的建立发起者是否是服务器，主动模式服务器会使用固定的端口号连接客户端的临时端口号，被动模式服务器会开启某个临时端口号等待客户端连接。<br>注意，两种方式最后都会建立两个连接通道，控制连接在整个会话期间保持打开状态，数据连接传输完毕后就关闭。</p>          </div><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/Pasted%20image%2020221230015319.png"></p><h1 id="六、电子邮件"><a href="#六、电子邮件" class="headerlink" title="六、电子邮件"></a>六、电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-905f080fde0331a5.webp"></p><blockquote><p>注意：SMTP是发送协议，POP3&#x2F;IMAP是读取协议。</p></blockquote><h2 id="邮件发送和接受过程"><a href="#邮件发送和接受过程" class="headerlink" title="邮件发送和接受过程"></a>邮件发送和接受过程</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a55537e03d980133.webp"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）"></a>简单邮件传送协议SMTP（<em>Simple Mail Transfer Protocol</em>）</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03f4877d2621c261.webp"></p><h3 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-fb16b5ace5466b25.webp"></p><div class="note note-primary">            <p><strong>MIME</strong>是一层非ASCII和ASCII码之间的扩展转换器，其可以协助非ASCII码邮件以SMTP的形式发送。</p>          </div><h3 id="邮件接受"><a href="#邮件接受" class="headerlink" title="邮件接受"></a>邮件接受</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c825d1ad122bd41c.webp"></p><blockquote><p><strong>POP3</strong>是正式标准，客户只读。<br><strong>IMAP4</strong>是建议标准，客户可以操作服务器中的邮件，需要联机。</p></blockquote><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-46b15b10a17604fa.webp"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-b400e3f6c0a87238.webp"></p><div class="note note-primary">            <p>POP3使用110端口，IMAP4使用143端口</p>          </div><h1 id="七、万维网WWW"><a href="#七、万维网WWW" class="headerlink" title="七、万维网WWW"></a>七、万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>基本概念</p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络，而是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。<strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8646898df7461ca3.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-05ae15f55de2ba0a.webp"></p><h2 id="HTTP（Hyper-Transfer-Protocol）"><a href="#HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="HTTP（Hyper Transfer Protocol）"></a>HTTP（<em>Hyper Transfer Protocol</em>）</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP是一个应用层协议，它使用 <strong>TCP 连接</strong>进行可靠的传送。</li><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-614d1960b2b805d9.webp"></li></ul><div class="note note-primary">            <p>可以注意到第三次握手的时候就发出了HTTP请求报文。</p>          </div><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-22dfb8a34acf459c.webp"><br>响应报文<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-0409ca153701fbb4.webp"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-969dc15b42399e98.webp"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-abf0fcf785757c26.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-e7f4b696946ffafa.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-14ec3f45c4af32f9.webp"></p><div class="note note-primary">            <p>为了保证缓存的正确性，设置有过期时间，若没有过期，则直接返回，若过期了，则询问服务器文档内容是否有变化：</p><ul><li>若没有则直接返回一个普通响应，缓存服务器接受后直接刷新倒计时。</li><li>若有则返回新的文档内容，缓存服务器接收并更新内容。</li></ul>          </div><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-dab94fae0e969502.webp"></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第5章（运输层）</title>
    <link href="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程之间通讯<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-86df51cb4523e3bf.webp"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><div class="note note-primary">            <p>NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议。</p>          </div><p>之前介绍的物理层、数据链路层、网络层解决了主机到主机的通讯。但通讯的真正实体是位于通讯两端主机的进程，如何为这两个进程提供通讯服务是运输层的任务，运输层协议也被称为端到端协议。</p><h2 id="端口号与复用"><a href="#端口号与复用" class="headerlink" title="端口号与复用"></a>端口号与复用</h2><p>端口号的使用<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-de597eda77aa6acd.webp"></p><h3 id="发送方与接受方的复用"><a href="#发送方与接受方的复用" class="headerlink" title="发送方与接受方的复用"></a>发送方与接受方的复用</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2a4ec3f5d5c11433.webp"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong><br><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p></blockquote><h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2117fa99a7f2a89c.webp"></p><h1 id="二、运输层传输流程（DNS）"><a href="#二、运输层传输流程（DNS）" class="headerlink" title="二、运输层传输流程（DNS）"></a>二、运输层传输流程（DNS）</h1><ul><li>DNS客户端（端口为短暂端口号）发送一个<strong>DNS请求报文</strong>（UDP）到DNS服务器（端口号为53）。</li><li>DNS服务器将接受到的信息上传给DNS服务器端进程（端口号为53），随后给用户回复<strong>DNS响应报文</strong>（UDP），目的端口为客户端的短暂端口号。</li><li>DNS客户端将接受到的信息上传给DNS客户端进程（端口号为短暂端口号），随后解析DNS响应报文，即可直到Web域名对应的IP地址。</li><li>向Web域名对应的IP发送http请求。</li></ul><h1 id="三、UDP与TCP对比"><a href="#三、UDP与TCP对比" class="headerlink" title="三、UDP与TCP对比"></a>三、UDP与TCP对比</h1><h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h2><ul><li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>；当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。；UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li><li>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接；UDP的通信是无连接的，不需要套接字（Socket）。</li></ul><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-58c94f043969af9a.webp"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>结构<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-624005a24bc5bfcd.webp"><br>实现</p><ul><li>UDP可以<strong>广播、多播和单播</strong></li><li>UDP对应用进程交下来的报文<strong>既不合并也不拆分</strong>，而是保留这些报文的边界</li><li>UDP向上层提供<strong>无连接不可靠传输服务</strong></li></ul><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h2><p>结构<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-db48b70af7fb7884.webp"><br>实现</p><ul><li>TCP只支持单播，端对端通讯</li><li>需要先通过3次握手建立连接</li><li>TCP是面向字节流的，即其<strong>可能会拆分上层交付的报文</strong>。</li><li>TCP向上层提供<strong>面向连接的可靠传输服务</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-b0c1d4146735458a.webp"></p><h1 id="四、TCP流量控制"><a href="#四、TCP流量控制" class="headerlink" title="四、TCP流量控制"></a>四、TCP流量控制</h1><p>目的：发送的速率尽可能快，但需要接受方来得及接受。<br>实现：滑动窗口。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=60">具体流程视频</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>累计确认+选择重传（只重传超时的，即每个窗口独立持有一个计时器）</p><ol><li>发送端和接受端分别具有发送窗口和接受窗口。发送端会将发送窗口内的字节数据依次发出。</li><li>接受方通过累计确认提示发送端应该<strong>如何调整发送窗口的大小</strong>（流量控制）以及<strong>已经接受到了n字节之前的数据</strong>。</li><li>发送方接受到累计确认后<strong>调整发送窗口大小</strong>并<strong>移动发送窗口</strong>。</li><li>移动发送窗口后：<ul><li>将刚进入窗口的窗口信息发送出去</li><li>同时等待看是否有窗口触发超时重传，若有则重传旧数据。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f73e94f75e94ea4c.webp"></li></ul></li><li>接受端将发送窗口调整为了0，说明暂时不接受数据，其恢复后给发送方的提示是可能丢失的。因此，<strong>当发送窗口为0（接受到0窗口通知）时，</strong>发送方<strong>持有持续计时器，超时时会发送</strong>零窗口探测报文**，确认接受端处理能力情况。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-5bd53b8a5a5ac400.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ea9dc3589e6c6bd1.webp"></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d8221e9dda7919f9.webp"></p><h1 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-9d4b410b2a44c125.webp"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><div class="note note-primary">            <p>理解拥塞原因：<br>1.传输时，链路容量不足；2.接受时，容量太小；3.处理时，速率太慢；4.负反馈。</p>          </div><p><strong>拥塞控制的一般原理</strong></p><ol><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ol><p><strong>开环控制和闭环控制</strong><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2740d71c5e1d6aac.webp"></p><p><strong>监测网络的拥塞</strong><br>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><div class="note note-primary">            <p>理解：</p>          </div><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-67852fc13fc0e263.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c7682fe29ebcb6fd.webp"></p><blockquote><p>发送窗口大小 &#x3D; min(接受方窗口大小，拥塞窗口大小)</p></blockquote><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul><li><p>目的：用来确定网络的负载能力或拥塞程度。</p></li><li><p>算法的思路：由小到大逐渐增大拥塞窗口数值。</p></li><li><p>两个变量：</p><ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值有2 种设置方法。窗口值逐渐增大。第一种是1 至 2 个最大报文段 （旧标准）；第二种是2 至 4 个最大报文段 （RFC 5681）</li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li><li><p>实现：</p><ul><li>起初拥塞窗口按指数增加，当达到慢开始门限后，为了避免出现拥塞，每经过一个传输伦次，cwnd++</li><li>如果出现超时重传，则重新回到慢开始<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f5db7ea25d8aca73.webp"></li></ul></li></ul><div class="note note-primary">            <p>慢开始是为了从小到大且尽快的达到门限，门限后则缓慢的扩大拥塞窗口来试探网络情况，两者一起使用以实现动态调整拥塞窗口。</p>          </div><div class="note note-warning">            <p>注意：这里是拥塞窗口的变化，而不是发送窗口的变化，发送窗口的大小还受限于接受端的接受窗口。</p>          </div><h3 id="快重传（fast-retrasmit）与快恢复（fast-recovery）"><a href="#快重传（fast-retrasmit）与快恢复（fast-recovery）" class="headerlink" title="快重传（fast retrasmit）与快恢复（fast recovery）"></a>快重传（<em>fast retrasmit</em>）与快恢复（<em>fast recovery</em>）</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-a57c7cc819aa4bae.webp"></p><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ab5a63efbd586eb8.webp"></p><div class="note note-primary">            <p>一般接受方对接受到的报文段的确定都是捎带的，和窗口控制报文一起发送给发送端，导致重传开启较慢。<br><strong>快重传</strong>：需要接受端尽快的回复接受到的报文信息，然后发送端实现快重出传（接受到连续3个重复的确认报文）</p><p>发送端发生重传时，直接进入慢开始，这对于仅丢失个别报文的传输的效率较大，而快重传刚好可以确定这类情况。<br><strong>快恢复</strong>：当发送快重传时不进入慢开始，而是调节ssthresh值和cwnd值为一半后直接开始执行拥塞避免算法。</p><p>快恢复要和快重传结合使用，快恢复的具体调整依赖于发送端具体的实现。</p>          </div><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-8f61b8eddb5b2624.webp"></p><h1 id="六、TCP超时重传时间的选择"><a href="#六、TCP超时重传时间的选择" class="headerlink" title="六、TCP超时重传时间的选择"></a>六、TCP超时重传时间的选择</h1><p>不必要的重传会导致网络负荷的增大，但重传推迟的太久也会导致传输效率的降低。因此需要合理的设置超时重传时间<em>RTO</em>，其应该略大于往返时间<em>RTT</em>，具体计算：</p><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-20d1cf6bb211fe7e.webp"></p><h2 id="RTO"><a href="#RTO" class="headerlink" title="RTO"></a>RTO</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-39ab62874e65b623.webp"></p><div class="note note-primary">            <p>RTT计算：越近的RTT样本权重越大。<br>RTO计算：在RTT的基础上加上了RTT的偏差。(相当于加上了RTTs与新样本的差异，β只是一个权重参数，RTT（D1） &#x3D; RTT（1）&#x2F;2只是数据的初始化）。</p>          </div><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-dbc63525eab966e1.webp"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c94fa8a3ad6b277f.webp"></p><h1 id="七、TCP可靠传输的实现"><a href="#七、TCP可靠传输的实现" class="headerlink" title="七、TCP可靠传输的实现"></a>七、TCP可靠传输的实现</h1><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-6d10ea76a1ea032b.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-92d975bc880db892.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-35bff0a8cc5b0d71.webp"></p><div class="note note-primary">            <p>发送方接收到确认消息后，需要1.前移2.调整窗口大小。<br>调整窗口大小时，原则上窗口的前沿是不推荐后移的，所以最好是通过 后沿前移+前沿不动 来实现窗口缩小。</p>          </div><div class="note note-primary">            <p>接收方对数据的确认有累计确认和捎带确认：</p><ul><li>累计确认要求接收方不要过迟的发送确认。</li><li>捎带确认使用较少。</li></ul>          </div><h1 id="八、TCP的运输连接管理"><a href="#八、TCP的运输连接管理" class="headerlink" title="八、TCP的运输连接管理"></a>八、TCP的运输连接管理</h1><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e7d2329746de8e6a.webp"></p><h2 id="TCP连接建立（握手）"><a href="#TCP连接建立（握手）" class="headerlink" title="TCP连接建立（握手）"></a>TCP连接建立（握手）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-84c2b6dbb20379bd.webp"></p><div class="note note-primary">            <p><strong>双报文握手</strong>保证双方得知对方的存在，随后可以直接发送数据。<br><strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误，导致服务器资源浪费。</p>          </div><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-0a5773a600817c41.webp" alt="两报文握手"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e69d0e450b080e1f.webp" alt="服务器打开传输控制块"></li></ul><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。<br>之后，就准备接受TCP客户端进程的连接请求。<br>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求。<br>而TCP客户端在主动打开前也是要先创建传输控制块。</p></blockquote><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-3205fd7d7d75b62e.webp"></p><div class="note note-primary">            <p><strong>SYN</strong>，<strong>ACK</strong>是TCP报文头中的一个bit，其标识了当前TCP报文的属性：<br>SYN（同步标志位）表示请求同步，ACK（确认标识位）表示是对某报文的回复。<br><strong>seq</strong>，<strong>ack</strong>是TCP报文头中的两个字段，都占4个字节，其标识了端消息的id和确认收到的消息id+1。</p><p>TCP规定SYN&#x3D;1的报文段即使不携带数据，也要消耗掉一个序号。<br>普通的确认报文可以不消耗序号。</p>          </div><h2 id="TCP连接释放（挥手）"><a href="#TCP连接释放（挥手）" class="headerlink" title="TCP连接释放（挥手）"></a>TCP连接释放（挥手）</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-1c5e0c6357d039ed.webp"></p><ul><li>前两次握手是确认服务器接受到了释放连接的请求，此后服务器对剩余数据进行传输，客户端进入终止等待2状态。</li><li>后两次握手是确认客户端接受到了释放连接的命令，此后服务器关闭，客户端则继续等待2MSL，这是为了防止第四次握手丢失导致服务器资源浪费。若直接关闭：<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ef85470fe120f146.webp"></li><li>若服务器没有收到第四次握手，则会重传第三次握手，以确保收到第四次握手。</li></ul><div class="note note-warning">            <p>第二次握手和第三次握手的ack序号相同，说明这个消息是对同一个消息（第一次握手）的回应，分别表示服务器收到释放连接请求和服务器运行释放连接请求。</p>          </div><div class="note note-warning">            <p>可见握手和挥手，都需要客户端保证对服务器连接的最终确认以防止服务器的资源浪费。<br>在握手中体现在服务器之后接收到第三次握手确认在进入连接状态。<br>在挥手中体现在客户端会保持等待，服务器主动重传第三次握手以收到第四次握手。</p>          </div><div class="note note-primary">            <p><strong>FIN</strong>是TCP报文头中的一个bit，表示请求释放连接。在挥手中其会出现两次，一次是客户端主动请求释放连接，一次是服务器回复可以释放连接了。</p><p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>          </div><h2 id="TCP保活计时器"><a href="#TCP保活计时器" class="headerlink" title="TCP保活计时器"></a>TCP保活计时器</h2><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障，TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此，应当有措施使TCP服务器进程不要再白白等待下去<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2dc97e06fe1d82ed.webp"></p><h1 id="九、TCP报文段的首部格式"><a href="#九、TCP报文段的首部格式" class="headerlink" title="九、TCP报文段的首部格式"></a>九、TCP报文段的首部格式</h1><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-df9263a14e1da2c1.webp"></p><h2 id="固定首部"><a href="#固定首部" class="headerlink" title="固定首部"></a>固定首部</h2><p>源端口和目的端口<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-27e4bd51d5db2f8e.webp"><br>序号、确认号和确认标志位<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-fd0e64d8be3f598b.webp"><br>数据偏移、保留、窗口和校验和<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d3d4c61af68fdb6d.webp"><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f09bdaba863c4ca3.webp"></p><h2 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d1a8d3ca5ac7f39d.webp"></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第4章（网际层）</title>
    <link href="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li><li>为了实现这个任务，有以下问题：<ul><li>网络层提供可靠传输还是不可靠传输</li><li>网络层怎么寻址(IP地址做导航)</li><li>网络层路由选择(路由器根据路由表转发，为了记录路由需要人工配置或实现各种路由选择协议)</li></ul></li></ul><blockquote><p>网络层（网际层）,除了<strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><blockquote><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，因此在TCP&#x2F;IP协议中网络层常称为网际层。</p></blockquote><div class="note note-primary">            <ul><li>数据链路层能通过MAC地址与交换机实现数据的定向传输，但是对于庞大的因特网，这显然是不合理的，相比起MAC地址的无序序列，我们需要一个具有明显层级关系的地址（如湖北省武汉市洪山区）方便快速定位，统一管理，因此有了IP地址。</li><li>网络层需要实现数据在局域网和局域网之间的传递（不同于之前的局域网通过交换机互联，这样会扩大广播域，VLAN虽然能实现类似的功能，但依赖于用户设置，无法达到全网统一）。</li></ul>          </div><h1 id="二、网络层提供的服务"><a href="#二、网络层提供的服务" class="headerlink" title="二、网络层提供的服务"></a>二、网络层提供的服务</h1><p>网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”），实质就是<strong>在计算机通信中，可靠交付应当由网络还是端系统来负责</strong>？</p><ul><li>第一种观点是<strong>网络提供虚电路连接</strong>（一种使用<strong>面向连接</strong>的通信方式，通信之前先建立<strong>虚电路</strong>，保证所有网络资源，分组即可按顺序无差错的到达），由网络本身负责可靠交付。</li><li>另一种观点是<strong>网络只提供数据报服务</strong>，向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong>。</li></ul><blockquote><p>显然后者是我们现在使用的，其运行灵活，造价低，适应性强。</p><p><strong>区别</strong><br>终点地址：<br>1.仅在连接建立阶段使用，每个分组使用短的虚电路号<br>2.每个分组都有终点的完整地址</p><p>当结点出故障时：<br>1.所有通过出故障的结点的虚电路均不能工作<br>2.出故障的结点可能会丢失分组，一些路由可能会发生变化</p><p>端到端的差错处理和流量控制：<br>1.可以由网络负责，也可以由用户主机负责<br>2.由用户主机负责</p></blockquote><div class="note note-primary">            <p>当前网络层的服务实现是：<strong>尽最大努力交付</strong>。</p>          </div><h1 id="三、IPv4"><a href="#三、IPv4" class="headerlink" title="三、IPv4"></a>三、IPv4</h1><p><strong>IPv4地址</strong>是因特网（<em>Internet</em>）上每一个主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32bit（4个字节）的标识符。</p><div class="note note-warning">            <p>只有<strong>公网IP</strong>是全世界独一无二的，<strong>私网IP</strong>是在不同局域网中可以重复使用的：<br>RFC1918定义了私有IP的地址范围：<br>A:10.0.0.0 ~ 10.255.255.255即10.0.0.0&#x2F;8<br>B:172.16.0.0 ~ 172.31.255.255即172.16.0.0&#x2F;12<br>C:192.168.0.0 ~ 192.168.255.255 即192.168.0.0&#x2F;16</p>          </div><div class="note note-success">            <p><strong>私有IP是无法随意定义的</strong>，只有以上范围内的IP会被路由器视为内网IP，以这些IP为源IP的数据包只会在局域网内传递，不会在因特网上传递。</p><p>私有IP设备<strong>发送</strong>与<strong>接受</strong>外网数据包：<br>首先内网中的客户端将数据包传送给路由器，路由器解析数据包后发现，这个数据包是来自与私网、发送给外网的。例如某个数据包的源IP:192.168.1.2，当路由器检测到这个数据包的目标IP是外网IP的时候，路由器中会生成一个唯一端口号对应192.168.1.2，再生成一个随机端口号对应这个唯一端口号。然后路由器会将数据包的源IP改成公网IP，发送到互联网上。接收数据时，数据包会被发送到路由器的随机端口号上，这时和原来生成的映射表进行匹配，再把数据包传送到内网客户端，其实就是一个端口映射表。<br><a href="https://blog.csdn.net/weixin_39661353/article/details/110806482">路由器修改报文端口号</a></p>          </div><p>IPv4的编址方法经历了3个阶段：<br><strong>分类编址 -&gt; 划分子网 -&gt; 无分类编址</strong></p><h2 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h2><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-617a75508f564e07.webp"><br>其中有2个网络号无法分配，即A类地址：</p><ul><li><strong>最小网络号为0，保留不做指派</strong></li><li><strong>最大网络号为127，是本地回环测试地址，保留不做指派</strong></li></ul><p>有2类主机号无法分配：</p><ul><li>全0的主机号，其表示该网络的标识地址</li><li>全1的主机号，其表示该网络的广播地址</li></ul><div class="note note-primary">            <p>网络号，主机号都为0，即<code>0.0.0.0</code>，表示本网络上的本主机（见DHCP协议）</p>          </div><blockquote><ul><li><strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</li><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li><strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong></li></ul></blockquote><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>两级的IP地址会导致IP地址空间的利用率很低。<br>子网即从主机号借一部分作为子网号，从而将一个网络号分为多个子网。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5006c8be601f1a11.webp"><br>划分子网的工具即<strong>子网掩码</strong>。<br>其将<strong>两级的IP地址</strong>变成了<strong>三级的IP地址</strong>。</p><p><strong>默认子网掩码</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5e9d1b71bd598e62.webp"></p><p>IPv4地址与子网掩码相与即得到所在子网的网络地址。</p><blockquote><p>对于在因特网上传输的数据报，仍然是根据<strong>目的网络号</strong>net-id寻找下一跳路由器。到了该网络号的路由器时，路由器再根据<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</p></blockquote><div class="note note-primary">            <p><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。<br>这里所谈论的<strong>划分子网</strong>针对的仍然是因特网上的IP地址，其并没有造成IP地址重复（<code>相同的ip/不同的子网掩码</code>指的仍是同一个主机），只是单位内部对于可分配的主机号进行的一种再划分，即：</p><ul><li>子网掩码对于外网路由器没有作用。</li><li>内网路由器根据接受到的IP匹配对于的子网，能实现对该子网更精准的路由。<br>（最长前缀匹配）</li></ul>          </div><blockquote><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个记录，除了要记载目的网络地址外，还必须同时记载该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><div class="note note-primary">            <p>以上路由器行为是为了保证在传递IP数据报时，能够选择最符合的端口转发数据。todo？</p>          </div><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><strong>无分类域间路由选择 CIDR</strong> (<em>Classless Inter-Domain Routing</em>)。</p><ul><li>CIDR消除了A、B、C类地址和划分子网的概念。</li><li>CIDR能更有效的分配IPv4的地址空间。</li></ul><p><strong>特点</strong></p><ul><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li><li>IP 地址的形式为：<code>a.b.c.d/x</code>，其中地址的 <code>x</code> 最高比特构成了 IP 地址的<strong>网络部分（即网络前缀）</strong>，所以 <strong>CIDR 中 IP 地址由前缀和主机号构成</strong>，<code>x</code> 为前缀长度，<code>/x</code> 的记法也称为<strong>子网掩码</strong>。</li></ul><div class="note note-primary">            <p><strong>CIDR</strong>只是在网络实现层面消除了这些概念，并不代表A、B、C类地址和划分子网的协议行为不存在了。具体而言，总服务商分配到的公网IP地址基本仍为A、B、C类地址（如130.67.0.0&#x2F;16），不过服务商可以把这些地址再划分下去给子服务商(如130.67.0.0&#x2F;17和130.67.128.0&#x2F;17)使用，我们也不再把这样的关系称为总网、子网关系。</p><p>问题：130.67.0.0&#x2F;16 和130.67.0.0&#x2F;17还是同一个目标IP地址吗？<br>答：这个问题本身就是错误的。</p><ol><li><strong>IP地址仍然为一个全网唯一的IP地址</strong>，并没有后面的网络前缀的区分。</li><li>对于一个目标IP地址，<strong>不会也不可能在数据传递时携带网络前缀</strong>。</li><li>在数据的传输中，<strong>网络前缀只保存在路由器表中</strong>，用于记录与路由器相连接的网络的所在的网络号。</li></ol><p>问题：如果两个服务商，一个分到了<code>130.67.0.0/16</code>的公网IP，一个分到了<code>130.67.128.0/17</code>的公网IP，此时服务商1内部划分出子网<code>130.67.128.0/17</code>，其是否会与服务商2的IP在公网上重复？<br>答：不会。如上面所说，IP地址在分配时仍有等级之分，服务商一般只会分到<code>/8</code>，<code>/16</code>，<code>/24</code>这样的网络前缀，像<code>/17</code>这样的IP和网络前缀，本身就是由服务商1分发出来的，不可能由服务商2获得。</p>          </div><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p><strong>超网（路由聚合）技术是为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。</strong></p><p>即路由器发现其某个端口与多个具有相同前缀的网络对应，会将这些记录合并。</p><blockquote><p>举个例子，如果路由器1与路由器2连接，路由器2的各个端口连接了不同的网络（本质上是多个子网）。<br>经过路由器交换学习，路由器1会得知路由器2所在网络号和网络前缀，而路由器2的不同接口在不同的网络号中，因此路由器1学习到了路由器2的多个网络。（如<code>67.67.0.0/18</code>，<code>67.67.64/18</code>, <code>67.67.128.0/18</code>,<code>67.67.192.0/18</code>)<br>此时，路由器1发现虽然有多个网络，但他们都对应着同一个端口，并且具有相同前缀（<code>67.67.0.0/16</code>）。此时路由器1会将这些记录合并，这种行为叫做路由聚合，也叫构造超网。</p></blockquote><h3 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h3><p>最长匹配 是指存在多条目的网段相同的路由时，匹配掩码最长的那一条。因为掩码越长，表示的网段就越小，匹配也就越精确。</p><div class="note note-primary">            <p>条件：</p><ul><li>路由器1：外部路由器。</li><li>路由器2：连接多个网段（子网）路由器。</li><li>路由器3：连接路由器2的一个子网路由器。</li><li>网段3：路由器3所在的网络。</li><li>3个路由器两两相连。<br>对于划分子网的IPv4地址，同一网络号的不同子网的记录只保存在该网络的中转的路由器2中。对于路由器1，其只需要知道路由器2的总网络号即可，其子网的划分对路由器1是<strong>屏蔽的</strong>。</li></ul><p>但CIDR不再区分子网，路由器1会学习与之相连接的路由器2的所有网络号（IP和网络前缀）。这导致路由器2所在的子网对路由器1也是<strong>可见的</strong>，因此需要将这些网络号在本路由器的路由表中聚合起来，避免路由表内存浪费。</p><p>至于最长匹配原则，则可以当某个数据包要从路由器1要发往子网3。此时路由器1会优先匹配到最长的网段3，并将数据转发到路由器3。</p>          </div><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/routeUnion.png"></p><h2 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h2><ul><li>定长的子网掩码FLSM（<em>Fixed Length Subnet Mask</em>）</li><li>变长的子网掩码VLSM（<em>Variable Length Subnet Mask</em>）<blockquote><p>前者就是分类IP，后者就是无分类IP<br>定长的子网掩码只能划分出2^n个子网，而变长的子网掩码可以按需分配，减少对IP地址的浪费。</p></blockquote></li></ul><h1 id="四、IP数据包的发送和转发过程"><a href="#四、IP数据包的发送和转发过程" class="headerlink" title="四、IP数据包的发送和转发过程"></a>四、IP数据包的发送和转发过程</h1><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>,由默认网关帮忙转发</li><li>为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong>。（具体地，默认网关指的是与本机网络直接相连的路由器<strong>接口</strong>，即下图中的0。通俗的讲，默认网关就是本网络与外网的默认接口）</li></ul></blockquote><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0351946f5505b37a.webp"></p><div class="note note-primary">            <p>前提：</p><ul><li>本机IP ＆ 本机掩码 &#x3D; 本机网络</li><li>目的IP ＆ 目的掩码 &#x3D; 目的网络</li></ul><p>正向来看：<br>如果：目的网络 &#x3D;&#x3D; 本机网络（即目的掩码 &#x3D; 本机掩码）<br>那么：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络（目的网络）</p><p>反向来看：<br>条件：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络<br>问题：目的网络是否为本机网络呢？<br>答案：<strong>是</strong>。考虑这个问题的时候主要在想以下情形：<br>”如果目的网络（<code>190.68.16.128/25</code>）是本机网络（<code>190.68.16.0/24</code>）的子网，那么上面条件是成立的，但该子网和该网络并不能划等号。“<br>但实际上这个想法本质就是错误的，在<strong>CIDR和变长的子网掩码</strong>中：</p><ol><li>IP网络之间的关系已经没有了父子关系，</li><li>对于变长子网掩码，不同的子网之间的关系依然是并列的。也就是说，如果本机IP的网络会被划分成（<code>190.68.16.0/24</code>），就说明已经有一个网段包含了<code>190.68.16.xxx</code>的所有主机，<code>190.68.16.128/25</code>网络根本就不可能存在，即若有某主机IP为<code>190.68.16.129</code>，其子网掩码也一定是<code>/24</code>。</li></ol><p>以上证明了可以根据本机掩码和目的IP判断目的网络是否为本机网络，但如果不是本机网络，则不能直接判断目的网络的具体掩码长度，不过对于本机而言，只需要操心一个IP是由自己直接交付（本机网络）还是交给路由器（外网网络）处理即可。</p>          </div><h2 id="路由器行为"><a href="#路由器行为" class="headerlink" title="路由器行为"></a>路由器行为</h2><ol><li>检查IP数据报首部是否出错<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ol><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>静态路由配置指用户或网络管理员使用路由器的相关命令给路由<strong>人工配置路由表</strong>。</p><p><strong>默认路由</strong><br>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是<strong>优先级最低</strong>的。一般为0.0.0.0&#x2F;0(可以匹配所有地址)</p><p><strong>特定主机路由</strong><br>给路由器添加的针对某个主机的特定主机路由条目，可以指定其下一条目的。一般用于网络管理人员对网络的管理和测试。</p><div class="note note-primary">            <p>当多条路由可选时，使用最长匹配原则。</p>          </div><p><strong>静态路由配置</strong>其可能出现以下导致产生<strong>路由环路</strong>的错误。</p><ul><li><strong>配置错误</strong>（手动配置错误）</li><li><strong>聚合了不存在的网络</strong>（解决办法：黑洞路由）<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-caeddc52bde20f9c.webp"></li><li><strong>网络故障</strong>（解决方法：为故障网路添加黑洞路由，故障恢复后使该黑洞路由失效）<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d8107f8fc71dd1f4.webp"></li></ul><h2 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>动态路由选择</strong>相比<strong>静态路由选择</strong>能更好适应网络状态的变化，且适用于大规模网络。其路由器通过路由选择协议自动获取路由信息。</p><blockquote><p><strong>因特网采用分层次的路由选择协议</strong></p></blockquote><p><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器。自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-9e37d1229ec7836e.webp"></p><p><strong>路由选择协议</strong>：域间路由选择使用外部网关协议<strong>EGP</strong>这个类别的路由选择协议，域内路由选择使用内部网关协议<strong>IGP</strong>这个类别的路由选择协议。<strong>网关协议</strong>的名称可称为<strong>路由协议</strong>。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8729bdd2bd367edf.webp"></p><div class="note note-primary">            <p><strong>路由选择协议</strong>的本质是路由器之间交换信息、判断某网络是否可达并进行路径选择的规则。由于路由器之间交换信息需要进行广播行为，由于路由表容量有限和避免广播的泛滥，需要使用<strong>自治系统</strong>来隔离网络中的路由器，并保证<strong>同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</strong></p>          </div><h3 id="常见的路由选择协议"><a href="#常见的路由选择协议" class="headerlink" title="常见的路由选择协议"></a>常见的路由选择协议</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b1876963d6d9de0.webp"></p><h3 id="路由器基本结构和功能"><a href="#路由器基本结构和功能" class="headerlink" title="路由器基本结构和功能"></a>路由器基本结构和功能</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e6b69c1f176e24c5.webp"></p><p><strong>分组转发部分</strong><br>转发时需要注意的行为：</p><ul><li>若在转发表中找不到匹配条目则<strong>丢弃分组</strong></li><li>转发时会<strong>更新分组首部的某些字段</strong>，如分组生存时间</li><li>各端口都有缓冲区，每个端口一般都具有输入、输出功能</li></ul><p><strong>路由选择部分</strong><br>路由选择处理器根据所使用的路由选择协议周期性的与其他路由器进行路由信息交互来更新路由表。<br>如果路由器接受到的分组是路由器之间交换路由信息的<strong>路由报文</strong>，则会把这种分组送交给<strong>路由选择处理器</strong>进行处理。</p><p>路由选择处理器的行为：</p><ul><li>路由表一般只包含从目的网络到下一条的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表生成的</li><li>转发表的结构应当使查找过程最优化</li></ul><div class="note note-primary">            <p>路由表（RIB）和转发表（FIB）的联系和区别：</p><ul><li><p>联系<br>转发表是路由器使用一个特定的进程通过路由表中的信息和自身的网卡等信息综合得到的。转发表类似于交换机的地址信息表。</p></li><li><p>区别<br>首先，”转发”和”路由选择”是有区别的，”转发”时，路由器只需要把接受到的信息从合适的端口发送出去即可，只涉及到一个路由器。”路由选择”则是许多路由器协同工作的结果。<br>其次，路由表只存储三元素：目标，掩码，下一跳；而转发表存储更详细的信息：比如输出端口信息，某些MAC地址，比如标记信息等。</p></li></ul><p>这里的描述都屏蔽了MAC地址的问题，这里在汇总对比一下：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。<br>举例：<br>局域网：使用MAC表和ARP表即可实现局域网内主机通讯（使用交换机，虽然现在不会这么使用）<br>主机流程：目的IP地址 -&gt; 目的MAC地址 -&gt;端口<br>路由器流程同上。</li></ul><p>因特网：但不同网段之间的通讯，要涉及到网络路线选择问题。<br>主机流程：目的IP地址(非本网段) -&gt; 目的MAC地址（默认网关）-&gt;端口<br>路由器流程：目的IP地址 -&gt; 下一跳IP地址（路由选择） -&gt;MAC地址 -&gt; 端口</p>          </div><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由信息协议RIP(<em>Routing Information Protocol</em>)<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-850c29aaf1e744d6.webp"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>思路</strong></p><ul><li>距离最短为最好路由</li><li>相同距离则负载均衡</li><li><strong>只和相邻的路由器周期性的交换自己的路由表</strong></li></ul><h5 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6bf4e045a90846e0.webp"></p><p><strong>路由更新细节</strong><br>接受到更新报文后和自己的路由器对比：</p><ul><li>未知的Net，插入新信息。</li><li>相同Net和相同下一跳，<strong>覆盖距离信息</strong>。</li><li>相同Net和不同下一跳，距离不同则使用，若<strong>相等则都保留并负载均衡</strong>。</li></ul><h4 id="RIP存在的问题"><a href="#RIP存在的问题" class="headerlink" title="RIP存在的问题"></a>RIP存在的问题</h4><p>如果网络出现故障，由于远处的路由器获知这个消息慢，先发出了自己的更新报文，则可能造成路由器之间互相认为对方可以到达一个不可达的网络，形成<strong>网络环路</strong>。</p><p>解决方法<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-3a055002b79a9cda.webp"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><h4 id="RIP的优缺点"><a href="#RIP的优缺点" class="headerlink" title="RIP的优缺点"></a>RIP的优缺点</h4><blockquote><p>RIP 协议的优缺点<br>优点：</p><ol><li>实现简单，开销较小。<br>缺点：</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p>开放最短路径优先 OSPF (<em>Open Shortest Path First</em>)。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f5dc77f36b5b1047.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="OSPF五种分组类型"><a href="#OSPF五种分组类型" class="headerlink" title="OSPF五种分组类型"></a>OSPF五种分组类型</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a2a83ab2654e270f.webp"></p><h5 id="基本工作过程-1"><a href="#基本工作过程-1" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-339786779f0e1a82.webp"></p><p>部分细节：<br><strong>Hello分组</strong><br>建立并维护路由器关系的分组。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f9c642e76e871651.webp"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong><br>包含具体的路由信息，被封装在<strong>LSU分组</strong>中<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bbed8a0d31bf19c3.webp"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b8e10e2d82cfa6f.webp"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-4239eee0b6040f52.webp"></p><div class="note note-primary">            <p>总结，OSPF是一个路由器通过获取AS内所有路由器之间边信息，然后建立一个以自己为根节点的无环图的过程。<br>具体地，相邻路由器会通过Hello分组维护关系，并互相简单介绍自己已知的路由信息，然后各自通过路由信息请求、路由信息返回、路由信息确认等过程逐步获得整个AS内的路由信息，最后构建各自的路由表。</p>          </div><h4 id="OSPF存在的问题"><a href="#OSPF存在的问题" class="headerlink" title="OSPF存在的问题"></a>OSPF存在的问题</h4><h5 id="大量多播分组"><a href="#大量多播分组" class="headerlink" title="大量多播分组"></a>大量多播分组</h5><p>多点接入（较多路由器互联）时，会产生大量的多播分组，通讯量过大。<br><strong>解决方法</strong></p><ol><li><p>屏蔽部分路径，因此只与部分路由器进行数据交换。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6420e503df73b7ef.webp"><br>DR出现问题后使用BDR替换。</p></li><li><p>路由分区，<strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-725b3aab5aa350b1.webp"></p><blockquote><p>实现细节：</p><ul><li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域，每个区域都有一个32比特的区域标识符，主干区域的区域标识符必须为0，主干区域用于连通其他区域，其他区域的区域标识符不能为0且不相同。</li><li>每个区域一般不应包含路由器超过200个。</li><li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量。</li></ul></blockquote></li></ol><h4 id="OSPF的优缺点"><a href="#OSPF的优缺点" class="headerlink" title="OSPF的优缺点"></a>OSPF的优缺点</h4><div class="note note-primary">            <p>优点：</p><ul><li>从算法上避免了环路的产生。</li><li>基于链路状态，相比RIP考虑了更多对链路代价的影响因素。</li><li>不限制网络规模（没有最长距离限制）</li></ul><p>缺点：</p><ul><li>实现较复杂。</li><li>路由器需要获取AS内所有路由器信息，通信量大，可以通过<strong>指定路由器</strong>和<strong>划分区域</strong>的手段解决。</li></ul>          </div><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（<em>Border Gateway Protocol</em>） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><strong>为何需要BGP？</strong><br>AS之间没有统一度量，且需要一个网关去解决AS之间通讯时的相关策略问题（政治、经纪、安全等），因此需要一个外部网关协议。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5aae9c53795e17a7.webp"></p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-04fe6f98036db57c.webp"><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bc71c2ee5976ac53.webp"><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-b472dd1a51f30666.webp"></p><h5 id="BGP-4四种分组类型"><a href="#BGP-4四种分组类型" class="headerlink" title="BGP-4四种分组类型"></a>BGP-4四种分组类型</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-67b837e6c27d5e9c.webp"></p><div class="note note-primary">            <p>总结，BGP协议要求每个AS有一个发言人，发言人之间建立TCP连接建立会话，交换路由信息。类似于OSPF协议，发言人也会构造一个无环路的AS连通图。<br>注意，<strong>BGP不保证最好路由，只选择较好路由</strong>。</p>          </div><h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-40cf22cbd65e9ed8.webp"></p><h1 id="五、IPv4数据包格式"><a href="#五、IPv4数据包格式" class="headerlink" title="五、IPv4数据包格式"></a>五、IPv4数据包格式</h1><h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><blockquote><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li></ul></blockquote><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-73800cce52c3a91e.webp"></p><h3 id="固定部分"><a href="#固定部分" class="headerlink" title="固定部分"></a>固定部分</h3><p><strong>基本信息</strong><br>主要记录一些版本，服务约定，和后续数据长度。</p><ul><li>版本：占4比特，目前最广泛的是4（IPv4）</li><li>首部长度：占4比特，该字段的取单位为<strong>4个字节</strong>（即上图的一行）。<ul><li>最小十进制取值为5，即20字节固定部分</li><li>最大十进制取值为15，即20字节固定部分和40字节可变部分</li></ul></li><li>区分服务：占8比特，需要区分服务（不同等级的服务质量）时才起作用，一般不适用该字段。</li><li>总长度：占16比特，表示<strong>单位为字节</strong>的IP数据报总长度（包括首部长度）。最大值为65535，即2^16-1</li></ul><p><strong>分片信息</strong><br>主要用于IP数据报分片<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a014cde6b0ff9691.webp"></p><ul><li>标识：占16比特，同一个IP数据包的分片应该有同一个标识，类似IP</li><li>标志：占3比特：<ul><li>DF位：1个比特，1表示不允许分片；0表示允许分片。</li><li>MF位：1个比特，1表示不是最后一个分片，0表示是最后一个分片。</li><li>保留位：1个比特。</li></ul></li><li>片偏移：占13比特，表示分片数据包的“数据载荷部分”相比原数据报中的“数据载荷部分”偏移了多少。（<strong>单位为8字节</strong>，注意，由于这里的偏移量比特位小于总长比特位，为了完成表达必须使用更大的单位。）<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5d538557f988dc41.webp"></li></ul><p><strong>解析信息</strong></p><ul><li>生存时间TTL：占8比特，以“跳数”为单位，每次路由器转发该IP数据包，TTL-1，若为0则丢弃。</li><li>协议：占8比特，指明IPv4数据包的数据部分向上交付给什么协议。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-94a3b7c0b1f01488.webp"></li><li>首部检验和：占16比特，检测首部在传输过程中是否出现差错。比CRC检验码简单，被称为因特网检验和。（由于TTL、片偏移、标志等可能发生变化，每次路由器转发时都要重新计算该值，耗时太大，在IPv6中已经不再计算首部校验和）</li></ul><p><strong>地址信息</strong><br>目的IP和源IP地址：各占32比特。</p><h3 id="可变部分"><a href="#可变部分" class="headerlink" title="可变部分"></a>可变部分</h3><ul><li>可选字段：长度从1到40字节不等</li><li>填充字段：确保<strong>首部长度为4字节</strong>（呼应首部长度的单位是4个字节）的整数倍，使用全0填充。</li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h3><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><div class="note note-primary">            <p>简而言之，需要一个与路由器之间的协议来<strong>监测数据的转发情况</strong>。</p>          </div><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8739d970a0300acc.webp"></p><blockquote><p><strong>ICMP报文会被封装到IP数据报中，但其不是高层协议，而是IP层的特殊协议（起控制作用，所以也叫网际控制报文协议ICMP）。</strong></p></blockquote><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6a02675fccdc2958.webp"></p><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p><strong>终点不可达</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-855edabd9c1e6298.webp"><br><strong>源点抑制</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e7f27ef6c93c9621.webp"><br><strong>时间超过</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-49d82185c88813fe.webp"><br><strong>参数问题</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e2457fe1291c9bca.webp"><br><strong>改变路由（重定向）</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0ef50227f921ca79.webp"></p><p><strong>另外，不应发送ICMP差错报告报文情况</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a0c3a21bb04ede42.webp"></p><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（<em>Packet InterNet Groper</em>）</h4><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-75d7bc12ca942415.webp"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（<em>traceroute</em>）</h4><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-185af899d5e5a922.webp"><br>实现原理：<br>使用从1开始递增的TTL发送多个报文，报文在路由器超时时会返回给源主机ICMP差错报告，从而得到各跳的信息。</p><h1 id="六、虚拟专用网VPN与网络地址转换NAT"><a href="#六、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="六、虚拟专用网VPN与网络地址转换NAT"></a>六、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（<em>Virtual Private Network</em>）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>虚拟专用网络</strong>VPN的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><div class="note note-primary">            <p>顾名思义，指一种利用公网实现专用网访问的技术。</p><p>简单的说就是两个专用网络之间通过公网IP进行加密通讯。VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>          </div><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ad9e5dcca8c0a1c9.webp"></p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6731dbc8b1ee1abc.webp"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（<em>Network Address Translation</em>）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>目的：大量的办公室网络和家庭网络导致IP地址仍然不够，需要实现IP复用。NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p>专有NAT软件的路由器叫做NAT路由器，其有至少一个公网IP地址。</p><p>以上只解决了发送信息的问题，为了实现接受消息后的对内网用户的分发需要使用NAPT技术，具体见以下实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-05d3e1e3fd4b1998.webp"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>外网无法直接访问内网<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d2fd109d060e4853.webp"></li><li>NAT对内网主机提供了一定的安全保护<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ff43ea52e61da271.webp"></li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第3章（数据链路层）</title>
    <link href="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>物理层已经保证了数据在物理层面上的传输功能，但无法避免传输中发生的错误。数据链路层作为网络层、物理层之间的桥梁，<strong>主要的职责则是保证数据传输过程的差错控制和可靠传输</strong>，即识别、纠正传输中发生的错误。</p><p>网络中的主机、路由器、交换机等都必须实现数据链路层。</p><p>术语：</p><ul><li><strong>链路</strong>（<em>Link</em>）表示一段没有交换节点<strong>物理</strong>线路</li><li><strong>数据链路</strong>（<em>Data Link</em>）表示具有通讯协议的软硬件实现的<strong>链路</strong>。</li></ul><div class="note note-primary">            <p>数据链路层的协议是多样的，两个主机之间的数据传输，可能会经过多个不同协议数据链路，他们只需要保证实现数据链路层的功能和对网络层的服务相同即可。</p>          </div><p>使用的信道类型分类：</p><ul><li>点对点信道</li><li>广播信道</li></ul><blockquote><p><strong>局域网属于数据链路层</strong><br>局域网虽然也是个互联网，但我们不将其放在网络层考虑，因为网络层的主要职责是将分组从一个网络通过路由器发送到另一个网络。而局域网的功能，使用交换机即可实现。<br>PS：路由器也可以称为三级交换机，我们平时说的交换机就是二级交换机。</p></blockquote><h2 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong><br><strong>封装成帧</strong>：将数据加上帧头和帧尾，用于<strong>帧定界</strong><br><strong>差错控制</strong>：识别传输中的错误。<br><strong>可靠传输</strong>：识别错误后确保重传。</p><blockquote><p>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决，如帧识别（确认是发给自己的帧）、数据碰撞问题（共享信道的问题）。下面我们只讲PPP的例子。</p></blockquote><blockquote><p>目前，在有线（局域网）领域使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>已经取代了<del>共享式局域网</del><br>而在无线局域网中仍然使用的是共享信道技术</p></blockquote><h1 id="二、主要职责"><a href="#二、主要职责" class="headerlink" title="二、主要职责"></a>二、主要职责</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-bf6fe42eeea3f376.webp"><br>封装成帧的目的是识别帧分界，不同数据链路层协议对此的实现是不同的：</p><ul><li>PPP，帧头和帧尾有1字节的标识符</li><li>EtherNet的V2的MAC帧，使用一个前导码，例如：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f1441c531b4d740e.webp"></li></ul><blockquote><p>为了实现定界，需要一个开始和结尾符，以太网规定开始符为前导码，结尾符的功能通过保持帧的间距（以太网还规定了帧间间隔为96比特时间）实现（说明PPP的帧是连续的？也合理，点对点连着传）</p><p>前导码包括前同步码和帧开始定界符</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧（这里是从右往左看）</li></ul></blockquote><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，因此我们要避免上层数据中也出现帧定界符导致的解析混淆。</p><p><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (<em>byte stuffing</em>) 或<strong>字符填充</strong> (<em>character stuffing</em>)，面向比特的物理链路使用比特填充的方法实现透明传输。</p><p>具体的:</p><ul><li>发送端对于上层交付数据中出现的与定界符相同的字符，在其前插入转义字符“ESC”（十六进制编码是1B），若上层数据本身有该转义字符，则再其前插入一个转义字符。</li><li>接受端将内容中的转义字符剔除即可。</li></ul><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-9d3f61fdd96b7dee.webp"></p><p>最大传送单元MTU 规定了帧的<strong>数据部分</strong>的长度上限。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><strong>比特差错</strong>：1变0，0变1<br><strong>误码率BER</strong>(<em>Bit Error Rate</em>)：错误bit占总bit的比率。</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>使用1位bit来标记 数据中“1”个数的奇偶性，只要出现两个相同类型误码就会漏检。</p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(<em>Cyclic Redundancy Check</em>)</h3><p>约定好一个生成多项式G(x)，其实就是一段bit串，如：10111<br>将这个bit串作为除数，原数据作为被除数，得到余数，这个数称为<strong>检错码</strong>，也称为<strong>帧校验序列 FCS</strong></p><blockquote><p>检错码只有检查错误的能力，<strong>不知道错误发送的位置</strong><br><strong>纠错码</strong>可以进行前向纠错，但成本高，使用少<br>CRC非常易于硬件实现，被<strong>广泛应用于数据链路层</strong><br>检查出错误后，是丢弃还是重传，往往取决于数据链路层向上层提供的是<strong>可靠传输服务</strong>还是<strong>不可靠传输服务</strong>。</p></blockquote><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><strong>比特差错</strong></p><ul><li>对于可靠传输要求实现重传，对于不可靠传输，交给上层协议处理。</li><li><strong>一般而言</strong>，有限链路不要求可靠，无线链路要求可靠（误码率高）。</li></ul><p><strong>分组丢失、分组失序、分组重复</strong><br>一般不发生在数据链路层，而是发送在上层。</p><div class="note note-primary">            <p>理解：在单条数据链路上，数据一般不会丢失。失序、重复，这些问题往往发生在网络层。</p>          </div><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/Pic0.png"></p><p>为了解决以上错误，有以下三种可靠协议，这三种协议更多体现的是一种事件确认思想，因此可以应用到各层的协议中。</p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><h4 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>发送端发送数据DATA0后，等待接受方返回一个确认信息ACK0后，再发送下一条数据DATA1。</li><li>为了防止数据的丢失、错误，需要设置<strong>重传时间</strong></li><li>为了防止数据重传造成的重复发送、接受，需要设置一个<strong>Bit位标识数据</strong>区别</li></ul><div class="note note-primary">            <p>这部分的各种特殊情况比较复杂，我们按照事件的发生进行梳理。<br>在数据传输过程中有三个基本问题需要解决：<br><strong>数据丢失</strong>（没传到）、<strong>数据错误</strong>（传错了）、<strong>数据延迟</strong>（传慢了）。</p><p>为了解决<strong>数据丢失</strong>和<strong>数据错误</strong>的问题，发送端需要重发数据，所以设置了一个超时时间，超过时间就会进行<strong>重传</strong>。（实际上对于<strong>数据错误</strong>，接受端也可以主动回复NAK提醒发送端尽快重发，但有线网内这种情况较少，一般只在误码率较高的时候进行）。</p><p>对于<strong>数据延迟</strong>的问题，理想情况其实是等待数据达到，即不需要我们解决。但实际上无法确定是数据是延迟还是丢失，也会导致触发重传，这里就衍生出了一个新问题，即<strong>发送端和接受端都可能接受到两条甚至更多相同的数据</strong>（因为接受端对每条信息都会回复确认，所以发送端也会收到两条确认ACK信息），显然我们要对后面的数据进行忽略，因此需要一个数据标识符做区分，在这里体现为一个bit。</p><p>至此，我们解决了3个基本问题和1个衍生问题。</p>          </div><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-8dbdfdbac8087fd21.webp"></p><h5 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3b4b0d81e5dd78eb.webp"></li></ul><blockquote><p>停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><div class="note note-warning">            <p>为了解决RTT过长的问题，有以下两种协议。</p>          </div><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cc9d42f63bd259cc.webp"></p><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-2a7141766ab1aa80.webp"></p><ul><li>发送方可以一次性<strong>连续发送</strong>多个数据分组，接受方每接受到一个数据就移动一次窗口，且不需要对每个分组逐个确认，一般设置在接受到若干个数据分组，对接受到的最后一个数据分组进行一次<strong>累计确认</strong>即可。</li><li>传递发生错误时，例如5号分组出现错误则丢弃，此后接收方每接受到一个不是5号的信息都会<strong>主动回复</strong>一个ACK4，请求发送端尽快发送DATA5（发送端在收到多少个ACK4后会提前发送DATA5，由具体实现决定，实际上就算收不到，也会超时重发。）<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-215e8704b22ef7f2.webp"></li><li><strong>使用n位bit标识分组</strong>，则编号范围为0~2^n-1，发送窗口大小必须小于2^n-1，否则接收方会出现误判。</li></ul><div class="note note-primary">            <p>相对SW协议，GBN协议为了提高信道利用率，采用了<strong>连续发送与累计确认、主动回复</strong>等方式，在具体的实现上出现了新的问题和解决：</p><ul><li>针对<strong>连续发送与累计确认</strong>，为了识别正确接受顺序，需要使用多bit位标识数据，bit的位数也限制了发送窗口大小。</li><li>针对<strong>主动回复</strong>，客户端之前接受到错误信息和重复分组时会直接舍弃。现在客户端只舍弃错误信息，也因此会接收到许多错误分组信息（不是当前需要的分组），对这些都要进行重复确认ACK。</li></ul><p>当然，超时重传的性质依然存在，这是避免信息丢失的必要手段，主动回复只是一种加速，不是一种保证。</p>          </div><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><h5 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li><strong>扩大接受窗口的尺寸</strong>，接收方可以不用按照顺序接受分组，避免浪费。发送方也可以只重传错误分组。</li><li>由于不再按顺序接受分组，所以需要<strong>逐条确认</strong>，累计确认不再有效。发送，接受方都需要逐个确认。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=27&vd_source=7324e975d0c1b4b4719d1194e3649ff8">视频参考</a></li></ul><div class="note note-primary">            <p>相当于对分组进行批量的发送接受，只重传错误分组，重传机制仍是超时判断。接收方根据接受到的分组DATA滑动窗口，发送方根据接受到的ACK滑动窗口。</p>          </div><h1 id="三、点对点协议PPP"><a href="#三、点对点协议PPP" class="headerlink" title="三、点对点协议PPP"></a>三、点对点协议PPP</h1><ul><li>点对点协议PPP（<em>Point-to-Point Protocol</em>）是目前使用最广泛的点对点数据链路层协议。</li></ul><div class="note note-primary">            <p>端对端是P2P(Peer-to-Peer)。</p>          </div><h2 id="职责实现"><a href="#职责实现" class="headerlink" title="职责实现"></a>职责实现</h2><p>上文介绍了数据链路层的主要职责和方法，具体协议则需要对各功能做具体实现。</p><h3 id="封装成帧-1"><a href="#封装成帧-1" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>使用了帧头帧尾和对应的转义字符。<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-b384615e861000f3.webp"></p><h4 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h4><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d40da4575c590f5c.webp"></li><li>面向比特的同步链路：比特填充法（插入“比特0”）<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6290c73d8957ee8d.webp"></li></ul><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>使用FCS计算帧部分，立即丢弃错误帧。<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-501e6b9dd2afcee3.webp"></p><h1 id="四、媒体接入控制——广播信道"><a href="#四、媒体接入控制——广播信道" class="headerlink" title="四、媒体接入控制——广播信道"></a>四、媒体接入控制——广播信道</h1><blockquote><p><em>Medium Access Control</em>翻译成媒体接入控制，有些翻译成<strong>介质访问控制</strong>，是一种主要用于局域网的数据链路层的广播通信方式。</p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>网络拓扑结构：星形、总线、环形</p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><div class="note note-primary">            <p>PPP协议是目前使用最广泛的点对点数据链路层协议，但数据链路层需要解决局域网问题，局域网常常会有共享信道，广播等需求。对于不同类型的局域网，这些需求的解决方式也不尽相同，因此又将数据链路层分为两层，一层解决类似PPP（PPP基本没有第二层问题，其独占信道）的问题，另一层解决传输媒体（主要是信道冲突）上的问题。</p>          </div><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3d6792f6b442b459.webp"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><div class="note note-primary">            <p>PPP协议对应的交换机技术可以很好的解决共享信道问题，但是无线网络仍需要共享媒体。信道复用问题之前在物理层也提过，但由于物理层主要只解决01传递的问题，这种与传媒相关的问题则交给了数据链路层的MAC子层解决。</p>          </div><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>频分复用FDM</strong> (<em>Frequency Division Multiplexing</em>)</p><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。<br><strong>时分复用TDM</strong> (<em>Time Division Multiplexing</em>)</li><li><strong>时分复用</strong>则是将时间划分为一段段<strong>等长</strong>的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。  </li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong><br><strong>波分复用 WDM</strong>(<em>Wavelength Division Multiplexing</em>)</li><li>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。<br><strong>码分复用 CDM</strong> (<em>Code Division Multiplexing</em>)<blockquote><p>复用：信道分为多个子信道，用户使用子信道。<br>多址：动态分配信道给用户，用户暂时占用信道。<br>因此码分复用更多的被称为码分多址。</p></blockquote></li></ul><p>具体实现：使用多个bit位表示1个bit位，解释如下：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-91ed6f416ae8fad6.webp"><br>这样，接受方通过向量计算即可从叠加信号中解析中指定发送方发出的信息。</p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>总线局域网</strong>使用CSMA&#x2F;CD（<em>Carrier Sense Multiple Access&#x2F;Collision Detection</em>）协议，即载波监听多址接入&#x2F;碰撞检测。<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-00eb7fba113030d2.webp"><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-574d77a51611a634.webp"></p><div class="note note-primary">            <p>CD的硬件实现：判断总线电压摆动值变大超过门限。<br>为什么需要CD：CS具有传播延迟。</p>          </div><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1.准备发送-&gt;2.载波监听（信道忙则回到1）-&gt;3.发送并碰撞检测（碰撞则停止并等待一段时间回到1）-&gt;4.发送直到完毕</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a77d88a950995527.webp"></p><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-423fe21ffdbacb81.webp"></p><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-fa63a8f164fb9191.webp"></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-93f832e4b0a569ae.webp"></p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dc35877bb4bead1a.webp"></p><h4 id="帧接受过程"><a href="#帧接受过程" class="headerlink" title="帧接受过程"></a>帧接受过程</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cf2d95546ecf2664.webp"></p><div class="note note-primary">            <p>以上特性、限制都是为了在保证<strong>数据不碰撞</strong>的情况下保证<strong>合理性</strong>。<br><strong>保证不碰撞</strong>：<strong>争用期</strong>，<strong>最小帧长</strong>都是为了保证能检测信道是否有碰撞。<br><strong>合理性</strong>：<strong>最大帧长</strong>，单帧不能过长占用信道，<strong>截断二进制指数退避算法</strong>，灵活延迟避让时间，防止多次重传。</p>          </div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。<br><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong><br><strong>主要的无线网标准：802.11标准</strong><br>为什么无线局域网要使用CSMA&#x2F;CA协议：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dd01f296832d017a.webp"></p><div class="note note-primary">            <p>分布式协调功能DCF是各站点争用的方式。<br>点协调功能PCF则有一个中心站做协调，但使用较少。</p>          </div><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6c9fe4ae6927eb02.webp"><br>相比载波监听，有信道空闲持续时间限制，其控制了帧的发送间隔。</p><blockquote><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul></blockquote><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a756ebbd569e600a.webp"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><ul><li>防止多个站点同时发送数据而产生碰撞</li></ul></blockquote><p><strong>使用退避算法的时机</strong><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f0d70f0b26645fb4.webp"></p><p><strong>CSMA&#x2F;CA协议的退避算法</strong><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-1de197cb6f859f3c.webp"></p><p>示例：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-12262e66fc986d52.webp"></p><div class="note note-primary">            <p><strong>碰撞检测CD</strong>的思想类似于<strong>乐观锁</strong>，即先发送，发送后碰撞则进行退避处理。<br><strong>碰撞避免CA</strong>的思想类似于<strong>悲观锁</strong>，需要尽可能的保证信道通畅（通过退避的方式）然后再发送。<br>载波监听则是一种判断是否有锁的工具。</p><p>在CD中，如果当前信道空闲则直接发送信号，失败后则停止发送并等待，随后尝试重新发送。<br>在CA中，如果当前信道空闲，<strong>首先要等待一个DIFS时间</strong>，等待<strong>优先级</strong>更高的站点先尝试获取信道，这个时间之后，<strong>再根据信道的状况判断是否需要进行退避。</strong></p><ul><li><strong>DIFS时间是DCF模式（分布式协调功能）下的退避时间的基本单位。</strong></li><li><strong>默认的DIFS间隔时间并不在退避算法中</strong>。其是整个共享信道的处理完一个帧之后的间隙时间，各个站点以通过信道的这个间隙时间来判断信道进入了空闲状态（空闲了一个DIFS时间），然后解冻倒计时，进行<strong>优先级</strong>争夺。</li></ul>          </div><h4 id="信道预约和虚拟载波监听"><a href="#信道预约和虚拟载波监听" class="headerlink" title="信道预约和虚拟载波监听"></a>信道预约和虚拟载波监听</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-98353d62c0ef033f.webp"><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ac35b15f5f22bf7d.webp"></p><div class="note note-primary">            <p>以上为可选功能，通过向目的站发送“要发送数据帧”的请求（<strong>信道预约</strong>），目的站同意这个请求后发出“允许发送数据帧”的广播，此时其他站点就不能使用该信道了。由于RTS、CTS都携带了下次传递的大数据帧信息，因此其他站点知道本次信道会被占用的时间，实现了<strong>虚拟载波</strong>。<br>此时，如果其他站只能监听到目的站信息，监听不到源站信息，其也可以收到CTS从而避免在这个时间段内发送信息，减少了隐蔽站的问题。</p>          </div><h1 id="五、MAC地址、IP地址、ARP地址"><a href="#五、MAC地址、IP地址、ARP地址" class="headerlink" title="五、MAC地址、IP地址、ARP地址"></a>五、MAC地址、IP地址、ARP地址</h1><p>三者的关系：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ede2c92a0c809e6c.webp"></p><h2 id="MAC-Media-Access-Control-地址"><a href="#MAC-Media-Access-Control-地址" class="headerlink" title="MAC(Media Access Control)地址"></a>MAC(<em>Media Access Control</em>)地址</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><div class="note note-primary">            <p>注意：MAC地址的主要作用标记目的物理地址和源物理地址，在<strong>广播信道</strong>中，所有站点都会接受到MAC帧（也可以由交换机进行调度），然后根据目的物理地址是自身而决定是否舍弃该帧，但对于<strong>点对点的信道（不是协议）</strong> 则不需要MAC帧。</p>          </div><blockquote><ul><li><strong>MAC地址又称为硬件地址或物理地址</strong>。但其属于数据链路层而不是物理层。</li><li>MAC地址是对网络上各接口的唯一标识。</li></ul></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-70ee74506eca1df4.webp"></p><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。<br>无效MAC帧：</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；<br>（防止bit丢失）</li><li>用收到的帧检验序列 FCS 查出有差错；<br>（防止bit错误）</li><li>数据字段的长度不在 46 ~ 1500 字节之间。<br> (防止bit增加)<br>以太网检测到无效MAC帧直接丢弃。</li></ul><p>MAC帧发送顺序</p><ul><li>从第一字节发到第六字节</li><li>每字节从b0发到b7</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>单播（单选）：根据站点根据目标地址与自己是否相符决定是否舍弃。</li><li>广播（全选）：<strong>广播MAC地址为全F</strong>，所有站点都接受该帧</li><li>多播（多选）：只发送给指定的若干目的站点。<strong>多播MAC帧的目的地址的第一个bit为1</strong>，即第一个字节的b0位为1。其他站点是否接受则根据自身多播组列表设置。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴。</p><ul><li>对于局域网而言MAC地址即可区分设备（但现在实际上还是会使用IP地址而不是MAC地址）。</li><li>对于因特网而言MAC地址无法区分一个网络，需要使用IP地址加MAC地址。</li><li>例子：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-77c204bc8181b3ed.webp"></li></ul><div class="note note-primary">            <p>参考现实中根据地图导航。<br><strong>IP地址</strong>用来标记起点和终点，从起点到终点需要经过很多交通工具。<br><strong>MAC地址</strong>根据目的IP地址选择当前交通应该在哪站下车然后换乘。<br>这个根据IP地址选择下车站的方法就是<strong>ARP协议</strong></p>          </div><h2 id="ARP协议（地址解析协议Address）"><a href="#ARP协议（地址解析协议Address）" class="headerlink" title="ARP协议（地址解析协议Address）"></a>ARP协议（地址解析协议Address）</h2><p>主机都有一个ARP高速缓存表，其中记录了IP地址和MAC地址的映射。</p><ul><li>如果表中记录了IP地址对应的MAC地址，则可以直接填写目的MAC地址发送MAC帧。</li><li>如果不知道，则发送<strong>ARP请求报文</strong>（广播）。目的IP地址的主机接受到该请求后会给源主机回复自己的MAC地址。</li></ul><p><strong>ARP高速缓存表</strong><br>有动态记录和静态记录。</p><ul><li>动态记录为自动获取，有持续时间、过期作废（默认两分钟）</li><li>静态记录为手工设置，始终保存（实际上依赖于操作系统的实现）。</li></ul><blockquote><p>ARP是逐段链路进行的。即主机只记录和自己直接连接主机的MAC地址，跨网络的地址则不管。</p></blockquote><div class="note note-primary">            <p>这里的ARP的作用主要是让机器通过广播形式学习和自己直连的设备的IP-MAC映射关系，<strong>方便其填入MAC帧的目的地址</strong>，并不能告知他应该如何把数据准确的发送到哪个主机。</p><p>ARP没有安全验证机制，可能<strong>存在ARP欺骗（攻击）问题</strong>。</p><p>ARP表中记录<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>          </div><h1 id="六、集线器和交换机"><a href="#六、集线器和交换机" class="headerlink" title="六、集线器和交换机"></a>六、集线器和交换机</h1><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>在总线型网络中，所有站点共享一个信道。但总线的拓扑结构在<strong>物理层</strong>实现很不方便，所以可以使用集线器作为中点，网络结构则变成了<strong>星型结构</strong>。</li><li>但实际上其在以太网上仍是一个<strong>总线型网络</strong>。集线器也只工作在物理层，并没有网络管理作用。</li><li>集线器是也可以看做多口<strong>中继器</strong>，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>扩展网络（<strong>扩大广播域</strong>），两个集线器直接连接即构成了更大的总线网络。但<strong>碰撞域</strong>却增大了。</p><blockquote><p><strong>碰撞域</strong>（<em>collision domain</em>）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p></blockquote><div class="note note-primary">            <p>集线器工作在物理层，而下文中的交换机工作在数据链路层。</p>          </div><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是网桥的替代品，是一个多接口的网桥。<br><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃（<strong>具有管理作用</strong>）。<br><strong>交换机</strong></li><li>1990 年问世的交换式集线器 (<em>switching hub</em>) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (<em>switch</em>) 或<strong>第二层交换机</strong> (<em>L2 switch</em>)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul><p>相对于集线器，其可以进行ARP自学习，并将数据帧定向转发。</p><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度</li><li>不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d5c429a2f92149ff.webp"></p><p><strong>扩大广播域</strong>的同时，<strong>隔离碰撞域</strong></p><blockquote><p><strong>广播域</strong>（<em>broadcast domain</em>）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。注意要与前面的碰撞域做区分。</p></blockquote><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-25db1be3ca96bc2f.webp"></p><h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>以太网交换机通过<strong>自学习算法</strong>建立<strong>帧交换表</strong></p><h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><ul><li>交换机接受到一个数据帧后就会记录这个帧的<strong>源地址</strong>和对应的交换机<strong>端口</strong>（没有则插入，有则更新）</li></ul><h4 id="转发行为"><a href="#转发行为" class="headerlink" title="转发行为"></a>转发行为</h4><ul><li>交换接的帧交换表中如果有该帧<strong>目标地址</strong>对应的端口，则直接将消息转发到该端口，否则发送<strong>广播</strong>（但不对源地址发送）。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每条记录都有有效时间，有效时间到期后删除。（主机可能换网卡，交换机可能改接另一台主机）</li></ul><div class="note note-primary">            <p>注意本处的自学习和前面提到的ARP的异同：<br>异：</p><ul><li>ARP记录的是IP和MAC地址之间的映射关系，记录在ARP高速缓存表中。交换机的自学习记录的是MAC地址与自己的端口的关系，记录在帧交换表中。</li><li>ARP高速缓存表主要用于根据上层的目的IP地址填入目的MAC地址。交换机帧纪录表则用于根据目的MAC地址选择往哪个端口发送。</li><li>实现在不同层面，ARP的实现在逻辑上，依赖于非目标主机会自行舍弃帧；交换机实现在物理上，依赖于只发送给目标机。可以认为交换机是对ARP的总线结构下的一种信道层面优化，减少了各个客户端识别帧的负担并解决碰撞问题。<br>同：</li><li>有已知记录时都会直接发送，没有时都会进行广播学习。</li></ul>          </div><h1 id="七、生成树协议STP"><a href="#七、生成树协议STP" class="headerlink" title="七、生成树协议STP"></a>七、生成树协议STP</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>想要提高以太网的<strong>可靠性</strong>，可以尽可能多的添加交换机之间的连线（<strong>冗余链路</strong>）。这样两个交换机之间就不会因为一条链路出现故障而无法通讯。但这样会造成重复广播等问题，因此需要避免<strong>逻辑上的环路</strong>（保留物理上的环路以备用）。</p><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a65d811129786ec6.webp"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</p></blockquote><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (<em>Spanning Tree Protocol</em>)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><h1 id="八、虚拟局域网VLAN"><a href="#八、虚拟局域网VLAN" class="headerlink" title="八、虚拟局域网VLAN"></a>八、虚拟局域网VLAN</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>集线器和交换机扩大了广播域，但是广播域过于又会造成广播风暴，我们希望能够实现局部广播功能。</p><p><strong>广播风暴</strong><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a2a78b40ae5307db.webp"></p><h2 id="分割局域网的方法"><a href="#分割局域网的方法" class="headerlink" title="分割局域网的方法"></a>分割局域网的方法</h2><ol><li>使用路由器</li><li>VLAN(<em>Virtual LAN</em>)虚拟局域网</li></ol><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>： <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li></ul></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>本质上是要求使用<strong>交换机</strong>实现逻辑上将一个局域网划分成几个虚拟局域网（将一个交换机分成多个交换机），即判断一条广播消息属于哪一个组，因此这种MAC帧需要多一个明确的标识符以供交换机判断。</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-5d3549cc02f9a3b4.webp"><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6af352f81b800a98.webp"></li></ul><h3 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h3><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-44a2e259c33ecfd3.webp"></p><h4 id="Truck端口"><a href="#Truck端口" class="headerlink" title="Truck端口"></a>Truck端口</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a93996aae716c6aa.webp"></p><h4 id="Hybrid端口"><a href="#Hybrid端口" class="headerlink" title="Hybrid端口"></a>Hybrid端口</h4><p>是华为私有的端口类型，既可以用于交换机之间或交换机与路由器之间互连，也可以用于交换机与计算机之间互联。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-primary">            <p>数据链路层主要要负责将数据正确的送到目的地。</p><p>其需要在逻辑上实现其职责(逻辑链路控制LLC)：封装帧、差错检测和可靠重传。典型实现是PPP。</p><p>也需要与物理层的交界处实现对共享媒体控制(媒体接入控制MAC)：控制共享媒介的使用策略。典型实现是CSMA&#x2F;CA协议。</p><p>以上内容保证了数据的完整性，但我们还需要保证数据能正确送到指定主机或进行广播。因此需要ARP表来指明目的主机的MAC地址。</p><p>集线器与普通总线结构网络没有区别，而交换机则在可以根据目标MAC地址定向转发MAC帧，避免了碰撞问题，扩大了广播域。</p><p>最后，由于广播域的扩大会造成广播风暴，也有以下两种解决方法：</p><ul><li>为了避免循环广播，需要生成树协议。</li><li>为了避免广播到不必要的区域，需要VLAN。</li></ul>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/6b82134a4325">计算机网络第3章（数据链路层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第2章（物理层）</title>
    <link href="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、物理层的基本概念"><a href="#一、物理层的基本概念" class="headerlink" title="一、物理层的基本概念"></a>一、物理层的基本概念</h1><p>物理层主要考虑如何传输数据比特流。</p><h1 id="二、物理层传输媒体"><a href="#二、物理层传输媒体" class="headerlink" title="二、物理层传输媒体"></a>二、物理层传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><ol><li>同轴电缆（已被淘汰）</li><li>双绞线（主要用于局域网）</li><li>光纤（主要用于ISP接入服务）<ul><li>多模光纤：允许多条不同角度的光纤同时传输</li><li>单模光纤：如同一根波导，没有反射</li></ul></li><li>电力线（主要用于家庭网络扩展：猫）</li></ol><h2 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h2><ol><li>无线电波（波长1m-10km）</li><li>微波（波长1mm-1m）</li><li>红外线（已淘汰，只能直线传输）</li><li>可见光（LIFI）</li></ol><h1 id="三、传输方式"><a href="#三、传输方式" class="headerlink" title="三、传输方式"></a>三、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><strong>串行传输</strong>：数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可<br><strong>并行传输</strong>：一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p><div class="note note-primary">            <p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>          </div><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><strong>同步传输</strong>：以<strong>比特流</strong>的形式传输。字节之间没有间隔。<br><strong>异步传输</strong>：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</p><p>同步传输需要解决时钟问题，即数据的接收方如何判断哪一部分是一个字节：<br>对于同步传输，有两种方式同步时钟：</p><ul><li>外同步：添加独立时钟信号线</li><li>内同步：通过编码信息判断</li></ul><p>异步传输把字节之间断开，根据字节开始和结尾判断即可：</p><ul><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><h2 id="单双工"><a href="#单双工" class="headerlink" title="单双工"></a>单双工</h2><p>信道（<em>channel</em>）：信道一般都是用来表示向某一个方向传送信息的媒体。</p><p>单工：单向传输<br>半双工；双向（不能同时，需要两条信道）<br>双工：双向（同时，需要两条信道）</p><h1 id="四、编码和调制"><a href="#四、编码和调制" class="headerlink" title="四、编码和调制"></a>四、编码和调制</h1><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-acc59055804f0890.webp"></p><blockquote><p>术语：<br><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote><div class="note note-primary">            <p>编码和调制主要解决如何将0，1比特流转化为可以传输的信号形式。<br>码元（code）：对于本章的学习，可以理解为表示一个比特的单元波形。<strong>实际上，根据编码的不同，一个码元可以对应于几个比特，但也可以是几个码元对应于一个比特</strong>。</p><p>基带信号：表示数据传输前的原始信号。</p><p>针对不同的信道（媒介）有不同的方式：</p><ul><li>对于数字信道，其可以清楚的区分电平的高低，因此可以采用<strong>编码</strong>的方式处理原始信号。</li><li>对于模拟信道，一般使用波作为媒介，需要通过控制信号的频率和相位（即<strong>调制</strong>）的方式处理原始信号</li></ul>          </div><blockquote><p>严格来说，传输媒体 ≠ 信道，使用信道复用技术时，一条传输媒体可以包含多个信道。</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>不归零编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-0732d0edc74846b5.webp"><br>缺点：没有时钟同步。<br><strong>归零编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-8aa838a116fdafb4.webp"><br>缺点：每个码元都要归零，数据量太大，编码效率低。<br><strong>曼彻斯特编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-a34a686a9d052e9c.webp"><br>通过跳变方向判断比特位。</p><div class="note note-primary">            <p>相对归零编码，省去了当比特变化为<code>10101010</code>样式时的归零行为，不过对于<code>00000000</code>形式的编码，数据量仍比较大，每次上升后需要在码元间隙下降，如上图的第二个0后面，以便于下一次上升。</p><p>问题：<br>这个码元间隙的下降行为是否导致时钟的误判问题。<br>解释：<br>所谓时钟同步，可以理解为一个打点计时器（？），设备根据打点瞬间电信号的电平判断这个比特位为0还是1，所以若是打点计时器的频率或初始时间与发送端不一致，就会得到失真的信号，这种现象也叫时钟滑移。<br>而曼彻斯特码元间的下降&#x2F;上升行为其实不会被视为下降沿&#x2F;上升沿，因为其实这种编码还是有一个隐藏时钟。对于设备来说，其可以判断接受到的电信号的最短时间间隔，从而判断一个码元的时间长度。（1个码元时间&#x3D;2个最短时间间隔），这样就解决了频率问题。<br>而一个码元单元必然有一个跳变，码元之间不一定有，从而解决了相位问题。</p>          </div><p><strong>差分曼彻斯特编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-9a758474e374329a.webp"><br>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li>跳变仅表示时钟</li><li>码元开始处电平是否变换表示数据<br>优点：比曼彻斯特编码的变化少，曼彻斯特编码为了得到正确的跳变方向有时需要在码元结束时置反，即（连续1和连续0时会导致码元间置反），而这里连续0<strong>或</strong>连续1时（具体看规定变化为0还是1），不需要进行置反。变化相对少一些。</li></ul><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。<br>每个基本波形只能表示1比特信息量。</li></ul><h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><ul><li>在编码中两个电位（一个表示时钟一个表示值）的信息即可表示1比特信息。而对于模拟信号，其有更多维度的信息（同上调制的基本方法），因此可以尝试使用一个码元表示多个比特。</li><li>频率就是相位的变化速率，因此两者不可同时调制。</li></ul><p><strong>正交振幅调制QAM</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1cb6de826ba63b70.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1e2617434d904ce4.webp"></p><ul><li>给出了12个相位（角度），其中有4个角度（45°）有两个振幅，则共有：8 * 1 + 4 * 2 &#x3D; 16种码元。</li><li>故一个码元的信息量为 2^4，可以表示4位bit。</li></ul><h1 id="五、信道的极限容量"><a href="#五、信道的极限容量" class="headerlink" title="五、信道的极限容量"></a>五、信道的极限容量</h1><p>传输信号时会产生各种失真。</p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p>如何尽可能地避免失真：</p><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-b90918937a54faa6.webp"></p><div class="note note-primary">            <p>奈氏准则主要给出一条信道的最高码元传输效率（理论）<br>波特率：码元传输速率<br>比特率&#x3D;波特率 * 每波特携带比特数<br>那么要提高比特率，则要提高每波特携带比特数。</p>          </div><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-57e105e5df793b93.webp"></p><div class="note note-primary">            <p>信噪比：理解起来可以视为信号相对噪音的占比，这个值越大，极限传输速率越高。</p>          </div><div class="note note-info">            <p>奈氏准则主要指出<strong>码元比特量</strong>对传输极限的影响。<br>香农准则主要指出<strong>信噪比</strong>对传输极限的影响。</p>          </div><h1 id="六、信道复用技术"><a href="#六、信道复用技术" class="headerlink" title="六、信道复用技术"></a>六、信道复用技术</h1><h2 id="复用技术类型"><a href="#复用技术类型" class="headerlink" title="复用技术类型"></a>复用技术类型</h2><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽（频率带宽）资源</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-bcb9321a6a8a3d7a.webp"></li><li><strong>时分复用TDM</strong>（<em>Time Division Multiplexing</em>）则是将时间划分为一段段等长的**时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。（可能浪费）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-cb9a20b7ce00d497.webp"></li><li><strong>统计时分复用 STDM</strong> (<em>Statistic TDM</em>)，弥补时分中的浪费，按需分配。<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-7f0b54d1c14702ca.webp"></li><li><strong>波分复用WDM</strong>(<em>Wavelength Division Multiplexing</em>)<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-039cdf67599ebe3b.webp"></li><li><strong>码分复用</strong>（<em>Code Division Multiplexing</em>），常用的名词是<strong>码分多址</strong> CDMA (<em>Code Division Multiple Access</em>)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/792648675640">计算机网络第2章（物理层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第1章（概述）</title>
    <link href="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <url>/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong>互连网</strong>（<em>internet</em>）：多个网络通过路由器互连起来构成的网络（通用名词，可使用任意协议）<br><strong>因特网</strong>（<em>Internet</em>）：是世界上最大的互连网（专有名词，使用TCP&#x2F;IP协议）<br><strong>ISP</strong>（<em>Internet Service Provider</em>）：因特网服务提供者，如电信、联通、移动。</p><p><strong>端系统之间通信</strong>：主机 A 的某个进程和主机 B 上的另一个进程进行通信。</p><div class="note note-primary">            <p>端对端通讯分为两大类：C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p>          </div><h1 id="二、交换方式"><a href="#二、交换方式" class="headerlink" title="二、交换方式"></a>二、交换方式</h1><h2 id="1-电路交换（Circuit-Switching）"><a href="#1-电路交换（Circuit-Switching）" class="headerlink" title="1.电路交换（Circuit Switching）"></a>1.电路交换（<em>Circuit Switching</em>）</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-acb87df045723236.webp"></p><blockquote><p>步骤：<br>1.建立连接 2.通话 3.释放连接</p></blockquote><h2 id="2-分组交换（Packet-Switching）"><a href="#2-分组交换（Packet-Switching）" class="headerlink" title="2.分组交换（Packet Switching）"></a>2.分组交换（<em>Packet Switching</em>）</h2><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>称为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方：</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器：</p><ul><li>缓存分组</li><li>转发分组</li></ul><p>接收方：</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h2><p>报文交换对报文的大小没有限制，主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="4-对比"><a href="#4-对比" class="headerlink" title="4.对比"></a>4.对比</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e655a213714d1871.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-c56f91f290cbc92b.webp"></p><h1 id="三、定义与分类"><a href="#三、定义与分类" class="headerlink" title="三、定义与分类"></a>三、定义与分类</h1><h2 id="按覆盖范围"><a href="#按覆盖范围" class="headerlink" title="按覆盖范围"></a>按覆盖范围</h2><ul><li>广域网WAN（<em>Wide Area Network</em>）</li><li>城域网MAN（<em>Metropolitan</em>）</li><li>局域网LAN（<em>Local</em>）</li><li>个域网PAN（<em>Personal</em>）</li></ul><h2 id="按结构"><a href="#按结构" class="headerlink" title="按结构"></a>按结构</h2><ul><li>总线<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-4ed63e74d9ced719.webp"></li><li>星型<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f6a1849bcc443935.webp"></li><li>环形<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ca133aaaf8fe8659.webp"></li><li>网络<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-d0d30cddc7356396.webp"></li></ul><h1 id="四、性能指标"><a href="#四、性能指标" class="headerlink" title="四、性能指标"></a>四、性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ba6c4e627a62c05e.webp"></p><div class="note note-primary">            <p>速率的k一般指1000，数据量的k为1024</p>          </div><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f4b18e0039f4a6c6.webp"></p><div class="note note-primary">            <p>带宽在模拟信号中指频率范围，在计网中指最高<strong>速率</strong>。<br>关联在于，频率越高，速率越高。</p>          </div><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位时间通过某网络的数据量</p><div class="note note-primary">            <p>带宽相当于理论值、吞吐量为真实值。</p>          </div><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</p><blockquote><p>有时会把排队时延看成<strong>处理时延的一部分</strong><br>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><div class="note note-primary">            <p>m &#x3D; 2 * 10^8</p>          </div><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><div class="note note-primary">            <p>表示链路上有多少个bit正在流动</p>          </div><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>RTT(<em>Round-Trip Time</em>)</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-62d6da59682ef67f.webp"></p><div class="note note-primary">            <p>信道利用率针对具体信道，网络针对全网络信道，都是对时间的利用统计。</p>          </div><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>一定时间范围内，丢失分组数量与总分组数量的比率</p><h1 id="五、体系结构"><a href="#五、体系结构" class="headerlink" title="五、体系结构"></a>五、体系结构</h1><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b5174af1551d6cee.webp"></p><div class="note note-primary">            <p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。<br>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>          </div><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6800e214b18c47c3.webp"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="1-发送"><a href="#1-发送" class="headerlink" title="1.发送"></a>1.发送</h3><p>应用层（<strong>HTTP请求报文</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ac36f7a9544dde9f.webp"><br>传输层（<strong>TCP报文段</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-cc2b73b1736d5809.webp"><br>网络层（<strong>IP数据报</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-dc02183dcf759d9e.webp"><br>数据链路层（<strong>帧</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f8cf8ce4a6bfdb54.webp"><br>物理层（<strong>比特流</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e7285afa504bce0d.webp"></p><h3 id="2-路由转发"><a href="#2-路由转发" class="headerlink" title="2.路由转发"></a>2.路由转发</h3><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b9824f4625354b9b.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-09a0b27933c9895e.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6eace5a882cca26d.webp"><br>再整个封装回去。</p><div class="note note-primary">            <p>路由器主要作用在网络层及以下，主要根据路由表查询端口转发IP数据包。</p>          </div><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>实体：任意可发送或接受信息的硬件或进程</li><li>对等实体：相同层次的实体</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-01d621fd0afde0a2.webp"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合<br>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f9bd7898a7f2dadd.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/541d4f0c0f1e">计算机网络第1章（概述）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-基础篇</title>
    <link href="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP-x2F-IP网络模型"><a href="#一、TCP-x2F-IP网络模型" class="headerlink" title="一、TCP&#x2F;IP网络模型"></a>一、TCP&#x2F;IP网络模型</h1><p>主要针对TCP&#x2F;IP网络模型。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层</strong>（<em>Application Layer</em>）只专注于提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="传输层"></p><p>传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p><strong>TCP</strong> 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p><strong>UDP</strong> 只负责发送数据包，不保证数据包是否能抵达对方。但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><h3 id="应用层与传输层的交互"><a href="#应用层与传输层的交互" class="headerlink" title="应用层与传输层的交互"></a>应用层与传输层的交互</h3><p>应用需要传输的数据可能会非常大，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E6%AE%B5.png" alt="TCP段"></p><p>传输层其实并不负责整个传输过程，它的作用是相对应用层而言的，即它可以帮助应用层实现数据传输。</p><p>到传输层数据到达目标设备时，传输层则要负责把数据包传给应用，但一台设备有多个应用，这时需要使用端口号将应用区分开来。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层报文中携带端口号，因此可以识别数据要发给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>如上所述，传输层其实主要做区分应用，把应用数据下发的作用，真正使数据在互联网上传输的功能在<strong>网络层</strong>（<em>Internet Layer</em>）上。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/12.jpg" alt="MAC"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p><p>将IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>配合<strong>子网掩码</strong>，可以将一个网络号同时给多个主机使用，子网掩码则用于计算 网络号和主机号。</p><p>如10.100.122.0&#x2F;24后面的<code>/24</code>表示就是 <code>255.255.255.0</code>，将IP地址与子网掩码按位与，得到网络号，与子网掩码的取反按位与，则得到主机号。</p><p>寻找目标地址的过程，就是一个寻找网络-&gt;寻找主机的过程。</p><p><strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网路接口层"><a href="#网路接口层" class="headerlink" title="网路接口层"></a>网路接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="网络接口层"></p><p>网络层实现了信息在互联网上传输的功能，而要将信息传输到互联网，我们还需要经过网络接口层。</p><p>网络接口层的功能主要体现在以太网技术上，即通过局域网把网络包发送到目的地。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务。个人理解是在数据的传输中，数据包会经过很多交换机，交换机会将数据包解包至网络接口层，然后再封装，发送。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>使用 MAC 地址，我们可以标识网络上的设备，实现在以太网、WiFi 这样的底层网络上发送原始数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="tcpip参考模型"></p><p>封装格式：</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.png" alt="封装"></p><div class="note note-info">            <p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>          </div><blockquote><p>应用层负责将应用产生的数据传递给传输层，将从传输层接受到的数据组合，返回给应用。</p><p>传输层负责将从应用层接受到的数据包传递给网络层，这个过程会携带应用端口</p><p>网络层负责将从传输层接受到的数据包发送到网络，这个过程会携带IP地址（网络号+主机号&#x2F;子网掩码）</p><p>网络接口层负责将网络层的数据通过以太网技术的方式发送到数据库</p></blockquote><h1 id="二、浏览器请求过程"><a href="#二、浏览器请求过程" class="headerlink" title="二、浏览器请求过程"></a>二、浏览器请求过程</h1><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/2.webp"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-解析URL"><a href="#1-解析URL" class="headerlink" title="1.解析URL"></a>1.解析URL</h3><p>浏览器先解析URL地址，然后生成给WEB服务器的信息。<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/3.webp"><br>如果省略资源路径，则会访问Web服务根目录的<code>index.html</code>或<code>default.html</code></p><h3 id="2-生成HTTP请求信息"><a href="#2-生成HTTP请求信息" class="headerlink" title="2.生成HTTP请求信息"></a>2.生成HTTP请求信息</h3><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/4.webp"></p><div class="note note-primary">            <p>HTTP报文三要素：</p><ul><li>请求报文：请求行(req)+请求头(head)+请求体(body)</li><li>响应报文：状态行(status)+消息头(head)+消息体(body)</li></ul>          </div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>消息发送前需要<strong>查询服务器域名对应的 IP 地址</strong><br>因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DNS是一种服务器，其专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>，这与中文相反。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。即<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><p>所以实际上是 .  –&gt; .com –&gt;server<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/5.webp"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><p>也就是说，查询域名IP时：</p><ol><li>客户端只会向最近的本地DNS服务器请求ip地址。</li><li>本地DNS服务器若记录了ip地址，则直接返回，若没有记录，则进行以下操作。</li><li>本地DNS向根DNS服务器请求ip地址，根DNS将.com的DNS服务器给本地DNS服务器。</li><li>本地DNS服务器再向.com的DNS（顶级域名服务器）请求ip地址，顶级域名服务器将<a href="http://www.server.com的权威/">www.server.com的权威</a> DNS 服务器给本地DNS服务器。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接。</li></ol><div class="note note-warning">            <p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明目标服务器的位置。</p>          </div><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/6.webp"></p><blockquote><p>DNS 域名解析的过程是一个<strong>只指路不带路</strong>的过程。</p></blockquote><div class="note note-primary">            <p>当然，浏览器、操作系统、hosts文件都有缓存，在这些地方都找不到时才会向本地DNS服务器发请求。</p>          </div><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><div class="note note-primary">            <p>注意这里开始进入操作系统层面。</p>          </div><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/7.webp"></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。</p><p>协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><p>进入协议栈后，就依靠各层协议一步一步完成数据传输。 </p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>HTTP 是<strong>基于 TCP 协议</strong>传输的，TCP报文格式如下：<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/8.webp" alt="TCP报文"></p><p>理解：</p><ul><li><strong>源端口号</strong>和<strong>目标端口</strong>号：这是与应用层交互的关键识别信息。</li><li>包<strong>序</strong>号，防止乱序</li><li><strong>确认号</strong>，防止丢包</li><li><strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>：TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，从而实现<strong>拥塞控制</strong>：即控制发送的速度。</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓的握手就是使通讯双方维护一个状态机。<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"></p><blockquote><p>SYN指<strong>SYN：同步序列编号</strong>（ Synchronize Sequence Numbers ）<br>ACK指<strong>ACK：确认字符</strong>（Acknowledge character）</p></blockquote><div class="note note-success">            <p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>          </div><div class="note note-primary">            <p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>          </div><h3 id="TCP数据分割"><a href="#TCP数据分割" class="headerlink" title="TCP数据分割"></a>TCP数据分割</h3><p>若HTTP请求报文较长，超过了 <code>MSS</code> 的长度则需要拆解。<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/11.webp"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/12.webp"></p><p>拆分出来的每一块数据都会被放进单独的网络包中，分别加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>todo:<br>TCP报文生成<br><a href="https://cloud.tencent.com/developer/article/1875682#:~:text=%E5%BD%93%E8%B7%AF%E7%94%B1%E5%99%A8%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90%E5%87%BAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%20%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%20%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1%E8%A1%A8%EF%BC%8C%E4%BE%9D%E6%8D%AE,%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3%E6%88%96%E8%80%85%E5%87%BA%E6%8E%A5%E5%8F%A3%E5%B0%86%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91%E5%87%BA%E5%8E%BB%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%20%E8%B7%AF%E7%94%B1%20%E3%80%82">https://cloud.tencent.com/developer/article/1875682#:~:text=%E5%BD%93%E8%B7%AF%E7%94%B1%E5%99%A8%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90%E5%87%BAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%20%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%20%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1%E8%A1%A8%EF%BC%8C%E4%BE%9D%E6%8D%AE,%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3%E6%88%96%E8%80%85%E5%87%BA%E6%8E%A5%E5%8F%A3%E5%B0%86%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91%E5%87%BA%E5%8E%BB%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%20%E8%B7%AF%E7%94%B1%20%E3%80%82</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIwOTcyNjA3Mw==&mid=2247500748&idx=1&sn=08b9a324a2c33a6c80e26a7711cfef96&chksm=976dfcdaa01a75ccc0cf85569f92ed3d0597bfaeac736a3a3114e0d34fac821b1c0458269fb9&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIwOTcyNjA3Mw==&amp;mid=2247500748&amp;idx=1&amp;sn=08b9a324a2c33a6c80e26a7711cfef96&amp;chksm=976dfcdaa01a75ccc0cf85569f92ed3d0597bfaeac736a3a3114e0d34fac821b1c0458269fb9&amp;scene=21#wechat_redirect</a><br><a href="https://www.cnblogs.com/mefj/p/14543955.html#:~:text=%E4%B8%80%E3%80%81%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B6%E4%B8%AD%E6%8E%A9%E7%A0%81%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E7%94%B1%20%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%B8%8B%E5%BD%93%E6%9C%89%2F24%E5%92%8C%2F25%E4%BD%8D%E7%9A%84%E6%8E%A9%E7%A0%81%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%EF%BC%8C%E9%80%89%E6%8B%A9%2F25%E7%9A%84%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%A3E0%E3%80%82%20%E4%BA%8C%E3%80%81%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB,%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E6%8E%A9%E7%A0%81%E4%B8%80%E6%A0%B7%20%28%E8%B7%B3%E8%BF%87%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%29%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%E4%B8%80%E6%A0%B7%20%28%E7%9B%B8%E5%90%8C%E5%8D%8F%E8%AE%AE%2C%E8%BF%99%E6%97%B6%E5%80%99%E8%B7%B3%E8%BF%87%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%29%E3%80%82%20%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%86%85%E5%88%A4%E5%BA%A6%E9%87%8F%E5%80%BC%20%E6%80%BB%E7%BB%93%EF%BC%9A%20%E4%BD%9C%E8%80%85%EF%BC%9A%20%E8%BF%90%E7%BB%B4%E5%AF%86%E7%A0%81">https://www.cnblogs.com/mefj/p/14543955.html#:~:text=%E4%B8%80%E3%80%81%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B6%E4%B8%AD%E6%8E%A9%E7%A0%81%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E7%94%B1%20%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%B8%8B%E5%BD%93%E6%9C%89%2F24%E5%92%8C%2F25%E4%BD%8D%E7%9A%84%E6%8E%A9%E7%A0%81%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%EF%BC%8C%E9%80%89%E6%8B%A9%2F25%E7%9A%84%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%A3E0%E3%80%82%20%E4%BA%8C%E3%80%81%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB,%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E6%8E%A9%E7%A0%81%E4%B8%80%E6%A0%B7%20%28%E8%B7%B3%E8%BF%87%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%29%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%E4%B8%80%E6%A0%B7%20%28%E7%9B%B8%E5%90%8C%E5%8D%8F%E8%AE%AE%2C%E8%BF%99%E6%97%B6%E5%80%99%E8%B7%B3%E8%BF%87%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%29%E3%80%82%20%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%86%85%E5%88%A4%E5%BA%A6%E9%87%8F%E5%80%BC%20%E6%80%BB%E7%BB%93%EF%BC%9A%20%E4%BD%9C%E8%80%85%EF%BC%9A%20%E8%BF%90%E7%BB%B4%E5%AF%86%E7%A0%81</a><br><a href="https://bbs.huaweicloud.com/blogs/359221">https://bbs.huaweicloud.com/blogs/359221</a><br><a href="https://zhuanlan.zhihu.com/p/61805945">https://zhuanlan.zhihu.com/p/61805945</a><br><a href="https://www.cnblogs.com/liyuanhong/p/13585654.html">https://www.cnblogs.com/liyuanhong/p/13585654.html</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/">小林coding-图解网络</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyFirstBlog</title>
    <link href="/2022/12/09/MyFirstBlog/"/>
    <url>/2022/12/09/MyFirstBlog/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h1><p>这是我的第一个条博文，为了建立这个博客我花费了整整一晚上。<br>有时候真希望我是一个好的前端程序员，因为我看不懂这些layout的设置:)<br>下面测试一下功能</p><h1 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h1><blockquote><p>引用</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>Hello.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是反斜杠方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><a href="https://hexo.bootcss.com/docs/tag-plugins.html" title="" target="">引用网址</a><h1 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h1><img src="/2022/12/09/MyFirstBlog/test.png" class=""><p>或使用markdown标记相对资源</p><p><img src="/2022/12/09/MyFirstBlog/test.png" alt="测试图片"></p><h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><h1 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h1><span class="label label-primary">Label</span>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
