<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java NIO</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/</url>
    
    <content type="html"><![CDATA[<h1 id="一、BIO"><a href="#一、BIO" class="headerlink" title="一、BIO"></a>一、BIO</h1><p><code>BIO</code>就是: <code>blocking IO</code></p><p><em>阻塞IO 和 非阻塞IO</em><br>这两个概念是<code>程序级别</code>的，主要描述程序请求操作系统IO操作后，如果IO资源没准备好，该如何响应程序的问题：</p><ul><li>前者阻塞等待。</li><li>后者轮询。</li></ul><p><em>同步IO 和 非同步IO</em><br>这两个概念是<code>操作系统级别</code>的，主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: </p><ul><li>前者不响应；</li><li>后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</li></ul><h2 id="BIO通信方式"><a href="#BIO通信方式" class="headerlink" title="BIO通信方式"></a>BIO通信方式</h2><p><em>基本模式：请求-等待-响应</em><br>问题：同一时间，服务器只能接受来自于一个客户端的请求信息；<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213151111.png"></p><p><em>改进模式：多线程方式 - 伪异步方式</em><br>问题：</p><ul><li>操作系统通知accept()的方式还是单个的，多线程只体现在处理请求上，无法体现在接受请求上。</li><li>操作系统线程有限、创建线程造成大量消耗、连接不关闭占用资源。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213151131.png"></li></ul><h2 id="BIO主要问题"><a href="#BIO主要问题" class="headerlink" title="BIO主要问题"></a>BIO主要问题</h2><p>阻塞模式下：</p><ul><li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停（闲置）</li><li>SocketChannel.read 会在没有数据可读时让线程暂停</li></ul><p>线程：</p><ul><li>使用多线程时，过多的连接数也会导致OOM，这点NIO也无法避免。</li></ul><p><em>原生代码</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    log.debug(<span class="hljs-string">&quot;connecting...&quot;</span>);<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>    log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>    channels.add(sc);<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        log.debug(<span class="hljs-string">&quot;before read... &#123;&#125;&quot;</span>, channel);<br>        channel.read(buffer); <span class="hljs-comment">// 阻塞方法，线程停止运行</span><br>        buffer.flip();<br>        debugRead(buffer);<br>        buffer.clear();<br>        log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>结论</em><br>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。</p><h2 id="NIO对问题的改进"><a href="#NIO对问题的改进" class="headerlink" title="NIO对问题的改进"></a>NIO对问题的改进</h2><p>非阻塞模式下：</p><ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>SocketChannel.read 在没有数据可读时，会返回 0。</li></ul><p>线程：</p><ul><li>非阻塞模式下，即使没有连接建立和可读数据，线程仍然在不断运行。</li><li>数据复制过程中，线程实际还是阻塞的（这是AIO 改进的地方）。</li></ul><p><em>原生代码</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>ssc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span><br>    <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>        sc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br>        channels.add(sc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span><br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            debugRead(buffer);<br>            buffer.clear();<br>            log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>配合Selector，可以完成对多个Chaannel读写事件的控制，称之多路复用（多路复用仅针对网络 IO）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BIO就是<strong>阻塞IO模型</strong>，NIO就是<strong>非阻塞IO模型</strong>，通过使用Selector组件管理channel，可以让Java实现原生的<strong>IO多路复用</strong>。</p><h1 id="二、NIO"><a href="#二、NIO" class="headerlink" title="二、NIO"></a>二、NIO</h1><p><code>NIO</code>(non blocking io)是库是在 JDK 1.4 中引入的包，其提供了<strong>高速的、面向块</strong>的 I&#x2F;O。</p><p>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流(字节)的方式处理数据，而 NIO 以块（数据块）的方式处理数据。</p><blockquote><p>本包中的组件可以用来实现中的Reactor模型。</p></blockquote><h2 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>buffer 用来缓冲读写数据，必须通过读写buffer来实现对channel的读写。缓冲区实质上是一个<strong>数组</strong>，常见的buffer有：</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel 类似于 stream，它就是读写数据的<strong>双向通道</strong>，常见的channel有：</p><ul><li>FileChannel: 从文件中读写数据；</li><li>DatagramChannel: 通过 UDP 读写网络中数据；</li><li>SocketChannel: 通过 TCP 读写网络中数据；</li><li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><p><strong>channel 比 stream 更为底层，且是双向的。</strong></p><blockquote><p>只有继承了SelectableChannel类的子类Channel才能被注册。</p></blockquote><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件。适合连接数特别多，但流量低的场景。<br><img src="/1676302539083.png"></p><h2 id="Buffer-1"><a href="#Buffer-1" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer有两种工作模式: 写模式和读模式：</p><ul><li>调用<code>flip()</code>进入读模式，应用程序只能从Buffer中读取数据，不能进行写操作。</li><li>调用<code>clear()</code>或<code>compact()</code>进入写模式，应用程序是可以进行读、写操作的。</li></ul><blockquote><p>写模式下可能会出现脏读的情况。所以一旦决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p></blockquote><h4 id="Buffer结构"><a href="#Buffer结构" class="headerlink" title="Buffer结构"></a>Buffer结构</h4><ul><li>capacity: 最大容量；</li><li>position: 当前指针；</li><li>limit: 可读&#x2F;写的最大指针。</li></ul><blockquote><ul><li>clear()会把buffer清空。</li><li>compact()会把未读完的部分压缩到前面。</li></ul></blockquote><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213162200.png"></p><h3 id="Buffer操作"><a href="#Buffer操作" class="headerlink" title="Buffer操作"></a>Buffer操作</h3><p>buffer是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成buffer</span><br><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">//写数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br>buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br><span class="hljs-comment">//读数据</span><br><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br><span class="hljs-comment">//position标记与复位</span><br>buf.mark()<br>buf.reset()<br><span class="hljs-comment">//字符串转buffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-comment">//buffer转字符串</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> buffer3.toString();<br></code></pre></td></tr></table></figure><h2 id="Channel-1"><a href="#Channel-1" class="headerlink" title="Channel"></a>Channel</h2><h3 id="Channel操作"><a href="#Channel操作" class="headerlink" title="Channel操作"></a>Channel操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//channel常常不能直接获取，需要通过stream获取</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> FileInputStream.getChannel() <span class="hljs-comment">//只能读</span><br><br><span class="hljs-comment">//读取</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> channel.read(buffer);<br><span class="hljs-comment">//写入，应该循环保证全部写入</span><br><span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;<br>channel.write(buffer);<br>&#125;<br><span class="hljs-comment">//关闭，必须关闭，也可调用stream的close来间接关闭</span><br>channel.close();<br></code></pre></td></tr></table></figure><h2 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213152218.png"></p><blockquote><p>注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p></blockquote><p>功能：</p><ul><li>事件订阅和Channel管理</li><li>轮询代理</li><li>实现不同操作系统的支持</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建选择器</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//创建Channel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open(); ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//注册Channel到selector上</span><br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br><span class="hljs-comment">//监听事件，阻塞等待事件到达</span><br>selector.select();<br><br><span class="hljs-comment">//获取到达的事件，SelectionKey是每个Channel是否到达的标志对象。</span><br>Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br><span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    keyIterator.remove();<br>&#125;<br><br><span class="hljs-comment">//一般会循环</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>    <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        keyIterator.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个NIO服务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> ssChannel.socket();<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>        serverSocket.bind(address);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            selector.select();<br>            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>            <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>                <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel1</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.channel();<br>                    <span class="hljs-comment">// 服务器会为每个新连接创建一个 SocketChannel</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> ssChannel1.accept();<br>                    sChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 这个新连接主要用于从客户端读取数据</span><br>                    sChannel.register(selector, SelectionKey.OP_READ);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                    System.out.println(readDataFromSocketChannel(sChannel));<br>                    sChannel.close();<br>                &#125;<br>                keyIterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readDataFromSocketChannel</span><span class="hljs-params">(SocketChannel sChannel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            buffer.clear();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sChannel.read(buffer);<br>            <span class="hljs-keyword">if</span> (n == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            buffer.flip();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> buffer.limit();<br>            <span class="hljs-type">char</span>[] dst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[limit];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; limit; i++) &#123;<br>                dst[i] = (<span class="hljs-type">char</span>) buffer.get(i);<br>            &#125;<br>            data.append(dst);<br>            buffer.clear();<br>        &#125;<br>        <span class="hljs-keyword">return</span> data.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//NIO客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>        out.write(s.getBytes());<br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I&#x2F;O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I&#x2F;O 快得多。<br>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mbb</span> <span class="hljs-operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><h1 id="六、IO多路复用"><a href="#六、IO多路复用" class="headerlink" title="六、IO多路复用"></a>六、IO多路复用</h1><h2 id="典型的多路复用IO实现"><a href="#典型的多路复用IO实现" class="headerlink" title="典型的多路复用IO实现"></a>典型的多路复用IO实现</h2><p>目前流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>：</p><table><thead><tr><th>IO模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA支持情况</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows&#x2F;Linux</td><td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>Linux</td><td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td></tr><tr><td>epoll</td><td>高</td><td>Reactor&#x2F;Proactor</td><td>Linux</td><td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>Linux</td><td>目前JAVA的版本不支持</td></tr></tbody></table><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><h3 id="传统IO模型"><a href="#传统IO模型" class="headerlink" title="传统IO模型"></a>传统IO模型</h3><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213154142.png"></p><h3 id="Reactor事件驱动模型"><a href="#Reactor事件驱动模型" class="headerlink" title="Reactor事件驱动模型"></a>Reactor事件驱动模型</h3><p><strong>同步I&#x2F;O</strong><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213154156.png"><br>有四个角色：客户端连接，Reactor，Acceptor和Handler。</p><ul><li>Acceptor会不断地接收客户端的连接，然后将接收到的连接交由Reactor进行分发。</li><li>由具体的Handler进行处理。</li></ul><p>改进后的Reactor模型相对于传统的IO模型主要有如下优点：</p><ul><li>Reactor模型是以事件进行驱动的，其不仅可接受连接、读、写，还可以对业务进行拆分。</li><li>异步非阻塞模型。</li></ul><h4 id="业务处理与IO分离"><a href="#业务处理与IO分离" class="headerlink" title="业务处理与IO分离"></a>业务处理与IO分离</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213154452.png"></p><h4 id="并发读写"><a href="#并发读写" class="headerlink" title="并发读写"></a>并发读写</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213154633.png"><br>Reactor拆分为了mainReactor和subReactor：</p><ul><li>mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。</li><li>subReactor则是使用一个线程池来支撑的，其读写能力将会随着线程数的增多而大大增加。</li></ul><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p>Reator负责监听端口，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reactor</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    serverSocket = ServerSocketChannel.open();  <span class="hljs-comment">// 创建服务端的ServerSocketChannel</span><br>    serverSocket.configureBlocking(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 设置为非阻塞模式</span><br>    selector = Selector.open();  <span class="hljs-comment">// 创建一个Selector多路复用器</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);<br>    serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));  <span class="hljs-comment">// 绑定服务端端口</span><br>    key.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Acceptor</span>(serverSocket));  <span class="hljs-comment">// 为服务端Channel绑定一个Acceptor</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        selector.select();  <span class="hljs-comment">// 服务端使用一个线程不断等待客户端的连接到达</span><br>        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-comment">//获取到连接，则将它交付给Acceptor</span><br>          dispatch(iterator.next());  <span class="hljs-comment">// 监听到客户端连接事件后将其分发给Acceptor</span><br>          iterator.remove();<br>        &#125;<br><br>        selector.selectNow();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 这里的attachement也即前面为服务端Channel绑定的Acceptor，调用其run()方法进行</span><br>    <span class="hljs-comment">// 客户端连接的获取，并且进行分发</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> (Runnable) key.attachment();<br>    attachment.run();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Acceptor负责获取连接并分发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">20</span>);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverSocket)</span> &#123;<br>    <span class="hljs-built_in">this</span>.serverSocket = serverSocket;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> serverSocket.accept();  <span class="hljs-comment">// 获取客户端连接</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != channel) &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(channel));  <span class="hljs-comment">// 将客户端连接交由线程池处理</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Selector selector;<br>  <span class="hljs-comment">//有一个私有客户端连接</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel channel;<br>  <span class="hljs-keyword">private</span> SelectionKey key;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">//线程池创建Handler</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(SocketChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-built_in">this</span>.channel = channel;<br>    channel.configureBlocking(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 设置客户端连接为非阻塞模式</span><br>    selector = Selector.open();  <span class="hljs-comment">// 为客户端创建一个新的多路复用器</span><br>    key = channel.register(selector, SelectionKey.OP_READ);  <span class="hljs-comment">// 注册客户端Channel的读事件</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (selector.isOpen() &amp;&amp; channel.isOpen()) &#123;<br>        Set&lt;SelectionKey&gt; keys = select();  <span class="hljs-comment">// 等待客户端事件发生</span><br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>          <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>          iterator.remove();<br>          <span class="hljs-comment">// 如果当前是读事件，则读取数据</span><br>          <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            read(key);<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>           <span class="hljs-comment">// 如果当前是写事件，则写入数据</span><br>            write(key);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这里处理的主要目的是处理Jdk的一个bug，该bug会导致Selector被意外触发，但是实际上没有任何事件到达，此时的处理方式是新建一个Selector，然后重新将当前Channel注册到该Selector上</span><br>  <span class="hljs-keyword">private</span> Set&lt;SelectionKey&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    <span class="hljs-keyword">if</span> (keys.isEmpty()) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> key.interestOps();<br>      selector = Selector.open();<br>      key = channel.register(selector, interestOps);<br>      <span class="hljs-keyword">return</span> select();<br>    &#125;<br>    <span class="hljs-keyword">return</span> keys;<br>  &#125;<br><br>  <span class="hljs-comment">// 读取客户端发送的数据</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    channel.read(input);<br>    <span class="hljs-keyword">if</span> (input.position() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    input.flip();<br>    process();  <span class="hljs-comment">// 对读取的数据进行业务处理</span><br>    input.clear();<br>    key.interestOps(SelectionKey.OP_WRITE);  <span class="hljs-comment">// 读取完成后监听写入事件</span><br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    output.flip();<br>    <span class="hljs-keyword">if</span> (channel.isOpen()) &#123;<br>      channel.write(output);  <span class="hljs-comment">// 当有写入事件时，将业务处理的结果写入到客户端Channel中</span><br>      key.channel();<br>      channel.close();<br>      output.clear();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-comment">// 进行业务处理，并且获取处理结果。本质上，基于Reactor模型，如果这里成为处理瓶颈，则直接将其处理过程放入线程池即可，并且使用一个Future获取处理结果，最后写入客户端Channel</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[input.remaining()];<br>    input.get(bytes);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, CharsetUtil.UTF_8);<br>    System.out.println(<span class="hljs-string">&quot;receive message from client: \n&quot;</span> + message);<br><br>    output.put(<span class="hljs-string">&quot;hello client&quot;</span>.getBytes());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h2><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213161940.png"><br><strong>异步I&#x2F;O</strong>，与Reactor类似，但编程复杂，不完善，目前高并发编程都是以Reactor模型为主。</p><h1 id="七、AIO"><a href="#七、AIO" class="headerlink" title="七、AIO"></a>七、AIO</h1><p>异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。</p><h2 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h2><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213174047.png"></p><ul><li>JAVA AIO框架在windows下使用windows IOCP技术</li><li>Linux下使用epoll多路复用IO技术模拟异步IO</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketServer</span> &#123;<br><span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        BasicConfigurator.configure();<br>    &#125;<br><span class="hljs-comment">// 信号对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">waitObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 对于使用的线程池技术:</span><br><span class="hljs-comment">         * 1、Executors是线程池生成工具，通过这个工具我们可以很轻松的生成“固定大小的线程池”、“调度池”、“可伸缩线程数量的池”。具体请看API Doc</span><br><span class="hljs-comment">         * 2、当然您也可以通过ThreadPoolExecutor直接生成池。</span><br><span class="hljs-comment">         * 3、这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池(最好不要混用)</span><br><span class="hljs-comment">         * 4、您也可以不使用线程池(不推荐)，如果决定不使用线程池，直接AsynchronousServerSocketChannel.open()就行了。</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//为线程池组创建异步管道组</span><br>        <span class="hljs-type">AsynchronousChannelGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> AsynchronousChannelGroup.withThreadPool(threadPool);<br>        <span class="hljs-comment">//使用管道组做参数创建服务socket</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open(group);<br>        <span class="hljs-comment">//设置要监听的端口“0.0.0.0”代表本机所有IP设备</span><br>        serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">83</span>));<br>        <span class="hljs-comment">//为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听</span><br>        <span class="hljs-comment">//并不包括为 随后客户端和服务器 socketchannel通道注册的监听</span><br>        serverSocket.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocketChannelHandle</span>(serverSocket));<br><br>        <span class="hljs-comment">//等待，以便观察现象(这个和要讲解的原理本身没有任何关系，只是为了保证守护线程不会退出)</span><br>        <span class="hljs-keyword">synchronized</span>(waitObject) &#123;<br>            waitObject.wait();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerSocketChannelHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LogFactory.getLog(ServerSocketChannelHandle.class);<br><span class="hljs-comment">//每个Handle都持有serverSocketChannel</span><br>    <span class="hljs-keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverSocketChannel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerSocketChannelHandle</span><span class="hljs-params">(AsynchronousServerSocketChannel serverSocketChannel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverSocketChannel = serverSocketChannel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。</span><br><span class="hljs-comment">     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel socketChannel, Void attachment)</span> &#123;<br>        ServerSocketChannelHandle.LOGGER.info(<span class="hljs-string">&quot;completed(AsynchronousSocketChannel result, ByteBuffer attachment)&quot;</span>);<br>        <span class="hljs-comment">//每次都要重新注册监听(一次注册，一次响应)，但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件</span><br>        <span class="hljs-built_in">this</span>.serverSocketChannel.accept(attachment, <span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-comment">//为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序</span><br>        <span class="hljs-comment">//在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringbuffer对象作为一个“附件”依附在这个channel上</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">readBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">50</span>);<br>        socketChannel.read(readBuffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketChannelReadHandle</span>(socketChannel , readBuffer));<br>    &#125;<br><br>    <span class="hljs-comment">/* (non-Javadoc)</span><br><span class="hljs-comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Void attachment)</span> &#123;<br>        ServerSocketChannelHandle.LOGGER.info(<span class="hljs-string">&quot;failed(Throwable exc, ByteBuffer attachment)&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 负责对每一个socketChannel的数据获取事件进行监听。&lt;p&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 重要的说明: 一个socketchannel都会有一个独立工作的SocketChannelReadHandle对象(CompletionHandler接口的实现)，</span><br><span class="hljs-comment"> * 其中又都将独享一个“文件状态标示”对象FileDescriptor、</span><br><span class="hljs-comment"> * 一个独立的由程序员定义的Buffer缓存(这里我们使用的是ByteBuffer)、</span><br><span class="hljs-comment"> * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。&lt;p&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 但是最重要的，用于生成channel的对象: AsynchronousChannelProvider是单例模式，无论在哪组socketchannel，</span><br><span class="hljs-comment"> * 对是一个对象引用(但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinwenjie</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketChannelReadHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, StringBuffer&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LogFactory.getLog(SocketChannelReadHandle.class);<br><br>    <span class="hljs-keyword">private</span> AsynchronousSocketChannel socketChannel;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 专门用于进行这个通道数据缓存操作的ByteBuffer&lt;br&gt;</span><br><span class="hljs-comment">     * 当然，您也可以作为CompletionHandler的attachment形式传入。&lt;br&gt;</span><br><span class="hljs-comment">     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的Stringbuffer了。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ByteBuffer byteBuffer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SocketChannelReadHandle</span><span class="hljs-params">(AsynchronousSocketChannel socketChannel , ByteBuffer byteBuffer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socketChannel = socketChannel;<br>        <span class="hljs-built_in">this</span>.byteBuffer = byteBuffer;<br>    &#125;<br><br>    <span class="hljs-comment">/* (non-Javadoc)</span><br><span class="hljs-comment">     * @see java.nio.channels.CompletionHandler#completed(java.lang.Object, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, StringBuffer historyContext)</span> &#123;<br>        <span class="hljs-comment">//如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了</span><br>        <span class="hljs-keyword">if</span>(result == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.socketChannel.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                SocketChannelReadHandle.LOGGER.error(e);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度</span><br><span class="hljs-comment">         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，</span><br><span class="hljs-comment">         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理(做成了多次通知)</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-built_in">this</span>.byteBuffer.flip();<br>        <span class="hljs-type">byte</span>[] contexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">this</span>.byteBuffer.get(contexts, <span class="hljs-number">0</span>, result);<br>        <span class="hljs-built_in">this</span>.byteBuffer.clear();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">nowContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(contexts , <span class="hljs-number">0</span> , result , <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            historyContext.append(nowContent);<br>            SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;================目前的传输结果: &quot;</span> + historyContext);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            SocketChannelReadHandle.LOGGER.error(e);<br>        &#125;<br><br>        <span class="hljs-comment">//如果条件成立，说明还没有接收到“结束标记”</span><br>        <span class="hljs-keyword">if</span>(historyContext.indexOf(<span class="hljs-string">&quot;over&quot;</span>) == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//=========================================================================</span><br>        <span class="hljs-comment">//          和上篇文章的代码相同，我们以“over”符号作为客户端完整信息的标记</span><br>        <span class="hljs-comment">//=========================================================================</span><br>        SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;=======收到完整信息，开始处理业务=========&quot;</span>);<br>        historyContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br>        <span class="hljs-comment">//还要继续监听(一次监听一次通知)</span><br>        <span class="hljs-built_in">this</span>.socketChannel.read(<span class="hljs-built_in">this</span>.byteBuffer, historyContext, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* (non-Javadoc)</span><br><span class="hljs-comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, StringBuffer historyContext)</span> &#123;<br>        SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;=====发现客户端异常关闭，服务器将关闭TCP通道&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.socketChannel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            SocketChannelReadHandle.LOGGER.error(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七、AIO-1"><a href="#七、AIO-1" class="headerlink" title="七、AIO"></a>七、AIO</h1><p>异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。</p><h2 id="Java-AIO-1"><a href="#Java-AIO-1" class="headerlink" title="Java AIO"></a>Java AIO</h2><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20NIO/Pasted-image-20230213174047.png"></p><ul><li>JAVA AIO框架在windows下使用windows IOCP技术</li><li>Linux下使用epoll多路复用IO技术模拟异步IO</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketServer</span> &#123;<br><span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        BasicConfigurator.configure();<br>    &#125;<br><span class="hljs-comment">// 信号对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">waitObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 对于使用的线程池技术:</span><br><span class="hljs-comment">         * 1、Executors是线程池生成工具，通过这个工具我们可以很轻松的生成“固定大小的线程池”、“调度池”、“可伸缩线程数量的池”。具体请看API Doc</span><br><span class="hljs-comment">         * 2、当然您也可以通过ThreadPoolExecutor直接生成池。</span><br><span class="hljs-comment">         * 3、这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池(最好不要混用)</span><br><span class="hljs-comment">         * 4、您也可以不使用线程池(不推荐)，如果决定不使用线程池，直接AsynchronousServerSocketChannel.open()就行了。</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//为线程池组创建异步管道组</span><br>        <span class="hljs-type">AsynchronousChannelGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> AsynchronousChannelGroup.withThreadPool(threadPool);<br>        <span class="hljs-comment">//使用管道组做参数创建服务socket</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open(group);<br>        <span class="hljs-comment">//设置要监听的端口“0.0.0.0”代表本机所有IP设备</span><br>        serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">83</span>));<br>        <span class="hljs-comment">//为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听</span><br>        <span class="hljs-comment">//并不包括为 随后客户端和服务器 socketchannel通道注册的监听</span><br>        serverSocket.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocketChannelHandle</span>(serverSocket));<br><br>        <span class="hljs-comment">//等待，以便观察现象(这个和要讲解的原理本身没有任何关系，只是为了保证守护线程不会退出)</span><br>        <span class="hljs-keyword">synchronized</span>(waitObject) &#123;<br>            waitObject.wait();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerSocketChannelHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LogFactory.getLog(ServerSocketChannelHandle.class);<br><span class="hljs-comment">//每个Handle都持有serverSocketChannel</span><br>    <span class="hljs-keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverSocketChannel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerSocketChannelHandle</span><span class="hljs-params">(AsynchronousServerSocketChannel serverSocketChannel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverSocketChannel = serverSocketChannel;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。</span><br><span class="hljs-comment">     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel socketChannel, Void attachment)</span> &#123;<br>        ServerSocketChannelHandle.LOGGER.info(<span class="hljs-string">&quot;completed(AsynchronousSocketChannel result, ByteBuffer attachment)&quot;</span>);<br>        <span class="hljs-comment">//每次都要重新注册监听(一次注册，一次响应)，但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件</span><br>        <span class="hljs-built_in">this</span>.serverSocketChannel.accept(attachment, <span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-comment">//为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序</span><br>        <span class="hljs-comment">//在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringbuffer对象作为一个“附件”依附在这个channel上</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">readBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">50</span>);<br>        socketChannel.read(readBuffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketChannelReadHandle</span>(socketChannel , readBuffer));<br>    &#125;<br><br>    <span class="hljs-comment">/* (non-Javadoc)</span><br><span class="hljs-comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Void attachment)</span> &#123;<br>        ServerSocketChannelHandle.LOGGER.info(<span class="hljs-string">&quot;failed(Throwable exc, ByteBuffer attachment)&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 负责对每一个socketChannel的数据获取事件进行监听。&lt;p&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 重要的说明: 一个socketchannel都会有一个独立工作的SocketChannelReadHandle对象(CompletionHandler接口的实现)，</span><br><span class="hljs-comment"> * 其中又都将独享一个“文件状态标示”对象FileDescriptor、</span><br><span class="hljs-comment"> * 一个独立的由程序员定义的Buffer缓存(这里我们使用的是ByteBuffer)、</span><br><span class="hljs-comment"> * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。&lt;p&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 但是最重要的，用于生成channel的对象: AsynchronousChannelProvider是单例模式，无论在哪组socketchannel，</span><br><span class="hljs-comment"> * 对是一个对象引用(但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yinwenjie</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketChannelReadHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, StringBuffer&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LogFactory.getLog(SocketChannelReadHandle.class);<br><br>    <span class="hljs-keyword">private</span> AsynchronousSocketChannel socketChannel;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 专门用于进行这个通道数据缓存操作的ByteBuffer&lt;br&gt;</span><br><span class="hljs-comment">     * 当然，您也可以作为CompletionHandler的attachment形式传入。&lt;br&gt;</span><br><span class="hljs-comment">     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的Stringbuffer了。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> ByteBuffer byteBuffer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SocketChannelReadHandle</span><span class="hljs-params">(AsynchronousSocketChannel socketChannel , ByteBuffer byteBuffer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socketChannel = socketChannel;<br>        <span class="hljs-built_in">this</span>.byteBuffer = byteBuffer;<br>    &#125;<br><br>    <span class="hljs-comment">/* (non-Javadoc)</span><br><span class="hljs-comment">     * @see java.nio.channels.CompletionHandler#completed(java.lang.Object, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, StringBuffer historyContext)</span> &#123;<br>        <span class="hljs-comment">//如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了</span><br>        <span class="hljs-keyword">if</span>(result == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">this</span>.socketChannel.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                SocketChannelReadHandle.LOGGER.error(e);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度</span><br><span class="hljs-comment">         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，</span><br><span class="hljs-comment">         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理(做成了多次通知)</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-built_in">this</span>.byteBuffer.flip();<br>        <span class="hljs-type">byte</span>[] contexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">this</span>.byteBuffer.get(contexts, <span class="hljs-number">0</span>, result);<br>        <span class="hljs-built_in">this</span>.byteBuffer.clear();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">nowContent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(contexts , <span class="hljs-number">0</span> , result , <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            historyContext.append(nowContent);<br>            SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;================目前的传输结果: &quot;</span> + historyContext);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            SocketChannelReadHandle.LOGGER.error(e);<br>        &#125;<br><br>        <span class="hljs-comment">//如果条件成立，说明还没有接收到“结束标记”</span><br>        <span class="hljs-keyword">if</span>(historyContext.indexOf(<span class="hljs-string">&quot;over&quot;</span>) == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//=========================================================================</span><br>        <span class="hljs-comment">//          和上篇文章的代码相同，我们以“over”符号作为客户端完整信息的标记</span><br>        <span class="hljs-comment">//=========================================================================</span><br>        SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;=======收到完整信息，开始处理业务=========&quot;</span>);<br>        historyContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br>        <span class="hljs-comment">//还要继续监听(一次监听一次通知)</span><br>        <span class="hljs-built_in">this</span>.socketChannel.read(<span class="hljs-built_in">this</span>.byteBuffer, historyContext, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* (non-Javadoc)</span><br><span class="hljs-comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, StringBuffer historyContext)</span> &#123;<br>        SocketChannelReadHandle.LOGGER.info(<span class="hljs-string">&quot;=====发现客户端异常关闭，服务器将关闭TCP通道&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.socketChannel.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            SocketChannelReadHandle.LOGGER.error(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java-IO基础"><a href="#一、Java-IO基础" class="headerlink" title="一、Java IO基础"></a>一、Java IO基础</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="按数据分类"><a href="#按数据分类" class="headerlink" title="按数据分类"></a>按数据分类</h3><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213142717.png"></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213142723.png"></p><h4 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h4><ul><li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同。)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li><li>字节流名往往是Stream，字符流名往往是Reader&#x2F;Writer。</li></ul><blockquote><p>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。<br>char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p></blockquote><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputStream转Reader</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamReader</span><span class="hljs-params">(InputStream in,String charsetName)</span>;<br><span class="hljs-comment">//OutputStream转Writer</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">OutputStreamWriter</span><span class="hljs-params">(OutputStream out,String charsetName)</span>;<br></code></pre></td></tr></table></figure><h3 id="按操作对象分类"><a href="#按操作对象分类" class="headerlink" title="按操作对象分类"></a>按操作对象分类</h3><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213142850.png"></p><blockquote><p>根据操作对象分类的流，很多都需要套接在其他stream上，实现功能增强（装饰者模式）</p></blockquote><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>流的创建使用了装饰者模式：<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213143013.png"><br>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)。<br><em>eg：</em><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213143042.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath); <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>这些流都需要显示的关闭。</p>          </div><h2 id="Java-IO常见类"><a href="#Java-IO常见类" class="headerlink" title="Java IO常见类"></a>Java IO常见类</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String pathname)</span>;<br><span class="hljs-comment">//以parent为父路径，child为子路径创建File文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String parent,String child)</span>;<br><span class="hljs-comment">//常量，根据操作系统动态提供文件的分隔符</span><br>File.sepatator<br><span class="hljs-comment">//获取路径</span><br>String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//获取名称</span><br>String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//获取长度</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span><br><span class="hljs-comment">//创建文件目录，若上层目录不存在则不创建</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//创建文件目录，若上层目录不存在仍创建</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>该对象包含记录指针，可标记当前读写位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打开文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file,String mode)</span><br><span class="hljs-comment">//获取文件指针</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getFilePointer</span><span class="hljs-params">()</span><br><span class="hljs-comment">//设置文件指针</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">seek</span><span class="hljs-params">(<span class="hljs-type">long</span> pos)</span>;<br></code></pre></td></tr></table></figure><h3 id="Path-x2F-Paths-x2F-Files"><a href="#Path-x2F-Paths-x2F-Files" class="headerlink" title="Path&#x2F;Paths&#x2F;Files"></a>Path&#x2F;Paths&#x2F;Files</h3><p>这几个类是在nio类中新增的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Paths</span><br><span class="hljs-comment">//目标文件不存在也可以获取</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(String url);<br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(URL url);<br><br><span class="hljs-comment">//Path</span><br><span class="hljs-comment">//Path转File</span><br>File <span class="hljs-title function_">toFile</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//...</span><br><br><span class="hljs-comment">//Files:</span><br><span class="hljs-comment">//文件复制</span><br>Path <span class="hljs-title function_">copy</span><span class="hljs-params">(Path src,Path dest,CopyOption ... how)</span>;<br></code></pre></td></tr></table></figure><h2 id="Java网络常见类"><a href="#Java网络常见类" class="headerlink" title="Java网络常见类"></a>Java网络常见类</h2><ul><li>InetAddress: 用于表示网络上的硬件资源，即 IP 地址；</li><li>URL: 统一资源定位符；</li><li>Sockets: 使用 TCP 协议实现网络通信；</li><li>Datagram: 使用 UDP 协议实现网络通信。</li></ul><blockquote><p>URI：统一资源标识符<br>URL：统一资源定位符<br>URN：统一资源命名<br>URL和URN都是一种URI。</p></blockquote><h1 id="二、Unix-IO-模型"><a href="#二、Unix-IO-模型" class="headerlink" title="二、Unix IO 模型"></a>二、Unix IO 模型</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一个输入操作通常包括两个阶段:</p><ol><li>等待数据准备</li><li>等待从内核向进程复制数据</li></ol><p>Unix 下有五种 I&#x2F;O 模型:</p><ul><li>阻塞式 I&#x2F;O（BIO）</li><li>非阻塞式 I&#x2F;O</li><li>I&#x2F;O 复用(select 和 poll)</li><li>信号驱动式 I&#x2F;O(SIGIO)</li><li>异步 I&#x2F;O(AIO)</li></ul><h3 id="阻塞式-I-x2F-O"><a href="#阻塞式-I-x2F-O" class="headerlink" title="阻塞式 I&#x2F;O"></a>阻塞式 I&#x2F;O</h3><p>应用调用<code>recvfrom</code>，被阻塞，直到数据复制到应用进程缓冲区中才返回。</p><blockquote><p>阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。</p></blockquote><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213143753.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213143808.png"></p><h3 id="非阻塞式-I-x2F-O"><a href="#非阻塞式-I-x2F-O" class="headerlink" title="非阻塞式 I&#x2F;O"></a>非阻塞式 I&#x2F;O</h3><p>应用进程不断的执行<code>recvfrom</code>来获知 I&#x2F;O 是否完成，这种方式称为轮询(<code>polling</code>)。</p><blockquote><p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213143817.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213143825.png"></p></blockquote><h3 id="I-x2F-O-复用（事件驱动IO）"><a href="#I-x2F-O-复用（事件驱动IO）" class="headerlink" title="I&#x2F;O 复用（事件驱动IO）"></a>I&#x2F;O 复用（事件驱动IO）</h3><ol><li>使用<code>select</code>或者<code>poll</code>等待数据（阻塞），并且可以<strong>等待多个套接字</strong>中的任何一个变为可读，当某一个套接字可读时返回。</li><li>使用 recvfrom 把数据从内核复制到进程中。</li></ol><blockquote><p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150145.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150153.png"></p></blockquote><h3 id="信号驱动-I-x2F-O"><a href="#信号驱动-I-x2F-O" class="headerlink" title="信号驱动 I&#x2F;O"></a>信号驱动 I&#x2F;O</h3><ol><li>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回(非阻塞)。</li><li>内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150246.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150259.png"></li></ol><h3 id="异步-I-x2F-O"><a href="#异步-I-x2F-O" class="headerlink" title="异步 I&#x2F;O"></a>异步 I&#x2F;O</h3><ol><li>应用进行 aio_read 系统调用立即返回。</li><li>内核会在所有操作完成之后向应用进程发送信号。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150315.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150321.png"></li></ol><h2 id="I-x2F-O模型比较"><a href="#I-x2F-O模型比较" class="headerlink" title="I&#x2F;O模型比较"></a>I&#x2F;O模型比较</h2><p>除了<code>异步I/O</code>，其他IO都是<code>同步I/O</code>，因为这些IO模型在<code>recvfrom</code>时肯定会阻塞。</p><h3 id="五大-I-x2F-O-模型比较"><a href="#五大-I-x2F-O-模型比较" class="headerlink" title="五大 I&#x2F;O 模型比较"></a>五大 I&#x2F;O 模型比较</h3><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Netty/Java%20IO/Pasted-image-20230213150509.png"></p><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><h3 id="epoll-IO复用的关键"><a href="#epoll-IO复用的关键" class="headerlink" title="epoll(IO复用的关键)"></a>epoll(IO复用的关键)</h3><p>epoll 的描述符事件有两种触发模式: LT(level trigger)和 ET(edge trigger)。<br>1）LT 模式<br>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件。<br>下次调用 epoll_wait() 会再次通知进程。<br>是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><p>2）ET 模式<br>当 epoll_wait() 检测到描述符事件到达时，必须通知进程处理事件。<br>下次再调用 epoll_wait() 时不会再得到事件到达的通知。<br>只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p><blockquote><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。</p></blockquote><p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于<strong>实时要求</strong>更高的场景，比如核反应堆的控制。<br>select 可移植性更好，几乎被所有主流平台所支持。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 没有最大描述符数量的限制.</p><ul><li>如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li><li>如果监控的描述符状态较少，则没必要使用epoll。</li></ul><blockquote><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Spring/Spring%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Spring/Spring%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring基础概念"><a href="#一、Spring基础概念" class="headerlink" title="一、Spring基础概念"></a>一、Spring基础概念</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><em>概念</em><br>控制反转指的是在程序中，原本需要我们手动创建的对象现在可以由 Spring 的 IoC 容器帮助创建和注入依赖对象，我们只需要告诉容器什么时候创建对象、创建什么对象，完全不用考虑对象是怎么创建出来的。</p><p><em>传统程序设计与 IoC 模式的区别</em><br>传统：用户主动创建对象并关联<br>IoC：只需通知IoC容器执行</p><p><em>介绍一下 Spring IoC 容器的初始化过程</em></p><ol><li><strong>Bean 的资源定位</strong>。</li><li><strong>BeanDefinition 的载入</strong>。将用户定义好的 Bean 表示成 IoC 容器内部的数据结构，而这个容器内部的数据结构就是 BeanDefinition；</li><li><strong>向 IoC 容器注册这些 BeanDefinition</strong>。这个注册过程就是将在 IoC 容器内部将 BeanDefinition 注入到一个 HashMap 中去的过程。</li></ol><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p><em>介绍一下依赖注入（DI）</em><br>依赖注入是控制反转的一种实现方式，指的是程序所依赖的组件在运行时会动态地加载到程序中。</p><p><em>依赖注入的方式有哪些</em></p><ol><li>构造器注入；</li><li>Setter 方法注入；</li><li>属性（p）命名空间或者构造器（c）命名空间注入。</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><em>介绍一下 AOP</em><br>面向切面编程是面向对象编程的补充，它将面向对象编程产生的各个业务模块所共同调用的部分封装起来，达到与主业务逻辑解耦的目的。<br>同时，AOP 可以在不改变原来的代码的情况下，实现对原有功能的增强。（代理模式，开闭原则）。</p><p><em>介绍一下 Spring AOP 中创建代理的方式</em><br>Spring AOP 就是基于动态代理的，Spring 中的 AOP 目前支持 JDK 动态代理和 Cglib 代理。</p><p><em>说一下 JDK 动态代理和 Cglib 代理的区别</em></p><ol><li>JDK 动态代理本质上是实现了被代理对象的接口，而 Cglib 本质上是继承了被代理对象，覆盖其中的方法；</li><li>JDK 动态代理只能对实现了接口的类生成代理，Cglib 则没有这个限制。但是 Cglib 因为使用继承实现，所以 Cglib 无法代理被 final 修饰的方法或类；</li><li>在调用代理方法上，JDK 动态代理是通过反射机制调用，Cglib 是通过 FastClass 机制直接调用。FastClass 简单的理解，就是使用 index 作为入参，可以直接定位到要调用的方法直接进行调用；</li><li>在性能上，JDK1.7 之前，由于使用了 FastClass 机制，Cglib 在执行效率上比 JDK 快，但是随着 JDK 动态代理的不断优化，从 JDK 1.7 开始，JDK 动态代理已经明显比 Cglib 更快了。</li></ol><p><em>说一下 Spring AOP 和 AspectJ AOP 的区别</em></p><ol><li>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强；</li><li>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)；</li><li>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单；</li><li>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ol><h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><p><em>什么是 Spring bean 容器</em></p><ol><li>bean 是对象，一个或者多个不限定；</li><li>bean 由 Spring 中一个叫 IoC 的东西管理；</li><li>我们的应用程序由一个个 bean 构成。</li></ol><p><em>将⼀个类声明为 Spring 的 bean 的注解有哪些</em></p><ul><li>@Component ：通⽤的注解，可标注任意类为 Spring 组件，如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注；</li><li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作；</li><li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑；</li><li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯。</li></ul><p><em>Spring bean 生命周期</em><br><img src="/Pasted%20image%2020230213135711.jpg"></p><p><em>bean 的作用域</em><br><img src="/Pasted%20image%2020230213135728.png"></p><p><em>Spring 中的单例 bean 的线程安全问题了解吗？</em><br>常见的有两种解决办法：</p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）；</li><li>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中。</li></ol><blockquote><p>只要求可见性的对象可以使用volatile+CAS，或者使用悲观锁完成。</p></blockquote><p><em>@Component 和 @Bean 的区别</em></p><ol><li>@Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法；</li><li>@Component 通常是通过类路径扫描来⾃动侦测并⾃动装配到 Spring 容器中；@Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean。</li><li>@Bean 注解⽐ Component 注解的⾃定义性更强，如第三方库。</li></ol><h2 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h2><p><em>Spring 管理事务的方式</em></p><ol><li>编程式事务，在代码中硬编码(不推荐使用)；</li><li>声明式事务，在配置文件中配置（推荐使用）；<ul><li>基于 XML 的声明式事务；</li><li>基于注解的声明式事务；</li></ul></li></ol><p><em>事务的实现原理</em><br>Spring 事务的底层实现主要使用的技术：AOP（动态代理） + ThreadLocal + try&#x2F;catch。</p><ul><li>动态代理：基本所有要进行逻辑增强的地方都会用到动态代理，AOP 底层也是通过动态代理实现；</li><li>ThreadLocal：主要用于线程间的资源隔离，以此实现不同线程可以使用不同的数据源、隔离级别等等；</li><li>try&#x2F;catch：最终是执行 commit 还是 rollback，是根据业务逻辑处理是否抛出异常来决定。</li></ul><p><img src="/Pasted%20image%2020230213140151.jpg"></p><p><em>Spring 事务中的隔离级别</em></p><ul><li>TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别；</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><p><em>Spring 事务中有哪几种事务传播行为</em><br><strong>支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；</li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><p><em>Spring 的事务隔离级别是如何做到和数据库不一致的</em><br>Spring 的事务隔离级别本质上还是通过数据库来控制的，具体是在执行事务前先执行命令修改数据库隔离级别：<br><code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED</code></p><h1 id="二、Spring-MVC"><a href="#二、Spring-MVC" class="headerlink" title="二、Spring MVC"></a>二、Spring MVC</h1><p><em>什么是 MVC</em><br><img src="/Pasted%20image%2020230213141252.jpg"><br>在 Spring MVC 下，我们⼀般把后端项⽬分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层。</p><p><em>SpringMVC 的核心入口类是什么</em><br>DispatchServlet。</p><p><em>SpringMVC 的控制器是不是单例模式？</em><br>是单例模式，所以在多线程访问的时候有线程安全问题，不过不能使用同步，因为会影响性能的，解决方案是在控制器里面不能写字段（只有方法）。</p><p><em>SpingMVC 中的控制器的注解一般用哪个，有没有别的注解可以替代</em><br>@Conntroller</p><p><em>@RequestMapping 注解用在类上面有什么作用</em><br>其用于类上，表示类中的所有请求与响应的方法都是以该地址作为父路径。</p><p><em>怎么样把某个请求映射到特定的方法上面</em><br>在方法上面加上注解 @RequestMapping，并且在这个注解里面写上要拦截的路径。</p><p><em>如果前台有很多个参数传入，并且这些参数都是一个对象的,那么怎么样快速得到这个对象</em><br>直接声明这个对象。</p><h1 id="三、MyBatis"><a href="#三、MyBatis" class="headerlink" title="三、MyBatis"></a>三、MyBatis</h1><p><em>说一说什么是 MyBatis</em><br>Mybatis 是一个半 ORM（对象关系映射）的持久层框架，它内部封装了JDBC、加载驱动、创建连接、创建 statement 等繁杂的过程，开发者开发时只需要关注如何编写 SQL 语句，可以严格控制 SQL 执行性能，灵活度高。</p><p><em>那什么是持久化</em><br>将程序数据在持久状态和瞬时状态间转换的机制，即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）的机制。</p><p><em>为什么说 MyBatis 是半自动的 ORM 映射工具</em></p><ul><li>Hibernate 属于全⾃动 ORM 映射⼯具，使⽤ Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全⾃动的。</li><li><strong>Mybatis 在查询关联对象或关联集合对象时，需要⼿动编写 sql 来完成，所以，称之为半⾃动 ORM 映射⼯具</strong>。</li></ul><p><em>#{} 和 ${} 的区别是什么</em><br><strong>#{} 是预编译处理，${} 是字符串替换</strong>。</p><p><em>MyBatis 的生命周期</em></p><ol><li>SqlSessionFactoryBuilder 通过配置文件生成 SqlSessionFactory，一旦创建完后，就可以销毁它；</li><li>SqlSessionFactory 在 MyBatis 中以单例模式存在，创建于程序开始，销毁于程序结束，类似于线程池；</li><li>sqlSession 类似于线程池中的一个线程，线程结束后就归还于线程池；</li><li>Mapper 是 SqlSession 创建的一个具体的业务，一旦处理完了这个业务，就可以销毁它。</li></ol><table><thead><tr><th>类名</th><th>作用域</th></tr></thead><tbody><tr><td>SqlSessionFactoryBuilder</td><td>方法作用域</td></tr><tr><td>SqlSessionFactory</td><td>全局作用域</td></tr><tr><td>SqlSession</td><td>方法作用域</td></tr><tr><td>Mapper</td><td>方法作用域</td></tr></tbody></table><p><em>Mybatis 是如何进行分页的？分页插件的原理是什么？</em></p><ol><li>使用 limit 进行分页；</li><li>使用 RowBounds 分页，这个属于逻辑分页，即实际上 sql 查询的是所有的数据，在业务层进行了分页而已，比较占用内存，而且数据更新不及时，可能会有一定的滞后性；</li><li>使用分页插件（jar 包）进行分页；</li></ol><p><em>说一说 MyBatis 的缓存</em><br>MyBatis 中默认定义了两级缓存：一级缓存和二级缓存。</p><ul><li>一级缓存，又称为本地缓存，是 SqlSession 级别的缓存，默认情况下是开启的；</li><li>二级缓存是基于 namespace 级别的缓存，则需要手动开启和配置。</li></ul><p><strong>查询缓存的顺序</strong>：二级缓存 → 一级缓存 → 数据库。</p><p><em>说一说 MyBatis 的一级缓存</em><br>与数据库同一次会话期间查询到的数据会放在一级缓存中，以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库。</p><p>一级缓存失效的四种情况：</p><ul><li>当 SqlSession 相同，两次查询中出现了增删改。</li><li>SqlSession 相同，但查询不同的东西。</li><li>SqlSession 不同时。</li><li>SqlSession 相同，手动清除一级缓存。</li></ul><p><em>说一说 MyBatis 的二级缓存</em><br>一级缓存当会话关闭后就会释放，所以我们需要一个这个情况下数据依然存在的缓存。<br><strong>不过查出的数据都会被默认先放在一级缓存中，只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中。</strong></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式七大原则"><a href="#一、设计模式七大原则" class="headerlink" title="一、设计模式七大原则"></a>一、设计模式七大原则</h1><p>开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。<br>单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。<br>依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。<br>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。<br>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。<br>迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。<br>合成复用原则：尽量使用组合(has-a)&#x2F;聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</p><div class="note note-primary">            <p>开单依接里迪合</p>          </div><h1 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h1><p><em>创建型模式</em>：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><em>结构型模式</em>：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><em>行为型模式</em>：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><div class="note note-primary">            <p>工抽单建原<br>适装代外桥组享<br>策模观迭责<br>命备状访中解</p>          </div><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>定义：</strong> 是确保某一个类只有一个实例，并且提供一个全局访问点。<br><strong>应用实例：</strong> 唯一序列号、web页面计数器</p><div class="note note-primary">            <p>若想实现线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>       &#125;;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">synchronized</span> (instance) &#123;<br>                           <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                                  instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                           &#125;<br>                     &#125;<br>              &#125;<br>              <span class="hljs-keyword">return</span> instance;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><em>简单工厂模式</em>：一个工厂类根据传入的参量决定创建出那一种产品类的实例。<br>问题在于类的创建依赖工厂，扩展类时也要修改工厂类，不属于23类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePizzaFactory</span> &#123;<br>       <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">CreatePizza</span><span class="hljs-params">(String ordertype)</span> &#123;<br>              <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>              <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheesePizza</span>();<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;greek&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreekPizza</span>();<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;pepper&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PepperPizza</span>();<br>              &#125;<br>              <span class="hljs-keyword">return</span> pizza;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>工厂方法模式</em><br><strong>定义了一个创建对象的接口</strong>，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。（只实现某一实例的多样化生产）<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213113030.png"></p><p><em>抽象工厂模式</em><br><strong>定义一个接口用于创建对象族</strong>，无需指定它们的具体类。（实现某一类产品的多样化生产）<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213113259.png"></p><p>区别：<br>工厂方法重点在于<strong>方法</strong>：一个工厂（品牌）只能生产一种产品（鼠标），通过实现多个工厂扩展产品类型。<br>抽象工厂重点在于<strong>工厂</strong>：一个工厂（品牌）可以生产一系列不同产品（鼠标、键盘），通过实现多个工厂扩展产品系列的类型。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>封装一个<strong>复杂对象</strong>构造过程，并允许按步骤构造。<br>创建复杂一个对象需要为其装载很多属性，将这些装载属性的方法封装在不同方法中，子类继承时通过重写不同的方法，实现对对象创建的精准控制。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>复制现有实例：</p><ol><li>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</li><li>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</li></ol><blockquote><p>简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单(简)抽工建原</p><h2 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h2><p>适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>定义：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。<br>分类：</p><ul><li>类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li><li>对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li><li>接口适配器模式：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每一个方法提供一个空方法，那么继承该抽象类的子类则会有选择的覆盖父类的某些方法来实现需求。</li></ul><p>简单来说就是希望一个类、对象、接口（抽象类）实现一个新的接口：</p><ul><li>类可以继承原类，实现新接口（少用）</li><li>对象可以实现新接口，聚合原类</li><li>使用抽象类实现接口，并提供空方法。子类继承抽象类时则可以有选择性的覆盖方法实现需求。</li></ul><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。</p><p>例子：为咖啡添加牛奶，但他们都属于饮品。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213123111.png"><br>代码上，先生成coffee，为其装饰时，将coffer作为参数传入milk的构造器，由milk中的方法对其进行修饰。</p><p><strong>装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。</strong></p><blockquote><p>根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。</p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ol><li>静态代理 2. 动态代理 3. CGLIB代理</li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>定义：</strong> 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213123610.png"><br>破坏了开放封闭原则</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>简单地说就是将<br>例子：<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213124307.png"><br>某个类可能在不同的功能方向进行扩展，如果使用继承会造成类爆炸。通过将不同方向的扩展转变成通过聚合来实现，实现解偶。本例中将软件作为成员提炼出来，此后软件的实现类就可以独立变化。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>定义：通过共享的方式高效的支持大量细粒度的对象。<br>简单来说：抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。<br><strong>应用实例：</strong> JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>适配器模式：转化对象接口。<br>装饰者模式、代理模式：增强原对象。<br>外观模式、桥接模式、组合模式、享受元模：系统封装、功能隔离、功能分级、功能共享。</p><p>适、装代、外桥组享</p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>定义：</strong> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><blockquote><p>可以理解成针对算法（策略）的工厂模式。</p></blockquote><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p><strong>定义：</strong> 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。<br><strong>应用实例</strong>：AQS</p><h3 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><strong>定义：</strong> 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>应用实例：</strong> JAVA 中的 iterator。</p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义：</strong> 如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。<br><strong>应用实例：</strong> Handler</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>定义：</strong> 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><h3 id="类的状态"><a href="#类的状态" class="headerlink" title="类的状态"></a>类的状态</h3><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p><strong>定义：</strong> 当对象的状态改变时，同时改变其行为<br><strong>应用实例：</strong> 如Reentrant锁的state</p><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><strong>定义：</strong> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><h3 id="通过中间类"><a href="#通过中间类" class="headerlink" title="通过中间类"></a>通过中间类</h3><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p><strong>定义：</strong> 将作用于某种数据结构中的各元素的操作分离出来<strong>封装成独立的类</strong>，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。</p><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p><strong>定义：</strong> 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>策模、观迭责命<br>状备、访中</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p><em>设计模式七大原则：</em><br>开单依接里迪合<br><em>设计模式：</em><br>单抽工建原<br>适装代外桥组享<br>策模观迭责命<br>状备访中</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（内存与事务）</title>
    <link href="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Buffer-Poll"><a href="#一、Buffer-Poll" class="headerlink" title="一、Buffer Poll"></a>一、Buffer Poll</h1><h2 id="Buffer-Poll概念"><a href="#Buffer-Poll概念" class="headerlink" title="Buffer Poll概念"></a>Buffer Poll概念</h2><p><code>MySQL</code>服务器启动的时候就向操作系统申请了一片<strong>连续的内存</strong>，叫做<code>Buffer Pool</code>（缓冲池）。</p><h3 id="Buffer-Pool大小"><a href="#Buffer-Pool大小" class="headerlink" title="Buffer Pool大小"></a>Buffer Pool大小</h3><p>默认情况<code>Buffer Pool</code>只有<code>128M</code>，可以在启动服务器的时候配置<code>innodb_buffer_pool_size</code>参数的值来改变该值的大小。</p><h3 id="Buffer-Pool内部组成"><a href="#Buffer-Pool内部组成" class="headerlink" title="Buffer Pool内部组成"></a>Buffer Pool内部组成</h3><p><code>Buffer Pool</code>中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是<code>16KB</code>。<br>每一个缓存页都有一个<strong>控制块</strong>，来装一些<code>控制信息</code>，这些控制信息包括该页所属的表空间编号、页号、缓存页在<code>Buffer Pool</code>中的地址、链表节点信息、一些锁信息以及<code>LSN</code>信息。</p><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2b9d6dd1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="Buffer-Poll管理"><a href="#Buffer-Poll管理" class="headerlink" title="Buffer Poll管理"></a>Buffer Poll管理</h2><h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>Buffer Poll以<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建了一个Hash表，如果访问时命中则直接访问，否则在free链表中申请。</p><h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e300173c1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>链表的<code>基节点</code>占用的内存空间并不包含在<code>Buffer Pool</code>中，而是另外单独申请的一块内存空间，后续的各种链表基节点同理。</p></blockquote><h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><p>修改后的缓存页叫做<code>脏页</code>，为了避免频繁写磁盘影响性能，通过flush链表记录脏页，实现异步的写入磁盘。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2ec4572a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p><code>Buffer Pool</code>大小有限，有时需要将一些页淘汰出缓存。</p><h4 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h4><p>以<code>按照最近最少使用</code>的原则去淘汰缓存页，实现这个功能的链表被称为<code>LRU链表</code>（Least Recently Used）。<br>页面在被访问后就放在LRU链表的头部，淘汰时从尾部开始淘汰即可。</p><h4 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h4><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ol><li>InnoDB对于可能会读取的页面，会进行预加载，也叫<strong>预读</strong>。<ul><li>线性预读：如果访问某个区的页面超过56，则异步读取<strong>下一个区所有页面</strong>。</li><li>随机预读：如果缓存了某区的13个连续页面，则异步读取<strong>本区所有页面</strong>，默认关闭。</li></ul></li></ol><p>这会造成加载到Buffer Poll的页不一定用到，导致真正的热点数据淘汰。</p><ol start="2"><li>全表扫描</li></ol><p>非常多的使用频率偏低的页被同时加载到<code>Buffer Pool</code>时，可能会把那些使用频率非常高的页从<code>Buffer Pool</code>中淘汰掉。</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>InnoDB把这个<code>LRU链表</code>按照一定比例分成两截，分别是：</p><ul><li>一部分链表叫做<code>热数据</code>，或者称<code>young区域</code>。</li><li>另一部分叫做<code>冷数据</code>，或者称<code>old区域</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2a3fffa3_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>默认情况下，<code>old</code>区域在<code>LRU链表</code>中所占的比例是<code>37%</code>。</p><p>通过分区和访问策略，分别解决了预读和全表扫描的问题。<br><em>访问策略</em></p><ul><li>页面初次加载时，对应控制块放在old区头部。</li><li>在控制块上记录<strong>第一次访问时间</strong>，如果在较短时间（<code>innodb_old_blocks_time</code> &#x3D; 1s）内再次访问，则不会将其移动到yound区头部。</li></ul><h4 id="优化LRU链表"><a href="#优化LRU链表" class="headerlink" title="优化LRU链表"></a>优化LRU链表</h4><p>频繁操作头节点开销较大，要降低调整LRU链表的频率。选择只有被访问的缓存页位于<code>young</code>区域的<code>1/4</code>的后边，才会被移动到<code>LRU链表</code>头部。</p><h3 id="其他的一些链表"><a href="#其他的一些链表" class="headerlink" title="其他的一些链表"></a>其他的一些链表</h3><p>比如<code>unzip LRU链表</code>用于管理解压页，<code>zip clean链表</code>用于管理没有被解压的压缩页，<code>zip free数组</code>中每一个元素都代表一个链表，它们组成所谓的<code>伙伴系统</code>来为压缩页提供内存空间等等。</p><div class="note note-primary">            <p>Buffer Poll中有：HashMap、FREE链表、LRU链表、FLUSH链表、其他链表。</p>          </div><h3 id="空间释放"><a href="#空间释放" class="headerlink" title="空间释放"></a>空间释放</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，主要有两种刷新路径：</p><ul><li><code>BUF_FLUSH_LRU</code>：从<code>LRU链表</code>的冷数据中刷新一部分页面到磁盘</li><li><code>BUF_FLUSH_LIST</code>：从<code>flush链表</code>中刷新一部分页面到磁盘</li></ul><p><em>空间释放策略</em></p><ol><li>当空间不够时，用户线程看<code>LRU链表</code>尾部有没有可以释放未修改页面<ul><li>有则释放</li><li>没有则将LRU尾部脏页写盘后释放</li></ul></li><li>特别繁忙时，用户线程批量从<code>flush链表</code>中将脏页刷入盘中。</li></ol><h2 id="多Buffer-Pool实例"><a href="#多Buffer-Pool实例" class="headerlink" title="多Buffer Pool实例"></a>多Buffer Pool实例</h2><p>通过修改<code>innodb_buffer_pool_instances</code>设置Buffer Poll的个数。各Buffer Poll完全独立，提高了并发处理能力：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2abd79c1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>每个Buffer Poll内存大小</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure><p>即总共的大小除以实例的个数。</p><p><em>热更改</em></p><ul><li>MySQL5.7.5之前，只能在启动时配置Buffer Pool内存大小。</li><li>MySQL5.7.5之后，可以在运行时修改。<ul><li>如果想调整<code>Buffer Poll</code>大小，需要重新向操作系统申请连续内存空间，并将旧<code>Buffer Poll</code>复制过来。<strong>为了避免申请连续内存和复制的开销，MySQL将以<code>chunk</code>为单位向操作系统申请空间。</strong></li><li>一个<code>Buffer Pool</code>实例其实是由若干个<code>chunk</code>组成的，一个<code>chunk</code>就代表一片连续的内存空间。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2a5de8f2_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>上图表明，1个<code>Buffer Pool</code>由2个实例组成的，每个实例中又包含2个<code>chunk</code>。</p></blockquote><div class="note note-primary">            <p><code>chunk</code>是MySQL通过<code>innodb_buffer_pool_chunk_size</code>启动参数指定的，默认为128M，运行时无法修改。</p>          </div><blockquote><p>注意：</p><ul><li><code>innodb_buffer_pool_size</code>必须是<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的倍数，否则系统会自动调整<code>innodb_buffer_pool_size</code>的大小。</li><li>如果<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances&gt;innodb_buffer_pool_size</code>，则系统会自动调整<code>innodb_buffer_pool_chunk_size</code>大小。<br>即：</li><li>总大小 &lt; 分片 * 每片大小，则会调整每片大小</li><li>总大小 &gt; 分片 * 每片大小，但不是后者的整数倍，则会调节成后者的整数倍。</li></ul></blockquote><h2 id="Buffer-Pool中存储的其它信息"><a href="#Buffer-Pool中存储的其它信息" class="headerlink" title="Buffer Pool中存储的其它信息"></a>Buffer Pool中存储的其它信息</h2><p>链表和各种内存访问操作的统计数据。</p><h1 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h1><h2 id="事务基本性质"><a href="#事务基本性质" class="headerlink" title="事务基本性质"></a>事务基本性质</h2><ul><li>原子性（<code>Atomicity</code>）：事务是不可分割的操作</li><li>隔离性（<code>Isolation</code>）：两个并发事务之间不能互相影响。</li><li>一致性（<code>Consistency</code>）：保证数据库符合现实世界约束。</li><li>持久性（<code>Durability</code>）：<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来。</li></ul><blockquote><p>原子性和隔离性都是保证一致性的手段。</p></blockquote><h2 id="事务五态模型"><a href="#事务五态模型" class="headerlink" title="事务五态模型"></a>事务五态模型</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169d7fd5bd4ce2f1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持事务。</p></blockquote><h2 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h2><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><ul><li><code>BEGIN</code></li><li><code>START TRANSACTION</code>：后面可接修饰符指定事务模式（默认为读写模式）：<ul><li><code>READ ONLY</code>：只读事务</li><li><code>READ WRITE</code>：读写事务</li><li><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读todo</li></ul></li></ul><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><ul><li><code>COMMIT [WORK]</code></li></ul><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>，默认开启，表示每一条SQL语句是一个独立事务。<br><em>关闭自动提交</em></p><ul><li>显示开启事务。</li><li>修改系统变量<code>autocommit</code>为<code>true</code>。</li></ul><h4 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h4><p>有些语句会将本语句和之前的语句隐式提交</p><ul><li>定义或修改数据库对象的数据定义语言</li><li>使用或修改<code>mysql</code>数据库中的表</li><li>事务控制或关于锁定的语句</li><li>加载数据</li><li>复制（主从）语句</li></ul><h3 id="中止事务"><a href="#中止事务" class="headerlink" title="中止事务"></a>中止事务</h3><ul><li><code>ROLLBACK [WORK]</code></li></ul><h4 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h4><p>定义保存点和回滚保存点的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SAVEPOINT 保存点名称;<br>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;<br></code></pre></td></tr></table></figure><h1 id="三、redo日志"><a href="#三、redo日志" class="headerlink" title="三、redo日志"></a>三、redo日志</h1><h2 id="redo日志简介"><a href="#redo日志简介" class="headerlink" title="redo日志简介"></a>redo日志简介</h2><p>redo日志的目的是<strong>保证一致性</strong>（事务提交后一定执行）:</p><ul><li>若修改一个字段就对页进行一次刷盘，效率很低。</li><li>事务可能涉及多个页，随机I&#x2F;O效率低。</li></ul><p>mysql通过redo日志记录事务执行的结果，并持久化到硬盘，相比将脏页持久化到硬盘:</p><ul><li>效率更高。</li><li>顺序IO执行的。</li></ul><h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdec61898_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="简单redo日志"><a href="#简单redo日志" class="headerlink" title="简单redo日志"></a>简单redo日志</h3><p>只需要记录在某个页面修改&#x2F;写入了几字节值类型的redo日志叫做简单redo日志，也叫物理日志：</p><ul><li><code>MLOG_1/2/4/8BYTE</code>（<code>type</code>字段对应的十进制数字为<code>1/2/4/8</code>）：表示在页面的某个偏移量处写入<code>1/2/4/8</code>个字节的<code>redo</code>日志类型。</li><li><code>MLOG_WRITE_STRING</code>（<code>type</code>字段对应的十进制数字为<code>30</code>）：表示在页面的某个偏移量处写入一串数据，日志多了一个len字段。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdf053082_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdf3da823_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><div class="note note-primary">            <p>简单redo日志只记录在哪个地方写入了什么数据。</p>          </div><h3 id="复杂redo日志（插入日志）"><a href="#复杂redo日志（插入日志）" class="headerlink" title="复杂redo日志（插入日志）"></a>复杂redo日志（插入日志）</h3><p>插入新记录可能修改多个B+树，每个页面的统计信息也会更新：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdfa7d8ce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>解决方案</em></p><ul><li>方案一：在每个修改的地方都记录一条<code>redo</code>日志。</li><li>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。</li></ul><p><em>InnoDB的解决</em><br>提出了一些新的<code>redo</code>日志类型，比如：</p><ul><li><code>MLOG_REC_INSERT</code>（对应的十进制数字为<code>9</code>）：表示插入一条使用非紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_REC_INSERT</code>（对应的十进制数字为<code>38</code>）：表示插入一条使用紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>44</code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的<code>redo</code>日志类型。</li><li>等等…</li></ul><blockquote><p>逻辑上看，这些复杂redo日志无法用来直接记录修改结果，而是将修改时的行为记录下来，恢复时需要调用相关函数进行恢复。</p></blockquote><h2 id="redo日志分组"><a href="#redo日志分组" class="headerlink" title="redo日志分组"></a>redo日志分组</h2><h3 id="实现分组"><a href="#实现分组" class="headerlink" title="实现分组"></a>实现分组</h3><p>一条Sql语句可能产生多条redo日志，这些redo日志应该以组的形式写入磁盘，这是<strong>原子性</strong>的需要。</p><p><em>如何分组？</em></p><ul><li>每组的最后一条<code>redo</code>日志<strong>后边</strong>加上一条特殊类型的<code>redo</code>日志（分界符，只有一个type字段）</li><li>对于只有一条redo日志的组，通过<code>type</code>的第一个<code>bit</code>位标识即可，避免浪费。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489301685dcb4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h3><p>对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303b9e5c9f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="redo日志的写入"><a href="#redo日志的写入" class="headerlink" title="redo日志的写入"></a>redo日志的写入</h2><h3 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h3><p>通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。这里的页与前面16KB的页不同，可以将其称为<code>block</code>加以区分。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303bff8e20_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303c1fb389_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><em>LOG_BLOCK_HDR_NO是如何计算的</em><br>32位，前2位为0，所以该值最大为1G，意味着block块的个数不能超过1G。</p><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p><code>redo</code>日志时也不能直接直接写到磁盘上，服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的<strong>连续内存空间</strong>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303ceeb982_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小（默认16MB）。</p><h3 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h3><p>redo日志的写入是顺序的，InnoDB通过一个全局变量<code>buf_free</code>指明后续应该写入到哪个地方。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694893043dc7344_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>一个事务对应多个mtr，一个mtr对应一组redo日志，即一个事务有多个redo日志组。<br>由于事务是并发进行的，所以两个事务的redo日志组可能交替存储：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489304969c9d7_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="redo日志写入磁盘"><a href="#redo日志写入磁盘" class="headerlink" title="redo日志写入磁盘"></a>redo日志写入磁盘</h2><p>在一些情况下redo日志会从log buffer中刷新到磁盘里，比如：</p><ul><li><code>log buffer</code>空间不足时</li><li>事务提交时（持久性）</li><li>将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中。</li><li>后台线程</li><li>正常关闭服务器时</li><li>做<code>checkpoint</code>时</li></ul><h3 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h3><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，两个文件循环写入：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899033f3b35d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>也可以修改配置指定多个文件，<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p><h3 id="redo日志文件格式"><a href="#redo日志文件格式" class="headerlink" title="redo日志文件格式"></a>redo日志文件格式</h3><p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</li></ul><blockquote><p>注意，这里都是以block作为单位，也就是一个日志存储单元的大小。</p></blockquote><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899033e1cb89_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>log file header：</em><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899065200011_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td>LOG_HEADER_FORMAT</td><td>4</td><td>redo日志的版本，在MySQL 5.7.21中该值永远为1</td></tr><tr><td>LOG_HEADER_PAD1</td><td>4</td><td>做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td>LOG_HEADER_START_LSN</td><td>8</td><td>标记本redo日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值（关于什么是LSN我们稍后再看哈，看不懂的先忽略）。</td></tr><tr><td>LOG_HEADER_CREATOR</td><td>32</td><td>一个字符串，标记本redo日志文件的创建者是谁。正常运行时该值为MySQL的版本号，比如：”MySQL 5.7.21”，使用mysqlbackup命令创建的redo日志文件的该值为”ibbackup”和创建时间。</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><p><em>checkpoint1</em><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899037defb21_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td>LOG_CHECKPOINT_NO</td><td>8</td><td>服务器做checkpoint的编号，每做一次checkpoint，该值就加1。</td></tr><tr><td>LOG_CHECKPOINT_LSN</td><td>8</td><td>服务器做checkpoint结束时对应的LSN值，系统崩溃恢复时将从该值开始。</td></tr><tr><td>LOG_CHECKPOINT_OFFSET</td><td>8</td><td>上个属性中的LSN值在redo日志文件组中的偏移量</td></tr><tr><td>LOG_CHECKPOINT_LOG_BUF_SIZE</td><td>8</td><td>服务器在做checkpoint操作时对应的log buffer的大小</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><h2 id="redo日志的id"><a href="#redo日志的id" class="headerlink" title="redo日志的id"></a>redo日志的id</h2><h3 id="log-sequence-number（LSN）"><a href="#log-sequence-number（LSN）" class="headerlink" title="log sequence number（LSN）"></a>log sequence number（LSN）</h3><p><code>log sequence number</code>是一个全局变量，初始值为8704。其帮助标识了<strong>每个mtr的redo日志组</strong>在log buffer中的起始和结束位置。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899037f19b86_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。</p><ul><li><code>log sequence number</code>：全局变量，初始值为8704，标识<strong>每个mtr的redo日志组</strong>在log buffer中的位置。</li><li><code>flushed_to_disk_lsn</code>：全局变量，表示刷新到磁盘中的<code>redo</code>日志量的全局变量。</li><li><code>buf_free</code>：全局变量（指针），标志下一个mtr写入指针。</li><li><code>buf_next_to_write</code>：全局变量（指针），标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899065ece690_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>总结：当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。</p><blockquote><p>lsn值和redo日志文件偏移量的对应关系：<br><code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（加上<code>log block header</code>和<code>log block trailer</code>的大小）</p></blockquote><h3 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h3><p>修改页内容后要将其控制块加入flush链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899094bcc632_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>每个控制块记录两个属性：</p><ul><li><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</li><li><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</li></ul><p><em>eg:</em><br>修改页顺序：</p><ul><li>mtr_1：a</li><li>mtr_2：b,c</li><li>mtr_3：b,d<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b89909693bfe9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><blockquote><p>一个mtr中修改的两个页的o_m和n_m字段是相同的，所以lsn的变动单位是一个mtr而不是一个redo日志！</p></blockquote><h2 id="redo日志的释放"><a href="#redo日志的释放" class="headerlink" title="redo日志的释放"></a>redo日志的释放</h2><h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><p>redo日志文件大小有限，需要循环写入，因此redo日志文件需要释放空间：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b8990a1ec0f87_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>脏页刷盘前，redo日志必须写入磁盘；</li><li>脏页刷盘后，redo日志可释放；</li></ul><p>脏页刷盘、释放redo日志的过程本质是增加<code>checkpoint_lsn</code>的操作：</p><ul><li>计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。</li><li>将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b8990aeb41002_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><p>checkpoint_lsn：脏页已持久化<br>flushed_to_dick_lsn：redo日志已持久化<br>lsn：当前redo日志序列</p><h3 id="批量从flush链表中刷出脏页"><a href="#批量从flush链表中刷出脏页" class="headerlink" title="批量从flush链表中刷出脏页"></a>批量从flush链表中刷出脏页</h3><p>当lsn增长过快时，系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘。</p><h3 id="innodb-flush-log-at-trx-commit的用法"><a href="#innodb-flush-log-at-trx-commit的用法" class="headerlink" title="innodb_flush_log_at_trx_commit的用法"></a>innodb_flush_log_at_trx_commit的用法</h3><p>如果对持久性要求不太高，可以修改<code>innodb_flush_log_at_trx_commit</code>系统变量</p><ul><li><code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志；</li><li><code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘；</li><li><code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中；（这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了）。</li></ul><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p><em>恢复的起点</em><br><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖。</p><p><em>恢复的终点</em><br>log buffer文件是顺序IO的，找到没写满的block即可</p><p><em>怎么恢复</em></p><ul><li>Hash：使用hash将同一个表中同一个页的redo日志放在一起处理。</li><li>跳过已经刷新到磁盘的页面：<code>checkpoint_lsn</code>之后的<code>redo</code>日志可能也已经刷盘，根据每个页的<code>File Header</code>部分中的lsn字段可以判断本页最后一次刷盘时的lsn号，若其大于<code>checkpoint_lsn</code>，也不用恢复。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>redo日志的作用：记录事务执行的结果&#x2F;过程，主要数据库崩溃时的恢复，实现持久性。</li><li>redo日志的结构：每条语句可能修改多个页面，对应着若干条redo日志记录，这些记录以组的形式（mtr）存在。</li><li>redo日志的存储：redo日志会先写入log buffer区，然后同步到系统上的log file中。<ul><li>log buffer分若干个block块</li><li>相比log buffer，log file的前4个块是固定的</li></ul></li><li>redo日志的释放：脏页被刷盘时，形成一个check-point事件（记录当前check point lsn），该lsn之前redo日志不再被需要，可以释放。</li><li>崩溃恢复时：从check point lsn开始恢复，遇到页的lsn记录大于check point lsn时略过。</li></ul><h1 id="四、undo日志"><a href="#四、undo日志" class="headerlink" title="四、undo日志"></a>四、undo日志</h1><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>redo是为了防止数据库崩溃（持久性），undo是为了防止事件回滚（原子性）。</p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><p>当一个事务涉及到对某个表执行了增、删、改操作时，会为其分配一个事务id。<br>事务id由一个全局变量维护，新事务id自增1，当事务id达到<code>256</code>的倍数时，会将其记录下来<code>Max Trx ID</code>，下次启动时在该值基础上加256，防止事务id冲突。</p><h2 id="undo日志的格式"><a href="#undo日志的格式" class="headerlink" title="undo日志的格式"></a>undo日志的格式</h2><p><code>undo日志</code>是被记录到类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。<br>类似于<code>redo日志</code>：</p><ul><li>一个事务操作对应多个mtr，一个mtr对应多个<code>undo日志</code>。</li><li><code>undo no</code>在<strong>一个事务</strong>中是从<code>0</code>开始递增的，也就是说只要事务没提交，每生成一条<code>undo日志</code>，那么该条日志的<code>undo no</code>就增1。<ul><li>redo是以组为单位记录，复写的；</li><li>undo日志是以事务为单位记录、还原的。</li></ul></li><li><code>undo日志</code>也有很多种类。</li></ul><h3 id="行记录"><a href="#行记录" class="headerlink" title="行记录"></a>行记录</h3><h4 id="trx隐藏列"><a href="#trx隐藏列" class="headerlink" title="trx隐藏列"></a>trx隐藏列</h4><p>行格式中有一个<code>trx_id</code>字段，表示现在对该行进行修改的事务id。</p><h4 id="roll-pointer隐藏列"><a href="#roll-pointer隐藏列" class="headerlink" title="roll_pointer隐藏列"></a>roll_pointer隐藏列</h4><p>指向记录对应的<code>undo日志</code>的一个指针。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875af986df5c6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="undo日志类型"><a href="#undo日志类型" class="headerlink" title="undo日志类型"></a>undo日志类型</h2><h4 id="insert类"><a href="#insert类" class="headerlink" title="insert类"></a>insert类</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afa8857a9e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>只需要记录插入id即可，回滚时根据id删除。</p><h4 id="delete类"><a href="#delete类" class="headerlink" title="delete类"></a>delete类</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afcafda5bf_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>在对一条记录进行<code>delete mark</code>操作前，需要把该记录的旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都给记到对应的<code>undo日志</code>中来，形成版本链：</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afef7f83bf_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afd18e701d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>额外记录<strong>删除时记录各列数据</strong>和<strong>索引各列信息</strong>。</li></ul><p><em>删除页的过程：</em><br>1）将记录的<code>delete_mask</code>标识为改为1<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afc12f5533_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>2）删除事务提交后，有专门线程来将delete标识位为1的记录回收<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afc377e08f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h4 id="update类"><a href="#update类" class="headerlink" title="update类"></a>update类</h4><h5 id="不更新主键"><a href="#不更新主键" class="headerlink" title="不更新主键"></a>不更新主键</h5><ul><li>如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行<code>就地更新</code>。</li><li>否则，用户线程直接先删除记录（记录加入垃圾链表），然后插入新记录。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875b00a275e91_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h5 id="更新主键"><a href="#更新主键" class="headerlink" title="更新主键"></a>更新主键</h5><ul><li>将旧记录进行<code>delete mark</code>操作</li><li>创建新记录并插入</li></ul><blockquote><p>对应主键更新，可以delete mask，否则必须先硬删除记录再插入新记录。</p></blockquote><h2 id="undo页面"><a href="#undo页面" class="headerlink" title="undo页面"></a>undo页面</h2><p>FIL_PAGE_UNDO_LOG页面，该页面专门存储undo日志<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a7fd0d7f9fa_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16f3b5361c14d1b9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>TRX_UNDO_PAGE_TYPE</code>：本页面准备存储什么种类的<code>undo日志</code>。</li><li><code>TRX_UNDO_PAGE_START</code>：表示在当前页面第一条<code>undo日志</code>的起始偏移量。</li><li><code>TRX_UNDO_PAGE_FREE</code>：最后一条<code>undo</code>日志结束时的偏移量。</li><li><code>TRX_UNDO_PAGE_NODE</code>：代表一个<code>List Node</code>结构，连接前后的Undo页面（就像INODE页面一样）。</li></ul><h3 id="Undo页面链表"><a href="#Undo页面链表" class="headerlink" title="Undo页面链表"></a>Undo页面链表</h3><p>通过<code>TRX_UNDO_PAGE_NODE</code>形成链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a8074556f5d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>一个undo页只记录一种类型的undo日志，不同类型的undo页形成链表：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a808197ad5b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>针对普通表和临时表，又分别形成两组Undo日志。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80840261ec_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>这些链表是按需分配的。</p></blockquote><p>undo链表是属于事务的：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80bf9229a6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>每个事务分两组（普通&#x2F;临时），每组有两条链表（update&#x2F;insert），每个链表由若干该类型的undo页面连接构成。</p>          </div><h2 id="undo日志具体写入过程"><a href="#undo日志具体写入过程" class="headerlink" title="undo日志具体写入过程"></a>undo日志具体写入过程</h2><h3 id="undo-log-segment-header"><a href="#undo-log-segment-header" class="headerlink" title="undo log segment header"></a>undo log segment header</h3><p>每一个<code>Undo</code>链表都对应着一个<code>段</code>，称之为<code>Undo Log Segment</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80e0dadcce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>对于数据页，每个索引分两个段（叶子段&#x2F;非叶子段），每个段有若干页面。<br>对于undo页，每个链表就是一个段。</p></blockquote><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80e753a16e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>TRX_UNDO_STATE</code>：本<code>Undo</code>链表处在什么状态。<ul><li><code>TRX_UNDO_ACTIVE</code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入<code>undo日志</code>。</li><li><code>TRX_UNDO_CACHED</code>：被缓存的状态，等待被重用</li><li><code>TRX_UNDO_TO_FREE</code>：<code>insert undo</code>链表不能被重用</li><li><code>TRX_UNDO_TO_PURGE</code>：<code>update undo</code>链表不能被重用</li><li>处于<code>PREPARE</code>阶段的事务产生的<code>undo日志</code>。</li></ul></li><li><code>TRX_UNDO_LAST_LOG</code>：本<code>Undo页面</code>链表中最后一个<code>Undo Log Header</code>的位置。</li><li><code>TRX_UNDO_FSEG_HEADER</code>：本<code>Undo页面</code>链表对应的段的<code>Segment Header</code>信息</li><li><code>TRX_UNDO_PAGE_LIST</code>：<code>Undo页面</code>链表的基节点。</li></ul><blockquote><ul><li><code>undo page header</code> 主要记录本页的指针信息</li><li><code>undo log segment</code> 主要记录本undo log页链表的信息，便于快速搜索。</li><li><code>Segment Header</code> 可以用来快速定位本段的INODE Entry（INODE Entry用来管理一个段中各页面的链表）。</li></ul></blockquote><h3 id="undo-log-header"><a href="#undo-log-header" class="headerlink" title="undo log header"></a>undo log header</h3><p>定义：同一个事务向一个<code>Undo页面</code>链表中写入的<code>undo日志</code>算是一个组，在undo log header记录这些组信息。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f1d5b422_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>链表的第一个页面，会填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，之后才开始正式写入<code>undo日志</code>。</li><li>对于其他的页面只会填充<code>Undo Page Header</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f3cc070f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>如前面总结，一个事务会持有多个undo log页面链表，在第一个链表中放入：</p><ul><li>undo log segment header：记录本链表的状态（写入中？），并定位到INODE Entry，便于页面管理。</li><li>undo log header：记录本链表与事务相关的记录。</li></ul>          </div><h2 id="重用Undo页面"><a href="#重用Undo页面" class="headerlink" title="重用Undo页面"></a>重用Undo页面</h2><p><code>Undo页面</code>链表是否可以被重用的条件很简单：</p><ul><li>该链表中只包含一个<code>Undo页面</code>。</li><li>该<code>Undo页面</code>已经使用的空间小于整个页面空间的3&#x2F;4：<ul><li><code>delete undo</code>链表可立刻删除。</li><li><code>update undo</code>链表不能立刻删除。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f3f150f4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a81007cdf9f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h2><h3 id="Rollback-Segment-Header页面"><a href="#Rollback-Segment-Header页面" class="headerlink" title="Rollback Segment Header页面"></a>Rollback Segment Header页面</h3><p>在这个页面中存放了各个<code>Undo页面</code>链表的<code>frist undo page</code>的<code>页号</code>，他们把这些<code>页号</code>称之为<code>undo slot</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a810434772a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>每个链表的头部记录了链表的状态信息和事务信息<br>这个页面中通过引用各个链表头部对链表进行统一的管理，方便复用：</p><ul><li>事务从回滚段中申请Undo链表。</li><li>事务提交后，符合重用条件的可复用，不可重用的根据类型区分：</li><li>insert类型可释放</li><li>update类型需要放入history链表中。</li></ul></blockquote><h3 id="多个回滚段"><a href="#多个回滚段" class="headerlink" title="多个回滚段"></a>多个回滚段</h3><p>InnoDB中有127个回滚段，一个回滚段管理1024个undo链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a8116df4474_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="回滚段的分类"><a href="#回滚段的分类" class="headerlink" title="回滚段的分类"></a>回滚段的分类</h3><ul><li>普通表回滚段</li><li>临时表回滚段</li></ul><blockquote><p>划分原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p></blockquote><h3 id="回滚段相关配置"><a href="#回滚段相关配置" class="headerlink" title="回滚段相关配置"></a>回滚段相关配置</h3><ul><li>配置回滚段数量：启动参数<code>innodb_rollback_segments</code></li><li>通过<code>innodb_undo_directory</code>指定<code>undo表空间</code>所在的目录</li><li>通过<code>innodb_undo_tablespaces</code>定义<code>undo表空间</code>的数量</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>一个事务对于多个mtr，一个mtr对于多个undo日志</li><li>undo日志存在undo页中，undo页分update和insert类。</li><li>一个undo页不够记录一个事务的所有操作，所以要形成链表。每个事务持有2部分链表（普通&#x2F;临时），1部分链表包括2条链表（update&#x2F;insert）链表。（insert类型的undo页面在事务提交后就可以释放，update则不可以，这是处于版本链管理的需要）</li><li>一个链表就是一个undo页面段，其也有一个INODE结构来管理这个段中各个页面。</li><li>回滚段页面有各个链表头，实现对链表的管理。</li></ul><h1 id="五、事务隔离级别和MVCC"><a href="#五、事务隔离级别和MVCC" class="headerlink" title="五、事务隔离级别和MVCC"></a>五、事务隔离级别和MVCC</h1><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr><td>SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><h3 id="MySQL中支持的隔离级别"><a href="#MySQL中支持的隔离级别" class="headerlink" title="MySQL中支持的隔离级别"></a>MySQL中支持的隔离级别</h3><p>MySQL支持4种隔离级别。MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的。</p><h3 id="设置事务的隔离级别"><a href="#设置事务的隔离级别" class="headerlink" title="设置事务的隔离级别"></a>设置事务的隔离级别</h3><p><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level</code>；</p><h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/b6c72ab37d5a42b9a431d737f3c3b5ee_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>注意insert操作提交后对应的undo日志就没用了。</p></blockquote><p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a33e277a98dbec_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说：<br>必须保证可以读到已经提交了的事务修改过的记录。（未提交则不可见）</p><p>事务为了保证这种一致性，会在创建时，生成一个<code>ReadView</code>对象。</p><ul><li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的<code>事务id</code>列表。</li><li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</li><li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。</li><li><code>creator_trx_id</code>：表示生成该<code>ReadView</code>的事务的<code>事务id</code>。</li></ul><p>这样事务可以根据被访问版本的trx_id值判断：</p><ul><li>小于min_trx_id，说明trx_id事务已经被提交，可访问</li><li>大于max_trx_id，说明trx_id事务在本事务开启后开启的，不可访问</li><li>等于creator_trx_id，说明是本事务进行的修改，可访问</li><li>min与max之间，判断trx_id是否在m_ids中，在则说明开启本事务时trx_id事务未提交，不可访问，否则说明trx_id事务已经提交，可访问。</li></ul><h2 id="不同隔离级别的策略"><a href="#不同隔离级别的策略" class="headerlink" title="不同隔离级别的策略"></a>不同隔离级别的策略</h2><ul><li>READ COMMITTED —— 每次读取数据前都生成一个ReadView</li><li>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</li></ul><h1 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h1><h2 id="锁概念"><a href="#锁概念" class="headerlink" title="锁概念"></a>锁概念</h2><p><code>锁</code>其实是一个内存中的结构：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a680105d9425c2_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><blockquote><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别实际上就已经解决了<code>幻读</code>问题。</p></blockquote><p><em>如何实现多隔离级别？</em></p><ul><li>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</li><li>方案二：读、写操作都采用<code>加锁</code>的方式。</li></ul><h2 id="不同SQL操作对应的锁"><a href="#不同SQL操作对应的锁" class="headerlink" title="不同SQL操作对应的锁"></a>不同SQL操作对应的锁</h2><ul><li>一致性读：也叫<code>快照读</code>，不加锁：<code>SELECT ...</code></li><li>锁定读：<ul><li>共享锁（S锁）：<code>SELECT ... LOCK IN SHARE MODE;</code></li><li>排他锁（X锁）：<code>SELECT ... FOR UPDATE;</code></li></ul></li></ul><table><thead><tr><th>兼容性</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>兼容</td></tr></tbody></table><ul><li>写操作：<ul><li>DELETE：X锁</li><li>UPDATE：<ul><li>原地更新字段时（长度无变化）：X锁</li><li>删除新增字段时（长度有变化）：先后执行<code>DELETE</code>和<code>INSERT</code>。</li><li>更新主键时：先后执行<code>DELETE</code>和<code>INSERT</code>。</li></ul></li><li>INSERT：不加锁，但使用隐式锁保证新增记录在提交前无法被访问。</li></ul></li></ul><h2 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h2><p>锁影响的范围称为锁的粒度，常见的有行级锁和表级锁。</p><p>意向锁：</p><ul><li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li><li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li></ul><p>意向锁：想加<strong>表锁</strong>的事务可以通过查看本表有没有意向锁判断是否有其他事务已经加了<strong>行锁</strong>。</p><p>IX锁和IX锁是兼容的：表示有事务在对表进行读、写（不是同一行）。</p><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h2 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h2><h3 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h3><p>对于<code>MyISAM</code>、<code>MEMORY</code>、<code>MERGE</code>这些存储引擎来说，它们只支持表级锁，也不支持事务。</p><h3 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h3><h4 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁：</p><ul><li>表级别的<code>S锁</code>、<code>X锁</code></li><li>表级别的<code>IS锁</code>、<code>IX锁</code></li><li>表级别的<code>AUTO-INC锁</code>：插入时上AUTO-INC锁，插入完成就释放</li></ul><h4 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h4><ul><li><code>Record Locks</code>：分S、X</li><li><code>Gap Locks</code>：解决了幻读问题，加锁后其他事务无法在锁记录前面插入新记录，通过将锁防止在页面的最大记录上，其他事务就不能插入新记录了。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a5ddeea09f4b64_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd4244481b96_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>Next-Key Locks</code>：相当于<code>Record Locks+Gap Locks</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd42446ce8b5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>Insert Intention Locks</code>：插入意向锁，事务在插入时被gap锁或者next-key lock阻塞，则生成一个<code>Insert Intention Locks</code>锁，主要起唤醒作用。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd424353495e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a72bf8133eb1dc_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>隐式锁：如果某事务插入记录时，另一个事务要读取这个锁，会产生冲突（因为此时初始化未完成）。<ul><li>对于聚簇索引，另一个事务发现trx_id处于活跃状态时，会为插入事务创建一个X锁，并为自己创建一个X锁，形成等待。</li><li>对于二级索引，通过Page Header中的<code>PAGE_MAX_TRX_ID</code>属性判断该页面的记录是否都是已提交状态（与当前活跃事务的最小id对比）。</li></ul></li></ul><h2 id="InnoDB锁结构"><a href="#InnoDB锁结构" class="headerlink" title="InnoDB锁结构"></a>InnoDB锁结构</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a68cda54348429_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>事务信息：事务的指针</li><li>索引信息：加锁记录所属的索引</li><li>表锁／行锁信息：<ul><li>标记锁了哪个表：SpaceID</li><li>哪个表哪行记录：SpaceID,PageNumber,n_bits(一个数量，以便后面通过bit位标记页内哪些行加了锁)</li></ul></li><li>type_mode：这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：<ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。</li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。</li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。</li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。</li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在<code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。</li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。</li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示<code>正经记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。</li><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：也就是当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a864f3298df751_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>其他信息：为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</li><li>一堆比特位：数量由行锁信息的<code>n_bits</code>属性决定，每bit与页内记录的heap_no对应</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a69c2f7b413698_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（查询与优化）</title>
    <link href="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <url>/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单表访问"><a href="#一、单表访问" class="headerlink" title="一、单表访问"></a>一、单表访问</h1><h2 id="访问方法（access-method）"><a href="#访问方法（access-method）" class="headerlink" title="访问方法（access method）"></a>访问方法（access method）</h2><p>Mysql中查询的执行方式大致分两种：</p><ul><li>使用全表扫描进行查询</li><li>使用索引进行查询（使用xx索引的xx查询）</li></ul><p>访问方法分类：</p><ul><li>all：全表</li><li>const：主键 &#x3D; 常数</li><li>ref：二级索引 &#x3D; 常数</li><li>ref_or_null：二级索引 &#x3D; 常数 或 二级索引 &#x3D; null</li><li>range：利用索引进行范围查询</li><li>index：不用回表的二级索引搜索</li><li>index merge：使用到多个索引来完成一次查询</li></ul><h3 id="range优化"><a href="#range优化" class="headerlink" title="range优化"></a>range优化</h3><ul><li>多range合并</li><li>对于<code>range and 其他条件</code>，先根据range确定范围（将其他搜索条件替换为true，之后在筛选)。</li></ul><h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index merge"></a>index merge</h3><ul><li>Intersection合并，分别使用索引确定备选，然后取交集，出现以下情况才<strong>可能</strong>这样执行：<ul><li>情况一：二级索引列是等值匹配的情况。</li><li>情况二：主键列可以是范围匹配</li></ul></li><li>Union合并，分别使用索引确定备选，然后取并集，出现以下情况才<strong>可能</strong>这样执行：<ul><li>情况一：二级索引列是等值匹配的情况</li><li>情况二：主键列可以是范围匹配</li><li>情况三：与<code>Intersection的筛选结果</code>取并集</li></ul></li><li>Sort-Union合并，两个二级索引搜索结果先按照主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并。</li></ul><blockquote><p>注意：往往应该使用联合索引替代Intersection索引合并，即一个索引完成了两个列的范围搜索。</p></blockquote><h1 id="二、连接的原理"><a href="#二、连接的原理" class="headerlink" title="二、连接的原理"></a>二、连接的原理</h1><h2 id="连接本质"><a href="#连接本质" class="headerlink" title="连接本质"></a>连接本质</h2><p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户，如下，这样的结果集称为<code>笛卡尔积</code>。<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3feccc29_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><p><em>驱动表</em><br>第一个需要查询的表，这个表称之为<code>驱动表</code>。<br><em>被驱动表</em><br>使用<code>驱动表</code>中的搜索结果，每条记录都对<code>被驱动表</code>进行一次搜索，过滤得到满足连接的结果。</p><p><em>eg:</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2 <span class="hljs-keyword">WHERE</span> t1.m1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> t1.m1 <span class="hljs-operator">=</span> t2.m2 <span class="hljs-keyword">AND</span> t2.n2 <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;d&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3a02660b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p></blockquote><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><ul><li>对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录<strong>不会</strong>加入到最后的结果集。</li><li>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也<strong>仍然会</strong>加入到结果集。在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：<ul><li>左外连接：选取左侧的表为驱动表。</li><li>右外连接：选取右侧的表为驱动表。</li></ul></li></ul><h2 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h2><p>通用的两表连接过程如下图所示：<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3fa0f107_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上面过程。</p><blockquote><p>这是最简单和笨拙的连接查询算法。</p></blockquote><h3 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h3><p>加速连接查询主要是要加速被驱动表的查询。</p><ul><li>参考单表查询中索引的使用，建立合适的所以避免对被驱动表全表扫描。</li><li>为了避免被驱动表反复被加载到内存中，使用join buffer：<ul><li>执行连接查询前申请一块固定大小的内存，先把若干条<strong>驱动表结果集</strong>中的记录装在这个<code>join buffer</code>中</li><li>然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配</li></ul></li></ul><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3e5fa2f6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><blockquote><p>驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>。</p></blockquote><h1 id="三、查询成本优化"><a href="#三、查询成本优化" class="headerlink" title="三、查询成本优化"></a>三、查询成本优化</h1><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><p><code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p><ul><li><code>I/O</code>成本</li><li><code>CPU</code>成本</li></ul><p><em>成本常数</em></p><ul><li>读取一个页面花费的成本默认是<code>1.0</code>。</li><li>读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。</li></ul><h2 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h2><p>过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引（包括是否能使用联合索引）执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><h3 id="全表扫描成本计算"><a href="#全表扫描成本计算" class="headerlink" title="全表扫描成本计算"></a>全表扫描成本计算</h3><p>由于查询成本&#x3D;<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>I/O成本<br>聚簇索引页数 * <span class="hljs-number">1.0</span> + <span class="hljs-number">1.1</span><br><span class="hljs-regexp">//</span>CPU成本<br>rows * <span class="hljs-number">0.2</span> + <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="索引查询成本的代价"><a href="#索引查询成本的代价" class="headerlink" title="索引查询成本的代价"></a>索引查询成本的代价</h3><blockquote><p>范围搜索：</p><ul><li>查询优化器粗暴的认为读取索引的<strong>一个范围区间</strong>的<code>I/O</code>成本和读取一个页面是相同的。</li><li>对于范围搜索如<code>IN</code>，会预估rows：</li><li>先获取<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，在统计两者之间的记录数量（<code>index dive</code>）</li><li>IN中参数过多（多于200）时，会使用基数估算索引。</li></ul></blockquote><p><em>使用索引处理对于range类型的查询条件</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>I/O成本<br><span class="hljs-regexp">//</span>根据索引搜索一个范围<br><span class="hljs-number">1.0</span><br><span class="hljs-regexp">//</span>回表<br>rows * <span class="hljs-number">1.0</span><br><br><span class="hljs-regexp">//</span>CPU成本<br><span class="hljs-regexp">//</span>读取二级索引<br>rows * <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span><br><span class="hljs-regexp">//</span>读取聚簇索引<br>rows * <span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><h2 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h2><p>查询成本由下边两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code><br>两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>全表扫描时，猜满足搜索条件的记录到底有多少条。</li><li>索引扫描，猜满足除索引搜索条件外的其他搜索条件的记录有多少条。</li></ul><h3 id="两表连接的成本分析"><a href="#两表连接的成本分析" class="headerlink" title="两表连接的成本分析"></a>两表连接的成本分析</h3><p>内连接时，分析不同驱动表的情形，重点优化查询被驱动表的成本。</p><h3 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h3><p>多表时，可能的搜索策略过多，MySQL有以下方法减少计算连接顺序的成本：</p><ul><li>提前结束某种顺序的成本评估：如果某次计算已经大于其他执行方式的成本，提前结束。</li><li>系统变量<code>optimizer_search_depth</code>：连接表大于该值时，只对该值数量的表进行穷举分析。</li><li>根据某些规则不考虑某些连接顺序：<code>启发式规则</code>，就是使用经验。</li></ul><h2 id="调节成本常数"><a href="#调节成本常数" class="headerlink" title="调节成本常数"></a>调节成本常数</h2><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>成本常数被存在mysql数据库中的server_cost表和engine_cost表中。</p><h1 id="四、统计数据的收集"><a href="#四、统计数据的收集" class="headerlink" title="四、统计数据的收集"></a>四、统计数据的收集</h1><h2 id="两种的统计数据存储方式"><a href="#两种的统计数据存储方式" class="headerlink" title="两种的统计数据存储方式"></a>两种的统计数据存储方式</h2><ul><li>永久性的统计数据：存硬盘</li><li>非永久性的统计数据：存内存</li></ul><p><code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，通过修改表可调整策略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (...) Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>); <br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="基于磁盘的永久性统计数据"><a href="#基于磁盘的永久性统计数据" class="headerlink" title="基于磁盘的永久性统计数据"></a>基于磁盘的永久性统计数据</h3><p>统计数据存储到了两个表里，都位于<code>mysql</code>系统数据库，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><h4 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h4><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>database_name</td><td>数据库名</td></tr><tr><td>table_name</td><td>表名</td></tr><tr><td>last_update</td><td>本条记录最后更新时间</td></tr><tr><td>n_rows</td><td>表中记录的条数</td></tr><tr><td>clustered_index_size</td><td>表的聚簇索引占用的页面数量</td></tr><tr><td>sum_of_other_index_sizes</td><td>表的其他索引占用的页面数量</td></tr></tbody></table><blockquote><p>n_rows是估计值</p></blockquote><h4 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h4><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>database_name</td><td>数据库名</td></tr><tr><td>table_name</td><td>表名</td></tr><tr><td>index_name</td><td>索引名</td></tr><tr><td>last_update</td><td>本条记录最后更新时间</td></tr><tr><td>stat_name</td><td>统计项的名称</td></tr><tr><td>stat_value</td><td>对应的统计项的值</td></tr><tr><td>sample_size</td><td>为生成统计数据而采样的页面数量</td></tr><tr><td>stat_description</td><td>对应的统计项的描述</td></tr></tbody></table><h4 id="定期更新统计数据"><a href="#定期更新统计数据" class="headerlink" title="定期更新统计数据"></a>定期更新统计数据</h4><ul><li><code>innodb_stats_auto_recalc</code>：系统变量。默认为开启状态，当发送变动的记录超过表大小的10%，即重新计算。</li><li><code>ANALYZE TABLE</code>：手动调用命令，重新计算。</li></ul><h3 id="基于内存的非永久性统计数据"><a href="#基于内存的非永久性统计数据" class="headerlink" title="基于内存的非永久性统计数据"></a>基于内存的非永久性统计数据</h3><p>非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><h4 id="innodb-stats-method"><a href="#innodb-stats-method" class="headerlink" title="innodb_stats_method"></a>innodb_stats_method</h4><p>是一个系统变量，设置对于<code>允许NULL的索引列</code>的基数计算策略：</p><ul><li><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。</li><li><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</li><li><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</li></ul><h1 id="五、基于规则优化"><a href="#五、基于规则优化" class="headerlink" title="五、基于规则优化"></a>五、基于规则优化</h1><h2 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h2><ul><li>移除不必要的括号</li><li>常量传递</li><li>等值传递</li><li>移除没用的条件</li><li>表达式计算</li><li>HAVING子句和WHERE子句的合并：没有出现聚集函数时，合并HAVING子句和WHERE子句。</li><li>常量表检测：表中只有一条数据或使用主键等值匹配的子句，优先执行。</li><li>外连接消除：WHERE子句中指定<code>被驱动表</code>的 <code>连接列</code> 不为NULL，则变成了内连接。</li></ul><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><h3 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h3><p><em>按查询结果分类</em></p><ul><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ul><p><em>按与外层查询关系分类</em></p><ul><li>不相关子查询：子查询可以独立运行</li><li>相关子查询：子查询的执行需要依赖于外层查询的值（一般表现为子查询中有带有外层表的条件）</li></ul><p><em>子查询语法注意事项</em></p><ul><li>子查询必须用小括号扩起来。</li><li>在<code>SELECT</code>子句中的子查询必须是标量子查询。</li><li>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。</li><li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li></ul><h3 id="子查询在MySQL中执行"><a href="#子查询在MySQL中执行" class="headerlink" title="子查询在MySQL中执行"></a>子查询在MySQL中执行</h3><p>原始子查询：先执行子查询，然后将结果作为外层参数。</p><h4 id="标量子查询、行子查询"><a href="#标量子查询、行子查询" class="headerlink" title="标量子查询、行子查询"></a>标量子查询、行子查询</h4><p>原始子查询。</p><h4 id="IN子查询优化（列子查询）"><a href="#IN子查询优化（列子查询）" class="headerlink" title="IN子查询优化（列子查询）"></a>IN子查询优化（列子查询）</h4><h5 id="物化表"><a href="#物化表" class="headerlink" title="物化表"></a>物化表</h5><p>将不相关子查询的结果集写入一个临时表（基于内存的使用<code>Memory</code>存储引擎，并且会自动去重，如果太大了就会转而使用磁盘和B+树存储），这个表叫做<strong>物化表</strong>。</p><p><em>物化表转连接</em><br>将物化表转化成内连接，提供了转换驱动表的可能。</p><h5 id="semi-join"><a href="#semi-join" class="headerlink" title="semi-join"></a>semi-join</h5><p>对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录。</p><blockquote><p>内连接时，驱动表的每行都要在被驱动表中匹配（被驱动表中可能有多条匹配的行），但IN子句查询，只需要判断被驱动表中有匹配的行即可。</p></blockquote><p>实现方式：</p><ul><li>Table pullout （子查询中的表上拉）：连接列是被驱动表的唯一索引时，连接；</li><li>DuplicateWeedout execution strategy （重复值消除）：临时表去重；</li><li>LooseScan execution strategy （松散扫描）：子查询做驱动表，使用其结果扫描主表的各行结果是否满足条件；</li><li>Semi-join Materialization execution strategy：物化；</li><li>FirstMatch execution strategy （首次匹配）：原始查询。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>满足转换为<code>semi-join</code>的条件时，查询优化器会优先把该子查询转换为<code>semi-join</code>，然后再考虑下边5种执行半连接的策略中哪个成本最低。</li><li>不满足转换<code>semi-join</code>的条件时，查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：<ul><li><p>先将子查询物化之后再执行查询</p></li><li><p>执行<code>IN to EXISTS</code>转换，转化后可能可以使用索引。</p><p>  任意一个IN子查询都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">outer_expr <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where)<br><span class="hljs-comment">--可转化为：</span><br><span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where <span class="hljs-keyword">AND</span> outer_expr<span class="hljs-operator">=</span>inner_expr)<br></code></pre></td></tr></table></figure><h4 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY&#x2F;ALL子查询优化"></a>ANY&#x2F;ALL子查询优化</h4><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr …)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr …)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h4 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h4><ul><li>对于不相关子查询，查出来true&#x2F;false然后重写原语句</li><li>对于相关子查询，只能使用原始子查询</li></ul><h4 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h4><p>子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code></p><div class="note note-primary">            <p>列子查询结果叫<strong>物化表</strong><br>表子查询结果叫<strong>派生表</strong></p>          </div><h1 id="六、Explain"><a href="#六、Explain" class="headerlink" title="六、Explain"></a>六、Explain</h1><p><code>EXPLAIN</code>是一个语句，能帮助我们查看查询语句的执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>输出结果的各列：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><ul><li>id，查询语句中每出现一个<code>SELECT</code>关键字，设计<code>MySQL</code>的大叔就会为它分配一个唯一的<code>id</code>值。<ul><li>若被转化为连接则与驱动表查询SELECT的id相同。</li><li>若创建了临时表，则临时表的id为null。</li></ul></li><li>select_type：<ul><li>SIMPLE：独立查询</li><li>PRIMARY：驱动表查询</li><li>UNION：被驱动表查询</li></ul></li><li>type：访问方法，如const,ref</li><li>filtered：估算满足驱动表查询条件的结果占比，用于估计扇出</li><li>Extra：一些可并列的额外信息</li></ul><h2 id="JSON格式的执行计划"><a href="#JSON格式的执行计划" class="headerlink" title="JSON格式的执行计划"></a>JSON格式的执行计划</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN FORMAT<span class="hljs-operator">=</span>JSON <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>输出json形式的查询语句执行策略，包括成本计算过程。</p><h2 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h2><p><code>optimizer trace</code>是一个系统变量，开启后可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。</p><p>优化过程大致分为了三个阶段：</p><ul><li><code>prepare</code>阶段</li><li><code>optimize</code>阶段（优化主要在这个阶段）</li><li><code>execute</code>阶段</li></ul><p><a href="MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89.md">MySQL基础（内存与事务）</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（InnoDB数据存储）</title>
    <link href="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/"/>
    <url>/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、InnoDB记录"><a href="#一、InnoDB记录" class="headerlink" title="一、InnoDB记录"></a>一、InnoDB记录</h1><h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>目前有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式<br>可以指定表的行格式：<code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></p><h2 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e8fafc21aa_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e8fe4ee6b0_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>按字段顺序，逆序存放各变长字段的长度（Null值除外）。<br>每个可变字段可能占1到2字节来表示长度。</p><p>前提：</p><ul><li>某个字符集中表示一个字符最多需要使用的字节数为<code>W</code></li><li>这种类型表示能存储最多<code>M</code>个字符，如VARCHAR(M)</li><li>它实际存储的字符串占用的字节数是<code>L</code></li></ul><p>策略：</p><ul><li>如果<code>M×W &lt;= 255</code>，使用1字节表示</li><li>如果<code>M×W &gt; 255</code>，则分为两种情况：<ul><li>如果<code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li><li>如果<code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li></ul></li></ul><blockquote><p>先判断<code>M*W</code>，然后通过判断第一个比特位是0或1即可知道是1字节存储还是2字节存储了。</p></blockquote><div class="note note-primary">            <p>尽量使用1字节来存储。<br>这个字段只记录变长字段如VARCHAR，长度固定的字段不用记录。<br>对于溢出数据，只保留只保留前<code>768</code>个字节和<code>20</code>个字节的溢出页面地址，所以2字节足够表达长度。</p>          </div><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e944a8af0c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>对于允许存null的字段，逆序排列，使用比特记录，0表示非空，1表示为空。<br>但是NULL值列表整体长度必须用字节表示，即未使用的高位会补0。</p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e97718ef01_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在本页（记录堆）的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h3 id="真实数据"><a href="#真实数据" class="headerlink" title="真实数据"></a>真实数据</h3><h4 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h4><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><blockquote><ul><li>transaction_id表示最后操作的事务todo</li><li>roll_pointer指向版本日志</li></ul></blockquote><p>对于主键，用户自行实现了就不会创建隐藏列，否则InnoDB为其添加<code>row_id</code>。</p><h4 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h4><h5 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h5><p>字符串的长度可能因为编码不同而不同，对于CHAR(M)：</p><ul><li>当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表</li><li>而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</li></ul><h2 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h2><p>古老的行格式<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e99a69ba3d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>特点是：</p><ul><li>通过<strong>偏移（相对偏移）</strong> 替代<strong>变长字段长度</strong>保存各字段记录结束处的长度。</li><li>对于溢出页，使用2字节存储地址即可。</li><li>使用字段偏移量的第一个Bit作为是否为Null的判断方法。</li><li>对于CHAR(M)，给出最大的空间，不会产生碎片</li></ul></blockquote><h2 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h2><h3 id="行数据上限"><a href="#行数据上限" class="headerlink" title="行数据上限"></a>行数据上限</h3><p>除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过<code>65535</code>个字节。（<code>4*16KB</code>，即需要4个页存储）<br>所以，对于<code>VARCHAR(M)</code>类型的列最多可以占用<code>65535</code>个字节。</p><p>在<code>Compact</code>和<code>Redundant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e9aab47ea5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h3><p><code>MySQL</code>中规定一个页中至少存放两行记录！所以当某列占用字节过多时就会溢出。</p><blockquote><p>如果一个页只放一个页面，B+树的目录层级会非常高！</p></blockquote><h2 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h2><p><code>5.7</code>版本的MYSQL默认行格式是<code>Dynamic</code>，只不过在处理<code>行溢出</code>数据时不一样，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9b2c2b71e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB"></p><h1 id="二、InnoDB数据页结构"><a href="#二、InnoDB数据页结构" class="headerlink" title="二、InnoDB数据页结构"></a>二、InnoDB数据页结构</h1><p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>，也可以叫<code>索引页</code>。</p><h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16f13ee1e2dfac7c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p>其中，FileHeader和FileTrailer是所有页的通用部分。</p><h2 id="文件头部（File-Header）"><a href="#文件头部（File-Header）" class="headerlink" title="文件头部（File Header）"></a>文件头部（File Header）</h2><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr><tr><td><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>，分别代表上一个页和下一个页之间的页号：</td><td></td><td></td></tr><tr><td><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c10eb9d61ce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></td><td></td><td></td></tr></tbody></table><blockquote><p>不是所有的页都有<code>File Header</code>属性。</p></blockquote><h2 id="文件尾部（File-Trailer）"><a href="#文件尾部（File-Trailer）" class="headerlink" title="文件尾部（File Trailer）"></a>文件尾部（File Trailer）</h2><p>这个部分由<code>8</code>个字节组成，可以分成2个小部分：<br>前4个字节代表页的校验和，后4个字节代表页面被最后修改时对应的日志序列位置（LSN）。</p><div class="note note-primary">            <p>文件首部和尾部都会记录校验和<code>checkSum</code>和最后日志序列位置<code>LSN</code>，如果某项校验不成功说明同步出现问题。</p>          </div><h2 id="页头（Page-Header）"><a href="#页头（Page-Header）" class="headerlink" title="页头（Page Header）"></a>页头（Page Header）</h2><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><p>用来存储一个数据页的基本信息。</p><h2 id="用户信息（User-Record）"><a href="#用户信息（User-Record）" class="headerlink" title="用户信息（User Record）"></a>用户信息（User Record）</h2><p>介绍行格式时提到过，InnoDB记录中，每条记录都有一个记录头：</p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><strong>n_owned</strong></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><strong>heap_no</strong></td><td>13</td><td>表示当前记录在本页中的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示本页最小记录，3表示本页最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>去除预留位，剩余的部分如下：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c1084c440b4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>heap_no，表示当前记录在<strong>本页</strong>中的位置，0代表最小记录，1代表最大记录，所以某个页中这个记录从2开始。</li><li>最小记录和最大记录是哑节点，各自保存了一个字符串，且没有放在User Records部分。</li><li>n_owned：记录当前记录所在的组有多少条数据。</li><li>next_record:记录当前记录到下一天记录的地址偏移量。</li></ul><p><img src="/16a95c1084c440b4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0%201.webp"></p><blockquote><p>链表会随着删除而变化，但删除时只会改变标记delete_mask，然后将其放入一个垃圾链表中，当新插入记录时，可以复用垃圾链表中旧记录的空间。</p></blockquote><div class="note note-primary">            <p>记录会按照索引从小到大通过链表连接，但不一定在空间上连续。</p>          </div><h2 id="页目录（Page-Directory）"><a href="#页目录（Page-Directory）" class="headerlink" title="页目录（Page Directory）"></a>页目录（Page Directory）</h2><p>为了避免查看某个页记录时通过遍历来查看索引，将正常记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组，每个组的最后一条记录通过<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</p><p>将每个组的最后一条记录的地址偏移量单独提取出来<strong>按顺序存储</strong>到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c10f2e61ad5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间。</p><blockquote><p>初始情况下有两个分组，先填充最大记录所在分组，然后创建新分组。</p></blockquote><p><em>从数据页中找数据分两步：</em><br><strong>通过二分法确认记录所在的组，通过next_record遍历找到组内对应的记录。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>。</li><li>一个数据页可以被大致划分为7个部分，见上文图中所示。</li><li>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</li><li><code>InnoDB</code>会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</li></ol><h1 id="三、B-树索引"><a href="#三、B-树索引" class="headerlink" title="三、B+树索引"></a>三、B+树索引</h1><h2 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h2><p>为了快速检索，将记录按索引顺序连接（同页或跨页），并为页其添加目录记录，和在页中将数据分组的思想类似。<br>目录记录一般叫做<code>目录项</code>，其中的两个列是<code>主键</code>和<code>页号</code>，其中主键记录的是某个页首个记录的id。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a01bd295fd42b5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a01bd2a6c7a65f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>满足以下条件的就是聚簇索引：</p><ul><li>聚簇索引使用记录主键值的大小进行记录和页的排序</li><li><code>B+</code>树的叶子节点存储的是完整的用户记录。</li></ul><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>满足以下条件的就是二级索引，也叫辅助索引：</p><ul><li>使用非主键做顺序进行记录和页的排序</li><li><code>B+</code>树的叶子节点存储的是二级索引和<strong>主键</strong></li></ul><p>通过二级索引查询时，若要找完整数据行数据则需要<strong>回表</strong>，即根据查到的ID再在聚簇索引中搜索一次。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>同时以多个列作为排序规则：</p><ul><li>同时以多个列作为排序规则，根据列出现的前后顺序，依次排序</li><li><code>B+</code>树的叶子节点存储的是联合索引和<strong>主键</strong></li></ul><h2 id="B-树变化过程"><a href="#B-树变化过程" class="headerlink" title="B+树变化过程"></a>B+树变化过程</h2><h3 id="B-树形成过程"><a href="#B-树形成过程" class="headerlink" title="B+树形成过程"></a>B+树形成过程</h3><ol><li>先在B+根节点上添加用户数据</li><li>根节点满后将记录复制到新页中，并新页A进行分裂，得到新页A1和新页A2，新记录选择性的插入页A或页B，然后根节点升级成目录页。</li></ol><h3 id="二级索引B-树"><a href="#二级索引B-树" class="headerlink" title="二级索引B+树"></a>二级索引B+树</h3><p>二级索引B+树的主键不唯一，可能导致无法确定唯一的索引方向，所以<strong>二级索引的非叶子节点</strong>也会保存<strong>主键</strong>列，以便快速确定新记录位置。</p><h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储。</p><ul><li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。</li><li><code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。</li></ul><blockquote><p>所以MyISAM搜索记录至少要进行一次回表。</p></blockquote><h2 id="MySQL如何创建-x2F-删除索引"><a href="#MySQL如何创建-x2F-删除索引" class="headerlink" title="MySQL如何创建&#x2F;删除索引"></a>MySQL如何创建&#x2F;删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> TALBE 表名 (<br>    各种列的信息 ··· , <br>    [KEY<span class="hljs-operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)<br>)<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名 (需要被索引的单个列或多个列);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名;<br></code></pre></td></tr></table></figure><blockquote><p>KEY和INDEX是同义词。</p></blockquote><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><ul><li><p>空间上的代价：建立一个索引需要耗费空间</p></li><li><p>时间上的代价：update类操作需要同时更新多个索引</p></li><li><p>对于二级索引：获取id后还要回到聚簇索引中搜索，这个过程称为<strong>回表</strong>。（一次顺序IO，一次随机IO），查询优化器会衡量回表消耗选择合适的搜索方式。</p></li></ul><h3 id="匹配方式"><a href="#匹配方式" class="headerlink" title="匹配方式"></a>匹配方式</h3><p>InnoDB会为每个索引都会建立一个B+树。<br>可以使用索引的方式有：</p><ul><li>全值匹配：搜索条件为<code>索引 = 常量</code>。</li><li>匹配左边的列：搜索条件为 <code>联合索引中的第一个索引 = 常量</code>。</li><li>匹配列前缀：搜索条件为 <code>索引 like &#39;A%&#39;</code>(‘%A’则不行)</li><li>匹配范围：搜索条件为 <code>索引&gt;常量 and 索引&lt;常量</code></li><li>精确匹配某一列并范围匹配另外一列：搜索条件为 <code>联合索引中的第一个索引 = 常量</code> + <code>联合索引中的第二个索引 &gt; 常量</code></li><li>用于排序：搜索条件为<code>order by 索引</code><ul><li>不可以使用索引进行排序的几种情况：<ul><li>ASC、DESC混用</li><li>排序列包含非同一个索引的列</li><li>排序列使用了复杂的表达式</li></ul></li></ul></li><li>用于分组：搜索条件为<code>group by 索引</code></li></ul><h3 id="如何选择索引"><a href="#如何选择索引" class="headerlink" title="如何选择索引"></a>如何选择索引</h3><ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li></ul><h1 id="四、MySQL数据目录"><a href="#四、MySQL数据目录" class="headerlink" title="四、MySQL数据目录"></a>四、MySQL数据目录</h1><p><code>数据目录</code>是用来存储<code>MySQL</code>在运行过程中产生的数据的。</p><h2 id="数据目录的结构"><a href="#数据目录的结构" class="headerlink" title="数据目录的结构"></a>数据目录的结构</h2><h3 id="InnoDB文件系统"><a href="#InnoDB文件系统" class="headerlink" title="InnoDB文件系统"></a>InnoDB文件系统</h3><h4 id="库在文件系统中的表示"><a href="#库在文件系统中的表示" class="headerlink" title="库在文件系统中的表示"></a>库在文件系统中的表示</h4><ol><li>在<code>数据目录</code>下创建一个和数据库名同名的子目录（或者说是文件夹）。</li><li>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，其中有数据库的基本属性。</li></ol><h4 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h4><p><em>表结构</em><br><code>InnoDB</code>和<code>MyISAM</code>这两种存储引擎都在<code>数据目录</code>下对应的<strong>数据库子目录</strong>下创建了一个专门用于描述<strong>表结构</strong>的文件<code>表名.frm</code></p><p><em>表空间</em></p><ul><li>系统表空间：对应文件系统上一个或多个实际的文件，默认情况下，<code>InnoDB</code>会在<code>数据目录</code>下创建一个名为<code>ibdata1</code>，该文件是自扩展的。（<strong>在MYSQL5.5.7到MYSQL5.6.6之间，所有表数据都默认存放在系统表空间</strong>）</li><li>独立表空间：<strong>MYSQL5.6.6之后，InnoDB为每一个表建立一个独立表空间</strong>，文件名为<code>表名.ibd</code>。</li><li>其他类型的表空间：通用表空间，undo表空间等。</li></ul><blockquote><p>将用户数据存在在系统表空间还是独立表空间是可以配置的，但只对新表有用。旧的表只能转移。</p></blockquote><div class="note note-primary">            <p>表空间是一个抽象的概念，对应系统中一个或多个文件。</p>          </div><h4 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h4><p>对于视图，不需要存储真实的数据的，只需要把它的结构存储起来就行了，只存储一个<code>视图名.frm</code>文件。</p><h3 id="MyISAM文件系统"><a href="#MyISAM文件系统" class="headerlink" title="MyISAM文件系统"></a>MyISAM文件系统</h3><p>没有表空间，表数据都放在数据库的子目录下，如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">test.frm <span class="hljs-regexp">//</span>表结构<br>test.MYD <span class="hljs-regexp">//</span>数据<br>test.MYI <span class="hljs-regexp">//</span>索引<br></code></pre></td></tr></table></figure><h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><p><code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li>服务器进程文件。</li><li>服务器日志文件。</li><li>默认&#x2F;自动生成的SSL和RSA证书和密钥文件。</li></ul><h2 id="MYSQL系统数据库"><a href="#MYSQL系统数据库" class="headerlink" title="MYSQL系统数据库"></a>MYSQL系统数据库</h2><ul><li><code>mysql</code>：存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</li><li><code>information_schema</code>：这个数据库保存着MySQL服务器维护的所有<strong>其他数据库的信息</strong>，有时候也称之为元数据。</li><li><code>performance_schema</code>：这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，MySQL服务器的一个性能监控。</li><li><code>sys</code>： 这个数据库主要是通过视图的形式把<code>information_schema</code> 和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</li></ul><h1 id="五、InnoDB表空间"><a href="#五、InnoDB表空间" class="headerlink" title="五、InnoDB表空间"></a>五、InnoDB表空间</h1><h2 id="页面回顾"><a href="#页面回顾" class="headerlink" title="页面回顾"></a>页面回顾</h2><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>BLOB页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><h3 id="页面通用部分"><a href="#页面通用部分" class="headerlink" title="页面通用部分"></a>页面通用部分</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f33c338667_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>File Header和File Trailder都保存了LSN！</p>          </div><h2 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h2><h3 id="区（Extent）"><a href="#区（Extent）" class="headerlink" title="区（Extent）"></a>区（Extent）</h3><p>物理概念，连续的64个页。</p><h3 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h3><p>物理概念，连续的256个组。</p><blockquote><p>注意，这里的组与页里面几个记录为一组不是一个东西！</p></blockquote><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f33df9307a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>信息：</p><ul><li>第一个页<ul><li>表空间的在<strong>第一个组的第一个页</strong>中使用一个<code>FSP_HDR</code>的页来存储<strong>表信息和本组的页面信息</strong>。</li><li>除了第一个组，<strong>每个组的第一个页</strong>使用一个<code>XDES</code>的页来存储<strong>本组页面的信息</strong>。</li></ul></li><li>第二个页<ul><li><strong>每组的第二个页</strong>使用了一个<code>IBUF_BITMAP</code>页保存了本组页面的<code>INSERT BUFFER</code>的信息。</li></ul></li><li>第三个页<ul><li>第一个组的第三个页使用一个<code>INODE</code>页保存todo</li></ul></li></ul><div class="note note-primary">            <p><strong>为了管理，分配页空间</strong>，把每64个页作为一个区，每256个区作为一个组。<br>以<strong>组</strong>为单位维护组内<strong>各个区</strong>的<strong>页面</strong>使用情况。<br>目的在于尽可能让同一个索引树的数据在一个连续的空间中，实现顺序IO。即当数据量很大时，以区（64个页）为单位分配空间。</p>          </div><h3 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h3><p>段是一个抽象的概念，1个索引会生成2个段，一个叶子节点段，一个非叶子节点段。<br>为段分配空间的策略：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会<strong>以完整的区为单位</strong>来分配存储空间。</li></ul><h2 id="区的分类与管理"><a href="#区的分类与管理" class="headerlink" title="区的分类与管理"></a>区的分类与管理</h2><p>区有4种状态：</p><ul><li>空闲的区：现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>FREE</td><td>空闲的区</td></tr><tr><td>FREE_FRAG</td><td>有剩余空间的碎片区</td></tr><tr><td>FULL_FRAG</td><td>没有剩余空间的碎片区</td></tr><tr><td>FSEG</td><td>附属于某个段的区</td></tr></tbody></table><h3 id="XDES-Entry"><a href="#XDES-Entry" class="headerlink" title="XDES Entry"></a>XDES Entry</h3><p>为了集中管理区的状态，使用了<code>XDES Entry</code>结构保存区状态。<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f343654829_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>XDES Entry保存了这个区：</p><ul><li>State状态：是否为空，或者是否附属于什么段。</li><li>XDES指针(一前一后)：便于快速检索每个区的状态。</li><li>Segment ID：所属段ID。</li><li>Page State Bitmap：标记本区的各个页是否空闲。</li></ul><h3 id="XDES-Entry链表"><a href="#XDES-Entry链表" class="headerlink" title="XDES Entry链表"></a>XDES Entry链表</h3><h4 id="全局的XDES-Entry链表"><a href="#全局的XDES-Entry链表" class="headerlink" title="全局的XDES Entry链表"></a>全局的XDES Entry链表</h4><p>除了FSEG状态，<strong>每个表会维护以下三个链表</strong>：</p><ul><li><code>FREE</code>链表</li><li><code>FREE_FRAG</code>链表</li><li><code>FULL_FRAG</code>链表</li></ul><p>这样在为段分配新空间时就可以快速找到碎片区和空闲区</p><h4 id="段中的XDES-Entry链表"><a href="#段中的XDES-Entry链表" class="headerlink" title="段中的XDES Entry链表"></a>段中的XDES Entry链表</h4><p>向段中插入数据时：</p><ol><li>段中碎片少时先找碎片区，找<code>FREE_FRAG</code>链表</li><li>段占满32个离散的页后，开始申请完整的区，找<code>FREE</code>链表</li></ol><p>区被分配给段之后，<strong>每个段也会维护以下三个链表</strong>：</p><ul><li><code>FREE</code>链表</li><li><code>FREE_FRAG</code>链表</li><li><code>FULL_FRAG</code>链表</li></ul><p>这三个链表是属于具体的段的，这样为该段的新数据找区分配时也可以直接找，不需要找全局申请。</p><h3 id="链表基节点"><a href="#链表基节点" class="headerlink" title="链表基节点"></a>链表基节点</h3><p><code>List Base Node</code>的结构：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f388927e1c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>每个链表都有一个这样的头节点，来描述这个链表的基本属性。</p><div class="note note-primary">            <p>通过在全局维护不同类型区的链表和为每个段维护不同类型的区的链表，为管理区提供了条件。</p>          </div><h2 id="段的属性"><a href="#段的属性" class="headerlink" title="段的属性"></a>段的属性</h2><p>每个区使用了<code>XDES Entry</code>记录区的信息。<br>每个段使用了<code>INODE Entry</code>记录段的信息：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4087c4a56_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>这里可见，段使用<code>INODE Entry</code>结构记录自己的信息，通过引用链表基节点<code>List Base</code>访问记录各个区信息的<code>XDES Entry</code>结构来实现对本段持有的区的管理。</p>          </div><h2 id="各种类型页面"><a href="#各种类型页面" class="headerlink" title="各种类型页面"></a>各种类型页面</h2><p>上面介绍了<code>XDES Entry</code>和<code>INODE Entry</code>结构分别记录区信息和段信息，现在介绍这些结构实际存储在哪里。</p><h3 id="FSP-HDR页面"><a href="#FSP-HDR页面" class="headerlink" title="FSP_HDR页面"></a>FSP_HDR页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4733af475_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><code>FSR_HDR</code>是表空间中第一个组的第一个区的第一个页面，具体信息如下：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>File Space Header</td><td>表空间头部</td><td>112字节</td><td>表空间的一些整体属性信息</td></tr><tr><td>XDES Entry</td><td>区描述信息</td><td>10240字节</td><td>存储本组256个区对应的属性信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>5986字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><blockquote><p>这个页记录了：</p><ul><li>本表的属性</li><li>本组的各个区（256个区）的属性信息。</li></ul></blockquote><p><em>File Space Header</em></p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>Space ID</td><td>4字节</td><td>表空间的ID</td></tr><tr><td>Not Used</td><td>4字节</td><td>这4个字节未被使用，可以忽略</td></tr><tr><td>Size</td><td>4字节</td><td>当前表空间占有的页面数</td></tr><tr><td>FREE Limit</td><td>4字节</td><td>尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td></tr><tr><td>Space Flags</td><td>4字节</td><td>表空间的一些占用存储空间比较小的属性</td></tr><tr><td>FRAG_N_USED</td><td>4字节</td><td>FREE_FRAG链表中已使用的页面数量</td></tr><tr><td>List Base Node for FREE List</td><td>16字节</td><td>FREE链表的基节点</td></tr><tr><td>List Base Node for FREE_FRAG List</td><td>16字节</td><td>FREE_FRAG链表的基节点</td></tr><tr><td>List Base Node for FULL_FRAG List</td><td>16字节</td><td>FULL_FRAG链表的基节点</td></tr><tr><td>Next Unused Segment ID</td><td>8字节</td><td>当前表空间中下一个未使用的 Segment ID</td></tr><tr><td>List Base Node for SEG_INODES_FULL List</td><td>16字节</td><td>SEG_INODES_FULL链表的基节点</td></tr><tr><td>List Base Node for SEG_INODES_FREE List</td><td>16字节</td><td>SEG_INODES_FREE链表的基节点</td></tr></tbody></table><h3 id="XDES页面"><a href="#XDES页面" class="headerlink" title="XDES页面"></a>XDES页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f475c0ec2a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>这个页记录了：</p><ul><li>本组的各个区（256个区）的属性信息。</li></ul></blockquote><p>与<code>FSR_HDR</code>相似，只是没有<em>File Space Header</em>字段。</p><h3 id="IBUF-BITMAP页面"><a href="#IBUF-BITMAP页面" class="headerlink" title="IBUF_BITMAP页面"></a>IBUF_BITMAP页面</h3><p>todo</p><h3 id="INODE页面"><a href="#INODE页面" class="headerlink" title="INODE页面"></a>INODE页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16ef3a8df380813e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>前面说过每个段设计了一个<code>INODE Entry</code>结构，通过<code>INODE Entry</code>结构找<code>XDES Entry</code>实现段对区的管理。</p></blockquote><p>表空间在第一个组的第一个区的第三个页面保存这些<code>INODE</code>节点，具体：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>List Node for INODE Page List</td><td>通用链表节点</td><td>12字节</td><td>存储上一个INODE页面和下一个INODE页面的指针</td></tr><tr><td>INODE Entry</td><td>段描述信息</td><td>16320字节</td><td></td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>6字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>List Node for INODE Page List</code>：该页面只能创建85个<code>INODE Entry</code>，如果这个表空间的索引较多（一个索引对应两个段，一个段就有一个INODE Entry），则需要使用其他的页来记录，这里用来存储上一个和下一个INODE Entry页面。</p><p>为了管理INODE Entry页面，也创建了两个链表：</p><ul><li><code>SEG_INODES_FULL</code>链表：该链表中的<code>INODE</code>类型的页面中已经没有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li><li><code>SEG_INODES_FREE</code>链表：该链表中的<code>INODE</code>类型的页面中还有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li></ul><p>而这两个链表的基节点在<code>File Space Header</code>（在FSP_HDR页面中）。</p><h2 id="Segment-Header-结构"><a href="#Segment-Header-结构" class="headerlink" title="Segment Header 结构"></a>Segment Header 结构</h2><p>每个段用一个<code>INODE Entry</code>记录属性，同时也需要建立段中页面和<code>INODE Entry</code>的对应方式。</p><p>每个索引页都有一个Page Header部分（存放这个数据页的基本信息），对于每个索引的<strong>根节点</strong>，都有两个属性：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的根页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的根页定义</td></tr></tbody></table><p>这两个属性都对应一个<code>Segment Header</code>结构：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f48c4472a3_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>各个部分的具体释义如下：</p><table><thead><tr><th>名称</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td>Space ID of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的表空间ID</td></tr><tr><td>Page Number of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的页面页号</td></tr><tr><td>Byte Offset of the INODE Ent</td><td>2</td><td>INODE Entry结构在该页面中的偏移量</td></tr></tbody></table><div class="note note-primary">            <p>即<strong>索引的根节点</strong>的<strong>页头信息</strong>中记录了对<strong>该索引的两个段的INODE结构</strong>的指针。</p>          </div><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p><code>系统表空间 ID</code>（Space ID）是<code>0</code>。<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4911220d8_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><p>第一个区extend 0中有许多页来记录系统属性：</p><table><thead><tr><th>页号</th><th>页面类型</th><th>英文描述</th><th>描述</th></tr></thead><tbody><tr><td>3</td><td>SYS</td><td>Insert Buffer Header</td><td>存储Insert Buffer的头部信息</td></tr><tr><td>4</td><td>INDEX</td><td>Insert Buffer Root</td><td>存储Insert Buffer的根页面</td></tr><tr><td>5</td><td>TRX_SYS</td><td>Transction System</td><td>事务系统的相关信息</td></tr><tr><td>6</td><td>SYS</td><td>First Rollback Segment</td><td>第一个回滚段的页面</td></tr><tr><td>7</td><td>SYS</td><td>Data Dictionary Header</td><td>数据字典头部信息</td></tr></tbody></table></li><li><p><code>extent 1</code>和<code>extent 2</code>这两个区被称为双写缓冲区</p></li></ul><h3 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h3><p>InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIRTUAL</td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr><tr><td>这些系统表也被称为<code>数据字典</code>。</td><td></td></tr></tbody></table><h4 id="SYS-TABLES表"><a href="#SYS-TABLES表" class="headerlink" title="SYS_TABLES表"></a>SYS_TABLES表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>NAME</td><td>表的名称</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个表都有一个唯一的ID</td></tr><tr><td>N_COLS</td><td>该表拥有列的个数</td></tr><tr><td>TYPE</td><td>表的类型，记录了一些文件格式、行格式、压缩等信息</td></tr><tr><td>MIX_ID</td><td>已过时，忽略</td></tr><tr><td>MIX_LEN</td><td>表的一些额外的属性</td></tr><tr><td>CLUSTER_ID</td><td>未使用，忽略</td></tr><tr><td>SPACE</td><td>该表所属表空间的ID</td></tr></tbody></table><h4 id="SYS-COLUMNS表"><a href="#SYS-COLUMNS表" class="headerlink" title="SYS_COLUMNS表"></a>SYS_COLUMNS表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该列所属表对应的ID</td></tr><tr><td>POS</td><td>该列在表中是第几列</td></tr><tr><td>NAME</td><td>该列的名称</td></tr><tr><td>MTYPE</td><td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td></tr><tr><td>PRTYPE</td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td></tr><tr><td>LEN</td><td>该列最多占用存储空间的字节数</td></tr><tr><td>PREC</td><td>该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><h4 id="SYS-INDEXES表"><a href="#SYS-INDEXES表" class="headerlink" title="SYS_INDEXES表"></a>SYS_INDEXES表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该索引所属表对应的ID</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td>NAME</td><td>该索引的名称</td></tr><tr><td>N_FIELDS</td><td>该索引包含列的个数</td></tr><tr><td>TYPE</td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td>SPACE</td><td>该索引根页面所在的表空间ID</td></tr><tr><td>PAGE_NO</td><td>该索引根页面所在的页面号</td></tr><tr><td>MERGE_THRESHOLD</td><td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><h4 id="SYS-FIELDS表"><a href="#SYS-FIELDS表" class="headerlink" title="SYS_FIELDS表"></a>SYS_FIELDS表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>INDEX_ID</td><td>该索引列所属的索引的ID</td></tr><tr><td>POS</td><td>该索引列在某个索引中是第几列</td></tr><tr><td>COL_NAME</td><td>该索引列的名称</td></tr></tbody></table><h3 id="Data-Dictionary-Header页面"><a href="#Data-Dictionary-Header页面" class="headerlink" title="Data Dictionary Header页面"></a>Data Dictionary Header页面</h3><p>以上的四个系统表描述了用户表的元数据，而这四个系统表的元数据则通过固定页面（Data Dictionary Header）来存储。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16efe1e5a01aeac9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Data Dictionary Header</td><td>数据字典头部信息</td><td>56字节</td><td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td>Segment Header</td><td>段头部信息</td><td>10字节</td><td>记录本页面所在段对应的INODE Entry位置信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>16272字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>Data Dictionary Header</code>描述了整个系统分配下一个表空间ID，列ID等的策略。</p><blockquote><p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表，但可以参考。</p></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4a99c9a08_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>用户表空间结构：</p><ol><li>每个页通过将记录分成多组，使用页头管理</li><li>每个区由64个连续页组成，通过XDES结构管理每个页的状态</li><li>每个组由256个连续区组成，通过FSP_HDR&#x2F;XDES页面管理每个区的状态。</li><li>每个表由若干组组成，通过INODE页面管理本表的段。</li><li>每个索引由2个段组成，段是一个逻辑上的概念。</li></ol><p>空间分配：<br>当段占用的页面超过32个时，开始以区为单位分配空间，因此：</p><ol><li>每个表空间有3个全局链表，分别代表了不同状态的XDES结构。</li><li>每个段也有3个链表，维护属于本段的XDES结构。</li></ol>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（启动选项与字符集）</title>
    <link href="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/"/>
    <url>/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、启动选项"><a href="#一、启动选项" class="headerlink" title="一、启动选项"></a>一、启动选项</h1><h2 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h2><p><em>eg:</em><br><code>--skip-networking</code> 禁止网络<br><code>--default-storage-engine=MyISAM</code> 选择默认存储引擎</p><p>注意：</p><ul><li>选项有长形式和短形式<ul><li>长形式前面<code>--</code></li><li>短形式前面<code>-</code></li><li>一般短形式后面要直接加参数（不能空格）</li></ul></li><li>选项名是区分大小写的</li></ul><div class="note note-primary">            <p><code>mysqld_safe</code>会间接调用<code>mysqld</code></p>          </div><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可以在配置文件中修改启动参数。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p><h3 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h3><ul><li>不同配置文件和同一个配置文件中的相同选项，按扫描最后出现的为准。</li><li>可以<code>defaults-extra-file</code>指定额外的配置文件，这样会只使用该指定文件。</li></ul><h1 id="二、系统变量"><a href="#二、系统变量" class="headerlink" title="二、系统变量"></a>二、系统变量</h1><h2 id="系统变量基本概念"><a href="#系统变量基本概念" class="headerlink" title="系统变量基本概念"></a>系统变量基本概念</h2><ul><li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li><li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li></ul><h2 id="系统变量基本操作"><a href="#系统变量基本操作" class="headerlink" title="系统变量基本操作"></a>系统变量基本操作</h2><h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><p><code>SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</code></p><h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><h4 id="启动时"><a href="#启动时" class="headerlink" title="启动时"></a>启动时</h4><ul><li>启动时指定</li><li>配置文件中配置</li></ul><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>设置不同作用范围的系统变量：<br><code>SET [GLOBAL|SESSION] 系统变量名 = 值;</code><br>或<br><code>SET [@@(GLOBAL|SESSION).]var_name = XXX;</code></p><blockquote><p>注意：</p><ul><li>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。</li><li>有些系统变量是只读的，并不能设置值。</li></ul></blockquote><h4 id="启动选项和系统变量的区别"><a href="#启动选项和系统变量的区别" class="headerlink" title="启动选项和系统变量的区别"></a>启动选项和系统变量的区别</h4><ul><li>大部分的系统变量都可以被当作启动选项传入。</li><li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>啥的。</li><li>有些启动选项也不是系统变量，比如<code>defaults-file</code>。</li></ul><h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><h3 id="查看状态变量"><a href="#查看状态变量" class="headerlink" title="查看状态变量"></a>查看状态变量</h3><p><code>SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</code></p><h1 id="三、字符集"><a href="#三、字符集" class="headerlink" title="三、字符集"></a>三、字符集</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>主要字符集：</p><ul><li><code>ASCII</code>字符集：128个字符，<strong>1字节</strong>编码</li><li><code>ISO 8859-1</code>字符集：256个字符，<strong>1字节</strong>编码</li><li><code>GB2312</code>字符集：汉字，ASCII中1字节编码，其他<strong>2字节</strong>编码</li><li><code>GBK</code>字符集：对<code>GB2312</code>扩充，<strong>1～2字节</strong>编码。</li><li><code>utf8</code>字符集：兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用<strong>1～4个字节</strong>。</li></ul><h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>每个字符集都有对应的若干个比较规则，如针对二进制编码比较，大小写比较等等。</p><h2 id="MySQL中支持的字符集和排序规则"><a href="#MySQL中支持的字符集和排序规则" class="headerlink" title="MySQL中支持的字符集和排序规则"></a>MySQL中支持的字符集和排序规则</h2><h3 id="utf8和utf8mb4"><a href="#utf8和utf8mb4" class="headerlink" title="utf8和utf8mb4"></a>utf8和utf8mb4</h3><ul><li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</li></ul><p>因为4字节的字符很少，有时可以使用utf8mb3。</p><h3 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h3><p><code>SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</code></p><h3 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h3><p><code>SHOW COLLATION [LIKE 匹配的模式];</code></p><table><thead><tr><th>后缀</th><th>英文释义</th><th>描述</th></tr></thead><tbody><tr><td><code>_ai</code></td><td>accent insensitive</td><td>不区分重音</td></tr><tr><td><code>_as</code></td><td>accent sensitive</td><td>区分重音</td></tr><tr><td><code>_ci</code></td><td>case insensitive</td><td>不区分大小写</td></tr><tr><td><code>_cs</code></td><td>case sensitive</td><td>区分大小写</td></tr><tr><td><code>_bin</code></td><td>binary</td><td>以二进制方式比较</td></tr></tbody></table><h3 id="字符集与比较规则的应用"><a href="#字符集与比较规则的应用" class="headerlink" title="字符集与比较规则的应用"></a>字符集与比较规则的应用</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><code>MySQL</code>有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别：系统变量</li><li>数据库级别：创建库时指定</li><li>表级别：创建表时指定</li><li>列级别：创建表时指定</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>在创建库&#x2F;表&#x2F;列时，若没有指定，默认使用上一级的参数。</li><li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li></ul><h4 id="客户端和服务器通信中的字符集"><a href="#客户端和服务器通信中的字符集" class="headerlink" title="客户端和服务器通信中的字符集"></a>客户端和服务器通信中的字符集</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/f87857b928f84edca6a6cf127b3fda5a_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>MYSQL会使用<code>character_set_client</code>字符集来解码客户端传来的二进制数据，然后将其编码成<code>character_set_connection</code>执行，最后将结果编码成<code>character_set_results</code>返回给客户端。</p><h4 id="比较规则的应用"><a href="#比较规则的应用" class="headerlink" title="比较规则的应用"></a>比较规则的应用</h4><p>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（链表）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、寻找链表中点"><a href="#一、寻找链表中点" class="headerlink" title="一、寻找链表中点"></a>一、寻找链表中点</h1><p>寻找链表中点，是很多链表题解题的关键，重点则在于终止条件和得到的中点位置以及断开连接等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getMid</span><span class="hljs-params">(ListNode head)</span>&#123;<br><span class="hljs-comment">//两个终止条件，避免fast指针出错。</span><br><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(node.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-comment">//可以想象长度为2的链表和长度和3的链表分别会得到什么结果。</span><br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>slow = slow.next;<br>fast = fast.next.next;<br>&#125;<br><span class="hljs-comment">//slow永远在是“中点/右偏中点”的位置。将slow与后面的节点切割，对于只要求分割链表的题目这样操作已经足够。</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> slow.next;<br>    slow.next = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若希望得到绝对中点，实现断开功能，可以采用哑节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//让slow和fast都慢一步，这样slow则是“中点/左偏中点”。需要在初始化时执行。</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>dummy.next = head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br><br><span class="hljs-comment">//可以只让slow慢一步，这样slow就是&#x27;中点/左偏中点的前一个节点&#x27;，便于断开连接</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>dummy.next = head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br></code></pre></td></tr></table></figure><p>若不需要调整链表的结构，只需要节点中顺序摆放的值，也可以不断开链表，只通过设置终止节点来分割，如<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>的特殊解法。</p><h1 id="二、链表反转-x2F-排序"><a href="#二、链表反转-x2F-排序" class="headerlink" title="二、链表反转&#x2F;排序"></a>二、链表反转&#x2F;排序</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></p><blockquote><p>归并排序对链表很有效，通过寻找中点分割左右两侧。</p></blockquote><p>可以联动该题的常规解法：<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>，子顶向下归并排序。也可以子底向上排序，逐渐扩大合并范围即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自顶向下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sort(head);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(node.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//左侧节点排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">leftsort</span> <span class="hljs-operator">=</span> sort(node);<br>        <span class="hljs-comment">//右侧节点排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightsort</span> <span class="hljs-operator">=</span> sort(temp);<br>        <span class="hljs-comment">//合并节点</span><br>        <span class="hljs-keyword">return</span> merge(leftsort,rightsort);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode node1,ListNode node2)</span>&#123;<br>    <span class="hljs-comment">//创建哑节点方便返回。</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> ans;<br>        <span class="hljs-comment">//这里的外循环是左右都有值</span><br>        <span class="hljs-keyword">while</span>(node1 != <span class="hljs-literal">null</span> &amp;&amp; node2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1.val&lt;node2.val)&#123;<br>                pre.next = node1;<br>                node1 = node1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre.next = node2;<br>                node2 = node2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">//然后接上还有值的节点即可</span><br>        pre.next = node1 == <span class="hljs-literal">null</span>?node2:node1;<br>        <span class="hljs-keyword">return</span> ans.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/">2046. 给按照绝对值排序的链表排序</a><br>多指针完成有序移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortLinkedList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, cur = head.next; <br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// cur为非负数时则两个指针向后移动；</span><br>            <span class="hljs-keyword">if</span> (cur.val &gt;= <span class="hljs-number">0</span>)&#123;<br>                pre = pre.next;<br>                cur = pre.next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.val &lt; <span class="hljs-number">0</span>)&#123;<br>                pre.next = cur.next;<br>                cur.next = head;<br>                head = cur;<br>                cur = pre.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p><ol><li>一次遍历，存数组双指针判断</li><li>递归判断</li><li>双指针</li></ol><blockquote><p>递归是反向遍历链表的好方式！可以通过递归先找到尾部节点，然后与外部的节点指针对比交互。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//函数外的节点，代表待比较的头节点</span><br>    ListNode l1;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        l1 = head;<br>        <span class="hljs-keyword">return</span> func(head);<br>    &#125;<br><span class="hljs-comment">//判断节点是否为回文链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">func</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">func</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//通过func递归，直接找到尾节点，然后与外部头节点逐一比较</span><br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>)&#123;<br>            func = func(node.next);<br>        &#125;<br>        <span class="hljs-comment">//如果最后一个节点与头节点相等，则返回true，并移动头节点，此时尾部节点的func出栈，对比新的头节点和倒数第二个尾节点。</span><br>        <span class="hljs-keyword">if</span> (l1.val == node.val &amp;&amp; func)&#123;<br>            l1 = l1.next;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（DFS与BFS）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、DFS与BFS"><a href="#一、DFS与BFS" class="headerlink" title="一、DFS与BFS"></a>一、DFS与BFS</h1><p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a><br>简单的搜索，注意终止条件的写法，由于不需要记录路径，所以不需要使用回溯，成功时直接返回即可。</p><h1 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a><br>先建立数字与字母<code>Map&lt;Integer,List&lt;Character&gt;&gt;</code>，使用一个<code>StringBuilder</code>，每层做循环，添加和删除末尾，当长度达到要求时返回一个记录并保存。<br><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a><br>记录左右括号的数量作为参数传递，左括号数量-右括号数量&gt;&#x3D;0时才能加右括号。<br><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p><blockquote><p>注意复制list的方法：构造函数<code>new ArrayList&lt;T&gt;(Collection&lt;T&gt;)</code></p></blockquote><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a><br><a href="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索 II</a><br>要一次实现对每个单词的匹配，就不要有方向的寻找路径，而是枚举路径，只要判断出有一个单词之后就不会再核对这个路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯，不要对每个单词单独遍历，太慢超时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[][] board;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] _board, String[] words)</span> &#123;<br>        board = _board;<br>        m = board.length; n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (String w : words) set.add(w);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;<br>                sb.append(board[i][j]);<br>                dfs(i, j, sb);<br>                vis[i][j] = <span class="hljs-literal">false</span>;<br>                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, StringBuilder sb)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (set.contains(sb.toString())) &#123;<br>            ans.add(sb.toString());<br>            set.remove(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> i + d[<span class="hljs-number">0</span>], dy = j + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span> || dx &gt;= m || dy &lt; <span class="hljs-number">0</span> || dy &gt;= n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[dx][dy]) <span class="hljs-keyword">continue</span>;<br>            vis[dx][dy] = <span class="hljs-literal">true</span>;<br>            sb.append(board[dx][dy]);<br>            dfs(dx, dy, sb);<br>            vis[dx][dy] = <span class="hljs-literal">false</span>;<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯算法</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（树）</title>
    <link href="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/"/>
    <url>/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h1><h2 id="二叉树遍历、路径与构造"><a href="#二叉树遍历、路径与构造" class="headerlink" title="二叉树遍历、路径与构造"></a>二叉树遍历、路径与构造</h2><h3 id="先中后序遍历"><a href="#先中后序遍历" class="headerlink" title="先中后序遍历"></a>先中后序遍历</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><ol><li>DFS</li><li>迭代，使用队列作为栈，然后让所有左节点入栈，出栈时添加其右节点（及其所有左子节点）到栈中。</li></ol><p><a href="https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树</a></p><blockquote><p>可以将遍历理解成一个回溯的过程！</p></blockquote><p>逐个取出节点，使用链表保存路径上的节点，根据节点的深度判断：</p><ol><li>其是沿着上一个节点的左节点</li><li>之前别的的节点的右节点，此时可不停出列直到找到对应深度的节点。</li></ol><p><a href="https://leetcode.cn/problems/find-leaves-of-binary-tree/">366. 寻找二叉树的叶子节点</a><br>后序遍历，反向求各节点的深度，然后按照深度依次放入结果集即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">//求节点到最近叶子节点的距离，或者叫反深度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//求左节点深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(node.left);<br>        <span class="hljs-comment">//求右节点深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(node.right);<br>        <span class="hljs-comment">//当前节点深度 = 最大深度+1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(l, r) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//如果还没有创建该深度的List，创建一个</span><br>        <span class="hljs-keyword">if</span> (cur &gt;= ret.size()) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-comment">//将该节点添加到对应列表中</span><br>        ret.get(cur).add(node.val);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p><ol><li>层序遍历</li><li>遍历当前节点时，就建立下一层节点之间的关系：为每层建立一个哑节点作为头节点，即可实现子节点的记录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(now != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> pre;<br>            <span class="hljs-keyword">while</span>(now != <span class="hljs-literal">null</span> &amp;&amp; now.left != <span class="hljs-literal">null</span>)&#123;<br>                pre.next = now.left;<br>                pre = pre.next;<br>                pre.next = now.right;<br>                pre = pre.next;<br>                now = now.next;<br>            &#125;<br>            now = index.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iv/">666. 路径总和 IV</a><br>层数小于5和满二叉树的编号，已经提醒了我们可以使用数组来对树进行存储</p><ul><li>先逐个取出节点，保存到数组中</li><li>然后从根节点开始逐层计算分数，未发现叶子节点则结算当前节点，否则累加后等待子节点结算</li></ul><h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><blockquote><p>对于树的问题，要善于使用递归，通过递归传递出子节点的信息以供父节点使用。该题则需要传递出</p><ul><li>子节点能提供的最大path（小于0则提供0）</li><li>子节点及以下节点的可能出现的最大分数</li></ul></blockquote><p><a href="https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/">1530. 好叶子节点对的数量</a><br>迭代，同时返回各叶子节点的深度，数量和可以为结果作出的贡献，必要时建立结构体作为返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> dfs(root, distance);<br>        <span class="hljs-keyword">return</span> pair.count;<br>    &#125;<br><br>    <span class="hljs-comment">// 对于 dfs(root,distance)，同时返回：</span><br>    <span class="hljs-comment">// 1）每个叶子节点与 root 之间的距离</span><br>    <span class="hljs-comment">// 2) 以 root 为根节点的子树中好叶子节点对的数量</span><br>    <span class="hljs-keyword">public</span> Pair <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-type">int</span>[] depths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//如果是叶子节点，直接返回。</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeaf</span> <span class="hljs-operator">=</span> root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (isLeaf) &#123;<br>            depths[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(depths, <span class="hljs-number">0</span>);<br>        &#125;<br><span class="hljs-comment">//</span><br>        <span class="hljs-type">int</span>[] leftDepths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] rightDepths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取左右节点信息</span><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">leftPair</span> <span class="hljs-operator">=</span> dfs(root.left, distance);<br>            leftDepths = leftPair.depths;<br>            leftCount = leftPair.count;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">rightPair</span> <span class="hljs-operator">=</span> dfs(root.right, distance);<br>            rightDepths = rightPair.depths;<br>            rightCount = rightPair.count;<br>        &#125;<br><span class="hljs-comment">//将左右叶子节点的深度加1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; distance; i++) &#123;<br>            depths[i + <span class="hljs-number">1</span>] += leftDepths[i];<br>            depths[i + <span class="hljs-number">1</span>] += rightDepths[i];<br>        &#125;<br><span class="hljs-comment">//统计当前节点为路径节点能得到的好子节点数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= distance; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j + i + <span class="hljs-number">2</span> &lt;= distance; j++) &#123;<br>                cnt += leftDepths[i] * rightDepths[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回更新后的叶子节点深度和数量，所有好子节点数量。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(depths, cnt + leftCount + rightCount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-type">int</span>[] depths;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] depths, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.depths = depths;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、二叉搜索树"><a href="#二、二叉搜索树" class="headerlink" title="二、二叉搜索树"></a>二、二叉搜索树</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a><br>删除二叉搜索树的节点，可以递归解决，可以参考红黑树中的做法，寻找待删除节点的后继节点，使用该后继节点代替原节点！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-comment">//左右递归判断</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>            root.left = deleteNode(root.left, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>            root.right = deleteNode(root.right, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">//需要删除本节点</span><br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>    <span class="hljs-comment">//左右节点存在空节点的情况</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-comment">//左右节点都不为空，则寻找后继节点，即找其右节点的（循环寻找左节点），这与使用迭代来遍历中序遍历二叉树有异曲同工之妙。</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-comment">//删除后继节点</span><br>            root.right = deleteNode(root.right, successor.val);<br>            <span class="hljs-comment">//使用后继节点代替本节点</span><br>            successor.right = root.right;<br>            successor.left = root.left;<br>            <span class="hljs-keyword">return</span> successor;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化写法：使用递归是因为要将子节点操作结果反馈给父节点，若主动记录父节点则可以避免递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, curParent = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.val != key) &#123;<br>            curParent = cur;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; key) &#123;<br>                cur = cur.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>            cur = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.right == <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> cur.right, successorParent = cur;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successorParent = successor;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (successorParent.val == cur.val) &#123;<br>                successorParent.right = successor.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                successorParent.left = successor.right;<br>            &#125;<br>            successor.right = cur.right;<br>            successor.left = cur.left;<br>            cur = successor;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (curParent == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (curParent.left != <span class="hljs-literal">null</span> &amp;&amp; curParent.left.val == key) &#123;<br>                curParent.left = cur;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curParent.right = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/depth-of-bst-given-insertion-order/">1902. 给定二叉搜索树的插入顺序求深度</a><br>使用TreeMap保存值和深度的关系，新值的深度肯定是其左右值深度的较大值+1。</p><p><a href="https://leetcode.cn/problems/split-bst/">776. 拆分二叉搜索树</a><br>注意题目条件，递归解决。</p><p><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></p><ol><li>普通做法是找中点，切断关系然后递归，因为需要根据中点来建立左右节点关系。</li><li>也可以认为有序链表就是二叉搜索树的先序遍历，建立一个假重点建立左节点关系，等左节点建立好之后，就可以获取到中节点的值，最后在建立右节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode globalHead;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        globalHead = head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(index != <span class="hljs-literal">null</span>)&#123;<br>            index = index.next;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> midSearch(<span class="hljs-number">0</span>,end-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">midSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        root.left = midSearch(start,mid-<span class="hljs-number">1</span>);<br>        root.val = globalHead.val;<br>        globalHead = globalHead.next;<br>        root.right = midSearch(mid+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（应用类）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%BA%94%E7%94%A8%E7%B1%BB%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%BA%94%E7%94%A8%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="综合应用类"><a href="#综合应用类" class="headerlink" title="综合应用类"></a>综合应用类</h1><h3 id="对比两个文件-x2F-数组，文件过大时怎么办？"><a href="#对比两个文件-x2F-数组，文件过大时怎么办？" class="headerlink" title="对比两个文件&#x2F;数组，文件过大时怎么办？"></a>对比两个文件&#x2F;数组，文件过大时怎么办？</h3><ul><li>为了解决文件过大，使用分治；</li><li>最后需要将结果合并；</li><li>为了合并结果，可使用hash结构记录每一块的对比结果或对后续的影响；</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（动态规划）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、字符串问题"><a href="#一、字符串问题" class="headerlink" title="一、字符串问题"></a>一、字符串问题</h1><h2 id="通配符问题"><a href="#通配符问题" class="headerlink" title="通配符问题"></a>通配符问题</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/wildcard-matching/">44. 通配符匹配</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//*可以匹配空，所以要找到p的第一个非*的数，其前面的都可以与空匹配。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(p.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//c1 与 c2匹配</span><br>                <span class="hljs-keyword">if</span>(c1 == c2 || c2 == <span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-comment">//c2包含 c1时和 c2不包含c1时</span><br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h2><p>对于寻找字符串的回文子串问题：</p><ul><li>可采用从中心扩展的方式（）</li><li>可使用dp的思想解决</li></ul><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><ol><li>中心扩展，注意剪枝</li><li>dp，处理好索引</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//中心扩展</span><br>String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//边界条件判断</span><br>    <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-comment">//start表示最长回文串开始的位置，</span><br>    <span class="hljs-comment">//maxLen表示最长回文串的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ) &#123;<br>        <span class="hljs-comment">//如果剩余子串长度小于目前查找到的最长回文子串的长度，直接终止循环</span><br>        <span class="hljs-comment">// （因为即使他是回文子串，也不是最长的，所以直接终止循环，不再判断）</span><br>        <span class="hljs-keyword">if</span> (length - i &lt;= maxLen / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i;<br>        <span class="hljs-keyword">while</span> (right &lt; length - <span class="hljs-number">1</span> &amp;&amp; s.charAt(right + <span class="hljs-number">1</span>) == s.charAt(right))<br>            ++right; <span class="hljs-comment">//过滤掉重复的</span><br>        <span class="hljs-comment">//下次在判断的时候从重复的下一个字符开始判断</span><br>        i = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//然后往两边判断，找出回文子串的长度</span><br>        <span class="hljs-keyword">while</span> (right &lt; length - <span class="hljs-number">1</span> &amp;&amp; left &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(right + <span class="hljs-number">1</span>) == s.charAt(left - <span class="hljs-number">1</span>)) &#123;<br>            ++right;<br>            --left;<br>        &#125;<br>        <span class="hljs-comment">//保留最长的</span><br>        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>            start = left;<br>            maxLen = right - left + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//截取回文子串</span><br>    <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h2><h3 id="拼接问题"><a href="#拼接问题" class="headerlink" title="拼接问题"></a>拼接问题</h3><p><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a><br><a href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a><br>使用set判断片段匹配，为每一个字符索引维护一个<code>List&lt;String&gt;</code>，发现匹配后，直接在原<code>String</code>后拼接即可。</p><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></p><blockquote><p>题目要求，最小且最左，使用DP解决时，考虑从左到右，每轮后需要对比看是否能得到更小的窗口结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s2.length();<br>        <span class="hljs-comment">//dp表示s1的前i个包含s2的前j个的初始位置.</span><br>        Integer[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//可以初始化dp[i][0]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">window_size</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//求每个i包含s2的前1,2,3,...m个字符的初始值.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//求s1中i下标之前，包含s2[:j]的起始位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                <span class="hljs-comment">//若s1的第i个刚好等于s2的第j个,则s1前i个包含s2的前j个的起始位置为s1前i-1个包含s2前j-1个的位置</span><br>                <span class="hljs-keyword">if</span>(s1.charAt(i-<span class="hljs-number">1</span>)==s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-comment">//否则,s1前i个包含s2的前j个的起始位置为s1前i-1个包含s2前j个的位置</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果当前i包含s2的前m个字符的初始值不为空,即满足条件,计算窗口大小和左右指针,</span><br>            <span class="hljs-keyword">if</span>(dp[i][m]!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur_window_size</span> <span class="hljs-operator">=</span> i-dp[i][m];<br>                <span class="hljs-keyword">if</span>(cur_window_size&lt;window_size)&#123;<br>                    l = dp[i][m];<br>                    r = i-<span class="hljs-number">1</span>;<br>                    window_size = cur_window_size;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> s1.substring(l,r+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a><br>一开始想到用双指针，dfs函数中判断是否分支计算，但超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        dfs(s,t,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s,String t,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(j == n)&#123;<br>            count++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == m)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(s,t,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>            dfs(s,t,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态规划可以更好的利用子问题的结果简化计算，实现剪枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//边界条件，对任意空串都有一个匹配！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-comment">//不使用i匹配，默认有dp[i-1][j]个匹配。</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                <span class="hljs-comment">//i可以匹配，再加上dp[i-1][j-1]。</span><br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、状态转移类"><a href="#二、状态转移类" class="headerlink" title="二、状态转移类"></a>二、状态转移类</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a><br>状态：1.持有股票 2.不持有股票 3.不持有股票且今日卖出<br><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></p><ul><li>状态：1.今日偷取 2.今日未偷，每日结束时最大价值取决于前一日是否偷和对应金额，因为环形问题分两种情况考虑即可</li><li>状态：记录每日结束时最大即可，每日结束时最大价值取决于前两日。<br><a href="https://leetcode.cn/problems/pizza-with-3n-slices/">1388. 3n 块披萨</a><br>类似打家劫舍，但由于取每块批萨时，不仅取决于前一块，还会影响后一块。由于取走的总数是恒定的，所以根据取走的块数来进行dp。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSizeSlices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] slices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> slices.length;<br>        <span class="hljs-type">int</span>[] slices1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] slices2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-<span class="hljs-number">1</span>];<br>        System.arraycopy(slices,<span class="hljs-number">1</span>,slices1,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        System.arraycopy(slices,<span class="hljs-number">0</span>,slices2,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans1</span> <span class="hljs-operator">=</span> pick(slices1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans2</span> <span class="hljs-operator">=</span> pick(slices2);<br>        <span class="hljs-keyword">return</span> Math.max(ans1,ans2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] slices)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> slices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> (n+<span class="hljs-number">1</span>)/<span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][choose+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxPick</span> <span class="hljs-operator">=</span> Math.min(i,choose);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=maxPick;j++)&#123;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],(i-<span class="hljs-number">2</span>&gt;=<span class="hljs-number">0</span>?dp[i-<span class="hljs-number">2</span>][j-<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>)+slices[i-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][choose];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>由打家结舍2和批萨问题可知，状态转移的前驱状态不仅只能是前一天。</p></blockquote><h1 id="三、数值匹配"><a href="#三、数值匹配" class="headerlink" title="三、数值匹配"></a>三、数值匹配</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a><br>通过处理缩小枚举左指针范围。<br><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a><br>记录各索引元素前递增个数。<br><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a><br>把信封按宽度递增、高度递减排序。实现了每个信封宽度都比前面大或相同，且相同宽度的信封不会装起来。</p><ul><li>直接dp，判断高度，超时！</li><li>直接dp超时的原因在于寻找前一个可以装的信封时是枚举算法，改进：使用一个数组记录 套了i个信封的 的最小信封高度，这是一个递增数组。在判断一个新信封能装多少信封时，搜索刚好低于该高度的最长序列即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分dp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] es)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> es.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-comment">// 由于我们使用了 g 记录高度，因此这里只需将 w 从小到达排序即可</span><br>        Arrays.sort(es, (a, b)-&gt;a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// f(i) 为考虑前 i 个物品，并以第 i 个物品为结尾的最大值</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>        <span class="hljs-comment">// g(i) 记录的是长度为 i 的最长上升子序列的最小「信封高度」</span><br>        <span class="hljs-type">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>        <span class="hljs-comment">// 因为要取 min，用一个足够大（不可能）的高度初始化</span><br>        Arrays.fill(g, Integer.MAX_VALUE); <br>        g[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, len = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 对于 w 相同的数据，不更新 g 数组</span><br>            <span class="hljs-keyword">if</span> (es[i][<span class="hljs-number">0</span>] != es[j][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">// 限制 j 不能越过 i，确保 g 数组中只会出现第 i 个信封前的「历史信封」</span><br>                <span class="hljs-keyword">while</span> (j &lt; i) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> f[j], cur = es[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (prev == len) &#123;<br>                        <span class="hljs-comment">// 与当前长度一致了，说明上升序列多增加一位</span><br>                        g[len++] = cur;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 始终保留最小的「信封高度」，这样可以确保有更多的信封可以与其行程上升序列</span><br>                        <span class="hljs-comment">// 举例：同样是上升长度为 5 的序列，保留最小高度为 5 记录（而不是保留任意的，比如 10），这样之后高度为 7 8 9 的信封都能形成序列；</span><br>                        g[prev] = Math.min(g[prev], cur);<br>                    &#125;<br>                    j++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 二分过程</span><br>            <span class="hljs-comment">// g[i] 代表的是上升子序列长度为 i 的「最小信封高度」</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 令 check 条件为 es[i][1] &lt;= g[mid]（代表 w 和 h 都严格小于当前信封）</span><br>                <span class="hljs-comment">// 这样我们找到的就是满足条件，最靠近数组中心点的数据（也就是满足 check 条件的最大下标）</span><br>                <span class="hljs-comment">// 对应回 g[] 数组的含义，其实就是找到 w 和 h 都满足条件的最大上升长度</span><br>                <span class="hljs-keyword">if</span> (es[i][<span class="hljs-number">1</span>] &lt;= g[mid]) &#123;<br>                    r = mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新 f[i] 与答案</span><br>            f[i] = r;<br>            ans = Math.max(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量</a><br>按攻击力升序，按防御力降序即可判断是否有角色比本角色弱。<br>本题求的是弱角色的数量，而不是求比各个角色弱的角色数量，计算时需要去重。<br>可以使用队列记录防御力，若当前角色防御力高于队尾角色，则应该将尾部不断出队，然后将当前角色入队。每出队一个角色即有一个弱角色。</p><h1 id="四、双向dp"><a href="#四、双向dp" class="headerlink" title="四、双向dp"></a>四、双向dp</h1><p>通过左右指针获取各索引元素左右侧元素状态<br><em>例题</em><br><a href="https://leetcode.cn/problems/longest-mountain-in-array/">845. 数组中的最长山脉</a><br>类似接雨水题。</p><h1 id="五、分治型"><a href="#五、分治型" class="headerlink" title="五、分治型"></a>五、分治型</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球</a></p><h1 id="六、矩阵问题"><a href="#六、矩阵问题" class="headerlink" title="六、矩阵问题"></a>六、矩阵问题</h1><p>一般求矩阵和等情况，需要通过预处理，避免大量计算。<br><em>例题</em><br><a href="https://leetcode.cn/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵</a><br>暴力解：</p><ul><li>固定上边<ul><li>扩大下边，利用上一轮dp情况减少计算量。<ul><li>上下边中间的各列和都计算出来后，转化为求一维数组的最大数值。</li></ul></li></ul></li></ul><p><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值</a><br>与最大子矩阵类似，使用treeset记录前缀和数值，实现计算最大数值不超过K的逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（数组）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="数组本身性质"><a href="#数组本身性质" class="headerlink" title="数组本身性质"></a>数组本身性质</h2><p>数组本身的索引的具有信息量，对于很多数组类题目要求时间复杂度O(n)，常量空间复杂度的问题，可以考虑把遍历信息保存在数组内部：</p><ul><li>对数组指定索引做标记：加负号；</li><li>将数组元素与指定索引元素做交换；</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a><br><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></p><ol><li>标记出现了的数的正负号</li><li>将出现了的数交换到对于索引上</li></ol><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>数组中的排序有以下功能：</p><ul><li>相同的数字在一起，实现去重</li><li>连续的数字在一起，可以查看连续序列</li><li>两个排序数组对比可以快速比较重合数（使用双指针）</li><li>利用排序可以快速筛选结果</li></ul><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a><br><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a><br>本质是硬解，但通过排序保证第一个元素永远不重复，还可以通过一些手段减枝。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a><br>建立绝对值和索引的映射，根据绝对值排序，根据索引取真实值。<br><a href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/">2171. 拿出最少数目的魔法豆</a><br>拿出最少的数目 &#x3D; 留下最多的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumRemoval</span><span class="hljs-params">(<span class="hljs-type">int</span>[] beans)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> beans.length;<br>        Arrays.sort(beans);<br>        <span class="hljs-comment">//max表示最多留下的豆子的数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//sum表示所有豆子数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum += beans[i];<br>            max = Math.max(max,(<span class="hljs-type">long</span>)beans[i] * (n-i));<br>        &#125;<br>        <span class="hljs-comment">//最少拿走的豆子 = 总豆子数 - 最多留下的豆子数。</span><br>        <span class="hljs-keyword">return</span> sum-max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="禁止排序"><a href="#禁止排序" class="headerlink" title="禁止排序"></a>禁止排序</h3><p>对于要求n时间复杂度的数组，优先考虑能否利用数组性质保存遍历结果，否则可以通过set等集合保存遍历结果<br><em>例题</em><br><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>对于数组中的滑动窗口首先要注意问题的转化：</p><ul><li>对于<strong>从数组左右两端操作的问题能否转化为对数组中的一个滑动窗口</strong>的问题，如《将x减到0的最小操作数》</li><li>对于窗口内信息的计算能否转化为对窗口两端存储数据的相减，如使用<strong>预处理</strong>方式处理每个元素左边&#x2F;右边的状态，如《爱生气的书店老板》</li><li>差分数组常用于区域<strong>翻转</strong>问题：如将某个数组的一部分翻转（修改正负号或1&#x2F;0变换），判断相邻数的情况。</li></ul><h3 id="静态滑动窗口"><a href="#静态滑动窗口" class="headerlink" title="静态滑动窗口"></a>静态滑动窗口</h3><p>窗口大小不变。<br>每次滑动伴随元素的新增和删除，一般需要维护窗口的性质：</p><ul><li>维护窗口内字符数量等统计信息的：使用如hash，数组等的数据结构维护；</li><li>维护窗口内最大值，最小值的：使用单调队列（LinkedList结构）。</li></ul><blockquote><p>使用数组维护数量时注意：<br>全大&#x2F;小写字符计数：使用<code>int[26]</code>，char-‘a’或-‘A’<br>大小写都有：使用<code>int[58]</code>，char-‘A’<br>全字符：使用<code>int[128]</code></p></blockquote><h4 id="维护窗口统计信息"><a href="#维护窗口统计信息" class="headerlink" title="维护窗口统计信息"></a>维护窗口统计信息</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串</a><br>可以使用一个数维护重复值，一个Hash&#x2F;数组维护字符的数量<br><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a><br>使用预处理数组记录可能获得的顾客<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><ol><li>使用计数法，并且不收缩滑动窗口。</li><li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li></ol><h4 id="维护窗口最大值"><a href="#维护窗口最大值" class="headerlink" title="维护窗口最大值"></a>维护窗口最大值</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a><br>右指针元素比队列尾部大则先循环pollLast再OfferLast，即将移出的左指针元素刚好等于队头时pollFirst<br><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将x减到0的最小操作数</a><br><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a><br>使用有序集合维护窗口的最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Long&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">ceiling</span> <span class="hljs-operator">=</span> set.ceiling((<span class="hljs-type">long</span>) nums[i] - (<span class="hljs-type">long</span>) t);<br>            <span class="hljs-keyword">if</span> (ceiling != <span class="hljs-literal">null</span> &amp;&amp; ceiling &lt;= (<span class="hljs-type">long</span>) nums[i] + (<span class="hljs-type">long</span>) t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            set.add((<span class="hljs-type">long</span>) nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                set.remove((<span class="hljs-type">long</span>) nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>回顾TreeMap的API<br>map.ceilingEntry(key)&#x2F;&#x2F;刚好或大于该key的Entry<br>map.floorEntry(key)&#x2F;&#x2F;刚好或小于该key的Entry<br>map.firstEntry(key)&#x2F;&#x2F;最小的Entry<br>map.lastEntry(key)&#x2F;&#x2F;最大的Entry<br>HashSet同理。</p></blockquote><p><a href="https://leetcode.cn/problems/sliding-window-median/">480. 滑动窗口中位数</a><br>通过大堆+小堆的堆顶实现取中位数，然后维护有效元素的平衡<br>移出元素时：</p><ul><li>直接使用remove(Priority提供了这个方法)</li><li>用HashMap记录过期元素，延迟删除堆顶元素</li></ul><h4 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K连续位的最小翻转次数</a></p><blockquote><p>假设从index&#x3D;0开始判断，每次翻转只翻转index之后长度为k的区域</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minKBitFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-comment">//d[x]记录了A[x]相对A[x-1]翻转了多少次，即d[i] = re[i]-re[i-1]</span><br>    <span class="hljs-comment">//那么第i个数的旋转次数为re[i] = d[0]+d[1]+...+d[i]</span><br>    <span class="hljs-comment">//只需要维护re[i]，即可直到每个位置是否还需要翻转</span><br>        <span class="hljs-type">int</span>[] d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> count= <span class="hljs-number">0</span> ,sumReA= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>        <span class="hljs-comment">//sumReA表示当前i位旋转的次数</span><br>            sumReA +=d[i];<br>            <span class="hljs-comment">//若当前旋转结果为0，则需要以当前索引为窗口头部进行一次旋转</span><br>            <span class="hljs-keyword">if</span>(((sumReA&amp;<span class="hljs-number">1</span>)^A[i]) ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//若后续已经不能旋转了，说明无法实现</span><br>                <span class="hljs-keyword">if</span>(i+K&gt;A.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//当前位旋转。</span><br>                <span class="hljs-comment">//d[i]+=1; 可省略，后续用不到</span><br>                <span class="hljs-comment">//i+K相对i+K-1少旋转一次</span><br>                d[i+K]-=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//由于d[i]+=1，修正sumReA</span><br>                sumReA+=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//结果++</span><br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态滑动窗口"><a href="#动态滑动窗口" class="headerlink" title="动态滑动窗口"></a>动态滑动窗口</h3><p>动态滑动窗口会在合适的时候扩张：</p><ul><li>使用双指针做窗口条件判断，每循环一次右指针向右扩展一单位，然后考虑左边界的情况。</li><li>使用动态规划的方法维护窗口性质，本质就是用数组保存右指针在某处时的窗口状态。</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a><br>不满足要求后，不根据奇偶判断状态，而是根据上一个序列顺序判断，省去一次遍历，不符合要求时，左指针 &#x3D;&#x3D; 右指针<br><a href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a><br>先找到区间，该区间的右扩展全部满足条件，然后收缩左端，每收缩一次计算一次以当前左指针为子数组左端能够得到的子数组数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> answer=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//abc 的计数</span><br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">//窗口左沿</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//窗口右沿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;end&lt;s.length();end++)&#123;<br>            <span class="hljs-type">char</span> charAtEnd=s.charAt(end);<br>            count[charAtEnd-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">while</span>(count[<span class="hljs-number">0</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">2</span>]&gt;=<span class="hljs-number">1</span>)&#123;<br>                answer+=s.length()-end;<br>                <span class="hljs-type">char</span> charAtStart=s.charAt(start);<br>                count[charAtStart-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                start++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a><br>动态滑动窗口+有序集合</p><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a><br>自己做时总想记录特殊字符的位置，实现快速搜索，实际上直接遍历过去速度更快。另外，数组总是比hash更方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-comment">//t中出现字符记录</span><br>    <span class="hljs-type">int</span>[] time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> t.length();<br><br>    <span class="hljs-comment">//结果记录</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length()+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;need;i++)&#123;<br>        mark[t.charAt(i)] = <span class="hljs-literal">true</span>;<br>        time[t.charAt(i)]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>        time[s.charAt(i)]--;<br>        <span class="hljs-keyword">if</span>(mark[s.charAt(i)]&amp;&amp;time[s.charAt(i)]&gt;=<span class="hljs-number">0</span>)&#123;<br>            need--;<br>        &#125;<br>        <span class="hljs-comment">//若满足条件，收缩左侧到刚好不满足条件，并计算值</span><br>        <span class="hljs-keyword">if</span>(need == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(need == <span class="hljs-number">0</span>)&#123;<br>                time[s.charAt(start)]++;<br>                <span class="hljs-keyword">if</span>(mark[s.charAt(start)]&amp;&amp;time[s.charAt(start)]&gt;<span class="hljs-number">0</span>)&#123;<br>                    need++;<br>                &#125;<br>                start++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i-start+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(l&lt;length)&#123;<br>                left = start-<span class="hljs-number">1</span>;<br>                right = i+<span class="hljs-number">1</span>;<br>                length = l;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(length == s.length()+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(left,right);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a><br>动态规划：由于每个状态只依赖前一个状态，所以也可以使用变量代替。<br>同时计算最小、最大和的情况即可，主要排除计算最小和时选择了所有数字的情况。</p><h3 id="子数组与问题转化"><a href="#子数组与问题转化" class="headerlink" title="子数组与问题转化"></a>子数组与问题转化</h3><p>一般我们有如下定义：<br><strong>子数组</strong>：连续的子数组。<br><strong>子序列</strong>：不连续的子数组。</p><p>求满足要求子数组的问题一般分两类解决方案：</p><ul><li>滑动窗口</li><li>问题转化<ul><li><strong>恰好问题转化为最大-最大</strong></li><li><strong>求最长满足条件的子数组长度问题可以不缩小窗口</strong></li><li><strong>元素抵消</strong></li></ul></li><li>动态规划（见动态规划章节）</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">795. 区间子数组个数</a><br>问题转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">return</span> count(A, R) - count(A, L-<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//计算最大值小于bound的子数组个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> bound)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: A) &#123;<br>            cur = x &lt;= bound ? cur + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            ans += cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a><br>问题转化 + 动态滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//把恰好问题转化为最大-最大</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysWithKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//子数组中存在不同整数数量最大为k的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-comment">//记录窗口中元素数量</span><br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 里不同整数的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>        <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>        <span class="hljs-comment">//添加right元素</span><br>            <span class="hljs-keyword">if</span> (freq[A[right]] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>            freq[A[right]]++;<br>            right++;<br>            <span class="hljs-comment">//若不再满足条件，收缩左端</span><br>            <span class="hljs-keyword">while</span> (count &gt; K) &#123;<br>                freq[A[left]]--;<br>                <span class="hljs-keyword">if</span> (freq[A[left]] == <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献，解释一下，相当于[left,right-1]区间满足count == K，此时以right-1为右节点，向左延申到left，有right-left个数（right-1是因为本轮的right加过1了）</span><br>            res += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a><br>以右指针为目标字符，只需要考虑维护这个最大长度，不用缩短区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> len;<br>        &#125;<br>        <span class="hljs-type">char</span>[] array = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//maxCount表示在满足条件的区间内出现过的最多的相同字符数量，即maxCount+k 一般等于 当前窗口大小。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">while</span>(right&lt;len)&#123;<br>        <span class="hljs-comment">//右端字符数量更新</span><br>            freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            <span class="hljs-comment">//看右端字符数量是否超过了历史最多相同字符数量，</span><br>            maxCount = Math.max(maxCount,freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>            right++;<br>            <span class="hljs-comment">//如果区间内右端字符数量+可修改的字符数量比区间小，说明这个区间无法满足条件，左端需要移动来满足条件，这里没有使用where。</span><br>            <span class="hljs-keyword">if</span>(maxCount+k&lt;right-left)&#123;<br>                freq[array[left]-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//确认当前区间的大小</span><br>            res = Math.max(right-left,res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/A1NYOS/">剑指 Offer II 011. 0 和 1 个数相同的子数组</a><br>使用状态量表示1和0数量的差别，通过预处理可以找到匹配的字符串，这里使用HashMap记录相同状态出现的最左索引更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        map.put(counter, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                counter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.containsKey(counter)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> map.get(counter);<br>                maxLength = Math.max(maxLength, i - prevIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(counter, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-all-good-indices/">2420. 找到所有好下标</a><br>双指针左右遍历，使用两个数组分别记录连续递增&#x2F;减数量。</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><ol><li>使用计数法，并且不收缩滑动窗口。</li><li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li></ol><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p>一般为事件在指定时间&#x2F;坐标必然发生&#x2F;结束，需要计算重合情况。<br><em>例题</em><br><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></p><ol><li>可以使用<strong>优先队列</strong>，将所有会议的开始，结束按时间发送顺序排列，然后遍历处理。</li><li>由于题目只要求最多同时需要多少间，因此可以只用<strong>最小堆</strong>记录结束时间，然后采用延迟删除策略。</li><li>创建会议开始，结束时间的有序数组，使用双指针。</li></ol><p><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></p><ul><li>在插入区间的左侧且无交集的区间可以直接添加。</li><li>在插入区间的右侧且无交集的区间也可以直接添加。</li><li>其他情况表示有交集，合并方式是取最左和最右侧。<ul><li>合并可能多次发生，在多次合并后应该确保合并区间被添加。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//表示是否</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">placed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>        <span class="hljs-comment">// 在插入区间的右侧且无交集</span><br>            <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; right) &#123;<br>                <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>                <span class="hljs-keyword">if</span> (!placed) &#123;<br>                    ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>                    placed = <span class="hljs-literal">true</span>;                    <br>                &#125;<br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                <span class="hljs-comment">// 在插入区间的左侧且无交集</span><br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 与插入区间有交集，计算它们的并集</span><br>                left = Math.min(left, interval[<span class="hljs-number">0</span>]);<br>                right = Math.max(right, interval[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>        <span class="hljs-keyword">if</span> (!placed) &#123;<br>            ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ansList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ansList.size(); ++i) &#123;<br>            ans[i] = ansList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/">LeetCode讲解</a></p><blockquote><p>树状数组是一种很巧妙的数据结构，通过树状数组可以很方便的解决<strong>前缀和</strong>问题和<strong>单点更新</strong>。</p></blockquote><p><img src="/Pasted%20image%2020230209172457.png"><br>树状数组的本质是一种通过 树状组织 数组区间和 的数据结构 可以在更新数组节点时依次更新树结构，方便前缀和的查询。</p><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p>得到二进制数x的最低位1的值。相当于计算出了该数在二进制下的粒度&#x2F;最小单位。</p><ul><li>节点依次减去其最小二进制单位即得到求和所需的节点</li><li>节点加上其最小二进制单位即可得到其父节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="前缀和查询"><a href="#前缀和查询" class="headerlink" title="前缀和查询"></a>前缀和查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从右到左查询</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//从节点开始逐一加上前面的节点</span><br>        sum += tree[i];<br>        i -= lowbit(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在要求前6项的和，6的二进制为0110，可分解为0010+0100，对应的是2+4，可以使用C4+C6来表达这个前6项的和。</p><h4 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从节点本身开始更新父节点</span><br>    <span class="hljs-keyword">while</span> (i &lt;= len) &#123;<br>    tree[i] += delta;<br>    i += lowbit(i);<br>&#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>树状数组最小索引为1</strong>，所以创建时长度要+1。然后为每个索引初始化数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FenwickTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-built_in">this</span>.len = nums.length + <span class="hljs-number">1</span>;<br>    tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        update(i, nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>例题</em><br><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a><br>本题很容易想到从右到左遍历，但如何维护右边所有数字的值的大小和数量是一个问题。</p><ul><li>先使用有序集合，对所有元素进行排序，得到每个元素大小对应的树状数组索引排名并使用Hash记录。(树状数组的索引是连续的，但索引所代表的值大小不需要连续，只需要保持大小关系即可。)</li><li>从右到左遍历，通过元素大小获取在树状数组下的索引后，获取值，并更新。</li></ul><p><a href="https://leetcode.cn/problems/queries-on-a-permutation-with-key/">1409. 查询带键的排列</a></p><ul><li>扩充数组长度并使用树状数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] processQueries(<span class="hljs-type">int</span>[] queries, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(m + n);<br>        <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            pos[i] = n + i;<br>            bit.update(n + i, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pos[queries[i]];<br>            bit.update(cur, -<span class="hljs-number">1</span>);<br>            ans[i] = bit.query(cur);<br>            cur = n - i;<br>            pos[queries[i]] = cur;<br>            bit.update(cur, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br>  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += a[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            a[x] += dt;<br>            x += lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/">1664. 生成平衡数组的方案数</a><br>预处理奇数和偶数之和数组，然后枚举删除点。<br><a href="https://leetcode.cn/problems/count-good-meals/">1711. 大餐计数</a><br>Hash记录数量，简单遍历即可，每道餐品与前面餐品匹配，不会出现重复情况。</p><blockquote><p>int MOD &#x3D; (int)1e9+7;</p></blockquote><p><a href="https://leetcode.cn/problems/number-of-subarrays-having-even-product/">2495. 乘积为偶数的子数组数</a><br>只要子数组中有偶数，乘积就为偶数，计算以偶数作为结尾的数组即可。</p><div class="note note-primary">            <p>总结：</p><ol><li>看排序能不能改善计算！</li><li>看问题能不能转化<ul><li>如最多与最少的转化</li><li>两侧与中间区间的转化</li><li><strong>恰好</strong>与<strong>最大-最大</strong>的转化</li><li>是否能使用预处理数组</li></ul></li><li>对于滑动窗口<ul><li>是否一定要缩小窗口</li><li>统计满足条件的子数组时，以左&#x2F;右端点作为开始&#x2F;结束点。</li></ul></li></ol>          </div><hr><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>字符串的很多题目与数组的处理方式类似，因为字符串本身就是一个字符数组。</p><div class="note note-success">            <p>本篇主要为利用双指针移动判定条件解决问题。<br>对于子序列、回文等问题见动态规划篇。</p>          </div><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a><br>将具有相同元素的单词分类，对各个字符串分别使用字符数组排序，将排序后的单词作为key做对比。</p><h2 id="语义解释"><a href="#语义解释" class="headerlink" title="语义解释"></a>语义解释</h2><p>一般使用双指针，对于计算类需要灵活应用栈，滑动窗口等方法解决。<br><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a><br>类似于操作数栈，但带有正负号，且记录上一次的符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将遇到的数压栈，碰到乘除时出栈计算再压栈，记录每个数前面的符号。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//第一个数前符号为正</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">preSign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">//若是数字，则当前数变化</span><br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>                num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">//若是符号，说明当前数字可以入栈了</span><br>            <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//根据符号选择入栈的真实值</span><br>                <span class="hljs-keyword">switch</span> (preSign) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        stack.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        stack.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        stack.push(stack.pop() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stack.push(stack.pop() / num);<br>                &#125;<br>                preSign = s.charAt(i);<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            ans += stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a><br>可以正向使用栈遍历，然后对比栈；<br>也可以逆向遍历，双指针一次完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> S.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> T.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">skipS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//从右往左移动到第一个有效字符，注意，若没有有效字符了，会变成负数，从而终止。</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipS++;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipS--;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (T.charAt(j) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipT++;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipT--;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//两者都有有效字符，则比较</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            <span class="hljs-comment">//至少有一个已经没有字符了，如果另外一个还有字符，则返回false，当然如果都小于0，可以返回true，但不用写这个逻辑了。</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="比较问题"><a href="#比较问题" class="headerlink" title="比较问题"></a>比较问题</h3><p>一般是双指针，但可以注意循环策略。<br><a href="https://leetcode.cn/problems/long-pressed-name/">925. 长按键入</a><br>判断对比结束是比较难的，这里以i指针作为考察，如果遍历完成后，i指针指向了字符串末尾就算对比成功。<br>此外，return false包含了很多失败情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLongPressedName</span><span class="hljs-params">(String name, String typed)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; typed.length()) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; name.length() &amp;&amp; name.charAt(i) == typed.charAt(j)) &#123;<br>                i++;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; typed.charAt(j) == typed.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == name.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>到这种双指针对比的问题，很容易遇到很多边界条件，如一个结束了另外一个没结束要接着判断边界等情况：<br>1）<code>while(index1&lt;n1 &amp;&amp; index2&lt;n2)</code>，常规思路，还需要额外判断两者是否到达结束点。<br>2）在一个指针的循环体内判断另一个指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1)&#123;<br><span class="hljs-keyword">if</span>(index2&lt;n2)&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）通过if处理都在界内的情况，然后处理有指针不在界内的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1 || index2&lt;n2)&#123;<br><span class="hljs-keyword">if</span>(index1&lt;n1 &amp;&amp; index2&lt;n2)&#123;<br><span class="hljs-comment">//代码，</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="轮转问题"><a href="#轮转问题" class="headerlink" title="轮转问题"></a>轮转问题</h3><p><a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSubstringInWraproundString</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (p.charAt(i) - p.charAt(i - <span class="hljs-number">1</span>) + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 字符之差为 1 或 -25</span><br>                ++k;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k = <span class="hljs-number">1</span>;<br>            &#125;<br>            dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = Math.max(dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>], k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了去重，求以每个字符为结尾的数组长度最大为多少，最后求和。</p><blockquote><p>z-a相连问题，即两字符之间的差为1或-25，可以将其转化为以下式子：<br>（p.charAt(i) - p.charAt(i - 1) + 26) % 26 &#x3D;&#x3D; 1<br>因为25与-1相差26，将符号修正后对26求余时结果肯定一样。</p></blockquote><p><a href="https://leetcode.cn/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></p><blockquote><p>轮转问题一般可以考虑扩充原<strong>数组&#x2F;字符</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFlipedString</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-keyword">if</span>(s2.length() != n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1+s1;<br>        <span class="hljs-keyword">return</span> s3.contains(s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串替换-x2F-编码"><a href="#字符串替换-x2F-编码" class="headerlink" title="字符串替换&#x2F;编码"></a>字符串替换&#x2F;编码</h2><p>一般题目为允许&#x2F;必须替换字符串中的某些字符，以达到某种条件。<br>滑动窗口类题型可见上文，下面为<strong>规律题</strong>：<br><a href="https://leetcode.cn/problems/1-bit-and-2-bit-characters/">717. 1 比特与 2 比特字符</a></p><ol><li>正向推理：遇到0走一格，遇到1走两格，判断最后一次走的是几格。</li><li>反向推理：<ul><li>如果结尾前为0，则必然为true</li><li>如果结尾前是1，则必然为11<ul><li>这个11的前面只能接着放11或0结尾的字符，所以判断结尾0到倒数第二个0中间1的个数是否为偶数。</li></ul></li></ul></li></ol><p><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a><br>由题可知：<br>L可以与右侧的X交换，R可以与左侧的X交换，但L不可以跨越R。<br>即L可以右移，R可以左移，L和R的顺序不能改变。<br>那么可以忽略X，如果找到对应的L，原始L应该在变化后的L的左侧，原始R应该在变化后的R的右侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (start.charAt(i) != end.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> start.charAt(i);<br>                <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; i &lt; j) || (c == <span class="hljs-string">&#x27;R&#x27;</span> &amp;&amp; i &gt; j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                i++;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (end.charAt(j) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-IP</title>
    <link href="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/"/>
    <url>/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、IP概念"><a href="#一、IP概念" class="headerlink" title="一、IP概念"></a>一、IP概念</h1><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong><br><strong>MAC 的作用是实现「直连」的两个设备之间通信，而 IP 负责在「没有直连」的两个网络之间进行通信传输。</strong><br>在网络中数据包传输中：<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><h1 id="二、IP基础概念"><a href="#二、IP基础概念" class="headerlink" title="二、IP基础概念"></a>二、IP基础概念</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/4.webp"><br>IP最大值为：<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5.webp"></p><h2 id="分类地址"><a href="#分类地址" class="headerlink" title="分类地址"></a>分类地址</h2><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7.webp"><br><strong>主机号全为 1 表示广播 和 全为 0 表示网络。</strong></p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><div class="note note-primary">            <p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p>          </div><blockquote><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0&#x2F;24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（<strong>由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。</strong>） 。</li></ul></blockquote><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><p>而D类和E类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/12.webp"></p><blockquote><p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p></blockquote><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13.webp"></p><p><strong>多播中，后面的28位是多播的组编号。</strong></p><p><em>缺点一</em><br><strong>同一网络下没有地址层次</strong></p><p><em>缺点二</em><br><strong>不能很好的与现实网络匹配</strong>。</p><h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18.webp"></p><h2 id="公有IP地址与私有IP地址"><a href="#公有IP地址与私有IP地址" class="headerlink" title="公有IP地址与私有IP地址"></a>公有IP地址与私有IP地址</h2><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/22.webp"></p><blockquote><p>公有 IP 地址由谁管理呢？<br>公有 IP 地址是由 <code>ICANN</code> 组织管理，中文叫「互联网名称与数字地址分配机构」。</p></blockquote><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/25.webp"></p><blockquote><p><strong>127.0.0.1 作为环回地址</strong>，这是不会流向网络。</p></blockquote><h2 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h2><p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，如FDDI数据链路 MTU 4352、以太网的MTU是1500字节等。<br>那么当IP数据包大小大于MTU时，IP数据包就会被分片。</p><p>在分片传输中，一旦某个分片丢失，则会造成整个IP数据报作废，所以 TCP 引入了<code>MSS</code>也就是在TCP层进行分片不由IP层分片，那么对于UDP我们尽量不要发送一个大于<code>MTU</code>的数据报文。</p><h2 id="IPv6-基本认识"><a href="#IPv6-基本认识" class="headerlink" title="IPv6 基本认识"></a>IPv6 基本认识</h2><p>IPv6 的地址是 <code>128</code> 位的，每 16 位作为一组，每组用冒号 「:」 隔开。</p><blockquote><p>IPv4 和 IPv6 不能相互兼容</p></blockquote><p>IPv6 的地址主要有以下类型地址：</p><ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/29.webp"><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/30.webp"></p><ul><li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4没有此类型。</li><li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于IPv4的私有 IP</li><li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于IPv4的公有IP</li></ul><h3 id="IPv6首部"><a href="#IPv6首部" class="headerlink" title="IPv6首部"></a>IPv6首部</h3><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/31.webp"></p><ul><li><strong>取消了首部校验和字段。</strong>（数据链路和传输层都校验，这里就省略了）</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong>（路由器不再可以分片，只允许源与目标主机分片重组）</li><li><strong>取消选项字段。</strong>（变成了下一个首部）。</li></ul><h1 id="三、IP协议相关技术"><a href="#三、IP协议相关技术" class="headerlink" title="三、IP协议相关技术"></a>三、IP协议相关技术</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>那么实现这一技术的就是 <strong>DNS 域名解析</strong>，DNS 可以将域名网址自动转换为具体的 IP 地址。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/33.webp"><br>DNS的域名解析方式是迭代而不是递归（<strong>只指路不带路</strong>）。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>已知 IP 求 MAC 地址。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/34.webp">两ARP是借助<strong>ARP请求与ARP响应</strong>种类型的包确定 MAC 地址的。</p><ul><li>主机会通过<strong>广播发送ARP请求</strong>，这个包中包含了想要知道的 MAC 地址的主机IP地址。</li><li>当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的 MAC 地址塞入<strong>ARP响应包</strong>返回给主机。</li></ul><h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>那 RARP 协议正好相反，它是<strong>已知 MAC 地址求 IP 地址</strong>。</p><p>通常这需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li><li>然后设备根据该回复设置自己的IP地址。</li></ul><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/36.webp"></p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong>，<strong>UDP广播</strong>。</li><li>服务器<strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应，<strong>UDP广播</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数，<strong>UDP广播</strong>。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数，<strong>UDP广播</strong>。</li></ul><p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li></ul><div class="note note-primary">            <ol><li>DHCP交互都是UDP报文</li><li>首次交互根据事务ID维持沟通独立性</li><li>各DHCP发送自己准备分配的相关信息（提供的地址等），客户端选择后，服务端再确认。</li></ol>          </div><p>如何实现大网段的IP地址分发：</p><blockquote><p><strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p></blockquote><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/37.webp"></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p><strong>网络地址转换 NAT</strong>，对外部通信时，把私有 IP 地址转换成公有 IP 地址，缓解了IP地址不够的问题。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/38.webp"><br>而把 IP 地址 + 端口号一起进行转换的技术叫<strong>网络地址与端口转换 NAPT。</strong><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/39.webp"><br><strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong></p><p>这种转换表在 NAT 路由器上自动生成。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>IPv6</li><li>NAT穿透技术：网络应用程序主动发现自己位于NAT设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目。</li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。<br><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/40.webp"></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><blockquote><p>IGMP与ICMP毫无关系</p></blockquote><p>既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/42.webp"><br><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p><ul><li>主机可以使用IGMP报文向路由器申请加入和退出组播组。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><em>常规查询与响应和离开组播组</em><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/43.webp"></p><ol><li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li><li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）<ul><li>如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li></ul></li><li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li></ol><div class="note note-primary">            <p>简而言之，主机向路由器发送成员关系报告报文后，表示该路由器的直连主机中有某个组播的成员，此后路由器就会转发这个组播。</p>          </div><p><em>离开组播组工作机制</em><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/44.webp"></p><ol><li>主机1要离开组播组，发送给网段内所有路由器</li><li>路由器询问是否还有该组播成员</li><li>若有，则之后会继续转发该组播消息；否则，不再转发。</li></ol><h1 id="四、PING的原理"><a href="#四、PING的原理" class="headerlink" title="四、PING的原理"></a>四、PING的原理</h1><p>ping 是基于 <code>ICMP</code> 协议工作的。<br>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5-1.webp"></p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/6.webp"></li></ul><h2 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h2><p>回送消息 —— 类型 <code>0</code>（回送响应）和 <code>8</code>（回送请求）<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7-1.webp"><br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/8.webp"><br>相比原生的 ICMP，这里多了两个字段：</p><ul><li><strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li><strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><h2 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h2><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>目标不可达消息 —— 类型 为 <code>3</code></li><li>原点抑制消息 —— 类型 <code>4</code></li><li>重定向消息 —— 类型 <code>5</code></li><li>超时消息 —— 类型 <code>11</code></li></ul><h3 id="不可达分类"><a href="#不可达分类" class="headerlink" title="不可达分类"></a>不可达分类</h3><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/9.webp"><br><em>网络不可达</em><br>路由表匹配不到</p><p><em>主机不可达</em><br>找得到网络，但找不到主机</p><p><em>协议不可达</em><br>对端主机的防火墙已经禁止TCP协议访问等情况</p><p><em>端口不可达</em><br>通过防火墙，但没有进程监听目标端口</p><p><em>需要进行分片但设置了不分片</em><br>组件路由器由于不分片政策直接丢弃IP分组</p><h4 id="原点抑制"><a href="#原点抑制" class="headerlink" title="原点抑制"></a>原点抑制</h4><p>原点抑制消息（ICMP Source Quench Message）—— 类型 <code>4</code><br>通知主机线路拥堵，需要增大IP包传输间隔</p><blockquote><p>由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p></blockquote><h4 id="重定向消息"><a href="#重定向消息" class="headerlink" title="重定向消息"></a>重定向消息</h4><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code><br>路由器发现不是最优路径，则返回重定向消息给主机。</p><h4 id="超时消息"><a href="#超时消息" class="headerlink" title="超时消息"></a>超时消息</h4><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code><br>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><h2 id="Ping-请求报文的应用"><a href="#Ping-请求报文的应用" class="headerlink" title="Ping-请求报文的应用"></a>Ping-请求报文的应用</h2><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13-1.webp"></p><p>整体流程：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/17.webp"></p><h2 id="traceroute—差错报文类型的使用"><a href="#traceroute—差错报文类型的使用" class="headerlink" title="traceroute—差错报文类型的使用"></a>traceroute—差错报文类型的使用</h2><p><em>1. traceroute 作用一</em><br>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong><br>将TTL从1开始递增，强制接受ICMP超时消息。</p><p><em>2. traceroute 作用二</em><br>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18-1.webp"></p><h1 id="五、ping-127-0-0-1"><a href="#五、ping-127-0-0-1" class="headerlink" title="五、ping 127.0.0.1"></a>五、ping 127.0.0.1</h1><h2 id="ping流程"><a href="#ping流程" class="headerlink" title="ping流程"></a>ping流程</h2><p>ping与TCP的区别（_右边的ping数据应该为TCP数据_）：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/Pasted-image-20230208113935.png"></p><ul><li>ping是应用层协议</li><li>创建socket时的使用的参数不同</li><li>其他与普通TCP发送消息相同，所以可以通过ping测试能否到达访问</li></ul><h2 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/Pasted-image-20230208114527.png"><br>回环地址，<strong>软中断</strong>会直接返回，不走网卡。</p><h2 id="ping回环地址与ping本机IP"><a href="#ping回环地址与ping本机IP" class="headerlink" title="ping回环地址与ping本机IP"></a>ping回环地址与ping本机IP</h2><p><strong>没有区别！</strong><br>即使填写真IP，也会通过本地回环，不走网卡。</p><h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP</title>
    <link href="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/"/>
    <url>/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP基本认识"><a href="#一、TCP基本认识" class="headerlink" title="一、TCP基本认识"></a>一、TCP基本认识</h1><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h2 id="头格式"><a href="#头格式" class="headerlink" title="头格式"></a>头格式</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207114528.png"><br>不常见的：<br>URG：紧急标志位，优先处理紧急数据。<br>PSH：催促标志位，发送方立即发送，接受方立即接受。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文。</li></ul><h2 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h2><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115025.png"><br>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="唯一确定一个-TCP-连接呢？"><a href="#唯一确定一个-TCP-连接呢？" class="headerlink" title="唯一确定一个 TCP 连接呢？"></a>唯一确定一个 TCP 连接呢？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115107.png"></p><ul><li><strong>文件描述符限制</strong>，每个TCP连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看；</li><li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li><li><strong>进程级</strong>：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li></ul></li><li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h3 id="IP层会分片，为什么TCP层还需要MSS？"><a href="#IP层会分片，为什么TCP层还需要MSS？" class="headerlink" title="IP层会分片，为什么TCP层还需要MSS？"></a>IP层会分片，为什么TCP层还需要MSS？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207131104.png"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>如果把TCP报文整个交给IP分层，则一个IP分片丢失就会造成整个IP报文重传，因为IP报文没有分片重传机制，效率很低。</p><p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值。</strong></p><div class="note note-primary">            <p>TCP分片后保证其数据包大小MSS+TCP头部+IP头部&lt;MTU，因此不需要IP分片，这样重发时也是以MSS为单位，效率更高。</p>          </div><div class="note note-success">            <p>注意：MSS不包括TCP头部，但MTU包括IP头部。</p>          </div><h3 id="如何理解TCP基于字节流"><a href="#如何理解TCP基于字节流" class="headerlink" title="如何理解TCP基于字节流"></a>如何理解TCP基于字节流</h3><p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p><p>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。</p><h4 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h4><p>一般交给应用层解决。</p><ul><li>固定长度的消息；</li><li>特殊字符作为边界，如HTTP；</li><li>自定义消息结构；</li></ul><h2 id="UDP-和-TCP-有什么区别呢"><a href="#UDP-和-TCP-有什么区别呢" class="headerlink" title="UDP 和 TCP 有什么区别呢"></a>UDP 和 TCP 有什么区别呢</h2><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115326.png"><br><strong>TCP 和 UDP 区别：</strong><br><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 <strong>MSS</strong> 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 <strong>MTU</strong> 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong><br>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><p><strong>为什么UDP头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115616.png"><br>UDP的头部理论上也可这样省略，保留的原因可能有：</p><ul><li>保持4的整数倍。</li><li>当年UDP协议可能不是基于IP发展的。</li></ul><p><strong>TCP和UDP可以使用同一个端口吗？</strong><br>可以，两者是不同的模块。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.webp"></p><h1 id="二、TCP连接建立"><a href="#二、TCP连接建立" class="headerlink" title="二、TCP连接建立"></a>二、TCP连接建立</h1><h2 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h2><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"></p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120323.png"></p><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120334.png"></p><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120342.png"><br><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</strong></p><blockquote><p>第三次握手如果丢了可以建立连接吗？<br>可以，因为之后的普通数据报文也有ACK标志符和ack号。</p></blockquote><blockquote><p>Linux查看TCP连接状态：<code>netstat -napt</code>查看</p></blockquote><h2 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h2><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p><em>原因一：避免历史连接</em><br><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120725.png"></p><blockquote><p>如果新SYN在RST前到达，则回 <a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。</p><ul><li>客户端第一次握手后收到不正确的ACK会发送RST</li><li>服务端收到新的SYN报文时会要求对方传输正确的SYN，即回复上一次ACK报文。</li></ul></blockquote><p><em>原因二：同步双方初始序列号</em><br><strong>要确保双方的初始序列号能被可靠的同步。</strong> 在两次握手的情况下，只能保证客户端的SYN被接受。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207121527.png"><br>TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以<strong>去除重复</strong>的数据；</li><li>接收方可以根据数据包的序列号<strong>按序</strong>接收；</li><li>可以<strong>标识</strong>发送出去的数据包中，哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p><em>原因三：避免资源浪费</em><br>在两次握手的情况下，服务器无法判断客户端是否接受到了第二次握手，所以服务端每接受到一个SYN都要建立连接，如果SYN阻塞，则会产生很多冗余链接，造成不必要的资源浪费。</p><p><em>小结</em><br>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><div class="note note-primary">            <p>原因一、三有点类似，但角度不同，一个是历史连接建立造成的连接混乱，一个是历史连接建立造成的资源消耗。</p>          </div><h2 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h2><h3 id="初始化序列号为何不同？"><a href="#初始化序列号为何不同？" class="headerlink" title="初始化序列号为何不同？"></a>初始化序列号为何不同？</h3><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收；</li></ul><p>如果每次都是相同的初始化序列号，历史的滞留信息可能被下一次相同四元组的连接接受：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/isn%E7%9B%B8%E5%90%8C.webp"></p><h3 id="如何随机初始化序列号？"><a href="#如何随机初始化序列号？" class="headerlink" title="如何随机初始化序列号？"></a>如何随机初始化序列号？</h3><p>起始<code>ISN</code>是基于时钟的，每4微秒+1，转一圈要4.55个小时。<br>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><div class="note note-primary">            <p>可见不同四元组的ISN几乎不可能相同，同一个四元组中可能产生计时器回绕，因此有时需要时间戳判断历史报文。</p>          </div><h2 id="握手丢失"><a href="#握手丢失" class="headerlink" title="握手丢失"></a>握手丢失</h2><h3 id="第一次握手丢失"><a href="#第一次握手丢失" class="headerlink" title="第一次握手丢失"></a>第一次握手丢失</h3><p>客户端以相同的syn序列号重传。</p><h4 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>第一次超时重传是在<strong>1秒</strong>后。</li><li>默认总共超时<strong>重传5次</strong>（<code>tcp_syn_retries</code>设置）。</li><li><strong>每次超时的时间是上一次的2倍</strong>。</li><li>第五次重传后等待32秒然后断开连接。</li><li>总共耗时63秒，大约1分钟。</li></ul><h3 id="第二次握手丢失"><a href="#第二次握手丢失" class="headerlink" title="第二次握手丢失"></a>第二次握手丢失</h3><ul><li>客户端以相同的序列号<strong>重传</strong>，类似第一次握手丢失。</li><li>服务器也以相同的序列号<strong>重传</strong>SYN-ACK报文。</li></ul><h4 id="超时机制-1"><a href="#超时机制-1" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>默认总共超时<strong>重传5次</strong>（<code>tcp_synack_retries</code>设置）。</li></ul><h3 id="第三次握手丢失"><a href="#第三次握手丢失" class="headerlink" title="第三次握手丢失"></a>第三次握手丢失</h3><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。即服务器超时重传。</p><h3 id="客户端二次握手后超时重传"><a href="#客户端二次握手后超时重传" class="headerlink" title="客户端二次握手后超时重传"></a>客户端二次握手后超时重传</h3><p>TCP 建立连接后的<strong>数据包传输</strong>，最大超时重传次数是由 <code>tcp_retries2</code> 指定，默认值是 15 次。</p><h2 id="TCP快速连接"><a href="#TCP快速连接" class="headerlink" title="TCP快速连接"></a>TCP快速连接</h2><p>Linux 3.7内核版本中，提供了<strong>TCP Fast Open</strong>功能。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/45.webp"></p><ul><li>第一次连接：第二次握手时服务器给客户端传<code>Cookie</code>（加密）</li><li>第二次连接：第一次握手时客户端直接发送<code>Cookie</code>，省去了一次握手。</li></ul><p>net.ipv4.tcp_fastopen 各个值的意义:</p><ul><li>0 关闭</li><li>1 作为客户端使用 Fast Open 功能</li><li>2 作为服务端使用 Fast Open 功能</li><li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能</li></ul><h1 id="三、TCP连接断开"><a href="#三、TCP连接断开" class="headerlink" title="三、TCP连接断开"></a>三、TCP连接断开</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207141651.png"><br><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h2 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h2><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p><strong>在特定情况下，四次挥手是可以变成三次挥手的。</strong></p><h2 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h2><p>关闭的连接的函数有两种函数：</p><ul><li><code>close</code> 函数，同时 socket 关闭发送方向和读取方向。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让socket 引用计数 -1，并不会导致 socket 不可用，同时也<strong>不会发出 FIN 报文</strong>，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li><li><code>shutdown</code> 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。（如果有多进程&#x2F;多线程共享同一个 socket，<strong>shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文</strong>，如果有别的进程企图使用该 socket，将会受到影响。）</li></ul><div class="note note-primary">            <p>CLOSE只关闭SOCKET对本身的引用，不发FIN；<br>SHUTDOWN关闭写方向时，直接关闭SOCKET，发FIN；</p>          </div><ul><li>如果客户端调用<code>close</code>使Socket引用计数为0时，关闭连接，客户端发送FIN后若再接收到服务器的数据消息，会发送RST给服务端，从而不会经历四次握手。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230208001214.png"></li><li>如果客户端调用shutdown关闭写方向，正常4次挥手，关闭读方向的化，不会发送FIN，因为FIN的语义是我方不再发送信息。</li></ul><h2 id="TCP四次握手变三次"><a href="#TCP四次握手变三次" class="headerlink" title="TCP四次握手变三次"></a>TCP四次握手变三次</h2><p>服务端「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul><li>当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方。</li><li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ul><p>延迟等待的时间是在Linux内核中定义。</p><h2 id="挥手丢失"><a href="#挥手丢失" class="headerlink" title="挥手丢失"></a>挥手丢失</h2><h3 id="第一次挥手丢失"><a href="#第一次挥手丢失" class="headerlink" title="第一次挥手丢失"></a>第一次挥手丢失</h3><p>当客户端向服务端重传 FIN 报文。</p><h4 id="超时机制-2"><a href="#超时机制-2" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>默认总共超时<strong>重传8次</strong>（<code>tcp_orphan_retries</code>设置）。</li><li><strong>每次超时的时间是上一次的2倍</strong>。</li><li>超时仍未收到则close。</li></ul><h3 id="第二次挥手丢失"><a href="#第二次挥手丢失" class="headerlink" title="第二次挥手丢失"></a>第二次挥手丢失</h3><ul><li>客户端重传FIN报文，类似第一次挥手丢失。</li><li>服务端不会主动重传ACK，接收到重传的FIN会再次进行二次挥手。</li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.webp"></p><h3 id="第三次挥手丢失"><a href="#第三次挥手丢失" class="headerlink" title="第三次挥手丢失"></a>第三次挥手丢失</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.webp"></p><ul><li>服务端重传，机制类似第一次握手（<code>tcp_orphan_retries</code>）</li><li>客户端超过<code>tcp_fin_timeout</code>（默认60s）后关闭</li></ul><h3 id="第四次挥手丢失"><a href="#第四次挥手丢失" class="headerlink" title="第四次挥手丢失"></a>第四次挥手丢失</h3><ul><li>服务端重传第三次握手，机制类似第一次握手</li><li>客户端进入time_wait状态（2MSL），并会不断回复第四次握手。</li></ul><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>。<br>目的是保证这次连接中所有报文已经死亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p>如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p><strong>为什么是2倍MSL？</strong><br>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>2MSL表示允许第四次挥手报文至少丢失一次。</p><h3 id="TIME-WAIT的目的"><a href="#TIME-WAIT的目的" class="headerlink" title="TIME_WAIT的目的"></a>TIME_WAIT的目的</h3><p><em>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p><ul><li>序列号：为32位，即达到4G数据后会循环回0；</li><li>初始序列号：受时间影响，4.55小时一次循环；</li></ul><p>如果不保证连接中所有报文都死亡，则可能在相同四元组的情况下被下一个连接错误的接受。</p><p><em>原因二：保证「被动关闭连接」的一方，能被正确的关闭</em><br>第四次挥手可能丢失，此时服务端会重传第三次挥手，TW状态可以回复第四次挥手ACK。<br>否则，重传的第三次握手遇到CLOSE状态会收到RST回复来关闭连接，这部是一个优雅的终止方式。</p><h3 id="TIME-WAIT不能过多"><a href="#TIME-WAIT不能过多" class="headerlink" title="TIME_WAIT不能过多"></a>TIME_WAIT不能过多</h3><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><p>对客户端、服务端的影响：</p><ul><li>客户端：对相同IP，PORT的TCP连接是有上线的，即占用端口资源，且占用系统资源。</li><li>服务端：服务器只监听一个端口，理论上不会收到端口资源影响，但仍然占用系统资源。</li></ul><h3 id="优化TIME-WAIT"><a href="#优化TIME-WAIT" class="headerlink" title="优化TIME_WAIT"></a>优化TIME_WAIT</h3><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em><br><strong>tcp_tw_reuse 功能只能用客户端（连接发起方），开启了该功能后，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong><br>前提：打开对 TCP 时间戳的支持，即打开了tcp_timestamps</p><p>结果：时间戳避免了2MSL问题。</p><p><em>方式二：net.ipv4.tcp_max_tw_buckets</em><br>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p><p><em>方式三：程序中使用 SO_LINGER</em><br>设置 socket 选项，来设置调用 close 关闭连接行为。<br>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><h2 id="服务端出现大量TIME-WAIT"><a href="#服务端出现大量TIME-WAIT" class="headerlink" title="服务端出现大量TIME_WAIT"></a>服务端出现大量TIME_WAIT</h2><p><em>第一个场景：HTTP 没有使用长连接</em><br><strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p><p>请求和响应的双方都可以主动关闭 TCP 连接。<strong>但根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接。</strong></p><p><em>第二个场景：HTTP 长连接超时</em><br>web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如nginx提供的keepalive_timeout参数。<br><strong>这种时候也是服务端主动关闭连接。</strong></p><p><em>第三个场景：HTTP 长连接的请求数量达到上限</em><br>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。<br>调大nginx的配置数量即可。</p><h2 id="服务端大量CLOSE-WAIT"><a href="#服务端大量CLOSE-WAIT" class="headerlink" title="服务端大量CLOSE_WAIT"></a>服务端大量CLOSE_WAIT</h2><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>分析一个普通的 TCP 服务端的流程：</p><ol><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll</li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ol><p>导致不会调用close的可能：</p><ol><li>第2步没有注册epoll，代码问题</li><li>第3步没有accept</li><li>第4步没有注册epoll</li><li>第6步没有执行close，代码问题</li></ol><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><div class="note note-primary">            <p>不好记，记下流程和结论就行。</p>          </div><h2 id="客户端突然故障"><a href="#客户端突然故障" class="headerlink" title="客户端突然故障"></a>客户端突然故障</h2><h3 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h3><blockquote><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p></blockquote><p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_keepalive_time</span>=<span class="hljs-number">7200</span><br><span class="hljs-attr">net.ipv4.tcp_keepalive_intvl</span>=<span class="hljs-number">75</span>  <br><span class="hljs-attr">net.ipv4.tcp_keepalive_probes</span>=<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>即一般2小时无信息就开始发送探测报文，9次无响应则断开，共2小时11分15秒。TCP 保活的这个机制检测的时间有点长，我们可以自己在应用层实现一个心跳机制。比如Web应用设置定时器，定时器一到如果没有请求就主动释放连接。</p><p>应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，客户端程序正常工作的。会响应探测信息，重置保活。</li><li>第二种，客户端程序崩溃，不会触发保活，操作系统会回收资源完成挥手。</li><li>第三种，客户端主机宕机并重启。回复RST，直接触发关闭。</li><li>第四种，客户端主机宕机或报文不可达。多次探测后关闭连接。</li></ul><blockquote><p>客户端也有保活机制！</p></blockquote><h2 id="服务端进程突然崩溃"><a href="#服务端进程突然崩溃" class="headerlink" title="服务端进程突然崩溃"></a>服务端进程突然崩溃</h2><p>主机操作系统自动完成挥手释放连接。</p><h1 id="四、Socket编程"><a href="#四、Socket编程" class="headerlink" title="四、Socket编程"></a>四、Socket编程</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207155558.png"><br>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个<strong>已完成连接的 socket</strong>，后续用来传输数据。<br>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>过程：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207155715.png"></p><ul><li>半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li><li>全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；<br>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></li></ul><p><strong>但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 &#x3D; min(backlog, somaxconn)，详情见下面的全连接，半连接章节。</strong></p><h3 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"><br><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><h3 id="close-断开流程"><a href="#close-断开流程" class="headerlink" title="close 断开流程"></a>close 断开流程</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207160043.png"></p><p>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</p><h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以</strong>，accept的作用就是从全连接队列中取出连接，然后对其进行读写，但其不参与连接的建立。</p><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以</strong>：</p><ol><li>客户端可以自连接。</li><li>两个客户端同时发起SYN可以互连。</li></ol><h1 id="五、TCP重传、滑动窗口、流量控制、拥塞控制"><a href="#五、TCP重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="五、TCP重传、滑动窗口、流量控制、拥塞控制"></a>五、TCP重传、滑动窗口、流量控制、拥塞控制</h1><h2 id="重传控制"><a href="#重传控制" class="headerlink" title="重传控制"></a>重传控制</h2><p>常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p><code>RTT</code>（往返时延）：指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong><br><code>RTO</code>（超时重传时间）：<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><ul><li>RTO过小导致不必要的重传</li><li>过大导致传输效率低下</li></ul><p>每次超时重传时将下次超时时间时间设置为先前的2倍。</p><h4 id="RTO计算"><a href="#RTO计算" class="headerlink" title="RTO计算"></a>RTO计算</h4><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/9.webp"><br>在 Linux 下，<strong>α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4</strong>。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>慢</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>客户端回复ACK中携带确认收到的报文，连续3个相同ACK表示通知系统重传。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>无法确定重传一条还是重传一批</p><h3 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h3><p><strong>选择性确认</strong>。<br>它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/11.webp"></p><p>要支持<code>SACK</code>需要双方都开启该功能。</p><h3 id="DSACK方法"><a href="#DSACK方法" class="headerlink" title="DSACK方法"></a>DSACK方法</h3><p>Duplicate SACK 又称 <code>D-SACK</code>。<strong>将接受到的重复消息发送给「发送方」</strong>。</p><p>可以配合超时重传或快传，指出哪些数据重复了：<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/12.webp"></p><p><code>D-SACK</code> 有这么几个好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>在滑动窗口模式下，不用逐一等待ACK，实现批量发送、<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>TCP 头里有一个字段叫 <code>Window</code>：这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。</p><h3 id="发送方滑动窗口"><a href="#发送方滑动窗口" class="headerlink" title="发送方滑动窗口"></a>发送方滑动窗口</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/19.webp"><br>通过一个窗口大小，两个绝对指针可以得到可用窗口大小。</p><h3 id="接受方滑动窗口"><a href="#接受方滑动窗口" class="headerlink" title="接受方滑动窗口"></a>接受方滑动窗口</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/20.webp"><br>通过一个窗口大小，一个绝对指针表示窗口。每个小窗口内部记录了是否接受到了数据。</p><div class="note note-primary">            <p>接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>          </div><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>发送方接受到ACK后移动并调整窗口大小</li><li>接受方接受到Seq后移动窗口并调整窗口大小。</li></ul><h3 id="操作系统缓冲区"><a href="#操作系统缓冲区" class="headerlink" title="操作系统缓冲区"></a>操作系统缓冲区</h3><p>发送窗口和接收窗口中所存放的字节数，都放在<strong>操作系统内存缓冲区</strong>中。<br><em>情况一：应用程序读取慢</em><br>当接受方的应用程序没有及时获取已经送达的消息时：<br>接受方滑动窗口的右端不变，左端移动 应用程序取走的比特数量，实现窗口缩小。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/22.webp"></p><p><em>情况二：服务器资源紧张</em><br>操作系统可能会直接减少了接收缓冲区大小：<br>这种情况下，可能另发送方调整后的右端比之前的右端还前面。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/23.webp"><br>即发送方发送了接受方不在窗口内的消息，导致数据包丢失。</p><p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p><div class="note note-primary">            <p>即保证右端不会左移动。</p>          </div><h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><p>窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/24.webp"></p><h4 id="零窗口探测报文"><a href="#零窗口探测报文" class="headerlink" title="零窗口探测报文"></a>零窗口探测报文</h4><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong><br><strong>窗口探测 (Window probe) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><blockquote><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p></blockquote><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。<br>也就是为了几字节而发送一个TCP包，不值得。</p><p>发生：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据</li></ul><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>解决：</p><ul><li>让接收方不通告小窗口给发送方：<ul><li>当窗口大小小于<code>min(MSS，缓存空间/2）</code>时，通知发送方窗口为0。</li></ul></li><li>让发送方避免发送小数据：<ul><li><strong>Nagle算法</strong>：满足条件之一时才发送<ul><li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li><li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li></ul></li></ul></li></ul><p>Nagle：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/55.webp"></p><p><strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p><h4 id="延迟确认-1"><a href="#延迟确认-1" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul><li>当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方。</li><li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ul><p><strong>与窗口无关但也可以提高效率，避免小报文，同时其可能导致四次挥手变成三次。</strong></p><h4 id="Nagle算法和延迟确认混合使用"><a href="#Nagle算法和延迟确认混合使用" class="headerlink" title="Nagle算法和延迟确认混合使用"></a>Nagle算法和延迟确认混合使用</h4><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/61.webp"></p><ul><li>接受方因为延迟确认算法不回复。</li><li>发送方因为Nagle算法，不发送后续数据。</li><li>导致接收方等到延迟算法达到时间后（延迟算法：只在有新数据发送 或 达到延迟时间 或 接收到新数据后才回复）才回复，整体时延增加。</li></ul><p>解决：</p><ul><li>发送方关闭Nagle算法</li><li>接收方关闭TCP延迟确认</li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制主要考虑避免接受方接受得了。<br>拥塞控制主要考虑网络是否承担得了。</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><blockquote><p>发送窗口 swnd &#x3D; min(拥塞窗口cwnd，接受窗口rwnd)</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p><strong>当发送方每收到一个ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/27.webp"></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。<br><strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/28.webp"></p><h3 id="拥塞发送"><a href="#拥塞发送" class="headerlink" title="拥塞发送"></a>拥塞发送</h3><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><ul><li>超时重传：<ul><li><code>ssthresh</code> &#x3D; <code>cwnd/2</code>，即慢启动门限为当前的一半</li><li><code>cwnd</code> &#x3D; <code>1</code>，重置拥塞窗口。</li></ul></li></ul><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/29.webp"></p><ul><li>快速重传：<ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入<strong>快速恢复算法</strong>；</li></ul></li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>一般认为如果快速重传，网络问题应该不大，会进入快速恢复算法：<br>快速恢复算法：</p><ul><li><code>cwnd = ssthresh + 3</code></li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1，当收到新的ACK后，说明丢失数据包已经完成发送，恢复拥塞避免状态。</li><li><code>cwnd = ssthresh</code></li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.webp"></p><div class="note note-primary">            <p>快速恢复的观点是，丢失包是意外情况，想要尽快恢复正常，因此：</p><ol><li>更新门限和窗口（快速重传）。</li><li>紧急加大3个门限希望多发一些数据包。</li><li>当接受到新ACK后说明状态恢复，此时门限再回归拥塞避免状态。</li></ol>          </div><h1 id="六、TCP半连接队列和全连接队列"><a href="#六、TCP半连接队列和全连接队列" class="headerlink" title="六、TCP半连接队列和全连接队列"></a>六、TCP半连接队列和全连接队列</h1><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列，是一个Hash表，便于常数时间取出连接；</li><li>全连接队列，也称 accept 队列，是一个链表，只需取出头节点；<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230208000041.png"></li></ul><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/3.webp"><br>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，<strong>内核会直接丢弃，或返回 <code>RST</code> 包</strong>。</p><h2 id="TCP全连接溢出"><a href="#TCP全连接溢出" class="headerlink" title="TCP全连接溢出"></a>TCP全连接溢出</h2><p><strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接。</strong><br>丢掉的 TCP 连接的个数会被统计起来。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h4><p>丢弃连接是默认行为，可以通过调整策略修改行为。<br>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：</p><ul><li>0：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；</li><li>1：如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接；</li></ul><div class="note note-primary">            <p>即判断是否要回复RST，设置为0更好，因为一般全连接队列只是短暂的满了，不回复RST便于客户端重连。</p>          </div><h4 id="调大区间"><a href="#调大区间" class="headerlink" title="调大区间"></a>调大区间</h4><p>队列大小为<code>min(somaxconn, backlog)</code>，两者都要调大。</p><h2 id="TCP半连接溢出"><a href="#TCP半连接溢出" class="headerlink" title="TCP半连接溢出"></a>TCP半连接溢出</h2><h3 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h3><p><strong>半连接队列最大值</strong>不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系，即与全连接队列最大值有关。</p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li></ul><p><strong>其长度为max_syn_backlog和全连接队列长度中较小者的两倍</strong>。</p><p>溢出时，看是否开启了tcp_syncookies设置判断是否丢弃。</p><h3 id="舍弃行为"><a href="#舍弃行为" class="headerlink" title="舍弃行为"></a>舍弃行为</h3><p>对消息的舍弃行为行为如下：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/28-1.webp"></p><ol><li>半连接队列满了，没开tcp_syncookies，丢弃</li><li>全连接队列满了，且存在尚未重传第二次握手的连接（说明全连接队列还有有效连接），丢弃</li><li>没开tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)（即超过了配置数值&lt;不是理论最大值&gt;的3&#x2F;4），则丢弃。</li></ol><h3 id="处于SYN-RECV状态的连接数量"><a href="#处于SYN-RECV状态的连接数量" class="headerlink" title="处于SYN_RECV状态的连接数量"></a>处于SYN_RECV状态的连接数量</h3><p>由于丢弃策略的第3点，半连接最大值依然只是一个理论最大值。</p><blockquote><p>Linux5.0后，理论最大值就是全连接最大值。</p></blockquote><h4 id="Syncookies"><a href="#Syncookies" class="headerlink" title="Syncookies"></a>Syncookies</h4><p><strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong><br>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h3 id="SYN攻击方式"><a href="#SYN攻击方式" class="headerlink" title="SYN攻击方式"></a>SYN攻击方式</h3><p>把TCP半连接队列打满。</p><h3 id="SYN攻击避免"><a href="#SYN攻击避免" class="headerlink" title="SYN攻击避免"></a>SYN攻击避免</h3><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li><li>减少 SYN+ACK 重传次数</li></ul><p><em>方式一：调大 netdev_max_backlog</em><br>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。扩大这个队列(默认为1000)。</p><p><em>方式二：增大半连接队列</em><br>同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.<code>tcp_max_syn_backlog</code></li><li>增大 listen() 函数中的 <code>backlog</code></li><li>增大 net.core.<code>somaxconn</code></li></ul><p><em>方式三：开启 net.ipv4.tcp_syncookies</em><br>不再保存半连接，而是给客户端发cookie，收到客户端ACK后再验证cookie。</p><p><em>方式四：减少 SYN+ACK 重传次数</em><br>此时会出现大量的二次握手重传，应该减少重传次数。</p><h1 id="七、TCP优化"><a href="#七、TCP优化" class="headerlink" title="七、TCP优化"></a>七、TCP优化</h1><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/4.webp"></p><h2 id="握手优化"><a href="#握手优化" class="headerlink" title="握手优化"></a>握手优化</h2><h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><p>适当调低重传次数<strong>tcp_syn_retries</strong></p><h3 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h3><h4 id="半连接"><a href="#半连接" class="headerlink" title="半连接"></a>半连接</h4><ul><li>扩大半连接队列大小：<strong>tcp_max_syn_backlog</strong>、<strong>somaxconn</strong>、<strong>backlog</strong></li><li>开启<strong>syncookies</strong>功能</li><li>修改第二次握手的重传次数<strong>tcp_synack_retries</strong></li></ul><h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><ul><li>扩大全连接队列大小：<strong>somaxconn</strong>、<strong>backlog</strong></li></ul><h3 id="如何绕开三次握手"><a href="#如何绕开三次握手" class="headerlink" title="如何绕开三次握手"></a>如何绕开三次握手</h3><p>TCP Fast Open，第一次派发一个cookie（不同于syncookies，那个是用于绕开全连接和半连接队列的）<br>开启方式：<strong>tcp_fastopn</strong></p><h2 id="挥手优化"><a href="#挥手优化" class="headerlink" title="挥手优化"></a>挥手优化</h2><h3 id="主动方"><a href="#主动方" class="headerlink" title="主动方"></a>主动方</h3><p>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。</p><ul><li>close(int sock)：函数意味着完全断开连接。</li><li>shutdown(int sock,int howto)：控制只关闭 读&#x2F;写&#x2F;双向 方向的连接。</li></ul><h4 id="FIN-WAIT1优化"><a href="#FIN-WAIT1优化" class="headerlink" title="FIN_WAIT1优化"></a>FIN_WAIT1优化</h4><ul><li>调低<strong>tcp_orphan_retries参数（默认8次）控制</strong></li><li>调低<strong>tcp_max_orphans 参数，它定义了「孤儿连接」的最大数量</strong>，新的孤儿连接直接发送RST强制关闭。</li><li>设置close关闭行为，即客户端可以强行关闭。</li></ul><h4 id="FIN-WAIT2优化"><a href="#FIN-WAIT2优化" class="headerlink" title="FIN_WAIT2优化"></a>FIN_WAIT2优化</h4><ul><li>shutdown关闭时，可一直维持该状态</li><li>close关闭时，<strong>tcp_fin_timeout</strong>标出了最大持续时长，目的与TIME_WAIT类似。</li></ul><h4 id="TIME-WAIT优化"><a href="#TIME-WAIT优化" class="headerlink" title="TIME_WAIT优化"></a>TIME_WAIT优化</h4><ul><li><strong>tcp_max_tw_buckets参数</strong>限制TIME_WAIT数量。</li><li><strong>tcp_tw_reuse</strong>复用TIME_WAIT连接，同时还要双方开启时间戳。</li></ul><p>时间戳作用：</p><ul><li>防止过期数据</li><li>防止序列号绕回</li></ul><p>PAWS坑：<br>老版本的 Linux 还提供了 <code>tcp_tw_recycle</code> 参数，但是当开启了它，允许处于 TIME_WAIT 状态的连接被快速回收，但是有个<strong>大坑</strong>，现在已经关掉这个参数了。</p><p>开启了 recycle 和 timestamps 选项，就会开启一种叫 per-host 的 PAWS（判断TCP 报文中时间戳是否是历史报文） 机制，<strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>，而非对「IP + 端口」四元组做 PAWS 检查。因此如果客户端通过NAT与服务器建立连接，另一个客户端可能与其复用IP，但两者时间戳可能不一样，导致错误丢弃。</p><div class="note note-primary">            <p>SHUTDOWN比CLOSE优雅，但CLOSE仍然是主流的断开连接方式，并且可以指定CLOSE行为（挥手或直接RST）</p>          </div><h3 id="被动方"><a href="#被动方" class="headerlink" title="被动方"></a>被动方</h3><h4 id="CLOSE-WAIT优化"><a href="#CLOSE-WAIT优化" class="headerlink" title="CLOSE_WAIT优化"></a>CLOSE_WAIT优化</h4><p>调低tcp_orphan_retries 参数</p><blockquote><p>另外，close如果被迅速调用，四次挥手可能变成三次。<br>也可以理解成延时响应。</p></blockquote><p><strong>如果双方同时关闭连接？</strong><br>同时关闭，出现了一个新状态（CLOSING）<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/38.webp"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>滑动窗口大小：TCP可选字段中指明窗口扩大因子。</li><li>最大传输速度：发送缓冲区大小最好与带宽时延积靠近。</li><li>缓冲区：<ul><li>发送缓冲区是自行调节的。</li><li>接受缓冲区可以配置开启，根据系统空闲来接受窗口。</li></ul></li><li>TCP内存范围：<strong>调大 tcp_mem 的上限</strong>扩大TCP内存。</li></ul><h1 id="八、如何确定序列号和确认号"><a href="#八、如何确定序列号和确认号" class="headerlink" title="八、如何确定序列号和确认号"></a>八、如何确定序列号和确认号</h1><ul><li>序列号 &#x3D; <strong>上一次发送</strong>的序列号 + len（数据长度）。<ul><li>特殊情况，如果<strong>上次发送</strong>的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li></ul></li><li>确认号 &#x3D; <strong>上一次收到</strong>的报文中的序列号 + len（数据长度）。<ul><li>特殊情况，如果<strong>上次收到</strong>的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li></ul></li></ul><div class="note note-primary">            <p>总结就是上次序列号+数据长度，但SYN和FIN作为主动发出的控制，都需要占用1个syn。<br>ack表示期待的下一个收到的syn报文。</p>          </div><h1 id="九、QUIC"><a href="#九、QUIC" class="headerlink" title="九、QUIC"></a>九、QUIC</h1><h2 id="TCP协议的缺点"><a href="#TCP协议的缺点" class="headerlink" title="TCP协议的缺点"></a>TCP协议的缺点</h2><ul><li>升级 TCP 的工作很困难：内核实现</li><li>TCP 建立连接的延迟：3次握手</li><li>TCP 存在队头阻塞问题：滑动窗口队头阻塞</li><li>网络迁移需要重新建立 TCP 连接：四元组发生变化</li></ul><h2 id="UDP可靠传输QUIC"><a href="#UDP可靠传输QUIC" class="headerlink" title="UDP可靠传输QUIC"></a>UDP可靠传输QUIC</h2><p>解决了TCP的缺点</p><ul><li>升级容易（随浏览器升级，应用层实现）</li><li>快速连接（配合TLS1.3，1RTT即可实现首次连接，0RTT实现二次连接）</li><li>只存在单个Stream对队头阻塞</li><li>无感迁移（靠连接ID识别）</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/ab3283383013b707d1420b6b4cb8517c.webp"></p><h3 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207231330.jpg"><br>Packet Header 细分这两种：</p><ul><li>Long Packet Header 用于首次建立连接。</li><li>Short Packet Header 用于日常传输数据。</li></ul><p><em>握手次数</em><br><strong>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。</strong></p><p>Short Packet Header 中的 <code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>。</p><blockquote><p>TCP无法区分ACK是对原始报文还是重传报文的响应，因为ack值相同，但SYN重传时Packet Number也不一样，从而便于计算RTT和RTO。</p></blockquote><p>此外，QUIC 使用的Packet Number单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持<strong>乱序确认</strong>，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动。</p><p><em>重传问题</em><br>重传时编号比原始编号大。与乱序确认一起解决了队头阻塞问题。</p><h3 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h3><p>一个 Packet 报文中可以存放多个 QUIC Frame。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207232037.png"></p><h3 id="Fream结构"><a href="#Fream结构" class="headerlink" title="Fream结构"></a>Fream结构</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207232139.jpg"></p><ul><li>Stream ID：区别真正的消息ID，便于组装</li><li>Offset：指出负载数据在消息体中的偏移，保证顺序和可靠性。</li></ul><blockquote><p>如何确定两个Packet相同，即是重传的：<br>通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="如何解决队头阻塞问题？"><a href="#如何解决队头阻塞问题？" class="headerlink" title="如何解决队头阻塞问题？"></a>如何解决队头阻塞问题？</h3><p>HTTP&#x2F;2通过Stream解决了HTTP消息阻塞（不同Stream可以乱序），但无法避免TCP阻塞。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/http2%E9%98%BB%E5%A1%9E.webp"><br><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/quic%E6%97%A0%E9%98%BB%E5%A1%9E.webp"><br>即如果一个Stream丢了UDP包，只影响Stream2的处理。</p><h3 id="如何实现流量控制"><a href="#如何实现流量控制" class="headerlink" title="如何实现流量控制"></a>如何实现流量控制</h3><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><h4 id="Stream-级别的流量控制"><a href="#Stream-级别的流量控制" class="headerlink" title="Stream 级别的流量控制"></a>Stream 级别的流量控制</h4><p>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p><p>**接收窗口的流控：接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</p><p><strong>接收窗口的滑动</strong>：当已经上交给应用的数据达到最大接受窗口的一半时进行滑动。</p><h4 id="Connection-流量控制"><a href="#Connection-流量控制" class="headerlink" title="Connection 流量控制"></a>Connection 流量控制</h4><p>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</p><h1 id="X：列举问题"><a href="#X：列举问题" class="headerlink" title="X：列举问题"></a>X：列举问题</h1><h3 id="SYN报文什么时候情况下会被丢弃？"><a href="#SYN报文什么时候情况下会被丢弃？" class="headerlink" title="SYN报文什么时候情况下会被丢弃？"></a>SYN报文什么时候情况下会被丢弃？</h3><ul><li>半连接、全连接队列数量限制且没开syncookies设置。</li><li>为了复用TIME_WAIT开启tcp_tw_recycle，开启了时间戳，在NAT网络下消息过期被丢弃。</li></ul><h3 id="已建立连接的TCP，收到SYN会发生什么？"><a href="#已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="已建立连接的TCP，收到SYN会发生什么？"></a>已建立连接的TCP，收到SYN会发生什么？</h3><ol><li>客户端的SYN报文里的端口号与历史连接不相同：建立新连接。</li><li>客户端的SYN报文里的端口号与历史连接相同：<ul><li>服务端回复ACK（Challenge ACK：包含正确的序列号和确认号）。</li><li>客户端回复RST（即这个ACK处理不了）</li></ul></li></ol><h3 id="收到乱序的FIN包如何处理"><a href="#收到乱序的FIN包如何处理" class="headerlink" title="收到乱序的FIN包如何处理"></a>收到乱序的FIN包如何处理</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207222312.png"><br><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p><p>等收到延迟的数据包后检查乱序队列，若该队列中有可用数据，且数据有FIN标志，则进入TIME_WAIT状态。</p><h3 id="在TIME-WAIT状态的TCP连接，收到-SYN-后会发生什么？"><a href="#在TIME-WAIT状态的TCP连接，收到-SYN-后会发生什么？" class="headerlink" title="在TIME_WAIT状态的TCP连接，收到 SYN 后会发生什么？"></a>在TIME_WAIT状态的TCP连接，收到 SYN 后会发生什么？</h3><p><strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong></p><ul><li>序列号比期望的大</li><li>时间戳要比上次收到的要大</li></ul><p>处理：</p><ul><li>合法则重用四元组连接。</li><li>非法<ul><li>主动端回复第四次ACK</li><li>被动端发现不是自己期待的就发送RST</li><li>主动方接受RST：看<code>net.ipv4.tcp_rfc1337</code> 这个内核参数<ul><li>参数设置为 0，则提前结束TIME_WAIT</li><li>参数设置为 1，则丢掉RST</li></ul></li></ul></li></ul><div class="note note-primary">            <p>接收方发现非法SYN会回复正确的ACK。<br>发送方发现非法ACK会回复RST。</p>          </div><h3 id="TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="TCP 连接，一端断电和进程崩溃有什么区别？"></a>TCP 连接，一端断电和进程崩溃有什么区别？</h3><h4 id="无数据传输"><a href="#无数据传输" class="headerlink" title="无数据传输"></a>无数据传输</h4><p><strong>断电</strong>：过一段时间进入保活，然后关闭<br><strong>进程崩溃</strong>：直接释放，进行挥手</p><h4 id="有数据传输"><a href="#有数据传输" class="headerlink" title="有数据传输"></a>有数据传输</h4><p><strong>客户端主机宕机，又迅速重启</strong>：</p><ol><li>服务端超时重传。</li><li>客户端重启后若无论端口是否被绑定，都会回复RST。</li></ol><p><strong>客户端主机宕机，一直没有重启</strong>：</p><ol><li>服务器超时重传（<code> tcp_retries2</code>，默认15次），然后断开连接。</li></ol><h3 id="拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗？"></a>拔掉网线后， 原本的 TCP 连接还存在吗？</h3><p>本质和数据丢包一样，若有数据则超时重传，没有则等保活。</p><h3 id="tcp-tw-reuse-为什么默认是关闭的？"><a href="#tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="tcp_tw_reuse 为什么默认是关闭的？"></a>tcp_tw_reuse 为什么默认是关闭的？</h3><p>以下两种方式都默认关闭：</p><ul><li>net.ipv4.tcp_tw_reuse，连接时发现<strong>相同四元组</strong>的连接在TIME_WAIT状态则复用。</li><li>net.ipv4.tcp_tw_recycle，由于PWSA机制，NAT网络下不安全。</li></ul><p>tw的2MSL是很重要的：</p><ul><li>RST报文即使时间戳过期也会被处理，关闭正常连接。</li><li>服务端无法正确关闭，不优雅。</li></ul><h3 id="TLS和TCP可以同时握手吗"><a href="#TLS和TCP可以同时握手吗" class="headerlink" title="TLS和TCP可以同时握手吗"></a>TLS和TCP可以同时握手吗</h3><p>只有以下两点同时满足：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><p>利用TCP Fast Open第二次连接时只需要发送cookie，可以同时携带TLS1.3的第二次连接时的会话恢复机制，1RTT即可完成握手。</p><h3 id="TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h3><h4 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h4><p>应用层不主动释放TCP连接，而是复用该TCP连接。</p><h4 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h4><p>在没有数据交互的情况下，探测目标是否存活的保活机制。</p><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p>可以，两套独立模块<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97-1.webp"></p><h3 id="多个TCP服务进程可以bind同一个端口吗？"><a href="#多个TCP服务进程可以bind同一个端口吗？" class="headerlink" title="多个TCP服务进程可以bind同一个端口吗？"></a>多个TCP服务进程可以bind同一个端口吗？</h3><p>不行，绑定相同IP和Port时不行。</p><h4 id="同一个TCP服务进程如何复用TCP连接"><a href="#同一个TCP服务进程如何复用TCP连接" class="headerlink" title="同一个TCP服务进程如何复用TCP连接"></a>同一个TCP服务进程如何复用TCP连接</h4><blockquote><p>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？<br>因为有TIME_WAIT状态，服务器进程可以bind前开启<strong>SO_REUSEADDR</strong>，即仅针对自己这个进程的TW复用。</p></blockquote><h4 id="不同IP相同Port可行吗"><a href="#不同IP相同Port可行吗" class="headerlink" title="不同IP相同Port可行吗"></a>不同IP相同Port可行吗</h4><p>一般可行，但有特例：</p><blockquote><p>注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p><p>这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。</p></blockquote><p>开启<strong>SO_REUSEADDR</strong>后，只要求IP和端口不完全一样即可，所以这个特例也变成可行的。</p><h3 id="多个客户端可以bind同一个端口吗"><a href="#多个客户端可以bind同一个端口吗" class="headerlink" title="多个客户端可以bind同一个端口吗"></a>多个客户端可以bind同一个端口吗</h3><blockquote><p>客户端是在调用 connect 函数的时候，由内核随机选取一个端口作为连接的端口。<br>而如果我们想自己指定连接的端口，就可以用 bind 函数来实现：客户端先通过 bind 函数绑定一个端口，然后调用 connect 函数就会跳过端口选择的过程了，转而使用 bind 时确定的端口。</p></blockquote><p>其他同上一个问题。</p><h3 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h3><p>TCP由四元组做区分，在所有IP相同情况下：</p><ul><li>访问不同的服务器（目标IP和目标端口不同），总是可以复用。</li><li>访问同一个服务器，则端口有冲突，但很少不够用导致重复。</li></ul><blockquote><p>客户端TCP连接TIME_WAIT状态过多，会导致端口资源耗尽而无法建立新的连接吗？<br>与上个问题类似。</p></blockquote><blockquote><p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？<br>开启tw_reuse，若TIME_WAIT超过1s，则可以复用。</p></blockquote><p>客户端端口选择：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.webp"></p><h3 id="服务端没有listen，可以建立连接吗"><a href="#服务端没有listen，可以建立连接吗" class="headerlink" title="服务端没有listen，可以建立连接吗"></a>服务端没有listen，可以建立连接吗</h3><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><div class="note note-primary">            <p>bind只是表示进程会占用该端口发送消息，只有listen后才会创建全连接队列，半连接队列。</p>          </div><p><strong>不使用listen，可以建立连接吗？</strong><br>与服务端必须开启listen不同，主机内核有个全局 hash 表，可以用于存放 sock 连接的信息。<br>当<strong>客户端</strong>调用connect函数时，会将该sock信息放入表中，因此可以实现连接一般有两种情况：</p><ul><li>客户端自连接</li><li>两个客户端互相连接</li></ul><div class="note note-primary">            <p>服务端listen后，创建队列接受处理连接。<br>客户端connect后，自己的连接信息放入内核hash处理连接。</p>          </div><h3 id="没有-accept，能建立-TCP-连接吗？-1"><a href="#没有-accept，能建立-TCP-连接吗？-1" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>执行accept()只是为了从全连接队列里取出一条连接。</strong><br>不干涉TCP握手的建立。</p><h3 id="队列满了的行为"><a href="#队列满了的行为" class="headerlink" title="队列满了的行为"></a>队列满了的行为</h3><ul><li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li><li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li></ul><h3 id="四次挥手可以变成三次吗"><a href="#四次挥手可以变成三次吗" class="headerlink" title="四次挥手可以变成三次吗"></a>四次挥手可以变成三次吗</h3><p>可以，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><h3 id="TCP一定可靠吗？"><a href="#TCP一定可靠吗？" class="headerlink" title="TCP一定可靠吗？"></a>TCP一定可靠吗？</h3>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTP</title>
    <link href="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    <url>/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>超文本传输协议，<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><ul><li>协议：HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</li><li>传输：HTTP 协议是一个<strong>双向协议</strong>。</li><li>超文本：<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li></ul><p>总结：<br><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.webp"><br><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。<br><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 </li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h2><ul><li>Accept: 可接受的数据格式</li><li>Host 字段：服务器域名</li><li>Connection 字段：使用长连接<br>  即复用同一个TCP连接，HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li><li>Content-Length 字段：数据长度，为了解决粘包</li><li>Content-Type：本次数据格式</li><li>Content-Encoding：数据的压缩方法</li></ul><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>get：语义是获取资源（可放入body也可放入url）<br>post：语义是操作资源（请求参数放入body）</p><h3 id="GET和POST方法都是安全和幂等的吗？"><a href="#GET和POST方法都是安全和幂等的吗？" class="headerlink" title="GET和POST方法都是安全和幂等的吗？"></a>GET和POST方法都是安全和幂等的吗？</h3><p>安全：不破坏服务器资源<br>幂等：多次执行结果不变</p><ul><li><strong>GET 方法就是安全且幂等的</strong>（可做缓存）。</li><li><strong>POST</strong> <strong>方法不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。（<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>）。</li></ul><blockquote><p>实际上开发者也可以不遵守这个规定。</p></blockquote><h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><p>本地缓存的方式有：<strong>强制缓存和协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>HTTP响应头可以表示资源的缓存时间：</p><ul><li><code>Cache-Control</code>，是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>其中，<strong>Cache-Control 的优先级高于 Expires</strong>了。<br>强制缓存：只要不过期，肯定直接返回。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%BC%93%E5%AD%98etag.webp"><br>协商缓存：<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>实现方法：<br>方法一：时间戳</p><ul><li>响应头中的<code>Last-Modified</code>：资源最后的修改时间</li><li>请求头中的<code>If-Modified-Since</code>：告诉服务器上次接受资源的时间</li></ul><p>即客户端接受到第一次访问的数据中发现有<code>Last-Modified</code>字段，再次请求时会携带<code>If-Modified-Since</code>字段（值为<code>Last-Modified</code>），服务器通过判断<code>Last-Modified</code>是否过期判断回复最新结果200还是无修改304。</p><p>方法二：E-tag</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：告诉服务器上次接受资源的ID。</li></ul><p>原理相同。<br>由于方法一的时间戳可能背篡改导致不可靠，主要使用方法二，且<strong>Etag 的优先级更高</strong>。</p><p><strong>Etag的优点</strong>：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><div class="note note-primary">            <p>这些Last-Modified的缺点与TCP连接的TW-REUSE开启之后使用时间戳的缺点类似。</p>          </div><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><h1 id="二、HTTP特性"><a href="#二、HTTP特性" class="headerlink" title="二、HTTP特性"></a>二、HTTP特性</h1><p>到目前为止，HTTP 常见到版本有 <code>HTTP/1.1</code>，<code>HTTP/2.0</code>，<code>HTTP/3.0</code>，不同版本的 HTTP 特性是不一样的。</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>HTTP 最突出的优点是「简单(格式简单)、灵活和易于扩展（在应用层请求头和响应头可扩展）、应用广泛和跨平台」。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>长连接</li><li>管道网络传输，解决了请求的对头阻塞。</li></ul><h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><h5 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h5><p>在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.webp"></p><p><strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。<br>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。<br><strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="传输上"><a href="#传输上" class="headerlink" title="传输上"></a>传输上</h4><ul><li>数据量大</li><li>响应阻塞</li></ul><h4 id="安全性上"><a href="#安全性上" class="headerlink" title="安全性上"></a>安全性上</h4><ul><li>无状态：无状态使服务器不用记忆http状态，但关联性操作会比较麻烦。可使用cookie技术解决。</li><li>明文传输：信息容易被爬</li><li>不安全：<ul><li>明文导致密码泄露</li><li>假网站</li><li>无法证明报文完整性</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="与HTTP的区别"><a href="#与HTTP的区别" class="headerlink" title="与HTTP的区别"></a>与HTTP的区别</h3><ul><li>HTTPS 则解决 <strong>HTTP 不安全</strong>的缺陷，在TCP和HTTP网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h3><p>窃听、篡改、冒充</p><h3 id="HTTPS解决的方法"><a href="#HTTPS解决的方法" class="headerlink" title="HTTPS解决的方法"></a>HTTPS解决的方法</h3><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li></ul><div class="note note-primary">            <p>对称加密：就是一个密钥加密，并使用同一个密钥解密。<br>非对称加密：一个密钥加密，必须由另一个密钥解密。</p><p>其中非对称加密一般分公钥和私钥，这两个钥匙可以双向加解密。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；（防窃听）</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。（防冒充）</li></ul>          </div><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p><strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>。（防修改）</p><p><strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><div class="note note-primary">            <p>摘要只保证正文未被修改，不保证正文真伪。</p>          </div><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>数字签名算法</strong>，使用<strong>非对称加密算法</strong>加密哈希值（摘要）。</p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.webp"></p><p>由于中间人无法将数据使用私钥加密，其伪造的hash无法被公钥解密，所以可以得知数据被人替换过了。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>摘要和签名算法已经保证了数据不会被篡改和不被冒充。<br>但实现过程中存在漏洞：公钥的获取，客户端需要根据公钥来识别数字签名。</p><p><strong>数字证书认证机构</strong>CA：</p><ul><li>服务器可以将自己的公钥注册到CA机构，CA使用私钥将其加密后颁发数字证书。</li><li>客户端根据服务器发送的证书和公钥，将其使用CA公钥解开对比即可得知其是否得到了CA的信任。</li></ul><p>验证流程：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp"></p><h3 id="TLS握手阶段"><a href="#TLS握手阶段" class="headerlink" title="TLS握手阶段"></a>TLS握手阶段</h3><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp"></p><p>TLS 协议建立的详细流程：<br><em>1. ClientHello</em><br>客户端向服务器发送以下信息（明文）：<br>（1）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。<br>（2）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em><br>服务器回应的内容有如下内容（明文）：<br>（1）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。<br>（2）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</p><p><em>3.客户端回应</em><br>验证CA证书，取出公钥，并使用公钥加密（服务器公钥加密）：<br>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><blockquote><p>由于使用服务器公钥加密，所以只有服务器可以解密得知pre-master-key，即第三个随机数中间人无法获取。</p></blockquote><p><em>4. 服务器的最后回应</em><br>计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><blockquote><p>第三、四次握手只有第三次握手传了第三个随机数，剩下的两个内容类似TCP握手协议中的FIN，ACK确认。</p></blockquote><h3 id="TLS握手算法"><a href="#TLS握手算法" class="headerlink" title="TLS握手算法"></a>TLS握手算法</h3><p>不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的。<br>过程：与上面的过程相同。<br><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。一旦服务端的私钥泄漏了，过去被第三方截获的所有TLS通讯密文都会被破解。</p><h4 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h4><p>ECDHE 密钥协商算法是 DH 算法演进过来的。</p><h5 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h5><p>DH算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.webp"></p><ul><li>底数a和模数p是离散对数的公共参数，也就说是公开的。</li><li>b是真数（私钥），i是对数（公钥）。</li><li>知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</li></ul><h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>通讯双方各自根据自己的私钥，使用固定算法得到自己的公钥并交换。<br>根据得到的对方公钥，和自己的私钥计算，双方此时得到相同的密钥。<br>（这个算法具有交换律）</p><h5 id="DHE"><a href="#DHE" class="headerlink" title="DHE"></a>DHE</h5><p>根据私钥生成的方式，DH 算法分为两种实现：</p><ul><li>static DH 算法，这个是已经被废弃了；</li><li>DHE 算法，现在常用的；</li></ul><p>static DH不具有前向安全性，后者表示每次动态生成密钥。</p><h5 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h5><p>为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。利用了ECC 椭圆曲线特性。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p><strong>在TLS第四次握手前，客户端就已经发送了加密的 HTTP 数据，即ECDHE相比RSA握手过程省去了一个消息往返的时间</strong>。</p><ul><li>第一次握手与RSA类似</li><li>第二次握手新增了选择椭圆曲线和基点，动态生成了私钥和公钥，同时使用<strong>RSA签名算法</strong>给公钥签名并发送。</li><li>第三次握手验证CA后根据椭圆信息也生成私钥和公钥，并回复公钥。</li><li>第四次握手类似，回复确认过程没问题即可。</li></ul><div class="note note-primary">            <ul><li>ECDHE每次动态生成密钥和公钥，支持前向保密。</li><li>客户端可以在三次握手后就开始传输数据</li><li>在 TLS 第2次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li><li>依然使用了RSA算法，服务端使用了static私钥签名曲线公钥，用于保证发送的公钥不被篡改。</li></ul>          </div><h4 id="证书校核"><a href="#证书校核" class="headerlink" title="证书校核"></a>证书校核</h4><p>颁发和校核流程：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp"><br>信任链：<br>我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.webp"><br>验证链：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E9%93%BE.webp"></p><p>为何不直接由Root CA验证：<br><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p><h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p><em>SSL&#x2F;TLS</em>：SSL 是 “_Secure Sockets Layer_” 的缩写，中文叫做「安全套接层」。其标准化之后的名称改为 TLS（ “_Transport Layer Security_” ），即「传输层安全协议」。</p><p>_TLS1.3_：TLS1.3相对TLS1.2做了优化，其只需要<strong>3次</strong>握手：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/tls1.2and1.3-1.webp"></p><ul><li><strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</li><li>由于省去算法协商，直接互相交换使用相同算法计算过的公钥即完成了交换和计算，从而只需要3次握手（1RTT）。</li><li>重连时，使用Ticket技术优化的话可以在0RTT内完成重连(<strong>会话恢复机制</strong>)。</li></ul><h3 id="HTTPS的应用数据是如何保证完整性的？"><a href="#HTTPS的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS的应用数据是如何保证完整性的？"></a>HTTPS的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp"></p><p>具体过程如下：</p><ul><li>切割消息并压缩。</li><li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>通过对称密码进行加密。</li><li>加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><h3 id="HTTPS一定可靠吗？"><a href="#HTTPS一定可靠吗？" class="headerlink" title="HTTPS一定可靠吗？"></a>HTTPS一定可靠吗？</h3><p>如前面说的，HTTPS中CA部分是为了防止冒充，但这里中间人自己有证书，从而实现了服务代理。但这种证书其实是非法的，只要用户不主动接受非法证书，否则是不会出现问题的。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.webp"></p><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h3 id="如何避免被抓包"><a href="#如何避免被抓包" class="headerlink" title="如何避免被抓包"></a>如何避免被抓包</h3><ol><li>不点击允许非法证书（中间人攻击）</li><li>HTTPS双向认证，即服务端也要验证客户端信息。</li></ol><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><strong>HTTP&#x2F;2协议是基于HTTPS的。</strong><br>其兼容了老版本的HTTP&#x2F;1.1，即其仍使用http表示明文，https表示加密，而浏览器和服务器可以在背后实现协议升级。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/25-HTTP2.webp"></p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>主动推送</li></ul><div class="note note-primary">            <p>2个特点压缩信息，2个特点加强传输。</p>          </div><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>使用<code>HPAKC</code>算法，维护一张头信息表，为每个头信息生成一个id号，以后就可以只传id。</p><h4 id="HPAK算法"><a href="#HPAK算法" class="headerlink" title="HPAK算法"></a>HPAK算法</h4><ul><li>静态字典：有61种固定id和对应含义；</li><li>动态字典：自行构建动态表，发送一次后，双方都会更新自己的动态表（一个id保存本次所有Header字段），下次可以只发id；<ul><li>动态表生效前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。因此会造成内存占用过大，服务器一般会配置参数限制动态表大小，达到数量后关闭HTTP&#x2F;2连接来释放内存。</li></ul></li><li>Huffman 编码（压缩算法）；</li></ul><p>另外由于使用二进制表达，也不需要冒号空格和末尾的<code>\r\n</code>作为分隔符了，改用表示字符串长度（Value Length）来分割 Index 和 Value，一个Header字段：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224430.png"></p><h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>头信息和数据体都直接为二进制格式，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp"><br>这样解析数据时，可以直接解析二进制文件。</p><h4 id="二进制帧结构"><a href="#二进制帧结构" class="headerlink" title="二进制帧结构"></a>二进制帧结构</h4><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224926.png"></p><ul><li>帧长度后面的一个字节是表示<strong>帧的类型</strong>，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类。</li><li>帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息，比如：</li></ul><h3 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h3><p>HTTP&#x2F;1.1使用<strong>请求-响应</strong>模型，因此会产生对头阻塞。<br>HTTP&#x2F;2引入了Stream概念，使多个stream复用一个TCP连接：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/stream.webp"></p><blockquote><p>1 个 TCP 连接包含多个 Stream。<br>1 个 Stream 里可以包含多个 Message。<br>1 个 Message 对应 HTTP&#x2F;1 中的1个请求或响应，可以包含多个Frame</p></blockquote><p>每个HTTP请求（Message）都有独一无二的<strong>SteamID</strong>，这样接受端可以通过StreamID将多个Frame有序组装成一个HTTP消息。</p><ul><li>不同StreamID是可以乱序发送的。</li><li>相同Stream的frame必须有序发送。</li></ul><p>HTTP&#x2F;2 还可以对每个 Stream 设置不同<strong>优先级</strong>，在枕头中的标志位展示。</p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.webp"></p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID也是有区别的：</p><ul><li>客户端建立的Stream必须是奇数号。</li><li>服务器建立的Stream必须是偶数号。</li></ul><p>如下：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206191054.png"><br>应用有：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/push.webp"><br>主动推送css文件。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>还是存在队头阻塞问题，问题出在TCP层面。</li></ul><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><ul><li><strong>使用UDP，解决了TCP的阻塞问题。</strong></li><li>然后使用<strong>QUIC协议</strong>实现UDP可靠传输。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>特点：</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><p><em>1、无队头阻塞</em><br>多路复用，类似HTTP&#x2F;2的stream，但不受限于TCP了。<br><strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。<br>这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响（TCP）。</p><p><em>2、更快的连接建立</em><br>HTTP&#x2F;3 在传输数据前需要 QUIC 协议3次握手，需要 1 RTT。握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，其内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 <strong>TLS&#x2F;1.3</strong>，因此仅需 <strong>1 个 RTT</strong> 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.webp"><br>对于第二次连接，应用数据包+QUIC(TLS+连接信息)，可以实现0-RTT。</p><p>以下是TCP+TLS1.2，TCL+TLS1.3，QUIC三种情况在首次和再次需要的RTT时间：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206210341.png"></p><div class="note note-primary">            <p><strong>RTT是针对客户端建立连接耗时。</strong><br>TCP+TLS1.2：</p><ul><li>首次：TCP三次握手+TLS四次握手（TCP第三次握手合并，最后合并为6个）：3RTT</li><li>再次：TCP三次握手+TLS两次握手（TCP第三次握手合并，TLS使用Session技术，合并为4个）：2RTT<br>TCP+TLS1.3:</li><li>首次：TCP三次握手+TLS三次握手（TCP第三次握手合并，合并为5个）：2RTT</li><li>再次：TCP三次握手+TLS零次握手（TLS使用Ticket技术，合并为3个）：1RTT<br>QUIC+TLC1.3：</li><li>首次：QUIC三次握手+TLS三次握手（全程合并，为3个）：1RTT</li><li>再次：QUIC一次握手+TLS零次握手（QUIC和TLS使用Ticket技术，合并为1个）：0RTT</li></ul><p>RTT记忆：32,21,10。</p>          </div><p><em>3、连接迁移</em><br>四元组确定一个独立的<strong>TCP</strong>连接。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206211242.png"><br><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。</p><p>QUIC 协议没通过<strong>连接 ID</strong> 来标记通信的两个端点。只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，达到了<strong>连接迁移</strong>的功能。</p><blockquote><p>QUIC比较新，而又是基于 UDP 实现的，如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p></blockquote><h4 id="帧格式对比"><a href="#帧格式对比" class="headerlink" title="帧格式对比"></a>帧格式对比</h4><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206225705.png"></p><ul><li>类型：大体上分为数据帧和控制帧两大类，Headers 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</li><li>压缩：头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。</li><li>相比HTTP&#x2F;2，HTTP&#x2F;3的静态扩大了，动态表的解码方式不同，QPACK解决了该问题：使用两个特殊的单向流，实现字典的请求同步和响应。</li></ul><blockquote><p>动态表具有时序性，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。</p></blockquote><h1 id="三、HTTP1-1优化"><a href="#三、HTTP1-1优化" class="headerlink" title="三、HTTP1.1优化"></a>三、HTTP1.1优化</h1><p>我们可以从下面这三种优化思路来优化 HTTP&#x2F;1.1 协议：</p><ul><li>_尽量避免发送 HTTP 请求_；</li><li>_在需要发送 HTTP 请求时，考虑如何减少请求次数_；</li><li>_减少服务器的 HTTP 响应的数据大小_；</li></ul><h2 id="避免发送HTTP请求"><a href="#避免发送HTTP请求" class="headerlink" title="避免发送HTTP请求"></a>避免发送HTTP请求</h2><p>本地缓存：将请求url作为key，响应作为value保存到本地磁盘上。</p><ul><li>根据<code>Cache-Control</code>或<code>Expires</code>请求头实现强制缓存。</li><li>根据<code>Last_Modified</code>或<code>Ttag</code>请求头实现协商缓存。</li></ul><h2 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h2><ul><li>_减少重定向请求次数_；</li><li>_合并请求_；</li><li>_延迟发送请求_；</li></ul><h3 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h3><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.webp"><br><strong>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</strong><br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.webp"><br>代理服务器已知重定向规则后，直接实现代理访问：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.webp"></p><h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>多个小请求合并成大请求，body一样但避免了header重复。</p><p>另外，HTTP&#x2F;1.1的管道模式默认不开启，即存在请求队头阻塞问题，浏览器的处理方式是多开几个TCP连接一起访问，所以合并请求也可以减少TCP连接的数量。</p><h3 id="延迟发送请求"><a href="#延迟发送请求" class="headerlink" title="延迟发送请求"></a>延迟发送请求</h3><p>即懒加载。</p><h2 id="减少HTTP响应的数据大小"><a href="#减少HTTP响应的数据大小" class="headerlink" title="减少HTTP响应的数据大小"></a>减少HTTP响应的数据大小</h2><p><strong>压缩</strong>的方式一般分为 2 种，分别是：</p><ul><li>_无损压缩_；</li><li>_有损压缩_；</li></ul><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Encoding: gzip, deflate, br<br></code></pre></td></tr></table></figure><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>q表示质量引子。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: audio/*; q=<span class="hljs-number">0</span>.<span class="hljs-number">2</span>, audio/basic<br></code></pre></td></tr></table></figure><h3 id="增量数据"><a href="#增量数据" class="headerlink" title="增量数据"></a>增量数据</h3><p>对于视频和声音等，可以使用增量数据的方式表示后续帧。<br>对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p><div class="note note-primary">            <p>记忆总结：</p><ul><li>数量上不发</li><li>数量上少发</li><li>大小上减少</li></ul>          </div><h1 id="四、HTTPS优化"><a href="#四、HTTPS优化" class="headerlink" title="四、HTTPS优化"></a>四、HTTPS优化</h1><h2 id="性能消耗"><a href="#性能消耗" class="headerlink" title="性能消耗"></a>性能消耗</h2><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p><strong>HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</strong>，可以选择对应指令优化的CPU。</p><h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><ul><li>软件升级：Linux系统内核升级</li><li>协议优化：<ul><li>ECDHE密钥交换，客户端不用等第四次握手就可以发送消息。</li><li>TLS升级1.3，1RTT即完成握手。</li></ul></li></ul><h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><h4 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h4><p>相同强度下，椭圆曲线（ECDSA）证书比RSA证书密钥长度更短</p><h4 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h4><p>减少验证链的过程。</p><p>CRL：证书吊销列表（_Certificate Revocation List_）<br>即快速失败策略，会越来越大，也不好维护，已经不再使用。<br>OCSP：在线证书状态协议（_Online Certificate Status Protocol_），<strong>向CA发送请求查询，返回有效状态</strong>。</p><h5 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h5><p>服务器向CA周期性查询证书状态，并缓存经过<strong>签名</strong>结果。<br>客户端发起连接请求时，服务器把响应结果回复给客户端。<br>由于<strong>签名</strong>的存在，服务器无法篡改。</p><div class="note note-primary">            <p>即把客户端CA验证变成了服务端统一验证。</p>          </div><h2 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h2><ul><li>第一种叫 Session ID，1RTT；</li><li>第二种叫 Session Ticket，1RTT；</li><li>第三种叫 Pre-shared Key，0RTT；</li></ul><h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p><strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>。</p><p>缺点是占用内存（空间换时间），且不一定会命中上次访问过地服务器。</p><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p><strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。<br>客户端缓存Ticket，下次连接时发送，服务器直接解密校验。</p><p>缺点是要确保每台服务器的加解密方式一样，且不具有前向安全性。</p><h3 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h3><p>对于<strong>重连 TLS1.3</strong>只需要 0 RTT，原理与Ticket类似，但其重连时会直接把Ticket和HTTP一起发送给服务端。</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>中间人获取Session ID&#x2F;Ticket后模拟客户端不断请求。因此，要对<strong>对会话密钥设定一个合理的过期时间</strong>，并只对安全请求使用会话重用。</p><h1 id="五、RPC协议"><a href="#五、RPC协议" class="headerlink" title="五、RPC协议"></a>五、RPC协议</h1><h2 id="TCP存在的问题"><a href="#TCP存在的问题" class="headerlink" title="TCP存在的问题"></a>TCP存在的问题</h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。<br>由于TCP是<strong>基于字节流</strong>的，字节之间没有边界，会造成<strong>粘包问题</strong>。因此，一般使用TCP时，还需要自定义一些信息，如消息头中标记长度，从而取出正确的数据。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。<br>主要思想是像调用本地方法一样调用远程方法。<br><img src="/Pasted%20image%2020230207112106.png"><br>有非常多款式的 RPC 思想的实现，比如比较有名的<code>gRPC</code>，<code>thrift</code>。虽然大部分 RPC 协议底层使用 TCP，但实际上<strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><h3 id="存在"><a href="#存在" class="headerlink" title="存在"></a>存在</h3><ul><li>为什么有了HTTP还要RPC：RPC在HTTP前诞生</li><li>为什么有了RPC还要HTTP：B&#x2F;S架构的诞生，需要统一协议。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul><li>HTTP访问需要<strong>IP</strong>和<strong>端口</strong>。</li><li>RPC访问时，可以找中间服务获取IP等信息。</li></ul><p>本质上区别不大。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><ul><li>RPC和HTTP1.1一样，有长连接</li><li>RPC和HTTP一样，可以存在连接池</li></ul><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>RPC定制化程度更高，序列化协议的体积更小，因此<strong>性能</strong>也更好。</p><blockquote><p>当然上面说的 HTTP，其实<strong>特指的是现在主流使用的 HTTP&#x2F;1.1</strong>，<code>HTTP/2</code> 在前者的基础上做了很多改进，所以<strong>性能可能比很多 RPC 协议还要好</strong>，甚至连 <code>gRPC</code> 底层都直接用的 <code>HTTP/2</code>。</p></blockquote><h1 id="六、WebSocket"><a href="#六、WebSocket" class="headerlink" title="六、WebSocket"></a>六、WebSocket</h1><h2 id="服务器主动推送消息的方式"><a href="#服务器主动推送消息的方式" class="headerlink" title="服务器主动推送消息的方式"></a>服务器主动推送消息的方式</h2><ul><li>HTTP不断轮询：轮询存在间隔，有卡顿，浪费资源。</li><li>长轮询:即将超时时间设置的很长，出现响应后才回复（扫码）</li><li>WebSocket</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>HTTP&#x2F;1.1，使用了半双工的方式（请求-响应）。</p><h3 id="建立WebSocket连接"><a href="#建立WebSocket连接" class="headerlink" title="建立WebSocket连接"></a>建立WebSocket连接</h3><p>1）浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p><ul><li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是继续用普通 HTTP 协议进行交互。</li><li>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：即浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<br><span class="hljs-symbol">Upgrade:</span> WebSocket<br><span class="hljs-keyword">Sec</span>-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n<br></code></pre></td></tr></table></figure></li></ul><p>2）服务器接受到消息后，如果也想升级成WebSocket协议，则走WebSocket 握手流程，同时根据客户端生成的base64码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols\r\n<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>WebSocket\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade\r\n<br></code></pre></td></tr></table></figure><p>3）浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p><h3 id="WebSocket消息格式"><a href="#WebSocket消息格式" class="headerlink" title="WebSocket消息格式"></a>WebSocket消息格式</h3><p>数据包在WebSocket中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。<br><img src="/Pasted%20image%2020230207113622.png"><br><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p><ul><li>等于 1 ，是指text类型（<code>string</code>）的数据包</li><li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li><li>等于 8 ，是关闭连接的信号</li></ul><p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p><ul><li>既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit 或 7+64bit。</code></li><li>根据最前面7bit的数值绝对，若为126则实际上为<code>16bit</code>，127则实际上为<code>64bit</code>。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p><p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第5章（线程池）</title>
    <link href="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/"/>
    <url>/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程池工作原理"><a href="#一、线程池工作原理" class="headerlink" title="一、线程池工作原理"></a>一、线程池工作原理</h1><h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：系统的资源是有限的，所以线程作为一个消耗系统资源的东西，就不可能无限制的创建。这样，我们通过引入线程池，对线程进行进行统一地分配和监控，降低手动管理每个线程的复杂度。</li></ul><blockquote><p>阿里巴巴的《Java 开发手册》中也强制规定了：<strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong>。</p></blockquote><h2 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h2><p>线程池的组成：</p><ul><li>核心线程池（存储线程）</li><li>工作队列（存储任务）</li></ul><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203232839.png"><br>当提交一个新任务到线程池时，线程池的处理流程分如下三步走：</p><ol><li>判断核心线程池里的线程是否都在执行任务（<strong>核心线程池是否已满</strong>）：<ul><li>如果不是，则创建一个新的工作线程来执行任务。</li><li>如果核心线程池里的线程都在执行任务，则进入下一步。</li></ul></li><li>判断<strong>工作队列是否已满</strong>：<ul><li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li><li>如果工作队列满了，则进入下一步。</li></ul></li><li>判断线程池中的所有线程是否都处于工作状态（<strong>线程池是否已满</strong>）：<ul><li>如果没有，则创建一个新的工作线程来执行任务。</li><li>如果已经满了，则交给<strong>饱和策略</strong>来处理这个任务。</li></ul></li><li>饱和策略有以下几种：<ul><li>AbortPolicy（默认）：无法处理新任务时直接抛出异常</li><li>CallerRunsPolicy：使用调用者所在的线程来运行新任务（这个很好理解，一般我们都是主线程提交任务，然后扔进线程池执行，对吧。当线程池满了后，如果使用这个策略，就会调用主线程来执行新任务）</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并将新任务加入队列</li><li>DiscardPolicy：不做任何处理，直接将新任务丢弃掉，粗暴！</li></ul></li></ol><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203233411.png"></p><div class="note note-primary">            <p>总的思路是<strong>尽量使用核心线程池的线程执行任务</strong>，实在不行再请求新线程，还不行就走饱和策略。</p>          </div><p><strong>工作队列何时出列？</strong><br>线程在执行完任务后，就会主动从工作队列中获取任务来执行。</p><p><strong>为什么这样设计？</strong><br>创建新线程永远不是最优先的选择，而是尽可能地复用已存在的线程。</p><h1 id="二、创建线程池"><a href="#二、创建线程池" class="headerlink" title="二、创建线程池"></a>二、创建线程池</h1><p>线程池的创建方法总体来说可分为 2 大类：</p><ul><li>一种是通过 <code>Executors</code> 创建的线程池</li><li>另一种是通过 <code>ThreadPoolExecutor</code> 创建的线程池</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 封装了6种方法，对应创建6种不同的线程池：</p><ul><li>FixedThreadPool</li><li>CachedThreadPool</li><li>SingleThreadExecutor</li><li>WorkStealingPool</li><li>ScheduledThreadPool</li><li>SingleThreadScheduledExecutor</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234231.png"><br>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建包含 2 个线程的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 创建任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>    &#125;<br>&#125;;<br>fixedThreadPool.submit(runnable);<br>fixedThreadPool.execute(runnable);<br></code></pre></td></tr></table></figure><p>execute和submit </p><ul><li>execute用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li><li>submit用于提交需要返回值的任务，线程池会返回一个 Future 类型的对象。</li></ul><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>创建一个可缓存的线程池，若线程数超过处理任务所需（供 &gt; 求），多出来的线程缓存一段时间后会被回收掉；而如果线程数不够（供 &lt; 求），则线程池会新建一些线程出来。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234225.png"></p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>创建只包含一个线程的线程池，它可以保证任务先进先出的执行顺序。也就说，先被扔进线程池的任务，就会被先执行<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234321.png"></p><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234401.png"><br>和 SingleThreadExecutor相反，WorkStealingPool创建的是一个抢占式执行的线程池，也即任务执行顺序不确定。</p><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>创建一个可以执行延迟&#x2F;定时任务的线程池。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234413.png"><br>这时就不再使用<code>execute/submit</code>了，而是<code>schedule</code>。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234500.png"></p><h3 id="SingleThreadScheduledExecutor"><a href="#SingleThreadScheduledExecutor" class="headerlink" title="SingleThreadScheduledExecutor"></a>SingleThreadScheduledExecutor</h3><p>这个方法创建的是仅包含 1 个线程线程池，并且它可以执行延迟任务。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>上述Executors的6种方法，其底层最终调用的都是ThreadPoolExecutor的构造函数，只不过参数不同。可以简单理解为，<code>ThreadPoolExecutor</code>是最基本的创建线程池的方式，<code>Executors</code>对其做了一定的封装。</p><blockquote><p>在阿里巴巴的《Java 开发手册》上，明确规定了：<br>【强制要求】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234656.png"></p><ol><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</li><li>unit：即keepAliveTime的单位</li><li>workQueue：阻塞队列</li><li>threadFactory：线程工厂，主要用来创建线程，默认为正常优先级、非守护线程。</li><li>handler：拒绝策略，即饱和策略<ul><li>AbortPolicy (默认策略)：拒绝执行并抛出异常</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy：抛弃阻塞队列头部（最旧）的一个任务，并执行当前任务</li><li>DiscardPolicy：忽略并抛弃当前任务</li></ul></li></ol><div class="note note-primary">            <p><strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>阻塞队列</strong>是限制大小的。<br><strong>存活时间</strong>和<strong>单位</strong>是管理非核心线程的。<br><strong>工厂</strong>管理生成线程策略。<br><strong>处理器</strong>决定饱和策略。</p>          </div><p>后两个参数一般默认，常用的是5参数版本：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203235208.png"></p><h3 id="为什么不要使用Executors创建线程池"><a href="#为什么不要使用Executors创建线程池" class="headerlink" title="为什么不要使用Executors创建线程池"></a>为什么不要使用Executors创建线程池</h3><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</li><li>CachedThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li></ul><h1 id="三、Executor"><a href="#三、Executor" class="headerlink" title="三、Executor"></a>三、Executor</h1><p>Executor是一个接口，更是一个框架！<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203235700.png"></p><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204002439.png"></p><ul><li>任务：包括被执行任务需要实现的接口：<code>Runnable/Callable</code>接口</li><li>任务的执行：包括任务执行机制的核心接口<code>Executor</code>，以及继承自 <code>Executor</code>的<code>ExecutorService</code>接口。<ul><li><code>Executor</code>框架有两个关键类实现了<code>ExecutorService</code>接口，分别为<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code></li></ul></li><li>任务执行的结果：包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204002726.png"></p><ol><li>创建Runnable&#x2F;Callable</li><li>提交给ExecutorService，ExecutorService根据具体实现来处理任务。</li><li>返回Future&#x2F;FutureTask(FutureTask是Future的实现类)</li></ol><h2 id="Executors、Executor、ExecutorService"><a href="#Executors、Executor、ExecutorService" class="headerlink" title="Executors、Executor、ExecutorService"></a>Executors、Executor、ExecutorService</h2><p>区别：</p><ul><li><code>ExecutorService</code>接口继承了<code>Executor</code>接口<ul><li><code>execute()</code>方法在<code>Executor</code>中定义，而<code>submit()</code>在<code>ExecutorService</code>中定义。</li><li><code>ExecutorService</code>提供了很多控制线程池的方法，如<code>shutdown</code>。</li></ul></li><li><code>Executors</code>只是一个工具类，快速生成<code>ExecutorService</code>的子类，如<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>。</li></ul><h1 id="四、配置线程池"><a href="#四、配置线程池" class="headerlink" title="四、配置线程池"></a>四、配置线程池</h1><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204003341.png"><br>三个参数：<code>corePoolSize</code>核心线程数、<code>maximumPoolSize</code>最大线程数和 <code>workQueue</code>阻塞队列，就是我们在创建线程池时应该关注的重点。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="线上与线下"><a href="#线上与线下" class="headerlink" title="线上与线下"></a>线上与线下</h3><p><strong>线上 - 响应速度优先</strong>：需要快速响应用户的请求，应该不设置阻塞队列去缓冲并发任务，调高 <code>corePoolSize</code> 和 <code>maxPoolSize</code> 去创造尽可能多的线程快速执行任务。<br><strong>线下 - 吞吐量优先</strong>：需要尽可能快地批量处理任务，应该设置阻塞队列去缓冲并发任务，调整合适的<code>corePoolSize</code>去设置处理任务的核心线程数。</p><h3 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h3><p><strong>CPU密集型任务</strong>：充分利用CPU，设置corePoolSize为CPU数+1（备用，防止其他线程暂停不工作）。<br><strong>IO密集型任务</strong>：尽可能多配置核心线程，IO等待时让其他线程占用CPU。<br>主要还是看实际生产情况灵活调整。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第4章（并发集合与工具类）</title>
    <link href="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/"/>
    <url>/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、并发集合"><a href="#一、并发集合" class="headerlink" title="一、并发集合"></a>一、并发集合</h1><p>J.U.C 为每一类集合都提供了线程安全的实现，且大多都是以 <code>Concurrent</code> 或者 <code>CopyOnWrite</code> 开头的。</p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>1)List</p><ul><li><code>Vector</code>（这个没啥好说的，它就是把 ArrayList 中所有的方法统统加上 <code>synchronized</code> ）</li><li><code>CopyOnWriteArrayList</code></li></ul><p>2)Set</p><ul><li><code>CopyOnWriteArraySet</code></li><li><code>ConcurrentSkipListSet</code></li></ul><p>3)Queue</p><ul><li>BlockingQueue 接口<ul><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>ConcurrentLinkedQueue</li></ul></li><li>TransferQueue 接口<ul><li>LinkedTransferQueue</li></ul></li><li>BlockingDeque 接口<ul><li>LinkedBlockingDeque</li><li>ConcurrentLinkedDeque</li></ul></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li>HashTable（就是把 HashMap 中所有的方法统统加上 synchronized ）</li><li>ConcurrentMap 接口<ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul><li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</li><li>Segment 继承自 ReentrantLock，是一种可重入锁；HashEntry 是用于真正存储数据的地方</li><li>一个 ConcurrentHashMap 包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，当对某个 HashEntry 数组中的元素进行修改时，必须首先获得该元素所属 HashEntry 数组对应的 Segment 锁</li></ul><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203174438.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 真正存放数据的地方</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<br>    <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 阈值</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><br>    Segment(<span class="hljs-type">float</span> lf, <span class="hljs-type">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">this</span>.loadFactor = lf;<br>        <span class="hljs-built_in">this</span>.threshold = threshold;<br>        <span class="hljs-built_in">this</span>.table = tab;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简而言之，将HashCode分片，每片持有一个锁（ReentrantLock），多个桶（HashEntry数组）</p><p><strong>每个 <code>HashEntry</code> 是一个链表结构的元素</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V value;<br>    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><p>HashEntry维护了一个next指针，并注意value被<code>volatile</code>修饰，保证了可见性。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-comment">// 1. 通过 key 定位到具体的 Segment</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject<br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>)<br>        s = ensureSegment(j);<br>    <span class="hljs-comment">// 在对应的 Segment 中进行真正的 put</span><br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对key做hash处理（1次hash）</li><li>对key做掩码等处理（2次hash）</li><li>获取对应segment，如果为空则创建。</li><li>在对应segment上执行put操作（使用1次hash的值）</li><li>获取segment的锁，失败则自旋直到成功</li><li>成功后判断是否需要扩容HashEntry数组，然定位、插入。</li></ol><p>注意这里获取segment时，对key做了两次hash处理，目的是尽可能将将数据打散到各个segment。</p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ol><li>通过二次hash定位到具体segment</li><li>通过一次hash定位到具体元素</li></ol><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>不同于 JDK 1.7 版本的 Segment 数组 + HashEntry 链表。</p><ul><li>JDK 1.8 版本中的 ConcurrentHashMap 直接抛弃了 Segment 锁，一个 ConcurrentHashMap 包含一个 Node 数组（和 HashEntry 实现差不多）</li><li>每个 Node 是一个链表结构，并且在链表长度大于一定值时会转换为红黑树结构（TreeBin）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br><br>    Node(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p>TreeBin继承了Node，当Node链表长度过长时，会升级为TreeBin。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203175817.png"><br>结构图：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203175855.png"></p><p>使用<strong>synchronized+CAS</strong>保证并发安全性。</p><p>Node 数组其实就是一个哈希桶数组，每个 Node 头节点及其所有的 next 节点组成的链表就是一个桶，只要锁住这个桶的<strong>头结点</strong>，就不会影响其他哈希桶数组元素的读写。</p><blockquote><p>JDK 1.8 没有使用 ReentrantLock 而是改用 synchronized，足以说明新版 JDK 对 synchronized 的优化确有成效。</p></blockquote><h4 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h4><ol><li>根据key计算hash</li><li>根据hash定位Node<ul><li>若Node为空，则CAS写入（失败则自旋，重新判断Node是否为空）；</li><li>若不为空但hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1，需要扩容</li><li>若不为空且不需要扩容，则利用synchronized写入数据。</li></ul></li></ol><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><ol><li>根据key计算hash</li><li>根据hash定位Node</li><li>判断节点类型并搜索</li></ol><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列含义：</p><ul><li><strong>当队列满时，队列会阻塞向其中插入元素的线程，直到队列不满</strong></li><li><strong>当队列为空时，获取队列中元素的线程会一直等待，直到队列变为非空</strong><br>应用场景：生产者-消费者<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181313.png"><br>模式：<strong>当队列满时，生产者阻塞，当队列空时，消费者阻塞</strong>。</li></ul><h3 id="Java中的BlockingQueue"><a href="#Java中的BlockingQueue" class="headerlink" title="Java中的BlockingQueue"></a>Java中的BlockingQueue</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181429.png"><br>Java 中提供了一个阻塞队列的接口 BlockingQueue 以及 7 个具体的实现（6 个单向队列和 1 个双端队列）：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue：一个使用 PriorityBlockingQueue 实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储任何元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><h4 id="有界队列与无界队列"><a href="#有界队列与无界队列" class="headerlink" title="有界队列与无界队列"></a>有界队列与无界队列</h4><p>以LinkedBlockingQueue为例：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181546.png"></p><ul><li>带参构造函数需要指定队列的长度，并且当<strong>队列满了之后也不会对其进行扩容</strong>，这就是有界队列</li><li>而<strong>无参构造函数赋给队列的长度是 Integer.MAX_VALUE</strong>，显然现实几乎不会有这么大的容量超过 Integer.MAX_VALUE，所以从使用者的体验上，可以无限入队，相当于无界队列</li></ul><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>主要方法：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181646.png"><br>方法区别：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181641.png"></p><p>主要研究：”阻塞进” <code>put()</code> 和 “阻塞出” <code>take()</code></p><p>阻塞队列利用<code>Lock</code>中的<code>Condition</code>使用<strong>通知模式</strong>，实现对生产者，消费者的通知。</p><p>以<code>ArrayBlockingQueue</code>为例，其拥有两个condition成员变量：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181939.png"></p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 获取可中断锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果当前元素个数等于队列的最大长度，则调用 notFull.await() 进行等待</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br>        <span class="hljs-comment">// 向队列中插入元素</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 入队成功，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取可中断锁</li><li>判断队列空间<ul><li>如果队列空间不足，则在notFull队列中等待，被唤醒后继续尝试入列（<code>enqueue</code>，该方法中调用了notEmpty.signal()，提醒消费者）。</li><li>如果队列空间足够，入列（<code>enqueue</code>）</li></ul></li><li>释放锁</li></ol><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 获取可中断锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果队列中没有元素，则调用 notEmpty.await() 进行等待</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-comment">// 从队列中取出元素</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 出队成功，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取可中断锁</li><li>判断队列是否为空<ul><li>若为空，则在在notEmpty队列中等待，被唤醒后再尝试获取</li><li>若不为空，则获取元素(<code>dequeue</code>，notFull.signal()，提醒生产者)</li></ul></li><li>释放锁</li></ol><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203182814.png"></p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>ConcurrentLinkedQueue，使用CAS保证线程安全。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203182841.png"></p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>Vector</code> 其实是非常粗暴的给ArrayList所有方法都加上了锁，导致并发度不高。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>ArrayList迭代时，不允许集合被修改。因此需要避免多线程下ArrayList线程不安全的问题。<br>可以通过读写锁避免读时写，但如果我们希望无论合适都可以读取到数据，则需要COW的思想。</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>COW放弃了这种数据实时性，通过满足数据的最终一致性从而提升并发度。顾名思义，写时复制，Redis的主从复制就是使用的这种思想。<br>写操作时，先创建目标对象的拷贝，对拷贝对象写完成后替换原对象。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>CopyOnWriteArrayList维护一个底层数组，其可以被替换。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203183841.png"></p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203183612.png"></p><ol><li>加重入锁</li><li>复制数组</li><li>改写数组元素并替换原数组对象</li><li>释放锁</li></ol><h3 id="延时感知"><a href="#延时感知" class="headerlink" title="延时感知"></a>延时感知</h3><p>读线程读取数组元素时，可能读到的是旧数组。</p><h3 id="COW缺点"><a href="#COW缺点" class="headerlink" title="COW缺点"></a>COW缺点</h3><ul><li>复制严重消耗<strong>性能</strong>。</li><li>会产生大量数组垃圾，容易造成GC（<strong>内存</strong>）。</li><li>对实时性要求高的化也不建议使用。</li></ul><h1 id="二、并发工具类"><a href="#二、并发工具类" class="headerlink" title="二、并发工具类"></a>二、并发工具类</h1><p>J.U.C 为我们封装了一些有用的控制并发流程的工具，CountDownLatch、CyclicBarrier、Semaphore 以及 Exchanger。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒计时器，一个线程执行一定的时间后另一个线程才可以开始（继续）执行。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>join方法也可以提供类似的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>System.out.println(<span class="hljs-string">&quot;first thing finish&quot;</span>);   <br>    &#125;        <br>&#125;);          <br><br>threadA.start();     <br>threadA.join();   <br>System.out.println(<span class="hljs-string">&quot;FINISH&quot;</span>);    <br></code></pre></td></tr></table></figure><p>主线程会等待A线程完成后再执行FINISH打印。<br>join()方法还提供了<code>join(long millis)</code> 和 <code>join(long millis,int nanos)</code>，可以设置超时时间和时间单位。</p><p>join的底层原理：<strong>wait&#x2F;notify</strong> 等待通知机制。</p><h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203184730.png"><br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203184732.png"></p><ul><li>CountDownLatch 的构造函数接收一个 int 类型的参数（count）作为计数器。</li><li>每调用一次 countDown 方法，这个 count 就会减 1。</li><li>当 count 不为 0 的时候，我们可以调用 CountDownLatch 的 await 方法阻塞当前线程，直到 count 变为 0，当前线程才可以继续往下执行。</li></ul><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;first thing finish&quot;</span>);   <br>        countDownLatch.countDown(); <span class="hljs-comment">// count --</span><br>        System.out.println(<span class="hljs-string">&quot;second thing finish&quot;</span>);        <br>        countDownLatch.countDown(); <span class="hljs-comment">// count --</span><br>    &#125;        <br>&#125;).start();<br>countDownLatch.await(); <span class="hljs-comment">// 主线程被阻塞住，直到 count = 0</span><br>System.out.println(<span class="hljs-string">&quot;FINISH&quot;</span>);    <br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>join是必须等待其他线程执行完或超时才继续执行，这里则通过信号量的方式实现对主线程的通知。</p>          </div><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>        cyclicBarrier.await(); <span class="hljs-comment">// 子线程已达到屏障</span><br>        System.out.println(<span class="hljs-string">&quot;child Thread&quot;</span>);   <br>    &#125;        <br>&#125;).start();<br><br>cyclicBarrier.await(); <span class="hljs-comment">// 主线程已到达屏障</span><br>System.out.println(<span class="hljs-string">&quot;main Thread&quot;</span>);  <br></code></pre></td></tr></table></figure><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203185034.png"></p><p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties，Runnable barrier-Action)</code>，就是说，当抵达屏障的线程数量满足parties后，在所有被阻塞的线程继续执行之前（即屏障打开之前），率先执行<code>barrier-Action</code>方法。</p><div class="note note-primary">            <p>都是通过调用工具类对象的<code>await</code>方法实现线程阻塞，然后工具类在合适的时候会唤醒线程。</p>          </div><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用许可证来理解更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">20</span>);<br><span class="hljs-comment">//申请许可证</span><br>s.acquire();<br><span class="hljs-comment">//释放许可证</span><br>s.release();<br></code></pre></td></tr></table></figure><p>就像餐厅的座位有限一样，需要排队恰饭一样。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203185405.png"><br>其最大的作用就是限流，和阻塞队列的原理有些相似，只不过阻塞队列限制的是排队的长度，这里限制的是恰饭的人数。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>两个线程想要互相阻塞式地交换信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;aaa&quot;</span>);  <br>                System.out.println(<span class="hljs-string">&quot;B发生的消息：&quot;</span>+A);  <br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123; <br>            &#125;   <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;bbb&quot;</span>);  <br>            System.out.println(<span class="hljs-string">&quot;A发生的消息：&quot;</span>+B);  <br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123; <br>        &#125;<br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure><p>交换到信息后，两个线程各自继续执行。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal称不上是一个工具类，但其能起到隔离线程之间数据的效果。<br>线程在ThreadLocal中设置的值是线程私有的。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();  <br>threadLocal.set(<span class="hljs-string">&quot;aa&quot;</span>);  <br>threadLocal.get();  <br>System.out.println(threadLocal.get());  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191027.png"></p><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191043.png"></p><ol><li>通过线程t获取ThreadLocalMap</li><li>通过ThreadLocalMap设置（this，value）</li></ol><p>解释：<br>1）ThreadLocalMap<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191419.png"><br>ThreadLocalMap是ThreadLocal的内部类，其中，Entry是map中的节点，从来存储真正的k-v数据。所以当向ThreadLocal中set值时，实际上是在给ThreadLocalMap赋值，即，在ThreadLocalMap中创建新的Entry节点。<br>2）<code>map.set(this,value)</code><br>ThreadLocal是一个公共对象，且可以有多个ThreadLocal存在。</p><ul><li>同一个ThreadLocal在不同的线程下代表不同的值。</li><li>使用一个线程查看不同的ThreadLocal也具有不同的意义。</li></ul><p>因此，实际上只有<code>ThreadLocalMap</code>是线程私有的，<code>ThreadLocalMap</code>中的Entry存储着真正的值，通过这个map，以不同的<code>ThreadLocal</code>为键，即可存储本线程中不同<code>ThreadLocal</code>的值。</p><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191609.png"></p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191704.png"><br>可以看出来，一个 ThreadLocal 只能保存一个 “key : value” 键值对，并且各个线程的数据互不干扰。</p><h3 id="ThreadLocal经典之内存泄漏"><a href="#ThreadLocal经典之内存泄漏" class="headerlink" title="ThreadLocal经典之内存泄漏"></a>ThreadLocal经典之内存泄漏</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203192458.png"></p><p><strong>Entry结构</strong><br>ThreadLocalMap，底层保存了Entry数组，作为存储的桶。</p><p>Entry结构持有：</p><ul><li>虚引用threadLocal</li><li>实引用value</li></ul><p>在构造Entry（继承了<code>WeakReference&lt;ThreadLocal&gt;</code>，因此其可以虚引用一个<code>ThreadLocal</code>字段）的时候，会顺便把对应的<code>ThreadLocal</code>设置它的一个弱引用，空间不足且满足条件时可以将其释放。</p><p><strong>如何判断Entry的Index</strong><br>使用<code>(threadLocal.threadLocalHashCode &amp; capacity-1)</code>作为entry在数组中存放的地址。<br>这种设计是基于不会发生hash冲突的预期而实现的，数组中一个桶只放一个entry。</p><p><strong>为什么要使用弱引用保存key？</strong><br><code>ThreadLocalMap</code>的生命与<code>Thread</code>一样长，若使用了<code>ThreadLocal</code>作为键保存值而不进行回收，则会造成内存泄漏。</p><p><strong>存在的问题</strong><br>虽然key被设计成弱应用了，可以从某种程度上避免内存泄漏，但是，value仍然是强引用！需要<strong>显式地调用<code>remove</code>方法</strong>。</p><p><strong>为什么value不设置成弱引用</strong><br>因为不清楚这个value是否存在其他引用，如果value是弱引用对象，但存在其他引用，则GC时可能直接将value回收了。但ThreadLocal还在使用期间，导致get获取到null。</p><p><strong>要保证value的生命周期比key的生命周期长。</strong></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第3章（Lock接口）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、CAS"><a href="#一、CAS" class="headerlink" title="一、CAS"></a>一、CAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>乐观锁的目的就是在不使用锁（悲观锁）的情况下保证线程安全</strong>。<br>乐观锁在 Java 中是采用 CAS 算法实现的，J.U.C 包中的原子类就是通过 CAS 算法来实现了乐观锁。<br>使用这种 CAS 算法的代码也常被称为 <strong>无锁</strong> 编程（Lock-Free）。<br>**现代处理器基本都已经内置了实现 CAS 的指令，比如 x86 指令集上的 <code>CAMPXCHG</code>**。<br>当多个线程尝试使用 CAS 同时更新主内存中的同一个变量时，只有一个线程可以成功更新变量的值，其他的线程都会失败，失败的线程并不会挂起，而是会自旋重试。</p><p><strong>CAS</strong>（Compare And Set）的步骤为：</p><ul><li>读取主内存值</li><li>将读取到的值再与主内存值比较</li><li>将新值交换到该变量</li></ul><h2 id="CAS三大问题"><a href="#CAS三大问题" class="headerlink" title="CAS三大问题"></a>CAS三大问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203125031.png"></p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><strong>在变量值前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A</strong>。<br>从 Java 1.5 开始，JDK 的 Atomic 包里提供了一个类 <code>AtomicStampedReference</code> 来解决 ABA 问题，把变量放在 <code>AtomicStampedReference</code> 类中即可。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>x86 指令集上使用 CAMPCHG 来实现 CAS 操作，我们在一些源码里看到的 CAS 操作其实都是对这条底层指令的封装罢了，而<strong>这条指令的功能就是一次只原子地修改一个变量</strong>。</p><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ol><li>使用锁</li><li>将变量合并，操作后再拆解</li></ol><p>从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，这样我们就可以把多个变量封装在一个对象里来进行 CAS 操作。</p><h3 id="循环时间开销"><a href="#循环时间开销" class="headerlink" title="循环时间开销"></a>循环时间开销</h3><p>失败时一直重试，开销过大，CPU空转</p><h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>使 JVM 支持底层指令 pause，这个指令的功能就是当自旋失败时让 CPU 睡眠一小段时间再继续自旋，其有两个作用：<br>1）降低读操作的频率；<br>2）避免在退出循环的时候因 内存顺序冲突（Memory OrderViolation） 而引起 CPU 流水线被清空（CPU PipelineFlush）。</p><blockquote><p>内存顺序就是CPU访问内存的顺序，持锁线程store后，其他线程load才可以获取锁，但如果重排序，会导致load到的数据无效，此时会清空流水线再重排序，而pause可以减少重排序所耗费的时间。</p></blockquote><h1 id="二、Unsafe与原子类"><a href="#二、Unsafe与原子类" class="headerlink" title="二、Unsafe与原子类"></a>二、Unsafe与原子类</h1><h2 id="Unsafe-类浅析"><a href="#Unsafe-类浅析" class="headerlink" title="Unsafe 类浅析"></a>Unsafe 类浅析</h2><p>Unsafe 类存在于 sun.misc 包中，单从名称看来就可以知道该类是非安全的，因为其内部方法操作可以像 C 的指针一样直接操作内存（全是本地方法）。</p><p>所以事实上 Java 官方也不建议我们直接去使用 Unsafe 类。J.U.C 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p><p>CAS相关方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203125836.png"><br>将参数重命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapXxx</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object expected, Object update)</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数 o 为给定对象，即包含要修改字段的对象</li><li>第二个参数 offset 为对象内存的偏移量，通过这个偏移量可以迅速定位字段并设置或获取该字段的值</li><li>第三个参数 expected 表示期望值</li><li>第四个参数 update 表示要设置的值</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>在 Atomic 包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新属性（字段）</li></ul><h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><ul><li><code>AtomicBoolean</code>：原子更新布尔类型</li><li><code>AtomicInteger</code>：原子更新整型</li><li><code>AtomicLong</code>：原子更新长整型</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203134452.png"><br>常用方法：</p><ul><li><code>addAndGet</code></li><li><code>compareAndSet</code></li><li><code>getAndIncrement</code>、<code>getAndDecrement</code></li><li><code>getAndSet</code></li></ul><p>这些方法底层都是调用Unsafe类的方法进行CAS操作。<br>对于其他基本类型如char，float，double等，会先把其他类信息转换成int&#x2F;long类型再进行操作。</p><h3 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h3><ul><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203134948.png"><br>常用方法略，就是多一个数组索引。</p><h3 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h3><ul><li><code>AtomicReference</code>：原子更新引用类型</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li><li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203135105.png"><br>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReference&lt;User&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">16</span>);                <br>reference.set(user1);            <br><br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user2&quot;</span>, <span class="hljs-number">18</span>);<br>reference.compareAndSet(user1, user2);<br><br>System.out.println(reference.get().getName()); <span class="hljs-comment">// &quot;user2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原子更新字段"><a href="#原子更新字段" class="headerlink" title="原子更新字段"></a>原子更新字段</h3><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段</li><li>AtomicLongFieldUpdater：原子更新长整型字段</li><li>AtomicStampedReference：原子更新带有版本号的引用类型</li></ul><p>这三个方法不同于前面的简单封装，而是被称为原子更新器，构造函数如下：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203135443.png"><br>即都是通过抽象类的静态方法获取更新器实例，基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 原子更新 User 类的 age 字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 旧值是 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> updater.getAndAdd(user, <span class="hljs-number">5</span>); <span class="hljs-comment">// 原子更新为 5</span><br>        System.out.println(oldValue); <span class="hljs-comment">// 1</span><br>        System.out.println(updater.get(user)); <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="三、Lock接口"><a href="#三、Lock接口" class="headerlink" title="三、Lock接口"></a>三、Lock接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>为什么需要Lock？</strong><br>synchronized锁隐式的限定了锁的获取和释放位置，导致某线程获取锁的顺序总是先获取先释放（栈式），满足不了更多的需要，而lock手动获取释放。</p><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>         <span class="hljs-comment">// 加锁</span><br>reentrantLock.lock();<br>        <br><span class="hljs-comment">// do something ....</span><br>        <br>         <span class="hljs-comment">// 解锁</span><br>        reentrantLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>lock()：尝试获取锁，获取锁成功后返回</li><li>lockInterruptibly()：可中断的获取锁。所谓可中断的意思就是，在锁的获取过程中可以中断当前线程</li><li>tryLock()：尝试非阻塞的获取锁。不同于 lock() 方法在锁获取成功后再返回，该方法被调用后就会立即返回。如果最终获取锁成功返回 true，否则返回 false</li><li>tryLock(long time, TimeUnit unit)：超时的获取锁。如果在指定时间内未获取到锁，则返回 false</li><li>unlock()：释放锁</li><li>newCondition()：当前线程只有获得了锁，才能调用 Condition 接口的 await 方法。Condition 接口本文就先不做详细赘述了</li></ul><p>Lock是一个<strong>接口</strong>，它规定所有的锁要实现这6个方法(调用层)从而实现锁的功能。</p><h2 id="Lock底层：AQS"><a href="#Lock底层：AQS" class="headerlink" title="Lock底层：AQS"></a>Lock底层：AQS</h2><p>Lock 接口的实现基本都是通过聚合了一个队列同步器（AbstractQueuedSynchronizer，AQS）的<strong>子类</strong>来完成线程访问控制的。<br>比如 ReentrantLock：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203140146.png"><br>而AbstractQueuedSynchronizer：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203140222.png"><br>总结：</p><ul><li><code>Lock</code>的实现类（如<code>ReentrantLock</code>）基本都是通过使用它的一个<code>内部队列</code>（sync）来实现线程的控制访问的。</li><li><code>ReentrantLock</code>有一个内部抽象类<code>Sync</code>，该类继承另一个抽象类<code>AbstractQueuedSynchronizer</code>，并完成部分方法重写。</li><li><code>ReentrantLock</code>还有一些非抽象类，继承<code>Sync</code>，并对其部分方法进行重写，实现不同的队列控制，所谓的内部队列，就是某个非抽象类的实例。</li><li><code>AbstractQueuedSynchronizer</code>被称作同步器，其将一些方法开放给子类写，实现了不同需求的锁控制。</li></ul><h3 id="AQS方法"><a href="#AQS方法" class="headerlink" title="AQS方法"></a>AQS方法</h3><blockquote><p>理解 模板方法设计模式 是理解 AQS 的关键，所谓模板方法可以简单理解为不可被子类重写的方法，模板方法相当于一个骨架，也就是说整体骨架不能被改变，里面具体实现细节可以开放给子类进行重写。</p></blockquote><ul><li>AQS 中的模板方法 <code>acquire()</code>，可以看到被 <code>final</code> 关键字标识了，不可被继承重写。</li><li>但是这个模板方法中调用的 <code>tryAcquire</code> 就是开放给子类进行重写的。</li></ul><blockquote><p>谈谈对AQS的理解：<br>AQS 是一个抽象类，是用来构建锁或者其他同步组件的<strong>基础框架</strong>，它使用了一个 <strong>volaitle 修饰的 int 成员变量 state 表示同步状态</strong>，通过内置的 FIFO 双向队列（源码注释上写的 CLH（Craig，Landin，and Hagersten） 队列（三个人名的简称），其实就是一个先进先出的双向队列）来完成线程们获取资源的时候的排队工作。<br>具体来说，如果某个线程请求锁（共享资源）失败，则该线程就会被加入到 CLH 队列的末端。当持有锁的线程释放锁之后，会唤醒其后继节点，这个后继节点就可以开始尝试获取锁。</p></blockquote><h3 id="成员变量state"><a href="#成员变量state" class="headerlink" title="成员变量state"></a>成员变量state</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>    state = newState;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加锁时，通过CAS，state+1</li><li>释放时，通过CAS，state-1</li></ul><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><h4 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h4><p><code>addWaiter</code>，通过CAS创建一个node并添加到队列尾部。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203143108.png"><br>这里注意有一个添加Waiter时还需要指定一个Node对象<code>mode</code>，这是Node类的静态字段，主要其标记作用，用来指定是共享锁还是排他锁（可以看后面的Node节点中源码和AQS两套模式）。</p><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142026.png"><br>首节点的线程 A 在释放同步资源时，将会唤醒器其后继节点 B，而后继节点 B 被唤醒后，就会重新尝试加锁，同样还是 CAS 操作给 state 变量加 1，如果成功，就<strong>将自己设置为首节点</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142115.png"></p><p>设置首节点是不需要CAS的，因为当线程能否设置首节点时，说明已经获取到了同步资源，只有一个线程能做到（只有一个线程可以将state状态从0 CAS到 1）。</p><h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><p>addWaiter方法中调用了enq方法，这个方法通过死循环的方式使用CAS将节点设置成尾节点，即enq方法将<strong>并发添加节点的请求变成“串行化”了</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142655.png"></p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <br><span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><br>    <span class="hljs-keyword">volatile</span> Node prev; <span class="hljs-comment">// 前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node next; <span class="hljs-comment">// 后继节点</span><br><br>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 当前线程的引用</span><br><br>    Node nextWaiter; <span class="hljs-comment">//标记节点是共享锁还是排他锁</span><br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 最后一个节点</span><br></code></pre></td></tr></table></figure><p>每个Node拥有其<strong>线程的引用</strong>和一个<strong>状态</strong>，主要关注下面两个状态：</p><ul><li><code>CANCELLED</code>：表示取消状态，就是说我不要这个锁了，请你把我从队列中移出去。</li><li><code>SINGAL</code>：表示<strong>当前节点的后继节点</strong>正在等待，注意是后继节点，不是当前节点。</li></ul><h3 id="AQS两套模式"><a href="#AQS两套模式" class="headerlink" title="AQS两套模式"></a>AQS两套模式</h3><p>AQS的模板方法有：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203143651.png"><br>主要分三类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>独占Exclusive（排它锁模式）和共享 Share（共享锁模式）就是 AQS 提供的两种模式。事实上，在 AQS 的所有子类中，只会使用这两种模式的其中之一，要么实现并使用了独占锁的 API，要么使用了共享锁的 API，<strong>不会一个子类同时使用两套不同的模式。</strong><br>独占锁与共享锁在创建自己的节点时（<code>addWaiter</code> 方法）会通过 <code>nextWaiter</code> 变量来表明身份。</p><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="锁获取"><a href="#锁获取" class="headerlink" title="锁获取"></a>锁获取</h5><p>独占锁就是在同一时刻只能有一个线程获取到锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 此方法会尝试去获取锁</span><br>        <span class="hljs-comment">// 将当前线程加入 CLH 队列中，这里可见添加了独占节点</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>tryAcquire是开放给子类重写的，所以子类可以自定义这个方法是否实现公平竞争。即共享&#x2F;排他是AQS内部实现的，公平&#x2F;非公平是子类实现的。</p>          </div><p>acquireQueued方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 当前节点的前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果当前节点的前驱节点是头节点并且成功获取锁，则当前线程获取到独占锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 获取独占锁失败，则当前线程进入等待态</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意三点：<br>1)<code>if (p == head &amp;&amp; tryAcquire(arg))</code><br>如果当前节点的前驱节点是<strong>头节点</strong>并且成功获取锁，则当前线程获取到独占锁。<br>此时当前节点被称为<strong>首节点</strong>（与头节点做区分）。</p><p>2）<code>for(;;)</code><br>会通过死循环（<strong>自旋</strong>）获取锁，如果失败了就阻塞该线程，直到被唤醒。</p><p>3）<code>setHead(node)</code><br>将当前节点作为头节点</p><div class="note note-danger">            <p>重点解释一下，如果某个线程节点是<strong>头节点</strong>，意味着该线程可能<br>1.持有锁<br>2.之前持有锁，但已经释放了（该节点此时是空节点）</p><p>释放节点的时候，并不会像链表一样由头节点线程操作链表将自己弹出，而是释放锁（state &#x3D; 0），然后唤醒后继节点，后继节点发现自己已经是头节点的后继节点，且成功的获取同步（state &#x3D; 1），则将之前的头节点弹出，自己做新的头节点。</p>          </div><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203144926.png"></p><div class="note note-primary">            <ol><li>先看能否直接获取同步状态，有则直接获取return</li><li>若不能，则说明其他线程持有锁</li><li>在通过CAS添加节点的时候，再对前驱节点做一次判断，因为此时锁可能已经被释放，若前驱节点为头节点，则尝试获取同步状态，成功则return</li><li>若前驱节点不是头节点，或前驱节点是头节点，但同步状态获取失败，则线程进入等待状态park(waitStatus变成)。</li></ol>          </div><h5 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unparkSuccessor</code>用于CAS操作唤醒头节点的后继节点：</p><ul><li>改变头节点的waitStatus</li><li>校验后续节点的waitStatus查看是否已经放弃</li><li>若通过了则唤醒后继节点</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>在获取同步状态（锁）时，AQS 维护一个 CLH 双向队列，获取锁失败的线程都会通过 CAS 操作被加入到队列尾端，并且在队列中<strong>无限自旋等待获取锁</strong>；</li><li>停止自旋（或者说被移除 CLH 队列）的条件是其<strong>前驱节点为头节点并且成功获取了独占锁</strong>；</li><li>当前节点（线程）成功释放掉独占锁后，AQS 就会紧接着<strong>唤醒该节点的后继节点</strong>，这样，这个后继节点又会开始去尝试获取锁。循此往复。</li></ul><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="锁获取-1"><a href="#锁获取-1" class="headerlink" title="锁获取"></a>锁获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取失败则执行<code>doAcquireShared</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样会无限自旋直到获取锁：</p><ul><li>头节点的后继节点</li><li>成功获取锁，即拿到需要的资源量arg</li></ul><p><code>setHeadAndPropagate</code>：自己拿到资源后，如果条件满足还会唤醒后继节点，因为这里是共享模式。</p><h5 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doReleaseShared</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>独占锁的释放直接就调用了 unparkSuccessor 方法唤醒后继节点，而共享锁这里，在 unparkSuccessor 之前还加了一个循环和 CAS 的操作来确保共享锁成功释放，因为可能同时存在多个线程释放锁（共享）。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>共享锁与排他锁方法的区别：<br>这里的共享模式不同于读写锁，而是一种资源限制策略，一次只允许若干线程获取锁资源，前面的线程在释放锁之后，后面的线程就可以使用该线程释放的资源。</p><blockquote><ul><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul></blockquote><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>重入锁</strong>，是Lock接口的实现，聚合了AQS。</p><h3 id="重入锁原理"><a href="#重入锁原理" class="headerlink" title="重入锁原理"></a>重入锁原理</h3><h4 id="锁获取-2"><a href="#锁获取-2" class="headerlink" title="锁获取"></a>锁获取</h4><p>对于公平锁和非公平锁来说，它们获取锁的方式是不同的。</p><blockquote><p>ReentrantLock 的 tryLock 方法调用的也就是非公平锁的方法，也就是说，即使该锁是公平锁，使用 tryLock() 方法的话也会使用非公平的方式去获取锁。</p></blockquote><p>这里以获取非公平锁为例：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203163610.png"><br>该方法只定义如何获取锁，失败后策略在AQS中已经实现：</p><ul><li>若锁不被占有则获取return true</li><li>若被占有则检查持有者是否为本线程，是则获取+1，return true</li><li>否则return false</li></ul><h4 id="锁释放-2"><a href="#锁释放-2" class="headerlink" title="锁释放"></a>锁释放</h4><p>通过CAS令state–，如果state &#x3D; 0，则释放锁。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>红线表示内部类，蓝线表示继承，绿色虚线表示实现接口：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164710.png"><br>ReentrantLock 的无参构造使用的就是非公平锁：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164756.png"><br>当然也可以传入一个 boolean 值，true 时为公平锁，false 时为非公平锁：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164805.png"><br>重写方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164823.png"><br>都只重写了加锁方法，公平锁和非公平锁的释放方法相同。</p><p>调用链：<br>ReentrantLock.lock -&gt; Sync.lock -&gt; NonfairSync&#x2F;FairSync.lock -&gt; AQS.acquire -&gt; NonfairSync&#x2F;FairSync.tryAcquire()</p><ul><li>lock是根据具体实现决定执行方式</li><li>tryLock永远通过非公平方式，所以其实现放在了Sync中</li></ul><h4 id="底层区别"><a href="#底层区别" class="headerlink" title="底层区别"></a>底层区别</h4><p>公平锁的 <code>tryAcquire</code> 方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203165544.png"><br>公平锁多了hasQueuedPredecessors，快速判断当前节点是否有前驱节点。</p><ul><li>公平锁：先判断队列，再尝试CAS操作state</li><li>非公平锁：先CAS，失败再看队列，对于非公平锁，可能存在一个线程刚被唤醒与另一个外部线程同时尝试CAS。</li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>非公平锁的效率最高，所以<code>tryLock</code>的默认实现是非公平的。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>读写锁中的读锁和写锁也都是<strong>可重入</strong>的。通过分离读锁和写锁，使得读写锁的并发性能相比一般的排他锁有了很大提升。</p><h3 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170043.png"><br>这个接口只有两个方法，<code>readLock</code> 用来获取读锁，<code>writeLock</code> 用来获取写锁。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>ReentrantReadWriteLock</li><li>StampedLock，是对前者的增强</li></ul><h3 id="ReentrantReadWriteLock-1"><a href="#ReentrantReadWriteLock-1" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170223.png"><br>读写锁拥有读锁和写锁两个实体。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <br>    <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();  <br>    <span class="hljs-comment">// 读写锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();    <br>    <span class="hljs-comment">// 读锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> rwl.readLock();    <br>    <span class="hljs-comment">// 写锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> rwl.writeLock();    <br>    <span class="hljs-comment">// 获取一个 key 对应的 value    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123; <br>        <span class="hljs-comment">// 加读锁</span><br>        readLock.lock();            <br>        <span class="hljs-keyword">try</span> &#123;                    <br>            <span class="hljs-keyword">return</span> map.get(key);            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放读锁</span><br>            readLock.unlock();            <br>        &#125;    <br>    &#125;    <br>    <span class="hljs-comment">// 设置 key 对应的 value，并返回旧的 value    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;    <br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();            <br>        <span class="hljs-keyword">try</span> &#123;                    <br>            <span class="hljs-keyword">return</span> map.put(key, value);            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放写锁</span><br>            writeLock.unlock();            <br>        &#125;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果不使用读写锁，就需要使用java的等待通知机制（wait,notify）。使用读写锁比等待通知方式简单的多。</p></blockquote><h4 id="ReentrantWriteLock"><a href="#ReentrantWriteLock" class="headerlink" title="ReentrantWriteLock"></a>ReentrantWriteLock</h4><p>使用一个state同时维护读、写状态，将 32 位的整型变量 state 切分成两个部分，高 16 位表示读，低 16 位表示写：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170539.png"><br>通过位运算即可获取、修改状态。</p><h5 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h5><ul><li>如果当前有锁（state !&#x3D; 0）<ul><li>如果读锁（高16位）已经被获取过，则无法获取写锁。</li><li>如果没有读锁（高16位），且写锁持有者是自己，则可以重入。</li></ul></li><li>如果没锁<ul><li>尝试CAS获取</li></ul></li></ul><h5 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h5><ul><li>如果当前线程持有写锁，可重入</li><li>如果当前线程没有写锁<ul><li>如果其他线程有写锁，失败</li><li>如果其他线程没有写锁，查看本线程是否有读锁<ul><li>有则state++</li><li>没有则CAS获取</li></ul></li></ul></li></ul><p><strong>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在 <code>ThreadLocal</code> 中，由每个线程自己来维护</strong>，这使获取读锁的实现变得复杂。</p><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>读写锁中的锁降级指的是，<strong>写锁降级成为读锁</strong>。<br>把持住当前线程所拥有的写锁，然后获取到读锁，随后释放先前拥有的写锁。</p><p>主要应用在于：<br>某线程的加锁写操作对其后续的读操作必然是<strong>可见</strong>的，中间不会被其他线程修改。</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Lock中，通过Condition中实现等待通知功能。<br>lock有一个方法是<code>newCondition()</code>，其可以生成一个Condition对象并返回。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>Condition</code>接口的实现类为<code>ConditionObject</code>，其存在于AQS内部。</p><p>Condition也是通过队列的方式实现阻塞和唤醒的，与AQS中的CLH不同在于，Condition队列叫做<strong>等待队列</strong>，CLH队列叫做<strong>同步队列</strong>。</p><p>Condition等待队列是一个FIFO的<strong>单向队列</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203172742.png"></p><p><strong>一个 Lock 对象可以拥有一个同步队列和多个等待队列</strong>：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203172822.png"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>当前线程调用<code>Condition.await()</code> 方法，<strong>将会以当前线程构造节点，并将节点从尾部加入等待队列。</strong></p><p>不同于 CLH 同步队列在尾部添加节点时需要使用 CAS 操作，<strong>Condition 等待队列不需要 CAS 的保证</strong>，因为调用 <code>await</code> 方法的线程必定是获取了 Lock的线程，不会有其他线程来争夺这个添加尾部节点的操作。<br>从逻辑上看，这与设置头节点不需要CAS相同。<br>从语义上看，这与<code>wait()</code>方法只在<code>synchronized</code>块中调用相同。</p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p><strong>将 Condition 等待队列的首节点移动到 CLH 同步队列的尾部</strong><br>同样，<code>signal</code> 这个方法，一定是当前占据锁的线程调用的。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203173352.png"></p><h4 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h4><p>将等待队列中所有节点全部移动到同步队列中。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第2章（三大关键字）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1）根据线程要不要锁住共享资源，可以分为：</p><ul><li>悲观锁：锁住共享资源</li><li>乐观锁：不锁住共享资源</li></ul><p>2）如果试图锁住共享资源失败，那么线程要不要阻塞？如果不想要阻塞线程，可以通过以下两种锁实现：</p><ul><li>自旋锁</li><li>适应性自旋锁</li></ul><p>3）根据多个线程竞争锁时是否需要排队，可以分为：</p><ul><li>公平锁：需要排队</li><li>非公平锁：先尝试插队，插队失败再排队</li></ul><p>4）根据一个线程是否能够重复获取同一把锁，可以分为：</p><ul><li>可重入锁：能被同一个线程重复获取</li><li>不可重入锁：不能被同一个线程重复获取</li></ul><p>5）根据锁只能被单个线程持有还是能被多个线程共同持有，可以分为：</p><ul><li>排他锁：锁只能被单个线程持有</li><li>共享锁：锁能被多个线程共同持有</li></ul><p>6）以下这 4 种锁都是专门针对 synchronized 关键字的，是上面介绍的锁的组合实现：</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h2 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁 | 乐观锁"></a>悲观锁 | 乐观锁</h2><blockquote><p><strong>悲观锁是一种悲观思想</strong>，认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>乐观锁是一种乐观思想</strong>，认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在提交修改的时候去判断一下，在此之前有没有其他的线程也修改了这个数据：</p><ul><li>如果其他的线程还没有提交修改，那么当前线程就将自己修改的数据成功写入；</li><li>如果其他的线程已经提交了修改，则当前线程会根据不同的实现方式执行不同的操作（例如报错或者自动重试）</li></ul></blockquote><p>乐观锁的算法是CAS算法实现的，这种算法一般也被称为无锁编程（Lock-Free），这是一种算法思想。</p><p><strong>两者判断是否能拥有锁的时点不一样（先判断；先操作然后在提交时判断），判断的方式不一样（直接判断是否能获取；CAS算法）。</strong></p><div class="note note-primary">            <p>实用区别：</p><ul><li>悲观锁一般性能差，但修改量太大的话性能会好。</li><li>乐观锁一般性能好，但一直失败的话不如悲观，防止空转。<br>实现：</li><li><code>synchronized</code>和<code>Lock接口</code>的实现类都是悲观锁</li><li><code>JUC</code>的原子类是乐观锁。</li></ul>          </div><h2 id="自旋锁-自旋适应锁"><a href="#自旋锁-自旋适应锁" class="headerlink" title="自旋锁 | 自旋适应锁"></a>自旋锁 | 自旋适应锁</h2><blockquote><p><strong>自旋锁</strong>就是“稍等一下”，其实就是个 do-while 循环。更底层来说自旋操作就是<strong>空转 CPU</strong>，执行一些无意义的指令，目的就是不让出 CPU 等待锁的释放。如果这个线程自旋完成后，前面锁定共享资源的线程已经释放了锁，那么这个线程就可以不必被阻塞而是直接获取共享资源，从而<strong>避免切换操作系统状态的开销</strong>。</p><p><strong>自旋适应锁</strong>：如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源，空转，死等，还不如被阻塞住。自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。默认是 10 次，可以使用参数<code>-XX:PreBlockSpin</code>来更改。而在 JDK 1.6 中，对于自选等待的次数这个问题，做出了一次优化，即引入了<strong>适应性自旋锁</strong>（自适应的自旋锁）。</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么 JVM 就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；</li><li>如果对于某个锁，很少有线程通过自旋等待成功获得过，那么当以后有线程尝试获取这个锁时， JVM 可能省略掉自旋过程，直接阻塞住线程，避免空转浪费处理器资源。</li></ul></blockquote><p><strong>两者是判断当获取锁失败时策略，是直接阻塞还是稍作等待（实现是CAS算法）,并规定稍作等待的时长。</strong></p><div class="note note-primary">            <p>实用性：</p><ul><li>避免阻塞，阻塞后唤醒需要切换到内核态，对系统性能消耗大。<br>实现：</li><li>JUC的原子类是自旋锁，这也是一种乐观锁，可以说自旋锁的原理就是CAS算法。<br>乐观锁与自旋锁，CAS算法的关系：</li><li>CAS是一种实现自旋的算法</li><li>乐观锁和自旋锁都是期待可以获取同步资源并执行，因此在实现上总是同时出现，一个定义如何获取，一个定义失败行为。</li></ul>          </div><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 | 非公平锁"></a>公平锁 | 非公平锁</h2><blockquote><p><strong>公平锁</strong>：多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果该锁的等待队列为空，则直接占有锁；如果该锁的等待队列不为空，则该线程加入到等待队列的末尾，按照 FIFO 的原则从队列中取出线程，然后占有锁。</p><p><strong>非公平锁</strong>：线程会先尝试获取锁，如果获取不到，则再采用公平锁的方式也就是进入等待队列。也就是说，多个线程获取锁的顺序，不是按照 FIFO 的顺序，有可能后申请锁的线程比先申请的线程优先获取到锁。</p></blockquote><p>从源码上看，唯一区别就是公平锁在获取锁前多一个判断条件：<code>hasQueuedPredecessors</code>判断当前线程是否是等待队列中的第一个。</p><p><strong>两者决定多线程争夺时锁的归属策略</strong></p><div class="note note-primary">            <p>实用性：</p><ul><li>根据不同场景需要使用不同策略。</li><li>公平锁效率低，频繁阻塞造成进入内核态的开销。</li><li>非公平锁效率高，但可能饿死线程。</li></ul><p>实现：</p><ul><li>synchronized是非公平的</li><li>Lock接口的实现类ReentrantLock可以指定是否公平（默认非公平）。</li></ul>          </div><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 | 不可重入锁"></a>可重入锁 | 不可重入锁</h2><blockquote><p><strong>可重入锁</strong>：也称为递归锁，同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。</p><p><strong>不可重入锁</strong>：同一个线程不能获得同一个对象的锁两次。</p></blockquote><p>原理：如ReentrantLock，通过判断state字段，若为0则直接占用锁，不为0则判断主人是不是自己，若是，则锁上加一个记号。</p><p><strong>决定其在被一个线程重复获取时是否成功</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>防止同一个线程获取同一个锁失败<br>实现：</li><li>synchronized，ReentrantLock都是可重入锁。</li></ul>          </div><h2 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁 | 排他锁"></a>共享锁 | 排他锁</h2><blockquote><p><strong>共享锁</strong>：该锁可被多个线程所持有。如果线程 A 对数据 B 加上共享锁后，则其他线程只能对 B 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p><strong>排他锁</strong>：也称互斥锁、独享锁，该锁一次只能被一个线程所持有。如果线程 A 对数据 B 加上排它锁后，则其他线程不能再对 B 加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</p></blockquote><p>排他锁是一种悲观锁，共享锁是一种乐观锁。</p><p><strong>决定锁是否私有</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>根据场景，保证性能、准确性。<br>实现：</li><li>排他锁：synchronized 和 ReentrantLock、ReentrantReadWriteLock中的写锁。</li><li>共享锁：ReentrantReadWriteLock中的读锁。</li></ul>          </div><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 | 偏向锁 | 轻量级锁 | 重量级锁"></a>无锁 | 偏向锁 | 轻量级锁 | 重量级锁</h2><blockquote><p><strong>无锁（Lock-Free）</strong>,具体指的是没有使用悲观锁，如使用CAS算法的JUC原子类。</p><p><strong>偏向锁</strong>，锁会偏向于第一个获得它的<strong>线程</strong>，接下来如果没有其他线程竞争该锁，则该线程不需要进行CAS操作。偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制。</p><p><strong>轻量级锁</strong>，偏向锁时出现两个线程交替竞争则变成轻量级锁。（不会自旋）</p><p><strong>重量级锁</strong>，升级成重量级锁之后，线程如果没有争抢到锁，会进行一段自旋等待锁的释放。那么上文说过，自旋等待是需要有一定限度的，如果自旋等待超过了一定的次数（时间），那么这个线程就要被阻塞住了。因为涉及到操作系统所以重量。</p></blockquote><p>抛开无锁这个状态不谈，Java 中的<code>synchronized</code>有偏向锁、轻量级锁、重量级锁，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁就会按照顺序进行升级。</p><p>一般认为，<strong>锁只能升级不能降级</strong>，但实际上是有降级的，不过条件苛刻，可以忽略。</p><p><strong>定义了synchronized的状态，决定其在被一个或多个线程争夺时的线程的获取锁策略</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>无锁，写操作比较少时使用，使用CAS算法实现，效率高。</li><li>偏向锁，只有一个线程获取该锁时的策略，不会频繁的释放锁。</li><li>轻量级锁，两个线程交替拥有锁，但无实际竞争避免阻塞（<strong>信号量</strong>），像一个过渡状态，一旦竞争就变成重量级。</li><li>重量级锁，短暂自旋后会阻塞，安全性能好。<br>实现：</li><li><code>synchronized</code></li></ul>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>悲|乐观锁决定线程获取锁的行为时点和方式（先获取|先操作再校验）</li><li>自旋锁决定获取锁失败后的行为（阻塞|等待）</li><li>公平锁|非公平锁决定多线程竞争时的优先级（顺序|插队）</li><li>可重入锁|不可重入锁决定单线程能否重复获取锁</li><li>共享锁|排他锁决定锁能否被多个线程共有（读锁|写锁）</li></ol><p>无锁|偏向锁|轻量级锁|重量级锁是锁的状态，其是针对synchronized具体实现的分类，其他锁指的是思想。</p><div class="note note-primary">            <ul><li>synchronized 关键词是悲观锁、排他锁、可重入锁、(某些状态下可自旋)、非公平锁。</li><li>Lock接口的实现是悲观锁、可重入锁<ul><li>ReentrantLock是排他锁、有公平和非公平两种实现。</li><li>ReentrantReadWriteLock读锁是共享的，写锁是排他的。</li></ul></li><li>JUC原子类是乐观锁，自旋锁（可以认为，自旋操作的实现就是CAS，但乐观锁的实现不只CAS）。</li></ul>          </div><h1 id="二、synchronized关键字"><a href="#二、synchronized关键字" class="headerlink" title="二、synchronized关键字"></a>二、synchronized关键字</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1）对于普通同步方法（synchronized 修饰的普通方法），锁是<strong>当前实例对象</strong>。<br>2）对于静态同步方法（synchronized 修饰的静态方法），锁是<strong>当前类的 Class 对象</strong>。<br>3）对于同步方法块（synchronized 修饰的块），锁是<strong>Synchonized括号里配置的对象</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>monitorenter 和 monitorexit 来隐式地使用这两个操作。</p><h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>所有 Lock 实现都必须强制执行与内置监视器锁 synchronization 提供的相同的内存同步语义。<br>1）锁释放的内存语义：<strong>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong><br>2）锁获取的内存语义：<strong>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被锁保护的临界区代码必须从主内存中读取共享变量。</strong></p><blockquote><p>线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了消息，比如说告知对方我对某个共享变量做了修改；<br>线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的消息，比如说接收了线程 A 在释放这个锁之前对共享变量所做的修改；</p></blockquote><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><ol><li>普通同步方法：加上<code>ACC_SYNCHRONIZED</code>标识</li><li>静态同步方法：加上<code>ACC_SYNCHRONIZED</code>标识</li><li>同步方法块：方法的code属性中，多了<code>monitorenter</code>和<code>monitorexit</code>字节码。</li></ol><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="Monitor介绍"><a href="#Monitor介绍" class="headerlink" title="Monitor介绍"></a>Monitor介绍</h4><p>任何一个对象都与一个监视器（monitor）对象相关联。当一个监视器有拥有者（owner）的时候，这个监视器就会被锁定（locked）。</p><p>每个监视器都维护着一个自己被持有次数（或者说被锁住 locked）的计数器（count），具体如下：</p><ul><li>如果与对象关联的监视器的计数器为零，则线程进入监视器成为该监视器的拥有者，并将计数器设置为 1。</li><li>当同一个线程再次进入该对象的监视器的时候，计数器会再次自增</li><li>当其他线程想获得该对象关联的监视器的时候，就会被阻塞住，直到该监视器的计数器为 0 才会再次尝试获得其所有权。</li><li>因为计数器和owner的存在，被 <code>synchronized</code> 修饰的同步方法块对同一条线程来说是<strong>可重入</strong>的。所谓可重入就是说即使同一个线程反复进入一个同步方法块也不会出现自己把自己锁死的情况。</li></ul><div class="note note-primary">            <p>可见synchronized也是通过<strong>计数器信号量</strong>快速判断能否获取和重入次数的。</p>          </div><h4 id="ACC-SYNCHRONIZED"><a href="#ACC-SYNCHRONIZED" class="headerlink" title="ACC_SYNCHRONIZED"></a>ACC_SYNCHRONIZED</h4><p>方法级别的同步是隐式执行的，调用方法时，线程会进入对应对象的监视器，然后执行方法。<strong>在执行线程拥有监视器期间，没有其他线程可以进入这个方法</strong>。<br>另外，如果在调用同步方法过程中抛出异常并且同步方法没有处理该异常，则在异常重新抛出同步方法之前，该方法的监视器会自动退出。</p><h4 id="monitorenter、monitorexit"><a href="#monitorenter、monitorexit" class="headerlink" title="monitorenter、monitorexit"></a>monitorenter、monitorexit</h4><p>同步代码块是显示执行的。</p><h4 id="Monitor详解"><a href="#Monitor详解" class="headerlink" title="Monitor详解"></a>Monitor详解</h4><p>常见的进程同步与互斥机制是<strong>信号量</strong>和<strong>管程</strong>。</p><p>相比起信号量，管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。也就是说管程天生支持进程互斥。（排他锁）</p><p>Java中<strong>管程</strong>（monitor）的具体实现是<code>ObjectMonitor</code> 类。这是一个C++实现的类。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202192413.png"><br>补充：</p><ul><li>monitor还持有计数器count</li><li>WAITING列表中保存着：<strong>获得过锁但使用wait()方法等方式放弃锁的线程</strong>，它们等待被唤醒后进入RUNNABLE状态，此时无法获取锁则BLOCKED。</li></ul><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。<br>针对普通对象和数组对象：</p><ul><li>如果对象是数组类型，则虚拟机用3个字宽（Word，在32位系统中，一个word占4字节，32bit）存储对象头（Mard Word、类型指针、数组长度）</li><li>如果对象是非数组类型，则用2字宽存储对象头（Mard Word、类型指针）。</li></ul><p>在32位虚拟机中，1字宽等于4字节，即32bit，如表所示：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64 bit</td><td>Mark Word</td><td>存储对象的 hashCode 和锁信息等</td></tr><tr><td>32&#x2F;64 bit</td><td>Class Metadata（类型指针）</td><td>对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例</td></tr><tr><td>32&#x2F;64 bit</td><td>Array Length（数组长度）</td><td>数组的长度</td></tr></tbody></table><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202231421.png"><br>其中MarkWord部分是对象与monitor关联的重点，其有多种状态：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232949.png"><br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232952.png"></p><p>在64位下，MarkWord是64bit大小的，hashCode变成了31bit，原先的25bit则空了出来，且新增了1bit字段cms_free（CMS回收器GC时使用）<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232955.png"></p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>JDK1.6前，<strong>synchronized在1.6之前是一个重量级锁</strong>。</li><li>JDK1.6后，出现了各种锁优化技术，如自旋转，轻量级锁，锁消除和锁粗化等。</li></ul><h3 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h3><p><strong>自旋锁可以使线程免于阻塞但并不能代替阻塞</strong>，等待的时间必须有一定的限度，默认自旋等待次数是 10 次，用户也可以使用参数 <code>-XX：PreBlockSpin</code> 来自行更改，而在 JDK 1.6 中，对于自旋等待的次数这个问题，做出了一次优化，即引入了<strong>适应性自旋</strong>（也称为自旋适应锁）：</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么 JVM 就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；</li><li>如果对于某个锁，很少有线程通过自旋等待成功获得过，那么当以后有线程尝试获取这个锁时， JVM 可能省略掉自旋过程，直接阻塞住线程，避免空转浪费处理器资源。</li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能再降级回偏向锁（其实可以，要求很严格）</strong>。<br>Mark Word内容：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202233831.png"><br>初始状态和偏向锁下锁的标志位是<code>01</code>，轻量锁为<code>00</code>，重量锁为<code>10</code>，GC标记为<code>11</code>。<strong>01 -&gt; 00 -&gt; 10 -&gt; 11</strong></p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>1）<strong>检查Mark Word初始状态</strong>：需要保证对象无锁，即锁标志位为<code>01</code>，偏向锁标志位为<code>0</code>。<br>2）<strong>在当前线程的栈帧上建立锁记录</strong>：java虚拟机会将当前线程的<strong>栈帧</strong>中建立一个名为<strong>锁记录</strong>（Lock Record）的空间，Lock Record 中有一个字段 displaced_header，用于后续存储锁对象的 Mark Word 的拷贝。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202234727.png"><br>3）<strong>复制锁对象的 Mark Word 到锁记录中</strong>：把锁对象的 Mark Word 复制到锁记录中，更具体来讲，是将 Mark Word 放到锁记录的 <code>displaced_header</code>属性中。官方给这个复制过来的记录起名 <code>Displaced Mark Word</code>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202234855.png"><br>4）使用 <strong>CAS 操作更新锁对象的 Mark Word</strong>。Java 虚拟机使用 CAS 操作尝试把锁对象的 Mark Word 更新为指向锁记录的指针，并将锁记录里的 owner 指针指向对象的 Mark Word。</p><ul><li>如果这个更新操作成功了，就表明获取轻量级锁成功，也就是说该线程拥有了这个对象的锁！并且该对象 Mark Word 的锁标志位会被改为 00，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，那有两种可能性：<ul><li>当前线程已经拥有了这个对象锁（直接进入同步块继续执行）</li><li>存在其他的线程竞争获取这个对象锁（膨胀成重量级锁，锁标志的状态值变为 10，Mark Word 中存储的就是指向重量级锁（互斥量）的指针）</li></ul></li></ul><h5 id="当前线程已经拥有该锁"><a href="#当前线程已经拥有该锁" class="headerlink" title="当前线程已经拥有该锁"></a>当前线程已经拥有该锁</h5><p>虚拟机首先会检查该对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行（synchronized 是可重入锁）。</p><p>假设锁的状态是轻量级锁，下图反应了对象的 Mark word 和线程栈中锁记录的状态，可以看到左边线程栈中包含3个指向当前锁对象的 Lock Record。其中栈中最高位的锁记录为第一次获取轻量级锁时分配的，其 Displaced Mark word 的值为锁对象 obj 加锁之前的 Mark word，之后的每次锁重入都会在线程栈中分配一个 Displaced Mark word 为 <code>null</code>的锁记录。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202235425.png"></p><blockquote><p>为什么 synchronized 重入的时候 Java 虚拟机要在线程栈中添加 Displaced Mark word 为 null 的锁记录呢？</p><ul><li>首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，只有解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁的重入次数。</li><li>最简单的记录锁重入次数的方案就是将其记录在对象头的 Mark word 中，但 Mark word 大小有限，没有多出来的地方存放该信息了。</li><li>另一个方案就是在锁纪录中记录重入次数，但这样做的话，每次重入获得锁的时候都需要遍历该线程的栈找到对应的锁纪录，然后去修改重入次数的值，显然这样效率不是很高。</li></ul><p>所以最终 Hotspot 选择了每次重入获得锁都添加一个锁记录来表示锁的重入，这样有几个 Displaced Mark word 为 null 的锁记录就表示发生了几次锁重入，非常简单。</p></blockquote><h5 id="存在其他线程竞争该锁"><a href="#存在其他线程竞争该锁" class="headerlink" title="存在其他线程竞争该锁"></a>存在其他线程竞争该锁</h5><p><strong>轻量级锁 CAS 失败并不会自旋而是直接膨胀成重量级锁</strong>。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁的时候 Java 虚拟机会用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来：</p><ul><li>如果替换成功，那整个同步过程就顺利完成了</li><li>如果替换失败，则说明有其他线程尝试过获取该锁，轻量级锁会先膨胀成重量级锁然后再解锁（调用重量级锁的 exit 方法）</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>synchronized 关键字会尝试加锁：将<strong>锁对象的对象头</strong>中的<strong>mark word</strong>(包括hashCode,age,lock信息)复制到<strong>当前线程的栈帧</strong>当中，叫做<strong>displaced mark word</strong>。然后尝试通过<strong>CAS</strong>算法替换<strong>对象头的markword</strong>为指向栈帧中<strong>displaced mark word</strong>的指针，并将栈帧中的<strong>owner</strong>指向对象。</p><ul><li>若当前对象的mark word没有被替换过，替换成功，获得锁。</li><li>若当前对象的mark word被替换过，考虑：<ul><li>之前是被本线程替换的，经过检查后，会再到本线程的栈帧中插入新的lock record(displaced header和owner的集合)，其中header为空，owner与之前的一样</li><li>若是其他线程的竞争，则膨胀成重量级锁。获取该重量级锁时会进行失败自旋。</li></ul></li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢</strong>。但大多数情况下无竞争，为了避免CAS的开销，引入了偏向锁。</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>1）查看对象头的 Mark Word 中偏向锁的标识以及锁标志位，若<strong>偏向锁</strong>标识为1 且 <strong>锁标志位</strong> 为 01，则该锁为<strong>可偏向状态</strong>；<br>2）若为可偏向状态，则测试 Mark Word 中的线程 ID 是否与当前线程相同，若相同，则不用执行 CAS 操作，直接进入同步块执行，否则进入下一步。<br>3）当前线程通过 CAS 操作竞争锁，若竞争成功，则使用 CAS 操作将 Mark Word 中线程 ID 设置为当前线程 ID（重新偏向），然后执行同步块；若竞争失败，则进入偏向锁撤销的流程。</p><p>轻量级锁重入：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000535.png"><br>偏向锁重入：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000550.png"></p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>偏向锁的撤销采用了 <strong>一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争</strong>。</p><p>如果当前线程通过 CAS 竞争偏向锁失败，说明存在锁竞争，则进入偏向锁撤销的流程，偏向锁的撤销需要等待 全局安全点 safe point（这个时间点上没有正在执行的代码），其具体步骤如下：<br>1）JVM 会先暂停拥有偏向锁的线程，判断持有偏向锁的线程是否还存活；<br>2）根据判断结果执行</p><ul><li>如果持有偏向锁的线程存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁竞争的逻辑里。</li><li>如果持有偏向锁的线程已经不存活或者不在同步块中，则将对象头的 Mark Word 改为无锁状态（01），以允许其他线程竞争锁，之后再升级为轻量级锁；<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000458.png"></li></ul><h4 id="批量重偏向和批量撤销"><a href="#批量重偏向和批量撤销" class="headerlink" title="批量重偏向和批量撤销"></a>批量重偏向和批量撤销</h4><p>批量指的是某个类的大量对象，是<strong>针对类的优化</strong>。<br><strong>批量重偏向</strong>（bulk rebias）：当某个类的对象的偏向锁的<strong>撤销次数</strong>超过重偏向阈值（默认 20 次）后，JVM 会这样觉得，我是不是偏向错了呢，于是在给这些对象加锁时会重新偏向至试图加锁的线程。</p><p><strong>批量撤销</strong>（bulk revoke）：当某个类的对象的偏向锁的<strong>撤销次数</strong>超过批量撤销阈值（默认40 次）后，JVM 会这样觉得，自己确实偏向错了，根本就不该偏向，于是整个类的所有对象 都会变为<strong>不可偏向</strong>的，新建的对象也是不可偏向的。通俗来说，JVM 会认为这个类的所有对象的使用场景都存在多线程竞争，会标记该类为不可偏向，之后，对于该类的对象的锁，都会直接走轻量级锁的逻辑。</p><h4 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h4><p>JDK 15废弃了偏向锁，其带来的作用已经不大。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>偏向锁其实就是为了避免一直获取，释放锁带来的消耗（CAS）,采用确认mark word中的线程id来判断是否属于自己，若不属于则升级为轻锁（尝试CAS），再不行就变成重锁（先自旋再堵塞）</p><p>一个对象有<strong>可偏向</strong>和<strong>不可偏向</strong>两种状态（取决于偏向锁标志位是否为1），且初始时是可偏向的。若是对象可偏向尝试加偏向锁，否则直接走轻量级锁逻辑。</p><p><strong>撤销</strong>是等Save Point时，判断持有线程是否仍在同步块中：</p><ul><li>若在，则升级锁为轻量级锁（发生竞争）。</li><li>若不在，则将其变成无锁状态（此时<strong>不可偏向</strong>，此后该线程获取该对象锁时会直接获取轻量级锁）。<br>但是，若大量同类对象偏向锁的被撤销，则给与该类的对象重新偏向其他线程的机会（标记为<strong>可偏向</strong>），但是若再被撤销太多次，则变成<strong>不可偏向</strong>。</li></ul><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>Lock Elimination:锁消除的概念比较容易理解，就是<strong>如果编译器认定一个锁只会被单个线程访问，那么这个锁就可以被消除</strong>。</p><p>锁消除需要进行逃逸分析：</p><ul><li>方法逃逸</li><li><strong>线程逃逸</strong></li></ul><p>针对是否逃逸，JVM的优化有：</p><ul><li><strong>同步省略</strong></li><li>标量替换</li><li>栈上分配</li></ul><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>Lock Coarsening:如果虚拟机检查到有这样一串连续的操作都是对同一个对象进行加锁，就会把加锁同步的范围粗化（扩大）到整个操作序列的外部。<br>简单来说，锁粗化就是把多次加锁请求合并成一次。如<code>sb.append()</code>连续调用。</p><h2 id="wait和synchronized"><a href="#wait和synchronized" class="headerlink" title="wait和synchronized"></a>wait和synchronized</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>wait方法必须在 synchronized 同步块中调用</li><li>wait方法是Object实现的native方法</li></ul><p>某线程A调用对象a的<code>wait</code>方法，会让线程处于WAITING状态，直到另一个线程调用对象a的<code>notify</code>（随机）或<code>notifyAll</code>（所有）方法。可以看出，对象a基本上是信号的传递者的角色。</p><p><strong>调用 <code>wait</code> 方法的线程必须拥有此对象的监视器</strong>，否则报异常。该方法将当前线程（称为 T）置于此对象的 WaitSet 中，然后放弃该对对象的锁。直到被唤醒或中断、超时。</p><p>总结：调用 wait 方法就是对象通知持有自己锁的线程释放该锁并等待；而 notify 和 notifyAll 方法就是对象通知在等待的线程又可以来竞争我的锁了。</p><h3 id="无效唤醒-Lost-Wakeup"><a href="#无效唤醒-Lost-Wakeup" class="headerlink" title="无效唤醒 Lost Wakeup"></a>无效唤醒 Lost Wakeup</h3><p>为什么必须在同步块中调用wait？<br>wait要在notify前发生，即编程时希望先让某线程wait，再由其他线程唤醒它，但是多线程下不能保证wait发生在notify后，所以需要用锁来保证只有wait成功之后，其他线程才能notify这个对象。</p><h3 id="虚假唤醒-Spurious-Wakeup"><a href="#虚假唤醒-Spurious-Wakeup" class="headerlink" title="虚假唤醒 Spurious Wakeup"></a>虚假唤醒 Spurious Wakeup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(某条件)&#123;<br><span class="hljs-comment">//等待</span><br><span class="hljs-built_in">this</span>.wait();<br>&#125;<br><span class="hljs-comment">//执行某事件</span><br><span class="hljs-keyword">do</span>();<br><span class="hljs-comment">//通知其他线程</span><br><span class="hljs-built_in">this</span>.notifyAll();<br></code></pre></td></tr></table></figure><p>在if条件语句不满足条件时，线程进入wait，被唤醒时其if条件仍不满足，因此需要把if改成while。</p><h1 id="三、Volatile"><a href="#三、Volatile" class="headerlink" title="三、Volatile"></a>三、Volatile</h1><p>当一个变量被定义成 volatile 之后，它将具备两项特性：</p><ol><li>保证此变量对所有线程的<strong>可见性</strong>。所谓 “可见性” 就是指当一条线程修改了这个变量的值，其他线程可以立即得知这个修改。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</li><li><strong>禁止指令重排序</strong>。事实上，普通的变量是无法保证变量赋值操作的顺序与程序代码的执行顺序是一致的，在某些情况下，可能会出现意想不到的结果。</li></ol><h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><ol><li><strong>volatile 写的内存语义</strong>：当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li><strong>volatile 读的内存语义</strong>：当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ol><p>事实上，更底层来讲，有 volatile 变量修饰的共享变量进行写操作的时候会多出一条Lock前缀的指令，根据 IA-32 架构软件开发者手册，这条指令会引发两件事情：<br>1）将当前处理器缓存行的数据写回到系统内存<br>2）这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效<br>即<strong>无效其他线程本地内存的操作实际上是在写时就发生了</strong>。</p><h2 id="volatile禁止指令重排"><a href="#volatile禁止指令重排" class="headerlink" title="volatile禁止指令重排"></a>volatile禁止指令重排</h2><p>绿色表示可以重排序，红色则不能：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203010905.png"><br>简而言之：</p><ul><li>volatile写之前的不许被排序在其后(写之后不被修改)</li><li>volatile读之后的不许排序在其前（读之前不被修改）</li><li>volatile写和读不可以重排序</li></ul><p>更底层的，禁止指令重排的底层原理是插入内存屏障：编译器在生成字节码的时候，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序：</p><p>1）在每个 volatile 写操作的前面插入一个 StoreStore 屏障；在每个 volatile 写操作的后面插入一个 StoreLoad 屏障<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011123.png"></p><p>2）在每个 volatile 读操作的后面插入一个 LoadLoad 屏障和一个 LoadStore 屏障（图中volatile读前有一个Load屏障）<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011141.png"></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>内存屏障是一种指令，无论是在JAVA内存模型还是CPU层次，都是有具体的指令对应的，是一种特殊的指令，作用为禁止指令</strong><br>重排序的内存屏障有四种，分别叫做**LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</p><p>例子：LoadLoad屏障<br>序列：load1指令 <strong>LoadLoad屏障</strong> load2指令<br>作用：在load1指令和load2指令之间加上 LoadLoad屏障，<strong>强制先执行load1指令再执行load2指令</strong>；load1指令和load2指令不能进行重排序。</p><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011315.png"></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>volatile读需要保证，其后面的写操作不会重排序到其前面影响读结果（loadstore），同时保证其后的读的结果和本次读的结果一致（loadload）。</li><li>volatile写需要保证，其前面的写操作不会重排序到其后面（storestore），同时要保证可见性（storeload）。</li></ul><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p><strong>双重校验锁（Double Checked Locking，DCL）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span> &#123;<br><span class="hljs-comment">// 私有化构造方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span>&#123;&#125;; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">// 第一次校验</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;     <br>            <span class="hljs-keyword">synchronized</span> (SingleTon.class) &#123;<br>                <span class="hljs-comment">// 第二次校验</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;     <br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>                &#125;<br>        &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么 <code>instance</code> 一定要用 <code>volatile</code> 这个关键字来修饰？</p><h3 id="可见性应用"><a href="#可见性应用" class="headerlink" title="可见性应用"></a>可见性应用</h3><ul><li>第一次校验：直接返回已经创建的实例，且不通过同步方法，速度快。</li><li>第二次校验：防止两线程同时getIntance并通过第一次校验，导致创建两个对象。</li></ul><p>即只同步新建对象的过程，不影响直接返回对象的过程，且创建后对另一个线程<strong>可见</strong>。</p><h3 id="禁止指令重排序的应用"><a href="#禁止指令重排序的应用" class="headerlink" title="禁止指令重排序的应用"></a>禁止指令重排序的应用</h3><p>在 Java 语言层面上，创建对象仅仅是一个 new 关键字而已，而在 JVM 中，对象的创建其实并不是一蹴而就的，忽略掉一些 JVM 底层的细节比如设置对象头啥的，对象的创建可以大致分三个步骤：</p><ol><li>在堆中为对象分配内存空间</li><li>调用构造函数，初始化实例</li><li>将栈中的对象引用指向刚分配的内存空间</li></ol><p>为了防止2-&gt;3步发生重排序，使用volatile保证先创建完对象再给出引用。</p><h1 id="四、Final"><a href="#四、Final" class="headerlink" title="四、Final"></a>四、Final</h1><blockquote><p>引言：在旧的 Java 内存模型（JDK 1.5 以前）中，一个最严重的缺陷就是线程可能看到 final 域的值会改变。比如一个线程看到一个 int 类型 final 值为 0，此时该值是未初始化前的零值，一段时间后该值被某线程初始化，再去读这个 final 值会发现值变为 1。</p><p>为了修补这个漏洞，新的 Java 内存模型并增强了 final 的语义，通过为 final 域增加写和读重排序规则，为 Java 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（lock、volatile）就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p></blockquote><p>简单来说：只要一个不可变对象被正确地构建出来（即没有发生 this 引用逃逸的情况，这是一种例外），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。</p><p>甚至我们可以下结论：<strong>不可变对象永远是线程安全的。</strong></p><h2 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h2><p>构造对象时会初始化final域，此时：</p><ol><li>编译器：JMM 禁止编译器把对 final 域的写指令重排序到构造函数之外。</li><li>处理器：编译器会在对 final 域的写指令之后，构造函数 return 之前，插入一个 StoreStore 屏障（这个屏障的作用就是禁止处理器把对 final 域的写指令重排序到构造函数之外）</li></ol><p>解释：<strong>编译器</strong>不做重排序，并通过storestore防止<strong>处理器</strong>重排序。<br>目的：保证先赋值对象的final属性，后完成初始化给出该对象引用。</p><h2 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h2><ol><li>编译器：编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li><li>处理器：在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。</li></ol><blockquote><p>对于编译器和大部分处理器来说，肯定是不会对初次读对象引用与初次读该对象包含的 final 域这两个操作进行重排序的，因为这两个操作之间存在间接依赖关系。<br>但有少数处理器是允许对存在间接依赖关系的操作做重排序的，所以这个规则就是专门用来针对这种处理器的。</p></blockquote><p>解释：<strong>编译器</strong>通过loadload保证不会把读final域的操作放在读其所属对象前。<strong>处理器</strong>则对其做了约定。<br>目的：保证先获取到对象本身，然后再读final值。</p><h2 id="this引用逃逸"><a href="#this引用逃逸" class="headerlink" title="this引用逃逸"></a>this引用逃逸</h2><p>final保证了final属性在对象构造完成return前赋值，但若return前将this引用给到外部，此时对象尚未初始化完成，这就是一种线程逃逸。</p><p>避免：为了避免这种逃逸现象，最好不要这样编写代码，保证”只要一个不可变对象被正确地构建出来（即没有发生 this 引用逃逸的情况），那其外部的可见状态永远都不会改变”。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第1章（基础知识）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h1><h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>在操作系统中，内存通常会被分成用户空间（User space）与内核空间（Kernel space）这两个部分。当进程&#x2F;线程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态：</p><ul><li>运行在内核态的程序可以访问用户空间和内核空间，或者说它可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等。</li><li>而应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问用户空间。</li></ul><p>区分的目的：<br>用户态的程序不能随意操作内核地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。</p><p>那如果处于用户态的程序想要访问内核空间的话怎么办呢？<strong>就需要进行系统调用从用户态切换到内核态。</strong></p><h2 id="操作系统线程"><a href="#操作系统线程" class="headerlink" title="操作系统线程"></a>操作系统线程</h2><h3 id="用户空间实现线程"><a href="#用户空间实现线程" class="headerlink" title="用户空间实现线程"></a>用户空间实现线程</h3><p><strong>早期</strong>的操作系统<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202153716.png"><br>优点：</p><ul><li>第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；</li><li>第二点，线程的调度只发生在用户态，<strong>避免</strong>了操作系统从内核态到用户态的<strong>转换开销</strong>。<br>缺点：</li><li>CPU 的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于<strong>用户空间中没有时钟中断机制</strong>，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；</li><li>另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。</li></ul><h3 id="内核空间实现线程"><a href="#内核空间实现线程" class="headerlink" title="内核空间实现线程"></a>内核空间实现线程</h3><p><strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS X 和 Solaris 等，都支持内核线程。<strong>支持多线程的内核就叫做多线程内核</strong>（Multi-Threads Kernel）。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202154001.png"><br>我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，不需要像用户级线程那样自己设计线程调度等。</p><p>这种方式又分一对多、一对一、多对多三种，<a href="https://leetcode.cn/leetbook/read/concurrency/atqmpr/">参考</a></p><ul><li>一对多，特点同用户空间实现多线程</li><li>一对一，管理线程开销大，<strong>Windows (从 Win95 开始) 和 Linux 都实现了线程的一对一模型</strong>。</li><li>多对多，复用线程（线程池）</li></ul><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p><strong>线程库就是为开发人员提供创建和管理线程的一套 API</strong>。</p><p>下面简单介绍下三个主要的线程库：<br>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展<br>2）Win32 线程：用于 Window 操作系统的内核级线程库<br>3）Java 线程：<strong>Java 线程 API 通常采用宿主系统的线程库来实现</strong>，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p><p><strong>现今 Java 中线程的本质，其实就是操作系统中的线程。</strong></p><p>其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Win32 线程库来管理线程，且 Windows 采用的是一对一的线程模型。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有一个虚拟机栈空间。</p><p>当然，使用多线程就不可避免的会遇到一个问题，那就是线程的上下文切换（Thread Context Switch），就是说因为某些原因导致 CPU 不再执行当前的线程，转而执行另一个线程。</p><p>导致线程上下文切换的原因大概有以下几种：<br>1）线程的 CPU 时间片用完<br>2）发生了垃圾回收<br>3）有更高优先级的线程需要运行<br>4）线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p><p>当线程的上下文切换发生时，也就是从一个线程 A 转而执行另一个线程 B 时，需要由操作系统保存当前线程 A 的状态（为了以后还能顺利回来接着执行），并恢复另一个线程 B 的状态。</p><p>这个状态就包括每个线程私有的程序计数器和虚拟机栈中每个栈帧的信息等，显然，每次操作系统都需要存储这么多的信息，频繁的线程上下文切换势必会影响程序的性能。</p><h1 id="二、JAVA内存模型与原子性、可见性、有序性"><a href="#二、JAVA内存模型与原子性、可见性、有序性" class="headerlink" title="二、JAVA内存模型与原子性、可见性、有序性"></a>二、JAVA内存模型与原子性、可见性、有序性</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202154822.png"></p><blockquote><p>JMM(Java Memory Model) 规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory）。</p><p>线程的工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。</p></blockquote><p><strong>这就是并发时内存不一致的元凶！</strong></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>JMM 中定义了以下 8 种操作规范来完成一个变量从主内存拷贝到工作内存、以及从工作内存同步回主内存这一类的实现细节。Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量</li></ul><div class="note note-primary">            <ul><li>lock，unlock执行锁，操作主内存</li><li>read，write操作主内存</li><li>load，store操作工作内存</li><li>assign，use操作执行引擎<br>java的实现，保证以上8种类型的操作一定是原子操作。</li></ul>          </div><p><strong>如何保证原子性？</strong><br>处理器提供了总线锁和缓存锁，<strong>Java 提供了锁和循环 CAS 的方式</strong></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>何为可见性</strong>？就是指当一个线程修改了共享变量的值时，其他线程能够<strong>立即</strong>得知这个修改。<br>所谓可见性就是要把工作内存内容立即写入主内存。</p><h3 id="如何保证可见性？"><a href="#如何保证可见性？" class="headerlink" title="如何保证可见性？"></a>如何保证可见性？</h3><ul><li><strong>volatile</strong>：volatile修饰的变量。</li><li><strong>synchronized</strong>：对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）</li><li><strong>final</strong>：被 <code>final</code> 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看见 <code>final</code> 字段的值。</li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>Java的编译器也有这样的一种优化手段：<strong>指令重排序</strong>（Instruction Reorder）。<br>但都需要遵守一个规定：<br><strong>as-if-serial 语义</strong>：不管怎么重排序，<strong>单线程</strong>环境下程序的执行结果不能被改变。即CPU和编译器不会对存在<strong>数据依赖关系</strong>（1.读后写2.写后读3.写后写）的操作做重排序。</p><p><strong>不同 CPU 之间和不同线程之间的数据依赖性是不被 CPU 和编译器考虑的</strong>。所以as-if-serial的约束在多线程下是无效的。</p><p>结论：<strong>CPU 和 Java 编译器为了优化程序性能，会自发地对指令序列进行重新排序。在多线程的环境下，由于重排序的存在，就可能导致程序运行结果出现错误</strong>。</p><h3 id="如何保证有序性？"><a href="#如何保证有序性？" class="headerlink" title="如何保证有序性？"></a>如何保证有序性？</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>as-if-serial规定</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li><code>volatile</code> 本身除了保证可见性的语义外，还包含了禁止指令重排序的语义，所以天生就具有保证有序性的功能。</li><li><code>synchronized</code>保证有序性的理论支撑，仍然是 JMM 规定在执行 8 种基本原子操作时必须满足的一系列规则中的某一个提供的：<strong>一个变量在同一个时刻只允许一条线程对其进行 lock 操作</strong></li><li><code>Happens-before</code> 原则</li></ul><div class="note note-primary">            <p>volatile和synchronized都可以保证可见性和有序性。<br>final可以保证可见性。<br>as-if-serial原则保证单线程有序性。<br>happens-before原则保证多线程有序性。</p>          </div><h2 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>可见性和有序性是矛盾的：我们希望内容足够可见，但又希望提高性能（重排序）。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>如果一个操作 Happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作<strong>可见</strong>，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 Happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 Happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 Happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）</li></ol><div class="note note-primary">            <p>如果A happens before B</p><ul><li>一般来说，A需要在<strong>先于</strong>B执行并保证结果<strong>可见</strong>。</li><li>但如果<strong>重排序</strong>不影响执行结果，也可以改变执行顺序。</li></ul>          </div><p>JMM 其实是在遵循一个基本原则：<strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行</strong>。</p><h3 id="8条Happens-before规则"><a href="#8条Happens-before规则" class="headerlink" title="8条Happens-before规则"></a>8条Happens-before规则</h3><p>1）程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生（Happens-before）于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// A  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// B  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;  <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure><p>有A happens-before B，B happens-before C</p><div class="note note-primary">            <p>类似于单线程下的as-if-serial</p>          </div><p>2）管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是 “同一个锁”，而 “后面” 是指时间上的先后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 此处自动加锁</span><br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span>) &#123;<br>        x = <span class="hljs-number">1</span>;<br>    &#125;      <br>&#125; <span class="hljs-comment">// 此处自动解锁</span><br></code></pre></td></tr></table></figure><p>3）volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的 “后面” 同样是指时间上的先后。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202164431.png"></p><blockquote><p>以下将happens before简写为hb<br>程序次序规则：1hb2，3hb4<br> volatile规则：2hb3<br>此时线程A执行writer()，线程B执行reader()<br>如果flag &#x3D;&#x3D; true，则i &#x3D; a &#x3D; 42；</p></blockquote><div class="note note-primary">            <p>因为变量flag被violate修饰，所以它不会发生重排序，写变量a一定在写变量flag前执行。同时，因为flag被violate修饰，所以它在写后会强制同步到主内存，即，该操作完成时即同步（<strong>可见性</strong>），在其后执行读变量的话读到的一定是最新值。</p>          </div><p>4）线程启动原则（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</p><p>5）线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread 对象的 join() 方法是否结束、Thread 对象的 isAlive() 的返回值等手段检测线程是否已经终止执行。</p><p>6）线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread 对象的 interrupted() 方法检测到是否有中断发生。</p><p>7）对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p>8）传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</p><h3 id="“时间上先后发生”和“先行发生”"><a href="#“时间上先后发生”和“先行发生”" class="headerlink" title="“时间上先后发生”和“先行发生”"></a>“时间上先后发生”和“先行发生”</h3><p><strong>两者并无必然关系</strong><br>时间上先后发生：指事件A在事件B之前执行<br>先行发生：指事件A的执行结果对事件B可见</p><ul><li>符合先行发生关系如果对结果没影响也可能被重排序，导致两者矛盾。</li><li>时间上先后发生的不一定先行发生，如两个线程，先后调用set，get方法，这样set在get前调用，但不一定先行发生，无法保证set的结果对get可见。</li></ul><h3 id="Happens-before-与-as-if-serial"><a href="#Happens-before-与-as-if-serial" class="headerlink" title="Happens-before 与 as-if-serial"></a>Happens-before 与 as-if-serial</h3><ul><li>as-if-serial 语义保证单线程内程序的执行结果不被改变，Happens-before 关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。Happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 Happens-before 指定的顺序来执行的。</li></ul><h1 id="三、Java线程"><a href="#三、Java线程" class="headerlink" title="三、Java线程"></a>三、Java线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Thread实现了Runnable接口。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202170026.png"></p><h3 id="1-线程与任务合并"><a href="#1-线程与任务合并" class="headerlink" title="1.线程与任务合并"></a>1.线程与任务合并</h3><p>直接继承Thread+重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义线程对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 线程需要执行的任务</span><br>......<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>();<br><br><span class="hljs-comment">// 一般使用匿名内部类</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-comment">// run 方法内实现了要执行的任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 线程需要执行的任务</span><br>    ......<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-线程与任务分离-Runnable"><a href="#2-线程与任务分离-Runnable" class="headerlink" title="2.线程与任务分离(Runnable)"></a>2.线程与任务分离(Runnable)</h3><p>Thread + 实现 Runnable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程需要执行的任务</span><br>    ......<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建任务类对象</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br><br><span class="hljs-comment">// 匿名内部类</span><br><span class="hljs-comment">// 创建任务类对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        ......<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br></code></pre></td></tr></table></figure><h3 id="3-线程与任务分离-Callable"><a href="#3-线程与任务分离-Callable" class="headerlink" title="3.线程与任务分离(Callable)"></a>3.线程与任务分离(Callable)</h3><p>Thread + 实现 Callable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        ......<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 将 Callable 包装成 FutureTask，FutureTask也是一种Runnable</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>Thread只实现了runnable，所以需要将callable包装成一个runnable，通常使用FutureTask进行包装，其是一个Runnable。</p>          </div><div class="note note-success">            <p>start会异步执行，run会同步执行（<strong>使用当前线程执行，没有真正创建新线程</strong>）。</p>          </div><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h3 id="操作系统线程五态模型"><a href="#操作系统线程五态模型" class="headerlink" title="操作系统线程五态模型"></a>操作系统线程五态模型</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202170624.png"></p><h3 id="Java线程六态模型"><a href="#Java线程六态模型" class="headerlink" title="Java线程六态模型"></a>Java线程六态模型</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202173309.png"></p><ul><li>Java线程模型将操作系统中就绪态（READY）和运行态（RUNNING）两种状态统称为 “RUNNABLE”。</li><li>Java线程新增了WAITING状态和TIMED_WAITING状态，是为了实现线程的手动唤醒。</li></ul><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><p>刚创建，还没start</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><p>调用start后</p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h4><p>阻塞于锁，即同步资源获取失败，指<code>synchronized</code>。</p><blockquote><p>LOCK接口下，线程会进入WAITING状态</p></blockquote><h5 id="何时进入BLOCKED状态"><a href="#何时进入BLOCKED状态" class="headerlink" title="何时进入BLOCKED状态"></a>何时进入BLOCKED状态</h5><ol><li>首次竞争锁失败 RUNNABLE -&gt; BLOCKED</li><li>目标锁被其他线程释放，本线程被唤醒后再次竞争 BLOCKED -&gt; BLOCKED</li><li>处于等待状态的线程被唤醒然后竞争进入<code>synchronized</code>块 WAITING -&gt; RUNNABLE -&gt; BLOCKED</li></ol><div class="note note-primary">            <p>即WAITING状态的线程被唤醒后会先进入RUNNABLE状态，等待系统分配运行资源再竞争锁。</p>          </div><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><h5 id="RUNNABLE到WAITING"><a href="#RUNNABLE到WAITING" class="headerlink" title="RUNNABLE到WAITING"></a>RUNNABLE到WAITING</h5><ol><li>调用<code>Object.wait</code></li><li>调用<code>Thread.join</code>：当前线程调用t.join()，则当前线程需要等t执行完毕后才继续执行</li><li>调用<code>LockSupport.park</code></li></ol><h5 id="WAITING到RUNNABLE"><a href="#WAITING到RUNNABLE" class="headerlink" title="WAITING到RUNNABLE"></a>WAITING到RUNNABLE</h5><ol><li>调用了 <code>Object.notify</code></li><li>调用了 <code>Object.notifyAll</code></li><li>调用了 <code>LockSupport.unpark</code> 恢复某个线程的运行</li></ol><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>不同于WAITING，指定时间后返回到Runnable状态。</p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>终止状态，表示当前线程已经执行完毕。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM下篇:性能监控与调优</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8B%E7%AF%87-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8B%E7%AF%87-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p><strong>生产环境中的问题</strong></p><ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境CPU负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加log，如何确定请求是否执行了某一行代码？</li><li>不加log，如何实时查看某个方法的入参与返回值？</li></ul><p><strong>为什么要调优</strong></p><ul><li>防止出现OOM</li><li>解决OOM</li><li>减少Full GC出现的频率</li></ul><p><strong>不同阶段的考虑</strong></p><ul><li>上线前</li><li>项目运行阶段</li><li>线上出现OOM<div class="note note-primary">            <p>上面这些浏览一下，看个大概就行。</p>          </div></li></ul><h2 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h2><p><strong>监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>调优的大方向</strong></p><ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行JVM调优</li></ul><p><strong>性能优化的步骤</strong><br><strong>第1步：性能监控</strong></p><ul><li>GC频繁</li><li>cpu load过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul><p><strong>第2步：性能分析</strong></p><ul><li>打印GC日志来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo等</li><li>dump出堆文件，使用内存分析工具分析文件</li><li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li><li>jstack查看堆栈信息</li></ul><p><strong>第3步：性能调优</strong></p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li></ul><p><strong>吞吐量</strong></p><ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li>吞吐量为1-1&#x2F;(1+n)，其中-XX::GCTimeRatio&#x3D;n</li></ul><p><strong>并发数</strong></p><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul><p><strong>内存占用</strong></p><ul><li>Java堆区所占的内存大小</li></ul><h1 id="二、监控-命令行"><a href="#二、监控-命令行" class="headerlink" title="二、监控-命令行"></a>二、监控-命令行</h1><ul><li>jps：查看正在运行的Java进程</li><li>jstat：查看JVM统计信息<ul><li>跟随 -class查看类加载情况</li><li>跟随 -compiler查看编译情况</li><li>跟随 -gc查看垃圾回收情况</li></ul></li><li>jinfo：实时查看和修改JVM配置参数</li><li>jmap：导出内存映像文件&amp;内存使用情况（<strong>dump文件</strong>）</li><li>jhat：JDK自带堆分析工具（已经删除）</li><li>jstack：打印JVM中线程快照</li><li>jcmd：多功能命令行（执行上面的命令）</li><li>jstatd：远程主机信息收集</li></ul><h1 id="三、监控-GUI"><a href="#三、监控-GUI" class="headerlink" title="三、监控-GUI"></a>三、监控-GUI</h1><ul><li>JConsole，java自带</li><li>Visual VM，java自带</li><li>Eclipse MAT，堆分析器，分析dump文件</li><li>JProfiler，好用全面，但收费</li><li>Arthas，阿里开源，远程监控</li><li>Java Misssion Control，Oracle JDK中提供，官方出品，使用采样技术，开销很小<ul><li>Java Flight Record，JMC的组件</li></ul></li></ul><h1 id="四、JVM运行时参数"><a href="#四、JVM运行时参数" class="headerlink" title="四、JVM运行时参数"></a>四、JVM运行时参数</h1><h2 id="JVM参数选项"><a href="#JVM参数选项" class="headerlink" title="JVM参数选项"></a>JVM参数选项</h2><h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><p>java -help出的内容，一般为常规参数</p><h4 id="Server模式与Client模式"><a href="#Server模式与Client模式" class="headerlink" title="Server模式与Client模式"></a>Server模式与Client模式</h4><p>Hotspot JVM有两种模式，分别是server和client，分别通过-server和-client模式设置。</p><ul><li><strong>32位系统</strong>上，默认使用Client类型的JVM。要想使用Server模式，机器配置至少有2个以上的CPU和2G以上的物理内存。<strong>client模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</strong>。</li><li><strong>64位系统</strong>上，<strong>只支持server模式的JVM</strong>，适用于需要大内存的应用程序，<strong>默认使用并行垃圾收集器</strong>。</li></ul><h3 id="类型二：-X参数选项"><a href="#类型二：-X参数选项" class="headerlink" title="类型二：-X参数选项"></a>类型二：-X参数选项</h3><p>java -X 出的内容，相当于一些高级选项<br>熟悉的有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xms&lt;size&gt;        设置初始 Java 堆大小<br>-Xmx&lt;size&gt;        设置最大 Java 堆大小<br>-Xss&lt;size&gt;        设置 Java 线程堆栈大小<br></code></pre></td></tr></table></figure><h3 id="类型三：-XX参数选项"><a href="#类型三：-XX参数选项" class="headerlink" title="类型三：-XX参数选项"></a>类型三：-XX参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+&lt;option&gt;  启用option属性<br>-XX:-&lt;option&gt;  禁用option属性<br><br>-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G<br>-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值<br></code></pre></td></tr></table></figure><p>一些开关类，设置类</p><h2 id="常用的JVM选项"><a href="#常用的JVM选项" class="headerlink" title="常用的JVM选项"></a>常用的JVM选项</h2><h3 id="打印XX选项"><a href="#打印XX选项" class="headerlink" title="打印XX选项"></a>打印XX选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项<br>-XX:+PrintFlagsInitial 打印所有XX选项的默认值<br>-XX:+PrintFlagsFinal 打印所有XX选项的实际值<br>-XX:+PrintVMOptions 打印JVM的参数<br></code></pre></td></tr></table></figure><h3 id="内存大小设置"><a href="#内存大小设置" class="headerlink" title="内存大小设置"></a>内存大小设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">栈</span><br>-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">堆</span><br>-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M<br>-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M<br>-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8<br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br>-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启<br>-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效<br>-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15<br>-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法区</span><br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M<br>-XX:+UseCompressedOops 使用压缩对象<br>-XX:+UseCompressedClassPointers 使用压缩类指针<br>-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接内存</span><br>-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>可见对内存使用的配置基本都是使用<code>-XX：</code>形式，其中设置堆、栈大小给出了<code>-X</code>的形式。</p>          </div><h3 id="OutOfMemory相关的选项"><a href="#OutOfMemory相关的选项" class="headerlink" title="OutOfMemory相关的选项"></a>OutOfMemory相关的选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥<br>-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录<br>-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本<br></code></pre></td></tr></table></figure><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Serial回收器</span><br>-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ParNew回收器</span><br>-XX:+UseParNewGC  年轻代使用ParNew GC<br>-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Parallel回收器</span><br>-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活<br>-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活<br>-XX:ParallelGCThreads<br>-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。<br>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。<br>所以服务器端适合Parallel，进行控制。该参数使用需谨慎。<br>-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小<br>取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。<br>与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。<br>-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。<br>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CMS回收器</span><br>-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。<br>开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合<br>-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。<br>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。<br>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<br>因此通过该选项便可以有效降低Fu1l GC的执行次数。<br>-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动<br>-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理<br>以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。<br>-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。<br>-XX:ParallelCMSThreads  设置CMS的线程数量。<br>CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。<br>当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。<br>-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的<br>-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度<br>-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）<br>-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记<br>用于提高标记速度，在Java8开始已经默认开启<br>-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启<br>-XX:+ExplicitGCInvokesConcurrent<br>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses<br>这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期<br>-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">G1回收器</span><br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。<br>-XX:G1HeapRegionSize 设置每个Region的大小。<br>值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。<br>-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms<br>-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8<br>-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。<br>-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。<br>-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）<br>-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）<br>-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出<br></code></pre></td></tr></table></figure><h4 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h4><ul><li>优先让JVM自适应，调整堆的大小</li><li><strong>串行</strong>收集器：内存小于100M；<strong>单核、单机程序</strong>，并且没有停顿时间的要求</li><li><strong>并行</strong>收集器：<strong>多CPU、高吞吐量</strong>、允许停顿时间超过1秒</li><li><strong>并发</strong>收集器：多CPU、追求低停顿时间、<strong>快速响应</strong>（比如延迟不能超过1秒，如互联网应用）</li><li><strong>官方推荐G1</strong>，性能高。现在互联网的项目，基本都是使用G1。</li></ul><h1 id="五、GC相关日志"><a href="#五、GC相关日志" class="headerlink" title="五、GC相关日志"></a>五、GC相关日志</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息<br>-XX:+PrintGCDetails            打印详细日志信息<br>-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图<br>-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中<br><br>-XX:+TraceClassLoading  监控类的加载<br>-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间<br>-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间<br>-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用<br>-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布<br>-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储<br>-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目<br>-XX:GCLogFileSize=1M  设置GC日志文件的大小<br></code></pre></td></tr></table></figure><h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用<br>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小<br>-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况<br>-XX:+DoEscapeAnalysis  开启逃逸分析<br>-XX:+UseBiasedLocking  开启偏向锁<br>-XX:+UseLargePages  开启使用大页面<br>-XX:+PrintTLAB  打印TLAB的使用情况<br>-XX:TLABSize  设置TLAB大小<br></code></pre></td></tr></table></figure><h2 id="Java获取运行参数"><a href="#Java获取运行参数" class="headerlink" title="Java获取运行参数"></a>Java获取运行参数</h2><p>Java提供了<code>java.lang.management</code>包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地或远程监控和管理运行的Java虚拟机。<br>其中<strong>ManagementFactory</strong>类较为常用，另外<strong>Runtime</strong>类可获取内存、CPU核数等相关的数据。通过使用这些api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryMonitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MemoryMXBean</span> <span class="hljs-variable">memorymbean</span> <span class="hljs-operator">=</span> ManagementFactory.getMemoryMXBean();<br>        <span class="hljs-type">MemoryUsage</span> <span class="hljs-variable">usage</span> <span class="hljs-operator">=</span> memorymbean.getHeapMemoryUsage();<br>        System.out.println(<span class="hljs-string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;\nFull Information:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());<br>        System.out.println(<span class="hljs-string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());<br><br>        System.out.println(<span class="hljs-string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 当前堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 空闲堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 最大可用总堆内存大小</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden &#x2F; S0, S1）的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br></code></pre></td></tr></table></figure><p><strong>GC原因</strong></p><ul><li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace区不够用了</li><li>FErgonomics：JVM自适应调整导致的GC</li><li>System：调用了System.gc()方法</li></ul><p><strong>垃圾收集器</strong></p><ul><li>Serial收集器：新生代显示 <code>&quot;[DefNew&quot;</code>，即 Default New Generation</li><li>ParNew收集器：新生代显示 <code>&quot;[ParNew&quot;</code>，即 Parallel New Generation</li><li>Parallel Scavenge收集器：新生代显示<code>&quot;[PSYoungGen&quot;</code>，JDK1.7使用的即PSYoungGen</li><li>Parallel Old收集器：老年代显示<code>&quot;[ParoldGen&quot;</code></li><li>G1收集器：显示<code>&quot;garbage-first heap&quot;</code></li></ul><p><strong>GC前后</strong><br>形式：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p><ul><li>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul><p><strong>GC时间</strong></p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核，一般而言：real time &lt; sys time＋user time<br>如果real＞sys＋user的话，则可能存在下列问题：IO负载非常重或CPU不够用。</p><h1 id="六、浅堆深堆与内存泄漏"><a href="#六、浅堆深堆与内存泄漏" class="headerlink" title="六、浅堆深堆与内存泄漏"></a>六、浅堆深堆与内存泄漏</h1><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><h3 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h3><p><strong>浅堆是指一个对象所消耗的内存</strong>。<br>在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。</p><h3 id="保留集（Retained-Set）"><a href="#保留集（Retained-Set）" class="headerlink" title="保留集（Retained Set）"></a>保留集（Retained Set）</h3><p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。<br>通俗地说，就是指<strong>仅被对象A所持有的对象的集合，包括A自身</strong>。</p><h3 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h3><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p><p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p><h3 id="对象的实际大小"><a href="#对象的实际大小" class="headerlink" title="对象的实际大小"></a>对象的实际大小</h3><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，<strong>但实际上，这个概念和垃圾回收无关</strong>。</p><div class="note note-primary">            <p>浅堆：对象本身的大小<br>深堆：对象及其<strong>独有</strong>所有直接，间接引用的大小<br>对象大小：对象及其所有直接，间接引用的大小</p>          </div><h3 id="支配树（Dominator-Tree）"><a href="#支配树（Dominator-Tree）" class="headerlink" title="支配树（Dominator Tree）"></a>支配树（Dominator Tree）</h3><p>支配树的概念源自图论。体现对象实例之间的支配关系：</p><ul><li>如果指向B的所有路径都经过A，则认为A是B的<strong>支配者</strong>。</li><li>如果A是离B最近的支配者，则A是B的<strong>直接支配者</strong>。</li></ul><h3 id="内存泄漏（memory-leak）"><a href="#内存泄漏（memory-leak）" class="headerlink" title="内存泄漏（memory leak）"></a>内存泄漏（memory leak）</h3><p>严格上说：对象不会再被程序用到了，但是GC又不能回收他们的情况（永生），才叫内存泄漏。<br>宽泛的说：由于对象的生命周期过长（存活过久，如某对象不再使用，但其支配者仍需要存活一段时间的情况）。</p><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>内存泄漏的增多，最终会导致内存溢出。</p><h2 id="Java中内存泄漏的8种情况"><a href="#Java中内存泄漏的8种情况" class="headerlink" title="Java中内存泄漏的8种情况"></a>Java中内存泄漏的8种情况</h2><ul><li>静态集合类（方法区）</li><li>单例模式（方法区）</li><li>内部类持有外部类（一个内部类总是保存着外部类的引用）</li><li>数据库，IO连接等（没有关闭连接，无法回收）</li><li>不合理的作用域（变量作用范围大于其使用范围）</li><li>改变哈希值<ul><li>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则再也无法检索到该对象</li></ul></li><li>缓存泄漏（可以使用WeakHashMap）</li><li>监听器和其他回调<ul><li>回调函数：一个通过<strong>函数指针</strong>调用的函数。如果你把函数的<strong>指针地址</strong>作为<strong>参数传递</strong>给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</li><li>如果客户端向应用注册了一个回调函数，使用后没有取消，则会造成内存泄漏，解决办法是使用WeakHashMap。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM中篇:字节码与类加载</title>
    <link href="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Class文件结构"><a href="#一、Class文件结构" class="headerlink" title="一、Class文件结构"></a>一、Class文件结构</h1><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td></tr></tbody></table><blockquote><p>其中un表示有n个字节。</p></blockquote><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>u4<br><code>0xCAFEBABE</code></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>u2+u2<br>主版本号和副版本号一起构成版本号：M.m<br>不同编译器的class文件不同，目前JVM可以向下兼容。</p><h2 id="常量池集合"><a href="#常量池集合" class="headerlink" title="常量池集合"></a>常量池集合</h2><p>u2(常量数量)+ cp_info（常量表大小）</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>u2，从1开始计数，所以constant_pool_count&#x3D;1时说明有0个常量。</p><div class="note note-primary">            <p>因为0索引被空出来作为“空常量”</p>          </div><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool"></a>constant_pool</h3><p>1 ~ constant_pool_count - 1为索引<br>主要存放<strong>字面量Literal</strong>和<strong>符号引用Symbolic References</strong>，其包含该class文件中如下内容：</p><ul><li>字面量<ul><li>字符串</li><li>final常量</li></ul></li><li>符号引用<ul><li>类，接口名</li><li>方法名</li><li>字段名</li></ul></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>使用1byte表示该常量的类型：如字符串、符号引用等，即下表中的tag，剩余的部分根据类型不同而不同。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201163645.png"><br>其中：只有CONSTANT_utf8_info的长度是不固定的，其本身也代表字符串，其他常量项的属性可以指向CONSTANT_utf8_info。</p><h2 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的，即bitmap，这样只使用<strong>2byte</strong>即可表达所有访问标志。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。</li><li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。JDK8后，默认每个class文件都设置了ACC_SUPER标志，目的是向后兼容。</li></ul><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><h3 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h3><p>2byte，指向常量池</p><h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>2byte，指向常量池</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>指向常量池索引集合。</p><h4 id="interfaces-count（接口计数器）"><a href="#interfaces-count（接口计数器）" class="headerlink" title="interfaces_count（接口计数器）"></a>interfaces_count（接口计数器）</h4><p>2byte，interfaces_count项的值表示当前类或接口的直接超接口数量。</p><h4 id="interfaces（接口索引集合）"><a href="#interfaces（接口索引集合）" class="headerlink" title="interfaces（接口索引集合）"></a>interfaces（接口索引集合）</h4><p><code>interfaces_count*2byte</code><br>每个成员的值必须是对常量池表中某项的有效索引值，长度为interfaces_count</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><h3 id="fields-table"><a href="#fields-table" class="headerlink" title="fields_table"></a>fields_table</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识符"><a href="#访问标识符" class="headerlink" title="访问标识符"></a>访问标识符</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h4 id="描述符索引"><a href="#描述符索引" class="headerlink" title="描述符索引"></a>描述符索引</h4><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object</code>;</td></tr><tr><td><code>[</code></td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D </code></td></tr></tbody></table><h4 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h4><p>每个字段还可以拥有不同的属性，如初始值，注释信息。这些属性的数量放在属性计数器attribute_count中，内容放在属性集合attributes中。</p><p>比如某常量字段拥有下面三个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>methods表中的每个成员都必须是一个method_info结构：</p><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识-1"><a href="#访问标识-1" class="headerlink" title="访问标识"></a>访问标识</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>这里与字段&#x2F;方法表中的属性集合要分开，字段&#x2F;方法中属性集合是描述字段&#x2F;方法属性的，本处的属性表集合用来描述class文件的附加信息。</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>attributes_count的值表示当前class文件属性表的成员个数。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>属性表中每一项都是一个attribute_info结构。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><p>各种属性的含义见官网，具体问题具体分析。</p><h1 id="二、字节码指令集"><a href="#二、字节码指令集" class="headerlink" title="二、字节码指令集"></a>二、字节码指令集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p><ul><li>i代表对int类型的数据操作，</li><li>l代表long</li><li>s代表short</li><li>b代表byte</li><li>c代表char</li><li>f代表float</li><li>d代表double</li></ul><div class="note note-primary">            <p>注意，编译器会将boolean,byte,char,short作为int使用i开头的指令处理。</p>          </div><h2 id="加载与存储"><a href="#加载与存储" class="headerlink" title="加载与存储"></a>加载与存储</h2><ul><li>xload，将<strong>局部变量</strong>加载到操作数栈。</li><li>iconst、bipush等，<strong>常量入操作数栈</strong></li><li>xstore，<strong>出栈装入局部变量表</strong></li></ul><div class="note note-primary">            <ul><li>x为a表示对象操作，如aload，即加载一个对象到操作数栈。</li><li>在x后加a表示从数组中操作，如iaload，即从<code>int[]</code>数组中取数。</li></ul>          </div><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><h3 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201172429.png"></p><h3 id="运算模式"><a href="#运算模式" class="headerlink" title="运算模式"></a>运算模式</h3><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；<br><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p><h3 id="NaN值使用"><a href="#NaN值使用" class="headerlink" title="NaN值使用"></a>NaN值使用</h3><p>对于浮点数，有特殊的表达式：<br>1&#x2F;0.0 &#x3D; Infinity<br>0.0&#x2F;0.0 &#x3D; NaN</p><h3 id="算数指令-1"><a href="#算数指令-1" class="headerlink" title="算数指令"></a>算数指令</h3><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位与指令</td><td>iand</td><td>land</td><td></td></tr><tr><td></td><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td></tr><tr><td>比较指令</td><td></td><td>lcmp</td><td>fcmpg &#x2F; fcmpl</td><td>dcmpg &#x2F; dcmpl</td></tr></tbody></table><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table><thead><tr><th>转化</th><th>byte</th><th>char</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>int</td><td>i2b</td><td>i2c</td><td>i2s</td><td>○</td><td>i2l</td><td>i2f</td><td>i2d</td></tr><tr><td>long</td><td>l2i i2b</td><td>l2i i2c</td><td>l2i i2s</td><td>l2i</td><td>○</td><td>l2f</td><td>l2d</td></tr><tr><td>float</td><td>f2i i2b</td><td>f2i i2c</td><td>f2i i2s</td><td>f2i</td><td>f2l</td><td>○</td><td>f2d</td></tr><tr><td>double</td><td>d2i i2b</td><td>d2i i2c</td><td>d2i i2s</td><td>d2i</td><td>d2l</td><td>d2f</td><td>○</td></tr></tbody></table><p><strong>宽化类型转换</strong>，可能有精度损失，如long-&gt;double，但结果不会偏离太远。<br><strong>窄化类型转换</strong>，可能造成数据溢出导致结果不正确，并有下面的规律：</p><ul><li>浮点-&gt;整数<ul><li>NaN -&gt; 0</li><li>其他 -&gt; 向0取整 或 转换为整数能表示的最大值</li></ul></li><li>浮点-&gt;浮点(d2f)<ul><li>过小 -&gt; 0</li><li>过大 -&gt; 正负无穷大</li><li>NaN -&gt; NaN</li></ul></li></ul><h2 id="对象创建与访问"><a href="#对象创建与访问" class="headerlink" title="对象创建与访问"></a>对象创建与访问</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><table><thead><tr><th>创建指令</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>创建类实例</td></tr><tr><td>newarray</td><td>创建基本类型数组</td></tr><tr><td>anewarray</td><td>创建引用类型数组</td></tr><tr><td>multilanewarra</td><td>创建多维数组</td></tr></tbody></table><h3 id="字段访问"><a href="#字段访问" class="headerlink" title="字段访问"></a>字段访问</h3><table><thead><tr><th>字段访问指令</th><th>含义</th></tr></thead><tbody><tr><td>getstatic、putstatic</td><td>访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td>getfield、 putfield</td><td>访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th></tr></thead><tbody><tr><td>xaload</td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td></tr><tr><td>xastore</td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td></tr></tbody></table><h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>判断给定对象是否是某一个类的实例</td></tr><tr><td>checkcast</td><td>检查类型强制转换是否可以进行</td></tr></tbody></table><ul><li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li><li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li></ul><h2 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h2><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><ul><li>invokevirtual，调用对象的实例方法，<strong>支持多态</strong>。</li><li>invokespecial，调用特殊方法，静态绑定。</li><li>invokestatic，静态绑定。</li><li>invokedynamic，动态解析方法，并执行。该指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。</li></ul><div class="note note-primary">            <p>invokedynamic是lambda表达式的具体底层实现，使用较少，类似于通过方法句柄调用方法，与反射不同，有点难理解，不要过度关注。</p>          </div><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td>xreturn</td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p><h3 id="操作数栈管理"><a href="#操作数栈管理" class="headerlink" title="操作数栈管理"></a>操作数栈管理</h3><ul><li>pop，出栈</li><li>dup，复制栈顶<ul><li>dupm表示复制m个slot并压入栈顶</li><li>dupm_xn表示复制m个slot，并插入到栈顶下的（m+n）slot的位置。</li></ul></li><li>swap，交换栈顶两个slot数值，long,double不可用（占用两个slot）</li><li>nop，占位</li></ul><h2 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h2><ol><li>比较指令</li><li>条件跳转指令</li><li>比较条件跳转指令</li><li>多条件分支跳转指令。</li><li>无条件跳转指令等。</li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>athrow 抛出异常或错误。将栈顶异常抛出<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>ret 从子例程返回</p><h3 id="athrow"><a href="#athrow" class="headerlink" title="athrow"></a>athrow</h3><p>即throw语句<br>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>异常表保存了每个异常处理信息。比如：</p><ul><li>起始位置</li><li>结束位置</li><li>程序计数器记录的代码处理的偏移地址</li><li>被捕获的异常类在常量池中的索引</li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。<br>如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p><p>如果有finally块，则finally块必然执行，finally块在return前执行，但不影响return的结果，因此最好不要在非finally块中使用return。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；不需要显式的用字节码表示。</p><h4 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h4><ul><li>如果设置了同步，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li><li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li><li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个<strong>同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</strong></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>jvm的指令集有monitorenter和monitorexit 两条指令来支持synchronized关键字的语义。</p><h4 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h4><p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><h1 id="三、类的加载过程"><a href="#三、类的加载过程" class="headerlink" title="三、类的加载过程"></a>三、类的加载过程</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201180946.png"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182105.png"></p><ol><li>通过类的全名，获取类的二进制数据流，来源有：<ul><li>本地文件</li><li>压缩包</li><li>网络</li><li>数据库</li><li>实时生成</li></ul></li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型）：<ul><li>JDK8前：永久代</li><li>JDK8后：元空间</li></ul></li><li>创建java.lang.Class类的实例（堆中），表示该类型。作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>此时Class类中的成员还没有初始化。</p>          </div><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p><strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的。</p><ul><li>因此，若数组元素是引用类型，则先加载引用类型，然后JVM自动创建其数组类型。</li><li>数组的访问权限由其元素类型的访问权限决定。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182705.png"></p><h4 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h4><ul><li><strong>加载过程中，只进行格式检查</strong></li><li>把class文件加载到方法区后，再进行后续的检查</li></ul><h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><ol><li>格式验证：是否以魔数0XCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li><li>语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的。如父类不存在，接口未实现等。</li><li>字节码验证：主要检查是否有不合理的跳转，赋值，调用。（检查手段是有限的，即使通过了这阶段检查也不代表没问题。）</li><li>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的，并有访问权限</strong>。</li></ol><div class="note note-primary">            <p>验证行为贯穿整个类的加载过程</p><ul><li>在加载阶段进行格式检查。</li><li>在链接阶段的验证环节进行语义和字节码验证。</li><li>在链接阶段的解析环节继续拿符号引用验证。</li></ul>          </div><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类分配内存空间，并设置初始值0值。</p><div class="note note-primary">            <p>不包含<strong>基本数据类型的字段</strong>用<strong>static final</strong>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。<br>此外，类变量(static)存放在<strong>堆</strong>中class对象中。</p>          </div><div class="note note-success">            <p><strong>static与static final</strong><br>根据虚拟机规范定义，类变量（static）应该被放入方法区，而java中方法区的具体实践是：</p><ul><li>类元信息放入元空间</li><li>字符串常量池和静态变量放入堆中，其中静态变量是伴随着Class对象分配空间的。<ul><li>如果静态变量是final且是基本数据类型（包括字符串），那么其值会在类加载过程中的<strong>链接环节的准备过程</strong>中初始化赋值，否则在这里赋0值。</li><li>如果静态变量不是final且是基本数据类型（包括字符串），那么其在类加载过程中的<strong>初始化环节</strong>中会初始化赋值。</li><li>所以，无论是否final，基本类型的static成员变量都在堆中（伴随Class对象）</li></ul></li></ul>          </div><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。<br>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h3><ul><li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值</li><li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行，即<code>String a = &quot;12&quot;</code>形式。</li><li>在初始化阶段<code>&lt;clinit&gt;()</code>中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</li></ul><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h3><p>该方法是带锁，线程安全的。只会被执行一次。</p><h3 id="类的初始化情况"><a href="#类的初始化情况" class="headerlink" title="类的初始化情况"></a>类的初始化情况</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p>总之是需要使用到类的字段或方法的情况。</p><ul><li>实例化</li><li>调用静态方法</li><li>获取静态字段</li><li>使用反射（包括<strong>forName</strong>）</li><li>继承该类</li><li>default方法</li><li>包含main方法</li><li>被指定调用MethodHandler</li></ul><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了以上情况都是被动使用，比如：</p><ul><li>通过子类引用父类的静态变量，子类不会初始化。</li><li>数组定义，定义某种类型的数组</li><li>引用某个的常量static final（常量在链接的准备阶段就已经完成赋值）</li><li><code>loadClass()</code>也不会主动初始化。</li></ul><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>类加载器</strong>与<strong>被该加载器加载的类</strong>的内部实现中，存在着双向引用。因此根据GC的原理，当某一个类的Class对象不再被引用时，即可回收，因此回收类的前提是回收其加载器。</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li><strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载的。</strong></li><li><strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>。</li><li>被开发者<strong>自定义的类加载器</strong>实例加载的类型<strong>只有在很简单的上下文环境中才能被卸载</strong>，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。</li></ul><h3 id="卸载前提"><a href="#卸载前提" class="headerlink" title="卸载前提"></a>卸载前提</h3><ul><li>所有类实例被回收</li><li>所有对该类的引用被回收</li><li>该类的加载器被回收</li></ul><h1 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。</p><p>ClassLoader在整个装载阶段，<strong>只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为</strong>。至于它是否可以运行，则由Execution Engine决定。</p><div class="note note-primary">            <p>ClassLoader只定义类加载中的<strong>加载环节的细节</strong>。</p>          </div><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="加载方式分类"><a href="#加载方式分类" class="headerlink" title="加载方式分类"></a>加载方式分类</h3><ul><li>显式加载：反射</li><li>隐式加载：JVM加载</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p><strong>类的唯一性：由加载器和该类共同决定其唯一性。</strong></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>可见性，子加载器可以看见父加载器加载的类型，反之则不行。</li><li>单一性，由于可见性，父加载器加载的类不会被子加载器重复加载。</li></ul><h2 id="加载器分类"><a href="#加载器分类" class="headerlink" title="加载器分类"></a>加载器分类</h2><ul><li>引导类加载器（Bootstrap ClassLoader）</li><li>自定义类加载器（User-Defined ClassLoader）</li></ul><p>加载器之间不是继承关系，而是<strong>包含关系</strong>，子加载器包含父加载器的引用，因此其可以看见父加载器加载的内容（可见性），以及调用父加载器（实现双亲委派机制）。</p><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><h4 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h4><ul><li>C&#x2F;C++实现，在JVM内部实现</li><li>加载核心库</li><li>没有父加载器</li></ul><h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>加载ext.dirs目录下的类库</li><li>父类加载器为启动类加载器</li><li>直接继承于URLClassLoader，最终继承于ClassLoader类（一个抽象类）</li></ul><h4 id="系统类加载器（AppClassLoader）"><a href="#系统类加载器（AppClassLoader）" class="headerlink" title="系统类加载器（AppClassLoader）"></a>系统类加载器（AppClassLoader）</h4><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li>父类加载器为扩展类加载器</li><li>直接继承于URLClassLoader，最终继承于ClassLoader类（一个抽象类）</li></ul><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><p>可以通过自定义实现插件机制，此外加载器可以实现应用隔离。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="ClassLoader主要方法"><a href="#ClassLoader主要方法" class="headerlink" title="ClassLoader主要方法"></a>ClassLoader主要方法</h3><p>ClassLoader是一个抽象类，基本java实现的加载器都继承自它。<br>其有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span><br><span class="hljs-comment">//加载</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-comment">//链接</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span><br></code></pre></td></tr></table></figure><ul><li>其中，<code>loadClass()</code>会调用<code>findClass()</code>，而loadClass中实现了双亲委派机制，因此自定义加载器时，尽量只重写findClass()及其调用的方法。</li><li><code>findClass()</code>会调用<code>defineClass()</code>，其指明如何将byte流解析成Class对象。</li></ul><h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><ul><li>SecureClassLoader继承并扩展了ClassLoader功能，添加了权限认证。</li><li>URLClassLoader继承并扩展了SecureClassLoader，其对ClassLoader中的许多抽象方法做了具体的实现。</li><li>一般自定义加载类直接继承URLClassLoader非常方便。</li></ul><h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><ul><li>JDK8中，这两个类都继承自URLClassLoader</li><li>JDK9中，这两个类都继承自BuiltinClassLoader</li></ul><h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><ul><li>前者会初始化，后者不会。</li><li>后者需要指定一个具体的加载器加载。</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先交给父类加载器加载，加载失败再由子类加载。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202001557.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>搜索类，有则返回</li><li>有父类则委托加载</li><li>无父类则使用引导类加载器加载（必须委托一次引导类，实现保护的核心API的功能）</li><li>都失败则主动加载</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>避免重复加载</li><li>保护核心类库</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>顶层无法访问底层加载器，系统类无法访问应用类，无法在系统类的方法中调用应用类。</li></ul><div class="note note-primary">            <p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</p>          </div><h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><h4 id="第一次：覆盖loadClass"><a href="#第一次：覆盖loadClass" class="headerlink" title="第一次：覆盖loadClass"></a>第一次：覆盖loadClass</h4><p>双亲委派机制推出前就有ClassLoader存在，loadClass方法已经被用户使用自定义加载器覆盖（没有双亲委派），后来才推荐用户改写findClass。</p><h4 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h4><p>解决系统类无法调用用户类的缺点，如JNDI服务就需要调用，管理用户类。</p><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202002835.png"><br>父类加载器可以通过线程上下文类加载器委托给子类加载器完成类的加载。这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h4 id="第三次：用户的要求"><a href="#第三次：用户的要求" class="headerlink" title="第三次：用户的要求"></a>第三次：用户的要求</h4><p>第三次破坏源于用户需求：代码热替换(Hot Swap)、模块热部署(Hot Deployment)等。</p><p>背景：IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>搜索顺序：</p><ol><li>java.开头，委托父类（双亲）</li><li>若在委派列表名单中，委托父类（双亲）</li><li>在各种列表中寻找类加载器进行加载（平行）</li></ol><p>PS：了解一下就行。</p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003613.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱。即将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源（CPU、内存、文件系统、网络）访问。</p><h3 id="JDK1-0"><a href="#JDK1-0" class="headerlink" title="JDK1.0"></a>JDK1.0</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003843.png"></p><h3 id="JDK1-1"><a href="#JDK1-1" class="headerlink" title="JDK1.1"></a>JDK1.1</h3><p>增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003849.png"></p><h3 id="JDK1-2"><a href="#JDK1-2" class="headerlink" title="JDK1.2"></a>JDK1.2</h3><p>改进了安全机制，增加了<strong>代码签名</strong>。由<strong>类加载器</strong>加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003938.png"></p><h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><p>虚拟机会把所有代码加载到不同的系统域和应用域。</p><p>系统域专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。</p><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003950.png"></p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>隔离加载类（容器隔离）</li><li>修改类的加载方式（动态加载）</li><li>扩展加载源（数据库，网络）</li><li>防止源码泄漏（加密）</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>方式</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法，推荐<br>说明</li><li>其父类加载器是系统类加载器</li></ul><h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</li><li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/323cfcda53f98034ed15372c0ea43685.png"><br>3. 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。<br>4. 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。<br>5. 类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202004846.png"></p><div class="note note-primary">            <p>总结就是：</p><ol><li>ext改名plat</li><li>新增getName()方法</li><li>plat和app不再继承url，而是builtin</li><li>引导类由java实现</li><li>双亲委托前可直接判断所属系统并交付</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM上篇:内存与垃圾回收</title>
    <link href="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JVM与Java体系"><a href="#一、JVM与Java体系" class="headerlink" title="一、JVM与Java体系"></a>一、JVM与Java体系</h1><ul><li>JVM只关心字节码文件</li><li>虚拟机是对物理计算机的模仿</li><li>JVM是运行在操作系统之上的，不直接与硬件交互<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140012.png"></li></ul><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140104.png"></p><h2 id="Java代码执行顺序"><a href="#Java代码执行顺序" class="headerlink" title="Java代码执行顺序"></a>Java代码执行顺序</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140118.png"></p><h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><ul><li>栈式架构<br>实现更简单，不需要硬件支持，指令集更小，跨平台</li><li>寄存器架构<br>指令集架构则完全依赖硬件，可移植性差</li></ul><h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></p><h3 id="虚拟机退出的情况"><a href="#虚拟机退出的情况" class="headerlink" title="虚拟机退出的情况"></a>虚拟机退出的情况</h3><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。<br>总结：一个正常执行完毕，两个错误终止，两个手动终止。</li></ul><h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="类加载器与类加载过程"><a href="#类加载器与类加载过程" class="headerlink" title="类加载器与类加载过程"></a>类加载器与类加载过程</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140856.png"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li><strong>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</strong></li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ol><li>通过类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>这里注意，加载阶段就完成了方法区数据结构的装载和Class对象的生成，但此时还没有进行类初始化，即此时类中的字段还没有初始化。</p>          </div><h4 id="补充：class文件来源"><a href="#补充：class文件来源" class="headerlink" title="补充：class文件来源"></a>补充：class文件来源</h4><ul><li>本地</li><li>网络</li><li>动态代理，动态生成</li><li>压缩包</li><li>JSP</li><li>数据库</li><li>加密文件</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在子确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li><strong>这里不包含用final修饰的static，因为final static在编译的时候就会分配了，准备阶段会显式初始化；</strong></li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<strong>符号引用转换为直接引用</strong>的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。符号引用就是一组符号来描述所引用的目标。</li><li>符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><strong>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。</strong></li><li>该阶段是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和<strong>静态代码</strong>块中的语句合并而来。</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</li></ul><div class="note note-primary">            <ul><li>加载阶段负责把字节码的二进制文件加载到方法区，并根据字节码在堆中生成class对象</li><li>链接阶段负责检验class文件的正确性、为类的变量分配内存并设置默认值（0值）、解析时将符号应用转换为直接引用。</li><li>初始化负责对类变量、static块执行赋值。</li></ul>          </div><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul><li>分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li><li>Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144137.png"></li></ul><h3 id="自带的加载器"><a href="#自带的加载器" class="headerlink" title="自带的加载器"></a>自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li><strong>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</strong></li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li><strong>并不继承自ava.lang.ClassLoader，没有父加载器。</strong></li><li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</strong></li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><div class="note note-primary">            <ul><li>引导类加载器不继承ClassLoader；其他类都继承该抽象类，被称为自定义类加载器。</li></ul>          </div><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>启动类加载器</strong></li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/1ib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>扩展类加载器</strong></li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><div class="note note-primary">            <p>具体到类加载过程中的步骤，其可以加密（防止源码泄漏），可以扩展加载的源（如网络），可以修改类的加载方式并隔离加载类（热部署）。</p>          </div><p>实现步骤：</p><ul><li>JDK1.2之前，继承ClassLoader，覆盖loadClass方法。</li><li>JDK1.2之后，继承ClassLoader，覆盖findClass方法（其被loadClass方法调用）。</li><li>没有复杂需求时，直接继承URLClassLoader，避免自己编写findClass。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144950.png"></li></ul><h3 id="获取ClassLoader方法"><a href="#获取ClassLoader方法" class="headerlink" title="获取ClassLoader方法"></a>获取ClassLoader方法</h3><ul><li>clazz.getClassLoader()</li><li>Thread.currentThread().getContextClassLoader() &#x2F;&#x2F;上下文线程的加载器</li><li>ClassLoader.getSystemClassLoader() &#x2F;&#x2F;系统类加载器</li><li>DriverManager.getCallerClassLoader() &#x2F;&#x2F;调用者的加载器</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul><li>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式</li><li>加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</li></ul><p><strong>原理</strong><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145155.png"><br>具体实现在loadClass()方法中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>如何判断两个class对象是否相同</strong><br>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p><strong>对类加载器的引用</strong></p><ul><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</li><li>如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。<div class="note note-primary">            <p>不同类加载器加载的对象解析需要其在同一个域。</p>          </div></li></ul><p><strong>主动使用与被动使用</strong><br>对类的成员的调用：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>初始化一个类的子类<br>规范：</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>Java虚拟机启动时被标明为<strong>启动类</strong>的类</li><li>JDK 7 开始提供的动态语言支持：<br>  java.lang.invoke.MethodHandle实例的解析结果<br>  REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都不会导致<strong>类的初始化</strong>。</p><h1 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h1><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145718.png"></p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>PS：JVM允许一个应用有多个线程并行的执行。在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><h2 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h2><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><div class="note note-primary">            <p>可以理解为JVM后台运行的线程，其中虚拟机线程是管理其他线程的线程，其令JVM达到安全点才调用执行一些操作，如Stop-the-world，线程栈收集，线程挂起，偏向锁撤销。</p>          </div><h2 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h2><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123150208.png"><br>作用：<br>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li><li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</strong></li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；<strong>或者，如果是在执行native方法，则是未指定值（undefined）</strong>。</li></ul><div class="note note-primary">            <p>每个线程都拥有一个PC计数器，相互隔离（私有），标识当前线程的执行点，这样执行引擎就会执行该地址代码。</p>          </div><p><strong>为什么使用PC寄存器记录当前线程的执行地址呢？</strong><br>CPU可能会分片执行，切换线程后需要知道从哪里开始执行。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。</p><ul><li><strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。</li><li>生命周期和线程一致</li><li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li><li>JVM对栈的操作仅有，出栈，入栈。</li></ul><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><code>StackOverflowError</code>，超过设定的栈容量</li><li><code>OutOfMemoryError</code>，整体内存空间不足。</li></ul><p>**设置大小方法:</p><ul><li>**<code>-Xss</code></li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><ul><li>栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong>。</li><li>栈帧<strong>先进后出</strong>，一个线程只有一个活动栈帧，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</li></ul><p>Java方法有两种返回函数的方式：</p><ul><li>一种是正常的函数返回，使用return指令；</li><li>另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h3 id="栈帧中的内容"><a href="#栈帧中的内容" class="headerlink" title="栈帧中的内容"></a>栈帧中的内容</h3><ul><li><strong>局部变量表（Local Variables）</strong></li><li><strong>操作数栈（operand Stack）（或表达式栈）</strong></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul><li>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><h5 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h5><ul><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li><li><strong>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</strong></li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或doub1e类型变量）</li><li>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123151728.png"><br>另外，Slot空间可以被复用，如某些局部变量超出作用域后，新的局部变量可以复用该位置。</p><h5 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h5><p>Static：类变量表有两次初始化的机会：</p><ul><li>第一次是在“链接阶段中的准备阶段”，执行系统初始化，对类变量设置零值。</li><li>另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li></ul><p>局部变量表：不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</p><div class="note note-primary">            <p>虚拟机栈指的就是整个线程栈，线程栈分若干个栈帧，栈帧中又有操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p>          </div><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123152330.png"></p><p>PS：每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</p><h5 id="栈顶缓存-Top-Of-Stack-Caching-技术"><a href="#栈顶缓存-Top-Of-Stack-Caching-技术" class="headerlink" title="栈顶缓存(Top Of Stack Caching)技术"></a>栈顶缓存(Top Of Stack Caching)技术</h5><p>操作数是存储在内存中的，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接、方法返回地址、附加信息有时被一起称为帧数据区。</p><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。通过这个引用，可以实现动态链接。</p><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123154403.png"></p><div class="note note-primary">            <p>现有动态链接，再有栈帧！<br>比如，现在某对象A在方法A0中调用对象B的一个方法B0，字节码文件如下：<br>invokeVirtual B0</p><p>此时虚拟机会根据操作数栈顶的对象类型，根据<strong>字符串</strong>查找其方法中类元信息中的<strong>方法入口</strong>。<br>但是每次调用方法都扫描查找一次类信息是很繁琐的，在方法区的运行时常量池中，直接保存了字符串与方法入口地址的对应关系（直接引用），这个对应关系也叫类B的Vtable。</p>          </div><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，<strong>动态链接的作用就是为了将这些符号引用转换位调用方法的直接引用</strong>。</p><div class="note note-primary">            <p>个人理解：某个方法A可能会调用其他方法B，在执行引擎遇到调用其他方法的语句如invokeVirtual时，需要找到方法B的入口。<br>而栈帧中保存了一个指针，指向了方法B符号在运行时常量池中的位置，再通过运行时常量池，实现将符号引用转化为直接引用。</p>          </div><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。</p><ul><li>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li><li>通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>目标方法在编译期可知，且运行期保持不变时。对应<strong>早期绑定</strong>，调用非虚方法。</p><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用。对应<strong>晚期绑定</strong>，调用虚方法。</p><h4 id="方法绑定"><a href="#方法绑定" class="headerlink" title="方法绑定"></a>方法绑定</h4><p>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><ul><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通方法调用</span><br>invokestatic：调用静态方法，解析阶段确定唯一方法版本<br>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本<br>invokevirtual：调用所有虚方法<br>invokeinterface：调用接口方法<br><br><span class="hljs-comment">//动态方法调用</span><br>invokedynamic：动态解析出需要调用的方法，然后执行<br></code></pre></td></tr></table></figure><p><strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><p><code>invokedynamic</code>在JAVA7中才出现，但没有直接生成该指令，在JAVA8中的Lambda表达式可以生成<code>invokedynamic</code></p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>也就是前面动态链接中提到的Vtable，每个类都有一个这样的虚方法表存在于方法区，便于查找方法的真实入口。</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>根据操作数栈顶元素的实际对象类型寻找方法</li><li>找到后使用权限校验，通过则调用，不通过则报异常</li><li>找不到则根据继承关系循环进行1，2步</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>方法中定义的局部变量是否线程安全？<br>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><h2 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>native修饰的方法<br>主要用于与外部环境、操作系统交互，调用C语言实现的方法等。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>实现本地方法的管理调用，也是每个线程持有一个。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129213758.png"></p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>这个图有点问题</p><ul><li>本地方法入栈后，执行引擎会调用本地方法库执行本地方法。</li><li><strong>本地方法接口</strong>则是<strong>本地方法访问虚拟机内部数据</strong>的接口。</li></ul><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。</p><p>并不是所有JVM都支持本地方法。<br><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆空间结构"><a href="#堆空间结构" class="headerlink" title="堆空间结构"></a>堆空间结构</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214614.png"><br>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214618.png"></p><p><strong>堆空间大小设置</strong></p><ul><li>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code><br>默认Xms:电脑内存&#x2F;64<br>默认Xmx:电脑内存&#x2F;4</li></ul><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129215125.png"></p><ul><li>可以设置新生代&#x2F;老年代占比：默认<code>-XX:NewRatio=2</code></li><li>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，可以使用<code>-XX:SurvivorRatio</code></li><li>可以使用<code>-Xmn</code>设置新生代最大内存大小。</li></ul><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><h4 id="小对象分配原则"><a href="#小对象分配原则" class="headerlink" title="小对象分配原则"></a>小对象分配原则</h4><ul><li><code>Eden</code>出生，一次MinorGC后进入<code>Survivor</code></li><li>15次（使用-XX:MaxTenuringThreshold&#x3D;N调整）Survivor移动后进入<code>Old</code>。</li><li><code>Old</code>若被MajorGC可能会清理，若无法保存则报OOM。</li></ul><h4 id="其他分配原则"><a href="#其他分配原则" class="headerlink" title="其他分配原则"></a>其他分配原则</h4><ul><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>动态对象年龄判断：如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保（-XX:HandlerPromotionFailure），开启时：<ul><li>MinorGC前检查老年代是否有连续空间容纳新生代的对象空间。<ul><li>若有，则可以执行MinorGC</li><li>若无，检查是否开启空间分配担保<code>-XX:HandlePromotionFailure</code><ul><li>若开启，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。<ul><li>若大于，则进行一次MinorGC（有风险）</li><li>若小于，FullGC</li></ul></li><li>否则，FullGC<div class="note note-primary">            <p>为什么需要空间担保：<br>minorGC时可能直接将大量Survivor区对象直接放入Old区，此时需要Old区保证能接受这些对象，若老年代剩余空间&gt;新生代所有对象大小，则肯定可以接受。若空间&lt;对象大小，则可以根据之前的回收情况预估实际进入老年代的对象大小，判断是否需要据此进行冒险的MinorGC，以避免盲目的FullGC。<br><strong>JDK7及以后已经弃用。此后，默认会进行冒险行为，否则FullGC。</strong></p>          </div></li></ul></li></ul></li></ul></li></ul><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>Thread Local Allocation Buffer，堆是所有线程共享的，因此也是线程不安全的。TLAB表示JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。<br>可以通过<code>-XX:UseTLAB</code>决定是否开启TLAB，通过<code>-XX:TLABWasteTargetPercent</code>决定TLAB占用Eden空间的大小。</p><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><p>GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h4><p>Eden满，需要清理Eden，STW。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129220927.png"></p><h4 id="MajorGC-x2F-FullGC"><a href="#MajorGC-x2F-FullGC" class="headerlink" title="MajorGC&#x2F;FullGC"></a>MajorGC&#x2F;FullGC</h4><p>Old区不够用时发生，Major发生总是伴随着MinorGC，但不绝对，STW。</p><h4 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h4><ol><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>要尽量避免FullGC，其耗时太长。</p><h3 id="堆是分配对象的唯一选择吗？"><a href="#堆是分配对象的唯一选择吗？" class="headerlink" title="堆是分配对象的唯一选择吗？"></a>堆是分配对象的唯一选择吗？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。</p><p>JDK6u23后默认开启逃逸分析，此前需要</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>栈上分配：对象不发生方法逃逸。</li><li>同步省略：对象不发生线程逃逸（其他线程不访问该对象），也叫<strong>锁消除</strong>。</li><li>标量替换：将对象结构体（聚合量）替换为一个个属性（标量，基本类型）。使用<code>-XX:EliminateAllocations</code>开启。</li></ul><p>逃逸分析不成熟，因为分析性能不一定优于优化性能。<br><strong>Hotspot中的所有对象都建立在堆上。</strong></p><div class="note note-primary">            <p>JDK7前，字符串常量池在永久代上，后来永久代被元空间取代，而字符串常量池迁移到堆中，符合了所有对象都建立在堆上的结论。</p>          </div><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>方法区是一个独立于java堆的内存空间。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131114507.png"><br>前面的概念中有提到，方法区只是一个逻辑上的概念。在JDK8之前，方法区由永久代实现，JDK8之后，方法区由元空间实现，其独立于java堆空间，直接使用本地内存（但是也可能报OOM，本地内存的大小也是有限的）。</p><h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3><h4 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h4><ul><li>初始：<code>-XX:Permsize</code></li><li>最大：<code>-XX:MaxPermsize</code></li></ul><h4 id="jdk8之后"><a href="#jdk8之后" class="headerlink" title="jdk8之后"></a>jdk8之后</h4><ul><li>初始：<code>-XX:MetaspaceSize</code></li><li>最大：<code>-XX:MaxMetaspaceSize</code>(设置为-1则不受限制)</li></ul><h3 id="存储什么"><a href="#存储什么" class="headerlink" title="存储什么"></a>存储什么</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><ol><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型直接接口的一个有序列表</li></ol><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ol><li>域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li><li>域类型</li><li>域名称</li></ol><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ol><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的返回类型（或void）</li><li>方法名称</li><li>方法参数的数量和类型（按顺序）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><div class="note note-primary">            <p>简而言之，我们java文件中写的内容基本都会保存到方法区中。</p>          </div><h4 id="对于static-x2F-final"><a href="#对于static-x2F-final" class="headerlink" title="对于static&#x2F;final"></a>对于static&#x2F;final</h4><ul><li>若符号由static修饰，说明是类变量，在类的加载过程中生成。</li><li>若符号由static final修饰，说明是常量，在编译时即完成分配。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131120156.png"></p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池也称静态常量池，每个类的字节码文件（.class）中都具有一个常量池表，其描述了各种<strong>字面量</strong>与<strong>类、域、方法</strong>的<strong>符号引用</strong>。<br>而常量池中一般存储有：</p><ul><li>字段复用<ul><li>数量值</li><li>字符串值</li></ul></li><li>类及成员<ul><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li></ul><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用。<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>，<strong>一个类加载到 JVM 中后对应一个运行时常量池</strong>。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</li></ul><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池是全局</strong>的，里面存储的是字符串对象，而不是字面量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li>常量池存在于Class文件中，表现为 序号（”#1”） 到 字面量（”java&#x2F;lang&#x2F;Object”）的映射</li><li>运行时常量池存在于方法区，表现为 序号（”#1”）到 字面量（基本类型） 或 真实地址的映射。</li><li>常量池在类的加载过程的<strong>链接阶段</strong>的<strong>解析阶段</strong>，会将常量池中的字面量解析为真实地址。</li></ul>          </div><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><table><thead><tr><th>JDK1.6及之前</th><th>有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><div class="note note-primary">            <ul><li>字符串常量池移动到了堆中，但运行时常量池依然在元空间。</li><li>元空间中可能持有字符串的引用。</li></ul>          </div><h4 id="为什么要使用元空间"><a href="#为什么要使用元空间" class="headerlink" title="为什么要使用元空间"></a>为什么要使用元空间</h4><ul><li>永久代大小不应限制，使用元空间使用本地内存</li><li>永久代很难调优，GC起来很困难，类的卸载条件很苛刻。</li></ul><h4 id="StringTable为何换位置"><a href="#StringTable为何换位置" class="headerlink" title="StringTable为何换位置"></a>StringTable为何换位置</h4><p>字符串的创建和回收是很频繁的，放在永久代不宜回收（只有FullGC），而放在堆中可以及时回收。</p><h4 id="静态变量存放在哪"><a href="#静态变量存放在哪" class="headerlink" title="静态变量存放在哪"></a>静态变量存放在哪</h4><p>虚拟机规范要求将class相关信息放置于方法区中，但没有限制方法区的实现，所以HotSpot选择将静态变量随着class对象一起放在堆中。</p><h4 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h4><p>方法区主要回收常量池中废弃的常量和不再使用的类型。</p><ul><li>常量：不再被使用即可回收。</li><li>类型：<ul><li>所有对象已经回收</li><li>所有对该类的引用已经被回收</li><li>对于的类加载器已经被回收<br>满足类型的回收条件也只是允许回收，并不是必然的。</li></ul></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>元空间使用直接内存，NIO（Native IO）时也可以使用直接内存</p><h4 id="非直接内存"><a href="#非直接内存" class="headerlink" title="非直接内存"></a>非直接内存</h4><p>使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><h4 id="直接内存-1"><a href="#直接内存-1" class="headerlink" title="直接内存"></a>直接内存</h4><p>使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。<br>直接内存可以通过<code>MaxDirectMemorySize</code>设置，不指定时与-Xmx参数一致。</p><h1 id="四、对象的实例化过程"><a href="#四、对象的实例化过程" class="headerlink" title="四、对象的实例化过程"></a>四、对象的实例化过程</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ul><li>new：最常见的方式、Xxx的静态方法，XxxBuilder&#x2F;XxxFactory的静态方法</li><li>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis</li></ul><div class="note note-primary">            <ul><li>new，类，构造器的构造方法是一般的生成新对象方法。</li><li>clone和序列化是复制对象的方法。</li><li>第三方库</li></ul>          </div><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol><li>判断对象对应的类是否加载、链接、初始化<ul><li>元空间查找</li><li>失败，双亲委派加载（classloader+包名+类名）</li><li>失败，抛出异常</li></ul></li><li>为对象分配内存（具体如何分配取决于java堆的GC功能）<ul><li>有规整的内存（使用指针碰撞法时）</li><li>内存不规整（需要维护一个空闲列表）</li></ul></li><li>处理并发问题：保证更新的原子性</li><li>初始化分配到的内存（所有对象赋默认值，0值）</li><li>设置对象的对象头</li><li>init方法初始化（显示、代码块，构造器）</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130349.png"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度。</p><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><p>详情见JUC</p><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>有以下两种模式</p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130511.png"><br>优点在于，若对象被移动只需要修改句柄池</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130542.png"><br>HotSpot采用这种方式，访问快速。</p><h1 id="五、执行引擎"><a href="#五、执行引擎" class="headerlink" title="五、执行引擎"></a>五、执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎属于JVM的下层，里面包括<strong>解释器、及时编译器、垃圾回收器</strong><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130915.png"><br>执行引擎的任务就是将字节码指令解释&#x2F;编译成本地平台上的本地机器指令。</p><p>工作流程：执行引擎执行PC寄存器指向的指令，PC寄存器指向下一条指令。</p><h2 id="编译与执行过程"><a href="#编译与执行过程" class="headerlink" title="编译与执行过程"></a>编译与执行过程</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131115.png"></p><ol><li>Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131132.png"></li><li>Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131139.png"></li></ol><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器：对字节码逐行解释成机器码并执行。<br>编译器：</p><ul><li>前端编译器：将java代码编译成class字节码文件</li><li>后端编译器（JIT编译器）：将源代码直接编译成机器语言。</li></ul><p>java是一门半解释半编译的语言。</p><h2 id="指令基本概念"><a href="#指令基本概念" class="headerlink" title="指令基本概念"></a>指令基本概念</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>二进制指令，与CPU相关</p><h3 id="指令与指令集"><a href="#指令与指令集" class="headerlink" title="指令与指令集"></a>指令与指令集</h3><p>将二进制指令使用mov,inc等人类可读的方式表示。不同机器上指令对应的机器码可能不同。每个平台所支持的所有指令，称之为对应平台的指令集。即指令的集合。如-86，ARM</p><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>用助记符代替机器指令的操作码，使用汇编语言编写的程序需要翻译成机器指令码才能被识别、执行。</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍然<strong>需要把程序解释和编译成机器的指令码</strong>。<br>一般都是高级指令翻译成汇编语言，然后翻译成机器指令才能被执行。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>为了实现跨平台，没有采用静态编译生成机器指令，而是生成class文件，由解释器实现跨平台。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><ol><li>字节码解释器：纯软件代码模拟字节码执行。</li><li>模板解释器：每一条字节码和一个模板函数相关联。</li></ol><p>HotSpotVM中，解释器由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><div class="note note-primary">            <p>Interpreter模块可以将字节码翻译为机器码，Code则管理字节码对机器码的映射。</p>          </div><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>基于解释器执行已经沦落为低效的代名词<br>为了解决该问题，JVM平台支持一种叫作即时编译的技术（JIT），将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>JIT编译器属于后端编译器，将字节码翻译为机器码，是一种即时编译器。<br>HopSpot VM使用了<strong>解释器和即时编译器并存的架构</strong>。</p><p>有了JIT，为什么还要解释器？</p><ul><li>快启动</li><li>编译器无法优化程序时，解释器是逃生门</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2。<br>开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li><li><code>-server</code>：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。</li><li><strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>Java7后，就算开启-server模式也会默认使用分层编译。</li></ul><h4 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h4><p>C1编译器上主要有方法内联、去虚拟化、冗余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2的优化主要是在全局层面，做逃逸分析</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h2 id="HopSpotJVM执行方式"><a href="#HopSpotJVM执行方式" class="headerlink" title="HopSpotJVM执行方式"></a>HopSpotJVM执行方式</h2><p>解释器先发生作用，即时编译器根据热点探测将有价值的字节码编译为本地机器指令。</p><ul><li>JIT编译器是<strong>后端运行时编译器</strong>（Just In Time Compiler）,将字节码编译成本地机器指令。</li><li>AOT编译器是<strong>静态提前编译器</strong>（Ahead Of Time），将java文件编译成本地机器指令。</li></ul><h3 id="热点代码及探测"><a href="#热点代码及探测" class="headerlink" title="热点代码及探测"></a>热点代码及探测</h3><h4 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h4><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”。因而可以通过JIT编译器编译为本地机器指令，这种方式叫做栈上替换，或称为OSR（On Stack Replacement）编译。</p><h4 id="热点探测功能"><a href="#热点探测功能" class="headerlink" title="热点探测功能"></a>热点探测功能</h4><p>HotSpot使用的热点探测方式是<strong>基于计数器</strong>的热点探测。</p><p>HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数。</li><li>回边计数器则用于统计方法内循环体执行的循环次数。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>Client模式下默认1500次，Server模式下默认10000次。<br>可以通过<code>-XX:CompileThreshold</code>来人为设定阈值。</p><p>如果发现<strong>方法调用计数器和回边计数器之和</strong>超过了阈值，则会提交JIT即时编译请求。</p><h4 id="热点衰退"><a href="#热点衰退" class="headerlink" title="热点衰退"></a>热点衰退</h4><p>方法调用计数器统计的并<strong>不是方法被调用的绝对次数</strong>，而是一个相对的执行频率，即一段时间之内方法被调用的次数。<br>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减（Counter Decay）</strong>，而这段时间就称为此方法统计的<strong>半衰周期（Counter Half Life Time）</strong><br>热点衰退在GC时顺便进行，可以使用<code>-XX:-UseCounterDecay</code>设置关闭热点衰减，使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li><p><code>-Xint</code>：完全采用解释器模式执行程序；</p></li><li><p><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</p></li><li><p><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</p></li></ul><h1 id="六、StringTable"><a href="#六、StringTable" class="headerlink" title="六、StringTable"></a>六、StringTable</h1><h2 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h2><ul><li>字符串</li><li>final，不可继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。</li><li>String实现了Comparable接口：表示string可以比较大小</li><li>String在jdk8及以前内部定义了<code>final char[] value</code>用于存储字符串数据。JDK9时改为<code>byte[]</code>。</li></ul><h2 id="为什么修改String底层"><a href="#为什么修改String底层" class="headerlink" title="为什么修改String底层"></a>为什么修改String底层</h2><p>原因：<code>char[]</code>数组中大多数char属于Latin-1字符，使用1byte即可表示，但char需要2byte，空间浪费。</p><p>改进：为String提供两种字符集使用（Latin-1或UTF-16）。</p><h2 id="StringPool"><a href="#StringPool" class="headerlink" title="StringPool"></a>StringPool</h2><p>String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</p><p>使用<code>-XX:StringTablesize</code>可设置StringTable的长度</p><ul><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，设置StringTable长度的话，1009是可以设置的最小值</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul><li>直接使用双引号声明出来的String对象会直接存储在<strong>常量池</strong>中。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</li><li>使用new，生成的对象在堆中，不入池。</li></ul><h3 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>Java 6及以前，字符串常量池存放在永久代<br>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<br>Java 8元空间，字符串常量池在堆内。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><code>String str =&quot;ab&quot; + &quot;cd&quot;</code>创建了1个对象，因为”ab”+”cd”会被编译器优化，只在常量池创建一个”abcd”并返回。</li><li><code>String str = new String(&quot;123&quot;)</code>创建了2个对象，一个”123”在字符串常量池，一个new String在堆中，返回堆中对象。</li></ul><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><ul><li>**常量(final)与常量(final)**的拼接结果在常量池，原理是编译期优化</li><li><strong>只要其中有一个是变量</strong>，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><h4 id="优化拼接"><a href="#优化拼接" class="headerlink" title="优化拼接"></a>优化拼接</h4><ul><li>尽量使用StringBuilder.append()</li><li>可以在初始化时，指定StringBuilder的capacity，减少扩容次数。</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>语义是：返回常量池中的相同字符串。</p><ul><li>如果池中本身存在该String对象，则直接返回池中对象。</li><li>否则，将该对象添加到池中，并返回该String对象。</li></ul><h4 id="JDK6-gt-JDK7-x2F-8"><a href="#JDK6-gt-JDK7-x2F-8" class="headerlink" title="JDK6-&gt;JDK7&#x2F;8"></a>JDK6-&gt;JDK7&#x2F;8</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br><span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-built_in">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br><span class="hljs-built_in">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224322.png"><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224329.png"></p><p>JDK1.6中，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象<strong>复制一份</strong>，放入池中，返回池中对象。</li></ul><p>JDK1.7后，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象的<strong>引用地址复制一份</strong>，放入池中，返回引用地址对象。</li></ul><p>简单讲，JDK7后的方式，省去了复制对象的开销。</p><h2 id="G1垃圾处理器去重String"><a href="#G1垃圾处理器去重String" class="headerlink" title="G1垃圾处理器去重String"></a>G1垃圾处理器去重String</h2><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。然后对队列中的元素进行去重处理。</li><li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ol><h1 id="七、垃圾回收"><a href="#七、垃圾回收" class="headerlink" title="七、垃圾回收"></a>七、垃圾回收</h1><h2 id="垃圾回收概念"><a href="#垃圾回收概念" class="headerlink" title="垃圾回收概念"></a>垃圾回收概念</h2><h3 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h3><p><strong>垃圾</strong>：垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>早期C&#x2F;C++，需要开发人员手动释放内存，若存在疏忽则会永久产生内存泄漏。</p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p>Java堆是垃圾收集器的工作重点</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h3 id="对象finalization机制"><a href="#对象finalization机制" class="headerlink" title="对象finalization机制"></a>对象finalization机制</h3><ul><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。</li><li>不要手动调用，应该由垃圾处理器调用<ul><li>调用可能使对象复活</li><li>执行时间无保证，取决于GC线程</li></ul></li><li>finalize()只能被调用一次，也就是说一个对象最多复活一次。</li></ul><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br>优点：</p><ul><li>实现简单，判断效率高。<br>缺点：</li><li>增加了对象的字段</li><li>加减法时间开销</li><li><strong>无法处理循环引用</strong><br>Python使用引用计数算法，通过弱引用解决循环引用的问题。</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>可达性分析算法是以<strong>根对象集合</strong>（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li></ul><h5 id="GCRoot"><a href="#GCRoot" class="headerlink" title="GCRoot"></a>GCRoot</h5><p>栈上引用</p><ul><li>虚拟机栈上引用对象</li><li>本地方法栈上引用对象</li></ul><p>方法区引用</p><ul><li>类静态属性</li><li>常量引用（String Table等）</li></ul><p>其他引用</p><ul><li>同步锁对象</li><li>虚拟机内部对象（class对象）</li><li>本地代码缓存等</li></ul><p>当然还要考虑GC的作用空间：对于young空间的某对象A，存在着被old空间的对象B引用的情况，因此old空间的对象也需要考虑到GCRoots集合中。</p><h4 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h4><p>由于finalize的存在，对象有三种状态。</p><ul><li>可触及</li><li>可复活</li><li>不可触及</li></ul><p>标记过程：</p><ol><li>若无引用，进行一次标记</li><li>若无finalize或finalize已经被执行过，进行二次标记，为不可触及。</li><li>若有finalize，加入F-Queue队列等待Finalizer线程执行finalize方法。</li><li>随后GC对F-Queue进行标记，看是否可触及，可触及则移出队列，否则移出并标记为不可触及。</li></ol><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231730.png"></p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p>缺点</p><ul><li>效率不高</li><li>STW</li><li>碎片</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231822.png"><br>优点</p><ul><li>不需要标记清除，直接复制可达对象，高效</li><li>无碎片<br>缺点</li><li>空间消耗大</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>Survivor区</li></ul><h4 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131232037.png"><br>优化了复制算法，使用原本的内存进行移动。</p><p><strong>指针碰撞</strong><br>指这种通过指针记录空闲空间的起始点，为新对象分配内存时可以直接分配。</p><p>优点</p><ul><li>相对标记清除，使用了指针碰撞</li><li>相对复制算法，不耗多余内存</li></ul><p>缺点</p><ul><li>效率比复制低（时间换空间）</li><li>移动对象时，若对象被其他对象引用，需要调整引用地址（与复制算法相同）</li><li>STW</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>对不同生命周期的对象采取不同的收集方式，以便提高回收效率。即，实际上的GC采用的是分代收集，其根据收集区域使用不同的收集方式。</p><ul><li>年轻代（Young Gen），空间不大，复制算法效率最高。</li><li>老年代（Tenured Gen），不同GC的处理方式不同。</li></ul><h3 id="增量收集算法与分区算法"><a href="#增量收集算法与分区算法" class="headerlink" title="增量收集算法与分区算法"></a>增量收集算法与分区算法</h3><h4 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h4><p>为了避免STW，GC线程与用户线程交替进行，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><p>缺点：线程上下文切换造成总吞吐量下降。</p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131233426.png"></p><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>提醒JVM进行FullGC,不保证立刻生效。</p><h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><ul><li>内存溢出：内存超了<ul><li>超出设置，可以调整</li><li>超出机器内存上限</li></ul></li><li>内存泄漏：存在不再使用的对象无法被回收<ul><li>例子：单例模式，资源未close<br>可以说内存泄漏是内存溢出的元凶之一。</li></ul></li></ul><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>标记过程（枚举GC Roots）需要STW，因为分析工作必须在一个快照中进行，否则准确性无法保证。</p><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上同时发生了，只在多核CPU存在。</li></ul><h4 id="对于垃圾回收"><a href="#对于垃圾回收" class="headerlink" title="对于垃圾回收"></a>对于垃圾回收</h4><p>并行（<em>Parallel</em>）：<strong>多条GC线程</strong>同时执行GC。<br>串行（<em>Serial</em>）：<strong>单GC线程</strong>执行GC。<br>并发（<em>Concurrent</em>）：<strong>用户线程与GC线程</strong>交替执行。</p><p>一次GC可能同时具有并行、并发的特性。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>只有在特定的位置才能STW，这些位置称为安全点。如果安全点过少，GC频率会很低。</p><p>中断方式：</p><ul><li>抢先式中断（已经不再使用），让所有线程在安全点中断。</li><li>主动式中断，线程运行到安全点后主动询问是否需要中断。</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点具有盲区，如果线程无法走到安全点（如Sleep或Block），也应该有中断的机会。<br>安全区域：<strong>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。</strong><br>因此，也可以把Safe Region看做是被扩展了的Safepoint。</p><p>执行时，若线程处于SaveRegion，则可以忽略该线程。当线程走出SaveRegion时，需要判断GC是否结束，若未结束则需要等待。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。<br>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们<br>分类：</p><ul><li>强引用（StrongReference）：引用赋值，不回收。</li><li>软引用（SoftReference）：内存不够（将要溢出前）时进行回收</li><li>弱引用（WeakReference）：GC时后回收</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>不回收，内存泄漏的主要原因之一。</li><li>可以直接访问目标对象。</li></ul><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><ul><li>内存不足即回收。</li><li>主要用于高速缓存。<br>软引用回收时，GC会选择性的将软引用放进一个<strong>引用队列</strong>。</li></ul><h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><ul><li>发现即回收。</li><li>GC时发现弱引用即回收。</li><li>也可用于缓存<br>比软引用回收更容易，更快。</li></ul><p><strong>会被回收的是WeakReference对象持有的对象，WeakReference本身并不会被回收。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value&quot;</span>);<br>WeakReference&lt;String&gt; WeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(hello);<br><span class="hljs-comment">//此时不会回收，因为该String被hello强引用持有。</span><br>System.gc();<br>hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value2&quot;</span>);<br><span class="hljs-comment">//此时，new String(&quot;value&quot;)被回收。</span><br>System.gc();<br></code></pre></td></tr></table></figure><h4 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h4><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。<br>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><div class="note note-primary">            <p>简而言之，将对象放入虚引用后得到的引用sf没有任何作用。<br>但当Object被回收时，phantomQueue会被添加一个虚引用，表示对象已被回收。</p>          </div><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象。</p><div class="note note-primary">            <p>由此可见，引用总是伴随着引用队列，JVM根据队列依次对引用进行处理。</p>          </div><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。<br>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。<br>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。<br>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p><h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><ul><li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li>内存占用：Java堆区所占的内存大小。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul><p>主要抓住两点：<strong>吞吐量（总效率）、暂停时间（用户体验）</strong><br>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h3 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143734.png"><br>按线程和工作模式分：</p><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1<br>按内存区分：</li><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143826.png"></p><ul><li>红色虚线是JDK8已经被移除的GC</li><li>绿色虚线是JDK14中弃用的组合</li><li>蓝色框CMS GC已被删除</li></ul><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>我们选择的只是对具体应用最合适的收集器。<br><code>-XX:+PrintCommandLineFlags</code>可以查看默认参数。</p><h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><strong>Serial GC</strong>：STW，单线程，复制算法<br><strong>Serial Old GC</strong>：STW，单线程，标记-压缩算法。</p><div class="note note-primary">            <p>根据新老年代需求给出的最土味的算法。</p>          </div><h5 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h5><p>Serial Old是Client模式下的默认回收器。<br>简单高效，但单线程不太行，对于web应用不可接受，已经不用了。</p><h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>只回收新生代<br><strong>ParNew</strong>：STW，多线程，复制算法</p><div class="note note-primary">            <p>相对Serial回收器的多线程版本</p>          </div><h5 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h5><p>单CPU下不如串行，可以设置线程数。</p><h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p><strong>Parallel Scavenge</strong>：STW，多线程，复制算法<br><strong>Parallel Old</strong>：STW，多线程，标记压缩</p><div class="note note-primary">            <p>Parallel Scavenge相比于ParNew，回收的目标是<strong>最大的吞吐量</strong>，因此其可控制吞吐量，自适应调节。比较适合<strong>批处理</strong>。</p>          </div><h5 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h5><p>JDK8的Server模式下的默认回收器，可以设置线程数和垃圾收集器最大停顿时间，吞吐量，以及设置自适应调节策略。</p><h4 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201145934.png"><br>只回收老年代，是第一款并发收集器，用户线程与GC线程同时工作。<br><strong>CMS（Concurrent Mark Sweep）</strong>：STW，单&#x2F;多线程，标记-清除算法</p><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><ul><li>初始标记：STW，标记GCRoots以及其直接关联到的对象。</li><li>并发标记：根据GCRoots直接关联对象遍历对象图。</li><li>重新标记：STW，修正由于并发标记期间用户线程造成的变化。</li><li>并发清理：清除标记删除的对象，释放内存。<br>由于并发标记和并发清理最耗费时间，采用并发的方式，整体回收停顿很低。</li></ul><p>另外，由于并发标记，清理中用户线程仍在跑，需要提前进行CMS回收才能防止OOM，一般是当堆内存使用率达到某一阈值时，便开始进行回收。<br>由于标记清除，会产生内存碎片，只能通过<strong>空闲列表</strong>分配内存。</p><h5 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h5><ul><li>并发收集，低延迟</li><li>会产生内存碎片，低延迟但吞吐量不行。</li><li>无法处理浮动垃圾（并发标记期间产生的新垃圾）</li></ul><p>可以设置触发阈值，JDK9中标记过时，JDK14中已经删除。</p><h4 id="G1（Garbage-First）回收器"><a href="#G1（Garbage-First）回收器" class="headerlink" title="G1（Garbage First）回收器"></a>G1（Garbage First）回收器</h4><p>官方给G1设定的目标是在<strong>延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“全功能收集器”的重任与期望。只所以叫G1回收器是因为其优先回收垃圾最多的空间。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151459.png"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>并行性：STW，多线程回收</li><li>并发性：部分工作可以与应用程序交替进行</li><li>分代：依然保持分代，但不要求连续空间，同时回收年轻代和老年代。</li><li>空间整合：Region之间复制算法，整体使用标记压缩，都避免内存碎片。</li><li>延迟：可以只回收一个Region，优先回收价值最大的Region。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不能碾压CMS，运行负担更大，小内存应用上CMS更好，大内存引用上G1更好。（6-8G左右）</li></ul><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li><li>当然也可以设置并发标记线程数和触发阈值。<br>提供三种垃圾回收模式：Young GC，Mixed GC，Full GC。</li></ul><h5 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151944.png"></p><ul><li>Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了找连续H区有时必须FullGC。</li><li>对每个Region内部使用指针碰撞方式分配空间（标记压缩）</li></ul><h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152200.png"></p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC） </li><li>全局GC（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p>一个对象可能被不同区域引用，<strong>Remembered Set是所有分代收集器避免全局扫描的关键</strong>。</p><p>G1的实现细节：<br>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；<br>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；<br>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152820.png"></p><p>更具体的：</p><ul><li>Card Table<ul><li>表中的每个entry覆盖512Byte的内存空间</li><li>当对应的内存空间发生改变时（如赋值操作的时候，会将该对象所在卡片标记），标记为dirty</li></ul></li><li>RememberSet（RSet）<ul><li>指向Card Table中对应的entry</li><li>可找到具体内存区域</li></ul></li></ul><p>当更新Region1的某指针时，会将Card标记为dirty，然后把Card存入Dirty Card Queue，这是因为RSet存在多线程竞争写入问题。</p><div class="note note-primary">            <p>即，将对象赋予给一个引用时，检查引用与对象是否在同一个region，若不在，则在对象所在region的remember set上记录对象被引用信息，最后在回收该区域时，将remember set上的对象也加入GCRoots。</p>          </div><h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201153244.png"><br>触发：当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。<br>回收范围：Eden区和Survivor区。<br>执行原理：STW，多线程，复制算法<br>过程：</p><ol><li>扫描root</li><li>更新rset（将Dirty Card Queue中的Card全部处理）</li><li>处理rset</li><li>复制对象</li><li>处理引用（存活对象的地址发送变化）</li></ol><h5 id="Conconrrent-Mark"><a href="#Conconrrent-Mark" class="headerlink" title="Conconrrent Mark"></a>Conconrrent Mark</h5><p>触发：堆内存达到45%时触发。<br>回收范围：Eden和Survivor区（触发一次Young GC）<br>过程：</p><ol><li>初始标记阶段：STW，扫描GCRoots，并触发一次Young GC（不一定立即执行）。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。<strong>这一过程必须在YoungGC之前完成。</strong></li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：STW，修正并发标记的问题。</li><li>独占清理（cleanup）：STW，计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h5 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h5><p>触发：并发标记结束后<br>回收范围：整个Young Region（Eden，Survivor），部分的Old Region(默认为1&#x2F;8，但分段执行8次)。<br>过程：<br>并发标记结束后，全垃圾的region已经被回收，部分垃圾的region已经被计算。使用和年轻代一样的方法GC即可。<br>备注：</p><ul><li>可以设置垃圾阈值，默认一个region只有垃圾占65%时才回收。</li><li>可以设置允许的垃圾阈值，当整堆中垃圾小于其时，不进行MixedGC。</li></ul><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>触发：以上方式无法正常工作（并发处理过程完成前空间耗尽）。<br>回收范围：整堆<br>特点：STW</p><h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</li><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。<br>回收器选择：官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><div class="note note-primary">            <p>G1回收器，三种清理模式：</p><ul><li>YoungGC：全程STW，根据GCRoots直接处理Young Region，注意rset的处理，region间复制算法。</li><li>MixedGC：<ul><li>STW扫描全局GCRoots压入扫描栈，并触发YoungGC</li><li>根区域扫描，即根据Survivor区找Old区的对象，也压入扫描栈，需要YGC之前完成。 </li><li>并发标记，根据扫描栈扫描对象。</li><li>STW修正标记，处理没处理的write barrier，即新出现的引用变化，但与CMS不同，这里的扫描范围只扫描SATB（snapshot-at-the-beginning），比CMS快。</li><li>STW计算区域属性</li><li>并发清理完全为空的区域</li><li>分段（默认8段）清理各区域。</li></ul></li><li>FullGC</li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第5章（集合）</title>
    <link href="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <url>/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="集合知识体系"><a href="#集合知识体系" class="headerlink" title="集合知识体系"></a>集合知识体系</h1><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109204736.png"><br>集合主要分Map和Collection两个体系:</p><ul><li>Map<ul><li>SortedMap<ul><li>NavigableMap</li></ul></li></ul></li><li>Collection<ul><li>List</li><li>Queue<ul><li>Deque</li></ul></li><li>Set<ul><li>SortedSet<ul><li>NavigableSet</li></ul></li></ul></li></ul></li></ul><div class="note note-primary">            <p>以上都是接口，从功能角度上对集合进行了分类。</p><ul><li>Map作为字典，重要的是其搜索能力，所以其有sorted-&gt;navigable的继承接口。</li><li>Collection中<ul><li>List体现的是对数组的封装，可以随机获取。</li><li>Queue体现单端的进出（堆）<ul><li>Deque实现双端的任意出入</li></ul></li><li>Set需要去重，重要的同样是其搜索能力，所以与map类似，有sorted-&gt;navigable的继承。</li></ul></li></ul>          </div><div class="note note-success">            <p>从基本的实现来看:</p><ul><li>Map<ul><li>map的朴素实现是HashMap<ul><li>HashMap有时需要保留先后顺序，LinkedHashMap继承自HashMap</li></ul></li><li>map搜索增强的实现是TreeMap</li><li>还有一些功能性Map(不做重点)，直接继承Map<ul><li>WeakHashMap，软引用，处于缓存角度，键值可以被回收</li><li>IdentifyHashMap，判断两值相等，只看其引用地址的16位hash（强相等）</li><li>EnumMap，只允许key为指定枚举值，底层其实是array实现。</li></ul></li></ul></li><li>Collection<ul><li>list的朴素实现是ArrayList<ul><li>vector还继承了list，是线程安全的，但已不推荐使用。<ul><li>stack继承了vector，先入先出</li></ul></li></ul></li><li>queue的实现是PriorityQueue(堆)<ul><li>deque的朴素实现是<strong>LinkedList</strong>，这个类也继承了List和Queue，三姓家奴</li><li>deque的另一个实现是ArrayDeque</li></ul></li><li>set与map类似，有HashSet-&gt;LinkedHashSet,TreeSet等实现。</li></ul></li></ul>          </div><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>继承：ArrayList实现了List接口<br>null：允许放入null<br>底层实现：array<br>同步：同步类为vector</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当数组capacity &#x3D;&#x3D; size时添加新元素</li><li>数组扩容通过一个公开的方法<code>ensureCapacity(int minCapacity)</code>来实现。</li><li>每次大约扩容1.5倍。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109213925.png"></li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li>每次add前通过<code>ensureCapacity()</code>确保容量足够</li><li><code>add(int index,E e)</code>，需要先对元素进行移动<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109214209.png"></li><li><code>addAll()</code>，注意addAll不会调用add，其需要保证modCount只+1次。</li></ul><h3 id="set-x2F-get"><a href="#set-x2F-get" class="headerlink" title="set()&#x2F;get()"></a>set()&#x2F;get()</h3><p>直接操作数组即可，不过要检查参数索引是否越界。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><ul><li><code>remove(int index)</code>移除指定坐标，原地copy数组完成</li><li><code>remove(Object o)</code>移除指定对象，底层通过equals判断</li></ul><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>将底层数组的容量调整为当前列表保存的实际元素的大小。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index，也通过equals判断。</p><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>快速失败，modCount标记操作数，避免并发带来的不确定风险。</p><div class="note note-primary">            <p>注意，除了扩容，其他的remove操作只会在原数组上进行copy，通过size维护有效数组大小即可。</p>          </div><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>注意不存在哑节点。</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>LinkedList同时实现了List接口和Deque接口。<br>不过现在的首选是ArrayDeque，其底层通过数组实现，性能更好。</p><h2 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h2><h3 id="底层-1"><a href="#底层-1" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><ul><li><code>getFirst()</code>, <code>getLast()</code>直接获取即可。</li><li><code>get(int index)</code>，通过<code>node(index)</code>获取节点并修改。</li></ul><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h3><p>底层调用unlink方法释放节点。</p><ul><li><code>removeFirst()</code>, <code>removeLast()</code>直接删除，调整指针即可。</li><li><code>remove(e)</code>需要迭代equals判断</li><li><code>remove(index)</code>同理（调用<code>node(index)</code>）<br>ps:</li><li>注意，以上方法都会先对操作的可行性进行判断。</li><li>查找指定索引节点的方法为<code>node(index)</code>，其会根据index判断从前开始找还是从后开始找速度快。</li></ul><h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><ul><li><code>add(E e)</code>直接加到尾部</li><li><code>add(int index,E e)</code>需要线性查找(也会先找<code>node(index)</code>)</li></ul><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>同arraylist，不会调用add()。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>会迭代将node之间引用清空，加快清理速度。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>通过equals迭代判断。</p><h3 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h3><p>上面都是一些list方法的实现，linkedlist还实现了queue和deque，以下是对这些类的实现。<br>peek(),element(),poll(),remove(),offer()</p><ul><li>peek,element,poll,remove都是操作头元素，offer操作尾元素</li><li>element调用<code>getFirst()</code>会抛出空异常，peek()返回null。</li></ul><h3 id="Deque方法"><a href="#Deque方法" class="headerlink" title="Deque方法"></a>Deque方法</h3><p>offerFirst,offerLast,peekFirst,peekLast,pollFirst,pollLast,push,pop</p><ul><li>push，pop都操作头元素。</li></ul><div class="note note-primary">            <p>记忆，</p><ul><li><code>peek,push,pop</code>属于栈方法，操作头元素</li><li><code>peek,offer,poll</code>属于队列方法，默认操作头元素，不会异常，且有双端方法可以使用</li><li><code>add,remove</code>属于list方法，操作尾部元素</li></ul>          </div><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>stack是一个具体的实现类，而Queue却没有，这是一个反常理的事情，不过现在Java已经不推荐使用Stack了，<code>ArrayDeque</code>往往更高效。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是一个接口，实现了Collection接口，其队列特殊方法不会抛出异常。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>deque是一个接口，实现了Queue接口，表示双向队列，支持双向的队列操作。<br>deque常见的实现是LinkedList和ArrayDeque</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>底层通过数组实现，且数组为循环数组，即任一点都可以是起点或终点，如下图。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109232400.png"></p><h3 id="机制-2"><a href="#机制-2" class="headerlink" title="机制"></a>机制</h3><p>ArrayDeque不允许放入null</p><h4 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h4><p><code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code><br>会对head-1取模，如果<code>head-1==-1</code>,则得到的head&#x3D;<code>elements.length - 1</code>，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><div class="note note-primary">            <p>elements.length总为偶数，-1后为全1。<br><code>(head - 1) &amp; (elements.length - 1)</code>相当于对<code>head-1</code>对<code>elements.length-1</code>做取模处理。</p><ul><li>head值若超过length-1，则相当于取余</li><li>head-1若为负数，相当于取对element.length的补码。</li><li>实际上head-1最小为-1，取补码后等于element.length-1。</li></ul>          </div><h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><p>容量满了就需要扩容，方法是<code>doubleCapacity()</code>。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109233801.png"></p><ul><li>第一次复制<code>head</code>右边的元素。</li><li>第二次复制<code>head</code>左边的元素。</li></ul><h4 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h4><p><code>(tail = (tail + 1) &amp; (elements.length - 1)) == head</code><br>tail+1取模，若<code>tail+1==elements.length-1</code>，则得到的tail &#x3D; 0，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><h3 id="pollFirst-pollFirst-peekLast-，pollLast"><a href="#pollFirst-pollFirst-peekLast-，pollLast" class="headerlink" title="pollFirst(),pollFirst(),peekLast()，pollLast()"></a>pollFirst(),pollFirst(),peekLast()，pollLast()</h3><p>返回对应值，为空则返回Null。</p><div class="note note-primary">            <p>注意，ArrayList扩容是1.5倍，ArrayDeque扩容是2倍。</p>          </div><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><ul><li>优先队列不允许放入<code>null</code>元素。</li><li>其通过完全二叉树的小顶堆实现。</li></ul><h3 id="机制-3"><a href="#机制-3" class="headerlink" title="机制"></a>机制</h3><h4 id="底层-2"><a href="#底层-2" class="headerlink" title="底层"></a>底层</h4><p>PriorityQueue底层通过数组维护堆结构<br><code>leftNode = parentNode*2+1</code><br><code>rightNo = parentNo*2+2</code><br><code>parentNo = (nodeNo-1)/2</code></p><h4 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h4><p>使用<code>grow()</code>函数，会复制原数组元素到新数组</p><h4 id="element-peek"><a href="#element-peek" class="headerlink" title="element(),peek()"></a>element(),peek()</h4><p>一个会抛异常，一个不会。都返回下标为0的元素。</p><h4 id="add-offer"><a href="#add-offer" class="headerlink" title="add(),offer()"></a>add(),offer()</h4><p>add、offer，添加在数组末尾，然后逐步向上调节。<br>会调用<code>siftUp(int k, E x)</code>，用于在指定位置插入节点并进行调整。</p><h4 id="remove-poll"><a href="#remove-poll" class="headerlink" title="remove(),poll()"></a>remove(),poll()</h4><p>一个会抛异常，一个不会，都移除下标为0的元素，然后进行堆调整。<br>会调用<code>siftDown(int k, E x)</code>，用于在指定位置删除节点并进行调整。</p><div class="note note-primary">            <p>siftUp，siftDown会根据指定元素x，不断对该位置及其上&#x2F;下的节点进行比较并移动，直到满足找到x小于&#x2F;大于目标节点的时候截至。</p>          </div><h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p>遍历数组删除第一个equals的元素。</p><h1 id="HashSet-amp-HashMap"><a href="#HashSet-amp-HashMap" class="headerlink" title="HashSet&amp;HashMap"></a>HashSet&amp;HashMap</h1><p>二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，即默认value &#x3D;&#x3D; null。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashTable是同步的HashMap。该map不保证元素顺序。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。</p><h3 id="Java7"><a href="#Java7" class="headerlink" title="Java7"></a>Java7</h3><p>HashMap采用的是冲突链表方式**。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110203318.png"></p><p>可见put，get方法可以在常数时间完成，但若table过大，对map进行遍历就会很耗时。</p><p>有<strong>两个参数</strong>可以影响HashMap的性能: 初始容量(<em>inital capacity</em>)和负载系数(<em>load factor</em>)。</p><ul><li>初始容量指定了初始<code>table</code>的大小</li><li>负载系数用来指定自动扩容的临界值。<br>当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</li></ul><p>将对象放入到HashMap或HashSet中时，有<strong>两个方法</strong>需要特别关心：<code>hashCode()</code>和<code>equals()</code>。</p><ul><li><strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。</li><li>所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><p>先<code>getEntry</code>，然后<code>getValue</code><br>其中getEntry先通过hashCode判断bucket，然后通过equals遍历判断。</p><p>求bucket的过程：<br><code>hash(k)&amp;(table.length-1)</code>，与list扩容类似，取模。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>先<code>getEntry</code>，如果没有则<code>addEntry</code>。在链表中使用头插法。</p><h4 id="remove-2"><a href="#remove-2" class="headerlink" title="remove()"></a>remove()</h4><p>先<code>getEntry</code>，然后remove。</p><h3 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h3><p>由 <strong>数组+链表+红黑树</strong> 组成。<br>当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110204320.png"><br>链表的元素为<code>Node</code>，红黑树的元素为<code>TreeNode</code>，通过头节点的类型判断是链表还是红黑树。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 <strong>2 倍</strong>，并进行数据迁移。<br>ps:java7是先扩容再插值，java8是先插值再扩容。</p><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p>判断是红黑树还是链表，采用不同方法取值。</p><p>具体红黑树讲解见TreeMap</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>就是对HashMap的一层包装。</p><h1 id="LinkedHashMap-amp-LinkedHashSet"><a href="#LinkedHashMap-amp-LinkedHashSet" class="headerlink" title="LinkedHashMap&amp;LinkedHashSet"></a>LinkedHashMap&amp;LinkedHashSet</h1><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>实现了map接口，<strong>允许放入key或value为null的元素</strong>，也是HashMap的子类。其使用双向链表将所有entry相连接。并多了header和tail指向<code>头部</code>和<code>尾部</code>。</p><p>优点：遍历时不用遍历所有bucket，只用遍历entrylist即可。</p><p>有<strong>两个参数</strong>可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。<br>将对象放入到LinkedHashMap或LinkedHashSet中时，有<strong>两个方法</strong>需要特别关心: <code>hashCode()</code>和<code>equals()</code>。</p><p>这点与HashMao相同。<br>其没有同步化实现，若需要同步，可使用：<br><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p><h3 id="get-3"><a href="#get-3" class="headerlink" title="get()"></a>get()</h3><p>同HashMap</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><p>也是先getEntry，然后再addEntry<br>add时，既要使用头插法插入bucket链表头部，也要将其插入linkedlist的尾部。</p><h3 id="remove-3"><a href="#remove-3" class="headerlink" title="remove()"></a>remove()</h3><p>同样先get，然后remove，同时维护两个链表。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>是LinkedHashMap的简单包装。</p><h1 id="TreeSet-amp-TreeMap"><a href="#TreeSet-amp-TreeMap" class="headerlink" title="TreeSet&amp;TreeMap"></a>TreeSet&amp;TreeMap</h1><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeSet是对TreeMap的一层包装。</p><p>底层通过红黑树实现。意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。</p><p>TreeSort是非同步的，若需要同步，可以使用：<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1d64y1z7Uk?p=20&vd_source=7324e975d0c1b4b4719d1194e3649ff8">bilibili</a><br>参考blog：<a href="https://www.bilibili.com/read/cv17486236">bilibili</a><br><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。</p><p>性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。<br>树结构改变时，任意破坏3，4，因此需要调整。</li></ol><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="234树"><a href="#234树" class="headerlink" title="234树"></a>234树</h4><p>一种特殊的搜索树。</p><ul><li>2节点表示3个key组成的一个节点</li><li>3节点表示3个key组成的一个节点</li><li>4节点表示3个key组成的一个节点</li></ul><p>当给234树添加节点时</p><ul><li>通过搜索找到应该插入的节点。</li><li>如果该节点位置已经有不超过3个节点，则可以进行合并。</li><li>如果已经为4节点，则需要拆解出节点并向上移动。</li></ul><p>因为这样自底向上的插入性质，其所有根节点的高度总是相等的。</p><h4 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是可以和234树等价的。</p><ul><li>2节点表示一个黑节点</li><li>3节点表示一个红节点和其一个黑子节点</li><li>4节点表示一个红节点和其两个黑子节点</li></ul><p>另外红黑树每个叶子节点都是黑节点（一般是隐藏的，其不会影响红黑树的3，4性质）</p><h4 id="左旋-x2F-右旋"><a href="#左旋-x2F-右旋" class="headerlink" title="左旋&#x2F;右旋"></a>左旋&#x2F;右旋</h4><p>以x节点为中心左旋，其右子节点r会成为x节点的父节点。右子节点r的左节点rl会称为x的右节点。<br>右旋同理，左右旋主要是为了调整树的节点构造，在不影响整体高度的情况下达到我们想要构造。</p><h4 id="节点后继"><a href="#节点后继" class="headerlink" title="节点后继"></a>节点后继</h4><p>搜索树中某节点x有前继pre（比x小的最大节点）和后继post（比x大的最小节点）节点。这两个节点可以完美替换节点x。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="get-4"><a href="#get-4" class="headerlink" title="get()"></a>get()</h4><p>按照常规二叉搜索树寻找即可。<br>底层根据compareTo()的返回值判断进行迭代。</p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h4><p>先查找，若没有，则add。<br>其可能破坏红黑树约束条件，因此需要调整。<br>1.默认插入RED节点。<br>2.1.若其父节点也为BLACK节点，不影响高度（return）。<br>2.2.若其父节点也为RED，需要调整父节点及其叔叔节点为BLACK(+1)，并让爷爷节点为RED(-1)。<br>3.迭代至根节点。</p><h4 id="remove-4"><a href="#remove-4" class="headerlink" title="remove()"></a>remove()</h4><p>先查找，若有，则remove。<br>其可能破坏红黑树约束条件，因此需要调整。</p><p>1.可能移除树中任意位置的节点，可以通过<strong>值替换</strong>的方式转化为移除其前继或<strong>后继</strong>节点，最终只会删除叶子节点或有单侧叶子节点的节点</p><p>2.1.若移除的是RED节点，不影响高度(return)。<br>2.1.1如果该节点是叶子节点，直接(return)<br>2.1.2如果该节点有单侧叶子节点，由叶子节点替代该节点（return）。</p><p>2.2.若移除的是BALCK节点L，需要调整。<br>2.2.1如果该节点是叶子节点，需要先调整，再移除<br>2.2.2如果该节点有单侧子节点，由子节点替代该节点后，再调整。</p><div class="note note-primary">            <p>所谓调整，本质上是一个方法 f(Node node)，其能让node节点这一侧补充一个黑色节点高度。核心思想是，由于移除了黑色节点L，该侧高度（-1），需要找一个节点（且为黑色）补充回来。</p><ul><li>如果L有红色子节点，将其提升后染黑即可。</li><li>如果L没有红色子节点，需要将其父节点P的左&#x2F;右旋，将P移到该侧填补黑色节点。然后由其兄弟节点提升多余节点（兄弟节点有红色子节点）代替父节点并进行调整。</li><li>如果兄弟节点R没有多余红色节点，则将兄弟节点一起染红，然后迭代其父节点P作为L。</li></ul>          </div><p>2.3.1.如果替代上来的节点是红色节点，将其染黑即可(return)<br>2.3.2.如果原节点(2.2.1)或替代上来的节点是黑色节点(2.2.2)，需要进行旋转调整。<br>2.3.3.事实上这不会容易，父节点P左旋时，其右节点R会成为新的父节点，这会导致右侧减去一个节点R，因此，右旋时要保证右侧的高度也不变，需要满足以下几种条件之一：<br>2.4.1.如果兄弟节点为红色，说明其不是真正的兄弟节点（因为234树中3节点和4节点都应该是黑色节点为根），此时应该<strong>调整兄弟节点成黑色节点为根的形态</strong>(通过左&#x2F;右旋并调整颜色实现，达到2.4.2)。<br>2.4.2.如果兄弟节点为黑色，考虑其子节点是否有红色节点可以借用。<br>2.4.2.1.兄弟节点有红色子节点：</p><ul><li>将父节点左旋，并染黑，补充L侧的黑节点个数</li><li>原兄弟节点成为新的父节点，将其调整为原父节点P的颜色</li><li>原兄弟节点的子节点成为新父节点的右节点，将其染黑补充R侧的黑节点个数</li><li>return</li></ul><p>2.4.2.2.兄弟节点没有红色子节点:</p><ul><li>将兄弟节点染红，则导致父节点到叶子的路径总体-1，以父节点为新的L迭代2.2.1步，可以将其视为一个整体。</li></ul><p>2.5最终达到root时，return。</p><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>具体实现类似HashMap，弱引用可以访问对象，但这不是有效引用，即被引用的对象可以被GC回收。<br>WeakHashMap内部通过弱引用管理entry。<br>想要获取HashSet，需要使用：<br><code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>，其可以将任意map转化为set。</p><h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><p>PriorityQueue，TreeSet不允许传入空值，因为其需要比较，其他集合都可以传入Null。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><table><thead><tr><th>不安全</th><th>安全实现</th><th>ConCurrent</th></tr></thead><tbody><tr><td>ArrayList</td><td>Vector&#x2F;Stack</td><td>暂无</td></tr><tr><td>LinkedList</td><td>Collections.synchronizedList(List)</td><td>暂无</td></tr><tr><td>PriorityQueue</td><td>无</td><td>暂无</td></tr><tr><td>HashMap</td><td>Hashtable</td><td>暂无</td></tr><tr><td>LinkedHashMap</td><td>Collections.synchronizedMap(Map)</td><td>暂无</td></tr><tr><td>TreeMap</td><td>Collections.synchronizedSortedMap(SortedMap);</td><td>暂无</td></tr><tr><td>NavigableMap</td><td>Collections.synchronizedNavigableMap(NavigableMap)</td><td>暂无</td></tr></tbody></table><p>Set的Collections包装方法类似map，待补充todo。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第4章（注解、异常、反射）</title>
    <link href="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/"/>
    <url>/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li><strong>生成文档</strong>，通过代码里标识的元数据生成javadoc文档。</li><li><strong>编译检查</strong>，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li><strong>编译时动态处理</strong>，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li><strong>运行时动态处理</strong>，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是注解的注解，一般用于标识注解的属性</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>描述注解的使用范围，即可以在哪些对象上使用注解（常见的有TYPE,FILED,METHOD）等等。</p><h3 id="Retention-amp-RetentionTarget"><a href="#Retention-amp-RetentionTarget" class="headerlink" title="@Retention &amp; @RetentionTarget"></a>@Retention &amp; @RetentionTarget</h3><p>描述注解的保留时间（注意这里是指被保留到什么时候）有（SOURCE,CLASS,RUNTIME）三种策略。</p><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p>被其修饰的注解在标记在 其他对象上后，使用 javadoc 工具为类生成帮助文档时<strong>会保留其注解信息</strong>。</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>被其修饰的注解是否有继承性，如某类使用注解A，其子类也会继承注解A</p><h3 id="Reaptable"><a href="#Reaptable" class="headerlink" title="@Reaptable"></a>@Reaptable</h3><p>描述注解是否可以重复使用，即在一个对象上多次标注（但使用不同的参数）</p><h3 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h3><p>被其修饰的<strong>成员变量</strong>可以被本地方法引用，使用较少。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：<strong>编译检查</strong>，会检查是否按规范重写了父类方法。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：表示这个对象已经过时。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;<br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭编译器警告,可传入<code>String[]</code>著名需要抑制的警告类型。</p><h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><p>如何获取注解信息？<br>通过反射即可获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; T <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span><br><br>Annotation[] getAnnotations()<br></code></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyMethodAnnotation &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">title</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><h3 id="JDK8新注解"><a href="#JDK8新注解" class="headerlink" title="JDK8新注解"></a>JDK8新注解</h3><ul><li>@Repeatable</li><li>新的Target参数<code>ElementType.TYPE_PARAMETER</code>，包括type和parameter。</li></ul><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p>注解之间无法继承，但编译后统一继承<code>java.lang.annotation.Annotation</code></p><h3 id="注解实现原理"><a href="#注解实现原理" class="headerlink" title="注解实现原理"></a>注解实现原理</h3><ul><li>注解是一个继承自Annotation的接口，里面每一个属性其实是一个接口的抽象方法。</li><li>使用注解时，会创建一个注解实例对象，该对象是通过jdk动态代理生成的（在<code>AnnotationInvocationHandler()</code>方法中就封装了代理的逻辑）</li></ul><h3 id="注解引用场景"><a href="#注解引用场景" class="headerlink" title="注解引用场景"></a>注解引用场景</h3><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架从配置化 -&gt; 注解化</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP实现统一日志管理，实现模块的解偶。<br>具体就是以@Log为切点，然后对方法进行增强。</p><h1 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h1><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109184839.png"></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error是JVM无法处理的错误。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><ul><li>Exception是可以被捕获，处理的异常。分为两类：运行时异常和编译时异常。</li><li>运行时异常（不会检查的）：NullPointerException,IndexOutOfBoundsException</li><li>非运行时异常（必须处理的）：IOException、SQLException。</li></ul><h3 id="可检查异常和不可检查异常"><a href="#可检查异常和不可检查异常" class="headerlink" title="可检查异常和不可检查异常"></a>可检查异常和不可检查异常</h3><p>除了Error，RuntimeException及其子类，其他都是可检查异常，需要在编写程序时对其进行解决。</p><h3 id="异常使用"><a href="#异常使用" class="headerlink" title="异常使用"></a>异常使用</h3><ul><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。如果try,catch中有return或throw，会先执行完finally再回去执行返回行为（return&#x2F;throw），如果finally中有返回行为，则不会再回去执行。finally可以脱离catch使用。</li><li><strong>throw</strong> – 用于<strong>抛出</strong>异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法<strong>可能抛出</strong>的异常。</li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>必须声明方法可抛出的任何可查异常（checked exception）。</p><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时会在catch中抛出另一个异常，主要是为了封闭异常细节。</p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>继承Exception即可，习惯上要定义无参和具有描述信息的构造函数。</p><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>JAVA7中引入，会自动关闭资源。需要该资源实现了AutoCloseable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br><span class="hljs-comment">// code</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br><span class="hljs-comment">// handle exception</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>JVM处理异常的机制涉及Exception Table，以下称为异常表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatch</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: goto          <span class="hljs-number">11</span><br>       <span class="hljs-number">6</span>: astore_0<br>       <span class="hljs-number">7</span>: aload_0<br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><p>异常表按<strong>catch顺序</strong>记录的异常捕获信息，包括：</p><ul><li><strong>from</strong> 可能发生异常的起始点</li><li><strong>to</strong> 可能发生异常的结束点</li><li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li><li><strong>type</strong> 异常处理者处理的异常的类信息</li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatchFinally</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">11</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">14</span>: astore_0<br>      <span class="hljs-number">15</span>: aload_0<br>      <span class="hljs-number">16</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">19</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">22</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">27</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">30</span>: astore_1<br>      <span class="hljs-number">31</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">34</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">36</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">39</span>: aload_1<br>      <span class="hljs-number">40</span>: athrow<br>      <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">14</span>   Class java/lang/Exception<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">30</span>   any<br>          <span class="hljs-number">14</span>    <span class="hljs-number">19</span>    <span class="hljs-number">30</span>   any<br></code></pre></td></tr></table></figure><p>一个finally会产生两个捕获表条目，表示try或catch中发送任何异常其都可以捕获并跳转到30执行。<br>如果方法有返回值，为了保证finally执行，会在编译时将finally中内容编译在return语句前。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Class类也是一个类，不同的类都有一个Class类的实体存在于堆中。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191903.png"><br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191923.png"></p><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><h4 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h4><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li><li>类加载器：xxxClassLoader.loadClass(全限定类名)</li></ul><div class="note note-primary">            <p>其中，通过类名.class，类加载器.loadClass获取class对象，不会进行类加载的初始化，此时静态代码块和静态对象不会执行。</p>          </div><h4 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h4><p>可以通过class对象获取该类的构造器。</p><ul><li>getConstructors() 获取所有public构造器</li><li>getDeclaredConstructors() 获取所有声明的构造器<br>以上两个方法不构成覆盖关系，getDeclaredConstructors能获取私有构造器，却无法获取继承到的public构造器。</li></ul><div class="note note-primary">            <p>Field&#x2F;Method的获取中的declared也类似。</p>          </div><h4 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h4><p><code>method.invoke(Object obj, Object... args)</code><br>可以使用arg作为参数，执行obj的method方法</p><h2 id="深入反射"><a href="#深入反射" class="headerlink" title="深入反射"></a>深入反射</h2><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109192732.png"></p><div class="note note-primary">            <p>获取类对象时，只会对类进行加载、链接。<br>只有通过<strong>forName获取类对象</strong>或<strong>创建该类的对象</strong>或<strong>使用该类的静态变量</strong>时才会进行初始化，详情见JVM。</p>          </div><blockquote><p>这里做一下区分，有具体实现的是java程序，没有具体实现的我们认为是交给JVM的(native)。</p></blockquote><ul><li>类加载<ul><li>forName会加载类，其会调用本地方法加载类（交给JVM）</li><li>JVM回调类加载其对类进行加载</li></ul></li><li>实例生成<ul><li>查找构造器，若没有则从JVM获取，有则直接从缓存中取出。缓存的结构名为ReflectionData，Class对象对该缓存使用了软引用，通过reflection()方法获取缓存。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ul><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>SPI（Service Provider Interface）服务发现机制，主要用于框架开发。核心思想就是解偶。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109194225.png"><br>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。<br>当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><p>例子：<br>java定义了java.sql.Driver接口。<br>mysql提供了mysql-connector-java-6.0.6.jar，其META-INF&#x2F;services下有文件<code>java.sql.Driver</code>，其内容为<code>com.mysql.cj.jdbc.Driver</code>，表示使用<code>com.mysql.cj.jdbc.Driver</code>实现<code>java.sql.Driver</code>。</p><h3 id="SPI和API区别"><a href="#SPI和API区别" class="headerlink" title="SPI和API区别"></a>SPI和API区别</h3><ul><li>SPI - “接口”位于“调用方”所在的“包”中，由外部实现该接口。</li><li>API - “接口”位于“实现方”所在的“包”中，服务自身实现该接口。</li></ul><h3 id="SPI缺点"><a href="#SPI缺点" class="headerlink" title="SPI缺点"></a>SPI缺点</h3><ul><li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第3章（泛型）</title>
    <link href="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/"/>
    <url>/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><h2 id="泛型的功能"><a href="#泛型的功能" class="headerlink" title="泛型的功能"></a>泛型的功能</h2><p>代码复用，使用一个代码流程适配多个类型。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class="hljs-keyword">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h2><p>使用泛型时，我们可以具体制定此时需要适配的类型，然后<strong>编译器</strong>会根据此进行类型检查，约束编码。</p><h1 id="二、泛型的基本使用"><a href="#二、泛型的基本使用" class="headerlink" title="二、泛型的基本使用"></a>二、泛型的基本使用</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>创建该类的对象的时候可以制定泛型的具体类型，其方法也会适配。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&lt;T&gt;&#123;         <span class="hljs-comment">// 此处可以随便写标识符号，T是type的简称  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;     <span class="hljs-comment">// var的类型由T指定，即：由外部指定  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 返回值的类型由外部决定  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <span class="hljs-comment">// 设置的类型也由外部决定  </span><br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsDemo01</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;  <br>        Point&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>&lt;String&gt;() ;     <span class="hljs-comment">// 里面的var类型为String类型  </span><br>        p.setVar(<span class="hljs-string">&quot;it&quot;</span>) ;                            <span class="hljs-comment">// 设置字符串  </span><br>        System.out.println(p.getVar().length()) ;   <span class="hljs-comment">// 取得字符串的长度  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用多元泛型&lt;A,B&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.value = value ;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>不要惧怕<code>&lt;&gt;</code>，其就是一个用来传参的窗口，类似与方法中在<code>()</code>写入多个参数，泛型则是在<strong>类&#x2F;接口的创建</strong>或<strong>方法的使用</strong>时，传入类型的参数<code>&lt;type1,type2&gt;</code>，从而令类型、方法等具体化。</p>          </div><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>可见定义接口和定义类类似，在实现该接口时，也应该使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;        <span class="hljs-comment">// 在接口上定义泛型  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> ; <span class="hljs-comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;   <span class="hljs-comment">// 定义泛型接口的子类  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;             <span class="hljs-comment">// 定义属性  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InfoImpl</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;     <span class="hljs-comment">// 通过构造方法设置属性内容  </span><br>        <span class="hljs-built_in">this</span>.setVar(<span class="hljs-keyword">var</span>) ;    <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个非泛型类里面也可以有泛型方法，泛型方法的目的也是可以对一个泛型方法传入多种类型的参数，而不需要new很多泛型类来实现。<br>同时，泛型方法就是为了适配不同类型的参数，所以一般在声明方法时，型参的类型也是一个泛型类，如下面的<code>Class&lt;T&gt;</code>。</p><p>此时泛型的类别应该在调用该方法时，通过参数？或其他方式，指明类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getObject</span><span class="hljs-params">(Class&lt;T&gt; c)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> c.newInstance();<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-type">Clazz</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clazz</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz1.getObject(Class.forName(<span class="hljs-string">&quot;com.cnblogs.test.User&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>泛型方法需要在修饰符后面加上<code>&lt;T&gt;</code>来标识这是一个泛型方法。</li><li>泛型方法需要使用泛型类型的型参来，使用时传入具体的泛型类型来适配。</li></ul><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>普通方法使用泛型，该方法不属于泛型方法，参数是泛型类，且已经制定了具体的泛型类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;Integer&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h2><p>泛型有一个问题，即</p><ul><li>Even <code>A extends B</code> but <code>List&lt;A&gt;  not extends List&lt;B&gt;</code><br>假如，现在有一个普通方法，参数是一个泛型类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;B&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>如果传入一个<code>List&lt;A&gt;</code>则会出现报错。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用上下边界机制解决,如：</p><h4 id="泛型方法-1"><a href="#泛型方法-1" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;? extends B&gt; list)</span>&#123;&#125;;<br><span class="hljs-comment">//下限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Info&lt;? <span class="hljs-built_in">super</span> String&gt; temp)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="泛型类-1"><a href="#泛型类-1" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;&#123;    <span class="hljs-comment">// 此处泛型只能是数字类型</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;        <span class="hljs-comment">// 定义泛型变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 直接打印</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span>.toString() ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>泛型上下限使用上下限 限制了 泛型的<strong>具体类型</strong>，此时注意<code>？</code>才是真正的泛型类型。<br>具体使用时，</p><ul><li>如果该 类&#x2F;方法 是对 界限类型T的生产者，则使用<code>&lt;? extends T&gt;</code>，即在类&#x2F;方法中有类似T t &#x3D; new B(实际传入的类型)，这类<strong>生产T</strong>的操作。即可以创造一个<code>List&lt;? extends Fruit&gt;</code>，然后我们可以通过getNode()，来确保我们能获取一个Fruit。</li><li>如果该 类&#x2F;方法 是对 界限类型T的消费者，则使用<code>&lt;? super T&gt;</code>，即在类&#x2F;方法中有类似 addNode(T t)，这类<strong>消费T</strong>的操作。一般用于泛型类当中，即可以创造一个<code>List&lt;? super Apple&gt;</code>，这样就知道往这个集合里add Apple或其子类肯定是可行的，因为Apple及其子类肯定也是<code>？</code>具体类型的子类。</li></ul><p>所以，上限确保我们可以得到一个具体类型<strong>T</strong>的引用（生产），下限确保我们可以往类型&#x2F;方法中消耗<strong>T</strong>(消费)。</p>          </div><div class="note note-primary">            <ul><li>在具体的泛型类&#x2F;泛型方法的<strong>声明</strong>中，一般使用<code>T</code>或<code>T extends Clazz</code>声明泛型，然后使用<strong>T</strong>进行操作。</li><li>在具体的普通引用&#x2F;普通方法的参数<strong>声明</strong>中，一般使用<code>List&lt;?&gt;</code>或<code>List&lt;? extends Clazz&gt;</code>，对传入的泛型对象的具体类型的限制。</li></ul>          </div><h4 id="多限制"><a href="#多限制" class="headerlink" title="多限制"></a>多限制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Staff</span> &amp; Passenger&gt;<br></code></pre></td></tr></table></figure><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;<span class="hljs-keyword">String</span>&gt;[] list13 = (List&lt;<span class="hljs-keyword">String</span>&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告 </span><br>List&lt;?&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;?&gt;[] list15 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK</span><br></code></pre></td></tr></table></figure><h1 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h1><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure）。</p><div class="note note-primary">            <p>回到本质，java泛型本质是为了复用代码，泛型则用于在编码时限制，编译时会对其进行擦除。</p>          </div><p>具体操作：</p><ul><li>T和？和? super Clazz都替换为Object<br><img src="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011238.png"></li><li>T extends Clazz&#x2F;? extends Clazz替换为Clazz<br><img src="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011241.png"></li></ul><h3 id="泛型方法-2"><a href="#泛型方法-2" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span><br></code></pre></td></tr></table></figure></li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float </span><br></code></pre></td></tr></table></figure></li></ul><h3 id="编译期检查"><a href="#编译期检查" class="headerlink" title="编译期检查"></a>编译期检查</h3><p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p><p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过</span><br></code></pre></td></tr></table></figure><h3 id="泛型多态"><a href="#泛型多态" class="headerlink" title="泛型多态"></a>泛型多态</h3><p>类型擦除会导致多态冲突，如继承一个具体泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Date&gt; &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>        <span class="hljs-built_in">super</span>.setValue(value);  <br>    &#125;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如我们希望通过继承<strong>具体泛型</strong>来重写具有<strong>具体参数</strong>和<strong>具体返回值</strong>的方法，但父类由于类型擦除，参数会变成Object。导致与重写发生定义冲突。</p><p>此时，JVM会使用桥方法解决问题，以下为字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.tao.test.DateInter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  <br>  com.tao.test.DateInter();  <br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.util.Date)</span>;  <span class="hljs-comment">//我们重写的setValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: invokespecial #<span class="hljs-number">16</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br>       <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> java.util.Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//我们重写的getValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">23</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br>       <span class="hljs-number">4</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">7</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> java.lang.Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;     <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokevirtual #<span class="hljs-number">28</span>                 <span class="hljs-comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br>       <span class="hljs-number">4</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.lang.Object)</span>;   <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">30</span>                 <span class="hljs-comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>编译器通过生成桥方法（Object作为参数和返回值等），实现对父类方法的重写，然后在其中调用我们真正重写的方法。<br>另外，桥方法getValue()看似和我们重写的getValue()冲突，但实际上JVM允许自己通过参数类型和返回类型共同确定一个方法。</p><h3 id="基本类型不能作为泛型类型"><a href="#基本类型不能作为泛型类型" class="headerlink" title="基本类型不能作为泛型类型"></a>基本类型不能作为泛型类型</h3><p>ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><h3 id="泛型类型不能实例化"><a href="#泛型类型不能实例化" class="headerlink" title="泛型类型不能实例化"></a>泛型类型不能实例化</h3><p>编译期找不到对应的类字节码文件，无法确认具体泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(); <span class="hljs-comment">// ERROR</span><br><br><span class="hljs-comment">//解决，利用反射</span><br><span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">newTclass</span> <span class="hljs-params">(Class &lt; T &gt; clazz)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型数组不能初始化"><a href="#泛型数组不能初始化" class="headerlink" title="泛型数组不能初始化"></a>泛型数组不能初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// Error，Class</span><br><br><span class="hljs-comment">//如果对lsa进行强转Object[]，就可以对其添加其他list，导致Class错误，因此要避免这样的情况发生：</span><br><br>List&lt;?&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// OK, array of unbounded wildcard type.</span><br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (Integer) lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">//因为使用？来创建类型，所以array本身的定位就是可以放入不同的list，最后取出时强转，符合逻辑</span><br></code></pre></td></tr></table></figure><h3 id="PS数组类型"><a href="#PS数组类型" class="headerlink" title="PS数组类型"></a>PS数组类型</h3><p><strong>数组类可以分类可以分成两类：</strong></p><ul><li>基本类型的数组类；</li><li>引用类型的数组类；<br>基本类型的数组类的父类是Object，即<code>int[]</code>可以强转<code>Object</code><br>引用类型的数组类的父类有<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>，即如果A extends B，A可以强转<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>。</li></ul><h3 id="泛型数组如何正确初始化"><a href="#泛型数组如何正确初始化" class="headerlink" title="泛型数组如何正确初始化"></a>泛型数组如何正确初始化</h3><p>最好使用列表集合对其替换。或者通过反射建立，因为反射时，类型已经被确认。</p><h3 id="如何理解泛型类中的静态方法和静态变量"><a href="#如何理解泛型类中的静态方法和静态变量" class="headerlink" title="如何理解泛型类中的静态方法和静态变量"></a>如何理解泛型类中的静态方法和静态变量</h3><p>泛型类中的静态方法和静态变量<strong>不可以</strong>使用泛型类所声明的泛型类型参数，显然当静态变量建立时，具体类型还未确认。</p><h3 id="如何理解异常中使用泛型"><a href="#如何理解异常中使用泛型" class="headerlink" title="如何理解异常中使用泛型"></a>如何理解异常中使用泛型</h3><ul><li>不能<strong>捕获</strong>泛型类型的异常。（编译器禁止）<ul><li>由于类型抹去，捕获泛型类型会失效，也可能导致多个catch句子中的父子类顺序混淆<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(Class&lt;T&gt; t)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(T e) &#123; <span class="hljs-comment">//编译错误</span><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123; <span class="hljs-comment">//Integer会抹去，无法捕获</span><br>    ...<br>    &#125; <span class="hljs-keyword">catch</span>(IndexOutOfBounds e) &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>但可以在方法声明中使用泛型并抛出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> T &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Throwable realCause) &#123;<br>        t.initCause(realCause);<br>        <span class="hljs-keyword">throw</span> t; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>由于泛型本质上是为了简化类型转换问题和约束编程，在编译时会进行类型抹去。而catch操作是一个运行时发生的事件，<strong>需要catch具体的类型</strong>，其抹去类型后，与catch的捕获异常的<strong>范围和先后顺序</strong>产生矛盾。<br>但通过限制泛型异常上界，并<strong>捕获其上界</strong>，对其进行抛出是可行的。</p>          </div></li></ul><h3 id="如何获取泛型参数"><a href="#如何获取泛型参数" class="headerlink" title="如何获取泛型参数"></a>如何获取泛型参数</h3><p><strong>Type</strong>是Java所有类型实现的<strong>公共接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericType&lt;String&gt; genericType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;<br><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> genericType.getClass().getGenericSuperclass();<br><span class="hljs-comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> ((ParameterizedType)superclass).getActualTypeArguments()[<span class="hljs-number">0</span>]; <br>System.out.println(type);<span class="hljs-comment">//class java.lang.String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第2章（知识点）</title>
    <link href="/2023/01/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/"/>
    <url>/2023/01/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型有<br>boolean(1),byte(8),char(16),short(16);<br>int(32),long(64),float(32),double(64);</p><p>括号表示类型占的bit数，其中，char,byte,short不会互相转换，其计算时首先转换为int。</p><div class="note note-primary">            <p>java分内码和外码，内码指运行时内存中编码方式。除了内码的都是外码（如class文件，序列化等）。</p><ul><li>boolean：实际上JVM规范将boolean当作int来处理，也就是都占用4个字节。true为1，false为0。</li><li>char：内码中使用UTF16编码，一个字符占2个或4个字节(相当于用两个char表示一个字符)。外码中char使用UTF8编码，一个字符占1-6个字节。</li></ul>          </div><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="String-x2F-Integer-x2F-int"><a href="#String-x2F-Integer-x2F-int" class="headerlink" title="String&#x2F;Integer&#x2F;int"></a>String&#x2F;Integer&#x2F;int</h3><p>基本类型之间，char,byte,short可以转化为int,int-&gt;long-&gt;float-&gt;double可以链式转换，反向转换需要强制类型转换，可能造成数据精度损失。</p><p>String与Integer互相转化：</p><ul><li>String.valueOf(Integer)</li><li>Integer.valueOf(String)<br>String与int互相转化：</li><li>String.valueOf(int) &#x2F; int + “”</li><li>Integer.parseInt(“int”)<br>Integer与int互相转化：</li><li>Integer.valueOf()</li><li>integer.intValue()<div class="note note-primary">            <p>可见，对于具体类（String,Integer）,valueOf是一个将其他类型转化为本类型的通用方法。涉及到其他类型转化为基本类型时，需要使用<code>Integer.parseInt(string)</code>和<code>integer.intValue()</code>这种特殊方法。</p>          </div></li></ul><h3 id="隐式类型"><a href="#隐式类型" class="headerlink" title="隐式类型"></a>隐式类型</h3><h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>1.1字面量是double类型的。<br><code>float f = 1.1f</code></p><h4 id="short"><a href="#short" class="headerlink" title="short"></a>short</h4><p>1字面量是int类型的<br><code>short s1 = 1</code>不可行，而<code>+=</code>可以实现隐式转换<br><code>s1 += 1</code>;<br>相当于s1 &#x3D; (short)(s1 + 1)</p><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li><li>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。<br><strong>自动装箱</strong>的过程，默认调用的是<strong>valueOf</strong>,因此会先判断对象是否在缓存池。<blockquote><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul></blockquote></li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 被声明为 final，因此它不可被继承。其内部使用一个final的char数组存储字符。</p><blockquote><p>JDK9时改为<code>byte[]</code>，因为一个char为2或4字节（UTF16），但大多数情况下char只需要1字节标识，所以使用Latin-1字符集表示即可。当遇到无法表示的字符时，String在转化字符集。</p></blockquote><h3 id="不可变的原因"><a href="#不可变的原因" class="headerlink" title="不可变的原因"></a>不可变的原因</h3><ul><li>String常作为hashKey，不可变时，每个String对象只需要计算一次hash</li><li>StringPool，只有</li><li>安全性，其常作为网络连接参数，不可变保证其正常运行。</li><li>String天生线程安全。</li></ul><h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><ul><li>String不可变，StringBuffer和StringBuilder可变</li><li>String线程安全，StringBuilder线程不安全，<strong>StringBuffer线程安全</strong>，内部synchronized进行同步。</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><ul><li>String s1 &#x3D; new String(“aaa”)不会将对象放入线程池</li><li>String s2 &#x3D; “bbb”会自动将对象放入线程池</li><li>String s3 &#x3D; s1.intern()会将s1放入线程池<br>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>HotSpot字符串常量池放在哪里？</p><ul><li>JVM虚拟机规范中：规定<strong>运行时常量池</strong>在方法区（<strong>方法区只是一个逻辑概念</strong>）内。</li><li>方法区在不同的虚拟机中有不同的实现，HotSpot才有永久代的概念。但随着时间发展，HotSpot也放弃了永久代的概念。</li></ul><table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table><div class="note note-primary">            <ul><li>1.6前，方法区由永久代（ALL）实现。</li><li>1.7时，方法区由永久代（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量）共同实现。</li><li>1.8时，方法区由元空间（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量static）共同实现。</li></ul>          </div><h1 id="二、运算"><a href="#二、运算" class="headerlink" title="二、运算"></a>二、运算</h1><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>减去一个正数 &#x3D; 加上一个负数 &#x3D; 加上一个进位值再减去该数的绝对值 &#x3D; 对原正数求补码并加一（这与我们对负数的补码的定义是相同的）</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="Mod与"><a href="#Mod与" class="headerlink" title="Mod与%"></a>Mod与%</h3><h4 id="求余"><a href="#求余" class="headerlink" title="%求余"></a>%求余</h4><p>a % b &#x3D; c…<code>d</code><br>余数的正负取决于被除数，顾名思义，求余，是指被除数 除以 除数 之后<strong>剩下</strong>的值（求余时，得到的c是<strong>向0取整</strong>的），因此肯定余被除数的符号相同。<br>eg:<br>9%4 &#x3D; 2…<code>1</code><br>9%-4 &#x3D; -2…<code>1</code><br>-9%4 &#x3D; -2…<code>-1</code><br>-9%-4 &#x3D; -2…<code>-1</code></p><h4 id="mod取模"><a href="#mod取模" class="headerlink" title="mod取模"></a>mod取模</h4><p>a mod b &#x3D; c…<code>d</code><br>mod时，结果与除数相同，（得到的c是<strong>向下取整</strong>的）<br>eg:<br>9mod4 &#x3D; 2…<code>1</code><br>9mod-4 &#x3D; -3…<code>-3</code><br>-9mod4 &#x3D; -3…<code>3</code><br>-9mod-4 &#x3D; 2…<code>-1</code></p><div class="note note-primary">            <p>java中%表示求余，但python中%表示求模。且java中的取模操作为<code>Math.floorMod(a,b)</code></p>          </div><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><div class="note note-primary">            <p>所有位运算都是针对补码而言的</p>          </div><h4 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h4><p>相当于 <code>*2</code></p><h4 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移&gt;&gt;"></a>右移&gt;&gt;</h4><p>相当于 <code>/2</code>,向下取整eg:<code>5&gt;&gt;1 = 2</code>,<code>-5&gt;&gt;1 = -3</code><br>(负数的高位补1)</p><h4 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h4><ul><li>对于正数相当于<code>/2</code>，向下取整。</li><li>对于负数，结果需要具体计算(负数的高位补0)</li></ul><h4 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h4><p>~n &#x3D; -(n+1)<br>eg:</p><ul><li>正数：<br>~ 3 &#x3D; -(3+1) &#x3D; -4<br>~0011 &#x3D; -(0011+0001) &#x3D; -0100 &#x3D; 1100</li><li>负数：<br>~ (-3) &#x3D; -(-3+1) &#x3D; 2<br>~1101 &#x3D; -(1101+0001) &#x3D; -1110 &#x3D; 0010</li></ul><div class="note note-primary">            <p>由上可见，在二进制上，取反相当于把1置0，把0置1。<br>在具体值上，我们是对原值的补码进行求反，得到的是答案的补码。<br>如果是正数，符号变负，且绝对值+1。<br>如果是负数，符号变正，且绝对值-1。<br>注意到这个过程是可以相互抵消的，即<del>(</del>n) &#x3D; n，从二进制角度来看，也很符合常理。</p><p>如何求-n的补码：<br>~n+1 &#x3D; -(n+1)+1 &#x3D; -n</p>          </div><div class="note note-success">            <p>取反可以理解成以-0.5为轴旋转！</p>          </div><h4 id="自增"><a href="#自增" class="headerlink" title="自增++"></a>自增++</h4><p>自增++线程不安全</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>java只有值传递，对于对象，传递的是对象的引用指针。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch条件判断语句中可以使用<br>byte,short,char,int,枚举(jdk5.0)，String对象(jdk7.0)，但不能使用long类。<br><strong>PS</strong>：实际上能string对象也只是一个语法糖，底层通过string对象的hash值处理。</p><h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h3 id="Java-中的编译期常量是什么-使用它有什么风险"><a href="#Java-中的编译期常量是什么-使用它有什么风险" class="headerlink" title="Java 中的编译期常量是什么? 使用它有什么风险?"></a>Java 中的编译期常量是什么? 使用它有什么风险?</h3><p>这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。<br>这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h3 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别?"></a>Java 中，Serializable 与 Externalizable 的区别?</h3><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。<br>Externalizable 接口要求重写 writeExternal 和 readExternal 方法，允许手动控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>声明为static和transient类型的数据不能被序列化，反序列化需要一个无参构造函数。<br>transient的内存语义就是其只存在于内存而不会被写入磁盘，可以将一些不希望被序列化的字段加上该关键字。</p><blockquote><p>当使用Externalizable手动实现序列化时不受该限制。</p></blockquote><h3 id="Object有哪些公用方法"><a href="#Object有哪些公用方法" class="headerlink" title="Object有哪些公用方法?"></a>Object有哪些公用方法?</h3><p>clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。</p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li><li>抽象类可以有构造方法, 接口没有构造方法</li><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法<div class="note note-primary">            <p>注意，接口不能拥有成员变量，但可以拥有静态变量。<br>抽象类可以有具体方法（代码复用），但具体类不能有抽象方法。<br>抽象类可以有静态方法，接口在JDK8之前没有，JDK8之后有。</p>          </div></li></ul><h3 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h3><ul><li>finally不管有没有异常都要处理</li><li><strong>当try和catch中有return时，finally仍然会执行，finally比return先执行</strong>，finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以<strong>函数返回值是在finally执行前确定</strong>的</li><li><strong>finally中最好不要包含return</strong>，这样返回值不是try或catch中保存的返回值，而是finally中的return值。<br>finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电。</li></ul><h3 id="局部变量为什么要手动初始化赋值"><a href="#局部变量为什么要手动初始化赋值" class="headerlink" title="局部变量为什么要手动初始化赋值"></a>局部变量为什么要手动初始化赋值</h3><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，<strong>如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销</strong>，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，<strong>解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第1章（面向对象）</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>属性和操作分离，即通过get,set方法操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，子类可以获得父类非 private的属性和方法。</p><div class="note note-primary">            <p>继承应该遵循<strong>里氏替换</strong>原则，子类对象必须能够替换掉所有父类对象。</p>          </div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>:</p><ul><li>编译时多态主要指方法的<strong>重载</strong></li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><blockquote><p>即子类要继承父类，覆盖父类的方法，并使用了父类的指针。</p></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191817.png"><br>即继承父类</p><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191831.png"><br>即实现接口</p><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191859.png"><br>弱依赖，整体不存在了部分也还是存在。</p><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191919.png"><br>强依赖，整体不存在了部分也不存在了。</p><h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192246.png"><br>1对1，1对n，n对1。</p><h3 id="依赖关系（Dependency）"><a href="#依赖关系（Dependency）" class="headerlink" title="依赖关系（Dependency）"></a>依赖关系（Dependency）</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192243.png"><br>A是B类的局部变量、参数，或A向B发送信息。</p><h2 id="面向对象的规则"><a href="#面向对象的规则" class="headerlink" title="面向对象的规则"></a>面向对象的规则</h2><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>Java 中有三个访问权限修饰符（四个访问权限等级）: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>对<strong>类</strong>或类中的成员(<strong>字段</strong>以及<strong>方法</strong>)加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>对于<strong>类</strong>：只有public和defualt修饰符<br>对于<strong>成员</strong>：4种访问等级都有，protected表示<strong>本包和子类</strong>可见</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>1.修饰数据<br>表示数据为不可改变，其只针对编译期检查，运行时会抹去。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变。</li></ul><p>2.修饰类<br>表示类不可继承</p><p>3.修饰方法<br>表示不可重写</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>1.静态变量<br>静态变量就是类变量<br>2.静态方法<br>类加载时就存在，必须实现，不可为抽象方法，也只能访问所属类的静态变量和静态方法<br>3.静态代码块<br>见代码块，类初始化时运行<br>4.静态内部类<br>不依赖外部实例的静态类（内部类本质上是一个单独的class文件）</p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>一个类至少有一个构造器，如果显示定义了构造器，系统默认的无参构造器会失效。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块分：</p><ul><li>普通代码块：类的方法体</li><li>构造代码块：即类中的{}</li><li>静态代码块：即类中的static {}</li></ul><div class="note note-primary">            <p>静态代码块是类加载时执行的，只会在第一次new时执行一次，是类的初始化<br>构造代码块是每新建一个实例都会执行一次，是对象的初始化</p>          </div><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>新建对象调用顺序：<br>静态代码块（只会调用一次）-&gt; 构造代码块 -&gt; 构造器</p><p>因此属性的赋值：</p><ul><li>静态初始化（静态赋值和静态代码块按照执行顺序）</li><li>默认初始化（0,false）</li><li>构造初始化（普通赋值和构造代码块按执行顺序）</li><li>构造函数</li></ul><p>存在继承时：</p><ol><li>父类静态、子类静态</li><li>父类构造初始化、父类构造函数</li><li>子类构造初始化、子类构造函数</li></ol><div class="note note-primary">            <p>静态变量是可以不赋初值的，所以当其被声明时，会先赋予默认值，后续再初值。</p>          </div><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类和抽象方法一定使用 abstract 关键字进行声明。<br>很容易理解：</p><ul><li>抽象类不能被实例化</li><li>抽象方法不能出现在非抽象类中</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口在Java 8之前是纯抽象类，在JAVA8之后其允许默认的方法实现。</p><ul><li>接口的成员，字段都默认（且必须）是Public的</li><li>接口的字段默认是static final的</li></ul><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p>抽象类是IS-A关系，接口是LIKE-A关系</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>接口：多重继承，主要用于表示实现类拥有具体方法。<br>抽象类：主要用于在相关类中共享代码。<br>优先使用接口</p><h4 id="super字段"><a href="#super字段" class="headerlink" title="super字段"></a>super字段</h4><ul><li>super()<br>父类的构造函数，如果子类使用必须放在子类构造函数的第一排</li></ul><h4 id="this字段"><a href="#this字段" class="headerlink" title="this字段"></a>this字段</h4><p>在方法中，this指方法所属对象（static方法里不能有this）<br>在构造函数中，this指正在初始化的对象</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写限制（里氏原则）：</p><ul><li>子类方法访问权限大于父类</li><li>子类方法返回值为父类返回值或其子类<br>@Override会对以上限制进行检查。</li></ul><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>同一个方法的参数：个数，类型，顺序至少一个不同</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类也都是独立的类，均有单独的class文件，但前面会有外部类的类名和$符<br>分类：</p><ul><li>成员内部类<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>局部内部类、匿名内部类</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>作为成员：</p><ul><li>成员内部类可以声明为private或protected，可以调用外部内的结构</li><li>如果是static的成员内部类，可以脱离父类实例存在，因此也只能使用父类静态成员。<br>作为类：<br>可以声明为abstract被其他内部类继承，也可以声明为final禁止继承</li></ul><div class="note note-primary">            <p>不存在静态的外部类，因为这没有意义，外部类的成员只要标注为static就能任意使用。<br>而内部类可以标注为静态，表示其可以脱离父实例而存在，因此若内部类需要再使用static成员，其类本身也必须为static，才可以任意使用。</p>          </div><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>即在方法中声明一个内部类，声明后在只能在方法体内使用。<br>（但可以在方法最后返回这个内部类实例，不过返回值应该设置为该内部类的父类或父接口，毕竟外部不认识该局部内部类）</p><p>其可以使用外部类的成员（包括私有的）、外部方法的局部变量，但必须是final修饰的</p><p>因为是一个局部的，短暂的类，所以其与局部变量类似，不存在修饰符，也不能为静态类或拥有静态成员。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类必须继承父类或实现接口，其只有一个对象，只能多态引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentClass</span>|ParentInterface()&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>局部内部类是主要用于在一个方法中，我们短暂的需要一个结构体来处理问题时使用；而如果我们明确只需要一个具体的函数，但不想为此创造一个新类，且这个函数已经有明确的父类或接口，我们则可以让局部内部类退化为匿名内部类实现这个方法即可。<br>同样，匿名内部类的方法也可以使用外部的变量，但外部的变量必须是final修饰的：<br>匿名内部类，之所以能够使用外部变量，是因为其底层将外部变量作为构造参数传入了匿名内部类，问题的核心在于，如果不声明外部变量为final，当外部变量变化时，匿名内部类无法感知这个变化，可能会导致数据的不一致问题。实际上，JDK8中我们不再需要显示的将外部变量声明为final，其实底层还是为我们加上了final（语法糖）。<br>不过回到final的知识点，读写final字段对于JVM而言，主要是在编译期起限制重排序的作用，详情见JUC。</p>          </div><div class="note note-primary">            <p>匿名内部类是lambda表达式的原型，因此也很好理解为声明lambda表达式只能使用final变量</p>          </div><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><ul><li>equals()<br>默认为比较对象是否等价，需要满足对称等性质。<br><code>==</code>则判断值（基本类型或指针）是否相等。 </li><li>hashCode()<br>默认：是一个native方法，返回int，使用的是对象的地址（引用地址）进行计算。<br>其可以被覆盖（String,Integer等都覆盖了这个方法）。对于两个对象，如果equals返回true,其hashCode()必须相等，因此覆盖equals时总是应该覆盖hashCode方法。</li><li>toString()<br>默认返回对象类型+@+16进制的hashCode()</li><li>clone()<br>clone()是一个native,protected方法<blockquote><p>因为clone修饰符为protected，其只对本包和其子类可见，对于自定义类1，2<br>在类1中调用类2的clone()，Object的默认clone只对类2可见，对类1不可见，所以要重写，一般重写为 return (T)super.clone()</p></blockquote></li></ul><p>另外，一个类要使用clone()方法，必须先继承Cloneable接口，并重写clone()，且要抛出CloneNotSupportedException异常。</p><p>另外，克隆也有浅拷贝和深拷贝，native的clone()只能获得一个对象的<strong>浅拷贝</strong>，对象的属性（引用类型）仍相同。想要获得<strong>深拷贝</strong>，需要在重写中实现。</p><p>替代方案，clone()既复杂又危险，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> &#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[original.arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;<br>            arr[i] = original.arr[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>类的对象有限且确定时可以使用枚举。</p><ul><li>enum定义的枚举类默认继承了java.lang.Enum类。</li><li>枚举类的构造器只能使用 private 权限修饰符。</li><li>必须在枚举类的第一行声明枚举类对象<br>具体使用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> <br>&#123; <br>    RED, GREEN, BLUE; <br>&#125;<br><span class="hljs-comment">//实际使用中，有一种获取静态变量的感觉</span><br>Color.RED<br><br><span class="hljs-comment">//通用方法和字段</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">1</span>), GREEN(<span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">2</span>), BLANK(<span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-number">3</span>), YELLO(<span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">4</span>);  <br>    <span class="hljs-comment">// 成员变量  </span><br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.index = index;  <br>    &#125;  <br>    <span class="hljs-comment">// 普通方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;  <br>            <span class="hljs-keyword">if</span> (c.getIndex() == index) &#123;  <br>                <span class="hljs-keyword">return</span> c.name;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;<br>get,set...<br>&#125;<br><span class="hljs-comment">//也可以声明抽象方法并在所有枚举中实现</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;红色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    GREEN&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;绿色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    BLUE&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;蓝色&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>枚举更像是在创建父类后，在父类中直接构造子类。</p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>指一个公共的，有无参公共构造其，有对应的set，get方法的，即一个标准的实体类。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>私有化构造器</strong>（外部不能new）</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>类自己持有自己的实例</strong>，通过static方法取得该实例，饿汉式表示会预加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>只有调用时才加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton single;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(single == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-type">return</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里省略了线程安全的部分。</p></blockquote><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>顾名思义，一个类A为另一个类做B代理，通过操作A来操作B<br>作用：</p><ul><li>屏蔽真实角色</li><li>增强功能，如添加权限，访问控制和申计</li><li>延迟加载</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>定义一个接口和实现类</li><li>定义一个代理类，实现该接口</li><li>将实现类注入代理类，实现代理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理类AdminServiceProxy与真实类AdminService继承相同的接口，即实现相同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdminService</span> &#123;<br><span class="hljs-comment">//以字段的形式持有真实对象</span><br>    <span class="hljs-keyword">private</span> AdminService adminService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceProxy</span><span class="hljs-params">(AdminService adminService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adminService = adminService;<br>    &#125;<br><span class="hljs-comment">//代理方法，可以在前后进行增强</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre&quot;</span>);<br>        adminService.update();<br>        System.out.println(<span class="hljs-string">&quot;post&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre1&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;pre2&quot;</span>);<br>        <span class="hljs-keyword">return</span> adminService.find();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态代理有<strong>适配器模式</strong>中对象适配器（聚合原类，继承接口）的影子，区别在于这里的原类也继承了该接口。静态代理编写代码时就明确了被代理类和方法。</p></blockquote></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>又名JDK动态代理，使用反射实现动态代理<br>优点：<strong>Proxy对象不需要实现接口，即不用实现接口所有的方法。</strong></p><ul><li>定义一个接口和一个实现类</li><li>定义一个服务类实现<code>InvocationHandler</code>接口，并重写invoke方法。</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>创建代理对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//reflect包中的静态方法，使用类加载器（不管）、接口列表（即生成的代理对象要实现哪些方法）、和事件处理器（代理对象在原目标上要做哪些加强）生成一个新的代理对象</span><br><span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler )</span>;<br><br><span class="hljs-comment">//事件处理器，主要用来写增强的内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceInvocation</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceInvocation</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理类，通过传入 增强器 和 代理目标，生成代理对象,后续可根据这个该代理类实体获取代理对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceDynamicProxy</span> extends &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-keyword">private</span> InvocationHandler invocationHandler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceDynamicProxy</span><span class="hljs-params">(Object target,InvocationHandler invocationHandler)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.invocationHandler = invocationHandler;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getPersonProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), invocationHandler);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>即通过反射的invoke方法，执行目标对象的目标方法。增强器会聚合被代理对象，但不需实现所有接口，invoke最终只会增强指定接口对应的方法。<br>被代理的对象类型没有被限定，因此可以复用增强器。</p></blockquote></li></ul><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>优点：<strong>代理目标对象没有实现接口时可使用</strong>，其会实现一个子类，实现对target对象的代理，因此target类不能为final。</p><blockquote><p>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。（Cglib代理可能是为了弥补无接口的方法的代理问题而出现的。）</p></blockquote><ul><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object object, Method method, Object[] arg2, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-type">AliSmsService</span> <span class="hljs-variable">aliSmsService</span> <span class="hljs-operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br></code></pre></td></tr></table></figure><blockquote><p>这里的增强器没有聚合被代理类，只将其作为拦截方法参数。然后通过代理类工厂将增强器和被代理类聚合在一起生成新类。</p></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h4><ul><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ul><li><strong>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第7章（性能监控）</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="状态命令"><a href="#状态命令" class="headerlink" title="状态命令"></a>状态命令</h1><ul><li>状态信息 - <code>info</code><br>通过<code>info</code>命令查看实时吞吐量（ops&#x2F;sec）。</li><li>监控执行命令 - <code>monitor</code><br>监控接受到的命令</li><li>监控延迟 - <code>latency</code><br>测量响应延迟<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --latency -h 127.0.0.1<br></code></pre></td></tr></table></figure></li><li>内部机制监控<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CONFIG SET latency-monitor-threshold 100 <span class="hljs-comment">#100是阈值，只有慢于100ms的才记录</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">latency latest <span class="hljs-comment">#查看最后一条消息的延迟</span></span><br><br></code></pre></td></tr></table></figure></li></ul><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="避免使用过于复杂的命令"><a href="#避免使用过于复杂的命令" class="headerlink" title="避免使用过于复杂的命令"></a>避免使用过于复杂的命令</h2><p>可以查看slowlog，查看执行慢的命令。</p><h2 id="操作BigKey"><a href="#操作BigKey" class="headerlink" title="操作BigKey"></a>操作BigKey</h2><p>如果value过大，分配内存会比较耗时。<br>可以通过<code>--bigkeys</code>命令扫描</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>避免使用bigkey</li><li>4.0版本以下，使用unlink代替del</li><li>6.0版本以上，开启lazy-free机制<div class="note note-primary">            <p>unlink和lazy-free都可以把释放内存放在后台线程中执行。</p>          </div></li></ul><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>随机过期时间</li><li>lazy-free</li></ul><h2 id="内存达到上限（max-memory）"><a href="#内存达到上限（max-memory）" class="headerlink" title="内存达到上限（max-memory）"></a>内存达到上限（max-memory）</h2><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>改成allkeys随机淘汰</li><li>拆分实例</li></ul><h2 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h2><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><ul><li>控制内存大小（fork与实例大小有关）</li><li>合理配置持久化策略</li></ul><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><p>我们都知道，应用程序向操作系统申请内存时，是按内存页进行申请的，而常规的内存页大小是 4KB。<br>Linux 内核从 2.6.38 开始，支持了内存大页机制，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。<br>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>关闭内存大页机制</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li>写磁盘的瓶颈</li><li>子线程将aof刷入盘中的过程如果阻塞也会影响主线程写aof</li></ul><p>一般下面一种情况发生在：</p><ul><li>正在重写aof</li><li>其他应用程序大量占用磁盘IO</li></ul><h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>配置中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>禁止了重写时的同步磁盘</p><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><p>避免了上下文切换，但Redis有子进程，子进程若大量占用被绑定的CPU，会导致主进程受阻。</p><h3 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h3><p>若一定要绑定，可绑定到多个CPU上，Redis6.0已经支持各线程分别绑定CPU</p><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><p>如果你对操作系统有些了解，就会知道操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。</p><h3 id="解决-7"><a href="#解决-7" class="headerlink" title="解决"></a>解决</h3><ul><li>增加内存</li><li>整理内存</li></ul><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>碎片内存会降低使用效率</p><h3 id="解决-8"><a href="#解决-8" class="headerlink" title="解决"></a>解决</h3><p>整理内存也CPU资源，需要谨慎</p><h2 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h2><h3 id="解决-9"><a href="#解决-9" class="headerlink" title="解决"></a>解决</h3><p>网络IO瓶颈，需要及时扩容。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第6章（缓存问题）</title>
    <link href="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <url>/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><ul><li>缓存穿透</li><li>缓存穿击</li><li>缓存雪崩</li><li>缓存污染（或者满了）</li><li>缓存和数据库一致性</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>。<br>缓存不命中则会一直请求数据库，数据库查不到，又无法写入缓存。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>禁止非法请求，如校验参数合法性</li><li>数据库取不到的数据，在redis中置为key-null，防止大量数据库请求</li><li>bloomfilter，判断key是否在容器中</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（单一过期）<br>缓存过期导致大量针对该过期数据的请求段时间发生。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>设置数据永不过期</li><li>接口限流、熔断</li><li>互斥锁</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大</strong>（大量同时过期）</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。</p><h3 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h3><p><strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p><h3 id="新数据进入redis"><a href="#新数据进入redis" class="headerlink" title="新数据进入redis"></a>新数据进入redis</h3><p>当新数据进入redis时，如果内存不足怎么办？</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>通过<code>max-memory</code>配置设置淘汰策略<br>Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。</p><p><strong>怎么理解呢</strong>？主要看分三类看：</p><ul><li>不淘汰<ul><li>noeviction （v4.0后默认的）</li></ul></li><li>对设置了过期时间的数据中进行淘汰<ul><li>随机：volatile-random</li><li>ttl：volatile-ttl</li><li>lru：volatile-lru</li><li>lfu：volatile-lfu</li></ul></li><li>全部数据进行淘汰<ul><li>随机：allkeys-random</li><li>lru：allkeys-lru</li><li>lfu：allkeys-lfu</li></ul></li></ul><p>具体而言：</p><ol><li>noeviction<br>写满了就停止服务。</li><li>volatile-random<br>对会过期的键随机删除</li><li>volatile-ttl<br>对即将过期的时间进行排序，删除</li><li>volatile-lru(last-recently-used)<br>对最后使用时间进行排序，删除最后一次使用较早的数据</li><li>volatile-lfu（4.0后新增）<br>对使用次数进行排序，删除最少使用的数据</li><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ol><div class="note note-primary">            <p>淘汰策略 不是 过期清理策略，其不太关心键是否已经过期，只将是否设置了过期、过期时间作为筛选的范围。<br>volatile的挑选范围是<code>所有可能过期的数据</code>。<br>allkeys的挑选范围是<code>所有数据</code>。</p>          </div><h4 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h4><ul><li>redis每个数据都会记录最后访问的时间戳（redisObject的lru字段，24位时间戳）和最近使用次数（只有开启LFU时才记录，字段变成lfu，16位时间戳+8位访问次数）。</li><li>LRU淘汰时：<ul><li>随机选N个数据（可以通过maxmemory-samples设置）</li><li>排序lru字段</li><li>淘汰lru最小的数据</li></ul></li><li>LFU淘汰时：<ul><li>根据访问次数筛选（lru字段后8bit）</li><li>淘汰访问次数最低的数据（次数相同则比较最后使用时间，前16bit）</li></ul></li></ul><blockquote><p>8bit只能记录255次使用，到达后LFU会退化为LRU，因此有策略控制lfu的增长。</p></blockquote><p><code>lfu-log-factor</code>，有新访问时，只有满足一定算法条件时才count++<br><code>lfu-decay-time</code>，有新访问时，会按照算法对count进行衰减。</p><h2 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h2><p>一般流程：<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105015406.jpg"><br>缓存与数据库必然存在不一致情况：<br>1.先写数据库，再删除redis，后者的删除可能未执行<br>2.先删除redis，再写数据库，后者还未执行redis可能就又刷新了。</p><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p><strong>写后失效缓存</strong><br>读时：</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。<br>写时：</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><h4 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br>相比Cache Aside模式：<br>读时：</p><ul><li><strong>失效</strong>：都会查找数据库然后同步到缓存，但Read Pattern会先缓存再返回。<br>写时：</li><li><strong>更新</strong>：Write Pattern会先<strong>更新</strong>缓存再写数据库，最后返回。<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105020042.png"></li></ul><h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105023335.png"><br>性能高，但数据一致性弱，实现较复杂，要判断哪些需要持久化。</p><h3 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h3><h4 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h4><p>以Cache Aside Pattern为例：<br>读操作（失效时）：1.查找数据库 2.更新缓存<br>写操作：1.修改数据库 2.失效缓存</p><p>同步进行读、写时，若读写先后完成了对数据库的查询、修改，此时写操作先失效缓存导致读操作将旧信息更新到了缓存。<br>即 读1-&gt;写1-&gt;写2-&gt;读2</p><p>该事件这个概率较低，其只发生在读时失效且刚好有并发写操作，且写操作较慢且需要锁表，读操作一般肯定已经完成，所以这个概率会很低。当然最好还是为缓存设置过期时间。</p><h4 id="缓存更新失效"><a href="#缓存更新失效" class="headerlink" title="缓存更新失效"></a>缓存更新失效</h4><p>解决写操作第二步：失效缓存因为异常导致没有执行的问题</p><h5 id="方案1：队列-重试"><a href="#方案1：队列-重试" class="headerlink" title="方案1：队列+重试"></a>方案1：队列+重试</h5><p><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105024206.png"><br>优点：队列解决了缓存更新失败的问题<br>缺点：对代码的侵入量大，影响服务速度</p><p>方案2：队列+重试+非业务代码做异步更新缓存<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105181554.png"><br>由非业务代码读取mysql的操作，然后更新缓存。<br>优点：不侵入业务<br>缺点：同步速度慢<br>例子：canal</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第5章（高可用）</title>
    <link href="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <url>/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p></blockquote><p><strong>主从复制的作用</strong>主要包括：<br>性能上：</p><ul><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>读写分离</strong>：<ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。<br>稳定性上：</li></ul></li><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>1.从节点 发送指令replicaof ip port，主节点接受并响应<br>2.从节点 连接master的socket<br>3.从节点 发送指令auth password<br>4.主节点 验证授权<br>5.从节点 发送自身信息，主节点保存slave</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>全量复制</li><li>增量复制</li></ul><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104040638.jpg"><br><strong>第一阶段</strong>：主从库间建立连接、协商同步的过程。</p><ul><li>从节点发送psync命令，其应该包含主库的runId和offset，但这是初次复制，所以发送的runId&#x3D;?,offset&#x3D;-1。</li><li>主节点回复FULLRESYNC，并携带runId和offset，告诉从节点自身信息。<br><strong>第二阶段</strong>：主库将所有数据同步给从库。</li><li>主库执行bgsave，将其发送给RDB。</li><li>从库接受到RDB时，先清空数据库，再加载RDB。</li><li>主库在这一阶段会把新的写命令记录在repl buffer中。<br><strong>第三阶段</strong>：主库发送期间同步期间产生的新的写命令。<div class="note note-primary">            <p>注意这里的repl buffer，前面讲AOF持久化时，也有一个aof_buffer，用于记录<strong>重写</strong>时的新写入命令。</p>          </div></li></ul><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><blockquote><p>每次都全量复制的开销过大。</p></blockquote><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104041537.jpg"></p><p><code>repl_backlog_buffer</code>：环形缓冲区，用于记录写命令（会覆盖）。repl_baklog文件记录了命令偏移，<strong>主节点的offset</strong>和<strong>从节点的offset</strong>（但还是会以从节点ask发来的offset为准）。</p><p><code>replication buffer</code>：每个client连上Redis后，<strong>Redis都会分配一个client buffer</strong>，所有数据交互都是通过这个buffer进行的。Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。repl buffer的默认大小为1M。</p><h4 id="全量复制还是增量复制？"><a href="#全量复制还是增量复制？" class="headerlink" title="全量复制还是增量复制？"></a>全量复制还是增量复制？</h4><p>从库会记录自己的<code>slave_repl_offset</code>，恢复连接时，从库会通过<code>psync</code>发送自己的offset，主库根据这个offset判断进行增量还是全量复制。（如果<code>repl_backlog_buffer</code>的<code>slave_repl_offset</code>已经被覆盖，进全量复制）。</p><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741726.png"></p><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741728.png"></p><div class="note note-primary">            <p>主从节点都会发心跳，目的都有判断对方是否在线，此外从节点还会汇报自己的复制进度。</p>          </div><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741729.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741730.png"></p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="主服务器持久化与安全性"><a href="#主服务器持久化与安全性" class="headerlink" title="主服务器持久化与安全性"></a>主服务器持久化与安全性</h3><ul><li>主从复制时，主服务器强烈建议开启持久化。</li><li>若主节点没有开启持久化，又开启了自动重启，重启后主节点数据库为空，而从节点对其进行全量复制，会导致从节点数据也被删除。</li><li>所以，若主节点没有开启持久化，应该禁止自动重启。</li></ul><h3 id="为什么主从全量复制使用RDB而不使用AOF"><a href="#为什么主从全量复制使用RDB而不使用AOF" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF"></a>为什么主从全量复制使用RDB而不使用AOF</h3><ul><li>RDB文件很小，适合传输</li><li>RDB加载很快，适合恢复</li><li>AOF使用不当，会严重影响Redis性能</li></ul><h3 id="无磁盘复制模式"><a href="#无磁盘复制模式" class="headerlink" title="无磁盘复制模式"></a>无磁盘复制模式</h3><p>主服务器磁盘速度较低时，RDB会带来一些负担，<strong>无磁盘复制模式</strong>是指：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。<br>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><h3 id="从库的从库"><a href="#从库的从库" class="headerlink" title="从库的从库"></a>从库的从库</h3><p>对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。<br>通过“主 - 从 - 从”模式可以<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104045116.jpg"><br>后续的写同步也可以级联传播。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="延迟与不一致问题"><a href="#延迟与不一致问题" class="headerlink" title="延迟与不一致问题"></a>延迟与不一致问题</h4><p><strong>优化</strong>：优化网络环境、舍弃大延迟从节点，使用集群扩展读负载能力。</p><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><p>单机redis的删除策略</p><ul><li><strong>惰性删除</strong>：客户端查询数据时才判断是否过期，过期则删除</li><li><strong>定期删除</strong>：服务器定时任务删除过期数据<br>主从复制时，从节点不主动删除，而是由主节点控制从节点删除（保证数据一致性），但由于主节点不会立即删除过期数据，客户端在从节点上容易读到过期数据。<br><strong>解决</strong>：Redis3.2中，从节点也会判断数据过期。</li></ul><h4 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h4><p>主&#x2F;从节点发生故障时，要及时切换客户端的Redis连接。</p><ul><li>手动：响应慢，容易出错</li><li>监控程序：实现复杂<div class="note note-primary">            <p>使用哨兵即可解决这个问题。</p>          </div></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><blockquote><p>哨兵Redis Sentinel的核心功能是协助完成自动故障转移。</p></blockquote><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>监控：监听主从节点运作</li><li>自动故障转移：更改主节点</li><li>配置提供：向客户端提供节点信息</li><li>通知：通知客户端故障转移的结果</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="集群组建"><a href="#集群组建" class="headerlink" title="集群组建"></a>集群组建</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223227.jpg"></p><ul><li>主节点上有一个<code>_sentinel_:hello</code>频道，哨兵们通过该频道实现互相发现。</li><li>互相发现后哨兵之间建立连接。</li></ul><h3 id="监控Redis库"><a href="#监控Redis库" class="headerlink" title="监控Redis库"></a>监控Redis库</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223410.jpg"></p><ul><li>哨兵向主节点发送<code>INFO</code>命令，根据接受到的Slave列表与各从库建立连接</li></ul><h3 id="主库下线判断"><a href="#主库下线判断" class="headerlink" title="主库下线判断"></a>主库下线判断</h3><p>下线概念：</p><ul><li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223530.jpg"></li><li>哨兵判断主库下线后，向其他哨兵发送<code>is-master-down-by-addr</code>命令，其他哨兵作出Y或N响应。</li><li>如果赞成票大于配置项<code>quorum</code>，判定主库客观下线。</li></ul><h3 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h3><p>客观下线后，需要选举一个主哨兵执行最终调整命令</p><ul><li>选举算法：<ul><li>Raft选举算法： 选举的票数大于等于num(sentinels)&#x2F;2+1时，将成为领导者，如果没有超过，继续选举</li></ul></li><li>成为Leader的前提：<ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <code>quorum</code> 值。</li></ul></li></ul><div class="note note-primary">            <p>这里注意，判断客观下线需要得到大于<code>quorum</code>的赞成票，选举leader需要半数以上<strong>且</strong>大于<code>quorum</code>值的赞成票。<br>即，若有哨兵掉线导致无法超过半数，也无法实现Leader选举</p>          </div><h3 id="新主库选择"><a href="#新主库选择" class="headerlink" title="新主库选择"></a>新主库选择</h3><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><div class="note note-primary">            <p>先选活的，再选关系户，最后选有实力的，都没法就选runID小的。</p>          </div><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104224208.png"></p><ul><li>让新主库脱离原主库（replicaof no one）</li><li>让其他从库成为新主库的从节点</li><li>通知应用程序新redis主节点</li><li>原主库上线后变成新主节点的从节点</li></ul><h1 id="分片技术"><a href="#分片技术" class="headerlink" title="分片技术"></a>分片技术</h1><blockquote><p>主从复制解决了主节点崩溃的备份问题，并通过读写分离提高了性能。<br>哨兵机制解决了主节点崩溃时的崩溃转移问题。<br>但这都没有扩展Redis的写能力和存储能力，因此Redis引入了集群的功能。</p></blockquote><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="哈希槽-Hash-Slot"><a href="#哈希槽-Hash-Slot" class="headerlink" title="哈希槽(Hash Slot)"></a>哈希槽(Hash Slot)</h3><p>Redis-cluster没有使用一致性hash，而是引入了<strong>哈希槽</strong>的概念。Redis-cluster中有<strong>16384(即2的14次方)个哈希槽</strong>，每个key通过CRC16校验后对16383取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。</p><h3 id="Keys-hash-tags"><a href="#Keys-hash-tags" class="headerlink" title="Keys hash tags"></a>Keys hash tags</h3><p>Hash tags提供了一种途径，<strong>用来将多个(相关的)key分配到相同的hash slot中</strong>。这时Redis Cluster中实现multi-key操作的基础。<br>hash tag规则如下，如果满足如下规则，<code>&#123;</code>和<code>&#125;</code>之间的字符将用来计算HASH_SLOT，以保证这样的key保存在同一个slot中。</p><p>例如：hash(“{user1}.name”) &#x3D;&#x3D; hash(“{user1}.age”)</p><h3 id="Cluster-nodes属性"><a href="#Cluster-nodes属性" class="headerlink" title="Cluster nodes属性"></a>Cluster nodes属性</h3><p>每个<strong>节点在cluster中有一个唯一的名字</strong>。<br>这个名字由160bit随机十六进制数字表示，并在节点启动时第一次获得(通常通过&#x2F;dev&#x2F;urandom)。节点在配置文件中保留它的ID，并永远地使用这个ID，直到被管理员使用CLUSTER RESET HARD命令hard reset这个节点。<br>这样节点可以实现IP的变化而不影响其在集群中的定位。</p><p>每个节点维护集群内其他节点的以下信息：</p><ul><li><code>node id</code>，<code>节点的IP和port</code>，<code>节点标签</code>，<code>master node id</code>（如果这是一个slave节点）</li><li><code>最后被挂起的ping的发送时间</code>(如果没有挂起的ping则为0)，<code>最后一次收到pong的时间</code></li><li><code>当前的节点configuration epoch</code>（配置版本号） ，<code>链接状态</code>，以及该节点服务的<code>hash slots</code>。</li></ul><div class="note note-primary">            <p>即维护基本身份（node id,ip port,从属）,存活信息（ping pong），服务信息（版本号、连接、slots）</p>          </div><h3 id="Cluster总线"><a href="#Cluster总线" class="headerlink" title="Cluster总线"></a>Cluster总线</h3><p>每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接。</p><p>这个端口与用来接收client命令的普通TCP端口有一个固定的offset。如该端口等于普通命令端口加上10000.例如，一个Redis街道口在端口6379坚挺客户端连接，那么它的集群总线端口16379也会被打开。</p><blockquote><p>节点到节点的通讯只使用集群总线，同时使用集群总线协议：有不同的类型和大小的帧组成的二进制协议。</p></blockquote><h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点总是接受集群总线端口的链接，并且总是会回复ping请求，即使ping来自一个不可信节点。然而，如果发送节点被认为不是当前集群的一部分，所有其他包将被抛弃。</p><p>节点认定其他节点是当前集群的一部分有两种方式（阶段）：</p><ul><li>节点接受到一条meet消息，其会将meet消息的发送节点视为集群内节点。</li><li>节点接受到其信任的节点的gossip信息，其会将gossip信息中提到的新节点标记为集群内节点。</li></ul><h3 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h3><p>Redis Cluster是一张全网拓扑，节点与其他每个节点之间都保持着TCP连接。<br>节点之间使用gossip协议更新避免过多的消息交换。</p><div class="note note-danger">            <p>上面主要是cluster的主要模块，涉及到以下几个方面：</p><ul><li>分片：使用了<strong>哈希槽</strong>的方法对键进行分片，同时使用<strong>keys hash tags</strong>技术实现了定向的分片。</li><li>通讯：节点会开启<strong>cluster总线</strong>监听、返回消息，其会记录各个<strong>cluster nodes</strong>的基本信息。</li><li><strong>握手</strong>：节点监听到meet消息或信任节点的gossip消息会将目标节点加入到集群内。</li></ul>          </div><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><ul><li>检查当前key是否存在当前NODE？<ul><li>通过crc16（key）&#x2F;16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果</li><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？</li><li>若key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若Slot未迁出，检查Slot是否导入中？</li><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul><h4 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233215.png"></p><h4 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233422.png"></p><h4 id="SMART客户端"><a href="#SMART客户端" class="headerlink" title="SMART客户端"></a>SMART客户端</h4><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来<strong>减低复杂性，追求更好的性能</strong>。<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233615.png"></p><p>客户端通过cluster slots命令获取集群信息，依据其自主计算目标key所在的节点，直接对目标节点进行访问。</p><blockquote><p>失败时，进行随机访问节点、更新自身映射表并重新访问，若失败过多则放弃。</p></blockquote><div class="note note-warning">            <p>简而言之，客户端请求后，节点判断是否由自己处理，不由自己处理则MOVED，由自己处理但发现slot已经迁移则ASK。<br>SMART客户端则自身计算slots的工作，映射失效时则随机访问节点刷新映射。</p>          </div><h3 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h3><p>Cluster中的每个节点都维护一份在自己看来当前整个集群的状态，主要包括：</p><ul><li>当前集群状态</li><li>集群中各节点所负责的slots信息，及其migrate状态</li><li>集群中各节点的master-slave状态</li><li>集群中各节点的存活状态及不可达投票</li></ul><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>gossip 协议（gossip protocol）又称 epidemic 协议（epidemic protocol）是一种P2P2协议，Gossip协议的最大的好处是，<strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许Consul管理的集群规模能横向扩展到数千个节点</strong>。</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><code>Meet</code> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><code>Ping</code> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><code>Pong</code> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><code>Fail</code> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><div class="note note-primary">            <p>meet用于新增节点，ping&#x2F;pong维护，fail用于下线节点</p>          </div><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>在某节点看来，其他节点的状态有<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p><ul><li>节点A发现某节点B下线时，将其标记为PFAIL，并通知附近节点C。</li><li>节点C接受到消息后，确认真假，将该状态记录并继续传播PFAIL消息。</li><li>最后节点判断其是否客观下线（<strong>自己认为</strong> 且 <strong>发现过半节点认为其疑似下线PFIAL</strong>），若客观下线，其会发送FAIL消息让所有节点接受节点A客观下线。</li></ul><h3 id="通讯维护"><a href="#通讯维护" class="headerlink" title="通讯维护"></a>通讯维护</h3><h4 id="什么时候进行心跳？"><a href="#什么时候进行心跳？" class="headerlink" title="什么时候进行心跳？"></a>什么时候进行心跳？</h4><p>Redis节点会记录其向每一个节点上一次发出ping和收到pong的时间，心跳发送时机与这两个值有关。通过下面的方式既能保证及时更新集群状态，又不至于使心跳数过多：</p><ul><li>每次Cron向所有未建立链接的节点发送ping或meet</li><li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li><li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li><li>收到ping或meet，立即回复pong</li></ul><h4 id="发送哪些心跳数据？"><a href="#发送哪些心跳数据？" class="headerlink" title="发送哪些心跳数据？"></a>发送哪些心跳数据？</h4><ul><li>Header，发送者自己的信息<ul><li>所负责slots的信息</li><li>主从信息</li><li>ip port信息</li><li>状态信息</li></ul></li><li>Gossip，发送者所了解的部分其他节点的信息<ul><li>ping_sent, pong_received</li><li>ip, port信息</li><li>状态信息，比如发送者认为该节点已经不可达，会在状态信息中标记其为PFAIL或FAIL</li></ul></li></ul><h4 id="如何处理心跳？"><a href="#如何处理心跳？" class="headerlink" title="如何处理心跳？"></a>如何处理心跳？</h4><h5 id="新节点加入"><a href="#新节点加入" class="headerlink" title="新节点加入"></a>新节点加入</h5><ul><li>发送meet包加入集群</li><li>从pong包中的gossip得到未知的其他节点</li><li>循环上述过程，直到最终加入集群<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104235107.png"></li></ul><h5 id="Slots消息"><a href="#Slots消息" class="headerlink" title="Slots消息"></a>Slots消息</h5><ul><li>判断发送者声明的slots信息，跟本地记录的是否有不同</li><li>如果不同，且发送者epoch较大，更新本地记录</li><li>如果不同，且发送者epoch小，发送Update信息通知发送者</li></ul><h5 id="Master-slave信息"><a href="#Master-slave信息" class="headerlink" title="Master slave信息"></a>Master slave信息</h5><p>发现发送者的master、slave信息变化，更新本地状态</p><h5 id="节点Fail探测-故障发现"><a href="#节点Fail探测-故障发现" class="headerlink" title="节点Fail探测(故障发现)"></a>节点Fail探测(故障发现)</h5><p>超时没有收到某节点pong包，标记其PFAIL，并在pong时传播这个标记。</p><blockquote><p>注：Gossip的存在使得集群状态的改变可以更快的达到整个集群。每个心跳包中会包含多个Gossip包，那么多少个才是合适的呢，redis的选择是N&#x2F;10，其中N是节点数，这样可以保证在PFAIL投票的过期时间内，节点可以收到80%机器关于失败节点的gossip，从而使其顺利进入FAIL状态。</p></blockquote><h3 id="故障恢复（Failover）"><a href="#故障恢复（Failover）" class="headerlink" title="故障恢复（Failover）"></a>故障恢复（Failover）</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>通过某个slave执行cluster failover命令，手动让某个master宕机，并将本slave作为master节点。<br>此时命令还包括一些流程处理，如校验offset，查看master状态和询问其他master意见等。</p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave。Failover的过程需要经过类Raft协议的过程在整个集群内达到一致，其过程如下：</p><ul><li>slave发现自己的master变为FAIL</li><li>将自己记录的集群currentEpoch加1，并广播Failover Request信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新Master</li><li>广播Pong通知其他集群节点<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230105001028.png"></li></ul><h3 id="扩容-amp-缩容"><a href="#扩容-amp-缩容" class="headerlink" title="扩容&amp;缩容"></a>扩容&amp;缩容</h3><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ol><li>首先将新节点加入到集群中，可以通过在集群中任何一个客户端执行cluster meet 新节点ip:端口，或者通过redis-trib add node添加，新添加的节点默认在集群中都是主节点。</li><li>迁移数据 迁移数据的大致流程是，首先需要确定哪些槽需要被迁移到目标节点，然后获取槽中key，将槽中的key全部迁移到目标节点，然后向集群所有主节点广播槽（数据）全部迁移到了目标节点。</li></ol><h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>缩容的大致过程与扩容一致，需要判断下线的节点是否是主节点，以及主节点上是否有槽，若主节点上有槽，需要将槽迁移到集群中其他主节点，槽迁移完成之后，需要向其他节点广播该节点准备下线（cluster forget nodeId）。最后需要将该下线主节点的从节点指向其他主节点，当然最好是先将从节点下线。</p><h2 id="更深入理解"><a href="#更深入理解" class="headerlink" title="更深入理解"></a>更深入理解</h2><h3 id="为什么Redis-Cluster的Hash-Slot是16384？"><a href="#为什么Redis-Cluster的Hash-Slot是16384？" class="headerlink" title="为什么Redis Cluster的Hash Slot是16384？"></a>为什么Redis Cluster的Hash Slot是16384？</h3><p>我们知道一致性hash算法是2的16次方（65535），为什么hash slot是2的14次方（16384）呢？</p><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，使用bitmap压缩，16384bit &#x3D; 16kb &#x3D; 2kB，也就是说使用2kB的空间创建了16k的槽数。如果使用CRC16分配65535个槽位，需要使用8kB才行，作者认为没有必要。</p><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢？"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢？" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢？"></a>为什么Redis Cluster中不建议使用发布订阅呢？</h3><p>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会<strong>严重消耗带宽</strong>，不建议使用。（虽然官网上讲有时候可以使用Bloom过滤器或其他算法进行优化的。</p><p>todo:对比哨兵和集群的交流，维护机制<br>通讯维护部分详细化。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第4章（事件与事物）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>所谓事件机制，指的是Redis 接受客户端的请求并响应（文件事件） 和 执行定时任务（时间事件） 的机制。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><div class="note note-primary">            <p>文件事件指交互性事件，时间事件指定时类执行事件。</p>          </div><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104015729.png"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p><p>Redis 是单线程主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>。采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。</p><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020000.png"></p><div class="note note-primary">            <p>这里还没学，暂时理解为netty、ae_event(Redis使用的)等是异步处理IO复用的应用框架，底层的实现库是与操作系统的具体实现有关。</p>          </div><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020123.png"><br>I&#x2F;O多路复用程序监听多个套接字（客户端），当需要套接字IO时，产生一个文件事件，Redis将这些就绪的文件事件放在一个队列中（fired就绪事件表），然后文件事件处理器会有序、同步、单个的执行一个个文件事件。</p><p>某客户端请求流程如下：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020550.png"></p><h3 id="Redis-IO多路复用模型"><a href="#Redis-IO多路复用模型" class="headerlink" title="Redis IO多路复用模型"></a>Redis IO多路复用模型</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020629.jpg"></p><div class="note note-primary">            <p>这里理解为epoll是一个操作系统内核机制，其监听了3个FD（套接字），当发生事件时，事件入列，然后逐个出列调用函数。</p>          </div><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis 的时间事件分为以下两类：</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：也就是说时间处理器处理某个事件后，判断其需不需要过一段时间再次执行。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104022102.png"><br>所有事件时间放在一个无序链表中，时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件并调用相应事件处理器。</p><blockquote><p>一般Redis服务器只使用serverCron一个时间事件，这个事件用于更新服务器各类统计数据，清理键值，整理客户端连接，尝试AOF或RDB，同步数据，心跳检测等。总之，Redis会周期性的执行这个函数。</p></blockquote><h2 id="aeEventLoop实现"><a href="#aeEventLoop实现" class="headerlink" title="aeEventLoop实现"></a>aeEventLoop实现</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。具体过程是其会调用aeCreateEventLoop函数：</p><ul><li>创建该aeEventLoop对象。</li><li>初始化文件事件表内容</li><li>初始化时间事件表</li><li>调用aeApiCreate函数创建epoll实例，初始化apidata<br>具体实现不细看了，逻辑图如下<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104024156.png"></li></ul><h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li><code>MULTI</code> ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li><code>EXEC</code>：执行事务中的所有操作命令。</li><li><code>DISCARD</code>：取消事务，放弃执行事务块中的所有命令。</li><li><code>WATCH</code>：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li><code>UNWATCH</code>：取消WATCH对所有key的监视。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>语法错误：若存在语法错误，整个事务不会被执行。</li><li>类型错误：若在执行时发送Redis类型错误，该条命令失败，但其他命令正常执行。</li></ul><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p>WATCH命令为Redis事务提供了CAS的行为：<br>当执行了WATCH命令监视某键后，在执行时发现与WATCH时相比，键值发生了变化，则回滚事务。最后会取消监控。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025042.png"></p><h3 id="事物执行步骤"><a href="#事物执行步骤" class="headerlink" title="事物执行步骤"></a>事物执行步骤</h3><ul><li>MULTI开始</li><li>入队</li><li>执行<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025058.png"></li></ul><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>redis悲观锁又称为分布式锁，主要是为了防止数据被其他客户改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>通过以上命令可以设置分布式锁(key&#x3D;lock-key)：</p><ul><li>若设置成功，会返回值，拥有控制权。</li><li>若设置失败，无返回值，需要排队等待。<br>期间其他客户无法操作lock-key。<br>操作完毕后通过<strong>del操作释放锁</strong>。</li></ul><h3 id="分布式锁改良"><a href="#分布式锁改良" class="headerlink" title="分布式锁改良"></a>分布式锁改良</h3><p>使用expire为lock-key设置过期时间，防止忘记或程序中断导致忘记释放锁</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="Redis不支持回滚？"><a href="#Redis不支持回滚？" class="headerlink" title="Redis不支持回滚？"></a>Redis不支持回滚？</h3><p>redis只会因语法错误（主要指类型错误这种无法提前检测的命令）而失败，这个错误是在编程时应该避免的。</p><h3 id="ACID？"><a href="#ACID？" class="headerlink" title="ACID？"></a>ACID？</h3><ul><li>原子性<em>atomicity</em><br>有观点认为Redis没有原子性，因为其不支持运行期回滚，但Redis官方的理解如下：<br><strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。</strong>这个过程并不保证执行成功。</li><li>一致性<em>consistency</em><br>Redis能保证命令失败的情况下回滚（普通语法错误、WATCH锁），能保证一致性。</li><li>隔离性<em>Isolation</em><br><strong>单线程</strong>的本质保证了隔离性（不会被其他客户端打断）</li><li>持久性<em>Durability</em><br><strong>redis事务是不保证持久性的</strong>，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</li></ul><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><ul><li><strong>基于Lua脚本</strong>，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li><strong>基于中间标记变量</strong>，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h1 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h1><blockquote><p>删除作为一个redis事件，也放在本章一起阐述。</p></blockquote><p>使用<code>TTL</code>可以查看键的生命状态：</p><ul><li>xx为时效数据</li><li>1为永久有效数据</li><li>2为已经过期或不存在的数据</li></ul><h2 id="常见的删除策略"><a href="#常见的删除策略" class="headerlink" title="常见的删除策略"></a>常见的删除策略</h2><ol><li>定时删除：定时任务，到时即删除</li><li>惰性删除：访问时删除，调用expireIfNeeded函数</li><li>定期删除：定期清理，serverCron()中会执行删除。</li></ol><div class="note note-success">            <p>redis使用的是<strong>惰性删除</strong>和<strong>定期删除</strong></p>          </div><div class="note note-primary">            <p>对于RDB，其不会记录已经删除的键<br>对于AOF，键过期后会在文件后面加上DEL key的命令。</p>          </div><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105004950.png"></p><p>这个格式不是redisObject的格式，而是redis数据库的一个格式。<br>redisDB结构中expires保存了所有的键过期信息。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105010244.png"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第3章（持久化）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="持久化：RDB和AOF机制详解"><a href="#持久化：RDB和AOF机制详解" class="headerlink" title="持久化：RDB和AOF机制详解"></a>持久化：RDB和AOF机制详解</h2><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(<em>Redis DataBase</em>)持久化</h3><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><blockquote><p><strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><code>save</code>命令：由主线程执行，会造成长时间阻塞。</li><li><code>bgsave</code>命令：fork子线程执行，阻塞只发生在fork阶段。</li></ul><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103211303.png"></p><p>具体流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，<strong>那么主进程直接返回</strong>；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子<strong>替换</strong>旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_相关选项）。</li></ul><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>由以下4种触发情况</p><ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul><p><strong>相关配置</strong><br><code>stop-writes-on-bgsave-error</code>：bgsave错误时暂停主线程，主要目的是让运维人员排查问题<br><code>rdbcompression</code>：启用LZF压缩算法<br><code>rdbchecksum</code>：64位CRC冗余校验编码，可以验证RDB的完整性。</p><h4 id="深入RDB"><a href="#深入RDB" class="headerlink" title="深入RDB"></a>深入RDB</h4><ul><li><p><strong>并发问题？</strong><br><a href="https://zhuanlan.zhihu.com/p/339437815#:~:text=%20Redis%E4%B8%AD%E6%89%A7%E8%A1%8CBGSAVE%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90RDB%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E8%B0%83%E7%94%A8Linux%E4%B8%AD%E7%9A%84fork%20%28%29%E5%91%BD%E4%BB%A4%EF%BC%8CLinux%E4%B8%8B%E7%9A%84fork,%28%29%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%BA%86copy-on-write%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9B%20fork%20%28%29%E4%B9%8B%E5%90%8E%EF%BC%8Ckernel%E6%8A%8A%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E6%9D%83%E9%99%90%E9%83%BD%E8%AE%BE%E4%B8%BAread-only%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%8C%87%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%82%20%E5%BD%93%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%83%BD%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E3%80%82">Copy-on-Write</a><br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103215527.jpg"><br>如果主线程需要进行写操作，则将写操作部分的数据块复制，对新的副本进行修改，这样保证了bgsave子进程可见的数据的一致性（即bgsave开始时的快照）</p></li><li><p><strong>若服务崩溃怎么办？</strong><br>bgsave的temp文件在生成之前不会覆盖旧的dump。</p></li><li><p><strong>能否尽可能快的RDB</strong>?<br>快照过快会导致fork大量阻塞主线程，且磁盘空间是有限的。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li><strong>LZF压缩算法，文件体积远小于内存</strong></li><li>加载速度比AOF快</li></ul></li><li>缺点<ul><li><strong>实时性不够</strong></li><li><strong>开销大</strong></li><li>版本兼容</li><li>RDB文件无法手动修改</li></ul></li></ul><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append only file)持久化"></a>AOF(<em>append only file</em>)持久化</h3><p>执行写命令时，<strong>先写内存，后写日志</strong>。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220350.jpg"></p><blockquote><p>目的：</p><ol><li>避免额外检查，执行成功才写日志</li><li>不阻塞当前写操作<br>风险：</li><li>完成写内存后中断，日志缺失</li><li>主线程写磁盘压力过大</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220620.jpg"></li><li><strong>AOF重写</strong> Redis通过创建一个新的AOF文件来替换现有的AOF。</li></ul><div class="note note-primary">            <p>aof_buf缓存写命令，触发写回时将aof_buf中命令一次写入磁盘</p>          </div><p><strong>相关配置</strong><br><code>appendfsync</code>：主要用于设置“真正执行”操作命令向AOF文件中同步的策略，支持always、everysec、no，默认为everysec。<br><code>no-appendfsync-on-rewrite</code>：<strong>重写</strong>时不再记录新命令<br><code>auto-aof-rewrite-percentage</code>：当前AOF文件超过上次重写AOF文件大小的百分之多少后开始重写。<br><code>auto-aof-rewrite-min-size</code>：当前AOF文件超过设置大小时开始重写</p><h4 id="深入AOF重写"><a href="#深入AOF重写" class="headerlink" title="深入AOF重写"></a>深入AOF重写</h4><ul><li><strong>AOF重写会阻塞吗</strong>？<br>重写时会fork主线程，由后台进程bgrewriteaof完成，fork时会阻塞主线程。</li><li><strong>何时重写</strong>？<br>auto-aof-rewrite-percentage和auto-aof-rewrite-min-size</li><li><strong>并发问题</strong>？<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103221653.jpg"><br>重写时:</li><li>redis原始数据会通过copy on write机制拷贝</li><li>服务器写入新数据时，会将新数据同时写入两个aof_buf缓存区（当持久化策略为always时，则是写入磁盘和一个aof_buf缓冲），<strong>子线程</strong>完成重写后通知主线程，<strong>主线程</strong>会把aof重写缓冲区的命令追加到aof文件中。最后文件改名，保证原子性。</li></ul><blockquote><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会<strong>拷贝父进程的页表</strong>，即<strong>虚实映射关系</strong>（虚拟内存和物理内存的映射索引表），而<strong>不会拷贝物理内存</strong>。这个拷贝会消耗大量cpu资源，并且<strong>拷贝完成前会阻塞主线程</strong>，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p></blockquote><ul><li><p><strong>重写时有哪些阻塞</strong>？</p><ul><li>fork</li><li>主线程bigkey写入，操作系统需要创建页面副本并拷贝原有数据。</li><li>主线程追加写入aof</li></ul></li><li><p><strong>为什么AOF不复用原AOF文件</strong>？</p><ul><li>父子同时写一个文件产生竞争，影响父进程性能</li><li>若重写失败会造成污染</li></ul></li></ul><h3 id="RDB和AOF混合方式"><a href="#RDB和AOF混合方式" class="headerlink" title="RDB和AOF混合方式"></a>RDB和AOF混合方式</h3><p>在Redis4.0提出，简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志<strong>记录这期间</strong>的所有命令操作。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222843.jpg"></p><ul><li>RDB不用过快执行，同时AOF也不会过大</li></ul><h3 id="持久化恢复"><a href="#持久化恢复" class="headerlink" title="持久化恢复"></a>持久化恢复</h3><p>重启redis即可恢复<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222858.png"><br>AOF优先级更高，因为其数据更完整。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第2章（对象机制）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><blockquote><p>前面介绍了Redis的基本数据类型，针对这些数据类型有着不同的底层实现。</p></blockquote><p>对象模型：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190013.png"></p><blockquote><p>Redis对象有不同的数据类型，而一个数据类型可能有多种实现方式（编码类型），根据value的情况灵活变化。<br>编码类型作为一种类型标识，告诉了Redis应该如何解析这个对象，不同编码类型也有不同的底层数据结构实现。</p></blockquote><p>Redis对象机制作用：<br><strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.<br><strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><h1 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190705.png"></p><ul><li>type标识了数据所属的基本类型</li><li>encoding标识了数据类型对于的编码</li><li>LRU记录了数据的最后访问时间和访问次数</li><li>refcount记录了对象被引计数</li><li>ptr指向真实的底层数据结构</li></ul><div class="note note-primary">            <p>redisObject保存了Redis服务器需要维护的对象信息，包括数据结构类型和编码（用于多态解析），LRU（LFU）和refcount（淘汰机制），ptr指向底层数据结构。</p>          </div><h2 id="命令检查与多态"><a href="#命令检查与多态" class="headerlink" title="命令检查与多态"></a>命令检查与多态</h2><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103191229.png"></p><div class="note note-success">            <p>type判断命令是否正确，encoding判断如何执行命令</p>          </div><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>redis一般会把一些常见值放入共享对象中：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192218.png"><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。<br>像整数集合和压缩列表这些将数据保存在数据结构内的则无法使用。</p></blockquote></li></ul><blockquote><p>为什么不共享其他数据结构：<br>复杂度较高，消耗CPU，用其换取内存不划算。</p></blockquote><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h1 id="底层数据对象"><a href="#底层数据对象" class="headerlink" title="底层数据对象"></a>底层数据对象</h1><h2 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h2><p><strong>简单动态字符串（simple dynamic string,SDS</strong>）的存在是为了尽可能的节省存储可见，只为对象分配其需要的空间大小。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192512.png"></p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的<strong>头部</strong>, 分别如下:<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192821.png"><br>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的<code>\0</code>, 剩余的字节数。</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><div class="note note-primary">            <p>实际SDS的长度为 头部+alloc+尾部。<br>len为<code>buf[]</code>中的有效长度，即有效字符串长度。</p>          </div><h3 id="为何使用SDS"><a href="#为何使用SDS" class="headerlink" title="为何使用SDS"></a>为何使用SDS</h3><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li></ul><blockquote><p>在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p></blockquote><h2 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h2><p>ziplist是一个特殊编码的双向列表，其可以存储字符串或整数，操作的时间复杂度为O(1)，每次操作都需要重新分配ziplist的内存。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103194043.png"></p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p>一般</p><ul><li><code>prevlen</code>：前一个entry的大小</li><li><code>encoding</code>：表示当前entry类型和长度</li><li><code>entry-data</code>:存储entry标识的数据<br>特殊<br>类型为int时，<code>encoding</code>和<code>entry-data</code>合并在一起表示，没有<code>entry-data</code>。</li></ul><p><strong>prevlen</strong><br>前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度。<br>如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><p><strong>encoding编码</strong><br>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；<br>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><h3 id="为什么ZipList省内存"><a href="#为什么ZipList省内存" class="headerlink" title="为什么ZipList省内存"></a>为什么ZipList省内存</h3><p>根据数据类型灵活变化编码规则，使用encoding标识entry类型和大小，是。<br>因为是双端列表，为了解决遍历问题，使用prevlen字段方便倒序遍历。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不预留空间，每次写操作都需要重新分配内存。<br>节点扩容可能导致后续所有prevlen字段扩容。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>是一个以ziplist为节点的双端链表结构。</p><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下</li></ul><h3 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103200220.png"></p><ul><li><p><code>quicklist.fill</code>影响ziplist的长度，数值为负数时限制ziplist最大长度，为正数时限制ziplist的entry数量。</p></li><li><p><code>quicklist.compress</code>影响zl字段指向的对象的类型，0标识指向ziplist，1表示链表的头尾节点不压缩，2标识头尾各2各节点不压缩，其他为压缩后的quicklistLZF。</p></li><li><p><code>quicklistNode.encoding</code>，标识本链表节点是否压缩，1表示没压缩，2表示压缩了。</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压。如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><h2 id="字典-x2F-哈系表-Dict"><a href="#字典-x2F-哈系表-Dict" class="headerlink" title="字典&#x2F;哈系表 - Dict"></a>字典&#x2F;哈系表 - Dict</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103201159.png"></p><h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul><li>哈希算法：使用hash函数计算key的哈希值，使用sizemask与第一步得到的hash值，计算索引。</li><li>哈希冲突：链地址法</li><li>扩容&#x2F;缩容：<ul><li>rehash，扩展时创建两倍大小的hash表，缩小时则创建缩小一倍的新哈希表。</li><li>重新计算索引</li><li>迁移所有键值对，然后释放内存</li></ul></li><li>扩容条件：<ol><li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</li><li>ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</li></ol></li><li>渐进式rehash<br>  分多次完成rehash迁移，此时查找会在新旧两个哈希表上找，但是新增只会在新哈希表上新增。</li></ul><h2 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202006.png"></p><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><div class="note note-primary">            <p>可见intset就是一个排序的数组。</p>          </div><p>contents中每个元素的数据类型由encoding决定，当有数字的值超出范围时，集合需要升级，其会：</p><ul><li>扩展整数集合底层数组的可见大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上。（需要继续维持底层数组的有序性质不变）。</li><li>最后改变encoding的值，length+1。</li></ul><p>但intset不会降级，这是没必要的开销。</p><h2 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h2><p>跳表在redis中只用在zset数据类型中，其保证查找删除添加等操作在对数的期望时间内完成。</p><p>原理示例：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202637.png"></p><p>内存布局：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202658.png"></p><p><strong>zskiplist的核心设计要点</strong></p><ul><li><strong>头节点</strong>不持有任何数据, 且其<code>level[]</code>的长度为32。</li><li><strong>每个结点</strong><ul><li><code>ele</code>字段，持有数据，是sds类型</li><li><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li><code>level</code>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段<ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在<code>level[]</code>中的索引为X, 则其forward字段指向的结点, 其<code>level[]</code>字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1</li></ul></li></ul></li></ul><h3 id="为什么不用平衡树或者哈希表"><a href="#为什么不用平衡树或者哈希表" class="headerlink" title="为什么不用平衡树或者哈希表"></a>为什么不用平衡树或者哈希表</h3><p>hash无序，无法进行范围查找，平衡数的范围搜索也很复杂，子树的调整也很复杂。</p><h1 id="redis对象与编码-底层结构-对应关系"><a href="#redis对象与编码-底层结构-对应关系" class="headerlink" title="redis对象与编码(底层结构)对应关系"></a>redis对象与编码(底层结构)对应关系</h1><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203244.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串长度不能超过512M。</strong></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li><code>int 编码</code>：保存的是可以用 long 类型表示的整数值。</li><li><code>embstr 编码</code>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><code>raw 编码</code>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203355.png"><br>embstr少一次分配空间，但其为只读,修改时要重新分配一次raw空间。</p><p>ps:<strong>Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型</strong>。</p><ul><li><strong>编码的转换</strong><blockquote><p>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。<br>对于embstr编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p></blockquote></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>按<strong>数值进行操作的数据</strong>，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>quicklist</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203823.png"></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h3><p>ziplist和hashtable</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><ul><li>ziplist</li><li>dict<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204020.png"></li></ul><p>使用ziplist时，新的键值对作为entry插入list尾部。<br>使用hashtable编码时，使用dict。</p><p><strong>编码转换</strong><br>和上面列表对象使用 ziplist 编码一样，当<strong>同时满足下面两个条件</strong>时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节<br>不能满足这两个条件的时候使用 hashtable 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>hash类型下的value只能存储字符串</li><li>每个hash可以存储2^32-1个键值对</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="编码-3"><a href="#编码-3" class="headerlink" title="编码"></a>编码</h3><p>intset或hashtable</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204842.png"></p><p><strong>编码转换</strong><br>当集合同时满足以下两个条件时，使用intset编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512<br>不能满足这两个条件的就使用hashtable编码。第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="编码-4"><a href="#编码-4" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 skiplist(ziplist+dict)</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p>ziplist<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205150.png"></p><p>skiplist(ziplist+dict)<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205236.png"><br>字典可以快速查找成员，但无序，跳表可以快速执行范围查找，将两者结合共同实现有序集合。</p><p><strong>编码转换</strong><br>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。<br>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第1章（数据类型与结构）</title>
    <link href="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <url>/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis知识体系"><a href="#一、Redis知识体系" class="headerlink" title="一、Redis知识体系"></a>一、Redis知识体系</h1><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230191017.png"></p><h1 id="二、Redis概念与基础"><a href="#二、Redis概念与基础" class="headerlink" title="二、Redis概念与基础"></a>二、Redis概念与基础</h1><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。</li><li>数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>持久化：AOF&#x2F;RDB</li><li>发布订阅：Subscribe</li><li>分布式：RedisCluster</li><li>redis为每个服务提供有16个数据库，编号从0到15，默认为0号数据库</li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>热点数据的缓存</li><li>限时任务的运用</li><li>计数器</li><li>分布式锁</li><li>延时操作</li><li>排行榜</li><li>点赞</li></ul><h1 id="三、Redis基础数据类型"><a href="#三、Redis基础数据类型" class="headerlink" title="三、Redis基础数据类型"></a>三、Redis基础数据类型</h1><blockquote><p>Redis所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p></blockquote><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230200246.jpg"></p><div class="note note-primary">            <p><strong>String</strong>也可以是整数和浮点数，支持自增和自减操作。<br><strong>Zset</strong>说是set，实际上结构类似hash，其保存了<strong>字符串成员</strong>和<strong>浮点分数</strong>之间的映射关系。</p>          </div><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>GET,SET,INCR,DECR,INCRBY,DECRBY</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>缓存常用信息，计数器，session.</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis用双端链表实现List。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>LPUSH,LPOP,<strong>LRANGE</strong>(获取范围内元素),LINDEX(获取索引元素)</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>时间轴微博，消息队列（按照时间先后排序的场景）</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序集合，成员唯一。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p>SADD,<strong>SCARD</strong>(获取成员数),SMEMERS(返回所有成员),SISMEMBER(判断是否为成员)</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>文章标签，不需要时间排序的点赞、收藏等。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>field -&gt; value，适合存储对象</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><p>HSET,HGET,HGETALL,HDEL</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>缓存查询信息，适合存储结构体。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>成员唯一。通过了压缩列表和跳跃表两种数据结构实现。<br>压缩列表：提高了存储效率，特殊编码的双向链表。<br>跳跃表：快速查找，删除，添加（对数时间内）</p><div class="note note-primary">            <p>操作时按照跳跃表找到指定位置对数据进行修改，存储时以压缩列表形式存储。</p>          </div><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>ZADD,ZRANGE,ZREM</p><h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>排行榜</p><h1 id="四、Redis特殊类型结构"><a href="#四、Redis特殊类型结构" class="headerlink" title="四、Redis特殊类型结构"></a>四、Redis特殊类型结构</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构</p></blockquote><p>基数统计，可以理解为高性能的set，但精确度有限（0.81% 标准误差）。<br>基数指的是set中每一个不重复的元素，其可以解决海量数据统计的问题，其优势在于存储消耗的空间很小。</p><h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfadd key1 a b c  #创建第一组元素<br>pfcount key1 #统计元素个数<br>pfmerge key3 key1 key2 #合并key1,key2到key3<br></code></pre></td></tr></table></figure><h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><p>每日访问IP数，在线用户数等</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>位存储，使用位记录 0，1两个状态。</p><h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">setbit key 0 1  #设置第0位为1<br>getbit key 0 #获取第0位<br>bitcount key #求1的数量<br></code></pre></td></tr></table></figure><h3 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h3><p>记录每条的打卡情况</p><h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了!</p></blockquote><h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">geoadd china:city(相当于key) 118 32 beijing(相当于value对象)#即可以为一个区域添加多个点<br>geopos china:city beijing<br>geodist china:city beijing shenyang m #以M为单位求两地距离<br>georadius china:city 110 30 1000 km #求中国城市中，以110，30为中心，1000km为半径范围内所有城市。<br>geohash china:city beijing #较少使用,返回hash字符串<br></code></pre></td></tr></table></figure><h3 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h3><p>附近的人code</p><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>底层实现是Zset，其将经纬度转换为一个分数保存在其中。</p><h1 id="五、消息队列Steam"><a href="#五、消息队列Steam" class="headerlink" title="五、消息队列Steam"></a>五、消息队列Steam</h1><p>借鉴了Kafka，是一种消息队列的实现。</p><blockquote><p>Redis的消息队列实现很多：</p><ul><li>Pub&#x2F;Sub，缺点：丢失的消息无法持久化。</li><li>List，缺点：不支持多播，持久化。</li></ul></blockquote><p>消息队列设计<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230213704.png"></p><h2 id="Stream结构"><a href="#Stream结构" class="headerlink" title="Stream结构"></a>Stream结构</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230214054.png"></p><ul><li><code>Stream</code>：一种数据结构，每个Stream有一个唯一的名称，也就是key。</li><li><code>Comsumer Group</code>消费组：一个消费组有多个消费者，他们之间是<strong>竞争关系</strong></li><li><code>pending_ids</code>消费者状态变量：维护了消费者尚未确认的id。</li></ul><div class="note note-primary">            <p>对于每一条消息都要确保其被消费，或者确定这是一个投递不出去的坏消息（死信）。所以需要对<strong>每个消费者</strong>维护一个<strong>pending_ids</strong>，表示这个消息已经交给它处理，但它还没有完成对该消息的确认（ack）。</p><p>而对于<strong>每个消费组</strong>，则需要一个指针维护其最后一次读取到的消息id（<strong>Last_dilivered_id</strong>）。</p>          </div><p>另外，每个消息都有独一无二的ID，默认为时间戳，格式为1527846880572-5，当毫秒不够用时，使用<code>-</code>后面的数标注该消息是本毫秒的第几个消息。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>即不使用消费组的情况下进行消费。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xread count 2 streams key 0-0 #读取两条消息<br>xread block 0 count 1 streams key $ #阻塞读取队列最后的消息<br></code></pre></td></tr></table></figure><p>block 0表示永远阻塞，直到消息到，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil。</p><blockquote><p>独立消费不会自动维护last_read指针，需要用户自己记住最后消息ID，下次将其作为参数传递即可继续消费。</p></blockquote><h2 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230231440.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为”已处理”</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息<br>具体使用见<a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html">消费组命令使用</a></li></ul><p>xreadgroup也可以阻塞等待，读取后，消息进入消费者的pending_ids，当消费者回复xack时，将这个消息从其pending_ids消除。</p><div class="note note-primary">            <p>消费时，需要传入流名称、消费组名称、消费者名称3个参数。<br>ACK时，需要传入流名称、消费组名称、消息id。<br>可见回复时，不需要具体定位到消费者，因为redis本身就知道某个消息id属于消费组中的哪个消费者。</p>          </div><h2 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h2><p><code>Xinfo</code>命令可以查看stream的基本信息，如：</p><ul><li>XINFO STREAM keyName</li><li>XINFO GROUPS keyName</li><li>XINFO CONSUMERS keyName groupName</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>实时通讯、大数据分析、异地数据备份。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个<strong>64位整型</strong>（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>Redis生成的ID是单调递增有序的。若服务器时间错误，Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号）。</p><h3 id="消费者崩溃带来的会不会消息丢失问题"><a href="#消费者崩溃带来的会不会消息丢失问题" class="headerlink" title="消费者崩溃带来的会不会消息丢失问题?"></a>消费者崩溃带来的会不会消息丢失问题?</h3><p>Pending列表可以记录已读取但未ack的消息。<br>命令<code>XPENDIING</code>用来获消费组或消费内消费者的未处理完毕的消息。</p><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>其保证消费者恢复时，可重新从pending列表中取消息处理。</p><h3 id="消费者彻底宕机后如何转移给其它消费者处理？"><a href="#消费者彻底宕机后如何转移给其它消费者处理？" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理？"></a>消费者彻底宕机后如何转移给其它消费者处理？</h3><p>使用<code>XCLAIM</code>将目标消费者和消息ID转移到自己的pending列表中，同时需要提供<strong>IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p><h3 id="坏消息问题，Dead-Letter，死信问题"><a href="#坏消息问题，Dead-Letter，死信问题" class="headerlink" title="坏消息问题，Dead Letter，死信问题"></a>坏消息问题，Dead Letter，死信问题</h3><p>delivery counter，反复转给各个消费者时会累加，当到达临界值时将该消息视为死信，此时可以处理该消息，一般删除即可，XDEL。</p><h1 id="六、发布订阅详解"><a href="#六、发布订阅详解" class="headerlink" title="六、发布订阅详解"></a>六、发布订阅详解</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis有两种发布&#x2F;订阅模式：</p><ul><li>基于频道(Channel)的发布&#x2F;订阅</li><li>基于模式(pattern)的发布&#x2F;订阅</li></ul><h2 id="基于频道的发布和订阅"><a href="#基于频道的发布和订阅" class="headerlink" title="基于频道的发布和订阅"></a>基于频道的发布和订阅</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">publish channel:1 hi #发布消息<br><br>subscribe channel:1 #订阅频道，随后进入订阅状态<br></code></pre></td></tr></table></figure><p>处于订阅状态下客户端不能使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>和<code>punsubscribe</code>这四个属于”发布&#x2F;订阅”之外的命令，否则会报错。</p><h2 id="基于模式-pattern-的发布-x2F-订阅"><a href="#基于模式-pattern-的发布-x2F-订阅" class="headerlink" title="基于模式(pattern)的发布&#x2F;订阅"></a>基于模式(pattern)的发布&#x2F;订阅</h2><p>如果有某个&#x2F;某些模式和这个频道匹配的话，那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-6.svg"><br>通配符中<code>?</code>表示1个占位符，<code>*</code>表示任意个占位符(包括0)，<code>?*</code>表示1个以上占位符。</p><ul><li>psubscribe可以重复订阅一个频道，会收到多条消息。</li><li>subscribe和psubscribe是相互独立的，接受到消息时也会有区别。</li><li>使用punsubscribe只能退订通过psubscribe命令订阅的规则。</li></ul><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="基于频道"><a href="#基于频道" class="headerlink" title="基于频道"></a>基于频道</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-4.svg"></p><ul><li>订阅时，将客户端添加到对应channel的list中</li><li>发布时，订阅到channel，发送给List中所有客户端。</li></ul><h3 id="基于模式"><a href="#基于模式" class="headerlink" title="基于模式"></a>基于模式</h3><ul><li>订阅时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-10.svg"></li><li>发布时，遍历pubsubPattern，逐一对比看是否要发送。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第6章（应用层）</title>
    <link href="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-968c1bcea54ea1f4.webp"><br>例子：<br><strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong>，该应用还涉及到域名到IP地址的转换，由属于<strong>应用层范畴的域名系统DNS</strong>完成。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4e9858624d4835ae.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c1c3868fb5e127b1.webp"></p><h1 id="二、两种组织方式"><a href="#二、两种组织方式" class="headerlink" title="二、两种组织方式"></a>二、两种组织方式</h1><h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-bbfb139bb8ffd796.webp"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-598b1158f5c33a11.webp"></p><div class="note note-primary">            <p>www,email,ftp为C&#x2F;S架构。</p>          </div><h1 id="三、动态主机配置协议DHCP"><a href="#三、动态主机配置协议DHCP" class="headerlink" title="三、动态主机配置协议DHCP"></a>三、动态主机配置协议DHCP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>DHCP</strong>使用了C&#x2F;S方式：</p><ul><li>主机在启动时向DHCP服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li><li>基于UDP工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><h4 id="发现报文"><a href="#发现报文" class="headerlink" title="发现报文"></a>发现报文</h4><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong>，其中包含<strong>事务ID</strong>，<strong>DHCP客户端的MAC地址</strong></p><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-6f9a9715f8b1c74a.webp"></p><blockquote><p>报文包括：</p><ul><li><strong>源IP地址</strong>：0.0.0.0，这是因为主机目前还未分配到IP地址。</li><li><strong>目的地址</strong>：广播地址255.255.255.255。</li><li><strong>MAC地址</strong>：主机MAC地址。</li></ul></blockquote><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送。</p><h4 id="提供报文"><a href="#提供报文" class="headerlink" title="提供报文"></a>提供报文</h4><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03ecd6d2838d4274.webp"></p><blockquote><p>报文包括</p><ul><li><strong>事务ID</strong>：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的。</li><li><strong>配置信息</strong>：IP地址、子网掩码、地址租期、默认网关、DNS服务器</li><li><strong>源IP地址</strong>：发送DHCP提供报文的DHCP服务器的IP</li><li><strong>目的地址</strong>：因为目的主机还没分配到IP，所以使用广播地址</li></ul></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-009b1e9a88976880.webp"></p><blockquote><p>报文包括<br><strong>事务ID</strong><br><strong>MAC地址</strong><br><strong>接受的IP地址</strong><br><strong>提供此租约的DHCP服务器端的IP地址</strong><br><strong>源IP地址</strong>：0.0.0.0<br><strong>目的地址</strong>：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们作为自己的DHCP服务器。</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文。</p><h4 id="确认报文"><a href="#确认报文" class="headerlink" title="确认报文"></a>确认报文</h4><p><strong>DHCP服务端将广播发送DHCP确认报文（DHCP ACK）</strong><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-35c9002bba766476.webp"></p><blockquote><p>报文包括：<br>源地址：DHCP服务器1的IP地址<br>目的地址：广播地址</p></blockquote><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong>，<strong>在使用前还会进行ARP检测</strong>。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-044fb99d76bd279c.webp"></p><h4 id="剩余流程"><a href="#剩余流程" class="headerlink" title="剩余流程"></a>剩余流程</h4><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a01eacfba40e9098.webp"></p><div class="note note-primary">            <p>由于确认客户端的IP地址前，其都没有IP地址，所以DHCP借用IP的过程中报文的目的IP都是广播，服务器的源IP地址都是自身IP地址，客户端IP地址为默认0.0.0.0。</p><p>客户端请求IP是一个4握手过程。前2个握手用于服务端和客户端明确对方的存在并给客户端一个Offer。后2个握手就是客户端确定这个Offer的过程。</p><p>第三个握手，虽然是广播，但其他的DHCP服务器是不会接受的，因为事物ID不符。</p><p>到达0.5倍租用期时，客户端会主动续租，若超过了租用期，则停止使用这个IP地址。</p>          </div><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-33c64efac75f0ad2.webp"></p><p>由于网络之间存在广播域，主机的广播消息可能无法送达DHCP服务器，可为路由器配置DHCP中继代理服务，路由器会将接受到的DHCP报文转发到DHCP服务器。</p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-37d8836f5ed85036.webp"></p><h1 id="四、域名系统DNS"><a href="#四、域名系统DNS" class="headerlink" title="四、域名系统DNS"></a>四、域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8dc45fb61122f775.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-31a3076fe8055379.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4655232a57435f63.webp"></p><blockquote><p>名称相同的域名等级未必相同。</p></blockquote><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c2350ce866abf74e.webp"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-aae45d426ec7fa49.webp"></p><div class="note note-primary">            <p>递归查询的过程是链式调用，最后将域名对应的IP地址返回给主机。<br>迭代查询的过程是由本地域名服务器作为请求主体，迭代查询各级服务器IP。</p>          </div><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-d2652511b6f2280d.webp"></p><div class="note note-primary">            <p>本地域名服务器使用高速缓存减少DNS查询次数，但需要保证正确性，所以对于每一项缓存都有倒计时，超时的记录会被删除。<br>同时，主机也需要做缓存（多级缓存），启动时便向本地域名服务器获取域名和IP的数据库信息，必要时再询问服务器。</p>          </div><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-93d3fbaa54195112.webp"></p><h1 id="五、文件传送协议FTP"><a href="#五、文件传送协议FTP" class="headerlink" title="五、文件传送协议FTP"></a>五、文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-df91fe396712c633.webp"></p><h2 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h2><p>FTP采用了C&#x2F;S方式，监听熟知端口（21）。</p><h3 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-885981a43745ae55.webp"></p><div class="note note-primary">            <p>主动、被动指的是数据通道的建立发起者是否是服务器，主动模式服务器会使用固定的端口号连接客户端的临时端口号，被动模式服务器会开启某个临时端口号等待客户端连接。<br>注意，两种方式最后都会建立两个连接通道，控制连接在整个会话期间保持打开状态，数据连接传输完毕后就关闭。</p>          </div><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/Pasted-image-20221230015319.png"></p><h1 id="六、电子邮件"><a href="#六、电子邮件" class="headerlink" title="六、电子邮件"></a>六、电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-905f080fde0331a5.webp"></p><blockquote><p>注意：SMTP是发送协议，POP3&#x2F;IMAP是读取协议。</p></blockquote><h2 id="邮件发送和接受过程"><a href="#邮件发送和接受过程" class="headerlink" title="邮件发送和接受过程"></a>邮件发送和接受过程</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a55537e03d980133.webp"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）"></a>简单邮件传送协议SMTP（<em>Simple Mail Transfer Protocol</em>）</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03f4877d2621c261.webp"></p><h3 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-fb16b5ace5466b25.webp"></p><div class="note note-primary">            <p><strong>MIME</strong>是一层非ASCII和ASCII码之间的扩展转换器，其可以协助非ASCII码邮件以SMTP的形式发送。</p>          </div><h3 id="邮件接受"><a href="#邮件接受" class="headerlink" title="邮件接受"></a>邮件接受</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c825d1ad122bd41c.webp"></p><blockquote><p><strong>POP3</strong>是正式标准，客户只读。<br><strong>IMAP4</strong>是建议标准，客户可以操作服务器中的邮件，需要联机。</p></blockquote><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-46b15b10a17604fa.webp"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-b400e3f6c0a87238.webp"></p><div class="note note-primary">            <p>POP3使用110端口，IMAP4使用143端口</p>          </div><h1 id="七、万维网WWW"><a href="#七、万维网WWW" class="headerlink" title="七、万维网WWW"></a>七、万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>基本概念</p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络，而是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。<strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8646898df7461ca3.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-05ae15f55de2ba0a.webp"></p><h2 id="HTTP（Hyper-Transfer-Protocol）"><a href="#HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="HTTP（Hyper Transfer Protocol）"></a>HTTP（<em>Hyper Transfer Protocol</em>）</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP是一个应用层协议，它使用 <strong>TCP 连接</strong>进行可靠的传送。</li><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-614d1960b2b805d9.webp"></li></ul><div class="note note-primary">            <p>可以注意到第三次握手的时候就发出了HTTP请求报文。</p>          </div><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-22dfb8a34acf459c.webp"><br>响应报文<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-0409ca153701fbb4.webp"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-969dc15b42399e98.webp"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-abf0fcf785757c26.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-e7f4b696946ffafa.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-14ec3f45c4af32f9.webp"></p><div class="note note-primary">            <p>为了保证缓存的正确性，设置有过期时间，若没有过期，则直接返回，若过期了，则询问服务器文档内容是否有变化：</p><ul><li>若没有则直接返回一个普通响应，缓存服务器接受后直接刷新倒计时。</li><li>若有则返回新的文档内容，缓存服务器接收并更新内容。</li></ul>          </div><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-dab94fae0e969502.webp"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第5章（运输层）</title>
    <link href="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程之间通讯<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-86df51cb4523e3bf.webp"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><div class="note note-primary">            <p>NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议。</p>          </div><p>之前介绍的物理层、数据链路层、网络层解决了主机到主机的通讯。但通讯的真正实体是位于通讯两端主机的进程，如何为这两个进程提供通讯服务是运输层的任务，运输层协议也被称为端到端协议。</p><h2 id="端口号与复用"><a href="#端口号与复用" class="headerlink" title="端口号与复用"></a>端口号与复用</h2><p>端口号的使用<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-de597eda77aa6acd.webp"></p><h3 id="发送方与接受方的复用"><a href="#发送方与接受方的复用" class="headerlink" title="发送方与接受方的复用"></a>发送方与接受方的复用</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2a4ec3f5d5c11433.webp"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong><br><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p></blockquote><h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2117fa99a7f2a89c.webp"></p><h1 id="二、运输层传输流程（DNS）"><a href="#二、运输层传输流程（DNS）" class="headerlink" title="二、运输层传输流程（DNS）"></a>二、运输层传输流程（DNS）</h1><ul><li>DNS客户端（端口为短暂端口号）发送一个<strong>DNS请求报文</strong>（UDP）到DNS服务器（端口号为53）。</li><li>DNS服务器将接受到的信息上传给DNS服务器端进程（端口号为53），随后给用户回复<strong>DNS响应报文</strong>（UDP），目的端口为客户端的短暂端口号。</li><li>DNS客户端将接受到的信息上传给DNS客户端进程（端口号为短暂端口号），随后解析DNS响应报文，即可直到Web域名对应的IP地址。</li><li>向Web域名对应的IP发送http请求。</li></ul><h1 id="三、UDP与TCP对比"><a href="#三、UDP与TCP对比" class="headerlink" title="三、UDP与TCP对比"></a>三、UDP与TCP对比</h1><h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h2><ul><li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>；当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。；UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li><li>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接；UDP的通信是无连接的，不需要套接字（Socket）。</li></ul><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-58c94f043969af9a.webp"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>结构<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-624005a24bc5bfcd.webp"><br>实现</p><ul><li>UDP可以<strong>广播、多播和单播</strong></li><li>UDP对应用进程交下来的报文<strong>既不合并也不拆分</strong>，而是保留这些报文的边界</li><li>UDP向上层提供<strong>无连接不可靠传输服务</strong></li></ul><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h2><p>结构<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-db48b70af7fb7884.webp"><br>实现</p><ul><li>TCP只支持单播，端对端通讯</li><li>需要先通过3次握手建立连接</li><li>TCP是面向字节流的，即其<strong>可能会拆分上层交付的报文</strong>。</li><li>TCP向上层提供<strong>面向连接的可靠传输服务</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-b0c1d4146735458a.webp"></p><h1 id="四、TCP流量控制"><a href="#四、TCP流量控制" class="headerlink" title="四、TCP流量控制"></a>四、TCP流量控制</h1><p>目的：发送的速率尽可能快，但需要接受方来得及接受。<br>实现：滑动窗口。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=60">具体流程视频</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>累计确认+选择重传（只重传超时的，即每个窗口独立持有一个计时器）</p><ol><li>发送端和接受端分别具有发送窗口和接受窗口。发送端会将发送窗口内的字节数据依次发出。</li><li>接受方通过累计确认提示发送端应该<strong>如何调整发送窗口的大小</strong>（流量控制）以及<strong>已经接受到了n字节之前的数据</strong>。</li><li>发送方接受到累计确认后<strong>调整发送窗口大小</strong>并<strong>移动发送窗口</strong>。</li><li>移动发送窗口后：<ul><li>将刚进入窗口的窗口信息发送出去</li><li>同时等待看是否有窗口触发超时重传，若有则重传旧数据。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f73e94f75e94ea4c.webp"></li></ul></li><li>接受端将发送窗口调整为了0，说明暂时不接受数据，其恢复后给发送方的提示是可能丢失的。因此，<strong>当发送窗口为0（接受到0窗口通知）时，</strong>发送方<strong>持有持续计时器，超时时会发送</strong>零窗口探测报文**，确认接受端处理能力情况。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-5bd53b8a5a5ac400.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ea9dc3589e6c6bd1.webp"></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d8221e9dda7919f9.webp"></p><h1 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-9d4b410b2a44c125.webp"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><div class="note note-primary">            <p>理解拥塞原因：<br>1.传输时，链路容量不足；2.接受时，容量太小；3.处理时，速率太慢；4.负反馈。</p>          </div><p><strong>拥塞控制的一般原理</strong></p><ol><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ol><p><strong>开环控制和闭环控制</strong><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2740d71c5e1d6aac.webp"></p><p><strong>监测网络的拥塞</strong><br>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><div class="note note-primary">            <p>理解：</p>          </div><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-67852fc13fc0e263.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c7682fe29ebcb6fd.webp"></p><blockquote><p>发送窗口大小 &#x3D; min(接受方窗口大小，拥塞窗口大小)</p></blockquote><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul><li><p>目的：用来确定网络的负载能力或拥塞程度。</p></li><li><p>算法的思路：由小到大逐渐增大拥塞窗口数值。</p></li><li><p>两个变量：</p><ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值有2 种设置方法。窗口值逐渐增大。第一种是1 至 2 个最大报文段 （旧标准）；第二种是2 至 4 个最大报文段 （RFC 5681）</li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li><li><p>实现：</p><ul><li>起初拥塞窗口按指数增加，当达到慢开始门限后，为了避免出现拥塞，每经过一个传输伦次，cwnd++</li><li>如果出现超时重传，则重新回到慢开始<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f5db7ea25d8aca73.webp"></li></ul></li></ul><div class="note note-primary">            <p>慢开始是为了从小到大且尽快的达到门限，门限后则缓慢的扩大拥塞窗口来试探网络情况，两者一起使用以实现动态调整拥塞窗口。</p>          </div><div class="note note-warning">            <p>注意：这里是拥塞窗口的变化，而不是发送窗口的变化，发送窗口的大小还受限于接受端的接受窗口。</p>          </div><h3 id="快重传（fast-retrasmit）与快恢复（fast-recovery）"><a href="#快重传（fast-retrasmit）与快恢复（fast-recovery）" class="headerlink" title="快重传（fast retrasmit）与快恢复（fast recovery）"></a>快重传（<em>fast retrasmit</em>）与快恢复（<em>fast recovery</em>）</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-a57c7cc819aa4bae.webp"></p><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ab5a63efbd586eb8.webp"></p><div class="note note-primary">            <p>一般接受方对接受到的报文段的确定都是捎带的，和窗口控制报文一起发送给发送端，导致重传开启较慢。<br><strong>快重传</strong>：需要接受端尽快的回复接受到的报文信息，然后发送端实现快重出传（接受到连续3个重复的确认报文）</p><p>发送端发生重传时，直接进入慢开始，这对于仅丢失个别报文的传输的效率较大，而快重传刚好可以确定这类情况。<br><strong>快恢复</strong>：当发送快重传时不进入慢开始，而是调节ssthresh值和cwnd值为一半后直接开始执行拥塞避免算法。</p><p>快恢复要和快重传结合使用，快恢复的具体调整依赖于发送端具体的实现。</p>          </div><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-8f61b8eddb5b2624.webp"></p><h1 id="六、TCP超时重传时间的选择"><a href="#六、TCP超时重传时间的选择" class="headerlink" title="六、TCP超时重传时间的选择"></a>六、TCP超时重传时间的选择</h1><p>不必要的重传会导致网络负荷的增大，但重传推迟的太久也会导致传输效率的降低。因此需要合理的设置超时重传时间<em>RTO</em>，其应该略大于往返时间<em>RTT</em>，具体计算：</p><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-20d1cf6bb211fe7e.webp"></p><h2 id="RTO"><a href="#RTO" class="headerlink" title="RTO"></a>RTO</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-39ab62874e65b623.webp"></p><div class="note note-primary">            <p>RTT计算：越近的RTT样本权重越大。<br>RTO计算：在RTT的基础上加上了RTT的偏差。(相当于加上了RTTs与新样本的差异，β只是一个权重参数，RTT（D1） &#x3D; RTT（1）&#x2F;2只是数据的初始化）。</p>          </div><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-dbc63525eab966e1.webp"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c94fa8a3ad6b277f.webp"></p><h1 id="七、TCP可靠传输的实现"><a href="#七、TCP可靠传输的实现" class="headerlink" title="七、TCP可靠传输的实现"></a>七、TCP可靠传输的实现</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-6d10ea76a1ea032b.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-92d975bc880db892.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-35bff0a8cc5b0d71.webp"></p><div class="note note-primary">            <p>发送方接收到确认消息后，需要1.前移2.调整窗口大小。<br>调整窗口大小时，原则上窗口的前沿是不推荐后移的，所以最好是通过 后沿前移+前沿不动 来实现窗口缩小。</p>          </div><div class="note note-primary">            <p>接收方对数据的确认有累计确认和捎带确认：</p><ul><li>累计确认要求接收方不要过迟的发送确认。</li><li>捎带确认使用较少。</li></ul>          </div><h1 id="八、TCP的运输连接管理"><a href="#八、TCP的运输连接管理" class="headerlink" title="八、TCP的运输连接管理"></a>八、TCP的运输连接管理</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e7d2329746de8e6a.webp"></p><h2 id="TCP连接建立（握手）"><a href="#TCP连接建立（握手）" class="headerlink" title="TCP连接建立（握手）"></a>TCP连接建立（握手）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-84c2b6dbb20379bd.webp"></p><div class="note note-primary">            <p><strong>双报文握手</strong>保证双方得知对方的存在，随后可以直接发送数据。<br><strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误，导致服务器资源浪费。</p>          </div><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-0a5773a600817c41.webp" alt="两报文握手"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e69d0e450b080e1f.webp" alt="服务器打开传输控制块"></li></ul><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。<br>之后，就准备接受TCP客户端进程的连接请求。<br>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求。<br>而TCP客户端在主动打开前也是要先创建传输控制块。</p></blockquote><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-3205fd7d7d75b62e.webp"></p><div class="note note-primary">            <p><strong>SYN</strong>，<strong>ACK</strong>是TCP报文头中的一个bit，其标识了当前TCP报文的属性：<br>SYN（同步标志位）表示请求同步，ACK（确认标识位）表示是对某报文的回复。<br><strong>seq</strong>，<strong>ack</strong>是TCP报文头中的两个字段，都占4个字节，其标识了端消息的id和确认收到的消息id+1。</p><p>TCP规定SYN&#x3D;1的报文段即使不携带数据，也要消耗掉一个序号。<br>普通的确认报文可以不消耗序号。</p>          </div><h2 id="TCP连接释放（挥手）"><a href="#TCP连接释放（挥手）" class="headerlink" title="TCP连接释放（挥手）"></a>TCP连接释放（挥手）</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-1c5e0c6357d039ed.webp"></p><ul><li>前两次握手是确认服务器接受到了释放连接的请求，此后服务器对剩余数据进行传输，客户端进入终止等待2状态。</li><li>后两次握手是确认客户端接受到了释放连接的命令，此后服务器关闭，客户端则继续等待2MSL，这是为了防止第四次握手丢失导致服务器资源浪费。若直接关闭：<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ef85470fe120f146.webp"></li><li>若服务器没有收到第四次握手，则会重传第三次握手，以确保收到第四次握手。</li></ul><div class="note note-warning">            <p>第二次握手和第三次握手的ack序号相同，说明这个消息是对同一个消息（第一次握手）的回应，分别表示服务器收到释放连接请求和服务器运行释放连接请求。</p>          </div><div class="note note-warning">            <p>可见握手和挥手，都需要客户端保证对服务器连接的最终确认以防止服务器的资源浪费。<br>在握手中体现在服务器之后接收到第三次握手确认在进入连接状态。<br>在挥手中体现在客户端会保持等待，服务器主动重传第三次握手以收到第四次握手。</p>          </div><div class="note note-primary">            <p><strong>FIN</strong>是TCP报文头中的一个bit，表示请求释放连接。在挥手中其会出现两次，一次是客户端主动请求释放连接，一次是服务器回复可以释放连接了。</p><p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>          </div><h2 id="TCP保活计时器"><a href="#TCP保活计时器" class="headerlink" title="TCP保活计时器"></a>TCP保活计时器</h2><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障，TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此，应当有措施使TCP服务器进程不要再白白等待下去<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2dc97e06fe1d82ed.webp"></p><h1 id="九、TCP报文段的首部格式"><a href="#九、TCP报文段的首部格式" class="headerlink" title="九、TCP报文段的首部格式"></a>九、TCP报文段的首部格式</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-df9263a14e1da2c1.webp"></p><h2 id="固定首部"><a href="#固定首部" class="headerlink" title="固定首部"></a>固定首部</h2><p>源端口和目的端口<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-27e4bd51d5db2f8e.webp"><br>序号、确认号和确认标志位<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-fd0e64d8be3f598b.webp"><br>数据偏移、保留、窗口和校验和<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d3d4c61af68fdb6d.webp"><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f09bdaba863c4ca3.webp"></p><h2 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d1a8d3ca5ac7f39d.webp"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第4章（网际层）</title>
    <link href="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li><li>为了实现这个任务，有以下问题：<ul><li>网络层提供可靠传输还是不可靠传输</li><li>网络层怎么寻址(IP地址做导航)</li><li>网络层路由选择(路由器根据路由表转发，为了记录路由需要人工配置或实现各种路由选择协议)</li></ul></li></ul><blockquote><p>网络层（网际层）,除了<strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><blockquote><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，因此在TCP&#x2F;IP协议中网络层常称为网际层。</p></blockquote><div class="note note-primary">            <ul><li>数据链路层能通过MAC地址与交换机实现数据的定向传输，但是对于庞大的因特网，这显然是不合理的，相比起MAC地址的无序序列，我们需要一个具有明显层级关系的地址（如湖北省武汉市洪山区）方便快速定位，统一管理，因此有了IP地址。</li><li>网络层需要实现数据在局域网和局域网之间的传递（不同于之前的局域网通过交换机互联，这样会扩大广播域，VLAN虽然能实现类似的功能，但依赖于用户设置，无法达到全网统一）。</li></ul>          </div><h1 id="二、网络层提供的服务"><a href="#二、网络层提供的服务" class="headerlink" title="二、网络层提供的服务"></a>二、网络层提供的服务</h1><p>网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”），实质就是<strong>在计算机通信中，可靠交付应当由网络还是端系统来负责</strong>？</p><ul><li>第一种观点是<strong>网络提供虚电路连接</strong>（一种使用<strong>面向连接</strong>的通信方式，通信之前先建立<strong>虚电路</strong>，保证所有网络资源，分组即可按顺序无差错的到达），由网络本身负责可靠交付。</li><li>另一种观点是<strong>网络只提供数据报服务</strong>，向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong>。</li></ul><blockquote><p>显然后者是我们现在使用的，其运行灵活，造价低，适应性强。</p><p><strong>区别</strong><br>终点地址：<br>1.仅在连接建立阶段使用，每个分组使用短的虚电路号<br>2.每个分组都有终点的完整地址</p><p>当结点出故障时：<br>1.所有通过出故障的结点的虚电路均不能工作<br>2.出故障的结点可能会丢失分组，一些路由可能会发生变化</p><p>端到端的差错处理和流量控制：<br>1.可以由网络负责，也可以由用户主机负责<br>2.由用户主机负责</p></blockquote><div class="note note-primary">            <p>当前网络层的服务实现是：<strong>尽最大努力交付</strong>。</p>          </div><h1 id="三、IPv4"><a href="#三、IPv4" class="headerlink" title="三、IPv4"></a>三、IPv4</h1><p><strong>IPv4地址</strong>是因特网（<em>Internet</em>）上每一个主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32bit（4个字节）的标识符。</p><div class="note note-warning">            <p>只有<strong>公网IP</strong>是全世界独一无二的，<strong>私网IP</strong>是在不同局域网中可以重复使用的：<br>RFC1918定义了私有IP的地址范围：<br>A:10.0.0.0 ~ 10.255.255.255即10.0.0.0&#x2F;8<br>B:172.16.0.0 ~ 172.31.255.255即172.16.0.0&#x2F;12<br>C:192.168.0.0 ~ 192.168.255.255 即192.168.0.0&#x2F;16</p>          </div><div class="note note-success">            <p><strong>私有IP是无法随意定义的</strong>，只有以上范围内的IP会被路由器视为内网IP，以这些IP为源IP的数据包只会在局域网内传递，不会在因特网上传递。</p><p>私有IP设备<strong>发送</strong>与<strong>接受</strong>外网数据包：<br>首先内网中的客户端将数据包传送给路由器，路由器解析数据包后发现，这个数据包是来自与私网、发送给外网的。例如某个数据包的源IP:192.168.1.2，当路由器检测到这个数据包的目标IP是外网IP的时候，路由器中会生成一个唯一端口号对应192.168.1.2，再生成一个随机端口号对应这个唯一端口号。然后路由器会将数据包的源IP改成公网IP，发送到互联网上。接收数据时，数据包会被发送到路由器的随机端口号上，这时和原来生成的映射表进行匹配，再把数据包传送到内网客户端，其实就是一个端口映射表。<br><a href="https://blog.csdn.net/weixin_39661353/article/details/110806482">路由器修改报文端口号</a></p>          </div><p>IPv4的编址方法经历了3个阶段：<br><strong>分类编址 -&gt; 划分子网 -&gt; 无分类编址</strong></p><h2 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h2><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-617a75508f564e07.webp"><br>其中有2个网络号无法分配，即A类地址：</p><ul><li><strong>最小网络号为0，保留不做指派</strong></li><li><strong>最大网络号为127，是本地回环测试地址，保留不做指派</strong></li></ul><p>有2类主机号无法分配：</p><ul><li>全0的主机号，其表示该网络的标识地址</li><li>全1的主机号，其表示该网络的广播地址</li></ul><div class="note note-primary">            <p>网络号，主机号都为0，即<code>0.0.0.0</code>，表示本网络上的本主机（见DHCP协议）</p>          </div><blockquote><ul><li><strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</li><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li><strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong></li></ul></blockquote><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>两级的IP地址会导致IP地址空间的利用率很低。<br>子网即从主机号借一部分作为子网号，从而将一个网络号分为多个子网。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5006c8be601f1a11.webp"><br>划分子网的工具即<strong>子网掩码</strong>。<br>其将<strong>两级的IP地址</strong>变成了<strong>三级的IP地址</strong>。</p><p><strong>默认子网掩码</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5e9d1b71bd598e62.webp"></p><p>IPv4地址与子网掩码相与即得到所在子网的网络地址。</p><blockquote><p>对于在因特网上传输的数据报，仍然是根据<strong>目的网络号</strong>net-id寻找下一跳路由器。到了该网络号的路由器时，路由器再根据<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</p></blockquote><div class="note note-primary">            <p><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。<br>这里所谈论的<strong>划分子网</strong>针对的仍然是因特网上的IP地址，其并没有造成IP地址重复（<code>相同的ip/不同的子网掩码</code>指的仍是同一个主机），只是单位内部对于可分配的主机号进行的一种再划分，即：</p><ul><li>子网掩码对于外网路由器没有作用。</li><li>内网路由器根据接受到的IP匹配对于的子网，能实现对该子网更精准的路由。<br>（最长前缀匹配）</li></ul>          </div><blockquote><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个记录，除了要记载目的网络地址外，还必须同时记载该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><div class="note note-primary">            <p>以上路由器行为是为了保证在传递IP数据报时，能够选择最符合的端口转发数据</p>          </div><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><strong>无分类域间路由选择 CIDR</strong> (<em>Classless Inter-Domain Routing</em>)。</p><ul><li>CIDR消除了A、B、C类地址和划分子网的概念。</li><li>CIDR能更有效的分配IPv4的地址空间。</li></ul><p><strong>特点</strong></p><ul><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li><li>IP 地址的形式为：<code>a.b.c.d/x</code>，其中地址的 <code>x</code> 最高比特构成了 IP 地址的<strong>网络部分（即网络前缀）</strong>，所以 <strong>CIDR 中 IP 地址由前缀和主机号构成</strong>，<code>x</code> 为前缀长度，<code>/x</code> 的记法也称为<strong>子网掩码</strong>。</li></ul><div class="note note-primary">            <p><strong>CIDR</strong>只是在网络实现层面消除了这些概念，并不代表A、B、C类地址和划分子网的协议行为不存在了。具体而言，总服务商分配到的公网IP地址基本仍为A、B、C类地址（如130.67.0.0&#x2F;16），不过服务商可以把这些地址再划分下去给子服务商(如130.67.0.0&#x2F;17和130.67.128.0&#x2F;17)使用，我们也不再把这样的关系称为总网、子网关系。</p><p>问题：130.67.0.0&#x2F;16 和130.67.0.0&#x2F;17还是同一个目标IP地址吗？<br>答：这个问题本身就是错误的。</p><ol><li><strong>IP地址仍然为一个全网唯一的IP地址</strong>，并没有后面的网络前缀的区分。</li><li>对于一个目标IP地址，<strong>不会也不可能在数据传递时携带网络前缀</strong>。</li><li>在数据的传输中，<strong>网络前缀只保存在路由器表中</strong>，用于记录与路由器相连接的网络的所在的网络号。</li></ol><p>问题：如果两个服务商，一个分到了<code>130.67.0.0/16</code>的公网IP，一个分到了<code>130.67.128.0/17</code>的公网IP，此时服务商1内部划分出子网<code>130.67.128.0/17</code>，其是否会与服务商2的IP在公网上重复？<br>答：不会。如上面所说，IP地址在分配时仍有等级之分，服务商一般只会分到<code>/8</code>，<code>/16</code>，<code>/24</code>这样的网络前缀，像<code>/17</code>这样的IP和网络前缀，本身就是由服务商1分发出来的，不可能由服务商2获得。</p>          </div><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p><strong>超网（路由聚合）技术是为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。</strong></p><p>即路由器发现其某个端口与多个具有相同前缀的网络对应，会将这些记录合并。</p><blockquote><p>举个例子，如果路由器1与路由器2连接，路由器2的各个端口连接了不同的网络（本质上是多个子网）。<br>经过路由器交换学习，路由器1会得知路由器2所在网络号和网络前缀，而路由器2的不同接口在不同的网络号中，因此路由器1学习到了路由器2的多个网络。（如<code>67.67.0.0/18</code>，<code>67.67.64/18</code>, <code>67.67.128.0/18</code>,<code>67.67.192.0/18</code>)<br>此时，路由器1发现虽然有多个网络，但他们都对应着同一个端口，并且具有相同前缀（<code>67.67.0.0/16</code>）。此时路由器1会将这些记录合并，这种行为叫做路由聚合，也叫构造超网。</p></blockquote><h3 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h3><p>最长匹配 是指存在多条目的网段相同的路由时，匹配掩码最长的那一条。因为掩码越长，表示的网段就越小，匹配也就越精确。</p><div class="note note-primary">            <p>条件：</p><ul><li>路由器1：外部路由器。</li><li>路由器2：连接多个网段（子网）路由器。</li><li>路由器3：连接路由器2的一个子网路由器。</li><li>网段3：路由器3所在的网络。</li><li>3个路由器两两相连。<br>对于划分子网的IPv4地址，同一网络号的不同子网的记录只保存在该网络的中转的路由器2中。对于路由器1，其只需要知道路由器2的总网络号即可，其子网的划分对路由器1是<strong>屏蔽的</strong>。</li></ul><p>但CIDR不再区分子网，路由器1会学习与之相连接的路由器2的所有网络号（IP和网络前缀）。这导致路由器2所在的子网对路由器1也是<strong>可见的</strong>，因此需要将这些网络号在本路由器的路由表中聚合起来，避免路由表内存浪费。</p><p>至于最长匹配原则，则可以当某个数据包要从路由器1要发往子网3。此时路由器1会优先匹配到最长的网段3，并将数据转发到路由器3。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/routeUnion.png"></p><h2 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h2><ul><li>定长的子网掩码FLSM（<em>Fixed Length Subnet Mask</em>）</li><li>变长的子网掩码VLSM（<em>Variable Length Subnet Mask</em>）<blockquote><p>前者就是分类IP，后者就是无分类IP<br>定长的子网掩码只能划分出2^n个子网，而变长的子网掩码可以按需分配，减少对IP地址的浪费。</p></blockquote></li></ul><h1 id="四、IP数据包的发送和转发过程"><a href="#四、IP数据包的发送和转发过程" class="headerlink" title="四、IP数据包的发送和转发过程"></a>四、IP数据包的发送和转发过程</h1><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>,由默认网关帮忙转发</li><li>为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong>。（具体地，默认网关指的是与本机网络直接相连的路由器<strong>接口</strong>，即下图中的0。通俗的讲，默认网关就是本网络与外网的默认接口）</li></ul></blockquote><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0351946f5505b37a.webp"></p><div class="note note-primary">            <p>前提：</p><ul><li>本机IP ＆ 本机掩码 &#x3D; 本机网络</li><li>目的IP ＆ 目的掩码 &#x3D; 目的网络</li></ul><p>正向来看：<br>如果：目的网络 &#x3D;&#x3D; 本机网络（即目的掩码 &#x3D; 本机掩码）<br>那么：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络（目的网络）</p><p>反向来看：<br>条件：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络<br>问题：目的网络是否为本机网络呢？<br>答案：<strong>是</strong>。考虑这个问题的时候主要在想以下情形：<br>”如果目的网络（<code>190.68.16.128/25</code>）是本机网络（<code>190.68.16.0/24</code>）的子网，那么上面条件是成立的，但该子网和该网络并不能划等号。“<br>但实际上这个想法本质就是错误的，在<strong>CIDR和变长的子网掩码</strong>中：</p><ol><li>IP网络之间的关系已经没有了父子关系，</li><li>对于变长子网掩码，不同的子网之间的关系依然是并列的。也就是说，如果本机IP的网络会被划分成（<code>190.68.16.0/24</code>），就说明已经有一个网段包含了<code>190.68.16.xxx</code>的所有主机，<code>190.68.16.128/25</code>网络根本就不可能存在，即若有某主机IP为<code>190.68.16.129</code>，其子网掩码也一定是<code>/24</code>。</li></ol><p>以上证明了可以根据本机掩码和目的IP判断目的网络是否为本机网络，但如果不是本机网络，则不能直接判断目的网络的具体掩码长度，不过对于本机而言，只需要操心一个IP是由自己直接交付（本机网络）还是交给路由器（外网网络）处理即可。</p>          </div><h2 id="路由器行为"><a href="#路由器行为" class="headerlink" title="路由器行为"></a>路由器行为</h2><ol><li>检查IP数据报首部是否出错<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ol><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>静态路由配置指用户或网络管理员使用路由器的相关命令给路由<strong>人工配置路由表</strong>。</p><p><strong>默认路由</strong><br>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是<strong>优先级最低</strong>的。一般为0.0.0.0&#x2F;0(可以匹配所有地址)</p><p><strong>特定主机路由</strong><br>给路由器添加的针对某个主机的特定主机路由条目，可以指定其下一条目的。一般用于网络管理人员对网络的管理和测试。</p><div class="note note-primary">            <p>当多条路由可选时，使用最长匹配原则。</p>          </div><p><strong>静态路由配置</strong>其可能出现以下导致产生<strong>路由环路</strong>的错误。</p><ul><li><strong>配置错误</strong>（手动配置错误）</li><li><strong>聚合了不存在的网络</strong>（解决办法：黑洞路由）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-caeddc52bde20f9c.webp"></li><li><strong>网络故障</strong>（解决方法：为故障网路添加黑洞路由，故障恢复后使该黑洞路由失效）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d8107f8fc71dd1f4.webp"></li></ul><h2 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>动态路由选择</strong>相比<strong>静态路由选择</strong>能更好适应网络状态的变化，且适用于大规模网络。其路由器通过路由选择协议自动获取路由信息。</p><blockquote><p><strong>因特网采用分层次的路由选择协议</strong></p></blockquote><p><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器。自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-9e37d1229ec7836e.webp"></p><p><strong>路由选择协议</strong>：域间路由选择使用外部网关协议<strong>EGP</strong>这个类别的路由选择协议，域内路由选择使用内部网关协议<strong>IGP</strong>这个类别的路由选择协议。<strong>网关协议</strong>的名称可称为<strong>路由协议</strong>。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8729bdd2bd367edf.webp"></p><div class="note note-primary">            <p><strong>路由选择协议</strong>的本质是路由器之间交换信息、判断某网络是否可达并进行路径选择的规则。由于路由器之间交换信息需要进行广播行为，由于路由表容量有限和避免广播的泛滥，需要使用<strong>自治系统</strong>来隔离网络中的路由器，并保证<strong>同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</strong></p>          </div><h3 id="常见的路由选择协议"><a href="#常见的路由选择协议" class="headerlink" title="常见的路由选择协议"></a>常见的路由选择协议</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b1876963d6d9de0.webp"></p><h3 id="路由器基本结构和功能"><a href="#路由器基本结构和功能" class="headerlink" title="路由器基本结构和功能"></a>路由器基本结构和功能</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e6b69c1f176e24c5.webp"></p><p><strong>分组转发部分</strong><br>转发时需要注意的行为：</p><ul><li>若在转发表中找不到匹配条目则<strong>丢弃分组</strong></li><li>转发时会<strong>更新分组首部的某些字段</strong>，如分组生存时间</li><li>各端口都有缓冲区，每个端口一般都具有输入、输出功能</li></ul><p><strong>路由选择部分</strong><br>路由选择处理器根据所使用的路由选择协议周期性的与其他路由器进行路由信息交互来更新路由表。<br>如果路由器接受到的分组是路由器之间交换路由信息的<strong>路由报文</strong>，则会把这种分组送交给<strong>路由选择处理器</strong>进行处理。</p><p>路由选择处理器的行为：</p><ul><li>路由表一般只包含从目的网络到下一条的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表生成的</li><li>转发表的结构应当使查找过程最优化</li></ul><div class="note note-primary">            <p>路由表（RIB）和转发表（FIB）的联系和区别：</p><ul><li><p>联系<br>转发表是路由器使用一个特定的进程通过路由表中的信息和自身的网卡等信息综合得到的。转发表类似于交换机的地址信息表。</p></li><li><p>区别<br>首先，”转发”和”路由选择”是有区别的，”转发”时，路由器只需要把接受到的信息从合适的端口发送出去即可，只涉及到一个路由器。”路由选择”则是许多路由器协同工作的结果。<br>其次，路由表只存储三元素：目标，掩码，下一跳；而转发表存储更详细的信息：比如输出端口信息，某些MAC地址，比如标记信息等。</p></li></ul><p>这里的描述都屏蔽了MAC地址的问题，这里在汇总对比一下：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。<br>举例：<br>局域网：使用MAC表和ARP表即可实现局域网内主机通讯（使用交换机，虽然现在不会这么使用）<br>主机流程：目的IP地址 -&gt; 目的MAC地址 -&gt;端口<br>路由器流程同上。</li></ul><p>因特网：但不同网段之间的通讯，要涉及到网络路线选择问题。<br>主机流程：目的IP地址(非本网段) -&gt; 目的MAC地址（默认网关）-&gt;端口<br>路由器流程：目的IP地址 -&gt; 下一跳IP地址（路由选择） -&gt;MAC地址 -&gt; 端口</p>          </div><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由信息协议RIP(<em>Routing Information Protocol</em>)<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-850c29aaf1e744d6.webp"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>思路</strong></p><ul><li>距离最短为最好路由</li><li>相同距离则负载均衡</li><li><strong>只和相邻的路由器周期性的交换自己的路由表</strong></li></ul><h5 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6bf4e045a90846e0.webp"></p><p><strong>路由更新细节</strong><br>接受到更新报文后和自己的路由器对比：</p><ul><li>未知的Net，插入新信息。</li><li>相同Net和相同下一跳，<strong>覆盖距离信息</strong>。</li><li>相同Net和不同下一跳，距离不同则使用，若<strong>相等则都保留并负载均衡</strong>。</li></ul><h4 id="RIP存在的问题"><a href="#RIP存在的问题" class="headerlink" title="RIP存在的问题"></a>RIP存在的问题</h4><p>如果网络出现故障，由于远处的路由器获知这个消息慢，先发出了自己的更新报文，则可能造成路由器之间互相认为对方可以到达一个不可达的网络，形成<strong>网络环路</strong>。</p><p>解决方法<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-3a055002b79a9cda.webp"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><h4 id="RIP的优缺点"><a href="#RIP的优缺点" class="headerlink" title="RIP的优缺点"></a>RIP的优缺点</h4><blockquote><p>RIP 协议的优缺点<br>优点：</p><ol><li>实现简单，开销较小。<br>缺点：</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p>开放最短路径优先 OSPF (<em>Open Shortest Path First</em>)。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f5dc77f36b5b1047.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="OSPF五种分组类型"><a href="#OSPF五种分组类型" class="headerlink" title="OSPF五种分组类型"></a>OSPF五种分组类型</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a2a83ab2654e270f.webp"></p><h5 id="基本工作过程-1"><a href="#基本工作过程-1" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-339786779f0e1a82.webp"></p><p>部分细节：<br><strong>Hello分组</strong><br>建立并维护路由器关系的分组。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f9c642e76e871651.webp"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong><br>包含具体的路由信息，被封装在<strong>LSU分组</strong>中<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bbed8a0d31bf19c3.webp"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b8e10e2d82cfa6f.webp"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-4239eee0b6040f52.webp"></p><div class="note note-primary">            <p>总结，OSPF是一个路由器通过获取AS内所有路由器之间边信息，然后建立一个以自己为根节点的无环图的过程。<br>具体地，相邻路由器会通过Hello分组维护关系，并互相简单介绍自己已知的路由信息，然后各自通过路由信息请求、路由信息返回、路由信息确认等过程逐步获得整个AS内的路由信息，最后构建各自的路由表。</p>          </div><h4 id="OSPF存在的问题"><a href="#OSPF存在的问题" class="headerlink" title="OSPF存在的问题"></a>OSPF存在的问题</h4><h5 id="大量多播分组"><a href="#大量多播分组" class="headerlink" title="大量多播分组"></a>大量多播分组</h5><p>多点接入（较多路由器互联）时，会产生大量的多播分组，通讯量过大。<br><strong>解决方法</strong><br>1）屏蔽部分路径，因此只与部分路由器进行数据交换。DR出现问题后使用BDR替换。</p><p> 2）路由分区，<strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-725b3aab5aa350b1.webp"></p><blockquote><p>实现细节：</p><ul><li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域，每个区域都有一个32比特的区域标识符，主干区域的区域标识符必须为0，主干区域用于连通其他区域，其他区域的区域标识符不能为0且不相同。</li><li>每个区域一般不应包含路由器超过200个。</li><li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量。</li></ul></blockquote><h4 id="OSPF的优缺点"><a href="#OSPF的优缺点" class="headerlink" title="OSPF的优缺点"></a>OSPF的优缺点</h4><div class="note note-primary">            <p>优点：</p><ul><li>从算法上避免了环路的产生。</li><li>基于链路状态，相比RIP考虑了更多对链路代价的影响因素。</li><li>不限制网络规模（没有最长距离限制）</li></ul><p>缺点：</p><ul><li>实现较复杂。</li><li>路由器需要获取AS内所有路由器信息，通信量大，可以通过<strong>指定路由器</strong>和<strong>划分区域</strong>的手段解决。</li></ul>          </div><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（<em>Border Gateway Protocol</em>） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><strong>为何需要BGP？</strong><br>AS之间没有统一度量，且需要一个网关去解决AS之间通讯时的相关策略问题（政治、经纪、安全等），因此需要一个外部网关协议。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5aae9c53795e17a7.webp"></p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-04fe6f98036db57c.webp"><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bc71c2ee5976ac53.webp"><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-b472dd1a51f30666.webp"></p><h5 id="BGP-4四种分组类型"><a href="#BGP-4四种分组类型" class="headerlink" title="BGP-4四种分组类型"></a>BGP-4四种分组类型</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-67b837e6c27d5e9c.webp"></p><div class="note note-primary">            <p>总结，BGP协议要求每个AS有一个发言人，发言人之间建立TCP连接建立会话，交换路由信息。类似于OSPF协议，发言人也会构造一个无环路的AS连通图。<br>注意，<strong>BGP不保证最好路由，只选择较好路由</strong>。</p>          </div><h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-40cf22cbd65e9ed8.webp"></p><h1 id="五、IPv4数据包格式"><a href="#五、IPv4数据包格式" class="headerlink" title="五、IPv4数据包格式"></a>五、IPv4数据包格式</h1><h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><blockquote><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li></ul></blockquote><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-73800cce52c3a91e.webp"></p><h3 id="固定部分"><a href="#固定部分" class="headerlink" title="固定部分"></a>固定部分</h3><p><strong>基本信息</strong><br>主要记录一些版本，服务约定，和后续数据长度。</p><ul><li>版本：占4比特，目前最广泛的是4（IPv4）</li><li>首部长度：占4比特，该字段的取单位为<strong>4个字节</strong>（即上图的一行）。<ul><li>最小十进制取值为5，即20字节固定部分</li><li>最大十进制取值为15，即20字节固定部分和40字节可变部分</li></ul></li><li>区分服务：占8比特，需要区分服务（不同等级的服务质量）时才起作用，一般不适用该字段。</li><li>总长度：占16比特，表示<strong>单位为字节</strong>的IP数据报总长度（包括首部长度）。最大值为65535，即2^16-1</li></ul><p><strong>分片信息</strong><br>主要用于IP数据报分片<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a014cde6b0ff9691.webp"></p><ul><li>标识：占16比特，同一个IP数据包的分片应该有同一个标识，类似IP</li><li>标志：占3比特：<ul><li>DF位：1个比特，1表示不允许分片；0表示允许分片。</li><li>MF位：1个比特，1表示不是最后一个分片，0表示是最后一个分片。</li><li>保留位：1个比特。</li></ul></li><li>片偏移：占13比特，表示分片数据包的“数据载荷部分”相比原数据报中的“数据载荷部分”偏移了多少。（<strong>单位为8字节</strong>，注意，由于这里的偏移量比特位小于总长比特位，为了完成表达必须使用更大的单位。）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5d538557f988dc41.webp"></li></ul><p><strong>解析信息</strong></p><ul><li>生存时间TTL：占8比特，以“跳数”为单位，每次路由器转发该IP数据包，TTL-1，若为0则丢弃。</li><li>协议：占8比特，指明IPv4数据包的数据部分向上交付给什么协议。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-94a3b7c0b1f01488.webp"></li><li>首部检验和：占16比特，检测首部在传输过程中是否出现差错。比CRC检验码简单，被称为因特网检验和。（由于TTL、片偏移、标志等可能发生变化，每次路由器转发时都要重新计算该值，耗时太大，在IPv6中已经不再计算首部校验和）</li></ul><p><strong>地址信息</strong><br>目的IP和源IP地址：各占32比特。</p><h3 id="可变部分"><a href="#可变部分" class="headerlink" title="可变部分"></a>可变部分</h3><ul><li>可选字段：长度从1到40字节不等</li><li>填充字段：确保<strong>首部长度为4字节</strong>（呼应首部长度的单位是4个字节）的整数倍，使用全0填充。</li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h3><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><div class="note note-primary">            <p>简而言之，需要一个与路由器之间的协议来<strong>监测数据的转发情况</strong>。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8739d970a0300acc.webp"></p><blockquote><p><strong>ICMP报文会被封装到IP数据报中，但其不是高层协议，而是IP层的特殊协议（起控制作用，所以也叫网际控制报文协议ICMP）。</strong></p></blockquote><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6a02675fccdc2958.webp"></p><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p><strong>终点不可达</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-855edabd9c1e6298.webp"><br><strong>源点抑制</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e7f27ef6c93c9621.webp"><br><strong>时间超过</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-49d82185c88813fe.webp"><br><strong>参数问题</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e2457fe1291c9bca.webp"><br><strong>改变路由（重定向）</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0ef50227f921ca79.webp"></p><p><strong>另外，不应发送ICMP差错报告报文情况</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a0c3a21bb04ede42.webp"></p><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（<em>Packet InterNet Groper</em>）</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-75d7bc12ca942415.webp"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（<em>traceroute</em>）</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-185af899d5e5a922.webp"><br>实现原理：<br>使用从1开始递增的TTL发送多个报文，报文在路由器超时时会返回给源主机ICMP差错报告，从而得到各跳的信息。</p><h1 id="六、虚拟专用网VPN与网络地址转换NAT"><a href="#六、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="六、虚拟专用网VPN与网络地址转换NAT"></a>六、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（<em>Virtual Private Network</em>）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>虚拟专用网络</strong>VPN的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><div class="note note-primary">            <p>顾名思义，指一种利用公网实现专用网访问的技术。</p><p>简单的说就是两个专用网络之间通过公网IP进行加密通讯。VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ad9e5dcca8c0a1c9.webp"></p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6731dbc8b1ee1abc.webp"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（<em>Network Address Translation</em>）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>目的：大量的办公室网络和家庭网络导致IP地址仍然不够，需要实现IP复用。NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p>专有NAT软件的路由器叫做NAT路由器，其有至少一个公网IP地址。</p><p>以上只解决了发送信息的问题，为了实现接受消息后的对内网用户的分发需要使用NAPT技术，具体见以下实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-05d3e1e3fd4b1998.webp"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>外网无法直接访问内网<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d2fd109d060e4853.webp"></li><li>NAT对内网主机提供了一定的安全保护<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ff43ea52e61da271.webp"></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第3章（数据链路层）</title>
    <link href="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>物理层已经保证了数据在物理层面上的传输功能，但无法避免传输中发生的错误。数据链路层作为网络层、物理层之间的桥梁，<strong>主要的职责则是保证数据传输过程的差错控制和可靠传输</strong>，即识别、纠正传输中发生的错误。</p><p>网络中的主机、路由器、交换机等都必须实现数据链路层。</p><p>术语：</p><ul><li><strong>链路</strong>（<em>Link</em>）表示一段没有交换节点<strong>物理</strong>线路</li><li><strong>数据链路</strong>（<em>Data Link</em>）表示具有通讯协议的软硬件实现的<strong>链路</strong>。</li></ul><div class="note note-primary">            <p>数据链路层的协议是多样的，两个主机之间的数据传输，可能会经过多个不同协议数据链路，他们只需要保证实现数据链路层的功能和对网络层的服务相同即可。</p>          </div><p>使用的信道类型分类：</p><ul><li>点对点信道</li><li>广播信道</li></ul><blockquote><p><strong>局域网属于数据链路层</strong><br>局域网虽然也是个互联网，但我们不将其放在网络层考虑，因为网络层的主要职责是将分组从一个网络通过路由器发送到另一个网络。而局域网的功能，使用交换机即可实现。<br>PS：路由器也可以称为三级交换机，我们平时说的交换机就是二级交换机。</p></blockquote><h2 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong><br><strong>封装成帧</strong>：将数据加上帧头和帧尾，用于<strong>帧定界</strong><br><strong>差错控制</strong>：识别传输中的错误。<br><strong>可靠传输</strong>：识别错误后确保重传。</p><blockquote><p>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决，如帧识别（确认是发给自己的帧）、数据碰撞问题（共享信道的问题）。下面我们只讲PPP的例子。</p></blockquote><blockquote><p>目前，在有线（局域网）领域使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>已经取代了<del>共享式局域网</del><br>而在无线局域网中仍然使用的是共享信道技术</p></blockquote><h1 id="二、主要职责"><a href="#二、主要职责" class="headerlink" title="二、主要职责"></a>二、主要职责</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-bf6fe42eeea3f376.webp"><br>封装成帧的目的是识别帧分界，不同数据链路层协议对此的实现是不同的：</p><ul><li>PPP，帧头和帧尾有1字节的标识符</li><li>EtherNet的V2的MAC帧，使用一个前导码，例如：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f1441c531b4d740e.webp"></li></ul><blockquote><p>为了实现定界，需要一个开始和结尾符，以太网规定开始符为前导码，结尾符的功能通过保持帧的间距（以太网还规定了帧间间隔为96比特时间）实现（说明PPP的帧是连续的？也合理，点对点连着传）</p><p>前导码包括前同步码和帧开始定界符</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧（这里是从右往左看）</li></ul></blockquote><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，因此我们要避免上层数据中也出现帧定界符导致的解析混淆。</p><p><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (<em>byte stuffing</em>) 或<strong>字符填充</strong> (<em>character stuffing</em>)，面向比特的物理链路使用比特填充的方法实现透明传输。</p><p>具体的:</p><ul><li>发送端对于上层交付数据中出现的与定界符相同的字符，在其前插入转义字符“ESC”（十六进制编码是1B），若上层数据本身有该转义字符，则再其前插入一个转义字符。</li><li>接受端将内容中的转义字符剔除即可。</li></ul><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-9d3f61fdd96b7dee.webp"></p><p>最大传送单元MTU 规定了帧的<strong>数据部分</strong>的长度上限。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><strong>比特差错</strong>：1变0，0变1<br><strong>误码率BER</strong>(<em>Bit Error Rate</em>)：错误bit占总bit的比率。</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>使用1位bit来标记 数据中“1”个数的奇偶性，只要出现两个相同类型误码就会漏检。</p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(<em>Cyclic Redundancy Check</em>)</h3><p>约定好一个生成多项式G(x)，其实就是一段bit串，如：10111<br>将这个bit串作为除数，原数据作为被除数，得到余数，这个数称为<strong>检错码</strong>，也称为<strong>帧校验序列 FCS</strong></p><blockquote><p>检错码只有检查错误的能力，<strong>不知道错误发送的位置</strong><br><strong>纠错码</strong>可以进行前向纠错，但成本高，使用少<br>CRC非常易于硬件实现，被<strong>广泛应用于数据链路层</strong><br>检查出错误后，是丢弃还是重传，往往取决于数据链路层向上层提供的是<strong>可靠传输服务</strong>还是<strong>不可靠传输服务</strong>。</p></blockquote><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><strong>比特差错</strong></p><ul><li>对于可靠传输要求实现重传，对于不可靠传输，交给上层协议处理。</li><li><strong>一般而言</strong>，有限链路不要求可靠，无线链路要求可靠（误码率高）。</li></ul><p><strong>分组丢失、分组失序、分组重复</strong><br>一般不发生在数据链路层，而是发送在上层。</p><div class="note note-primary">            <p>理解：在单条数据链路上，数据一般不会丢失。失序、重复，这些问题往往发生在网络层。</p>          </div><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/Pic0.png"></p><p>为了解决以上错误，有以下三种可靠协议，这三种协议更多体现的是一种事件确认思想，因此可以应用到各层的协议中。</p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><h4 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>发送端发送数据DATA0后，等待接受方返回一个确认信息ACK0后，再发送下一条数据DATA1。</li><li>为了防止数据的丢失、错误，需要设置<strong>重传时间</strong></li><li>为了防止数据重传造成的重复发送、接受，需要设置一个<strong>Bit位标识数据</strong>区别</li></ul><div class="note note-primary">            <p>这部分的各种特殊情况比较复杂，我们按照事件的发生进行梳理。<br>在数据传输过程中有三个基本问题需要解决：<br><strong>数据丢失</strong>（没传到）、<strong>数据错误</strong>（传错了）、<strong>数据延迟</strong>（传慢了）。</p><p>为了解决<strong>数据丢失</strong>和<strong>数据错误</strong>的问题，发送端需要重发数据，所以设置了一个超时时间，超过时间就会进行<strong>重传</strong>。（实际上对于<strong>数据错误</strong>，接受端也可以主动回复NAK提醒发送端尽快重发，但有线网内这种情况较少，一般只在误码率较高的时候进行）。</p><p>对于<strong>数据延迟</strong>的问题，理想情况其实是等待数据达到，即不需要我们解决。但实际上无法确定是数据是延迟还是丢失，也会导致触发重传，这里就衍生出了一个新问题，即<strong>发送端和接受端都可能接受到两条甚至更多相同的数据</strong>（因为接受端对每条信息都会回复确认，所以发送端也会收到两条确认ACK信息），显然我们要对后面的数据进行忽略，因此需要一个数据标识符做区分，在这里体现为一个bit。</p><p>至此，我们解决了3个基本问题和1个衍生问题。</p>          </div><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-8dbdfdbac8087fd21.webp"></p><h5 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3b4b0d81e5dd78eb.webp"></li></ul><blockquote><p>停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><div class="note note-warning">            <p>为了解决RTT过长的问题，有以下两种协议。</p>          </div><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cc9d42f63bd259cc.webp"></p><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-2a7141766ab1aa80.webp"></p><ul><li>发送方可以一次性<strong>连续发送</strong>多个数据分组，接受方每接受到一个数据就移动一次窗口，且不需要对每个分组逐个确认，一般设置在接受到若干个数据分组，对接受到的最后一个数据分组进行一次<strong>累计确认</strong>即可。</li><li>传递发生错误时，例如5号分组出现错误则丢弃，此后接收方每接受到一个不是5号的信息都会<strong>主动回复</strong>一个ACK4，请求发送端尽快发送DATA5（发送端在收到多少个ACK4后会提前发送DATA5，由具体实现决定，实际上就算收不到，也会超时重发。）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-215e8704b22ef7f2.webp"></li><li><strong>使用n位bit标识分组</strong>，则编号范围为0~2^n-1，发送窗口大小必须小于2^n-1，否则接收方会出现误判。</li></ul><div class="note note-primary">            <p>相对SW协议，GBN协议为了提高信道利用率，采用了<strong>连续发送与累计确认、主动回复</strong>等方式，在具体的实现上出现了新的问题和解决：</p><ul><li>针对<strong>连续发送与累计确认</strong>，为了识别正确接受顺序，需要使用多bit位标识数据，bit的位数也限制了发送窗口大小。</li><li>针对<strong>主动回复</strong>，客户端之前接受到错误信息和重复分组时会直接舍弃。现在客户端只舍弃错误信息，也因此会接收到许多错误分组信息（不是当前需要的分组），对这些都要进行重复确认ACK。</li></ul><p>当然，超时重传的性质依然存在，这是避免信息丢失的必要手段，主动回复只是一种加速，不是一种保证。</p>          </div><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><h5 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li><strong>扩大接受窗口的尺寸</strong>，接收方可以不用按照顺序接受分组，避免浪费。发送方也可以只重传错误分组。</li><li>由于不再按顺序接受分组，所以需要<strong>逐条确认</strong>，累计确认不再有效。发送，接受方都需要逐个确认。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=27&vd_source=7324e975d0c1b4b4719d1194e3649ff8">视频参考</a></li></ul><div class="note note-primary">            <p>相当于对分组进行批量的发送接受，只重传错误分组，重传机制仍是超时判断。接收方根据接受到的分组DATA滑动窗口，发送方根据接受到的ACK滑动窗口。</p>          </div><h1 id="三、点对点协议PPP"><a href="#三、点对点协议PPP" class="headerlink" title="三、点对点协议PPP"></a>三、点对点协议PPP</h1><ul><li>点对点协议PPP（<em>Point-to-Point Protocol</em>）是目前使用最广泛的点对点数据链路层协议。</li></ul><div class="note note-primary">            <p>端对端是P2P(Peer-to-Peer)。</p>          </div><h2 id="职责实现"><a href="#职责实现" class="headerlink" title="职责实现"></a>职责实现</h2><p>上文介绍了数据链路层的主要职责和方法，具体协议则需要对各功能做具体实现。</p><h3 id="封装成帧-1"><a href="#封装成帧-1" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>使用了帧头帧尾和对应的转义字符。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-b384615e861000f3.webp"></p><h4 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h4><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d40da4575c590f5c.webp"></li><li>面向比特的同步链路：比特填充法（插入“比特0”）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6290c73d8957ee8d.webp"></li></ul><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>使用FCS计算帧部分，立即丢弃错误帧。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-501e6b9dd2afcee3.webp"></p><h1 id="四、媒体接入控制——广播信道"><a href="#四、媒体接入控制——广播信道" class="headerlink" title="四、媒体接入控制——广播信道"></a>四、媒体接入控制——广播信道</h1><blockquote><p><em>Medium Access Control</em>翻译成媒体接入控制，有些翻译成<strong>介质访问控制</strong>，是一种主要用于局域网的数据链路层的广播通信方式。</p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>网络拓扑结构：星形、总线、环形</p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><div class="note note-primary">            <p>PPP协议是目前使用最广泛的点对点数据链路层协议，但数据链路层需要解决局域网问题，局域网常常会有共享信道，广播等需求。对于不同类型的局域网，这些需求的解决方式也不尽相同，因此又将数据链路层分为两层，一层解决类似PPP（PPP基本没有第二层问题，其独占信道）的问题，另一层解决传输媒体（主要是信道冲突）上的问题。</p>          </div><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3d6792f6b442b459.webp"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><div class="note note-primary">            <p>PPP协议对应的交换机技术可以很好的解决共享信道问题，但是无线网络仍需要共享媒体。信道复用问题之前在物理层也提过，但由于物理层主要只解决01传递的问题，这种与传媒相关的问题则交给了数据链路层的MAC子层解决。</p>          </div><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>频分复用FDM</strong> (<em>Frequency Division Multiplexing</em>)</p><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。<br><strong>时分复用TDM</strong> (<em>Time Division Multiplexing</em>)</li><li><strong>时分复用</strong>则是将时间划分为一段段<strong>等长</strong>的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。  </li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong><br><strong>波分复用 WDM</strong>(<em>Wavelength Division Multiplexing</em>)</li><li>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。<br><strong>码分复用 CDM</strong> (<em>Code Division Multiplexing</em>)<blockquote><p>复用：信道分为多个子信道，用户使用子信道。<br>多址：动态分配信道给用户，用户暂时占用信道。<br>因此码分复用更多的被称为码分多址。</p></blockquote></li></ul><p>具体实现：使用多个bit位表示1个bit位，解释如下：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-91ed6f416ae8fad6.webp"><br>这样，接受方通过向量计算即可从叠加信号中解析中指定发送方发出的信息。</p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>总线局域网</strong>使用CSMA&#x2F;CD（<em>Carrier Sense Multiple Access&#x2F;Collision Detection</em>）协议，即载波监听多址接入&#x2F;碰撞检测。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-00eb7fba113030d2.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-574d77a51611a634.webp"></p><div class="note note-primary">            <p>CD的硬件实现：判断总线电压摆动值变大超过门限。<br>为什么需要CD：CS具有传播延迟。</p>          </div><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1.准备发送-&gt;2.载波监听（信道忙则回到1）-&gt;3.发送并碰撞检测（碰撞则停止并等待一段时间回到1）-&gt;4.发送直到完毕</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a77d88a950995527.webp"></p><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-423fe21ffdbacb81.webp"></p><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-fa63a8f164fb9191.webp"></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-93f832e4b0a569ae.webp"></p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dc35877bb4bead1a.webp"></p><h4 id="帧接受过程"><a href="#帧接受过程" class="headerlink" title="帧接受过程"></a>帧接受过程</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cf2d95546ecf2664.webp"></p><div class="note note-primary">            <p>以上特性、限制都是为了在保证<strong>数据不碰撞</strong>的情况下保证<strong>合理性</strong>。<br><strong>保证不碰撞</strong>：<strong>争用期</strong>，<strong>最小帧长</strong>都是为了保证能检测信道是否有碰撞。<br><strong>合理性</strong>：<strong>最大帧长</strong>，单帧不能过长占用信道，<strong>截断二进制指数退避算法</strong>，灵活延迟避让时间，防止多次重传。</p>          </div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。<br><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong><br><strong>主要的无线网标准：802.11标准</strong><br>为什么无线局域网要使用CSMA&#x2F;CA协议：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dd01f296832d017a.webp"></p><div class="note note-primary">            <p>分布式协调功能DCF是各站点争用的方式。<br>点协调功能PCF则有一个中心站做协调，但使用较少。</p>          </div><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6c9fe4ae6927eb02.webp"><br>相比载波监听，有信道空闲持续时间限制，其控制了帧的发送间隔。</p><blockquote><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul></blockquote><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a756ebbd569e600a.webp"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><ul><li>防止多个站点同时发送数据而产生碰撞</li></ul></blockquote><p><strong>使用退避算法的时机</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f0d70f0b26645fb4.webp"></p><p><strong>CSMA&#x2F;CA协议的退避算法</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-1de197cb6f859f3c.webp"></p><p>示例：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-12262e66fc986d52.webp"></p><div class="note note-primary">            <p><strong>碰撞检测CD</strong>的思想类似于<strong>乐观锁</strong>，即先发送，发送后碰撞则进行退避处理。<br><strong>碰撞避免CA</strong>的思想类似于<strong>悲观锁</strong>，需要尽可能的保证信道通畅（通过退避的方式）然后再发送。<br>载波监听则是一种判断是否有锁的工具。</p><p>在CD中，如果当前信道空闲则直接发送信号，失败后则停止发送并等待，随后尝试重新发送。<br>在CA中，如果当前信道空闲，<strong>首先要等待一个DIFS时间</strong>，等待<strong>优先级</strong>更高的站点先尝试获取信道，这个时间之后，<strong>再根据信道的状况判断是否需要进行退避。</strong></p><ul><li><strong>DIFS时间是DCF模式（分布式协调功能）下的退避时间的基本单位。</strong></li><li><strong>默认的DIFS间隔时间并不在退避算法中</strong>。其是整个共享信道的处理完一个帧之后的间隙时间，各个站点以通过信道的这个间隙时间来判断信道进入了空闲状态（空闲了一个DIFS时间），然后解冻倒计时，进行<strong>优先级</strong>争夺。</li></ul>          </div><h4 id="信道预约和虚拟载波监听"><a href="#信道预约和虚拟载波监听" class="headerlink" title="信道预约和虚拟载波监听"></a>信道预约和虚拟载波监听</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-98353d62c0ef033f.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ac35b15f5f22bf7d.webp"></p><div class="note note-primary">            <p>以上为可选功能，通过向目的站发送“要发送数据帧”的请求（<strong>信道预约</strong>），目的站同意这个请求后发出“允许发送数据帧”的广播，此时其他站点就不能使用该信道了。由于RTS、CTS都携带了下次传递的大数据帧信息，因此其他站点知道本次信道会被占用的时间，实现了<strong>虚拟载波</strong>。<br>此时，如果其他站只能监听到目的站信息，监听不到源站信息，其也可以收到CTS从而避免在这个时间段内发送信息，减少了隐蔽站的问题。</p>          </div><h1 id="五、MAC地址、IP地址、ARP地址"><a href="#五、MAC地址、IP地址、ARP地址" class="headerlink" title="五、MAC地址、IP地址、ARP地址"></a>五、MAC地址、IP地址、ARP地址</h1><p>三者的关系：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ede2c92a0c809e6c.webp"></p><h2 id="MAC-Media-Access-Control-地址"><a href="#MAC-Media-Access-Control-地址" class="headerlink" title="MAC(Media Access Control)地址"></a>MAC(<em>Media Access Control</em>)地址</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><div class="note note-primary">            <p>注意：MAC地址的主要作用标记目的物理地址和源物理地址，在<strong>广播信道</strong>中，所有站点都会接受到MAC帧（也可以由交换机进行调度），然后根据目的物理地址是自身而决定是否舍弃该帧，但对于<strong>点对点的信道（不是协议）</strong> 则不需要MAC帧。</p>          </div><blockquote><ul><li><strong>MAC地址又称为硬件地址或物理地址</strong>。但其属于数据链路层而不是物理层。</li><li>MAC地址是对网络上各接口的唯一标识。</li></ul></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-70ee74506eca1df4.webp"></p><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。<br>无效MAC帧：</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；<br>（防止bit丢失）</li><li>用收到的帧检验序列 FCS 查出有差错；<br>（防止bit错误）</li><li>数据字段的长度不在 46 ~ 1500 字节之间。<br> (防止bit增加)<br>以太网检测到无效MAC帧直接丢弃。</li></ul><p>MAC帧发送顺序</p><ul><li>从第一字节发到第六字节</li><li>每字节从b0发到b7</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>单播（单选）：根据站点根据目标地址与自己是否相符决定是否舍弃。</li><li>广播（全选）：<strong>广播MAC地址为全F</strong>，所有站点都接受该帧</li><li>多播（多选）：只发送给指定的若干目的站点。<strong>多播MAC帧的目的地址的第一个bit为1</strong>，即第一个字节的b0位为1。其他站点是否接受则根据自身多播组列表设置。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴。</p><ul><li>对于局域网而言MAC地址即可区分设备（但现在实际上还是会使用IP地址而不是MAC地址）。</li><li>对于因特网而言MAC地址无法区分一个网络，需要使用IP地址加MAC地址。</li><li>例子：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-77c204bc8181b3ed.webp"></li></ul><div class="note note-primary">            <p>参考现实中根据地图导航。<br><strong>IP地址</strong>用来标记起点和终点，从起点到终点需要经过很多交通工具。<br><strong>MAC地址</strong>根据目的IP地址选择当前交通应该在哪站下车然后换乘。<br>这个根据IP地址选择下车站的方法就是<strong>ARP协议</strong></p>          </div><h2 id="ARP协议（地址解析协议Address）"><a href="#ARP协议（地址解析协议Address）" class="headerlink" title="ARP协议（地址解析协议Address）"></a>ARP协议（地址解析协议Address）</h2><p>主机都有一个ARP高速缓存表，其中记录了IP地址和MAC地址的映射。</p><ul><li>如果表中记录了IP地址对应的MAC地址，则可以直接填写目的MAC地址发送MAC帧。</li><li>如果不知道，则发送<strong>ARP请求报文</strong>（广播）。目的IP地址的主机接受到该请求后会给源主机回复自己的MAC地址。</li></ul><p><strong>ARP高速缓存表</strong><br>有动态记录和静态记录。</p><ul><li>动态记录为自动获取，有持续时间、过期作废（默认两分钟）</li><li>静态记录为手工设置，始终保存（实际上依赖于操作系统的实现）。</li></ul><blockquote><p>ARP是逐段链路进行的。即主机只记录和自己直接连接主机的MAC地址，跨网络的地址则不管。</p></blockquote><div class="note note-primary">            <p>这里的ARP的作用主要是让机器通过广播形式学习和自己直连的设备的IP-MAC映射关系，<strong>方便其填入MAC帧的目的地址</strong>，并不能告知他应该如何把数据准确的发送到哪个主机。</p><p>ARP没有安全验证机制，可能<strong>存在ARP欺骗（攻击）问题</strong>。</p><p>ARP表中记录<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>          </div><h1 id="六、集线器和交换机"><a href="#六、集线器和交换机" class="headerlink" title="六、集线器和交换机"></a>六、集线器和交换机</h1><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>在总线型网络中，所有站点共享一个信道。但总线的拓扑结构在<strong>物理层</strong>实现很不方便，所以可以使用集线器作为中点，网络结构则变成了<strong>星型结构</strong>。</li><li>但实际上其在以太网上仍是一个<strong>总线型网络</strong>。集线器也只工作在物理层，并没有网络管理作用。</li><li>集线器是也可以看做多口<strong>中继器</strong>，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>扩展网络（<strong>扩大广播域</strong>），两个集线器直接连接即构成了更大的总线网络。但<strong>碰撞域</strong>却增大了。</p><blockquote><p><strong>碰撞域</strong>（<em>collision domain</em>）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p></blockquote><div class="note note-primary">            <p>集线器工作在物理层，而下文中的交换机工作在数据链路层。</p>          </div><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是网桥的替代品，是一个多接口的网桥。<br><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃（<strong>具有管理作用</strong>）。<br><strong>交换机</strong></li><li>1990 年问世的交换式集线器 (<em>switching hub</em>) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (<em>switch</em>) 或<strong>第二层交换机</strong> (<em>L2 switch</em>)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul><p>相对于集线器，其可以进行ARP自学习，并将数据帧定向转发。</p><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度</li><li>不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d5c429a2f92149ff.webp"></p><p><strong>扩大广播域</strong>的同时，<strong>隔离碰撞域</strong></p><blockquote><p><strong>广播域</strong>（<em>broadcast domain</em>）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。注意要与前面的碰撞域做区分。</p></blockquote><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-25db1be3ca96bc2f.webp"></p><h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>以太网交换机通过<strong>自学习算法</strong>建立<strong>帧交换表</strong></p><h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><ul><li>交换机接受到一个数据帧后就会记录这个帧的<strong>源地址</strong>和对应的交换机<strong>端口</strong>（没有则插入，有则更新）</li></ul><h4 id="转发行为"><a href="#转发行为" class="headerlink" title="转发行为"></a>转发行为</h4><ul><li>交换接的帧交换表中如果有该帧<strong>目标地址</strong>对应的端口，则直接将消息转发到该端口，否则发送<strong>广播</strong>（但不对源地址发送）。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每条记录都有有效时间，有效时间到期后删除。（主机可能换网卡，交换机可能改接另一台主机）</li></ul><div class="note note-primary">            <p>注意本处的自学习和前面提到的ARP的异同：<br>异：</p><ul><li>ARP记录的是IP和MAC地址之间的映射关系，记录在ARP高速缓存表中。交换机的自学习记录的是MAC地址与自己的端口的关系，记录在帧交换表中。</li><li>ARP高速缓存表主要用于根据上层的目的IP地址填入目的MAC地址。交换机帧纪录表则用于根据目的MAC地址选择往哪个端口发送。</li><li>实现在不同层面，ARP的实现在逻辑上，依赖于非目标主机会自行舍弃帧；交换机实现在物理上，依赖于只发送给目标机。可以认为交换机是对ARP的总线结构下的一种信道层面优化，减少了各个客户端识别帧的负担并解决碰撞问题。<br>同：</li><li>有已知记录时都会直接发送，没有时都会进行广播学习。</li></ul>          </div><h1 id="七、生成树协议STP"><a href="#七、生成树协议STP" class="headerlink" title="七、生成树协议STP"></a>七、生成树协议STP</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>想要提高以太网的<strong>可靠性</strong>，可以尽可能多的添加交换机之间的连线（<strong>冗余链路</strong>）。这样两个交换机之间就不会因为一条链路出现故障而无法通讯。但这样会造成重复广播等问题，因此需要避免<strong>逻辑上的环路</strong>（保留物理上的环路以备用）。</p><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a65d811129786ec6.webp"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</p></blockquote><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (<em>Spanning Tree Protocol</em>)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><h1 id="八、虚拟局域网VLAN"><a href="#八、虚拟局域网VLAN" class="headerlink" title="八、虚拟局域网VLAN"></a>八、虚拟局域网VLAN</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>集线器和交换机扩大了广播域，但是广播域过于又会造成广播风暴，我们希望能够实现局部广播功能。</p><p><strong>广播风暴</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a2a78b40ae5307db.webp"></p><h2 id="分割局域网的方法"><a href="#分割局域网的方法" class="headerlink" title="分割局域网的方法"></a>分割局域网的方法</h2><ol><li>使用路由器</li><li>VLAN(<em>Virtual LAN</em>)虚拟局域网</li></ol><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>： <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li></ul></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>本质上是要求使用<strong>交换机</strong>实现逻辑上将一个局域网划分成几个虚拟局域网（将一个交换机分成多个交换机），即判断一条广播消息属于哪一个组，因此这种MAC帧需要多一个明确的标识符以供交换机判断。</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-5d3549cc02f9a3b4.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6af352f81b800a98.webp"></li></ul><h3 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h3><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-44a2e259c33ecfd3.webp"></p><h4 id="Truck端口"><a href="#Truck端口" class="headerlink" title="Truck端口"></a>Truck端口</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a93996aae716c6aa.webp"></p><h4 id="Hybrid端口"><a href="#Hybrid端口" class="headerlink" title="Hybrid端口"></a>Hybrid端口</h4><p>是华为私有的端口类型，既可以用于交换机之间或交换机与路由器之间互连，也可以用于交换机与计算机之间互联。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-primary">            <p>数据链路层主要要负责将数据正确的送到目的地。</p><p>其需要在逻辑上实现其职责(逻辑链路控制LLC)：封装帧、差错检测和可靠重传。典型实现是PPP。</p><p>也需要与物理层的交界处实现对共享媒体控制(媒体接入控制MAC)：控制共享媒介的使用策略。典型实现是CSMA&#x2F;CA协议。</p><p>以上内容保证了数据的完整性，但我们还需要保证数据能正确送到指定主机或进行广播。因此需要ARP表来指明目的主机的MAC地址。</p><p>集线器与普通总线结构网络没有区别，而交换机则在可以根据目标MAC地址定向转发MAC帧，避免了碰撞问题，扩大了广播域。</p><p>最后，由于广播域的扩大会造成广播风暴，也有以下两种解决方法：</p><ul><li>为了避免循环广播，需要生成树协议。</li><li>为了避免广播到不必要的区域，需要VLAN。</li></ul>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/6b82134a4325">计算机网络第3章（数据链路层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第2章（物理层）</title>
    <link href="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、物理层的基本概念"><a href="#一、物理层的基本概念" class="headerlink" title="一、物理层的基本概念"></a>一、物理层的基本概念</h1><p>物理层主要考虑如何传输数据比特流。</p><h1 id="二、物理层传输媒体"><a href="#二、物理层传输媒体" class="headerlink" title="二、物理层传输媒体"></a>二、物理层传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><ol><li>同轴电缆（已被淘汰）</li><li>双绞线（主要用于局域网）</li><li>光纤（主要用于ISP接入服务）<ul><li>多模光纤：允许多条不同角度的光纤同时传输</li><li>单模光纤：如同一根波导，没有反射</li></ul></li><li>电力线（主要用于家庭网络扩展：猫）</li></ol><h2 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h2><ol><li>无线电波（波长1m-10km）</li><li>微波（波长1mm-1m）</li><li>红外线（已淘汰，只能直线传输）</li><li>可见光（LIFI）</li></ol><h1 id="三、传输方式"><a href="#三、传输方式" class="headerlink" title="三、传输方式"></a>三、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><strong>串行传输</strong>：数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可<br><strong>并行传输</strong>：一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p><div class="note note-primary">            <p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>          </div><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><strong>同步传输</strong>：以<strong>比特流</strong>的形式传输。字节之间没有间隔。<br><strong>异步传输</strong>：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</p><p>同步传输需要解决时钟问题，即数据的接收方如何判断哪一部分是一个字节：<br>对于同步传输，有两种方式同步时钟：</p><ul><li>外同步：添加独立时钟信号线</li><li>内同步：通过编码信息判断</li></ul><p>异步传输把字节之间断开，根据字节开始和结尾判断即可：</p><ul><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><h2 id="单双工"><a href="#单双工" class="headerlink" title="单双工"></a>单双工</h2><p>信道（<em>channel</em>）：信道一般都是用来表示向某一个方向传送信息的媒体。</p><p>单工：单向传输<br>半双工；双向（不能同时，需要两条信道）<br>双工：双向（同时，需要两条信道）</p><h1 id="四、编码和调制"><a href="#四、编码和调制" class="headerlink" title="四、编码和调制"></a>四、编码和调制</h1><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-acc59055804f0890.webp"></p><blockquote><p>术语：<br><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote><div class="note note-primary">            <p>编码和调制主要解决如何将0，1比特流转化为可以传输的信号形式。<br>码元（code）：对于本章的学习，可以理解为表示一个比特的单元波形。<strong>实际上，根据编码的不同，一个码元可以对应于几个比特，但也可以是几个码元对应于一个比特</strong>。</p><p>基带信号：表示数据传输前的原始信号。</p><p>针对不同的信道（媒介）有不同的方式：</p><ul><li>对于数字信道，其可以清楚的区分电平的高低，因此可以采用<strong>编码</strong>的方式处理原始信号。</li><li>对于模拟信道，一般使用波作为媒介，需要通过控制信号的频率和相位（即<strong>调制</strong>）的方式处理原始信号</li></ul>          </div><blockquote><p>严格来说，传输媒体 ≠ 信道，使用信道复用技术时，一条传输媒体可以包含多个信道。</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>不归零编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-0732d0edc74846b5.webp"><br>缺点：没有时钟同步。<br><strong>归零编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-8aa838a116fdafb4.webp"><br>缺点：每个码元都要归零，数据量太大，编码效率低。<br><strong>曼彻斯特编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-a34a686a9d052e9c.webp"><br>通过跳变方向判断比特位。</p><div class="note note-primary">            <p>相对归零编码，省去了当比特变化为<code>10101010</code>样式时的归零行为，不过对于<code>00000000</code>形式的编码，数据量仍比较大，每次上升后需要在码元间隙下降，如上图的第二个0后面，以便于下一次上升。</p><p>问题：<br>这个码元间隙的下降行为是否导致时钟的误判问题。<br>解释：<br>所谓时钟同步，可以理解为一个打点计时器（？），设备根据打点瞬间电信号的电平判断这个比特位为0还是1，所以若是打点计时器的频率或初始时间与发送端不一致，就会得到失真的信号，这种现象也叫时钟滑移。<br>而曼彻斯特码元间的下降&#x2F;上升行为其实不会被视为下降沿&#x2F;上升沿，因为其实这种编码还是有一个隐藏时钟。对于设备来说，其可以判断接受到的电信号的最短时间间隔，从而判断一个码元的时间长度。（1个码元时间&#x3D;2个最短时间间隔），这样就解决了频率问题。<br>而一个码元单元必然有一个跳变，码元之间不一定有，从而解决了相位问题。</p>          </div><p><strong>差分曼彻斯特编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-9a758474e374329a.webp"><br>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li>跳变仅表示时钟</li><li>码元开始处电平是否变换表示数据<br>优点：比曼彻斯特编码的变化少，曼彻斯特编码为了得到正确的跳变方向有时需要在码元结束时置反，即（连续1和连续0时会导致码元间置反），而这里连续0<strong>或</strong>连续1时（具体看规定变化为0还是1），不需要进行置反。变化相对少一些。</li></ul><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。<br>每个基本波形只能表示1比特信息量。</li></ul><h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><ul><li>在编码中两个电位（一个表示时钟一个表示值）的信息即可表示1比特信息。而对于模拟信号，其有更多维度的信息（同上调制的基本方法），因此可以尝试使用一个码元表示多个比特。</li><li>频率就是相位的变化速率，因此两者不可同时调制。</li></ul><p><strong>正交振幅调制QAM</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1cb6de826ba63b70.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1e2617434d904ce4.webp"></p><ul><li>给出了12个相位（角度），其中有4个角度（45°）有两个振幅，则共有：8 * 1 + 4 * 2 &#x3D; 16种码元。</li><li>故一个码元的信息量为 2^4，可以表示4位bit。</li></ul><h1 id="五、信道的极限容量"><a href="#五、信道的极限容量" class="headerlink" title="五、信道的极限容量"></a>五、信道的极限容量</h1><p>传输信号时会产生各种失真。</p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p>如何尽可能地避免失真：</p><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-b90918937a54faa6.webp"></p><div class="note note-primary">            <p>奈氏准则主要给出一条信道的最高码元传输效率（理论）<br>波特率：码元传输速率<br>比特率&#x3D;波特率 * 每波特携带比特数<br>那么要提高比特率，则要提高每波特携带比特数。</p>          </div><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-57e105e5df793b93.webp"></p><div class="note note-primary">            <p>信噪比：理解起来可以视为信号相对噪音的占比，这个值越大，极限传输速率越高。</p>          </div><div class="note note-info">            <p>奈氏准则主要指出<strong>码元比特量</strong>对传输极限的影响。<br>香农准则主要指出<strong>信噪比</strong>对传输极限的影响。</p>          </div><h1 id="六、信道复用技术"><a href="#六、信道复用技术" class="headerlink" title="六、信道复用技术"></a>六、信道复用技术</h1><h2 id="复用技术类型"><a href="#复用技术类型" class="headerlink" title="复用技术类型"></a>复用技术类型</h2><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽（频率带宽）资源</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-bcb9321a6a8a3d7a.webp"></li><li><strong>时分复用TDM</strong>（<em>Time Division Multiplexing</em>）则是将时间划分为一段段等长的**时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。（可能浪费）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-cb9a20b7ce00d497.webp"></li><li><strong>统计时分复用 STDM</strong> (<em>Statistic TDM</em>)，弥补时分中的浪费，按需分配。<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-7f0b54d1c14702ca.webp"></li><li><strong>波分复用WDM</strong>(<em>Wavelength Division Multiplexing</em>)<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-039cdf67599ebe3b.webp"></li><li><strong>码分复用</strong>（<em>Code Division Multiplexing</em>），常用的名词是<strong>码分多址</strong> CDMA (<em>Code Division Multiple Access</em>)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/792648675640">计算机网络第2章（物理层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第1章（概述）</title>
    <link href="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <url>/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong>互连网</strong>（<em>internet</em>）：多个网络通过路由器互连起来构成的网络（通用名词，可使用任意协议）<br><strong>因特网</strong>（<em>Internet</em>）：是世界上最大的互连网（专有名词，使用TCP&#x2F;IP协议）<br><strong>ISP</strong>（<em>Internet Service Provider</em>）：因特网服务提供者，如电信、联通、移动。</p><p><strong>端系统之间通信</strong>：主机 A 的某个进程和主机 B 上的另一个进程进行通信。</p><div class="note note-primary">            <p>端对端通讯分为两大类：C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p>          </div><h1 id="二、交换方式"><a href="#二、交换方式" class="headerlink" title="二、交换方式"></a>二、交换方式</h1><h2 id="1-电路交换（Circuit-Switching）"><a href="#1-电路交换（Circuit-Switching）" class="headerlink" title="1.电路交换（Circuit Switching）"></a>1.电路交换（<em>Circuit Switching</em>）</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-acb87df045723236.webp"></p><blockquote><p>步骤：<br>1.建立连接 2.通话 3.释放连接</p></blockquote><h2 id="2-分组交换（Packet-Switching）"><a href="#2-分组交换（Packet-Switching）" class="headerlink" title="2.分组交换（Packet Switching）"></a>2.分组交换（<em>Packet Switching</em>）</h2><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>称为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方：</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器：</p><ul><li>缓存分组</li><li>转发分组</li></ul><p>接收方：</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h2><p>报文交换对报文的大小没有限制，主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="4-对比"><a href="#4-对比" class="headerlink" title="4.对比"></a>4.对比</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e655a213714d1871.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-c56f91f290cbc92b.webp"></p><h1 id="三、定义与分类"><a href="#三、定义与分类" class="headerlink" title="三、定义与分类"></a>三、定义与分类</h1><h2 id="按覆盖范围"><a href="#按覆盖范围" class="headerlink" title="按覆盖范围"></a>按覆盖范围</h2><ul><li>广域网WAN（<em>Wide Area Network</em>）</li><li>城域网MAN（<em>Metropolitan</em>）</li><li>局域网LAN（<em>Local</em>）</li><li>个域网PAN（<em>Personal</em>）</li></ul><h2 id="按结构"><a href="#按结构" class="headerlink" title="按结构"></a>按结构</h2><ul><li>总线<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-4ed63e74d9ced719.webp"></li><li>星型<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f6a1849bcc443935.webp"></li><li>环形<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ca133aaaf8fe8659.webp"></li><li>网络<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-d0d30cddc7356396.webp"></li></ul><h1 id="四、性能指标"><a href="#四、性能指标" class="headerlink" title="四、性能指标"></a>四、性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ba6c4e627a62c05e.webp"></p><div class="note note-primary">            <p>速率的k一般指1000，数据量的k为1024</p>          </div><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f4b18e0039f4a6c6.webp"></p><div class="note note-primary">            <p>带宽在模拟信号中指频率范围，在计网中指最高<strong>速率</strong>。<br>关联在于，频率越高，速率越高。</p>          </div><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位时间通过某网络的数据量</p><div class="note note-primary">            <p>带宽相当于理论值、吞吐量为真实值。</p>          </div><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</p><blockquote><p>有时会把排队时延看成<strong>处理时延的一部分</strong><br>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><div class="note note-primary">            <p>m &#x3D; 2 * 10^8</p>          </div><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><div class="note note-primary">            <p>表示链路上有多少个bit正在流动</p>          </div><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>RTT(<em>Round-Trip Time</em>)</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-62d6da59682ef67f.webp"></p><div class="note note-primary">            <p>信道利用率针对具体信道，网络针对全网络信道，都是对时间的利用统计。</p>          </div><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>一定时间范围内，丢失分组数量与总分组数量的比率</p><h1 id="五、体系结构"><a href="#五、体系结构" class="headerlink" title="五、体系结构"></a>五、体系结构</h1><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b5174af1551d6cee.webp"></p><div class="note note-primary">            <p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。<br>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>          </div><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6800e214b18c47c3.webp"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="1-发送"><a href="#1-发送" class="headerlink" title="1.发送"></a>1.发送</h3><p>应用层（<strong>HTTP请求报文</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ac36f7a9544dde9f.webp"><br>传输层（<strong>TCP报文段</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-cc2b73b1736d5809.webp"><br>网络层（<strong>IP数据报</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-dc02183dcf759d9e.webp"><br>数据链路层（<strong>帧</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f8cf8ce4a6bfdb54.webp"><br>物理层（<strong>比特流</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e7285afa504bce0d.webp"></p><h3 id="2-路由转发"><a href="#2-路由转发" class="headerlink" title="2.路由转发"></a>2.路由转发</h3><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b9824f4625354b9b.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-09a0b27933c9895e.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6eace5a882cca26d.webp"><br>再整个封装回去。</p><div class="note note-primary">            <p>路由器主要作用在网络层及以下，主要根据路由表查询端口转发IP数据包。</p>          </div><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>实体：任意可发送或接受信息的硬件或进程</li><li>对等实体：相同层次的实体</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-01d621fd0afde0a2.webp"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合<br>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f9bd7898a7f2dadd.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/541d4f0c0f1e">计算机网络第1章（概述）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>100 - 计算机网络 - 概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-基础篇</title>
    <link href="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP-x2F-IP网络模型"><a href="#一、TCP-x2F-IP网络模型" class="headerlink" title="一、TCP&#x2F;IP网络模型"></a>一、TCP&#x2F;IP网络模型</h1><p>主要针对TCP&#x2F;IP网络模型。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层</strong>（<em>Application Layer</em>）只专注于提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="传输层"></p><p>传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p><strong>TCP</strong> 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p><strong>UDP</strong> 只负责发送数据包，不保证数据包是否能抵达对方。但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><h3 id="应用层与传输层的交互"><a href="#应用层与传输层的交互" class="headerlink" title="应用层与传输层的交互"></a>应用层与传输层的交互</h3><p>应用需要传输的数据可能会非常大，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E6%AE%B5.png" alt="TCP段"></p><p>传输层其实并不负责整个传输过程，它的作用是相对应用层而言的，即它可以帮助应用层实现数据传输。</p><p>到传输层数据到达目标设备时，传输层则要负责把数据包传给应用，但一台设备有多个应用，这时需要使用端口号将应用区分开来。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层报文中携带端口号，因此可以识别数据要发给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>如上所述，传输层其实主要做区分应用，把应用数据下发的作用，真正使数据在互联网上传输的功能在<strong>网络层</strong>（<em>Internet Layer</em>）上。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/12.jpg" alt="MAC"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p><p>将IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>配合<strong>子网掩码</strong>，可以将一个网络号同时给多个主机使用，子网掩码则用于计算 网络号和主机号。</p><p>如10.100.122.0&#x2F;24后面的<code>/24</code>表示就是 <code>255.255.255.0</code>，将IP地址与子网掩码按位与，得到网络号，与子网掩码的取反按位与，则得到主机号。</p><p>寻找目标地址的过程，就是一个寻找网络-&gt;寻找主机的过程。</p><p><strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网路接口层"><a href="#网路接口层" class="headerlink" title="网路接口层"></a>网路接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="网络接口层"></p><p>网络层实现了信息在互联网上传输的功能，而要将信息传输到互联网，我们还需要经过网络接口层。</p><p>网络接口层的功能主要体现在以太网技术上，即通过局域网把网络包发送到目的地。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务。个人理解是在数据的传输中，数据包会经过很多交换机，交换机会将数据包解包至网络接口层，然后再封装，发送。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>使用 MAC 地址，我们可以标识网络上的设备，实现在以太网、WiFi 这样的底层网络上发送原始数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="tcpip参考模型"></p><p>封装格式：</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.png" alt="封装"></p><div class="note note-info">            <p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>          </div><blockquote><p>应用层负责将应用产生的数据传递给传输层，将从传输层接受到的数据组合，返回给应用。</p><p>传输层负责将从应用层接受到的数据包传递给网络层，这个过程会携带应用端口</p><p>网络层负责将从传输层接受到的数据包发送到网络，这个过程会携带IP地址（网络号+主机号&#x2F;子网掩码）</p><p>网络接口层负责将网络层的数据通过以太网技术的方式发送到数据库</p></blockquote><h1 id="二、浏览器请求过程"><a href="#二、浏览器请求过程" class="headerlink" title="二、浏览器请求过程"></a>二、浏览器请求过程</h1><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/2.webp"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-解析URL"><a href="#1-解析URL" class="headerlink" title="1.解析URL"></a>1.解析URL</h3><p>浏览器先解析URL地址，然后生成给WEB服务器的信息。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/3.webp"><br>如果省略资源路径，则会访问Web服务根目录的<code>index.html</code>或<code>default.html</code></p><h3 id="2-生成HTTP请求信息"><a href="#2-生成HTTP请求信息" class="headerlink" title="2.生成HTTP请求信息"></a>2.生成HTTP请求信息</h3><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/4.webp"></p><div class="note note-primary">            <p>HTTP报文三要素：</p><ul><li>请求报文：请求行(req)+请求头(head)+请求体(body)</li><li>响应报文：状态行(status)+消息头(head)+消息体(body)</li></ul>          </div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>消息发送前需要<strong>查询服务器域名对应的 IP 地址</strong><br>因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DNS是一种服务器，其专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>，这与中文相反。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。即<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><p>所以实际上是 .  –&gt; .com –&gt;server<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5.webp"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><p>也就是说，查询域名IP时：</p><ol><li>客户端只会向最近的本地DNS服务器请求ip地址。</li><li>本地DNS服务器若记录了ip地址，则直接返回，若没有记录，则进行以下操作。</li><li>本地DNS向根DNS服务器请求ip地址，根DNS将.com的DNS服务器给本地DNS服务器。</li><li>本地DNS服务器再向.com的DNS（顶级域名服务器）请求ip地址，顶级域名服务器将<a href="http://www.server.com的权威/">www.server.com的权威</a> DNS 服务器给本地DNS服务器。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接。</li></ol><div class="note note-warning">            <p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明目标服务器的位置。</p>          </div><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/6.webp"></p><blockquote><p>DNS 域名解析的过程是一个<strong>只指路不带路</strong>的过程。</p></blockquote><div class="note note-primary">            <p>当然，浏览器、操作系统、hosts文件都有缓存，在这些地方都找不到时才会向本地DNS服务器发请求。</p>          </div><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><div class="note note-primary">            <p>注意这里开始进入操作系统层面。</p>          </div><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7.webp"></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。</p><p>协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><p>进入协议栈后，就依靠各层协议一步一步完成数据传输。 </p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>HTTP 是<strong>基于 TCP 协议</strong>传输的，TCP报文格式如下：<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/8.webp" alt="TCP报文"></p><p>理解：</p><ul><li><strong>源端口号</strong>和<strong>目标端口</strong>号：这是与应用层交互的关键识别信息。</li><li>包<strong>序</strong>号，防止乱序</li><li><strong>确认号</strong>，防止丢包</li><li><strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>：TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，从而实现<strong>拥塞控制</strong>：即控制发送的速度。</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓的握手就是使通讯双方维护一个状态机。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"></p><blockquote><p>SYN指<strong>SYN：同步序列编号</strong>（ Synchronize Sequence Numbers ）<br>ACK指<strong>ACK：确认字符</strong>（Acknowledge character）</p></blockquote><div class="note note-success">            <p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>          </div><div class="note note-primary">            <p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>          </div><h3 id="TCP数据分割"><a href="#TCP数据分割" class="headerlink" title="TCP数据分割"></a>TCP数据分割</h3><p>若HTTP请求报文较长，超过了 <code>MSS</code> 的长度则需要拆解。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/11.webp"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/12.webp"></p><p>拆分出来的每一块数据都会被放进单独的网络包中，分别加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13.webp"></p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/14.webp"></p><ul><li>IP包头的<strong>协议号</strong>，要填写为<code>06</code>（十六进制），表示协议为 TCP。</li></ul><h3 id="网卡选择"><a href="#网卡选择" class="headerlink" title="网卡选择"></a>网卡选择</h3><p>如何填写源地址IP？<br>根据<strong>路由表</strong>规则，判断哪个网卡作为源地址。<br>使用 <code>route -n</code> 命令查看当前系统的路由表。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/15.webp"></p><ol><li>将目标IP地址与掩码逐行做 <strong>与运算</strong>，如果等于目的Destination，则匹配成功。</li><li>如果都无法匹配，则匹配最后一行，将IP发送给路由器（<strong>默认网关</strong>）</li></ol><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18.webp"></p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ：IP协议</li><li><code>0806</code> ：ARP协议</li></ul><p><strong>接收方MAC地址如何填写？</strong><br>ARP协议，通过广播的方式获取以太网中路由器的MAC地址。<br>ARP有缓存空间（几分钟），可以先查询缓存，未命中才广播。</p><h2 id="出口-网卡"><a href="#出口-网卡" class="headerlink" title="出口-网卡"></a>出口-网卡</h2><p><strong>数字信息转换为电信号</strong>。<br>通过网卡（硬件）+网卡驱动程序（软件）一起完成数据的发送。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.webp"></p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。<br>交换机：</p><ol><li>电信号-&gt;数字信号</li><li>MAC帧FCS矫错</li><li>根据MAC帧地址转发MAC帧</li><li>找不到则广播（除源端口）</li><li>只有相应的接受者才会接受MAC帧</li></ol><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/23.webp"></p><p>PS：这里注意<strong>交换机的端口不具有MAC地址</strong>，其只起转发包作用。</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/24.webp"></p><p>路由器工作：</p><ol><li>接受发送给自己的MAC帧</li><li>FCS矫错</li><li>根据帧中IP查找路由表，确定对应的接口</li><li>若找不到则选择默认路由。</li><li>要根据目标IP行的网关列判断发送到目标IP后是否还需要继续转发<ul><li>网关为IP地址，说明还要继续转发（IP聚合）</li><li>网关为空，则说明达到了目标地址</li></ul></li><li>根据ARP协议，使用IP地址查询MAC地址（路由器也有ARP缓存）</li><li>发送</li></ol><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h2 id="服务端与客户端"><a href="#服务端与客户端" class="headerlink" title="服务端与客户端"></a>服务端与客户端</h2><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/25.webp"></p><h1 id="三、Linux系统如何收发网络包"><a href="#三、Linux系统如何收发网络包" class="headerlink" title="三、Linux系统如何收发网络包"></a>三、Linux系统如何收发网络包</h1><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/OSI%E4%B8%8ETCP.webp"></p><h2 id="Linux-网络协议栈"><a href="#Linux-网络协议栈" class="headerlink" title="Linux 网络协议栈"></a>Linux 网络协议栈</h2><p>封装：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.webp"><br>以太网中，规定了最大传输单元（MTU）是 <code>1500</code> 字节，也就是规定了单次传输的最大 IP 包大小。</p><p>Linux网络栈：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8D%8F%E8%AE%AE%E6%A0%88.webp"></p><ul><li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li><li>Socket 层的下面就是传输层、网络层和网络接口层；</li></ul><h2 id="Linux接受包"><a href="#Linux接受包" class="headerlink" title="Linux接受包"></a>Linux接受包</h2><p>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>方式：</p><ul><li>触发中断：也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。（网络包过多时中断也太多，过时）</li><li><strong>NAPI 机制</strong>：<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</li></ul><p>硬件中断处理函数会做如下的事情：</p><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免CPU不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<br>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><h3 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.webp"></p><h2 id="Linux-发送网络包的流程"><a href="#Linux-发送网络包的流程" class="headerlink" title="Linux 发送网络包的流程"></a>Linux 发送网络包的流程</h2><ol><li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的sk_buff内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li><li>网络协议栈从 Socket 发送缓冲区中取出sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</li><li>TCP 传输协议发送数据，那么<strong>先拷贝一个新的sk_buff 副本</strong>，这是因为sk_buff后续在调用网络层，最后到达网卡发送完成的时候，这个sk_buff会被释放掉。而TCP协议是支持丢失重传的，在收到对方的ACK之前，这个sk_buff不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</li><li>对 sk_buff 填充 TCP 头。sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</li><li>交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</li><li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。</li><li>这一些工作准备好后，会触发「<strong>软中断</strong>」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将sk_buff数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li><li>当发送完成的时候，网卡设备会触发一个<strong>硬中断</strong>来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li></ol><p>通过调整 sk_buff 中 <code>data</code> 的指针，比如：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/sk_buff.webp"><br>即可实现使用同一个数据结构描述各层的数据。</p><p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p><ul><li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li><li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
