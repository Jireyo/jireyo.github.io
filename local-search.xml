<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM中篇:字节码与类加载</title>
    <link href="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Class文件结构"><a href="#一、Class文件结构" class="headerlink" title="一、Class文件结构"></a>一、Class文件结构</h1><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td></tr></tbody></table><blockquote><p>其中un表示有n个字节。</p></blockquote><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>u4<br><code>0xCAFEBABE</code></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>u2+u2<br>主版本号和副版本号一起构成版本号：M.m<br>不同编译器的class文件不同，目前JVM可以向下兼容。</p><h2 id="常量池集合"><a href="#常量池集合" class="headerlink" title="常量池集合"></a>常量池集合</h2><p>u2(常量数量)+ cp_info（常量表大小）</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>u2，从1开始计数，所以constant_pool_count&#x3D;1时说明有0个常量。</p><div class="note note-primary">            <p>因为0索引被空出来作为“空常量”</p>          </div><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool"></a>constant_pool</h3><p>1 ~ constant_pool_count - 1为索引<br>主要存放<strong>字面量Literal</strong>和<strong>符号引用Symbolic References</strong>，其包含该class文件中如下内容：</p><ul><li>字面量<ul><li>字符串</li><li>final常量</li></ul></li><li>符号引用<ul><li>类，接口名</li><li>方法名</li><li>字段名</li></ul></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>使用1byte表示该常量的类型：如字符串、符号引用等，即下表中的tag，剩余的部分根据类型不同而不同。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201163645.png"><br>其中：只有CONSTANT_utf8_info的长度是不固定的，其本身也代表字符串，其他常量项的属性可以指向CONSTANT_utf8_info。</p><h2 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的，即bitmap，这样只使用<strong>2byte</strong>即可表达所有访问标志。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。</li><li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。JDK8后，默认每个class文件都设置了ACC_SUPER标志，目的是向后兼容。</li></ul><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><h3 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h3><p>2byte，指向常量池</p><h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>2byte，指向常量池</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>指向常量池索引集合。</p><h4 id="interfaces-count（接口计数器）"><a href="#interfaces-count（接口计数器）" class="headerlink" title="interfaces_count（接口计数器）"></a>interfaces_count（接口计数器）</h4><p>2byte，interfaces_count项的值表示当前类或接口的直接超接口数量。</p><h4 id="interfaces（接口索引集合）"><a href="#interfaces（接口索引集合）" class="headerlink" title="interfaces（接口索引集合）"></a>interfaces（接口索引集合）</h4><p><code>interfaces_count*2byte</code><br>每个成员的值必须是对常量池表中某项的有效索引值，长度为interfaces_count</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><h3 id="fields-table"><a href="#fields-table" class="headerlink" title="fields_table"></a>fields_table</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识符"><a href="#访问标识符" class="headerlink" title="访问标识符"></a>访问标识符</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h4 id="描述符索引"><a href="#描述符索引" class="headerlink" title="描述符索引"></a>描述符索引</h4><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object</code>;</td></tr><tr><td><code>[</code></td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D </code></td></tr></tbody></table><h4 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h4><p>每个字段还可以拥有不同的属性，如初始值，注释信息。这些属性的数量放在属性计数器attribute_count中，内容放在属性集合attributes中。</p><p>比如某常量字段拥有下面三个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>methods表中的每个成员都必须是一个method_info结构：</p><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识-1"><a href="#访问标识-1" class="headerlink" title="访问标识"></a>访问标识</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>这里与字段&#x2F;方法表中的属性集合要分开，字段&#x2F;方法中属性集合是描述字段&#x2F;方法属性的，本处的属性表集合用来描述class文件的附加信息。</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>attributes_count的值表示当前class文件属性表的成员个数。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>属性表中每一项都是一个attribute_info结构。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><p>各种属性的含义见官网，具体问题具体分析。</p><h1 id="二、字节码指令集"><a href="#二、字节码指令集" class="headerlink" title="二、字节码指令集"></a>二、字节码指令集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p><ul><li>i代表对int类型的数据操作，</li><li>l代表long</li><li>s代表short</li><li>b代表byte</li><li>c代表char</li><li>f代表float</li><li>d代表double<div class="note note-primary">            <p>注意，编译器会将boolean,byte,char,short作为int使用i开头的指令处理。</p>          </div></li></ul><h2 id="加载与存储"><a href="#加载与存储" class="headerlink" title="加载与存储"></a>加载与存储</h2><ul><li>xload，将<strong>局部变量</strong>加载到操作数栈。</li><li>iconst、bipush等，<strong>常量入操作数栈</strong></li><li>xstore，<strong>出栈装入局部变量表</strong></li></ul><div class="note note-primary">            <ul><li>x为a表示对象操作，如aload，即加载一个对象到操作数栈。</li><li>在x后加a表示从数组中操作，如iaload，即从<code>int[]</code>数组中取数。</li></ul>          </div><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><h3 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h3><p><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201172429.png"></p><h3 id="运算模式"><a href="#运算模式" class="headerlink" title="运算模式"></a>运算模式</h3><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；<br><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p><h3 id="NaN值使用"><a href="#NaN值使用" class="headerlink" title="NaN值使用"></a>NaN值使用</h3><p>对于浮点数，有特殊的表达式：<br>1&#x2F;0.0 &#x3D; Infinity<br>0.0&#x2F;0.0 &#x3D; NaN</p><h3 id="算数指令-1"><a href="#算数指令-1" class="headerlink" title="算数指令"></a>算数指令</h3><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位与指令</td><td>iand</td><td>land</td><td></td></tr><tr><td></td><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td></tr><tr><td>比较指令</td><td></td><td>lcmp</td><td>fcmpg &#x2F; fcmpl</td><td>dcmpg &#x2F; dcmpl</td></tr></tbody></table><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table><thead><tr><th>转化</th><th>byte</th><th>char</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>int</td><td>i2b</td><td>i2c</td><td>i2s</td><td>○</td><td>i2l</td><td>i2f</td><td>i2d</td></tr><tr><td>long</td><td>l2i i2b</td><td>l2i i2c</td><td>l2i i2s</td><td>l2i</td><td>○</td><td>l2f</td><td>l2d</td></tr><tr><td>float</td><td>f2i i2b</td><td>f2i i2c</td><td>f2i i2s</td><td>f2i</td><td>f2l</td><td>○</td><td>f2d</td></tr><tr><td>double</td><td>d2i i2b</td><td>d2i i2c</td><td>d2i i2s</td><td>d2i</td><td>d2l</td><td>d2f</td><td>○</td></tr></tbody></table><p><strong>宽化类型转换</strong>，可能有精度损失，如long-&gt;double，但结果不会偏离太远。<br><strong>窄化类型转换</strong>，可能造成数据溢出导致结果不正确，并有下面的规律：</p><ul><li>浮点-&gt;整数<ul><li>NaN -&gt; 0</li><li>其他 -&gt; 向0取整 或 转换为整数能表示的最大值</li></ul></li><li>浮点-&gt;浮点(d2f)<ul><li>过小 -&gt; 0</li><li>过大 -&gt; 正负无穷大</li><li>NaN -&gt; NaN</li></ul></li></ul><h2 id="对象创建与访问"><a href="#对象创建与访问" class="headerlink" title="对象创建与访问"></a>对象创建与访问</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><table><thead><tr><th>创建指令</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>创建类实例</td></tr><tr><td>newarray</td><td>创建基本类型数组</td></tr><tr><td>anewarray</td><td>创建引用类型数组</td></tr><tr><td>multilanewarra</td><td>创建多维数组</td></tr></tbody></table><h3 id="字段访问"><a href="#字段访问" class="headerlink" title="字段访问"></a>字段访问</h3><table><thead><tr><th>字段访问指令</th><th>含义</th></tr></thead><tbody><tr><td>getstatic、putstatic</td><td>访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td>getfield、 putfield</td><td>访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th></tr></thead><tbody><tr><td>xaload</td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td></tr><tr><td>xastore</td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td></tr></tbody></table><h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>判断给定对象是否是某一个类的实例</td></tr><tr><td>checkcast</td><td>检查类型强制转换是否可以进行</td></tr></tbody></table><ul><li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li><li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li></ul><h2 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h2><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><ul><li>invokevirtual，调用对象的实例方法，<strong>支持多态</strong>。</li><li>invokespecial，调用特殊方法，静态绑定。</li><li>invokestatic，静态绑定。</li><li>invokedynamic，动态解析方法，并执行。该指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。<div class="note note-primary">            <p>invokedynamic是lambda表达式的具体底层实现，使用较少，类似于通过方法句柄调用方法，与反射不同，有点难理解，不要过度关注。</p>          </div></li></ul><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td>xreturn</td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p><h3 id="操作数栈管理"><a href="#操作数栈管理" class="headerlink" title="操作数栈管理"></a>操作数栈管理</h3><ul><li>pop，出栈</li><li>dup，复制栈顶<ul><li>dupm表示复制m个slot并压入栈顶</li><li>dupm_xn表示复制m个slot，并插入到栈顶下的（m+n）slot的位置。</li></ul></li><li>swap，交换栈顶两个slot数值，long,double不可用（占用两个slot）</li><li>nop，占位</li></ul><h2 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h2><ol><li>比较指令</li><li>条件跳转指令</li><li>比较条件跳转指令</li><li>多条件分支跳转指令。</li><li>无条件跳转指令等。</li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>athrow 抛出异常或错误。将栈顶异常抛出<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>ret 从子例程返回</p><h3 id="athrow"><a href="#athrow" class="headerlink" title="athrow"></a>athrow</h3><p>即throw语句<br>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>异常表保存了每个异常处理信息。比如：</p><ul><li>起始位置</li><li>结束位置</li><li>程序计数器记录的代码处理的偏移地址</li><li>被捕获的异常类在常量池中的索引</li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。<br>如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p><p>如果有finally块，则finally块必然执行，finally块在return前执行，但不影响return的结果，因此最好不要在非finally块中使用return。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；不需要显式的用字节码表示。</p><h4 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h4><ul><li>如果设置了同步，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li><li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li><li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个<strong>同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</strong></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>jvm的指令集有monitorenter和monitorexit 两条指令来支持synchronized关键字的语义。</p><h4 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h4><p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><h1 id="三、类的加载过程"><a href="#三、类的加载过程" class="headerlink" title="三、类的加载过程"></a>三、类的加载过程</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201180946.png"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182105.png"></p><ol><li>通过类的全名，获取类的二进制数据流，来源有：<ul><li>本地文件</li><li>压缩包</li><li>网络</li><li>数据库</li><li>实时生成</li></ul></li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型）：<ul><li>JDK8前：永久代</li><li>JDK8后：元空间</li></ul></li><li>创建java.lang.Class类的实例（堆中），表示该类型。作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>此时Class类中的成员还没有初始化。</p>          </div><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p><strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的。</p><ul><li>因此，若数组元素是引用类型，则先加载引用类型，然后JVM自动创建其数组类型。</li><li>数组的访问权限由其元素类型的访问权限决定。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182705.png"></p><h4 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h4><ul><li><strong>加载过程中，只进行格式检查</strong></li><li>把class文件加载到方法区后，再进行后续的检查</li></ul><h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><ol><li>格式验证：是否以魔数0XCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li><li>语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的。如父类不存在，接口未实现等。</li><li>字节码验证：主要检查是否有不合理的跳转，赋值，调用。（检查手段是有限的，即使通过了这阶段检查也不代表没问题。）</li><li>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的，并有访问权限</strong>。<div class="note note-primary">            <p>验证行为贯穿整个类的加载过程</p><ul><li>在加载阶段进行格式检查。</li><li>在链接阶段的验证环节进行语义和字节码验证。</li><li>在链接阶段的解析环节继续拿符号引用验证。</li></ul>          </div></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类分配内存空间，并设置初始值0值。</p><div class="note note-primary">            <p>不包含<strong>基本数据类型的字段</strong>用<strong>static final</strong>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。<br>此外，类变量(static)存放在<strong>堆</strong>中class对象中。</p>          </div><div class="note note-success">            <p><strong>static与static final</strong><br>根据虚拟机规范定义，类变量（static）应该被放入方法区，而java中方法区的具体实践是：</p><ul><li>类元信息放入元空间</li><li>字符串常量池和静态变量放入堆中，其中静态变量是伴随着Class对象分配空间的。<ul><li>如果静态变量是final且是基本数据类型（包括字符串），那么其值会在类加载过程中的<strong>链接环节的准备过程</strong>中初始化赋值，否则在这里赋0值。</li><li>如果静态变量不是final且是基本数据类型（包括字符串），那么其在类加载过程中的<strong>初始化环节</strong>中会初始化赋值。</li><li>所以，无论是否final，基本类型的static成员变量都在堆中（伴随Class对象）</li></ul></li></ul>          </div><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。<br>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h3><ul><li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值</li><li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行，即<code>String a = &quot;12&quot;</code>形式。</li><li>在初始化阶段<code>&lt;clinit&gt;()</code>中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</li></ul><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h3><p>该方法是带锁，线程安全的。只会被执行一次。</p><h3 id="类的初始化情况"><a href="#类的初始化情况" class="headerlink" title="类的初始化情况"></a>类的初始化情况</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p>总之是需要使用到类的字段或方法的情况。</p><ul><li>实例化</li><li>调用静态方法</li><li>获取静态字段</li><li>使用反射（包括<strong>forName</strong>）</li><li>继承该类</li><li>default方法</li><li>包含main方法</li><li>被指定调用MethodHandler</li></ul><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了以上情况都是被动使用，比如：</p><ul><li>通过子类引用父类的静态变量，子类不会初始化。</li><li>数组定义，定义某种类型的数组</li><li>引用某个的常量static final（常量在链接的准备阶段就已经完成赋值）</li><li><code>loadClass()</code>也不会主动初始化。</li></ul><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>类加载器</strong>与<strong>被该加载器加载的类</strong>的内部实现中，存在着双向引用。因此根据GC的原理，当某一个类的Class对象不再被引用时，即可回收，因此回收类的前提是回收其加载器。</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li><strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载的。</strong></li><li><strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>。</li><li>被开发者<strong>自定义的类加载器</strong>实例加载的类型<strong>只有在很简单的上下文环境中才能被卸载</strong>，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。</li></ul><h3 id="卸载前提"><a href="#卸载前提" class="headerlink" title="卸载前提"></a>卸载前提</h3><ul><li>所有类实例被回收</li><li>所有对该类的引用被回收</li><li>该类的加载器被回收</li></ul><h1 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。</p><p>ClassLoader在整个装载阶段，<strong>只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为</strong>。至于它是否可以运行，则由Execution Engine决定。</p><div class="note note-primary">            <p>ClassLoader只定义类加载中的<strong>加载环节的细节</strong>。</p>          </div><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="加载方式分类"><a href="#加载方式分类" class="headerlink" title="加载方式分类"></a>加载方式分类</h3><ul><li>显式加载：反射</li><li>隐式加载：JVM加载</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p><strong>类的唯一性：由加载器和该类共同决定其唯一性。</strong></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>可见性，子加载器可以看见父加载器加载的类型，反之则不行。</li><li>单一性，由于可见性，父加载器加载的类不会被子加载器重复加载。</li></ul><h2 id="加载器分类"><a href="#加载器分类" class="headerlink" title="加载器分类"></a>加载器分类</h2><ul><li>引导类加载器（Bootstrap ClassLoader）</li><li>自定义类加载器（User-Defined ClassLoader）</li></ul><p>加载器之间不是继承关系，而是<strong>包含关系</strong>，子加载器包含父加载器的引用，因此其可以看见父加载器加载的内容（可见性），以及调用父加载器（实现双亲委派机制）。</p><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><h4 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h4><ul><li>C&#x2F;C++实现，在JVM内部实现</li><li>加载核心库</li><li>没有父加载器</li></ul><h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>加载ext.dirs目录下的类库</li><li>父类加载器为启动类加载器</li><li>直接继承于URLClassLoader，最终继承于ClassLoader类（一个抽象类）</li></ul><h4 id="系统类加载器（AppClassLoader）"><a href="#系统类加载器（AppClassLoader）" class="headerlink" title="系统类加载器（AppClassLoader）"></a>系统类加载器（AppClassLoader）</h4><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li>父类加载器为扩展类加载器</li><li>直接继承于URLClassLoader，最终继承于ClassLoader类（一个抽象类）</li></ul><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><p>可以通过自定义实现插件机制，此外加载器可以实现应用隔离。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="ClassLoader主要方法"><a href="#ClassLoader主要方法" class="headerlink" title="ClassLoader主要方法"></a>ClassLoader主要方法</h3><p>ClassLoader是一个抽象类，基本java实现的加载器都继承自它。<br>其有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span><br><span class="hljs-comment">//加载</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-comment">//链接</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span><br></code></pre></td></tr></table></figure><ul><li>其中，<code>loadClass()</code>会调用<code>findClass()</code>，而loadClass中实现了双亲委派机制，因此自定义加载器时，尽量只重写findClass()及其调用的方法。</li><li><code>findClass()</code>会调用<code>defineClass()</code>，其指明如何将byte流解析成Class对象。</li></ul><h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><ul><li>SecureClassLoader继承并扩展了ClassLoader功能，添加了权限认证。</li><li>URLClassLoader继承并扩展了SecureClassLoader，其对ClassLoader中的许多抽象方法做了具体的实现。</li><li>一般自定义加载类直接继承URLClassLoader非常方便。</li></ul><h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><ul><li>JDK8中，这两个类都继承自URLClassLoader</li><li>JDK9中，这两个类都继承自BuiltinClassLoader</li></ul><h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><ul><li>前者会初始化，后者不会。</li><li>后者需要指定一个具体的加载器加载。</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先交给父类加载器加载，加载失败再由子类加载。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202001557.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>搜索类，有则返回</li><li>有父类则委托加载</li><li>无父类则使用引导类加载器加载（必须委托一次引导类，实现保护的核心API的功能）</li><li>都失败则主动加载</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>避免重复加载</li><li>保护核心类库</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>顶层无法访问底层加载器，系统类无法访问应用类，无法在系统类的方法中调用应用类。</li></ul><div class="note note-primary">            <p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</p>          </div><h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><h4 id="第一次：覆盖loadClass"><a href="#第一次：覆盖loadClass" class="headerlink" title="第一次：覆盖loadClass"></a>第一次：覆盖loadClass</h4><p>双亲委派机制推出前就有ClassLoader存在，loadClass方法已经被用户使用自定义加载器覆盖（没有双亲委派），后来才推荐用户改写findClass。</p><h4 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h4><p>解决系统类无法调用用户类的缺点，如JNDI服务就需要调用，管理用户类。</p><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202002835.png"><br>父类加载器可以通过线程上下文类加载器委托给子类加载器完成类的加载。这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h4 id="第三次：用户的要求"><a href="#第三次：用户的要求" class="headerlink" title="第三次：用户的要求"></a>第三次：用户的要求</h4><p>第三次破坏源于用户需求：代码热替换(Hot Swap)、模块热部署(Hot Deployment)等。</p><p>背景：IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>搜索顺序：</p><ol><li>java.开头，委托父类（双亲）</li><li>若在委派列表名单中，委托父类（双亲）</li><li>在各种列表中寻找类加载器进行加载（平行）</li></ol><p>PS：了解一下就行。</p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003613.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱。即将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源（CPU、内存、文件系统、网络）访问。</p><h3 id="JDK1-0"><a href="#JDK1-0" class="headerlink" title="JDK1.0"></a>JDK1.0</h3><p><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003843.png"></p><h3 id="JDK1-1"><a href="#JDK1-1" class="headerlink" title="JDK1.1"></a>JDK1.1</h3><p>增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003849.png"></p><h3 id="JDK1-2"><a href="#JDK1-2" class="headerlink" title="JDK1.2"></a>JDK1.2</h3><p>改进了安全机制，增加了<strong>代码签名</strong>。由<strong>类加载器</strong>加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。<br><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003938.png"></p><h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><p>虚拟机会把所有代码加载到不同的系统域和应用域。</p><p>系统域专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。</p><p><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003950.png"></p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>隔离加载类（容器隔离）</li><li>修改类的加载方式（动态加载）</li><li>扩展加载源（数据库，网络）</li><li>防止源码泄漏（加密）</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>方式</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法，推荐<br>说明</li><li>其父类加载器是系统类加载器</li></ul><h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</li><li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/323cfcda53f98034ed15372c0ea43685.png"><br>3. 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。<br>4. 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。<br>5. 类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><p><img src="/2023/02/01/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202004846.png"></p><div class="note note-primary">            <p>总结就是：</p><ol><li>ext改名plat</li><li>新增getName()方法</li><li>plat和app不再继承url，而是builtin</li><li>引导类由java实现</li><li>双亲委托前可直接判断所属系统并交付</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>JVM</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM上篇:内存与垃圾回收</title>
    <link href="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JVM与Java体系"><a href="#一、JVM与Java体系" class="headerlink" title="一、JVM与Java体系"></a>一、JVM与Java体系</h1><ul><li>JVM只关心字节码文件</li><li>虚拟机是对物理计算机的模仿</li><li>JVM是运行在操作系统之上的，不直接与硬件交互<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140012.png"></li></ul><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140104.png"></p><h2 id="Java代码执行顺序"><a href="#Java代码执行顺序" class="headerlink" title="Java代码执行顺序"></a>Java代码执行顺序</h2><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140118.png"></p><h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><ul><li>栈式架构<br>实现更简单，不需要硬件支持，指令集更小，跨平台</li><li>寄存器架构<br>指令集架构则完全依赖硬件，可移植性差</li></ul><h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></p><h3 id="虚拟机退出的情况"><a href="#虚拟机退出的情况" class="headerlink" title="虚拟机退出的情况"></a>虚拟机退出的情况</h3><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。<br>总结：一个正常执行完毕，两个错误终止，两个手动终止。</li></ul><h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="类加载器与类加载过程"><a href="#类加载器与类加载过程" class="headerlink" title="类加载器与类加载过程"></a>类加载器与类加载过程</h2><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140856.png"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li><strong>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</strong></li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ol><li>通过类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>这里注意，加载阶段就完成了方法区数据结构的装载和Class对象的生成，但此时还没有进行类初始化，即此时类中的字段还没有初始化。</p>          </div><h4 id="补充：class文件来源"><a href="#补充：class文件来源" class="headerlink" title="补充：class文件来源"></a>补充：class文件来源</h4><ul><li>本地</li><li>网络</li><li>动态代理，动态生成</li><li>压缩包</li><li>JSP</li><li>数据库</li><li>加密文件</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在子确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<strong>文件格式验证，元数据验证，字节码验证，符号引用验证</strong>。</li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li><strong>这里不包含用final修饰的static，因为final static在编译的时候就会分配了，准备阶段会显式初始化；</strong></li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<strong>符号引用转换为直接引用</strong>的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。符号引用就是一组符号来描述所引用的目标。</li><li>符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><strong>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。</strong></li><li>该阶段是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和<strong>静态代码</strong>块中的语句合并而来。</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</li></ul><div class="note note-primary">            <ul><li>加载阶段负责把字节码的二进制文件加载到方法区，并根据字节码在堆中生成class对象</li><li>链接阶段负责检验class文件的正确性、为类的变量分配内存并设置默认值（0值）、解析时将符号应用转换为直接引用。</li><li>初始化负责对类变量、static块执行赋值。</li></ul>          </div><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul><li>分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li><li>Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144137.png"></li></ul><h3 id="自带的加载器"><a href="#自带的加载器" class="headerlink" title="自带的加载器"></a>自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li><strong>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</strong></li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li><strong>并不继承自ava.lang.ClassLoader，没有父加载器。</strong></li><li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</strong></li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><div class="note note-primary">            <ul><li>引导类加载器不继承ClassLoader；其他类都继承该抽象类，被称为自定义类加载器。</li></ul>          </div><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>启动类加载器</strong></li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/1ib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>扩展类加载器</strong></li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><div class="note note-primary">            <p>具体到类加载过程中的步骤，其可以加密（防止源码泄漏），可以扩展加载的源（如网络），可以修改类的加载方式并隔离加载类（热部署）。</p>          </div><p>实现步骤：</p><ul><li>JDK1.2之前，继承ClassLoader，覆盖loadClass方法。</li><li>JDK1.2之后，继承ClassLoader，覆盖findClass方法（其被loadClass方法调用）。</li><li>没有复杂需求时，直接继承URLClassLoader，避免自己编写findClass。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144950.png"></li></ul><h3 id="获取ClassLoader方法"><a href="#获取ClassLoader方法" class="headerlink" title="获取ClassLoader方法"></a>获取ClassLoader方法</h3><ul><li>clazz.getClassLoader()</li><li>Thread.currentThread().getContextClassLoader() &#x2F;&#x2F;上下文线程的加载器</li><li>ClassLoader.getSystemClassLoader() &#x2F;&#x2F;系统类加载器</li><li>DriverManager.getCallerClassLoader() &#x2F;&#x2F;调用者的加载器</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul><li>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式</li><li>加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</li></ul><p><strong>原理</strong><br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145155.png"><br>具体实现在loadClass()方法中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>如何判断两个class对象是否相同</strong><br>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p><strong>对类加载器的引用</strong></p><ul><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</li><li>如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。<div class="note note-primary">            <p>不同类加载器加载的对象解析需要其在同一个域。</p>          </div></li></ul><p><strong>主动使用与被动使用</strong><br>对类的成员的调用：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>初始化一个类的子类<br>规范：</li><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>Java虚拟机启动时被标明为<strong>启动类</strong>的类</li><li>JDK 7 开始提供的动态语言支持：<br>  java.lang.invoke.MethodHandle实例的解析结果<br>  REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都不会导致<strong>类的初始化</strong>。</p><h1 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h1><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145718.png"></p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>PS：JVM允许一个应用有多个线程并行的执行。在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><h2 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h2><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><div class="note note-primary">            <p>可以理解为JVM后台运行的线程，其中虚拟机线程是管理其他线程的线程，其令JVM达到安全点才调用执行一些操作，如Stop-the-world，线程栈收集，线程挂起，偏向锁撤销。</p>          </div><h2 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h2><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123150208.png"><br>作用：<br>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li><li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</strong></li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；<strong>或者，如果是在执行native方法，则是未指定值（undefined）</strong>。</li></ul><div class="note note-primary">            <p>每个线程都拥有一个PC计数器，相互隔离（私有），标识当前线程的执行点，这样执行引擎就会执行该地址代码。</p>          </div><p><strong>为什么使用PC寄存器记录当前线程的执行地址呢？</strong><br>CPU可能会分片执行，切换线程后需要知道从哪里开始执行。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。</p><ul><li><strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。</li><li>生命周期和线程一致</li><li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li><li>JVM对栈的操作仅有，出栈，入栈。</li></ul><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><code>StackOverflowError</code>，超过设定的栈容量</li><li><code>OutOfMemoryError</code>，整体内存空间不足。</li></ul><p>**设置大小方法:</p><ul><li>**<code>-Xss</code></li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><ul><li>栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong>。</li><li>栈帧<strong>先进后出</strong>，一个线程只有一个活动栈帧，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</li></ul><p>Java方法有两种返回函数的方式：</p><ul><li>一种是正常的函数返回，使用return指令；</li><li>另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h3 id="栈帧中的内容"><a href="#栈帧中的内容" class="headerlink" title="栈帧中的内容"></a>栈帧中的内容</h3><ul><li><strong>局部变量表（Local Variables）</strong></li><li><strong>操作数栈（operand Stack）（或表达式栈）</strong></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul><li>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><h5 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h5><ul><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li><li><strong>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</strong></li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或doub1e类型变量）</li><li>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123151728.png"><br>另外，Slot空间可以被复用，如某些局部变量超出作用域后，新的局部变量可以复用该位置。</p><h5 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h5><p>Static：类变量表有两次初始化的机会：</p><ul><li>第一次是在“链接阶段中的准备阶段”，执行系统初始化，对类变量设置零值。</li><li>另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li></ul><p>局部变量表：不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</p><div class="note note-primary">            <p>虚拟机栈指的就是整个线程栈，线程栈分若干个栈帧，栈帧中又有操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p>          </div><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123152330.png"></p><p>PS：每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</p><h5 id="栈顶缓存-Top-Of-Stack-Caching-技术"><a href="#栈顶缓存-Top-Of-Stack-Caching-技术" class="headerlink" title="栈顶缓存(Top Of Stack Caching)技术"></a>栈顶缓存(Top Of Stack Caching)技术</h5><p>操作数是存储在内存中的，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接、方法返回地址、附加信息有时被一起称为帧数据区。</p><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。通过这个引用，可以实现动态链接。</p><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123154403.png"></p><div class="note note-primary">            <p>现有动态链接，再有栈帧！<br>比如，现在某对象A在方法A0中调用对象B的一个方法B0，字节码文件如下：<br>invokeVirtual B0</p><p>此时虚拟机会根据操作数栈顶的对象类型，根据<strong>字符串</strong>查找其方法中类元信息中的<strong>方法入口</strong>。<br>但是每次调用方法都扫描查找一次类信息是很繁琐的，在方法区的运行时常量池中，直接保存了字符串与方法入口地址的对应关系（直接引用），这个对应关系也叫类B的Vtable。</p>          </div><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，<strong>动态链接的作用就是为了将这些符号引用转换位调用方法的直接引用</strong>。</p><div class="note note-primary">            <p>个人理解：某个方法A可能会调用其他方法B，在执行引擎遇到调用其他方法的语句如invokeVirtual时，需要找到方法B的入口。<br>而栈帧中保存了一个指针，指向了方法B符号在运行时常量池中的位置，再通过运行时常量池，实现将符号引用转化为直接引用。</p>          </div><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。</p><ul><li>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li><li>通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>目标方法在编译期可知，且运行期保持不变时。对应<strong>早期绑定</strong>，调用非虚方法。</p><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用。对应<strong>晚期绑定</strong>，调用虚方法。</p><h4 id="方法绑定"><a href="#方法绑定" class="headerlink" title="方法绑定"></a>方法绑定</h4><p>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><ul><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通方法调用</span><br>invokestatic：调用静态方法，解析阶段确定唯一方法版本<br>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本<br>invokevirtual：调用所有虚方法<br>invokeinterface：调用接口方法<br><br><span class="hljs-comment">//动态方法调用</span><br>invokedynamic：动态解析出需要调用的方法，然后执行<br></code></pre></td></tr></table></figure><p><strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><p><code>invokedynamic</code>在JAVA7中才出现，但没有直接生成该指令，在JAVA8中的Lambda表达式可以生成<code>invokedynamic</code></p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>也就是前面动态链接中提到的Vtable，每个类都有一个这样的虚方法表存在于方法区，便于查找方法的真实入口。</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>根据操作数栈顶元素的实际对象类型寻找方法</li><li>找到后使用权限校验，通过则调用，不通过则报异常</li><li>找不到则根据继承关系循环进行1，2步</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>方法中定义的局部变量是否线程安全？<br>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><h2 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>native修饰的方法<br>主要用于与外部环境、操作系统交互，调用C语言实现的方法等。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>实现本地方法的管理调用，也是每个线程持有一个。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129213758.png"></p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>这个图有点问题</p><ul><li>本地方法入栈后，执行引擎会调用本地方法库执行本地方法。</li><li><strong>本地方法接口</strong>则是<strong>本地方法访问虚拟机内部数据</strong>的接口。</li></ul><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。</p><p>并不是所有JVM都支持本地方法。<br><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆空间结构"><a href="#堆空间结构" class="headerlink" title="堆空间结构"></a>堆空间结构</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214614.png"><br>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214618.png"></p><p><strong>堆空间大小设置</strong></p><ul><li>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code><br>默认Xms:电脑内存&#x2F;64<br>默认Xmx:电脑内存&#x2F;4</li></ul><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129215125.png"></p><ul><li>可以设置新生代&#x2F;老年代占比：默认<code>-XX:NewRatio=2</code></li><li>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，可以使用<code>-XX:SurvivorRatio</code></li><li>可以使用<code>-Xmn</code>设置新生代最大内存大小。</li></ul><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><h4 id="小对象分配原则"><a href="#小对象分配原则" class="headerlink" title="小对象分配原则"></a>小对象分配原则</h4><ul><li><code>Eden</code>出生，一次MinorGC后进入<code>Survivor</code></li><li>15次（使用-XX:MaxTenuringThreshold&#x3D;N调整）Survivor移动后进入<code>Old</code>。</li><li><code>Old</code>若被MajorGC可能会清理，若无法保存则报OOM。</li></ul><h4 id="其他分配原则"><a href="#其他分配原则" class="headerlink" title="其他分配原则"></a>其他分配原则</h4><ul><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>动态对象年龄判断：如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保（-XX:HandlerPromotionFailure），开启时：<ul><li>MinorGC前检查老年代是否有连续空间容纳新生代的对象空间。<ul><li>若有，则可以执行MinorGC</li><li>若无，检查是否开启空间分配担保<code>-XX:HandlePromotionFailure</code><ul><li>若开启，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。<ul><li>若大于，则进行一次MinorGC（有风险）</li><li>若小于，FullGC</li></ul></li><li>否则，FullGC<div class="note note-primary">            <p>为什么需要空间担保：<br>minorGC时可能直接将大量Survivor区对象直接放入Old区，此时需要Old区保证能接受这些对象，若老年代剩余空间&gt;新生代所有对象大小，则肯定可以接受。若空间&lt;对象大小，则可以根据之前的回收情况预估实际进入老年代的对象大小，判断是否需要据此进行冒险的MinorGC，以避免盲目的FullGC。<br><strong>JDK7及以后已经弃用。此后，默认会进行冒险行为，否则FullGC。</strong></p>          </div></li></ul></li></ul></li></ul></li></ul><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>Thread Local Allocation Buffer，堆是所有线程共享的，因此也是线程不安全的。TLAB表示JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。<br>可以通过<code>-XX:UseTLAB</code>决定是否开启TLAB，通过<code>-XX:TLABWasteTargetPercent</code>决定TLAB占用Eden空间的大小。</p><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><p>GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h4><p>Eden满，需要清理Eden，STW。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129220927.png"></p><h4 id="MajorGC-x2F-FullGC"><a href="#MajorGC-x2F-FullGC" class="headerlink" title="MajorGC&#x2F;FullGC"></a>MajorGC&#x2F;FullGC</h4><p>Old区不够用时发生，Major发生总是伴随着MinorGC，但不绝对，STW。</p><h4 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h4><ol><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>要尽量避免FullGC，其耗时太长。</p><h3 id="堆是分配对象的唯一选择吗？"><a href="#堆是分配对象的唯一选择吗？" class="headerlink" title="堆是分配对象的唯一选择吗？"></a>堆是分配对象的唯一选择吗？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。</p><p>JDK6u23后默认开启逃逸分析，此前需要</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>栈上分配：对象不发生方法逃逸。</li><li>同步省略：对象不发生线程逃逸（其他线程不访问该对象），也叫<strong>锁消除</strong>。</li><li>标量替换：将对象结构体（聚合量）替换为一个个属性（标量，基本类型）。使用<code>-XX:EliminateAllocations</code>开启。</li></ul><p>逃逸分析不成熟，因为分析性能不一定优于优化性能。<br><strong>Hotspot中的所有对象都建立在堆上。</strong></p><div class="note note-primary">            <p>JDK7前，字符串常量池在永久代上，后来永久代被元空间取代，而字符串常量池迁移到堆中，符合了所有对象都建立在堆上的结论。</p>          </div><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>方法区是一个独立于java堆的内存空间。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131114507.png"><br>前面的概念中有提到，方法区只是一个逻辑上的概念。在JDK8之前，方法区由永久代实现，JDK8之后，方法区由元空间实现，其独立于java堆空间，直接使用本地内存（但是也可能报OOM，本地内存的大小也是有限的）。</p><h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3><h4 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h4><ul><li>初始：<code>-XX:Permsize</code></li><li>最大：<code>-XX:MaxPermsize</code></li></ul><h4 id="jdk8之后"><a href="#jdk8之后" class="headerlink" title="jdk8之后"></a>jdk8之后</h4><ul><li>初始：<code>-XX:MetaspaceSize</code></li><li>最大：<code>-XX:MaxMetaspaceSize</code>(设置为-1则不受限制)</li></ul><h3 id="存储什么"><a href="#存储什么" class="headerlink" title="存储什么"></a>存储什么</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><ol><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型直接接口的一个有序列表</li></ol><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ol><li>域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li><li>域类型</li><li>域名称</li></ol><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ol><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的返回类型（或void）</li><li>方法名称</li><li>方法参数的数量和类型（按顺序）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><div class="note note-primary">            <p>简而言之，我们java文件中写的内容基本都会保存到方法区中。</p>          </div><h4 id="对于static-x2F-final"><a href="#对于static-x2F-final" class="headerlink" title="对于static&#x2F;final"></a>对于static&#x2F;final</h4><ul><li>若符号由static修饰，说明是类变量，在类的加载过程中生成。</li><li>若符号由static final修饰，说明是常量，在编译时即完成分配。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131120156.png"></p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池也称静态常量池，每个类的字节码文件（.class）中都具有一个常量池表，其描述了各种<strong>字面量</strong>与<strong>类、域、方法</strong>的<strong>符号引用</strong>。<br>而常量池中一般存储有：</p><ul><li>字段复用<ul><li>数量值</li><li>字符串值</li></ul></li><li>类及成员<ul><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li></ul><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用。<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>，<strong>一个类加载到 JVM 中后对应一个运行时常量池</strong>。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</li></ul><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池是全局</strong>的，里面存储的是字符串对象，而不是字面量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li>常量池存在于Class文件中，表现为 序号（”#1”） 到 字面量（”java&#x2F;lang&#x2F;Object”）的映射</li><li>运行时常量池存在于方法区，表现为 序号（”#1”）到 字面量（基本类型） 或 真实地址的映射。</li><li>常量池在类的加载过程的<strong>链接阶段</strong>的<strong>解析阶段</strong>，会将常量池中的字面量解析为真实地址。</li></ul>          </div><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><table><thead><tr><th>JDK1.6及之前</th><th>有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><div class="note note-primary">            <ul><li>字符串常量池移动到了堆中，但运行时常量池依然在元空间。</li><li>元空间中可能持有字符串的引用。</li></ul>          </div><h4 id="为什么要使用元空间"><a href="#为什么要使用元空间" class="headerlink" title="为什么要使用元空间"></a>为什么要使用元空间</h4><ul><li>永久代大小不应限制，使用元空间使用本地内存</li><li>永久代很难调优，GC起来很困难，类的卸载条件很苛刻。</li></ul><h4 id="StringTable为何换位置"><a href="#StringTable为何换位置" class="headerlink" title="StringTable为何换位置"></a>StringTable为何换位置</h4><p>字符串的创建和回收是很频繁的，放在永久代不宜回收（只有FullGC），而放在堆中可以及时回收。</p><h4 id="静态变量存放在哪"><a href="#静态变量存放在哪" class="headerlink" title="静态变量存放在哪"></a>静态变量存放在哪</h4><p>虚拟机规范要求将class相关信息放置于方法区中，但没有限制方法区的实现，所以HotSpot选择将静态变量随着class对象一起放在堆中。</p><h4 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h4><p>方法区主要回收常量池中废弃的常量和不再使用的类型。</p><ul><li>常量：不再被使用即可回收。</li><li>类型：<ul><li>所有对象已经回收</li><li>所有对该类的引用已经被回收</li><li>对于的类加载器已经被回收<br>满足类型的回收条件也只是允许回收，并不是必然的。</li></ul></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>元空间使用直接内存，NIO（Native IO）时也可以使用直接内存</p><h4 id="非直接内存"><a href="#非直接内存" class="headerlink" title="非直接内存"></a>非直接内存</h4><p>使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><h4 id="直接内存-1"><a href="#直接内存-1" class="headerlink" title="直接内存"></a>直接内存</h4><p>使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。<br>直接内存可以通过<code>MaxDirectMemorySize</code>设置，不指定时与-Xmx参数一致。</p><h1 id="四、对象的实例化过程"><a href="#四、对象的实例化过程" class="headerlink" title="四、对象的实例化过程"></a>四、对象的实例化过程</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ul><li>new：最常见的方式、Xxx的静态方法，XxxBuilder&#x2F;XxxFactory的静态方法</li><li>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis<div class="note note-primary">            <ul><li>new，类，构造器的构造方法是一般的生成新对象方法。</li><li>clone和序列化是复制对象的方法。</li><li>第三方库</li></ul>          </div></li></ul><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol><li>判断对象对应的类是否加载、链接、初始化<ul><li>元空间查找</li><li>失败，双亲委派加载（classloader+包名+类名）</li><li>失败，抛出异常</li></ul></li><li>为对象分配内存（具体如何分配取决于java堆的GC功能）<ul><li>有规整的内存（使用指针碰撞法时）</li><li>内存不规整（需要维护一个空闲列表）</li></ul></li><li>处理并发问题：保证更新的原子性</li><li>初始化分配到的内存（所有对象赋默认值，0值）</li><li>设置对象的对象头</li><li>init方法初始化（显示、代码块，构造器）</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130349.png"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度。</p><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><p>详情见JUC</p><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>有以下两种模式</p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130511.png"><br>优点在于，若对象被移动只需要修改句柄池</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130542.png"><br>HotSpot采用这种方式，访问快速。</p><h1 id="五、执行引擎"><a href="#五、执行引擎" class="headerlink" title="五、执行引擎"></a>五、执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎属于JVM的下层，里面包括<strong>解释器、及时编译器、垃圾回收器</strong><br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130915.png"><br>执行引擎的任务就是将字节码指令解释&#x2F;编译成本地平台上的本地机器指令。</p><p>工作流程：执行引擎执行PC寄存器指向的指令，PC寄存器指向下一条指令。</p><h2 id="编译与执行过程"><a href="#编译与执行过程" class="headerlink" title="编译与执行过程"></a>编译与执行过程</h2><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131115.png"></p><ol><li>Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131132.png"></li><li>Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131139.png"></li></ol><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器：对字节码逐行解释成机器码并执行。<br>编译器：</p><ul><li>前端编译器：将java代码编译成class字节码文件</li><li>后端编译器（JIT编译器）：将源代码直接编译成机器语言。</li></ul><p>java是一门半解释半编译的语言。</p><h2 id="指令基本概念"><a href="#指令基本概念" class="headerlink" title="指令基本概念"></a>指令基本概念</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>二进制指令，与CPU相关</p><h3 id="指令与指令集"><a href="#指令与指令集" class="headerlink" title="指令与指令集"></a>指令与指令集</h3><p>将二进制指令使用mov,inc等人类可读的方式表示。不同机器上指令对应的机器码可能不同。每个平台所支持的所有指令，称之为对应平台的指令集。即指令的集合。如-86，ARM</p><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>用助记符代替机器指令的操作码，使用汇编语言编写的程序需要翻译成机器指令码才能被识别、执行。</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍然<strong>需要把程序解释和编译成机器的指令码</strong>。<br>一般都是高级指令翻译成汇编语言，然后翻译成机器指令才能被执行。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>为了实现跨平台，没有采用静态编译生成机器指令，而是生成class文件，由解释器实现跨平台。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><ol><li>字节码解释器：纯软件代码模拟字节码执行。</li><li>模板解释器：每一条字节码和一个模板函数相关联。</li></ol><p>HotSpotVM中，解释器由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><div class="note note-primary">            <p>Interpreter模块可以将字节码翻译为机器码，Code则管理字节码对机器码的映射。</p>          </div><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>基于解释器执行已经沦落为低效的代名词<br>为了解决该问题，JVM平台支持一种叫作即时编译的技术（JIT），将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>JIT编译器属于后端编译器，将字节码翻译为机器码，是一种即时编译器。<br>HopSpot VM使用了<strong>解释器和即时编译器并存的架构</strong>。</p><p>有了JIT，为什么还要解释器？</p><ul><li>快启动</li><li>编译器无法优化程序时，解释器是逃生门</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2。<br>开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li><li><code>-server</code>：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。</li><li><strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>Java7后，就算开启-server模式也会默认使用分层编译。</li></ul><h4 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h4><p>C1编译器上主要有方法内联、去虚拟化、冗余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2的优化主要是在全局层面，做逃逸分析</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h2 id="HopSpotJVM执行方式"><a href="#HopSpotJVM执行方式" class="headerlink" title="HopSpotJVM执行方式"></a>HopSpotJVM执行方式</h2><p>解释器先发生作用，即时编译器根据热点探测将有价值的字节码编译为本地机器指令。</p><ul><li>JIT编译器是<strong>后端运行时编译器</strong>（Just In Time Compiler）,将字节码编译成本地机器指令。</li><li>AOT编译器是<strong>静态提前编译器</strong>（Ahead Of Time），将java文件编译成本地机器指令。</li></ul><h3 id="热点代码及探测"><a href="#热点代码及探测" class="headerlink" title="热点代码及探测"></a>热点代码及探测</h3><h4 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h4><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”。因而可以通过JIT编译器编译为本地机器指令，这种方式叫做栈上替换，或称为OSR（On Stack Replacement）编译。</p><h4 id="热点探测功能"><a href="#热点探测功能" class="headerlink" title="热点探测功能"></a>热点探测功能</h4><p>HotSpot使用的热点探测方式是<strong>基于计数器</strong>的热点探测。</p><p>HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数。</li><li>回边计数器则用于统计方法内循环体执行的循环次数。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>Client模式下默认1500次，Server模式下默认10000次。<br>可以通过<code>-XX:CompileThreshold</code>来人为设定阈值。</p><p>如果发现<strong>方法调用计数器和回边计数器之和</strong>超过了阈值，则会提交JIT即时编译请求。</p><h4 id="热点衰退"><a href="#热点衰退" class="headerlink" title="热点衰退"></a>热点衰退</h4><p>方法调用计数器统计的并<strong>不是方法被调用的绝对次数</strong>，而是一个相对的执行频率，即一段时间之内方法被调用的次数。<br>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减（Counter Decay）</strong>，而这段时间就称为此方法统计的<strong>半衰周期（Counter Half Life Time）</strong><br>热点衰退在GC时顺便进行，可以使用<code>-XX:-UseCounterDecay</code>设置关闭热点衰减，使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li><p><code>-Xint</code>：完全采用解释器模式执行程序；</p></li><li><p><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</p></li><li><p><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</p></li></ul><h1 id="六、StringTable"><a href="#六、StringTable" class="headerlink" title="六、StringTable"></a>六、StringTable</h1><h2 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h2><ul><li>字符串</li><li>final，不可继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。</li><li>String实现了Comparable接口：表示string可以比较大小</li><li>String在jdk8及以前内部定义了<code>final char[] value</code>用于存储字符串数据。JDK9时改为<code>byte[]</code>。</li></ul><h2 id="为什么修改String底层"><a href="#为什么修改String底层" class="headerlink" title="为什么修改String底层"></a>为什么修改String底层</h2><p>原因：<code>char[]</code>数组中大多数char属于Latin-1字符，使用1byte即可表示，但char需要2byte，空间浪费。</p><p>改进：为String提供两种字符集使用（Latin-1或UTF-16）。</p><h2 id="StringPool"><a href="#StringPool" class="headerlink" title="StringPool"></a>StringPool</h2><p>String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</p><p>使用<code>-XX:StringTablesize</code>可设置StringTable的长度</p><ul><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，设置StringTable长度的话，1009是可以设置的最小值</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul><li>直接使用双引号声明出来的String对象会直接存储在<strong>常量池</strong>中。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</li><li>使用new，生成的对象在堆中，不入池。</li></ul><h3 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>Java 6及以前，字符串常量池存放在永久代<br>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<br>Java 8元空间，字符串常量池在堆内。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><code>String str =&quot;ab&quot; + &quot;cd&quot;</code>创建了1个对象，因为”ab”+”cd”会被编译器优化，只在常量池创建一个”abcd”并返回。</li><li><code>String str = new String(&quot;123&quot;)</code>创建了2个对象，一个”123”在字符串常量池，一个new String在堆中，返回堆中对象。</li></ul><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><ul><li>**常量(final)与常量(final)**的拼接结果在常量池，原理是编译期优化</li><li><strong>只要其中有一个是变量</strong>，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><h4 id="优化拼接"><a href="#优化拼接" class="headerlink" title="优化拼接"></a>优化拼接</h4><ul><li>尽量使用StringBuilder.append()</li><li>可以在初始化时，指定StringBuilder的capacity，减少扩容次数。</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>语义是：返回常量池中的相同字符串。</p><ul><li>如果池中本身存在该String对象，则直接返回池中对象。</li><li>否则，将该对象添加到池中，并返回该String对象。</li></ul><h4 id="JDK6-gt-JDK7-x2F-8"><a href="#JDK6-gt-JDK7-x2F-8" class="headerlink" title="JDK6-&gt;JDK7&#x2F;8"></a>JDK6-&gt;JDK7&#x2F;8</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br><span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-built_in">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br><span class="hljs-built_in">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224322.png"><br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224329.png"></p><p>JDK1.6中，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象<strong>复制一份</strong>，放入池中，返回池中对象。</li></ul><p>JDK1.7后，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象的<strong>引用地址复制一份</strong>，放入池中，返回引用地址对象。</li></ul><p>简单讲，JDK7后的方式，省去了复制对象的开销。</p><h2 id="G1垃圾处理器去重String"><a href="#G1垃圾处理器去重String" class="headerlink" title="G1垃圾处理器去重String"></a>G1垃圾处理器去重String</h2><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。然后对队列中的元素进行去重处理。</li><li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ol><h1 id="七、垃圾回收"><a href="#七、垃圾回收" class="headerlink" title="七、垃圾回收"></a>七、垃圾回收</h1><h2 id="垃圾回收概念"><a href="#垃圾回收概念" class="headerlink" title="垃圾回收概念"></a>垃圾回收概念</h2><h3 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h3><p><strong>垃圾</strong>：垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>早期C&#x2F;C++，需要开发人员手动释放内存，若存在疏忽则会永久产生内存泄漏。</p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p>Java堆是垃圾收集器的工作重点</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h3 id="对象finalization机制"><a href="#对象finalization机制" class="headerlink" title="对象finalization机制"></a>对象finalization机制</h3><ul><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。</li><li>不要手动调用，应该由垃圾处理器调用<ul><li>调用可能使对象复活</li><li>执行时间无保证，取决于GC线程</li></ul></li><li>finalize()只能被调用一次，也就是说一个对象最多复活一次。</li></ul><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br>优点：</p><ul><li>实现简单，判断效率高。<br>缺点：</li><li>增加了对象的字段</li><li>加减法时间开销</li><li><strong>无法处理循环引用</strong><br>Python使用引用计数算法，通过弱引用解决循环引用的问题。</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>可达性分析算法是以<strong>根对象集合</strong>（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li></ul><h5 id="GCRoot"><a href="#GCRoot" class="headerlink" title="GCRoot"></a>GCRoot</h5><p>栈上引用</p><ul><li>虚拟机栈上引用对象</li><li>本地方法栈上引用对象</li></ul><p>方法区引用</p><ul><li>类静态属性</li><li>常量引用（String Table等）</li></ul><p>其他引用</p><ul><li>同步锁对象</li><li>虚拟机内部对象（class对象）</li><li>本地代码缓存等</li></ul><p>当然还要考虑GC的作用空间：对于young空间的某对象A，存在着被old空间的对象B引用的情况，因此old空间的对象也需要考虑到GCRoots集合中。</p><h4 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h4><p>由于finalize的存在，对象有三种状态。</p><ul><li>可触及</li><li>可复活</li><li>不可触及</li></ul><p>标记过程：</p><ol><li>若无引用，进行一次标记</li><li>若无finalize或finalize已经被执行过，进行二次标记，为不可触及。</li><li>若有finalize，加入F-Queue队列等待Finalizer线程执行finalize方法。</li><li>随后GC对F-Queue进行标记，看是否可触及，可触及则移出队列，否则移出并标记为不可触及。</li></ol><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231730.png"></p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p>缺点</p><ul><li>效率不高</li><li>STW</li><li>碎片</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231822.png"><br>优点</p><ul><li>不需要标记清除，直接复制可达对象，高效</li><li>无碎片<br>缺点</li><li>空间消耗大</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>Survivor区</li></ul><h4 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h4><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131232037.png"><br>优化了复制算法，使用原本的内存进行移动。</p><p><strong>指针碰撞</strong><br>指这种通过指针记录空闲空间的起始点，为新对象分配内存时可以直接分配。</p><p>优点</p><ul><li>相对标记清除，使用了指针碰撞</li><li>相对复制算法，不耗多余内存</li></ul><p>缺点</p><ul><li>效率比复制低（时间换空间）</li><li>移动对象时，若对象被其他对象引用，需要调整引用地址（与复制算法相同）</li><li>STW</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>对不同生命周期的对象采取不同的收集方式，以便提高回收效率。即，实际上的GC采用的是分代收集，其根据收集区域使用不同的收集方式。</p><ul><li>年轻代（Young Gen），空间不大，复制算法效率最高。</li><li>老年代（Tenured Gen），不同GC的处理方式不同。</li></ul><h3 id="增量收集算法与分区算法"><a href="#增量收集算法与分区算法" class="headerlink" title="增量收集算法与分区算法"></a>增量收集算法与分区算法</h3><h4 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h4><p>为了避免STW，GC线程与用户线程交替进行，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><p>缺点：线程上下文切换造成总吞吐量下降。</p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131233426.png"></p><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>提醒JVM进行FullGC,不保证立刻生效。</p><h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><ul><li>内存溢出：内存超了<ul><li>超出设置，可以调整</li><li>超出机器内存上限</li></ul></li><li>内存泄漏：存在不再使用的对象无法被回收<ul><li>例子：单例模式，资源未close<br>可以说内存泄漏是内存溢出的元凶之一。</li></ul></li></ul><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>标记过程（枚举GC Roots）需要STW，因为分析工作必须在一个快照中进行，否则准确性无法保证。</p><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上同时发生了，只在多核CPU存在。</li></ul><h4 id="对于垃圾回收"><a href="#对于垃圾回收" class="headerlink" title="对于垃圾回收"></a>对于垃圾回收</h4><p>并行（<em>Parallel</em>）：<strong>多条GC线程</strong>同时执行GC。<br>串行（<em>Serial</em>）：<strong>单GC线程</strong>执行GC。<br>并发（<em>Concurrent</em>）：<strong>用户线程与GC线程</strong>交替执行。</p><p>一次GC可能同时具有并行、并发的特性。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>只有在特定的位置才能STW，这些位置称为安全点。如果安全点过少，GC频率会很低。</p><p>中断方式：</p><ul><li>抢先式中断（已经不再使用），让所有线程在安全点中断。</li><li>主动式中断，线程运行到安全点后主动询问是否需要中断。</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点具有盲区，如果线程无法走到安全点（如Sleep或Block），也应该有中断的机会。<br>安全区域：<strong>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。</strong><br>因此，也可以把Safe Region看做是被扩展了的Safepoint。</p><p>执行时，若线程处于SaveRegion，则可以忽略该线程。当线程走出SaveRegion时，需要判断GC是否结束，若未结束则需要等待。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。<br>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们<br>分类：</p><ul><li>强引用（StrongReference）：引用赋值，不回收。</li><li>软引用（SoftReference）：内存不够（将要溢出前）时进行回收</li><li>弱引用（WeakReference）：GC时后回收</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>不回收，内存泄漏的主要原因之一。</li><li>可以直接访问目标对象。</li></ul><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><ul><li>内存不足即回收。</li><li>主要用于高速缓存。<br>软引用回收时，GC会选择性的将软引用放进一个<strong>引用队列</strong>。</li></ul><h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><ul><li>发现即回收。</li><li>GC时发现弱引用即回收。</li><li>也可用于缓存<br>比软引用回收更容易，更快。</li></ul><h4 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h4><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。<br>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><div class="note note-primary">            <p>简而言之，将对象放入虚引用后得到的引用sf没有任何作用。<br>但当Object被回收时，phantomQueue会被添加一个虚引用，表示对象已被回收。</p>          </div><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象。</p><div class="note note-primary">            <p>由此可见，引用总是伴随着引用队列，JVM根据队列依次对引用进行处理。</p>          </div><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。<br>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。<br>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。<br>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p><h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><ul><li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li>内存占用：Java堆区所占的内存大小。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul><p>主要抓住两点：<strong>吞吐量（总效率）、暂停时间（用户体验）</strong><br>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h3 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h3><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143734.png"><br>按线程和工作模式分：</p><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1<br>按内存区分：</li><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143826.png"></p><ul><li>红色虚线是JDK8已经被移除的GC</li><li>绿色虚线是JDK14中弃用的组合</li><li>蓝色框CMS GC已被删除</li></ul><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>我们选择的只是对具体应用最合适的收集器。<br><code>-XX:+PrintCommandLineFlags</code>可以查看默认参数。</p><h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><strong>Serial GC</strong>：STW，单线程，复制算法<br><strong>Serial Old GC</strong>：STW，单线程，标记-压缩算法。</p><div class="note note-primary">            <p>根据新老年代需求给出的最土味的算法。</p>          </div><h5 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h5><p>Serial Old是Client模式下的默认回收器。<br>简单高效，但单线程不太行，对于web应用不可接受，已经不用了。</p><h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>只回收新生代<br><strong>ParNew</strong>：STW，多线程，复制算法</p><div class="note note-primary">            <p>相对Serial回收器的多线程版本</p>          </div><h5 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h5><p>单CPU下不如串行，可以设置线程数。</p><h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p><strong>Parallel Scavenge</strong>：STW，多线程，复制算法<br><strong>Parallel Old</strong>：STW，多线程，标记压缩</p><div class="note note-primary">            <p>Parallel Scavenge相比于ParNew，回收的目标是<strong>最大的吞吐量</strong>，因此其可控制吞吐量，自适应调节。比较适合<strong>批处理</strong>。</p>          </div><h5 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h5><p>JDK8的Server模式下的默认回收器，可以设置线程数和垃圾收集器最大停顿时间，吞吐量，以及设置自适应调节策略。</p><h4 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h4><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201145934.png"><br>只回收老年代，是第一款并发收集器，用户线程与GC线程同时工作。<br><strong>CMS（Concurrent Mark Sweep）</strong>：STW，单&#x2F;多线程，标记-清除算法</p><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><ul><li>初始标记：STW，标记GCRoots以及其直接关联到的对象。</li><li>并发标记：根据GCRoots直接关联对象遍历对象图。</li><li>重新标记：STW，修正由于并发标记期间用户线程造成的变化。</li><li>并发清理：清除标记删除的对象，释放内存。<br>由于并发标记和并发清理最耗费时间，采用并发的方式，整体回收停顿很低。</li></ul><p>另外，由于并发标记，清理中用户线程仍在跑，需要提前进行CMS回收才能防止OOM，一般是当堆内存使用率达到某一阈值时，便开始进行回收。<br>由于标记清除，会产生内存碎片，只能通过<strong>空闲列表</strong>分配内存。</p><h5 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h5><ul><li>并发收集，低延迟</li><li>会产生内存碎片，低延迟但吞吐量不行。</li><li>无法处理浮动垃圾（并发标记期间产生的新垃圾）</li></ul><p>可以设置触发阈值，JDK9中标记过时，JDK14中已经删除。</p><h4 id="G1（Garbage-First）回收器"><a href="#G1（Garbage-First）回收器" class="headerlink" title="G1（Garbage First）回收器"></a>G1（Garbage First）回收器</h4><p>官方给G1设定的目标是在<strong>延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“全功能收集器”的重任与期望。只所以叫G1回收器是因为其优先回收垃圾最多的空间。<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151459.png"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>并行性：STW，多线程回收</li><li>并发性：部分工作可以与应用程序交替进行</li><li>分代：依然保持分代，但不要求连续空间，同时回收年轻代和老年代。</li><li>空间整合：Region之间复制算法，整体使用标记压缩，都避免内存碎片。</li><li>延迟：可以只回收一个Region，优先回收价值最大的Region。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不能碾压CMS，运行负担更大，小内存应用上CMS更好，大内存引用上G1更好。（6-8G左右）</li></ul><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li><li>当然也可以设置并发标记线程数和触发阈值。<br>提供三种垃圾回收模式：Young GC，Mixed GC，Full GC。</li></ul><h5 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h5><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151944.png"></p><ul><li>Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了找连续H区有时必须FullGC。</li><li>对每个Region内部使用指针碰撞方式分配空间（标记压缩）</li></ul><h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152200.png"></p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC） </li><li>全局GC（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p>一个对象可能被不同区域引用，<strong>Remembered Set是所有分代收集器避免全局扫描的关键</strong>。</p><p>G1的实现细节：<br>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；<br>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；<br>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152820.png"></p><p>更具体的：</p><ul><li>Card Table<ul><li>表中的每个entry覆盖512Byte的内存空间</li><li>当对应的内存空间发生改变时（如赋值操作的时候，会将该对象所在卡片标记），标记为dirty</li></ul></li><li>RememberSet（RSet）<ul><li>指向Card Table中对应的entry</li><li>可找到具体内存区域</li></ul></li></ul><p>当更新Region1的某指针时，会将Card标记为dirty，然后把Card存入Dirty Card Queue，这是因为RSet存在多线程竞争写入问题。</p><div class="note note-primary">            <p>即，将对象赋予给一个引用时，检查引用与对象是否在同一个region，若不在，则在对象所在region的remember set上记录对象被引用信息，最后在回收该区域时，将remember set上的对象也加入GCRoots。</p>          </div><h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p><img src="/2023/01/23/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201153244.png"><br>触发：当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。<br>回收范围：Eden区和Survivor区。<br>执行原理：STW，多线程，复制算法<br>过程：</p><ol><li>扫描root</li><li>更新rset（将Dirty Card Queue中的Card全部处理）</li><li>处理rset</li><li>复制对象</li><li>处理引用（存活对象的地址发送变化）</li></ol><h5 id="Conconrrent-Mark"><a href="#Conconrrent-Mark" class="headerlink" title="Conconrrent Mark"></a>Conconrrent Mark</h5><p>触发：堆内存达到45%时触发。<br>回收范围：Eden和Survivor区（触发一次Young GC）<br>过程：</p><ol><li>初始标记阶段：STW，扫描GCRoots，并触发一次Young GC（不一定立即执行）。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。<strong>这一过程必须在YoungGC之前完成。</strong></li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：STW，修正并发标记的问题。</li><li>独占清理（cleanup）：STW，计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h5 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h5><p>触发：并发标记结束后<br>回收范围：整个Young Region（Eden，Survivor），部分的Old Region(默认为1&#x2F;8，但分段执行8次)。<br>过程：<br>并发标记结束后，全垃圾的region已经被回收，部分垃圾的region已经被计算。使用和年轻代一样的方法GC即可。<br>备注：</p><ul><li>可以设置垃圾阈值，默认一个region只有垃圾占65%时才回收。</li><li>可以设置允许的垃圾阈值，当整堆中垃圾小于其时，不进行MixedGC。</li></ul><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>触发：以上方式无法正常工作（并发处理过程完成前空间耗尽）。<br>回收范围：整堆<br>特点：STW</p><h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</li><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。<br>回收器选择：官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><div class="note note-primary">            <p>G1回收器，三种清理模式：</p><ul><li>YoungGC：全程STW，根据GCRoots直接处理Young Region，注意rset的处理，region间复制算法。</li><li>MixedGC：<ul><li>STW扫描全局GCRoots压入扫描栈，并触发YoungGC</li><li>根区域扫描，即根据Survivor区找Old区的对象，也压入扫描栈，需要YGC之前完成。 </li><li>并发标记，根据扫描栈扫描对象。</li><li>STW修正标记，处理没处理的write barrier，即新出现的引用变化，但与CMS不同，这里的扫描范围只扫描SATB（snapshot-at-the-beginning），比CMS快。</li><li>STW计算区域属性</li><li>并发清理完全为空的区域</li><li>分段（默认8段）清理各区域。</li></ul></li><li>FullGC</li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>JVM</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第5章（集合）</title>
    <link href="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <url>/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="集合知识体系"><a href="#集合知识体系" class="headerlink" title="集合知识体系"></a>集合知识体系</h1><p><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109204736.png"><br>集合主要分Map和Collection两个体系:</p><ul><li>Map<ul><li>SortedMap<ul><li>NavigableMap</li></ul></li></ul></li><li>Collection<ul><li>List</li><li>Queue<ul><li>Deque</li></ul></li><li>Set<ul><li>SortedSet<ul><li>NavigableSet</li></ul></li></ul></li></ul></li></ul><div class="note note-primary">            <p>以上都是接口，从功能角度上对集合进行了分类。</p><ul><li>Map作为字典，重要的是其搜索能力，所以其有sorted-&gt;navigable的继承接口。</li><li>Collection中<ul><li>List体现的是对数组的封装，可以随机获取。</li><li>Queue体现单端的进出（堆）<ul><li>Deque实现双端的任意出入</li></ul></li><li>Set需要去重，重要的同样是其搜索能力，所以与map类似，有sorted-&gt;navigable的继承。</li></ul></li></ul>          </div><div class="note note-success">            <p>从基本的实现来看:</p><ul><li>Map<ul><li>map的朴素实现是HashMap<ul><li>HashMap有时需要保留先后顺序，LinkedHashMap继承自HashMap</li></ul></li><li>map搜索增强的实现是TreeMap</li><li>还有一些功能性Map(不做重点)，直接继承Map<ul><li>WeakHashMap，软引用，处于缓存角度，键值可以被回收</li><li>IdentifyHashMap，判断两值相等，只看其引用地址的16位hash（强相等）</li><li>EnumMap，只允许key为指定枚举值，底层其实是array实现。</li></ul></li></ul></li><li>Collection<ul><li>list的朴素实现是ArrayList<ul><li>vector还继承了list，是线程安全的，但已不推荐使用。<ul><li>stack继承了vector，先入先出</li></ul></li></ul></li><li>queue的实现是PriorityQueue(堆)<ul><li>deque的朴素实现是<strong>LinkedList</strong>，这个类也继承了List和Queue，三姓家奴</li><li>deque的另一个实现是ArrayDeque</li></ul></li><li>set与map类似，有HashSet-&gt;LinkedHashSet,TreeSet等实现。</li></ul></li></ul>          </div><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>继承：ArrayList实现了List接口<br>null：允许放入null<br>底层实现：array<br>同步：同步类为vector</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当数组capacity &#x3D;&#x3D; size时添加新元素</li><li>数组扩容通过一个公开的方法<code>ensureCapacity(int minCapacity)</code>来实现。</li><li>每次大约扩容1.5倍。<br><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109213925.png"></li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li>每次add前通过<code>ensureCapacity()</code>确保容量足够</li><li><code>add(int index,E e)</code>，需要先对元素进行移动<br><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109214209.png"></li><li><code>addAll()</code>，注意addAll不会调用add，其需要保证modCount只+1次。</li></ul><h3 id="set-x2F-get"><a href="#set-x2F-get" class="headerlink" title="set()&#x2F;get()"></a>set()&#x2F;get()</h3><p>直接操作数组即可，不过要检查参数索引是否越界。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><ul><li><code>remove(int index)</code>移除指定坐标，原地copy数组完成</li><li><code>remove(Object o)</code>移除指定对象，底层通过equals判断</li></ul><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>将底层数组的容量调整为当前列表保存的实际元素的大小。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index，也通过equals判断。</p><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>快速失败，modCount标记操作数，避免并发带来的不确定风险。</p><div class="note note-primary">            <p>注意，除了扩容，其他的remove操作只会在原数组上进行copy，通过size维护有效数组大小即可。</p>          </div><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>注意不存在哑节点。</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>LinkedList同时实现了List接口和Deque接口。<br>不过现在的首选是ArrayDeque，其底层通过数组实现，性能更好。</p><h2 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h2><h3 id="底层-1"><a href="#底层-1" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><ul><li><code>getFirst()</code>, <code>getLast()</code>直接获取即可。</li><li><code>get(int index)</code>，通过<code>node(index)</code>获取节点并修改。</li></ul><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h3><p>底层调用unlink方法释放节点。</p><ul><li><code>removeFirst()</code>, <code>removeLast()</code>直接删除，调整指针即可。</li><li><code>remove(e)</code>需要迭代equals判断</li><li><code>remove(index)</code>同理（调用<code>node(index)</code>）<br>ps:</li><li>注意，以上方法都会先对操作的可行性进行判断。</li><li>查找指定索引节点的方法为<code>node(index)</code>，其会根据index判断从前开始找还是从后开始找速度快。</li></ul><h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><ul><li><code>add(E e)</code>直接加到尾部</li><li><code>add(int index,E e)</code>需要线性查找(也会先找<code>node(index)</code>)</li></ul><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>同arraylist，不会调用add()。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>会迭代将node之间引用清空，加快清理速度。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>通过equals迭代判断。</p><h3 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h3><p>上面都是一些list方法的实现，linkedlist还实现了queue和deque，以下是对这些类的实现。<br>peek(),element(),poll(),remove(),offer()</p><ul><li>peek,element,poll,remove都是操作头元素，offer操作尾元素</li><li>element调用<code>getFirst()</code>会抛出空异常，peek()返回null。</li></ul><h3 id="Deque方法"><a href="#Deque方法" class="headerlink" title="Deque方法"></a>Deque方法</h3><p>offerFirst,offerLast,peekFirst,peekLast,pollFirst,pollLast,push,pop</p><ul><li>push，pop都操作头元素。</li></ul><div class="note note-primary">            <p>记忆，</p><ul><li><code>peek,push,pop</code>属于栈方法，操作头元素</li><li><code>peek,offer,poll</code>属于队列方法，默认操作头元素，不会异常，且有双端方法可以使用</li><li><code>add,remove</code>属于list方法，操作尾部元素</li></ul>          </div><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>stack是一个具体的实现类，而Queue却没有，这是一个反常理的事情，不过现在Java已经不推荐使用Stack了，<code>ArrayDeque</code>往往更高效。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是一个接口，实现了Collection接口，其队列特殊方法不会抛出异常。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>deque是一个接口，实现了Queue接口，表示双向队列，支持双向的队列操作。<br>deque常见的实现是LinkedList和ArrayDeque</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>底层通过数组实现，且数组为循环数组，即任一点都可以是起点或终点，如下图。<br><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109232400.png"></p><h3 id="机制-2"><a href="#机制-2" class="headerlink" title="机制"></a>机制</h3><p>ArrayDeque不允许放入null</p><h4 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h4><p><code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code><br>会对head-1取模，如果<code>head-1==-1</code>,则得到的head&#x3D;<code>elements.length - 1</code>，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><div class="note note-primary">            <p>elements.length总为偶数，-1后为全1。<br><code>(head - 1) &amp; (elements.length - 1)</code>相当于对<code>head-1</code>对<code>elements.length-1</code>做取模处理。</p><ul><li>head值若超过length-1，则相当于取余</li><li>head-1若为负数，相当于取对element.length的补码。</li><li>实际上head-1最小为-1，取补码后等于element.length-1。</li></ul>          </div><h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><p>容量满了就需要扩容，方法是<code>doubleCapacity()</code>。<br><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109233801.png"></p><ul><li>第一次复制<code>head</code>右边的元素。</li><li>第二次复制<code>head</code>左边的元素。</li></ul><h4 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h4><p><code>(tail = (tail + 1) &amp; (elements.length - 1)) == head</code><br>tail+1取模，若<code>tail+1==elements.length-1</code>，则得到的tail &#x3D; 0，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><h3 id="pollFirst-pollFirst-peekLast-，pollLast"><a href="#pollFirst-pollFirst-peekLast-，pollLast" class="headerlink" title="pollFirst(),pollFirst(),peekLast()，pollLast()"></a>pollFirst(),pollFirst(),peekLast()，pollLast()</h3><p>返回对应值，为空则返回Null。</p><div class="note note-primary">            <p>注意，ArrayList扩容是1.5倍，ArrayDeque扩容是2倍。</p>          </div><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><ul><li>优先队列不允许放入<code>null</code>元素。</li><li>其通过完全二叉树的小顶堆实现。</li></ul><h3 id="机制-3"><a href="#机制-3" class="headerlink" title="机制"></a>机制</h3><h4 id="底层-2"><a href="#底层-2" class="headerlink" title="底层"></a>底层</h4><p>PriorityQueue底层通过数组维护堆结构<br><code>leftNode = parentNode*2+1</code><br><code>rightNo = parentNo*2+2</code><br><code>parentNo = (nodeNo-1)/2</code></p><h4 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h4><p>使用<code>grow()</code>函数，会复制原数组元素到新数组</p><h4 id="element-peek"><a href="#element-peek" class="headerlink" title="element(),peek()"></a>element(),peek()</h4><p>一个会抛异常，一个不会。都返回下标为0的元素。</p><h4 id="add-offer"><a href="#add-offer" class="headerlink" title="add(),offer()"></a>add(),offer()</h4><p>add、offer，添加在数组末尾，然后逐步向上调节。<br>会调用<code>siftUp(int k, E x)</code>，用于在指定位置插入节点并进行调整。</p><h4 id="remove-poll"><a href="#remove-poll" class="headerlink" title="remove(),poll()"></a>remove(),poll()</h4><p>一个会抛异常，一个不会，都移除下标为0的元素，然后进行堆调整。<br>会调用<code>siftDown(int k, E x)</code>，用于在指定位置删除节点并进行调整。</p><div class="note note-primary">            <p>siftUp，siftDown会根据指定元素x，不断对该位置及其上&#x2F;下的节点进行比较并移动，直到满足找到x小于&#x2F;大于目标节点的时候截至。</p>          </div><h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p>遍历数组删除第一个equals的元素。</p><h1 id="HashSet-amp-HashMap"><a href="#HashSet-amp-HashMap" class="headerlink" title="HashSet&amp;HashMap"></a>HashSet&amp;HashMap</h1><p>二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，即默认value &#x3D;&#x3D; null。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashTable是同步的HashMap。该map不保证元素顺序。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。</p><h3 id="Java7"><a href="#Java7" class="headerlink" title="Java7"></a>Java7</h3><p>HashMap采用的是冲突链表方式**。<br><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110203318.png"></p><p>可见put，get方法可以在常数时间完成，但若table过大，对map进行遍历就会很耗时。</p><p>有<strong>两个参数</strong>可以影响HashMap的性能: 初始容量(<em>inital capacity</em>)和负载系数(<em>load factor</em>)。</p><ul><li>初始容量指定了初始<code>table</code>的大小</li><li>负载系数用来指定自动扩容的临界值。<br>当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</li></ul><p>将对象放入到HashMap或HashSet中时，有<strong>两个方法</strong>需要特别关心：<code>hashCode()</code>和<code>equals()</code>。</p><ul><li><strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。</li><li>所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><p>先<code>getEntry</code>，然后<code>getValue</code><br>其中getEntry先通过hashCode判断bucket，然后通过equals遍历判断。</p><p>求bucket的过程：<br><code>hash(k)&amp;(table.length-1)</code>，与list扩容类似，取模。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>先<code>getEntry</code>，如果没有则<code>addEntry</code>。在链表中使用头插法。</p><h4 id="remove-2"><a href="#remove-2" class="headerlink" title="remove()"></a>remove()</h4><p>先<code>getEntry</code>，然后remove。</p><h3 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h3><p>由 <strong>数组+链表+红黑树</strong> 组成。<br>当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="/2023/01/09/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110204320.png"><br>链表的元素为<code>Node</code>，红黑树的元素为<code>TreeNode</code>，通过头节点的类型判断是链表还是红黑树。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 <strong>2 倍</strong>，并进行数据迁移。<br>ps:java7是先扩容再插值，java8是先插值再扩容。</p><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p>判断是红黑树还是链表，采用不同方法取值。</p><p>具体红黑树讲解见TreeMap</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>就是对HashMap的一层包装。</p><h1 id="LinkedHashMap-amp-LinkedHashSet"><a href="#LinkedHashMap-amp-LinkedHashSet" class="headerlink" title="LinkedHashMap&amp;LinkedHashSet"></a>LinkedHashMap&amp;LinkedHashSet</h1><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>实现了map接口，<strong>允许放入key或value为null的元素</strong>，也是HashMap的子类。其使用双向链表将所有entry相连接。并多了header和tail指向<code>头部</code>和<code>尾部</code>。</p><p>优点：遍历时不用遍历所有bucket，只用遍历entrylist即可。</p><p>有<strong>两个参数</strong>可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。<br>将对象放入到LinkedHashMap或LinkedHashSet中时，有<strong>两个方法</strong>需要特别关心: <code>hashCode()</code>和<code>equals()</code>。</p><p>这点与HashMao相同。<br>其没有同步化实现，若需要同步，可使用：<br><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p><h3 id="get-3"><a href="#get-3" class="headerlink" title="get()"></a>get()</h3><p>同HashMap</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><p>也是先getEntry，然后再addEntry<br>add时，既要使用头插法插入bucket链表头部，也要将其插入linkedlist的尾部。</p><h3 id="remove-3"><a href="#remove-3" class="headerlink" title="remove()"></a>remove()</h3><p>同样先get，然后remove，同时维护两个链表。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>是LinkedHashMap的简单包装。</p><h1 id="TreeSet-amp-TreeMap"><a href="#TreeSet-amp-TreeMap" class="headerlink" title="TreeSet&amp;TreeMap"></a>TreeSet&amp;TreeMap</h1><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeSet是对TreeMap的一层包装。</p><p>底层通过红黑树实现。意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。</p><p>TreeSort是非同步的，若需要同步，可以使用：<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1d64y1z7Uk?p=20&vd_source=7324e975d0c1b4b4719d1194e3649ff8">bilibili</a><br>参考blog：<a href="https://www.bilibili.com/read/cv17486236">bilibili</a><br><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。</p><p>性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。<br>树结构改变时，任意破坏3，4，因此需要调整。</li></ol><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="234树"><a href="#234树" class="headerlink" title="234树"></a>234树</h4><p>一种特殊的搜索树。</p><ul><li>2节点表示3个key组成的一个节点</li><li>3节点表示3个key组成的一个节点</li><li>4节点表示3个key组成的一个节点</li></ul><p>当给234树添加节点时</p><ul><li>通过搜索找到应该插入的节点。</li><li>如果该节点位置已经有不超过3个节点，则可以进行合并。</li><li>如果已经为4节点，则需要拆解出节点并向上移动。</li></ul><p>因为这样自底向上的插入性质，其所有根节点的高度总是相等的。</p><h4 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是可以和234树等价的。</p><ul><li>2节点表示一个黑节点</li><li>3节点表示一个红节点和其一个黑子节点</li><li>4节点表示一个红节点和其两个黑子节点</li></ul><p>另外红黑树每个叶子节点都是黑节点（一般是隐藏的，其不会影响红黑树的3，4性质）</p><h4 id="左旋-x2F-右旋"><a href="#左旋-x2F-右旋" class="headerlink" title="左旋&#x2F;右旋"></a>左旋&#x2F;右旋</h4><p>以x节点为中心左旋，其右子节点r会成为x节点的父节点。右子节点r的左节点rl会称为x的右节点。<br>右旋同理，左右旋主要是为了调整树的节点构造，在不影响整体高度的情况下达到我们想要构造。</p><h4 id="节点后继"><a href="#节点后继" class="headerlink" title="节点后继"></a>节点后继</h4><p>搜索树中某节点x有前继pre（比x小的最大节点）和后继post（比x大的最小节点）节点。这两个节点可以完美替换节点x。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="get-4"><a href="#get-4" class="headerlink" title="get()"></a>get()</h4><p>按照常规二叉搜索树寻找即可。<br>底层根据compareTo()的返回值判断进行迭代。</p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h4><p>先查找，若没有，则add。<br>其可能破坏红黑树约束条件，因此需要调整。<br>1.默认插入RED节点。<br>2.1.若其父节点也为BLACK节点，不影响高度（return）。<br>2.2.若其父节点也为RED，需要调整父节点及其叔叔节点为BLACK(+1)，并让爷爷节点为RED(-1)。<br>3.迭代至根节点。</p><h4 id="remove-4"><a href="#remove-4" class="headerlink" title="remove()"></a>remove()</h4><p>先查找，若有，则remove。<br>其可能破坏红黑树约束条件，因此需要调整。</p><p>1.可能移除树中任意位置的节点，可以通过<strong>值替换</strong>的方式转化为移除其前继或<strong>后继</strong>节点，最终只会删除叶子节点或有单侧叶子节点的节点</p><p>2.1.若移除的是RED节点，不影响高度(return)。<br>2.1.1如果该节点是叶子节点，直接(return)<br>2.1.2如果该节点有单侧叶子节点，由叶子节点替代该节点（return）。</p><p>2.2.若移除的是BALCK节点L，需要调整。<br>2.2.1如果该节点是叶子节点，需要先调整，再移除<br>2.2.2如果该节点有单侧子节点，由子节点替代该节点后，再调整。</p><div class="note note-primary">            <p>所谓调整，本质上是一个方法 f(Node node)，其能让node节点这一侧补充一个黑色节点高度。核心思想是，由于移除了黑色节点L，该侧高度（-1），需要找一个节点（且为黑色）补充回来。</p><ul><li>如果L有红色子节点，将其提升后染黑即可。</li><li>如果L没有红色子节点，需要将其父节点P的左&#x2F;右旋，将P移到该侧填补黑色节点。然后由其兄弟节点提升多余节点（兄弟节点有红色子节点）代替父节点并进行调整。</li><li>如果兄弟节点R没有多余红色节点，则将兄弟节点一起染红，然后迭代其父节点P作为L。</li></ul>          </div><p>2.3.1.如果替代上来的节点是红色节点，将其染黑即可(return)<br>2.3.2.如果原节点(2.2.1)或替代上来的节点是黑色节点(2.2.2)，需要进行旋转调整。<br>2.3.3.事实上这不会容易，父节点P左旋时，其右节点R会成为新的父节点，这会导致右侧减去一个节点R，因此，右旋时要保证右侧的高度也不变，需要满足以下几种条件之一：<br>2.4.1.如果兄弟节点为红色，说明其不是真正的兄弟节点（因为234树中3节点和4节点都应该是黑色节点为根），此时应该<strong>调整兄弟节点成黑色节点为根的形态</strong>(通过左&#x2F;右旋并调整颜色实现，达到2.4.2)。<br>2.4.2.如果兄弟节点为黑色，考虑其子节点是否有红色节点可以借用。<br>2.4.2.1.兄弟节点有红色子节点：</p><ul><li>将父节点左旋，并染黑，补充L侧的黑节点个数</li><li>原兄弟节点成为新的父节点，将其调整为原父节点P的颜色</li><li>原兄弟节点的子节点成为新父节点的右节点，将其染黑补充R侧的黑节点个数</li><li>return<br>2.4.2.2.兄弟节点没有红色子节点:</li><li>将兄弟节点染红，则导致父节点到叶子的路径总体-1，以父节点为新的L迭代2.2.1步，可以将其视为一个整体。<br>2.5最终达到root时，return。</li></ul><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>具体实现类似HashMap，弱引用可以访问对象，但这不是有效引用，即被引用的对象可以被GC回收。<br>WeakHashMap内部通过弱引用管理entry。<br>想要获取HashSet，需要使用：<br><code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>，其可以将任意map转化为set。</p><h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><p>PriorityQueue，TreeSet不允许传入空值，因为其需要比较，其他集合都可以传入Null。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><table><thead><tr><th>不安全</th><th>安全实现</th><th>ConCurrent</th></tr></thead><tbody><tr><td>ArrayList</td><td>Vector&#x2F;Stack</td><td>暂无</td></tr><tr><td>LinkedList</td><td>Collections.synchronizedList(List)</td><td>暂无</td></tr><tr><td>PriorityQueue</td><td>无</td><td>暂无</td></tr><tr><td>HashMap</td><td>Hashtable</td><td>暂无</td></tr><tr><td>LinkedHashMap</td><td>Collections.synchronizedMap(Map)</td><td>暂无</td></tr><tr><td>TreeMap</td><td>Collections.synchronizedSortedMap(SortedMap);</td><td>暂无</td></tr><tr><td>NavigableMap</td><td>Collections.synchronizedNavigableMap(NavigableMap)</td><td>暂无</td></tr></tbody></table><p>Set的Collections包装方法类似map，待补充todo。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第4章（注解、异常、反射）</title>
    <link href="/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/"/>
    <url>/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li><strong>生成文档</strong>，通过代码里标识的元数据生成javadoc文档。</li><li><strong>编译检查</strong>，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li><strong>编译时动态处理</strong>，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li><strong>运行时动态处理</strong>，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是注解的注解，一般用于标识注解的属性</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>描述注解的使用范围，即可以在哪些对象上使用注解（常见的有TYPE,FILED,METHOD）等等。</p><h3 id="Retention-amp-RetentionTarget"><a href="#Retention-amp-RetentionTarget" class="headerlink" title="@Retention &amp; @RetentionTarget"></a>@Retention &amp; @RetentionTarget</h3><p>描述注解的保留时间（注意这里是指被保留到什么时候）有（SOURCE,CLASS,RUNTIME）三种策略。</p><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p>被其修饰的注解在标记在 其他对象上后，使用 javadoc 工具为类生成帮助文档时<strong>会保留其注解信息</strong>。</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>被其修饰的注解是否有继承性，如某类使用注解A，其子类也会继承注解A</p><h3 id="Reaptable"><a href="#Reaptable" class="headerlink" title="@Reaptable"></a>@Reaptable</h3><p>描述注解是否可以重复使用，即在一个对象上多次标注（但使用不同的参数）</p><h3 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h3><p>被其修饰的<strong>成员变量</strong>可以被本地方法引用，使用较少。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：<strong>编译检查</strong>，会检查是否按规范重写了父类方法。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：表示这个对象已经过时。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;<br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭编译器警告,可传入<code>String[]</code>著名需要抑制的警告类型。</p><h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><p>如何获取注解信息？<br>通过反射即可获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; T <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span><br><br>Annotation[] getAnnotations()<br></code></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyMethodAnnotation &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">title</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><h3 id="JDK8新注解"><a href="#JDK8新注解" class="headerlink" title="JDK8新注解"></a>JDK8新注解</h3><ul><li>@Repeatable</li><li>新的Target参数<code>ElementType.TYPE_PARAMETER</code>，包括type和parameter。</li></ul><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p>注解之间无法继承，但编译后统一继承<code>java.lang.annotation.Annotation</code></p><h3 id="注解实现原理"><a href="#注解实现原理" class="headerlink" title="注解实现原理"></a>注解实现原理</h3><ul><li>注解是一个继承自Annotation的接口，里面每一个属性其实是一个接口的抽象方法。</li><li>使用注解时，会创建一个注解实例对象，该对象是通过jdk动态代理生成的（在<code>AnnotationInvocationHandler()</code>方法中就封装了代理的逻辑）</li></ul><h3 id="注解引用场景"><a href="#注解引用场景" class="headerlink" title="注解引用场景"></a>注解引用场景</h3><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架从配置化 -&gt; 注解化</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP实现统一日志管理，实现模块的解偶。<br>具体就是以@Log为切点，然后对方法进行增强。</p><h1 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h1><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br><img src="/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109184839.png"></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error是JVM无法处理的错误。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><ul><li>Exception是可以被捕获，处理的异常。分为两类：运行时异常和编译时异常。</li><li>运行时异常（不会检查的）：NullPointerException,IndexOutOfBoundsException</li><li>非运行时异常（必须处理的）：IOException、SQLException。</li></ul><h3 id="可检查异常和不可检查异常"><a href="#可检查异常和不可检查异常" class="headerlink" title="可检查异常和不可检查异常"></a>可检查异常和不可检查异常</h3><p>除了Error，RuntimeException及其子类，其他都是可检查异常，需要在编写程序时对其进行解决。</p><h3 id="异常使用"><a href="#异常使用" class="headerlink" title="异常使用"></a>异常使用</h3><ul><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。如果try,catch中有return或throw，会先执行完finally再回去执行返回行为（return&#x2F;throw），如果finally中有返回行为，则不会再回去执行。finally可以脱离catch使用。</li><li><strong>throw</strong> – 用于<strong>抛出</strong>异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法<strong>可能抛出</strong>的异常。</li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>必须声明方法可抛出的任何可查异常（checked exception）。</p><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时会在catch中抛出另一个异常，主要是为了封闭异常细节。</p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>继承Exception即可，习惯上要定义无参和具有描述信息的构造函数。</p><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>JAVA7中引入，会自动关闭资源。需要该资源实现了AutoCloseable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br><span class="hljs-comment">// code</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br><span class="hljs-comment">// handle exception</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>JVM处理异常的机制涉及Exception Table，以下称为异常表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatch</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: goto          <span class="hljs-number">11</span><br>       <span class="hljs-number">6</span>: astore_0<br>       <span class="hljs-number">7</span>: aload_0<br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><p>异常表按<strong>catch顺序</strong>记录的异常捕获信息，包括：</p><ul><li><strong>from</strong> 可能发生异常的起始点</li><li><strong>to</strong> 可能发生异常的结束点</li><li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li><li><strong>type</strong> 异常处理者处理的异常的类信息</li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatchFinally</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">11</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">14</span>: astore_0<br>      <span class="hljs-number">15</span>: aload_0<br>      <span class="hljs-number">16</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">19</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">22</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">27</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">30</span>: astore_1<br>      <span class="hljs-number">31</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">34</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">36</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">39</span>: aload_1<br>      <span class="hljs-number">40</span>: athrow<br>      <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">14</span>   Class java/lang/Exception<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">30</span>   any<br>          <span class="hljs-number">14</span>    <span class="hljs-number">19</span>    <span class="hljs-number">30</span>   any<br></code></pre></td></tr></table></figure><p>一个finally会产生两个捕获表条目，表示try或catch中发送任何异常其都可以捕获并跳转到30执行。<br>如果方法有返回值，为了保证finally执行，会在编译时将finally中内容编译在return语句前。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Class类也是一个类，不同的类都有一个Class类的实体存在于堆中。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><img src="/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191903.png"><br><img src="/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191923.png"></p><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><h4 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h4><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li><li>类加载器：xxxClassLoader.loadClass(全限定类名)</li></ul><div class="note note-primary">            <p>其中，通过类名.class，类加载器.loadClass获取class对象，不会进行类加载的初始化，此时静态代码块和静态对象不会执行。</p>          </div><h4 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h4><p>可以通过class对象获取该类的构造器。</p><ul><li>getConstructors() 获取所有public构造器</li><li>getDeclaredConstructors() 获取所有声明的构造器<br>以上两个方法不构成覆盖关系，getDeclaredConstructors能获取私有构造器，却无法获取继承到的public构造器。</li></ul><div class="note note-primary">            <p>Field&#x2F;Method的获取中的declared也类似。</p>          </div><h4 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h4><p><code>method.invoke(Object obj, Object... args)</code><br>可以使用arg作为参数，执行obj的method方法</p><h2 id="深入反射"><a href="#深入反射" class="headerlink" title="深入反射"></a>深入反射</h2><p><img src="/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109192732.png"></p><div class="note note-primary">            <p>获取类对象时，只会对类进行加载、链接。<br>只有通过<strong>forName获取类对象</strong>或<strong>创建该类的对象</strong>或<strong>使用该类的静态变量</strong>时才会进行初始化，详情见JVM。</p>          </div><blockquote><p>这里做一下区分，有具体实现的是java程序，没有具体实现的我们认为是交给JVM的(native)。</p></blockquote><ul><li>类加载<ul><li>forName会加载类，其会调用本地方法加载类（交给JVM）</li><li>JVM回调类加载其对类进行加载</li></ul></li><li>实例生成<ul><li>查找构造器，若没有则从JVM获取，有则直接从缓存中取出。缓存的结构名为ReflectionData，Class对象对该缓存使用了软引用，通过reflection()方法获取缓存。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>反射也是考虑了线程安全的，放心使用；</li><li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ul><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>SPI（Service Provider Interface）服务发现机制，主要用于框架开发。核心思想就是解偶。<br><img src="/2023/01/09/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109194225.png"><br>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。<br>当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><p>例子：<br>java定义了java.sql.Driver接口。<br>mysql提供了mysql-connector-java-6.0.6.jar，其META-INF&#x2F;services下有文件<code>java.sql.Driver</code>，其内容为<code>com.mysql.cj.jdbc.Driver</code>，表示使用<code>com.mysql.cj.jdbc.Driver</code>实现<code>java.sql.Driver</code>。</p><h3 id="SPI和API区别"><a href="#SPI和API区别" class="headerlink" title="SPI和API区别"></a>SPI和API区别</h3><ul><li>SPI - “接口”位于“调用方”所在的“包”中，由外部实现该接口。</li><li>API - “接口”位于“实现方”所在的“包”中，服务自身实现该接口。</li></ul><h3 id="SPI缺点"><a href="#SPI缺点" class="headerlink" title="SPI缺点"></a>SPI缺点</h3><ul><li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第3章（泛型）</title>
    <link href="/2023/01/08/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/"/>
    <url>/2023/01/08/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><h2 id="泛型的功能"><a href="#泛型的功能" class="headerlink" title="泛型的功能"></a>泛型的功能</h2><p>代码复用，使用一个代码流程适配多个类型。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class="hljs-keyword">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h2><p>使用泛型时，我们可以具体制定此时需要适配的类型，然后<strong>编译器</strong>会根据此进行类型检查，约束编码。</p><h1 id="二、泛型的基本使用"><a href="#二、泛型的基本使用" class="headerlink" title="二、泛型的基本使用"></a>二、泛型的基本使用</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>创建该类的对象的时候可以制定泛型的具体类型，其方法也会适配。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&lt;T&gt;&#123;         <span class="hljs-comment">// 此处可以随便写标识符号，T是type的简称  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;     <span class="hljs-comment">// var的类型由T指定，即：由外部指定  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 返回值的类型由外部决定  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <span class="hljs-comment">// 设置的类型也由外部决定  </span><br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsDemo01</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;  <br>        Point&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>&lt;String&gt;() ;     <span class="hljs-comment">// 里面的var类型为String类型  </span><br>        p.setVar(<span class="hljs-string">&quot;it&quot;</span>) ;                            <span class="hljs-comment">// 设置字符串  </span><br>        System.out.println(p.getVar().length()) ;   <span class="hljs-comment">// 取得字符串的长度  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用多元泛型&lt;A,B&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.value = value ;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>不要惧怕<code>&lt;&gt;</code>，其就是一个用来传参的窗口，类似与方法中在<code>()</code>写入多个参数，泛型则是在<strong>类&#x2F;接口的创建</strong>或<strong>方法的使用</strong>时，传入类型的参数<code>&lt;type1,type2&gt;</code>，从而令类型、方法等具体化。</p>          </div><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>可见定义接口和定义类类似，在实现该接口时，也应该使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;        <span class="hljs-comment">// 在接口上定义泛型  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> ; <span class="hljs-comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;   <span class="hljs-comment">// 定义泛型接口的子类  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;             <span class="hljs-comment">// 定义属性  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InfoImpl</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;     <span class="hljs-comment">// 通过构造方法设置属性内容  </span><br>        <span class="hljs-built_in">this</span>.setVar(<span class="hljs-keyword">var</span>) ;    <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个非泛型类里面也可以有泛型方法，泛型方法的目的也是可以对一个泛型方法传入多种类型的参数，而不需要new很多泛型类来实现。<br>同时，泛型方法就是为了适配不同类型的参数，所以一般在声明方法时，型参的类型也是一个泛型类，如下面的<code>Class&lt;T&gt;</code>。</p><p>此时泛型的类别应该在调用该方法时，通过参数？todo或其他方式，指明类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getObject</span><span class="hljs-params">(Class&lt;T&gt; c)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> c.newInstance();<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-type">Clazz</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clazz</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz1.getObject(Class.forName(<span class="hljs-string">&quot;com.cnblogs.test.User&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>泛型方法需要在修饰符后面加上<code>&lt;T&gt;</code>来标识这是一个泛型方法。</li><li>泛型方法需要使用泛型类型的型参来，使用时传入具体的泛型类型来适配。</li></ul><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>普通方法使用泛型，该方法不属于泛型方法，参数是泛型类，且已经制定了具体的泛型类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;Integer&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h2><p>泛型有一个问题，即</p><ul><li>Even <code>A extends B</code> but <code>List&lt;A&gt;  not extends List&lt;B&gt;</code><br>假如，现在有一个普通方法，参数是一个泛型类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;B&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>如果传入一个<code>List&lt;A&gt;</code>则会出现报错。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用上下边界机制解决,如：</p><h4 id="泛型方法-1"><a href="#泛型方法-1" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;? extends B&gt; list)</span>&#123;&#125;;<br><span class="hljs-comment">//下限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Info&lt;? <span class="hljs-built_in">super</span> String&gt; temp)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="泛型类-1"><a href="#泛型类-1" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;&#123;    <span class="hljs-comment">// 此处泛型只能是数字类型</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;        <span class="hljs-comment">// 定义泛型变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 直接打印</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span>.toString() ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>泛型上下限使用上下限 限制了 泛型的<strong>具体类型</strong>，此时注意<code>？</code>才是真正的泛型类型。<br>具体使用时，</p><ul><li>如果该 类&#x2F;方法 是对 界限类型T的生产者，则使用<code>&lt;? extends T&gt;</code>，即在类&#x2F;方法中有类似T t &#x3D; new B(实际传入的类型)，这类<strong>生产T</strong>的操作。即可以创造一个<code>List&lt;? extends Fruit&gt;</code>，然后我们可以通过getNode()，来确保我们能获取一个Fruit。</li><li>如果该 类&#x2F;方法 是对 界限类型T的消费者，则使用<code>&lt;? super T&gt;</code>，即在类&#x2F;方法中有类似 addNode(T t)，这类<strong>消费T</strong>的操作。一般用于泛型类当中，即可以创造一个<code>List&lt;? super Apple&gt;</code>，这样就知道往这个集合里add Apple或其子类肯定是可行的，因为Apple及其子类肯定也是<code>？</code>具体类型的子类。</li></ul><p>所以，上限确保我们可以得到一个具体类型<strong>T</strong>的引用（生产），下限确保我们可以往类型&#x2F;方法中消耗<strong>T</strong>(消费)。</p>          </div><div class="note note-primary">            <ul><li>在具体的泛型类&#x2F;泛型方法的<strong>声明</strong>中，一般使用<code>T</code>或<code>T extends Clazz</code>声明泛型，然后使用<strong>T</strong>进行操作。</li><li>在具体的普通引用&#x2F;普通方法的参数<strong>声明</strong>中，一般使用<code>List&lt;?&gt;</code>或<code>List&lt;? extends Clazz&gt;</code>，对传入的泛型对象的具体类型的限制。</li></ul>          </div><h4 id="多限制"><a href="#多限制" class="headerlink" title="多限制"></a>多限制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Staff</span> &amp; Passenger&gt;<br></code></pre></td></tr></table></figure><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;<span class="hljs-keyword">String</span>&gt;[] list13 = (List&lt;<span class="hljs-keyword">String</span>&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告 </span><br>List&lt;?&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;?&gt;[] list15 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK</span><br></code></pre></td></tr></table></figure><h1 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h1><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure）。</p><div class="note note-primary">            <p>回到本质，java泛型本质是为了复用代码，泛型则用于在编码时限制，编译时会对其进行擦除。</p>          </div><p>具体操作：</p><ul><li>T和？和? super Clazz都替换为Object<br><img src="/2023/01/08/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011238.png"></li><li>T extends Clazz&#x2F;? extends Clazz替换为Clazz<br><img src="/2023/01/08/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011241.png"></li></ul><h3 id="泛型方法-2"><a href="#泛型方法-2" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span><br></code></pre></td></tr></table></figure></li><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float </span><br></code></pre></td></tr></table></figure></li></ul><h3 id="编译期检查"><a href="#编译期检查" class="headerlink" title="编译期检查"></a>编译期检查</h3><p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p><p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过</span><br></code></pre></td></tr></table></figure><h3 id="泛型多态"><a href="#泛型多态" class="headerlink" title="泛型多态"></a>泛型多态</h3><p>类型擦除会导致多态冲突，如继承一个具体泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Date&gt; &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>        <span class="hljs-built_in">super</span>.setValue(value);  <br>    &#125;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如我们希望通过继承<strong>具体泛型</strong>来重写具有<strong>具体参数</strong>和<strong>具体返回值</strong>的方法，但父类由于类型擦除，参数会变成Object。导致与重写发生定义冲突。</p><p>此时，JVM会使用桥方法解决问题，以下为字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.tao.test.DateInter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  <br>  com.tao.test.DateInter();  <br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.util.Date)</span>;  <span class="hljs-comment">//我们重写的setValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: invokespecial #<span class="hljs-number">16</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br>       <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> java.util.Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//我们重写的getValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">23</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br>       <span class="hljs-number">4</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">7</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> java.lang.Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;     <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokevirtual #<span class="hljs-number">28</span>                 <span class="hljs-comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br>       <span class="hljs-number">4</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.lang.Object)</span>;   <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">30</span>                 <span class="hljs-comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>编译器通过生成桥方法（Object作为参数和返回值等），实现对父类方法的重写，然后在其中调用我们真正重写的方法。<br>另外，桥方法getValue()看似和我们重写的getValue()冲突，但实际上JVM允许自己通过参数类型和返回类型共同确定一个方法。</p><h3 id="基本类型不能作为泛型类型"><a href="#基本类型不能作为泛型类型" class="headerlink" title="基本类型不能作为泛型类型"></a>基本类型不能作为泛型类型</h3><p>ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><h3 id="泛型类型不能实例化"><a href="#泛型类型不能实例化" class="headerlink" title="泛型类型不能实例化"></a>泛型类型不能实例化</h3><p>编译期找不到对应的类字节码文件，无法确认具体泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(); <span class="hljs-comment">// ERROR</span><br><br><span class="hljs-comment">//解决，利用反射</span><br><span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">newTclass</span> <span class="hljs-params">(Class &lt; T &gt; clazz)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型数组不能初始化"><a href="#泛型数组不能初始化" class="headerlink" title="泛型数组不能初始化"></a>泛型数组不能初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// Error，Class</span><br><br><span class="hljs-comment">//如果对lsa进行强转Object[]，就可以对其添加其他list，导致Class错误，因此要避免这样的情况发生：</span><br><br>List&lt;?&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// OK, array of unbounded wildcard type.</span><br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (Integer) lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">//因为使用？来创建类型，所以array本身的定位就是可以放入不同的list，最后取出时强转，符合逻辑</span><br></code></pre></td></tr></table></figure><h3 id="PS数组类型"><a href="#PS数组类型" class="headerlink" title="PS数组类型"></a>PS数组类型</h3><p><strong>数组类可以分类可以分成两类：</strong></p><ul><li>基本类型的数组类；</li><li>引用类型的数组类；<br>基本类型的数组类的父类是Object，即<code>int[]</code>可以强转<code>Object</code><br>引用类型的数组类的父类有<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>，即如果A extends B，A可以强转<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>。</li></ul><h3 id="泛型数组如何正确初始化"><a href="#泛型数组如何正确初始化" class="headerlink" title="泛型数组如何正确初始化"></a>泛型数组如何正确初始化</h3><p>最好使用列表集合对其替换。或者通过反射建立，因为反射时，类型已经被确认。</p><h3 id="如何理解泛型类中的静态方法和静态变量"><a href="#如何理解泛型类中的静态方法和静态变量" class="headerlink" title="如何理解泛型类中的静态方法和静态变量"></a>如何理解泛型类中的静态方法和静态变量</h3><p>泛型类中的静态方法和静态变量<strong>不可以</strong>使用泛型类所声明的泛型类型参数，显然当静态变量建立时，具体类型还未确认。</p><h3 id="如何理解异常中使用泛型"><a href="#如何理解异常中使用泛型" class="headerlink" title="如何理解异常中使用泛型"></a>如何理解异常中使用泛型</h3><ul><li>不能<strong>捕获</strong>泛型类型的异常。（编译器禁止）<ul><li>由于类型抹去，捕获泛型类型会失效，也可能导致多个catch句子中的父子类顺序混淆<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(Class&lt;T&gt; t)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(T e) &#123; <span class="hljs-comment">//编译错误</span><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123; <span class="hljs-comment">//Integer会抹去，无法捕获</span><br>    ...<br>    &#125; <span class="hljs-keyword">catch</span>(IndexOutOfBounds e) &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>但可以在方法声明中使用泛型并抛出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> T &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Throwable realCause) &#123;<br>        t.initCause(realCause);<br>        <span class="hljs-keyword">throw</span> t; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>由于泛型本质上是为了简化类型转换问题和约束编程，在编译时会进行类型抹去。而catch操作是一个运行时发生的事件，<strong>需要catch具体的类型</strong>，其抹去类型后，与catch的捕获异常的<strong>范围和先后顺序</strong>产生矛盾。<br>但通过限制泛型异常上界，并<strong>捕获其上界</strong>，对其进行抛出是可行的。</p>          </div></li></ul><h3 id="如何获取泛型参数"><a href="#如何获取泛型参数" class="headerlink" title="如何获取泛型参数"></a>如何获取泛型参数</h3><p><strong>Type</strong>是Java所有类型实现的<strong>公共接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericType&lt;String&gt; genericType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;<br><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> genericType.getClass().getGenericSuperclass();<br><span class="hljs-comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> ((ParameterizedType)superclass).getActualTypeArguments()[<span class="hljs-number">0</span>]; <br>System.out.println(type);<span class="hljs-comment">//class java.lang.String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第2章（知识点）</title>
    <link href="/2023/01/07/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/"/>
    <url>/2023/01/07/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型有<br>boolean(1),byte(8),char(16),short(16);<br>int(32),long(64),float(32),double(64);</p><p>括号表示类型占的bit数，其中，char,byte,short不会互相转换，其计算时首先转换为int。</p><div class="note note-primary">            <p>java分内码和外码，内码指运行时内存中编码方式。除了内码的都是外码（如class文件，序列化等）。</p><ul><li>boolean：实际上JVM规范将boolean当作int来处理，也就是都占用4个字节。true为1，false为0。</li><li>char：内码中使用UTF16编码，一个字符占2个或4个字节(相当于用两个char表示一个字符)。外码中char使用UTF8编码，一个字符占1-6个字节。</li><li>其他的与括号内的字节相同?todo。</li></ul>          </div><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="String-x2F-Integer-x2F-int"><a href="#String-x2F-Integer-x2F-int" class="headerlink" title="String&#x2F;Integer&#x2F;int"></a>String&#x2F;Integer&#x2F;int</h3><p>基本类型之间，char,byte,short可以转化为int,int-&gt;long-&gt;float-&gt;double可以链式转换，反向转换需要强制类型转换，可能造成数据精度损失。</p><p>String与Integer互相转化：</p><ul><li>String.valueOf(Integer)</li><li>Integer.valueOf(String)<br>String与int互相转化：</li><li>String.valueOf(int) &#x2F; int + “”</li><li>Integer.parseInt(“int”)<br>Integer与int互相转化：</li><li>Integer.valueOf()</li><li>integer.intValue()<div class="note note-primary">            <p>可见，对于具体类（String,Integer）,valueOf是一个将其他类型转化为本类型的通用方法。涉及到其他类型转化为基本类型时，需要使用<code>Integer.parseInt(string)</code>和<code>integer.intValue()</code>这种特殊方法。</p>          </div></li></ul><h3 id="隐式类型"><a href="#隐式类型" class="headerlink" title="隐式类型"></a>隐式类型</h3><h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>1.1字面量是double类型的。<br><code>float f = 1.1f</code></p><h4 id="short"><a href="#short" class="headerlink" title="short"></a>short</h4><p>1字面量是int类型的<br><code>short s1 = 1</code>不可行，而<code>+=</code>可以实现隐式转换<br><code>s1 += 1</code>;<br>相当于s1 &#x3D; (short)(s1 + 1)</p><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li><li>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。<br><strong>自动装箱</strong>的过程，默认调用的是<strong>valueOf</strong>,因此会先判断对象是否在缓存池。<blockquote><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul></blockquote></li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 被声明为 final，因此它不可被继承。其内部使用一个final的char数组存储字符。</p><h3 id="不可变的原因"><a href="#不可变的原因" class="headerlink" title="不可变的原因"></a>不可变的原因</h3><ul><li>String常作为hashKey，不可变时，每个String对象只需要计算一次hash</li><li>StringPool，只有</li><li>安全性，其常作为网络连接参数，不可变保证其正常运行。</li><li>String天生线程安全。</li></ul><h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><ul><li>String不可变，StringBuffer和StringBuilder可变</li><li>String线程安全，StringBuilder线程不安全，<strong>StringBuffer线程安全</strong>，内部synchronized进行同步。</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><ul><li>String s1 &#x3D; new String(“aaa”)不会将对象放入线程池</li><li>String s2 &#x3D; “bbb”会自动将对象放入线程池</li><li>String s3 &#x3D; s1.intern()会将s1放入线程池<br>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>HotSpot字符串常量池放在哪里？</p><ul><li>JVM虚拟机规范中：规定<strong>运行时常量池</strong>在方法区（<strong>方法区只是一个逻辑概念</strong>）内。</li><li>方法区在不同的虚拟机中有不同的实现，HotSpot才有永久代的概念。但随着时间发展，HotSpot也放弃了永久代的概念。</li></ul><table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table><div class="note note-primary">            <ul><li>1.6前，方法区由永久代（ALL）实现。</li><li>1.7时，方法区由永久代（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量）共同实现。</li><li>1.8时，方法区由元空间（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量static）共同实现。</li></ul>          </div><h1 id="二、运算"><a href="#二、运算" class="headerlink" title="二、运算"></a>二、运算</h1><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>减去一个正数 &#x3D; 加上一个负数 &#x3D; 加上一个进位值再减去该负数 &#x3D; 对原正数求补码并加一（这与我们对负数的补码的定义是相同的）</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="Mod与"><a href="#Mod与" class="headerlink" title="Mod与%"></a>Mod与%</h3><h4 id="求余"><a href="#求余" class="headerlink" title="%求余"></a>%求余</h4><p>a % b &#x3D; c…<code>d</code><br>余数的正负取决于被除数，顾名思义，求余，是指被除数 除以 除数 之后剩下的值（求余时，得到的c是向0取整的），因此肯定余被除数的符号相同。<br>eg:<br>9%4 &#x3D; 2…<code>1</code><br>9%-4 &#x3D; -2…<code>1</code><br>-9%4 &#x3D; -2…<code>-1</code><br>-9%-4 &#x3D; -2…<code>-1</code></p><h4 id="mod取模"><a href="#mod取模" class="headerlink" title="mod取模"></a>mod取模</h4><p>a mod b &#x3D; c…<code>d</code><br>mod时，结果与除数相同，（得到的c是向下取整的）<br>eg:<br>9mod4 &#x3D; 2…<code>1</code><br>9mod-4 &#x3D; -3…<code>-3</code><br>-9mod4 &#x3D; -3…<code>3</code><br>-9mod-4 &#x3D; 2…<code>-1</code></p><div class="note note-primary">            <p>java中%表示求余，但python中%表示求模。且java中的取模操作为<code>Math.floorMod(a,b)</code></p>          </div><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><div class="note note-primary">            <p>所有位运算都是针对补码而言的</p>          </div><h4 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h4><p>相当于 <code>*2</code></p><h4 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移&gt;&gt;"></a>右移&gt;&gt;</h4><p>相当于 <code>/2</code>,向下取整eg:<code>5&gt;&gt;1 = 2</code>,<code>-5&gt;&gt;1 = -3</code><br>(负数的高位补1)</p><h4 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h4><ul><li>对于正数相当于<code>/2</code>，向下取整。</li><li>对于负数，结果需要具体计算(负数的高位补0)</li></ul><h4 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h4><p>~n &#x3D; -(n+1)<br>eg:</p><ul><li>正数：<br>~ 3 &#x3D; -(3+1) &#x3D; -4<br>~0011 &#x3D; -(0011+0001) &#x3D; -0100 &#x3D; 1100</li><li>负数：<br>~ (-3) &#x3D; -(-3+1) &#x3D; 2<br>~1101 &#x3D; -(1101+0001) &#x3D; -1110 &#x3D; 0010</li></ul><div class="note note-primary">            <p>由上可见，在二进制上，取反相当于把1置0，把0置1。<br>在具体值上，我们是对原值的补码进行求反，得到的是答案的补码。<br>如果是正数，符号变正，且绝对值+1。<br>如果是负数，符号变负，且绝对值-1。<br>注意到这个过程是可以相互抵消的，即<del>(</del>n) &#x3D; n，从二进制角度来看，也很符合常理。</p><p>如何求-n的补码：<br>~ n+1 &#x3D; -(n+1)+1 &#x3D; -n</p>          </div><h4 id="自增"><a href="#自增" class="headerlink" title="自增++"></a>自增++</h4><p>自增++线程不安全</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>java只有值传递，对于对象，传递的是对象的引用指针。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch条件判断语句中可以使用<br>byte,short,char,int,枚举(jdk5.0)，String对象(jdk7.0)，但不能使用long类。<br><strong>PS</strong>：实际上能string对象也只是一个语法糖，底层通过string对象的hash值处理。</p><h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h3 id="Java-中的编译期常量是什么-使用它有什么风险"><a href="#Java-中的编译期常量是什么-使用它有什么风险" class="headerlink" title="Java 中的编译期常量是什么? 使用它有什么风险?"></a>Java 中的编译期常量是什么? 使用它有什么风险?</h3><p>这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。<br>这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h3 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别?"></a>Java 中，Serializable 与 Externalizable 的区别?</h3><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。<br>Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h3 id="Object有哪些公用方法"><a href="#Object有哪些公用方法" class="headerlink" title="Object有哪些公用方法?"></a>Object有哪些公用方法?</h3><p>clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。</p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li><li>抽象类可以有构造方法, 接口没有构造方法</li><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li><li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法<div class="note note-primary">            <p>注意，接口不能拥有成员变量，但可以拥有静态变量。<br>抽象类可以有具体方法（代码复用），但具体类不能有抽象方法。<br>抽象类可以有静态方法，接口在JDK8之前没有，JDK8之后有。</p>          </div></li></ul><h3 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h3><ul><li>finally不管有没有异常都要处理</li><li><strong>当try和catch中有return时，finally仍然会执行，finally比return先执行</strong>，finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以<strong>函数返回值是在finally执行前确定</strong>的</li><li><strong>finally中最好不要包含return</strong>，这样返回值不是try或catch中保存的返回值，而是finally中的return值。<br>finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电。</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数。</p><h3 id="局部变量为什么要初始化"><a href="#局部变量为什么要初始化" class="headerlink" title="局部变量为什么要初始化"></a>局部变量为什么要初始化</h3><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，<strong>如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销</strong>，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，<strong>解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第1章（面向对象）</title>
    <link href="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>属性和操作分离，即通过get,set方法操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，子类可以获得父类非 private的属性和方法。</p><div class="note note-primary">            <p>继承应该遵循<strong>里氏替换</strong>原则，子类对象必须能够替换掉所有父类对象。</p>          </div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>:</p><ul><li>编译时多态主要指方法的<strong>重载</strong></li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><blockquote><p>即子类要继承父类，覆盖父类的方法，并使用了父类的指针。</p></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><p><img src="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191817.png"><br>即继承父类</p><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p><img src="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191831.png"><br>即实现接口</p><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p><img src="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191859.png"><br>弱依赖，整体不存在了部分也还是存在。</p><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p><img src="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191919.png"><br>强依赖，整体不存在了部分也不存在了。</p><h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p><img src="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192246.png"><br>1对1，1对n，n对1。</p><h3 id="依赖关系（Dependency）"><a href="#依赖关系（Dependency）" class="headerlink" title="依赖关系（Dependency）"></a>依赖关系（Dependency）</h3><p><img src="/2023/01/06/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192243.png"><br>A是B类的局部变量、参数，或A向B发送信息。</p><h2 id="面向对象的规则"><a href="#面向对象的规则" class="headerlink" title="面向对象的规则"></a>面向对象的规则</h2><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>Java 中有三个访问权限修饰符（四个访问权限等级）: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>对<strong>类</strong>或类中的成员(<strong>字段</strong>以及<strong>方法</strong>)加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>对于<strong>类</strong>：只有public和defualt修饰符<br>对于<strong>成员</strong>：4种访问等级都有，protected表示<strong>本包和子类</strong>可见</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>1.修饰数据<br>表示数据为不可改变，其只针对编译期检查，运行时会抹去。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变。</li></ul><p>2.修饰类<br>表示类不可继承</p><p>3.修饰方法<br>表示不可重写</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>1.静态变量<br>静态变量就是类变量<br>2.静态方法<br>类加载时就存在，必须实现，不可为抽象方法，也只能访问所属类的静态变量和静态方法<br>3.静态代码块<br>见代码块，类初始化时运行<br>4.静态内部类<br>不依赖外部实例的静态类（内部类本质上是一个单独的class文件）</p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>一个类至少有一个构造器，如果显示定义了构造器，系统默认的无参构造器会失效。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块分：</p><ul><li>普通代码块：类的方法体</li><li>构造代码块：即类中的{}</li><li>静态代码块：即类中的static {}</li></ul><div class="note note-primary">            <p>静态代码块是类加载时执行的，只会在第一次new时执行一次，是类的初始化<br>构造代码块是每新建一个实例都会执行一次，是对象的初始化</p>          </div><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>新建对象调用顺序：<br>静态代码块（只会调用一次）-&gt; 构造代码块 -&gt; 构造器</p><p>因此属性的赋值：</p><ul><li>静态初始化（静态赋值和静态代码块按照执行顺序）</li><li>默认初始化（0,false）</li><li>构造初始化（普通赋值和构造代码块按执行顺序）</li><li>构造函数</li></ul><p>存在继承时：</p><ol><li>父类静态、子类静态</li><li>父类构造初始化、父类构造函数</li><li>子类构造初始化、子类构造函数</li></ol><div class="note note-primary">            <p>静态变量是可以不赋初值的，所以当其被声明时，会先赋予默认值，后续再初值。</p>          </div><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类和抽象方法一定使用 abstract 关键字进行声明。<br>很容易理解：</p><ul><li>抽象类不能被实例化</li><li>抽象方法不能出现在非抽象类中</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口在Java 8之前是纯抽象类，在JAVA8之后其允许默认的方法实现。</p><ul><li>接口的成员，字段都默认（且必须）是Public的</li><li>接口的字段默认是static final的</li></ul><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p>抽象类是IS-A关系，接口是LIKE-A关系</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>接口：多重继承，主要用于表示实现类拥有具体方法。<br>抽象类：主要用于在相关类中共享代码。<br>优先使用接口</p><h4 id="super字段"><a href="#super字段" class="headerlink" title="super字段"></a>super字段</h4><ul><li>super()<br>父类的构造函数，如果子类使用必须放在子类构造函数的第一排</li></ul><h4 id="this字段"><a href="#this字段" class="headerlink" title="this字段"></a>this字段</h4><p>在方法中，this指方法所属对象（static方法里不能有this）<br>在构造函数中，this指正在初始化的对象</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写限制（里氏原则）：</p><ul><li>子类方法访问权限大于父类</li><li>子类方法返回值为父类返回值或其子类<br>@Override会对以上限制进行检查。</li></ul><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>同一个方法的参数：个数，类型，顺序至少一个不同</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类也都是独立的类，均有单独的class文件，但前面会有外部类的类名和$符<br>分类：</p><ul><li>成员内部类<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>局部内部类、匿名内部类</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>作为成员：</p><ul><li>成员内部类可以声明为private或protected，可以调用外部内的结构</li><li>如果是static的成员内部类，可以脱离父类实例存在，因此也只能使用父类静态成员。<br>作为类：<br>可以声明为abstract被其他内部类继承，也可以声明为final禁止继承</li></ul><div class="note note-primary">            <p>不存在静态的外部类，因为这没有意义，外部类的成员只要标注为static就能任意使用。<br>而内部类可以标注为静态，表示其可以脱离父实例而存在，因此若内部类需要再使用static成员，其类本身也必须为static，才可以任意使用。</p>          </div><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>即在方法中声明一个内部类，声明后在只能在方法体内使用。<br>（但可以在方法最后返回这个内部类实例，不过返回值应该设置为该内部类的父类或父接口，毕竟外部不认识该局部内部类）</p><p>其可以使用外部类的成员（包括私有的）、外部方法的局部变量，但必须是final修饰的</p><p>因为是一个局部的，短暂的类，所以其与局部变量类似，不存在修饰符，也不能为静态类或拥有静态成员。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类必须继承父类或实现接口，其只有一个对象，只能多态引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentClass</span>|ParentInterface()&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>局部内部类是主要用于在一个方法中，我们短暂的需要一个结构体来处理问题时使用；而如果我们明确只需要一个具体的函数，但不想为此创造一个新类，且这个函数已经有明确的父类或接口，我们则可以让局部内部类退化为匿名内部类实现这个方法即可。<br>同样，匿名内部类的方法也可以使用外部的变量，但外部的变量必须是final修饰的：<br>匿名内部类，之所以能够使用外部变量，是因为其底层将外部变量作为构造参数传入了匿名内部类，问题的核心在于，如果不声明外部变量为final，当外部变量变化时，匿名内部类无法感知这个变化，可能会导致数据的不一致问题。实际上，JDK8中我们不再需要显示的将外部变量声明为final，其实底层还是为我们加上了final（语法糖）。<br>不过回到final的知识点，读写final字段对于JVM而言，主要是在编译器起限制重排序的作用，详情见JUC。</p>          </div><div class="note note-primary">            <p>匿名内部类是lambda表达式的原型，因此也很好理解为声明lambda表达式只能使用final变量</p>          </div><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><ul><li>equals()<br>默认为比较对象是否等价，需要满足对称等性质。<br><code>==</code>则判断值（基本类型或指针）是否相等。 </li><li>hashCode()<br>默认：是一个native方法，返回int，使用的是对象的地址（引用地址）进行计算。<br>其可以被覆盖（String,Integer等都覆盖了这个方法）。对于两个对象，如果equals返回true,其hashCode()必须相等，因此覆盖equals时总是应该覆盖hashCode方法。</li><li>toString()<br>默认返回对象类型+@+16进制的hashCode()</li><li>clone()<br>clone()是一个native,protected方法<blockquote><p>因为clone修饰符为protected，其只对本包和其子类可见，对于自定义类1，2<br>在类1中调用类2的clone()，Object的默认clone只对类2可见，对类1不可见，所以要重写，一般重写为 return (T)super.clone()</p></blockquote></li></ul><p>另外，一个类要使用clone()方法，必须先继承Cloneable接口，并重写clone()，且要抛出CloneNotSupportedException异常。</p><p>另外，克隆也有浅拷贝和深拷贝，native的clone()只能获得一个对象的<strong>浅拷贝</strong>，对象的属性（引用类型）仍相同。想要获得<strong>深拷贝</strong>，需要在重写中实现。</p><p>替代方案，clone()既复杂又危险，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> &#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[original.arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;<br>            arr[i] = original.arr[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>类的对象有限且确定时可以使用枚举。</p><ul><li>enum定义的枚举类默认继承了java.lang.Enum类。</li><li>枚举类的构造器只能使用 private 权限修饰符。</li><li>必须在枚举类的第一行声明枚举类对象<br>具体使用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> <br>&#123; <br>    RED, GREEN, BLUE; <br>&#125;<br><span class="hljs-comment">//实际使用中，有一种获取静态变量的感觉</span><br>Color.RED<br><br><span class="hljs-comment">//通用方法和字段</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">1</span>), GREEN(<span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">2</span>), BLANK(<span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-number">3</span>), YELLO(<span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">4</span>);  <br>    <span class="hljs-comment">// 成员变量  </span><br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.index = index;  <br>    &#125;  <br>    <span class="hljs-comment">// 普通方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;  <br>            <span class="hljs-keyword">if</span> (c.getIndex() == index) &#123;  <br>                <span class="hljs-keyword">return</span> c.name;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;<br>get,set...<br>&#125;<br><span class="hljs-comment">//也可以声明抽象方法并在所有枚举中实现</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;红色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    GREEN&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;绿色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    BLUE&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;蓝色&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>指一个公共的，有无参公共构造其，有对应的set，get方法的，即一个标准的实体类。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>私有化构造器</strong>（外部不能new）</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>类自己持有自己的实例</strong>，通过static方法取得该实例，饿汉式表示会预加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>只有调用时才加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton single;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(single == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-type">return</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>顾名思义，一个类A为另一个类做B代理，通过操作A来操作B<br>作用：</p><ul><li>屏蔽真实角色</li><li>增强功能，如添加权限，访问控制和申计</li><li>延迟加载</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>定义一个接口和实现类</li><li>定义一个代理类，实现该接口</li><li>将实现类注入代理类，实现代理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理类AdminServiceProxy与真实类AdminService继承相同的接口，即实现相同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdminService</span> &#123;<br><span class="hljs-comment">//以字段的形式持有真实对象</span><br>    <span class="hljs-keyword">private</span> AdminService adminService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceProxy</span><span class="hljs-params">(AdminService adminService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adminService = adminService;<br>    &#125;<br><span class="hljs-comment">//代理方法，可以在前后进行增强</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre&quot;</span>);<br>        adminService.update();<br>        System.out.println(<span class="hljs-string">&quot;post&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre1&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;pre2&quot;</span>);<br>        <span class="hljs-keyword">return</span> adminService.find();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>又名JDK动态代理，使用反射实现动态代理<br>优点：Proxy对象不需要实现接口，即不用实现接口所有的方法。</p><ul><li>定义一个接口和一个实现类</li><li>定义一个服务类实现<code>InvocationHandler</code>接口，并重写invoke方法。</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>创建代理对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//reflect包中的静态方法，使用类加载器（不管）、接口列表（即生成的代理对象要实现哪些方法）、和事件处理器（代理对象在原目标上要做哪些加强）生成一个新的代理对象</span><br><span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler )</span>;<br><br><span class="hljs-comment">//事件处理器，主要用来写增强的内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceInvocation</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceInvocation</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理类，通过传入 增强器 和 代理目标，生成代理对象,后续可根据这个该代理类实体获取代理对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceDynamicProxy</span> extends &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-keyword">private</span> InvocationHandler invocationHandler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceDynamicProxy</span><span class="hljs-params">(Object target,InvocationHandler invocationHandler)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.invocationHandler = invocationHandler;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getPersonProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), invocationHandler);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>即通过反射的invoke方法，执行目标对象的目标方法，</p></blockquote></li></ul><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>优点：代理目标对象没有实现接口时可使用，其会实现一个子类，实现对target对象的代理，因此target类不能为final。</p><blockquote><p>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p></blockquote><ul><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object object, Method method, Object[] arg2, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-type">AliSmsService</span> <span class="hljs-variable">aliSmsService</span> <span class="hljs-operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h4><ul><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ul><li><strong>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Java</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第7章（性能监控）</title>
    <link href="/2023/01/06/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <url>/2023/01/06/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="状态命令"><a href="#状态命令" class="headerlink" title="状态命令"></a>状态命令</h1><ul><li>状态信息 - <code>info</code><br>通过<code>info</code>命令查看实时吞吐量（ops&#x2F;sec）。</li><li>监控执行命令 - <code>monitor</code><br>监控接受到的命令</li><li>监控延迟 - <code>latency</code><br>测量响应延迟<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --latency -h 127.0.0.1<br></code></pre></td></tr></table></figure></li><li>内部机制监控<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CONFIG SET latency-monitor-threshold 100 <span class="hljs-comment">#100是阈值，只有慢于100ms的才记录</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">latency latest <span class="hljs-comment">#查看最后一条消息的延迟</span></span><br><br></code></pre></td></tr></table></figure></li></ul><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="避免使用过于复杂的命令"><a href="#避免使用过于复杂的命令" class="headerlink" title="避免使用过于复杂的命令"></a>避免使用过于复杂的命令</h2><p>可以查看slowlog，查看执行慢的命令。</p><h2 id="操作BigKey"><a href="#操作BigKey" class="headerlink" title="操作BigKey"></a>操作BigKey</h2><p>如果value过大，分配内存会比较耗时。<br>可以通过<code>--bigkeys</code>命令扫描</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>避免使用bigkey</li><li>4.0版本以下，使用unlink代替del</li><li>6.0版本以上，开启lazy-free机制<div class="note note-primary">            <p>unlink和lazy-free都可以把释放内存放在后台线程中执行。</p>          </div></li></ul><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>随机过期时间</li><li>lazy-free</li></ul><h2 id="内存达到上限（max-memory）"><a href="#内存达到上限（max-memory）" class="headerlink" title="内存达到上限（max-memory）"></a>内存达到上限（max-memory）</h2><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>改成allkeys随机淘汰</li><li>拆分实例</li></ul><h2 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h2><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><ul><li>控制内存大小（fork与实例大小有关）</li><li>合理配置持久化策略</li></ul><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><p>我们都知道，应用程序向操作系统申请内存时，是按内存页进行申请的，而常规的内存页大小是 4KB。<br>Linux 内核从 2.6.38 开始，支持了内存大页机制，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。<br>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>关闭内存大页机制</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li>写磁盘的瓶颈</li><li>子线程将aof刷入盘中的过程如果阻塞也会影响主线程写aof</li></ul><p>一般下面一种情况发生在：</p><ul><li>正在重写aof</li><li>其他应用程序大量占用磁盘IO</li></ul><h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>配置中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>禁止了重写时的同步磁盘</p><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><p>避免了上下文切换，但Redis有子进程，子进程若大量占用被绑定的CPU，会导致主进程受阻。</p><h3 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h3><p>若一定要绑定，可绑定到多个CPU上，Redis6.0已经支持各线程分别绑定CPU</p><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><p>如果你对操作系统有些了解，就会知道操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。</p><h3 id="解决-7"><a href="#解决-7" class="headerlink" title="解决"></a>解决</h3><ul><li>增加内存</li><li>整理内存</li></ul><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>碎片内存会降低使用效率</p><h3 id="解决-8"><a href="#解决-8" class="headerlink" title="解决"></a>解决</h3><p>整理内存也CPU资源，需要谨慎</p><h2 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h2><h3 id="解决-9"><a href="#解决-9" class="headerlink" title="解决"></a>解决</h3><p>网络IO瓶颈，需要及时扩容。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis复习（一）</title>
    <link href="/2023/01/06/Redis%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/01/06/Redis%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第6章（缓存问题）</title>
    <link href="/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <url>/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><ul><li>缓存穿透</li><li>缓存穿击</li><li>缓存雪崩</li><li>缓存污染（或者满了）</li><li>缓存和数据库一致性</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>。<br>缓存不命中则会一直请求数据库，数据库查不到，又无法写入缓存。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>禁止非法请求，如校验参数合法性</li><li>数据库取不到的数据，在redis中置为key-null，防止大量数据库请求</li><li>bloomfilter，判断key是否在容器中</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（单一过期）<br>缓存过期导致大量针对该过期数据的请求段时间发生。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>设置数据永不过期</li><li>接口限流、熔断</li><li>互斥锁</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大</strong>（大量同时过期）</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。</p><h3 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h3><p><strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p><h3 id="新数据进入redis"><a href="#新数据进入redis" class="headerlink" title="新数据进入redis"></a>新数据进入redis</h3><p>当新数据进入redis时，如果内存不足怎么办？</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>通过<code>max-memory</code>配置设置淘汰策略<br>Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。</p><p><strong>怎么理解呢</strong>？主要看分三类看：</p><ul><li>不淘汰<ul><li>noeviction （v4.0后默认的）</li></ul></li><li>对设置了过期时间的数据中进行淘汰<ul><li>随机：volatile-random</li><li>ttl：volatile-ttl</li><li>lru：volatile-lru</li><li>lfu：volatile-lfu</li></ul></li><li>全部数据进行淘汰<ul><li>随机：allkeys-random</li><li>lru：allkeys-lru</li><li>lfu：allkeys-lfu</li></ul></li></ul><p>具体而言：</p><ol><li>noeviction<br>写满了就停止服务。</li><li>volatile-random<br>对会过期的键随机删除</li><li>volatile-ttl<br>对即将过期的时间进行排序，删除</li><li>volatile-lru(last-recently-used)<br>对最后使用时间进行排序，删除最后一次使用较早的数据</li><li>volatile-lfu（4.0后新增）<br>对使用次数进行排序，删除最少使用的数据</li><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ol><div class="note note-primary">            <p>淘汰策略 不是 过期清理策略，其不太关心键是否已经过期，只将是否设置了过期、过期时间作为筛选的范围。<br>volatile的挑选范围是<code>所有可能过期的数据</code>。<br>allkeys的挑选范围是<code>所有数据</code>。</p>          </div><h4 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h4><ul><li>redis每个数据都会记录最后访问的时间戳（redisObject的lru字段，24位时间戳）和最近使用次数（只有开启LFU时才记录，字段变成lfu，16位时间戳+8位访问次数）。</li><li>LRU淘汰时：<ul><li>随机选N个数据（可以通过maxmemory-samples设置）</li><li>排序lru字段</li><li>淘汰lru最小的数据</li></ul></li><li>LFU淘汰时：<ul><li>根据访问次数筛选（lru字段后8bit）</li><li>淘汰访问次数最低的数据（次数相同则比较最后使用时间，前16bit）</li></ul></li></ul><blockquote><p>8bit只能记录255次使用，到达后LFU会退化为LRU，因此有策略控制lfu的增长。</p></blockquote><p><code>lfu-log-factor</code>，有新访问时，只有满足一定算法条件时才count++<br><code>lfu-decay-time</code>，有新访问时，会按照算法对count进行衰减。</p><h2 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h2><p>一般流程：<br><img src="/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105015406.jpg"><br>缓存与数据库必然存在不一致情况：<br>1.先写数据库，再删除redis，后者的删除可能未执行<br>2.先删除redis，再写数据库，后者还未执行redis可能就又刷新了。</p><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p><strong>写后失效缓存</strong><br>读时：</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。<br>写时：</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><h4 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br>相比Cache Aside模式：<br>读时：</p><ul><li><strong>失效</strong>：都会查找数据库然后同步到缓存，但Read Pattern会先缓存再返回。<br>写时：</li><li><strong>更新</strong>：Write Pattern会先<strong>更新</strong>缓存再写数据库，最后返回。<br><img src="/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105020042.png"></li></ul><h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105023335.png"><br>性能高，但数据一致性弱，实现较复杂，要判断哪些需要持久化。</p><h3 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h3><h4 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h4><p>以Cache Aside Pattern为例：<br>读操作（失效时）：1.查找数据库 2.更新缓存<br>写操作：1.修改数据库 2.失效缓存</p><p>同步进行读、写时，若读写先后完成了对数据库的查询、修改，此时写操作先失效缓存导致读操作将旧信息更新到了缓存。<br>即 读1-&gt;写1-&gt;写2-&gt;读2</p><p>该事件这个概率较低，其只发生在读时失效且刚好有并发写操作，且写操作较慢且需要锁表，读操作一般肯定已经完成，所以这个概率会很低。当然最好还是为缓存设置过期时间。</p><h4 id="缓存更新失效"><a href="#缓存更新失效" class="headerlink" title="缓存更新失效"></a>缓存更新失效</h4><p>解决写操作第二步：失效缓存因为异常导致没有执行的问题</p><h5 id="方案1：队列-重试"><a href="#方案1：队列-重试" class="headerlink" title="方案1：队列+重试"></a>方案1：队列+重试</h5><p><img src="/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105024206.png"><br>优点：队列解决了缓存更新失败的问题<br>缺点：对代码的侵入量大，影响服务速度</p><p>方案2：队列+重试+非业务代码做异步更新缓存<br><img src="/2023/01/05/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105181554.png"><br>由非业务代码读取mysql的操作，然后更新缓存。<br>优点：不侵入业务<br>缺点：同步速度慢<br>例子：canal</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第5章（高可用）</title>
    <link href="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <url>/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p></blockquote><p><strong>主从复制的作用</strong>主要包括：<br>性能上：</p><ul><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>读写分离</strong>：<ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。<br>稳定性上：</li></ul></li><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>1.从节点 发送指令replicaof ip port，主节点接受并响应<br>2.从节点 连接master的socket<br>3.从节点 发送指令auth password<br>4.主节点 验证授权<br>5.从节点 发送自身信息，主节点保存slave</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>全量复制</li><li>增量复制</li></ul><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104040638.jpg"><br><strong>第一阶段</strong>：主从库间建立连接、协商同步的过程。</p><ul><li>从节点发送psync命令，其应该包含主库的runId和offset，但这是初次复制，所以发送的runId&#x3D;?,offset&#x3D;-1。</li><li>主节点回复FULLRESYNC，并携带runId和offset，告诉从节点自身信息。<br><strong>第二阶段</strong>：主库将所有数据同步给从库。</li><li>主库执行bgsave，将其发送给RDB。</li><li>从库接受到RDB时，先清空数据库，再加载RDB。</li><li>主库在这一阶段会把新的写命令记录在repl buffer中。<br><strong>第三阶段</strong>：主库发送期间同步期间产生的新的写命令。<div class="note note-primary">            <p>注意这里的repl buffer，前面讲AOF持久化时，也有一个aof_buffer，用于记录<strong>重写</strong>时的新写入命令。</p>          </div></li></ul><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><blockquote><p>每次都全量复制的开销过大。</p></blockquote><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104041537.jpg"></p><p><code>repl_backlog_buffer</code>：环形缓冲区，用于记录写命令（会覆盖）。repl_baklog文件记录了命令偏移，<strong>主节点的offset</strong>和<strong>从节点的offset</strong>（但还是会以从节点ask发来的offset为准）。</p><p><code>replication buffer</code>：每个client连上Redis后，<strong>Redis都会分配一个client buffer</strong>，所有数据交互都是通过这个buffer进行的。Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。repl buffer的默认大小为1M。</p><h4 id="全量复制还是增量复制？"><a href="#全量复制还是增量复制？" class="headerlink" title="全量复制还是增量复制？"></a>全量复制还是增量复制？</h4><p>从库会记录自己的<code>slave_repl_offset</code>，恢复连接时，从库会通过<code>psync</code>发送自己的offset，主库根据这个offset判断进行增量还是全量复制。（如果<code>repl_backlog_buffer</code>的<code>slave_repl_offset</code>已经被覆盖，进全量复制）。</p><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741726.png"></p><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741728.png"></p><div class="note note-primary">            <p>主从节点都会发心跳，目的都有判断对方是否在线，此外从节点还会汇报自己的复制进度。</p>          </div><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741729.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741730.png"></p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="主服务器持久化与安全性"><a href="#主服务器持久化与安全性" class="headerlink" title="主服务器持久化与安全性"></a>主服务器持久化与安全性</h3><ul><li>主从复制时，主服务器强烈建议开启持久化。</li><li>若主节点没有开启持久化，又开启了自动重启，重启后主节点数据库为空，而从节点对其进行全量复制，会导致从节点数据也被删除。</li><li>所以，若主节点没有开启持久化，应该禁止自动重启。</li></ul><h3 id="为什么主从全量复制使用RDB而不使用AOF"><a href="#为什么主从全量复制使用RDB而不使用AOF" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF"></a>为什么主从全量复制使用RDB而不使用AOF</h3><ul><li>RDB文件很小，适合传输</li><li>RDB加载很快，适合恢复</li><li>AOF使用不当，会严重影响Redis性能</li></ul><h3 id="无磁盘复制模式"><a href="#无磁盘复制模式" class="headerlink" title="无磁盘复制模式"></a>无磁盘复制模式</h3><p>主服务器磁盘速度较低时，RDB会带来一些负担，<strong>无磁盘复制模式</strong>是指：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。<br>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><h3 id="从库的从库"><a href="#从库的从库" class="headerlink" title="从库的从库"></a>从库的从库</h3><p>对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。<br>通过“主 - 从 - 从”模式可以<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。<br><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104045116.jpg"><br>后续的写同步也可以级联传播。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="延迟与不一致问题"><a href="#延迟与不一致问题" class="headerlink" title="延迟与不一致问题"></a>延迟与不一致问题</h4><p><strong>优化</strong>：优化网络环境、舍弃大延迟从节点，使用集群扩展读负载能力。</p><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><p>单机redis的删除策略</p><ul><li><strong>惰性删除</strong>：客户端查询数据时才判断是否过期，过期则删除</li><li><strong>定期删除</strong>：服务器定时任务删除过期数据<br>主从复制时，从节点不主动删除，而是由主节点控制从节点删除（保证数据一致性），但由于主节点不会立即删除过期数据，客户端在从节点上容易读到过期数据。<br><strong>解决</strong>：Redis3.2中，从节点也会判断数据过期。</li></ul><h4 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h4><p>主&#x2F;从节点发生故障时，要及时切换客户端的Redis连接。</p><ul><li>手动：响应慢，容易出错</li><li>监控程序：实现复杂<div class="note note-primary">            <p>使用哨兵即可解决这个问题。</p>          </div></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><blockquote><p>哨兵Redis Sentinel的核心功能是协助完成自动故障转移。</p></blockquote><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>监控：监听主从节点运作</li><li>自动故障转移：更改主节点</li><li>配置提供：向客户端提供节点信息</li><li>通知：通知客户端故障转移的结果</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="集群组建"><a href="#集群组建" class="headerlink" title="集群组建"></a>集群组建</h3><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223227.jpg"></p><ul><li>主节点上有一个<code>_sentinel_:hello</code>频道，哨兵们通过该频道实现互相发现。</li><li>互相发现后哨兵之间建立连接。</li></ul><h3 id="监控Redis库"><a href="#监控Redis库" class="headerlink" title="监控Redis库"></a>监控Redis库</h3><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223410.jpg"></p><ul><li>哨兵向主节点发送<code>INFO</code>命令，根据接受到的Slave列表与各从库建立连接</li></ul><h3 id="主库下线判断"><a href="#主库下线判断" class="headerlink" title="主库下线判断"></a>主库下线判断</h3><p>下线概念：</p><ul><li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；<br><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223530.jpg"></li><li>哨兵判断主库下线后，向其他哨兵发送<code>is-master-down-by-addr</code>命令，其他哨兵作出Y或N响应。</li><li>如果赞成票大于配置项<code>quorum</code>，判定主库客观下线。</li></ul><h3 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h3><p>客观下线后，需要选举一个主哨兵执行最终调整命令</p><ul><li>选举算法：<ul><li>Raft选举算法： 选举的票数大于等于num(sentinels)&#x2F;2+1时，将成为领导者，如果没有超过，继续选举</li></ul></li><li>成为Leader的前提：<ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <code>quorum</code> 值。</li></ul></li></ul><div class="note note-primary">            <p>这里注意，判断客观下线需要得到大于<code>quorum</code>的赞成票，选举leader需要半数以上<strong>且</strong>大于<code>quorum</code>值的赞成票。<br>即，若有哨兵掉线导致无法超过半数，也无法实现Leader选举</p>          </div><h3 id="新主库选择"><a href="#新主库选择" class="headerlink" title="新主库选择"></a>新主库选择</h3><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><div class="note note-primary">            <p>先选活的，再选关系户，最后选有实力的，都没法就选runID小的。</p>          </div><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104224208.png"></p><ul><li>让新主库脱离原主库（replicaof no one）</li><li>让其他从库成为新主库的从节点</li><li>通知应用程序新redis主节点</li><li>原主库上线后变成新主节点的从节点</li></ul><h1 id="分片技术"><a href="#分片技术" class="headerlink" title="分片技术"></a>分片技术</h1><blockquote><p>主从复制解决了主节点崩溃的备份问题，并通过读写分离提高了性能。<br>哨兵机制解决了主节点崩溃时的崩溃转移问题。<br>但这都没有扩展Redis的写能力和存储能力，因此Redis引入了集群的功能。</p></blockquote><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="哈希槽-Hash-Slot"><a href="#哈希槽-Hash-Slot" class="headerlink" title="哈希槽(Hash Slot)"></a>哈希槽(Hash Slot)</h3><p>Redis-cluster没有使用一致性hash，而是引入了<strong>哈希槽</strong>的概念。Redis-cluster中有<strong>16384(即2的14次方)个哈希槽</strong>，每个key通过CRC16校验后对16383取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。</p><h3 id="Keys-hash-tags"><a href="#Keys-hash-tags" class="headerlink" title="Keys hash tags"></a>Keys hash tags</h3><p>Hash tags提供了一种途径，<strong>用来将多个(相关的)key分配到相同的hash slot中</strong>。这时Redis Cluster中实现multi-key操作的基础。<br>hash tag规则如下，如果满足如下规则，<code>&#123;</code>和<code>&#125;</code>之间的字符将用来计算HASH_SLOT，以保证这样的key保存在同一个slot中。</p><p>例如：hash(“{user1}.name”) &#x3D;&#x3D; hash(“{user1}.age”)</p><h3 id="Cluster-nodes属性"><a href="#Cluster-nodes属性" class="headerlink" title="Cluster nodes属性"></a>Cluster nodes属性</h3><p>每个<strong>节点在cluster中有一个唯一的名字</strong>。<br>这个名字由160bit随机十六进制数字表示，并在节点启动时第一次获得(通常通过&#x2F;dev&#x2F;urandom)。节点在配置文件中保留它的ID，并永远地使用这个ID，直到被管理员使用CLUSTER RESET HARD命令hard reset这个节点。<br>这样节点可以实现IP的变化而不影响其在集群中的定位。</p><p>每个节点维护集群内其他节点的以下信息：</p><ul><li><code>node id</code>，<code>节点的IP和port</code>，<code>节点标签</code>，<code>master node id</code>（如果这是一个slave节点）</li><li><code>最后被挂起的ping的发送时间</code>(如果没有挂起的ping则为0)，<code>最后一次收到pong的时间</code></li><li><code>当前的节点configuration epoch</code>（配置版本号） ，<code>链接状态</code>，以及该节点服务的<code>hash slots</code>。</li></ul><div class="note note-primary">            <p>即维护基本身份（node id,ip port,从属）,存活信息（ping pong），服务信息（版本号、连接、slots）</p>          </div><h3 id="Cluster总线"><a href="#Cluster总线" class="headerlink" title="Cluster总线"></a>Cluster总线</h3><p>每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接。</p><p>这个端口与用来接收client命令的普通TCP端口有一个固定的offset。如该端口等于普通命令端口加上10000.例如，一个Redis街道口在端口6379坚挺客户端连接，那么它的集群总线端口16379也会被打开。</p><blockquote><p>节点到节点的通讯只使用集群总线，同时使用集群总线协议：有不同的类型和大小的帧组成的二进制协议。</p></blockquote><h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点总是接受集群总线端口的链接，并且总是会回复ping请求，即使ping来自一个不可信节点。然而，如果发送节点被认为不是当前集群的一部分，所有其他包将被抛弃。</p><p>节点认定其他节点是当前集群的一部分有两种方式（阶段）：</p><ul><li>节点接受到一条meet消息，其会将meet消息的发送节点视为集群内节点。</li><li>节点接受到其信任的节点的gossip信息，其会将gossip信息中提到的新节点标记为集群内节点。</li></ul><h3 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h3><p>Redis Cluster是一张全网拓扑，节点与其他每个节点之间都保持着TCP连接。<br>节点之间使用gossip协议更新避免过多的消息交换。</p><div class="note note-danger">            <p>上面主要是cluster的主要模块，涉及到以下几个方面：</p><ul><li>分片：使用了<strong>哈希槽</strong>的方法对键进行分片，同时使用<strong>keys hash tags</strong>技术实现了定向的分片。</li><li>通讯：节点会开启<strong>cluster总线</strong>监听、返回消息，其会记录各个<strong>cluster nodes</strong>的基本信息。</li><li><strong>握手</strong>：节点监听到meet消息或信任节点的gossip消息会将目标节点加入到集群内。</li></ul>          </div><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><ul><li>检查当前key是否存在当前NODE？<ul><li>通过crc16（key）&#x2F;16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果</li><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？</li><li>若key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若Slot未迁出，检查Slot是否导入中？</li><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul><h4 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h4><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233215.png"></p><h4 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h4><p><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233422.png"></p><h4 id="SMART客户端"><a href="#SMART客户端" class="headerlink" title="SMART客户端"></a>SMART客户端</h4><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来<strong>减低复杂性，追求更好的性能</strong>。<br><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233615.png"></p><p>客户端通过cluster slots命令获取集群信息，依据其自主计算目标key所在的节点，直接对目标节点进行访问。</p><blockquote><p>失败时，进行随机访问节点、更新自身映射表并重新访问，若失败过多则放弃。</p></blockquote><div class="note note-warning">            <p>简而言之，客户端请求后，节点判断是否由自己处理，不由自己处理则MOVED，由自己处理但发现slot已经迁移则ASK。<br>SMART客户端则自身计算slots的工作，映射失效时则随机访问节点刷新映射。</p>          </div><h3 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h3><p>Cluster中的每个节点都维护一份在自己看来当前整个集群的状态，主要包括：</p><ul><li>当前集群状态</li><li>集群中各节点所负责的slots信息，及其migrate状态</li><li>集群中各节点的master-slave状态</li><li>集群中各节点的存活状态及不可达投票</li></ul><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>gossip 协议（gossip protocol）又称 epidemic 协议（epidemic protocol）是一种P2P2协议，Gossip协议的最大的好处是，<strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许Consul管理的集群规模能横向扩展到数千个节点</strong>。</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><code>Meet</code> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><code>Ping</code> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><code>Pong</code> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><code>Fail</code> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><div class="note note-primary">            <p>meet用于新增节点，ping&#x2F;pong维护，fail用于下线节点</p>          </div><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>在某节点看来，其他节点的状态有<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p><ul><li>节点A发现某节点B下线时，将其标记为PFAIL，并通知附近节点C。</li><li>节点C接受到消息后，确认真假，将该状态记录并继续传播PFAIL消息。</li><li>最后节点判断其是否客观下线（<strong>自己认为</strong> 且 <strong>发现过半节点认为其疑似下线PFIAL</strong>），若客观下线，其会发送FAIL消息让所有节点接受节点A客观下线。</li></ul><h3 id="通讯维护"><a href="#通讯维护" class="headerlink" title="通讯维护"></a>通讯维护</h3><h4 id="什么时候进行心跳？"><a href="#什么时候进行心跳？" class="headerlink" title="什么时候进行心跳？"></a>什么时候进行心跳？</h4><p>Redis节点会记录其向每一个节点上一次发出ping和收到pong的时间，心跳发送时机与这两个值有关。通过下面的方式既能保证及时更新集群状态，又不至于使心跳数过多：</p><ul><li>每次Cron向所有未建立链接的节点发送ping或meet</li><li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li><li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li><li>收到ping或meet，立即回复pong</li></ul><h4 id="发送哪些心跳数据？"><a href="#发送哪些心跳数据？" class="headerlink" title="发送哪些心跳数据？"></a>发送哪些心跳数据？</h4><ul><li>Header，发送者自己的信息<ul><li>所负责slots的信息</li><li>主从信息</li><li>ip port信息</li><li>状态信息</li></ul></li><li>Gossip，发送者所了解的部分其他节点的信息<ul><li>ping_sent, pong_received</li><li>ip, port信息</li><li>状态信息，比如发送者认为该节点已经不可达，会在状态信息中标记其为PFAIL或FAIL</li></ul></li></ul><h4 id="如何处理心跳？"><a href="#如何处理心跳？" class="headerlink" title="如何处理心跳？"></a>如何处理心跳？</h4><h5 id="新节点加入"><a href="#新节点加入" class="headerlink" title="新节点加入"></a>新节点加入</h5><ul><li>发送meet包加入集群</li><li>从pong包中的gossip得到未知的其他节点</li><li>循环上述过程，直到最终加入集群<br><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104235107.png"></li></ul><h5 id="Slots消息"><a href="#Slots消息" class="headerlink" title="Slots消息"></a>Slots消息</h5><ul><li>判断发送者声明的slots信息，跟本地记录的是否有不同</li><li>如果不同，且发送者epoch较大，更新本地记录</li><li>如果不同，且发送者epoch小，发送Update信息通知发送者</li></ul><h5 id="Master-slave信息"><a href="#Master-slave信息" class="headerlink" title="Master slave信息"></a>Master slave信息</h5><p>发现发送者的master、slave信息变化，更新本地状态</p><h5 id="节点Fail探测-故障发现"><a href="#节点Fail探测-故障发现" class="headerlink" title="节点Fail探测(故障发现)"></a>节点Fail探测(故障发现)</h5><p>超时没有收到某节点pong包，标记其PFAIL，并在pong时传播这个标记。</p><blockquote><p>注：Gossip的存在使得集群状态的改变可以更快的达到整个集群。每个心跳包中会包含多个Gossip包，那么多少个才是合适的呢，redis的选择是N&#x2F;10，其中N是节点数，这样可以保证在PFAIL投票的过期时间内，节点可以收到80%机器关于失败节点的gossip，从而使其顺利进入FAIL状态。</p></blockquote><h3 id="故障恢复（Failover）"><a href="#故障恢复（Failover）" class="headerlink" title="故障恢复（Failover）"></a>故障恢复（Failover）</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>通过某个slave执行cluster failover命令，手动让某个master宕机，并将本slave作为master节点。<br>此时命令还包括一些流程处理，如校验offset，查看master状态和询问其他master意见等。</p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave。Failover的过程需要经过类Raft协议的过程在整个集群内达到一致，其过程如下：</p><ul><li>slave发现自己的master变为FAIL</li><li>将自己记录的集群currentEpoch加1，并广播Failover Request信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新Master</li><li>广播Pong通知其他集群节点<br><img src="/2023/01/04/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230105001028.png"></li></ul><h3 id="扩容-amp-缩容"><a href="#扩容-amp-缩容" class="headerlink" title="扩容&amp;缩容"></a>扩容&amp;缩容</h3><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ol><li>首先将新节点加入到集群中，可以通过在集群中任何一个客户端执行cluster meet 新节点ip:端口，或者通过redis-trib add node添加，新添加的节点默认在集群中都是主节点。</li><li>迁移数据 迁移数据的大致流程是，首先需要确定哪些槽需要被迁移到目标节点，然后获取槽中key，将槽中的key全部迁移到目标节点，然后向集群所有主节点广播槽（数据）全部迁移到了目标节点。</li></ol><h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>缩容的大致过程与扩容一致，需要判断下线的节点是否是主节点，以及主节点上是否有槽，若主节点上有槽，需要将槽迁移到集群中其他主节点，槽迁移完成之后，需要向其他节点广播该节点准备下线（cluster forget nodeId）。最后需要将该下线主节点的从节点指向其他主节点，当然最好是先将从节点下线。</p><h2 id="更深入理解"><a href="#更深入理解" class="headerlink" title="更深入理解"></a>更深入理解</h2><h3 id="为什么Redis-Cluster的Hash-Slot是16384？"><a href="#为什么Redis-Cluster的Hash-Slot是16384？" class="headerlink" title="为什么Redis Cluster的Hash Slot是16384？"></a>为什么Redis Cluster的Hash Slot是16384？</h3><p>我们知道一致性hash算法是2的16次方（65535），为什么hash slot是2的14次方（16384）呢？</p><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，使用bitmap压缩，16384bit &#x3D; 16kb &#x3D; 2kB，也就是说使用2kB的空间创建了16k的槽数。如果使用CRC16分配65535个槽位，需要使用8kB才行，作者认为没有必要。</p><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢？"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢？" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢？"></a>为什么Redis Cluster中不建议使用发布订阅呢？</h3><p>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会<strong>严重消耗带宽</strong>，不建议使用。（虽然官网上讲有时候可以使用Bloom过滤器或其他算法进行优化的。</p><p>todo:对比哨兵和集群的交流，维护机制<br>通讯维护部分详细化。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第4章（事件与事物）</title>
    <link href="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>所谓事件机制，指的是Redis 接受客户端的请求并响应（文件事件） 和 执行定时任务（时间事件） 的机制。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><div class="note note-primary">            <p>文件事件指交互性事件，时间事件指定时类执行事件。</p>          </div><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104015729.png"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p><p>Redis 是单线程主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>。采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。</p><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020000.png"></p><div class="note note-primary">            <p>这里还没学，暂时理解为netty、ae_event(Redis使用的)等是异步处理IO复用的应用框架，底层的实现库是与操作系统的具体实现有关。</p>          </div><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020123.png"><br>I&#x2F;O多路复用程序监听多个套接字（客户端），当需要套接字IO时，产生一个文件事件，Redis将这些就绪的文件事件放在一个队列中（fired就绪事件表），然后文件事件处理器会有序、同步、单个的执行一个个文件事件。</p><p>某客户端请求流程如下：<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020550.png"></p><h3 id="Redis-IO多路复用模型"><a href="#Redis-IO多路复用模型" class="headerlink" title="Redis IO多路复用模型"></a>Redis IO多路复用模型</h3><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020629.jpg"></p><div class="note note-primary">            <p>这里理解为epoll是一个操作系统内核机制，其监听了3个FD（套接字），当发生事件时，事件入列，然后逐个出列调用函数。</p>          </div><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis 的时间事件分为以下两类：</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：也就是说时间处理器处理某个事件后，判断其需不需要过一段时间再次执行。<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104022102.png"><br>所有事件时间放在一个无序链表中，时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件并调用相应事件处理器。</p><blockquote><p>一般Redis服务器只使用serverCron一个时间事件，这个事件用于更新服务器各类统计数据，清理键值，整理客户端连接，尝试AOF或RDB，同步数据，心跳检测等。总之，Redis会周期性的执行这个函数。</p></blockquote><h2 id="aeEventLoop实现"><a href="#aeEventLoop实现" class="headerlink" title="aeEventLoop实现"></a>aeEventLoop实现</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。具体过程是其会调用aeCreateEventLoop函数：</p><ul><li>创建该aeEventLoop对象。</li><li>初始化文件事件表内容</li><li>初始化时间事件表</li><li>调用aeApiCreate函数创建epoll实例，初始化apidata<br>具体实现不细看了，逻辑图如下<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104024156.png"></li></ul><h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li><code>MULTI</code> ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li><code>EXEC</code>：执行事务中的所有操作命令。</li><li><code>DISCARD</code>：取消事务，放弃执行事务块中的所有命令。</li><li><code>WATCH</code>：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li><code>UNWATCH</code>：取消WATCH对所有key的监视。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>语法错误：若存在语法错误，整个事务不会被执行。</li><li>类型错误：若在执行时发送Redis类型错误，该条命令失败，但其他命令正常执行。</li></ul><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p>WATCH命令为Redis事务提供了CAS的行为：<br>当执行了WATCH命令监视某键后，在执行时发现与WATCH时相比，键值发生了变化，则回滚事务。最后会取消监控。<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025042.png"></p><h3 id="事物执行步骤"><a href="#事物执行步骤" class="headerlink" title="事物执行步骤"></a>事物执行步骤</h3><ul><li>MULTI开始</li><li>入队</li><li>执行<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025058.png"></li></ul><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>redis悲观锁又称为分布式锁，主要是为了防止数据被其他客户改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>通过以上命令可以设置分布式锁(key&#x3D;lock-key)：</p><ul><li>若设置成功，会返回值，拥有控制权。</li><li>若设置失败，无返回值，需要排队等待。<br>期间其他客户无法操作lock-key。<br>操作完毕后通过<strong>del操作释放锁</strong>。</li></ul><h3 id="分布式锁改良"><a href="#分布式锁改良" class="headerlink" title="分布式锁改良"></a>分布式锁改良</h3><p>使用expire为lock-key设置过期时间，防止忘记或程序中断导致忘记释放锁</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="Redis不支持回滚？"><a href="#Redis不支持回滚？" class="headerlink" title="Redis不支持回滚？"></a>Redis不支持回滚？</h3><p>redis只会因语法错误（主要指类型错误这种无法提前检测的命令）而失败，这个错误是在编程时应该避免的。</p><h3 id="ACID？"><a href="#ACID？" class="headerlink" title="ACID？"></a>ACID？</h3><ul><li>原子性<em>atomicity</em><br>有观点认为Redis没有原子性，因为其不支持运行期回滚，但Redis官方的理解如下：<br><strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。</strong>这个过程并不保证执行成功。</li><li>一致性<em>consistency</em><br>Redis能保证命令失败的情况下回滚（普通语法错误、WATCH锁），能保证一致性。</li><li>隔离性<em>Isolation</em><br><strong>单线程</strong>的本质保证了隔离性（不会被其他客户端打断）</li><li>持久性<em>Durability</em><br><strong>redis事务是不保证持久性的</strong>，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</li></ul><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><ul><li><strong>基于Lua脚本</strong>，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li><strong>基于中间标记变量</strong>，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h1 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h1><blockquote><p>删除作为一个redis事件，也放在本章一起阐述。</p></blockquote><p>使用<code>TTL</code>可以查看键的生命状态：</p><ul><li>xx为时效数据</li><li>1为永久有效数据</li><li>2为已经过期或不存在的数据</li></ul><h2 id="常见的删除策略"><a href="#常见的删除策略" class="headerlink" title="常见的删除策略"></a>常见的删除策略</h2><ol><li>定时删除：定时任务，到时即删除</li><li>惰性删除：访问时删除，调用expireIfNeeded函数</li><li>定期删除：定期清理，serverCron()中会执行删除。</li></ol><div class="note note-success">            <p>redis使用的是<strong>惰性删除</strong>和<strong>定期删除</strong></p>          </div><div class="note note-primary">            <p>对于RDB，其不会记录已经删除的键<br>对于AOF，键过期后会在文件后面加上DEL key的命令。</p>          </div><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105004950.png"></p><p>这个格式不是redisObject的格式，而是redis数据库的一个格式。<br>redisDB结构中expires保存了所有的键过期信息。<br><img src="/2023/01/03/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105010244.png"></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第3章（持久化）</title>
    <link href="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/"/>
    <url>/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="持久化：RDB和AOF机制详解"><a href="#持久化：RDB和AOF机制详解" class="headerlink" title="持久化：RDB和AOF机制详解"></a>持久化：RDB和AOF机制详解</h2><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(<em>Redis DataBase</em>)持久化</h3><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><blockquote><p><strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><code>save</code>命令：由主线程执行，会造成长时间阻塞。</li><li><code>bgsave</code>命令：fork子线程执行，阻塞只发生在fork阶段。</li></ul><p><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103211303.png"></p><p>具体流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，<strong>那么主进程直接返回</strong>；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子<strong>替换</strong>旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_相关选项）。</li></ul><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>由以下4种触发情况</p><ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul><p><strong>相关配置</strong><br><code>stop-writes-on-bgsave-error</code>：bgsave错误时暂停主线程，主要目的是让运维人员排查问题<br><code>rdbcompression</code>：启用LZF压缩算法<br><code>rdbchecksum</code>：64位CRC冗余校验编码，可以验证RDB的完整性。</p><h4 id="深入RDB"><a href="#深入RDB" class="headerlink" title="深入RDB"></a>深入RDB</h4><ul><li><p><strong>并发问题？</strong><br><a href="https://zhuanlan.zhihu.com/p/339437815#:~:text=%20Redis%E4%B8%AD%E6%89%A7%E8%A1%8CBGSAVE%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90RDB%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E8%B0%83%E7%94%A8Linux%E4%B8%AD%E7%9A%84fork%20%28%29%E5%91%BD%E4%BB%A4%EF%BC%8CLinux%E4%B8%8B%E7%9A%84fork,%28%29%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%BA%86copy-on-write%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9B%20fork%20%28%29%E4%B9%8B%E5%90%8E%EF%BC%8Ckernel%E6%8A%8A%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E6%9D%83%E9%99%90%E9%83%BD%E8%AE%BE%E4%B8%BAread-only%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%8C%87%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%82%20%E5%BD%93%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%83%BD%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E3%80%82">Copy-on-Write</a><br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103215527.jpg"><br>如果主线程需要进行写操作，则将写操作部分的数据块复制，对新的副本进行修改，这样保证了bgsave子进程可见的数据的一致性（即bgsave开始时的快照）</p></li><li><p><strong>若服务崩溃怎么办？</strong><br>bgsave的temp文件在生成之前不会覆盖旧的dump。</p></li><li><p><strong>能否尽可能快的RDB</strong>?<br>快照过快会导致fork大量阻塞主线程，且磁盘空间是有限的。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li><strong>LZF压缩算法，文件体积远小于内存</strong></li><li>加载速度比AOF快</li></ul></li><li>缺点<ul><li><strong>实时性不够</strong></li><li><strong>开销大</strong></li><li>版本兼容</li><li>RDB文件无法手动修改</li></ul></li></ul><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append only file)持久化"></a>AOF(<em>append only file</em>)持久化</h3><p>执行写命令时，<strong>先写内存，后写日志</strong>。<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220350.jpg"></p><blockquote><p>目的：</p><ol><li>避免额外检查，执行成功才写日志</li><li>不阻塞当前写操作<br>风险：</li><li>完成写内存后中断，日志缺失</li><li>主线程写磁盘压力过大</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220620.jpg"></li><li><strong>AOF重写</strong> Redis通过创建一个新的AOF文件来替换现有的AOF。</li></ul><div class="note note-primary">            <p>aof_buf缓存写命令，触发写回时将aof_buf中命令一次写入磁盘</p>          </div><p><strong>相关配置</strong><br><code>appendfsync</code>：主要用于设置“真正执行”操作命令向AOF文件中同步的策略，支持always、everysec、no，默认为everysec。<br><code>no-appendfsync-on-rewrite</code>：<strong>重写</strong>时不再记录新命令<br><code>auto-aof-rewrite-percentage</code>：当前AOF文件超过上次重写AOF文件大小的百分之多少后开始重写。<br><code>auto-aof-rewrite-min-size</code>：当前AOF文件超过设置大小时开始重写</p><h4 id="深入AOF重写"><a href="#深入AOF重写" class="headerlink" title="深入AOF重写"></a>深入AOF重写</h4><ul><li><strong>AOF重写会阻塞吗</strong>？<br>重写时会fork主线程，由后台进程bgrewriteaof完成，fork时会阻塞主线程。</li><li><strong>何时重写</strong>？<br>auto-aof-rewrite-percentage和auto-aof-rewrite-min-size</li><li><strong>并发问题</strong>？<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103221653.jpg"><br>重写时:</li><li>redis原始数据会通过copy on write机制拷贝</li><li>服务器写入新数据时，会将新数据同时写入两个aof_buf缓存区（当持久化策略为always时，则是写入磁盘和一个aof_buf缓冲），<strong>子线程</strong>完成重写后通知主线程，<strong>主线程</strong>会把aof重写缓冲区的命令追加到aof文件中。最后文件改名，保证原子性。</li></ul><blockquote><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会<strong>拷贝父进程的页表</strong>，即<strong>虚实映射关系</strong>（虚拟内存和物理内存的映射索引表），而<strong>不会拷贝物理内存</strong>。这个拷贝会消耗大量cpu资源，并且<strong>拷贝完成前会阻塞主线程</strong>，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p></blockquote><ul><li><p><strong>重写时有哪些阻塞</strong>？</p><ul><li>fork</li><li>主线程bigkey写入，操作系统需要创建页面副本并拷贝原有数据。</li><li>主线程追加写入aof</li></ul></li><li><p><strong>为什么AOF不复用原AOF文件</strong>？</p><ul><li>父子同时写一个文件产生竞争，影响父进程性能</li><li>若重写失败会造成污染</li></ul></li></ul><h3 id="RDB和AOF混合方式"><a href="#RDB和AOF混合方式" class="headerlink" title="RDB和AOF混合方式"></a>RDB和AOF混合方式</h3><p>在Redis4.0提出，简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志<strong>记录这期间</strong>的所有命令操作。<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222843.jpg"></p><ul><li>RDB不用过快执行，同时AOF也不会过大</li></ul><h3 id="持久化恢复"><a href="#持久化恢复" class="headerlink" title="持久化恢复"></a>持久化恢复</h3><p>重启redis即可恢复<br><img src="/2023/01/03/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222858.png"><br>AOF优先级更高，因为其数据更完整。</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第2章（对象机制）</title>
    <link href="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><blockquote><p>前面介绍了Redis的基本数据类型，针对这些数据类型有着不同的底层实现。</p></blockquote><p>对象模型：<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190013.png"></p><blockquote><p>Redis对象有不同的数据类型，而一个数据类型可能有多种实现方式（编码类型），根据value的情况灵活变化。<br>编码类型作为一种类型标识，告诉了Redis应该如何解析这个对象，不同编码类型也有不同的底层数据结构实现。</p></blockquote><p>Redis对象机制作用：<br><strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.<br><strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><h1 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190705.png"></p><ul><li>type标识了数据所属的基本类型</li><li>encoding标识了数据类型对于的编码</li><li>LRU记录了数据的最后访问时间和访问次数</li><li>refcount记录了对象被引计数</li><li>ptr指向真实的底层数据结构</li></ul><div class="note note-primary">            <p>redisObject保存了Redis服务器需要维护的对象信息，包括数据结构类型和编码（用于多态解析），LRU（LFU）和refcount（淘汰机制），ptr指向底层数据结构。</p>          </div><h2 id="命令检查与多态"><a href="#命令检查与多态" class="headerlink" title="命令检查与多态"></a>命令检查与多态</h2><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103191229.png"></p><div class="note note-success">            <p>type判断命令是否正确，encoding判断如何执行命令</p>          </div><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>redis一般会把一些常见值放入共享对象中：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192218.png"><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。<br>像整数集合和压缩列表这些将数据保存在数据结构内的则无法使用。</p></blockquote></li></ul><blockquote><p>为什么不共享其他数据结构：<br>复杂度较高，消耗CPU，用其换取内存不划算。</p></blockquote><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h1 id="底层数据对象"><a href="#底层数据对象" class="headerlink" title="底层数据对象"></a>底层数据对象</h1><h2 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h2><p><strong>简单动态字符串（simple dynamic string,SDS</strong>）的存在是为了尽可能的节省存储可见，只为对象分配其需要的空间大小。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192512.png"></p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的<strong>头部</strong>, 分别如下:<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192821.png"><br>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的<code>\0</code>, 剩余的字节数。</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><div class="note note-primary">            <p>实际SDS的长度为 头部+alloc+尾部。<br>len为<code>buf[]</code>中的有效长度，即有效字符串长度。</p>          </div><h3 id="为何使用SDS"><a href="#为何使用SDS" class="headerlink" title="为何使用SDS"></a>为何使用SDS</h3><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li></ul><blockquote><p>在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p></blockquote><h2 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h2><p>ziplist是一个特殊编码的双向列表，其可以存储字符串或整数，操作的时间复杂度为O(1)，每次操作都需要重新分配ziplist的内存。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103194043.png"></p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p>一般</p><ul><li><code>prevlen</code>：前一个entry的大小</li><li><code>encoding</code>：表示当前entry类型和长度</li><li><code>entry-data</code>:存储entry标识的数据<br>特殊<br>类型为int时，<code>encoding</code>和<code>entry-data</code>合并在一起表示，没有<code>entry-data</code>。</li></ul><p><strong>prevlen</strong><br>前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度。<br>如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><p><strong>encoding编码</strong><br>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；<br>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><h3 id="为什么ZipList省内存"><a href="#为什么ZipList省内存" class="headerlink" title="为什么ZipList省内存"></a>为什么ZipList省内存</h3><p>根据数据类型灵活变化编码规则，使用encoding标识entry类型和大小，是。<br>因为是双端列表，为了解决遍历问题，使用prevlen字段方便倒序遍历。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不预留空间，每次写操作都需要重新分配内存。<br>节点扩容可能导致后续所有prevlen字段扩容。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>是一个以ziplist为节点的双端链表结构。</p><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下</li></ul><h3 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103200220.png"></p><ul><li><p><code>quicklist.fill</code>影响ziplist的长度，数值为负数时限制ziplist最大长度，为正数时限制ziplist的entry数量。</p></li><li><p><code>quicklist.compress</code>影响zl字段指向的对象的类型，0标识指向ziplist，1表示链表的头尾节点不压缩，2标识头尾各2各节点不压缩，其他为压缩后的quicklistLZF。</p></li><li><p><code>quicklistNode.encoding</code>，标识本链表节点是否压缩，1表示没压缩，2表示压缩了。</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压。如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><h2 id="字典-x2F-哈系表-Dict"><a href="#字典-x2F-哈系表-Dict" class="headerlink" title="字典&#x2F;哈系表 - Dict"></a>字典&#x2F;哈系表 - Dict</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103201159.png"></p><h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul><li>哈希算法：使用hash函数计算key的哈希值，使用sizemask与第一步得到的hash值，计算索引。</li><li>哈希冲突：链地址法</li><li>扩容&#x2F;缩容：<ul><li>rehash，扩展时创建两倍大小的hash表，缩小时则创建缩小一倍的新哈希表。</li><li>重新计算索引</li><li>迁移所有键值对，然后释放内存</li></ul></li><li>扩容条件：<ol><li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</li><li>ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</li></ol></li><li>渐进式rehash<br>  分多次完成rehash迁移，此时查找会在新旧两个哈希表上找，但是新增只会在新哈希表上新增。</li></ul><h2 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202006.png"></p><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><div class="note note-primary">            <p>可见intset就是一个排序的数组。</p>          </div><p>contents中每个元素的数据类型由encoding决定，当有数字的值超出范围时，集合需要升级，其会：</p><ul><li>扩展整数集合底层数组的可见大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上。（需要继续维持底层数组的有序性质不变）。</li><li>最后改变encoding的值，length+1。</li></ul><p>但intset不会降级，这是没必要的开销。</p><h2 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h2><p>跳表在redis中只用在zset数据类型中，其保证查找删除添加等操作在对数的期望时间内完成。</p><p>原理示例：<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202637.png"></p><p>内存布局：<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202658.png"></p><p><strong>zskiplist的核心设计要点</strong></p><ul><li><strong>头节点</strong>不持有任何数据, 且其<code>level[]</code>的长度为32。</li><li><strong>每个结点</strong><ul><li><code>ele</code>字段，持有数据，是sds类型</li><li><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li><code>level</code>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段<ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在<code>level[]</code>中的索引为X, 则其forward字段指向的结点, 其<code>level[]</code>字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1</li></ul></li></ul></li></ul><h3 id="为什么不用平衡树或者哈希表"><a href="#为什么不用平衡树或者哈希表" class="headerlink" title="为什么不用平衡树或者哈希表"></a>为什么不用平衡树或者哈希表</h3><p>hash无序，无法进行范围查找，平衡数的范围搜索也很复杂，子树的调整也很复杂。</p><h1 id="redis对象与编码-底层结构-对应关系"><a href="#redis对象与编码-底层结构-对应关系" class="headerlink" title="redis对象与编码(底层结构)对应关系"></a>redis对象与编码(底层结构)对应关系</h1><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203244.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串长度不能超过512M。</strong></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li><code>int 编码</code>：保存的是可以用 long 类型表示的整数值。</li><li><code>embstr 编码</code>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><code>raw 编码</code>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203355.png"><br>embstr少一次分配空间，但其为只读,修改时要重新分配一次raw空间。</p><p>ps:<strong>Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型</strong>。</p><ul><li><strong>编码的转换</strong><blockquote><p>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。<br>对于embstr编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p></blockquote></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>按<strong>数值进行操作的数据</strong>，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>quicklist</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203823.png"></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h3><p>ziplist和hashtable</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><ul><li>ziplist</li><li>dict<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204020.png"></li></ul><p>使用ziplist时，新的键值对作为entry插入list尾部。<br>使用hashtable编码时，使用dict。</p><p><strong>编码转换</strong><br>和上面列表对象使用 ziplist 编码一样，当<strong>同时满足下面两个条件</strong>时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节<br>不能满足这两个条件的时候使用 hashtable 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>hash类型下的value只能存储字符串</li><li>每个hash可以存储2^32-1个键值对</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="编码-3"><a href="#编码-3" class="headerlink" title="编码"></a>编码</h3><p>intset或hashtable</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204842.png"></p><p><strong>编码转换</strong><br>当集合同时满足以下两个条件时，使用intset编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512<br>不能满足这两个条件的就使用hashtable编码。第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="编码-4"><a href="#编码-4" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 skiplist(ziplist+dict)</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p>ziplist<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205150.png"></p><p>skiplist(ziplist+dict)<br><img src="/2023/01/03/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205236.png"><br>字典可以快速查找成员，但无序，跳表可以快速执行范围查找，将两者结合共同实现有序集合。</p><p><strong>编码转换</strong><br>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。<br>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第1章（数据类型与结构）</title>
    <link href="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <url>/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis知识体系"><a href="#一、Redis知识体系" class="headerlink" title="一、Redis知识体系"></a>一、Redis知识体系</h1><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230191017.png"></p><h1 id="二、Redis概念与基础"><a href="#二、Redis概念与基础" class="headerlink" title="二、Redis概念与基础"></a>二、Redis概念与基础</h1><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。</li><li>数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>持久化：AOF&#x2F;RDB</li><li>发布订阅：Subscribe</li><li>分布式：RedisCluster</li><li>redis为每个服务提供有16个数据库，编号从0到15，默认为0号数据库</li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>热点数据的缓存</li><li>限时任务的运用</li><li>计数器</li><li>分布式锁</li><li>延时操作</li><li>排行榜</li><li>点赞</li></ul><h1 id="三、Redis基础数据类型"><a href="#三、Redis基础数据类型" class="headerlink" title="三、Redis基础数据类型"></a>三、Redis基础数据类型</h1><blockquote><p>Redis所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p></blockquote><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230200246.jpg"></p><div class="note note-primary">            <p><strong>String</strong>也可以是整数和浮点数，支持自增和自减操作。<br><strong>Zset</strong>说是set，实际上结构类似hash，其保存了<strong>字符串成员</strong>和<strong>浮点分数</strong>之间的映射关系。</p>          </div><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>GET,SET,INCR,DECR,INCRBY,DECRBY</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>缓存常用信息，计数器，session.</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis用双端链表实现List。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>LPUSH,LPOP,<strong>LRANGE</strong>(获取范围内元素),LINDEX(获取索引元素)</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>时间轴微博，消息队列（按照时间先后排序的场景）</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序集合，成员唯一。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p>SADD,<strong>SCARD</strong>(获取成员数),SMEMERS(返回所有成员),SISMEMBER(判断是否为成员)</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>文章标签，不需要时间排序的点赞、收藏等。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>field -&gt; value，适合存储对象</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><p>HSET,HGET,HGETALL,HDEL</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>缓存查询信息，适合存储结构体。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>成员唯一。通过了压缩列表和跳跃表两种数据结构实现。<br>压缩列表：提高了存储效率，特殊编码的双向链表。<br>跳跃表：快速查找，删除，添加（对数时间内）</p><div class="note note-primary">            <p>操作时按照跳跃表找到指定位置对数据进行修改，存储时以压缩列表形式存储。</p>          </div><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>ZADD,ZRANGE,ZREM</p><h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>排行榜</p><h1 id="四、Redis特殊类型结构"><a href="#四、Redis特殊类型结构" class="headerlink" title="四、Redis特殊类型结构"></a>四、Redis特殊类型结构</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构</p></blockquote><p>基数统计，可以理解为高性能的set，但精确度有限（0.81% 标准误差）。<br>基数指的是set中每一个不重复的元素，其可以解决海量数据统计的问题，其优势在于存储消耗的空间很小。</p><h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfadd key1 a b c  #创建第一组元素<br>pfcount key1 #统计元素个数<br>pfmerge key3 key1 key2 #合并key1,key2到key3<br></code></pre></td></tr></table></figure><h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><p>每日访问IP数，在线用户数等</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>位存储，使用位记录 0，1两个状态。</p><h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">setbit key 0 1  #设置第0位为1<br>getbit key 0 #获取第0位<br>bitcount key #求1的数量<br></code></pre></td></tr></table></figure><h3 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h3><p>记录每条的打卡情况</p><h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了!</p></blockquote><h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">geoadd china:city(相当于key) 118 32 beijing(相当于value对象)#即可以为一个区域添加多个点<br>geopos china:city beijing<br>geodist china:city beijing shenyang m #以M为单位求两地距离<br>georadius china:city 110 30 1000 km #求中国城市中，以110，30为中心，1000km为半径范围内所有城市。<br>geohash china:city beijing #较少使用,返回hash字符串<br></code></pre></td></tr></table></figure><h3 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h3><p>附近的人code</p><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>底层实现是Zset，其将经纬度转换为一个分数保存在其中。</p><h1 id="五、消息队列Steam"><a href="#五、消息队列Steam" class="headerlink" title="五、消息队列Steam"></a>五、消息队列Steam</h1><p>借鉴了Kafka，是一种消息队列的实现。</p><blockquote><p>Redis的消息队列实现很多：</p><ul><li>Pub&#x2F;Sub，缺点：丢失的消息无法持久化。</li><li>List，缺点：不支持多播，持久化。</li></ul></blockquote><p>消息队列设计<br><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230213704.png"></p><h2 id="Stream结构"><a href="#Stream结构" class="headerlink" title="Stream结构"></a>Stream结构</h2><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230214054.png"></p><ul><li><code>Stream</code>：一种数据结构，每个Stream有一个唯一的名称，也就是key。</li><li><code>Comsumer Group</code>消费组：一个消费组有多个消费者，他们之间是<strong>竞争关系</strong></li><li><code>pending_ids</code>消费者状态变量：维护了消费者尚未确认的id。</li></ul><div class="note note-primary">            <p>对于每一条消息都要确保其被消费，或者确定这是一个投递不出去的坏消息（死信）。所以需要对<strong>每个消费者</strong>维护一个<strong>pending_ids</strong>，表示这个消息已经交给它处理，但它还没有完成对该消息的确认（ack）。</p><p>而对于<strong>每个消费组</strong>，则需要一个指针维护其最后一次读取到的消息id（<strong>Last_dilivered_id</strong>）。</p>          </div><p>另外，每个消息都有独一无二的ID，默认为时间戳，格式为1527846880572-5，当毫秒不够用时，使用<code>-</code>后面的数标注该消息是本毫秒的第几个消息。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>即不使用消费组的情况下进行消费。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xread count 2 streams key 0-0 #读取两条消息<br>xread block 0 count 1 streams key $ #阻塞读取队列最后的消息<br></code></pre></td></tr></table></figure><p>block 0表示永远阻塞，直到消息到，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil。</p><blockquote><p>独立消费不会自动维护last_read指针，需要用户自己记住最后消息ID，下次将其作为参数传递即可继续消费。</p></blockquote><h2 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h2><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230231440.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为”已处理”</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息<br>具体使用见<a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html">消费组命令使用</a></li></ul><p>xreadgroup也可以阻塞等待，读取后，消息进入消费者的pending_ids，当消费者回复xack时，将这个消息从其pending_ids消除。</p><div class="note note-primary">            <p>消费时，需要传入流名称、消费组名称、消费者名称3个参数。<br>ACK时，需要传入流名称、消费组名称、消息id。<br>可见回复时，不需要具体定位到消费者，因为redis本身就知道某个消息id属于消费组中的哪个消费者。</p>          </div><h2 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h2><p><code>Xinfo</code>命令可以查看stream的基本信息，如：</p><ul><li>XINFO STREAM keyName</li><li>XINFO GROUPS keyName</li><li>XINFO CONSUMERS keyName groupName</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>实时通讯、大数据分析、异地数据备份。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个<strong>64位整型</strong>（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>Redis生成的ID是单调递增有序的。若服务器时间错误，Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号）。</p><h3 id="消费者崩溃带来的会不会消息丢失问题"><a href="#消费者崩溃带来的会不会消息丢失问题" class="headerlink" title="消费者崩溃带来的会不会消息丢失问题?"></a>消费者崩溃带来的会不会消息丢失问题?</h3><p>Pending列表可以记录已读取但未ack的消息。<br>命令<code>XPENDIING</code>用来获消费组或消费内消费者的未处理完毕的消息。</p><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>其保证消费者恢复时，可重新从pending列表中取消息处理。</p><h3 id="消费者彻底宕机后如何转移给其它消费者处理？"><a href="#消费者彻底宕机后如何转移给其它消费者处理？" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理？"></a>消费者彻底宕机后如何转移给其它消费者处理？</h3><p>使用<code>XCLAIM</code>将目标消费者和消息ID转移到自己的pending列表中，同时需要提供<strong>IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p><h3 id="坏消息问题，Dead-Letter，死信问题"><a href="#坏消息问题，Dead-Letter，死信问题" class="headerlink" title="坏消息问题，Dead Letter，死信问题"></a>坏消息问题，Dead Letter，死信问题</h3><p>delivery counter，反复转给各个消费者时会累加，当到达临界值时将该消息视为死信，此时可以处理该消息，一般删除即可，XDEL。</p><h1 id="六、发布订阅详解"><a href="#六、发布订阅详解" class="headerlink" title="六、发布订阅详解"></a>六、发布订阅详解</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis有两种发布&#x2F;订阅模式：</p><ul><li>基于频道(Channel)的发布&#x2F;订阅</li><li>基于模式(pattern)的发布&#x2F;订阅</li></ul><h2 id="基于频道的发布和订阅"><a href="#基于频道的发布和订阅" class="headerlink" title="基于频道的发布和订阅"></a>基于频道的发布和订阅</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">publish channel:1 hi #发布消息<br><br>subscribe channel:1 #订阅频道，随后进入订阅状态<br></code></pre></td></tr></table></figure><p>处于订阅状态下客户端不能使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>和<code>punsubscribe</code>这四个属于”发布&#x2F;订阅”之外的命令，否则会报错。</p><h2 id="基于模式-pattern-的发布-x2F-订阅"><a href="#基于模式-pattern-的发布-x2F-订阅" class="headerlink" title="基于模式(pattern)的发布&#x2F;订阅"></a>基于模式(pattern)的发布&#x2F;订阅</h2><p>如果有某个&#x2F;某些模式和这个频道匹配的话，那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。<br><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-6.svg"><br>通配符中<code>?</code>表示1个占位符，<code>*</code>表示任意个占位符(包括0)，<code>?*</code>表示1个以上占位符。</p><ul><li>psubscribe可以重复订阅一个频道，会收到多条消息。</li><li>subscribe和psubscribe是相互独立的，接受到消息时也会有区别。</li><li>使用punsubscribe只能退订通过psubscribe命令订阅的规则。</li></ul><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="基于频道"><a href="#基于频道" class="headerlink" title="基于频道"></a>基于频道</h3><p><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-4.svg"></p><ul><li>订阅时，将客户端添加到对应channel的list中</li><li>发布时，订阅到channel，发送给List中所有客户端。</li></ul><h3 id="基于模式"><a href="#基于模式" class="headerlink" title="基于模式"></a>基于模式</h3><ul><li>订阅时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。<br><img src="/2022/12/30/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-10.svg"></li><li>发布时，遍历pubsubPattern，逐一对比看是否要发送。</li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第6章（应用层）</title>
    <link href="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-968c1bcea54ea1f4.webp"><br>例子：<br><strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong>，该应用还涉及到域名到IP地址的转换，由属于<strong>应用层范畴的域名系统DNS</strong>完成。<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4e9858624d4835ae.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c1c3868fb5e127b1.webp"></p><h1 id="二、两种组织方式"><a href="#二、两种组织方式" class="headerlink" title="二、两种组织方式"></a>二、两种组织方式</h1><h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-bbfb139bb8ffd796.webp"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-598b1158f5c33a11.webp"></p><div class="note note-primary">            <p>www,email,ftp为C&#x2F;S架构。</p>          </div><h1 id="三、动态主机配置协议DHCP"><a href="#三、动态主机配置协议DHCP" class="headerlink" title="三、动态主机配置协议DHCP"></a>三、动态主机配置协议DHCP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>DHCP</strong>使用了C&#x2F;S方式：</p><ul><li>主机在启动时向DHCP服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li><li>基于UDP工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><h4 id="发现报文"><a href="#发现报文" class="headerlink" title="发现报文"></a>发现报文</h4><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong>，其中包含<strong>事务ID</strong>，<strong>DHCP客户端的MAC地址</strong></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-6f9a9715f8b1c74a.webp"></p><blockquote><p>报文包括：</p><ul><li><strong>源IP地址</strong>：0.0.0.0，这是因为主机目前还未分配到IP地址。</li><li><strong>目的地址</strong>：广播地址255.255.255.255。</li><li><strong>MAC地址</strong>：主机MAC地址。</li></ul></blockquote><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送。</p><h4 id="提供报文"><a href="#提供报文" class="headerlink" title="提供报文"></a>提供报文</h4><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03ecd6d2838d4274.webp"></p><blockquote><p>报文包括</p><ul><li><strong>事务ID</strong>：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的。</li><li><strong>配置信息</strong>：IP地址、子网掩码、地址租期、默认网关、DNS服务器</li><li><strong>源IP地址</strong>：发送DHCP提供报文的DHCP服务器的IP</li><li><strong>目的地址</strong>：因为目的主机还没分配到IP，所以使用广播地址</li></ul></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-009b1e9a88976880.webp"></p><blockquote><p>报文包括<br><strong>事务ID</strong><br><strong>MAC地址</strong><br><strong>接受的IP地址</strong><br><strong>提供此租约的DHCP服务器端的IP地址</strong><br><strong>源IP地址</strong>：0.0.0.0<br><strong>目的地址</strong>：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们作为自己的DHCP服务器。</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文。</p><h4 id="确认报文"><a href="#确认报文" class="headerlink" title="确认报文"></a>确认报文</h4><p><strong>DHCP服务端将广播发送DHCP确认报文（DHCP ACK）</strong><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-35c9002bba766476.webp"></p><blockquote><p>报文包括：<br>源地址：DHCP服务器1的IP地址<br>目的地址：广播地址</p></blockquote><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong>，<strong>在使用前还会进行ARP检测</strong>。<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-044fb99d76bd279c.webp"></p><h4 id="剩余流程"><a href="#剩余流程" class="headerlink" title="剩余流程"></a>剩余流程</h4><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a01eacfba40e9098.webp"></p><div class="note note-primary">            <p>由于确认客户端的IP地址前，其都没有IP地址，所以DHCP借用IP的过程中报文的目的IP都是广播，服务器的源IP地址都是自身IP地址，客户端IP地址为默认0.0.0.0。</p><p>客户端请求IP是一个4握手过程。前2个握手用于服务端和客户端明确对方的存在并给客户端一个Offer。后2个握手就是客户端确定这个Offer的过程。</p><p>第三个握手，虽然是广播，但其他的DHCP服务器是不会接受的，因为事物ID不符。</p><p>到达0.5倍租用期时，客户端会主动续租，若超过了租用期，则停止使用这个IP地址。</p>          </div><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-33c64efac75f0ad2.webp"></p><p>由于网络之间存在广播域，主机的广播消息可能无法送达DHCP服务器，可为路由器配置DHCP中继代理服务，路由器会将接受到的DHCP报文转发到DHCP服务器。</p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-37d8836f5ed85036.webp"></p><h1 id="四、域名系统DNS"><a href="#四、域名系统DNS" class="headerlink" title="四、域名系统DNS"></a>四、域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8dc45fb61122f775.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-31a3076fe8055379.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4655232a57435f63.webp"></p><blockquote><p>名称相同的域名等级未必相同。</p></blockquote><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c2350ce866abf74e.webp"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-aae45d426ec7fa49.webp"></p><div class="note note-primary">            <p>递归查询的过程是链式调用，最后将域名对应的IP地址返回给主机。<br>迭代查询的过程是由本地域名服务器作为请求主体，迭代查询各级服务器IP。</p>          </div><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-d2652511b6f2280d.webp"></p><div class="note note-primary">            <p>本地域名服务器使用高速缓存减少DNS查询次数，但需要保证正确性，所以对于每一项缓存都有倒计时，超时的记录会被删除。<br>同时，主机也需要做缓存（多级缓存），启动时便向本地域名服务器获取域名和IP的数据库信息，必要时再询问服务器。</p>          </div><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-93d3fbaa54195112.webp"></p><h1 id="五、文件传送协议FTP"><a href="#五、文件传送协议FTP" class="headerlink" title="五、文件传送协议FTP"></a>五、文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-df91fe396712c633.webp"></p><h2 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h2><p>FTP采用了C&#x2F;S方式，监听熟知端口（21）。</p><h3 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-885981a43745ae55.webp"></p><div class="note note-primary">            <p>主动、被动指的是数据通道的建立发起者是否是服务器，主动模式服务器会使用固定的端口号连接客户端的临时端口号，被动模式服务器会开启某个临时端口号等待客户端连接。<br>注意，两种方式最后都会建立两个连接通道，控制连接在整个会话期间保持打开状态，数据连接传输完毕后就关闭。</p>          </div><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/Pasted%20image%2020221230015319.png"></p><h1 id="六、电子邮件"><a href="#六、电子邮件" class="headerlink" title="六、电子邮件"></a>六、电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-905f080fde0331a5.webp"></p><blockquote><p>注意：SMTP是发送协议，POP3&#x2F;IMAP是读取协议。</p></blockquote><h2 id="邮件发送和接受过程"><a href="#邮件发送和接受过程" class="headerlink" title="邮件发送和接受过程"></a>邮件发送和接受过程</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a55537e03d980133.webp"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）"></a>简单邮件传送协议SMTP（<em>Simple Mail Transfer Protocol</em>）</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03f4877d2621c261.webp"></p><h3 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-fb16b5ace5466b25.webp"></p><div class="note note-primary">            <p><strong>MIME</strong>是一层非ASCII和ASCII码之间的扩展转换器，其可以协助非ASCII码邮件以SMTP的形式发送。</p>          </div><h3 id="邮件接受"><a href="#邮件接受" class="headerlink" title="邮件接受"></a>邮件接受</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c825d1ad122bd41c.webp"></p><blockquote><p><strong>POP3</strong>是正式标准，客户只读。<br><strong>IMAP4</strong>是建议标准，客户可以操作服务器中的邮件，需要联机。</p></blockquote><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-46b15b10a17604fa.webp"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-b400e3f6c0a87238.webp"></p><div class="note note-primary">            <p>POP3使用110端口，IMAP4使用143端口</p>          </div><h1 id="七、万维网WWW"><a href="#七、万维网WWW" class="headerlink" title="七、万维网WWW"></a>七、万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>基本概念</p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络，而是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。<strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8646898df7461ca3.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-05ae15f55de2ba0a.webp"></p><h2 id="HTTP（Hyper-Transfer-Protocol）"><a href="#HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="HTTP（Hyper Transfer Protocol）"></a>HTTP（<em>Hyper Transfer Protocol</em>）</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP是一个应用层协议，它使用 <strong>TCP 连接</strong>进行可靠的传送。</li><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-614d1960b2b805d9.webp"></li></ul><div class="note note-primary">            <p>可以注意到第三次握手的时候就发出了HTTP请求报文。</p>          </div><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-22dfb8a34acf459c.webp"><br>响应报文<br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-0409ca153701fbb4.webp"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-969dc15b42399e98.webp"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-abf0fcf785757c26.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-e7f4b696946ffafa.webp"><br><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-14ec3f45c4af32f9.webp"></p><div class="note note-primary">            <p>为了保证缓存的正确性，设置有过期时间，若没有过期，则直接返回，若过期了，则询问服务器文档内容是否有变化：</p><ul><li>若没有则直接返回一个普通响应，缓存服务器接受后直接刷新倒计时。</li><li>若有则返回新的文档内容，缓存服务器接收并更新内容。</li></ul>          </div><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-dab94fae0e969502.webp"></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第5章（运输层）</title>
    <link href="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程之间通讯<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-86df51cb4523e3bf.webp"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><div class="note note-primary">            <p>NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议。</p>          </div><p>之前介绍的物理层、数据链路层、网络层解决了主机到主机的通讯。但通讯的真正实体是位于通讯两端主机的进程，如何为这两个进程提供通讯服务是运输层的任务，运输层协议也被称为端到端协议。</p><h2 id="端口号与复用"><a href="#端口号与复用" class="headerlink" title="端口号与复用"></a>端口号与复用</h2><p>端口号的使用<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-de597eda77aa6acd.webp"></p><h3 id="发送方与接受方的复用"><a href="#发送方与接受方的复用" class="headerlink" title="发送方与接受方的复用"></a>发送方与接受方的复用</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2a4ec3f5d5c11433.webp"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong><br><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p></blockquote><h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2117fa99a7f2a89c.webp"></p><h1 id="二、运输层传输流程（DNS）"><a href="#二、运输层传输流程（DNS）" class="headerlink" title="二、运输层传输流程（DNS）"></a>二、运输层传输流程（DNS）</h1><ul><li>DNS客户端（端口为短暂端口号）发送一个<strong>DNS请求报文</strong>（UDP）到DNS服务器（端口号为53）。</li><li>DNS服务器将接受到的信息上传给DNS服务器端进程（端口号为53），随后给用户回复<strong>DNS响应报文</strong>（UDP），目的端口为客户端的短暂端口号。</li><li>DNS客户端将接受到的信息上传给DNS客户端进程（端口号为短暂端口号），随后解析DNS响应报文，即可直到Web域名对应的IP地址。</li><li>向Web域名对应的IP发送http请求。</li></ul><h1 id="三、UDP与TCP对比"><a href="#三、UDP与TCP对比" class="headerlink" title="三、UDP与TCP对比"></a>三、UDP与TCP对比</h1><h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h2><ul><li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>；当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。；UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li><li>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接；UDP的通信是无连接的，不需要套接字（Socket）。</li></ul><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-58c94f043969af9a.webp"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>结构<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-624005a24bc5bfcd.webp"><br>实现</p><ul><li>UDP可以<strong>广播、多播和单播</strong></li><li>UDP对应用进程交下来的报文<strong>既不合并也不拆分</strong>，而是保留这些报文的边界</li><li>UDP向上层提供<strong>无连接不可靠传输服务</strong></li></ul><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h2><p>结构<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-db48b70af7fb7884.webp"><br>实现</p><ul><li>TCP只支持单播，端对端通讯</li><li>需要先通过3次握手建立连接</li><li>TCP是面向字节流的，即其<strong>可能会拆分上层交付的报文</strong>。</li><li>TCP向上层提供<strong>面向连接的可靠传输服务</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-b0c1d4146735458a.webp"></p><h1 id="四、TCP流量控制"><a href="#四、TCP流量控制" class="headerlink" title="四、TCP流量控制"></a>四、TCP流量控制</h1><p>目的：发送的速率尽可能快，但需要接受方来得及接受。<br>实现：滑动窗口。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=60">具体流程视频</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>累计确认+选择重传（只重传超时的，即每个窗口独立持有一个计时器）</p><ol><li>发送端和接受端分别具有发送窗口和接受窗口。发送端会将发送窗口内的字节数据依次发出。</li><li>接受方通过累计确认提示发送端应该<strong>如何调整发送窗口的大小</strong>（流量控制）以及<strong>已经接受到了n字节之前的数据</strong>。</li><li>发送方接受到累计确认后<strong>调整发送窗口大小</strong>并<strong>移动发送窗口</strong>。</li><li>移动发送窗口后：<ul><li>将刚进入窗口的窗口信息发送出去</li><li>同时等待看是否有窗口触发超时重传，若有则重传旧数据。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f73e94f75e94ea4c.webp"></li></ul></li><li>接受端将发送窗口调整为了0，说明暂时不接受数据，其恢复后给发送方的提示是可能丢失的。因此，<strong>当发送窗口为0（接受到0窗口通知）时，</strong>发送方<strong>持有持续计时器，超时时会发送</strong>零窗口探测报文**，确认接受端处理能力情况。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-5bd53b8a5a5ac400.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ea9dc3589e6c6bd1.webp"></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d8221e9dda7919f9.webp"></p><h1 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-9d4b410b2a44c125.webp"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><div class="note note-primary">            <p>理解拥塞原因：<br>1.传输时，链路容量不足；2.接受时，容量太小；3.处理时，速率太慢；4.负反馈。</p>          </div><p><strong>拥塞控制的一般原理</strong></p><ol><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ol><p><strong>开环控制和闭环控制</strong><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2740d71c5e1d6aac.webp"></p><p><strong>监测网络的拥塞</strong><br>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><div class="note note-primary">            <p>理解：</p>          </div><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-67852fc13fc0e263.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c7682fe29ebcb6fd.webp"></p><blockquote><p>发送窗口大小 &#x3D; min(接受方窗口大小，拥塞窗口大小)</p></blockquote><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul><li><p>目的：用来确定网络的负载能力或拥塞程度。</p></li><li><p>算法的思路：由小到大逐渐增大拥塞窗口数值。</p></li><li><p>两个变量：</p><ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值有2 种设置方法。窗口值逐渐增大。第一种是1 至 2 个最大报文段 （旧标准）；第二种是2 至 4 个最大报文段 （RFC 5681）</li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li><li><p>实现：</p><ul><li>起初拥塞窗口按指数增加，当达到慢开始门限后，为了避免出现拥塞，每经过一个传输伦次，cwnd++</li><li>如果出现超时重传，则重新回到慢开始<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f5db7ea25d8aca73.webp"></li></ul></li></ul><div class="note note-primary">            <p>慢开始是为了从小到大且尽快的达到门限，门限后则缓慢的扩大拥塞窗口来试探网络情况，两者一起使用以实现动态调整拥塞窗口。</p>          </div><div class="note note-warning">            <p>注意：这里是拥塞窗口的变化，而不是发送窗口的变化，发送窗口的大小还受限于接受端的接受窗口。</p>          </div><h3 id="快重传（fast-retrasmit）与快恢复（fast-recovery）"><a href="#快重传（fast-retrasmit）与快恢复（fast-recovery）" class="headerlink" title="快重传（fast retrasmit）与快恢复（fast recovery）"></a>快重传（<em>fast retrasmit</em>）与快恢复（<em>fast recovery</em>）</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-a57c7cc819aa4bae.webp"></p><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ab5a63efbd586eb8.webp"></p><div class="note note-primary">            <p>一般接受方对接受到的报文段的确定都是捎带的，和窗口控制报文一起发送给发送端，导致重传开启较慢。<br><strong>快重传</strong>：需要接受端尽快的回复接受到的报文信息，然后发送端实现快重出传（接受到连续3个重复的确认报文）</p><p>发送端发生重传时，直接进入慢开始，这对于仅丢失个别报文的传输的效率较大，而快重传刚好可以确定这类情况。<br><strong>快恢复</strong>：当发送快重传时不进入慢开始，而是调节ssthresh值和cwnd值为一半后直接开始执行拥塞避免算法。</p><p>快恢复要和快重传结合使用，快恢复的具体调整依赖于发送端具体的实现。</p>          </div><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-8f61b8eddb5b2624.webp"></p><h1 id="六、TCP超时重传时间的选择"><a href="#六、TCP超时重传时间的选择" class="headerlink" title="六、TCP超时重传时间的选择"></a>六、TCP超时重传时间的选择</h1><p>不必要的重传会导致网络负荷的增大，但重传推迟的太久也会导致传输效率的降低。因此需要合理的设置超时重传时间<em>RTO</em>，其应该略大于往返时间<em>RTT</em>，具体计算：</p><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-20d1cf6bb211fe7e.webp"></p><h2 id="RTO"><a href="#RTO" class="headerlink" title="RTO"></a>RTO</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-39ab62874e65b623.webp"></p><div class="note note-primary">            <p>RTT计算：越近的RTT样本权重越大。<br>RTO计算：在RTT的基础上加上了RTT的偏差。(相当于加上了RTTs与新样本的差异，β只是一个权重参数，RTT（D1） &#x3D; RTT（1）&#x2F;2只是数据的初始化）。</p>          </div><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-dbc63525eab966e1.webp"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c94fa8a3ad6b277f.webp"></p><h1 id="七、TCP可靠传输的实现"><a href="#七、TCP可靠传输的实现" class="headerlink" title="七、TCP可靠传输的实现"></a>七、TCP可靠传输的实现</h1><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-6d10ea76a1ea032b.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-92d975bc880db892.webp"><br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-35bff0a8cc5b0d71.webp"></p><div class="note note-primary">            <p>发送方接收到确认消息后，需要1.前移2.调整窗口大小。<br>调整窗口大小时，原则上窗口的前沿是不推荐后移的，所以最好是通过 后沿前移+前沿不动 来实现窗口缩小。</p>          </div><div class="note note-primary">            <p>接收方对数据的确认有累计确认和捎带确认：</p><ul><li>累计确认要求接收方不要过迟的发送确认。</li><li>捎带确认使用较少。</li></ul>          </div><h1 id="八、TCP的运输连接管理"><a href="#八、TCP的运输连接管理" class="headerlink" title="八、TCP的运输连接管理"></a>八、TCP的运输连接管理</h1><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e7d2329746de8e6a.webp"></p><h2 id="TCP连接建立（握手）"><a href="#TCP连接建立（握手）" class="headerlink" title="TCP连接建立（握手）"></a>TCP连接建立（握手）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-84c2b6dbb20379bd.webp"></p><div class="note note-primary">            <p><strong>双报文握手</strong>保证双方得知对方的存在，随后可以直接发送数据。<br><strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误，导致服务器资源浪费。</p>          </div><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-0a5773a600817c41.webp" alt="两报文握手"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e69d0e450b080e1f.webp" alt="服务器打开传输控制块"></li></ul><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。<br>之后，就准备接受TCP客户端进程的连接请求。<br>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求。<br>而TCP客户端在主动打开前也是要先创建传输控制块。</p></blockquote><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-3205fd7d7d75b62e.webp"></p><div class="note note-primary">            <p><strong>SYN</strong>，<strong>ACK</strong>是TCP报文头中的一个bit，其标识了当前TCP报文的属性：<br>SYN（同步标志位）表示请求同步，ACK（确认标识位）表示是对某报文的回复。<br><strong>seq</strong>，<strong>ack</strong>是TCP报文头中的两个字段，都占4个字节，其标识了端消息的id和确认收到的消息id+1。</p><p>TCP规定SYN&#x3D;1的报文段即使不携带数据，也要消耗掉一个序号。<br>普通的确认报文可以不消耗序号。</p>          </div><h2 id="TCP连接释放（挥手）"><a href="#TCP连接释放（挥手）" class="headerlink" title="TCP连接释放（挥手）"></a>TCP连接释放（挥手）</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-1c5e0c6357d039ed.webp"></p><ul><li>前两次握手是确认服务器接受到了释放连接的请求，此后服务器对剩余数据进行传输，客户端进入终止等待2状态。</li><li>后两次握手是确认客户端接受到了释放连接的命令，此后服务器关闭，客户端则继续等待2MSL，这是为了防止第四次握手丢失导致服务器资源浪费。若直接关闭：<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ef85470fe120f146.webp"></li><li>若服务器没有收到第四次握手，则会重传第三次握手，以确保收到第四次握手。</li></ul><div class="note note-warning">            <p>第二次握手和第三次握手的ack序号相同，说明这个消息是对同一个消息（第一次握手）的回应，分别表示服务器收到释放连接请求和服务器运行释放连接请求。</p>          </div><div class="note note-warning">            <p>可见握手和挥手，都需要客户端保证对服务器连接的最终确认以防止服务器的资源浪费。<br>在握手中体现在服务器之后接收到第三次握手确认在进入连接状态。<br>在挥手中体现在客户端会保持等待，服务器主动重传第三次握手以收到第四次握手。</p>          </div><div class="note note-primary">            <p><strong>FIN</strong>是TCP报文头中的一个bit，表示请求释放连接。在挥手中其会出现两次，一次是客户端主动请求释放连接，一次是服务器回复可以释放连接了。</p><p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>          </div><h2 id="TCP保活计时器"><a href="#TCP保活计时器" class="headerlink" title="TCP保活计时器"></a>TCP保活计时器</h2><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障，TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此，应当有措施使TCP服务器进程不要再白白等待下去<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2dc97e06fe1d82ed.webp"></p><h1 id="九、TCP报文段的首部格式"><a href="#九、TCP报文段的首部格式" class="headerlink" title="九、TCP报文段的首部格式"></a>九、TCP报文段的首部格式</h1><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-df9263a14e1da2c1.webp"></p><h2 id="固定首部"><a href="#固定首部" class="headerlink" title="固定首部"></a>固定首部</h2><p>源端口和目的端口<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-27e4bd51d5db2f8e.webp"><br>序号、确认号和确认标志位<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-fd0e64d8be3f598b.webp"><br>数据偏移、保留、窗口和校验和<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d3d4c61af68fdb6d.webp"><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针<br><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f09bdaba863c4ca3.webp"></p><h2 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h2><p><img src="/2022/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d1a8d3ca5ac7f39d.webp"></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第4章（网际层）</title>
    <link href="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li><li>为了实现这个任务，有以下问题：<ul><li>网络层提供可靠传输还是不可靠传输</li><li>网络层怎么寻址(IP地址做导航)</li><li>网络层路由选择(路由器根据路由表转发，为了记录路由需要人工配置或实现各种路由选择协议)</li></ul></li></ul><blockquote><p>网络层（网际层）,除了<strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><blockquote><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，因此在TCP&#x2F;IP协议中网络层常称为网际层。</p></blockquote><div class="note note-primary">            <ul><li>数据链路层能通过MAC地址与交换机实现数据的定向传输，但是对于庞大的因特网，这显然是不合理的，相比起MAC地址的无序序列，我们需要一个具有明显层级关系的地址（如湖北省武汉市洪山区）方便快速定位，统一管理，因此有了IP地址。</li><li>网络层需要实现数据在局域网和局域网之间的传递（不同于之前的局域网通过交换机互联，这样会扩大广播域，VLAN虽然能实现类似的功能，但依赖于用户设置，无法达到全网统一）。</li></ul>          </div><h1 id="二、网络层提供的服务"><a href="#二、网络层提供的服务" class="headerlink" title="二、网络层提供的服务"></a>二、网络层提供的服务</h1><p>网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”），实质就是<strong>在计算机通信中，可靠交付应当由网络还是端系统来负责</strong>？</p><ul><li>第一种观点是<strong>网络提供虚电路连接</strong>（一种使用<strong>面向连接</strong>的通信方式，通信之前先建立<strong>虚电路</strong>，保证所有网络资源，分组即可按顺序无差错的到达），由网络本身负责可靠交付。</li><li>另一种观点是<strong>网络只提供数据报服务</strong>，向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong>。</li></ul><blockquote><p>显然后者是我们现在使用的，其运行灵活，造价低，适应性强。</p><p><strong>区别</strong><br>终点地址：<br>1.仅在连接建立阶段使用，每个分组使用短的虚电路号<br>2.每个分组都有终点的完整地址</p><p>当结点出故障时：<br>1.所有通过出故障的结点的虚电路均不能工作<br>2.出故障的结点可能会丢失分组，一些路由可能会发生变化</p><p>端到端的差错处理和流量控制：<br>1.可以由网络负责，也可以由用户主机负责<br>2.由用户主机负责</p></blockquote><div class="note note-primary">            <p>当前网络层的服务实现是：<strong>尽最大努力交付</strong>。</p>          </div><h1 id="三、IPv4"><a href="#三、IPv4" class="headerlink" title="三、IPv4"></a>三、IPv4</h1><p><strong>IPv4地址</strong>是因特网（<em>Internet</em>）上每一个主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32bit（4个字节）的标识符。</p><div class="note note-warning">            <p>只有<strong>公网IP</strong>是全世界独一无二的，<strong>私网IP</strong>是在不同局域网中可以重复使用的：<br>RFC1918定义了私有IP的地址范围：<br>A:10.0.0.0 ~ 10.255.255.255即10.0.0.0&#x2F;8<br>B:172.16.0.0 ~ 172.31.255.255即172.16.0.0&#x2F;12<br>C:192.168.0.0 ~ 192.168.255.255 即192.168.0.0&#x2F;16</p>          </div><div class="note note-success">            <p><strong>私有IP是无法随意定义的</strong>，只有以上范围内的IP会被路由器视为内网IP，以这些IP为源IP的数据包只会在局域网内传递，不会在因特网上传递。</p><p>私有IP设备<strong>发送</strong>与<strong>接受</strong>外网数据包：<br>首先内网中的客户端将数据包传送给路由器，路由器解析数据包后发现，这个数据包是来自与私网、发送给外网的。例如某个数据包的源IP:192.168.1.2，当路由器检测到这个数据包的目标IP是外网IP的时候，路由器中会生成一个唯一端口号对应192.168.1.2，再生成一个随机端口号对应这个唯一端口号。然后路由器会将数据包的源IP改成公网IP，发送到互联网上。接收数据时，数据包会被发送到路由器的随机端口号上，这时和原来生成的映射表进行匹配，再把数据包传送到内网客户端，其实就是一个端口映射表。<br><a href="https://blog.csdn.net/weixin_39661353/article/details/110806482">路由器修改报文端口号</a></p>          </div><p>IPv4的编址方法经历了3个阶段：<br><strong>分类编址 -&gt; 划分子网 -&gt; 无分类编址</strong></p><h2 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h2><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-617a75508f564e07.webp"><br>其中有2个网络号无法分配，即A类地址：</p><ul><li><strong>最小网络号为0，保留不做指派</strong></li><li><strong>最大网络号为127，是本地回环测试地址，保留不做指派</strong></li></ul><p>有2类主机号无法分配：</p><ul><li>全0的主机号，其表示该网络的标识地址</li><li>全1的主机号，其表示该网络的广播地址</li></ul><div class="note note-primary">            <p>网络号，主机号都为0，即<code>0.0.0.0</code>，表示本网络上的本主机（见DHCP协议）</p>          </div><blockquote><ul><li><strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</li><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li><strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong></li></ul></blockquote><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>两级的IP地址会导致IP地址空间的利用率很低。<br>子网即从主机号借一部分作为子网号，从而将一个网络号分为多个子网。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5006c8be601f1a11.webp"><br>划分子网的工具即<strong>子网掩码</strong>。<br>其将<strong>两级的IP地址</strong>变成了<strong>三级的IP地址</strong>。</p><p><strong>默认子网掩码</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5e9d1b71bd598e62.webp"></p><p>IPv4地址与子网掩码相与即得到所在子网的网络地址。</p><blockquote><p>对于在因特网上传输的数据报，仍然是根据<strong>目的网络号</strong>net-id寻找下一跳路由器。到了该网络号的路由器时，路由器再根据<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</p></blockquote><div class="note note-primary">            <p><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。<br>这里所谈论的<strong>划分子网</strong>针对的仍然是因特网上的IP地址，其并没有造成IP地址重复（<code>相同的ip/不同的子网掩码</code>指的仍是同一个主机），只是单位内部对于可分配的主机号进行的一种再划分，即：</p><ul><li>子网掩码对于外网路由器没有作用。</li><li>内网路由器根据接受到的IP匹配对于的子网，能实现对该子网更精准的路由。<br>（最长前缀匹配）</li></ul>          </div><blockquote><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个记录，除了要记载目的网络地址外，还必须同时记载该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><div class="note note-primary">            <p>以上路由器行为是为了保证在传递IP数据报时，能够选择最符合的端口转发数据。todo？</p>          </div><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><strong>无分类域间路由选择 CIDR</strong> (<em>Classless Inter-Domain Routing</em>)。</p><ul><li>CIDR消除了A、B、C类地址和划分子网的概念。</li><li>CIDR能更有效的分配IPv4的地址空间。</li></ul><p><strong>特点</strong></p><ul><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li><li>IP 地址的形式为：<code>a.b.c.d/x</code>，其中地址的 <code>x</code> 最高比特构成了 IP 地址的<strong>网络部分（即网络前缀）</strong>，所以 <strong>CIDR 中 IP 地址由前缀和主机号构成</strong>，<code>x</code> 为前缀长度，<code>/x</code> 的记法也称为<strong>子网掩码</strong>。</li></ul><div class="note note-primary">            <p><strong>CIDR</strong>只是在网络实现层面消除了这些概念，并不代表A、B、C类地址和划分子网的协议行为不存在了。具体而言，总服务商分配到的公网IP地址基本仍为A、B、C类地址（如130.67.0.0&#x2F;16），不过服务商可以把这些地址再划分下去给子服务商(如130.67.0.0&#x2F;17和130.67.128.0&#x2F;17)使用，我们也不再把这样的关系称为总网、子网关系。</p><p>问题：130.67.0.0&#x2F;16 和130.67.0.0&#x2F;17还是同一个目标IP地址吗？<br>答：这个问题本身就是错误的。</p><ol><li><strong>IP地址仍然为一个全网唯一的IP地址</strong>，并没有后面的网络前缀的区分。</li><li>对于一个目标IP地址，<strong>不会也不可能在数据传递时携带网络前缀</strong>。</li><li>在数据的传输中，<strong>网络前缀只保存在路由器表中</strong>，用于记录与路由器相连接的网络的所在的网络号。</li></ol><p>问题：如果两个服务商，一个分到了<code>130.67.0.0/16</code>的公网IP，一个分到了<code>130.67.128.0/17</code>的公网IP，此时服务商1内部划分出子网<code>130.67.128.0/17</code>，其是否会与服务商2的IP在公网上重复？<br>答：不会。如上面所说，IP地址在分配时仍有等级之分，服务商一般只会分到<code>/8</code>，<code>/16</code>，<code>/24</code>这样的网络前缀，像<code>/17</code>这样的IP和网络前缀，本身就是由服务商1分发出来的，不可能由服务商2获得。</p>          </div><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p><strong>超网（路由聚合）技术是为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。</strong></p><p>即路由器发现其某个端口与多个具有相同前缀的网络对应，会将这些记录合并。</p><blockquote><p>举个例子，如果路由器1与路由器2连接，路由器2的各个端口连接了不同的网络（本质上是多个子网）。<br>经过路由器交换学习，路由器1会得知路由器2所在网络号和网络前缀，而路由器2的不同接口在不同的网络号中，因此路由器1学习到了路由器2的多个网络。（如<code>67.67.0.0/18</code>，<code>67.67.64/18</code>, <code>67.67.128.0/18</code>,<code>67.67.192.0/18</code>)<br>此时，路由器1发现虽然有多个网络，但他们都对应着同一个端口，并且具有相同前缀（<code>67.67.0.0/16</code>）。此时路由器1会将这些记录合并，这种行为叫做路由聚合，也叫构造超网。</p></blockquote><h3 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h3><p>最长匹配 是指存在多条目的网段相同的路由时，匹配掩码最长的那一条。因为掩码越长，表示的网段就越小，匹配也就越精确。</p><div class="note note-primary">            <p>条件：</p><ul><li>路由器1：外部路由器。</li><li>路由器2：连接多个网段（子网）路由器。</li><li>路由器3：连接路由器2的一个子网路由器。</li><li>网段3：路由器3所在的网络。</li><li>3个路由器两两相连。<br>对于划分子网的IPv4地址，同一网络号的不同子网的记录只保存在该网络的中转的路由器2中。对于路由器1，其只需要知道路由器2的总网络号即可，其子网的划分对路由器1是<strong>屏蔽的</strong>。</li></ul><p>但CIDR不再区分子网，路由器1会学习与之相连接的路由器2的所有网络号（IP和网络前缀）。这导致路由器2所在的子网对路由器1也是<strong>可见的</strong>，因此需要将这些网络号在本路由器的路由表中聚合起来，避免路由表内存浪费。</p><p>至于最长匹配原则，则可以当某个数据包要从路由器1要发往子网3。此时路由器1会优先匹配到最长的网段3，并将数据转发到路由器3。</p>          </div><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/routeUnion.png"></p><h2 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h2><ul><li>定长的子网掩码FLSM（<em>Fixed Length Subnet Mask</em>）</li><li>变长的子网掩码VLSM（<em>Variable Length Subnet Mask</em>）<blockquote><p>前者就是分类IP，后者就是无分类IP<br>定长的子网掩码只能划分出2^n个子网，而变长的子网掩码可以按需分配，减少对IP地址的浪费。</p></blockquote></li></ul><h1 id="四、IP数据包的发送和转发过程"><a href="#四、IP数据包的发送和转发过程" class="headerlink" title="四、IP数据包的发送和转发过程"></a>四、IP数据包的发送和转发过程</h1><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>,由默认网关帮忙转发</li><li>为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong>。（具体地，默认网关指的是与本机网络直接相连的路由器<strong>接口</strong>，即下图中的0。通俗的讲，默认网关就是本网络与外网的默认接口）</li></ul></blockquote><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0351946f5505b37a.webp"></p><div class="note note-primary">            <p>前提：</p><ul><li>本机IP ＆ 本机掩码 &#x3D; 本机网络</li><li>目的IP ＆ 目的掩码 &#x3D; 目的网络</li></ul><p>正向来看：<br>如果：目的网络 &#x3D;&#x3D; 本机网络（即目的掩码 &#x3D; 本机掩码）<br>那么：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络（目的网络）</p><p>反向来看：<br>条件：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络<br>问题：目的网络是否为本机网络呢？<br>答案：<strong>是</strong>。考虑这个问题的时候主要在想以下情形：<br>”如果目的网络（<code>190.68.16.128/25</code>）是本机网络（<code>190.68.16.0/24</code>）的子网，那么上面条件是成立的，但该子网和该网络并不能划等号。“<br>但实际上这个想法本质就是错误的，在<strong>CIDR和变长的子网掩码</strong>中：</p><ol><li>IP网络之间的关系已经没有了父子关系，</li><li>对于变长子网掩码，不同的子网之间的关系依然是并列的。也就是说，如果本机IP的网络会被划分成（<code>190.68.16.0/24</code>），就说明已经有一个网段包含了<code>190.68.16.xxx</code>的所有主机，<code>190.68.16.128/25</code>网络根本就不可能存在，即若有某主机IP为<code>190.68.16.129</code>，其子网掩码也一定是<code>/24</code>。</li></ol><p>以上证明了可以根据本机掩码和目的IP判断目的网络是否为本机网络，但如果不是本机网络，则不能直接判断目的网络的具体掩码长度，不过对于本机而言，只需要操心一个IP是由自己直接交付（本机网络）还是交给路由器（外网网络）处理即可。</p>          </div><h2 id="路由器行为"><a href="#路由器行为" class="headerlink" title="路由器行为"></a>路由器行为</h2><ol><li>检查IP数据报首部是否出错<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ol><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>静态路由配置指用户或网络管理员使用路由器的相关命令给路由<strong>人工配置路由表</strong>。</p><p><strong>默认路由</strong><br>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是<strong>优先级最低</strong>的。一般为0.0.0.0&#x2F;0(可以匹配所有地址)</p><p><strong>特定主机路由</strong><br>给路由器添加的针对某个主机的特定主机路由条目，可以指定其下一条目的。一般用于网络管理人员对网络的管理和测试。</p><div class="note note-primary">            <p>当多条路由可选时，使用最长匹配原则。</p>          </div><p><strong>静态路由配置</strong>其可能出现以下导致产生<strong>路由环路</strong>的错误。</p><ul><li><strong>配置错误</strong>（手动配置错误）</li><li><strong>聚合了不存在的网络</strong>（解决办法：黑洞路由）<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-caeddc52bde20f9c.webp"></li><li><strong>网络故障</strong>（解决方法：为故障网路添加黑洞路由，故障恢复后使该黑洞路由失效）<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d8107f8fc71dd1f4.webp"></li></ul><h2 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>动态路由选择</strong>相比<strong>静态路由选择</strong>能更好适应网络状态的变化，且适用于大规模网络。其路由器通过路由选择协议自动获取路由信息。</p><blockquote><p><strong>因特网采用分层次的路由选择协议</strong></p></blockquote><p><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器。自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-9e37d1229ec7836e.webp"></p><p><strong>路由选择协议</strong>：域间路由选择使用外部网关协议<strong>EGP</strong>这个类别的路由选择协议，域内路由选择使用内部网关协议<strong>IGP</strong>这个类别的路由选择协议。<strong>网关协议</strong>的名称可称为<strong>路由协议</strong>。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8729bdd2bd367edf.webp"></p><div class="note note-primary">            <p><strong>路由选择协议</strong>的本质是路由器之间交换信息、判断某网络是否可达并进行路径选择的规则。由于路由器之间交换信息需要进行广播行为，由于路由表容量有限和避免广播的泛滥，需要使用<strong>自治系统</strong>来隔离网络中的路由器，并保证<strong>同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</strong></p>          </div><h3 id="常见的路由选择协议"><a href="#常见的路由选择协议" class="headerlink" title="常见的路由选择协议"></a>常见的路由选择协议</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b1876963d6d9de0.webp"></p><h3 id="路由器基本结构和功能"><a href="#路由器基本结构和功能" class="headerlink" title="路由器基本结构和功能"></a>路由器基本结构和功能</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e6b69c1f176e24c5.webp"></p><p><strong>分组转发部分</strong><br>转发时需要注意的行为：</p><ul><li>若在转发表中找不到匹配条目则<strong>丢弃分组</strong></li><li>转发时会<strong>更新分组首部的某些字段</strong>，如分组生存时间</li><li>各端口都有缓冲区，每个端口一般都具有输入、输出功能</li></ul><p><strong>路由选择部分</strong><br>路由选择处理器根据所使用的路由选择协议周期性的与其他路由器进行路由信息交互来更新路由表。<br>如果路由器接受到的分组是路由器之间交换路由信息的<strong>路由报文</strong>，则会把这种分组送交给<strong>路由选择处理器</strong>进行处理。</p><p>路由选择处理器的行为：</p><ul><li>路由表一般只包含从目的网络到下一条的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表生成的</li><li>转发表的结构应当使查找过程最优化</li></ul><div class="note note-primary">            <p>路由表（RIB）和转发表（FIB）的联系和区别：</p><ul><li><p>联系<br>转发表是路由器使用一个特定的进程通过路由表中的信息和自身的网卡等信息综合得到的。转发表类似于交换机的地址信息表。</p></li><li><p>区别<br>首先，”转发”和”路由选择”是有区别的，”转发”时，路由器只需要把接受到的信息从合适的端口发送出去即可，只涉及到一个路由器。”路由选择”则是许多路由器协同工作的结果。<br>其次，路由表只存储三元素：目标，掩码，下一跳；而转发表存储更详细的信息：比如输出端口信息，某些MAC地址，比如标记信息等。</p></li></ul><p>这里的描述都屏蔽了MAC地址的问题，这里在汇总对比一下：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。<br>举例：<br>局域网：使用MAC表和ARP表即可实现局域网内主机通讯（使用交换机，虽然现在不会这么使用）<br>主机流程：目的IP地址 -&gt; 目的MAC地址 -&gt;端口<br>路由器流程同上。</li></ul><p>因特网：但不同网段之间的通讯，要涉及到网络路线选择问题。<br>主机流程：目的IP地址(非本网段) -&gt; 目的MAC地址（默认网关）-&gt;端口<br>路由器流程：目的IP地址 -&gt; 下一跳IP地址（路由选择） -&gt;MAC地址 -&gt; 端口</p>          </div><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由信息协议RIP(<em>Routing Information Protocol</em>)<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-850c29aaf1e744d6.webp"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>思路</strong></p><ul><li>距离最短为最好路由</li><li>相同距离则负载均衡</li><li><strong>只和相邻的路由器周期性的交换自己的路由表</strong></li></ul><h5 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6bf4e045a90846e0.webp"></p><p><strong>路由更新细节</strong><br>接受到更新报文后和自己的路由器对比：</p><ul><li>未知的Net，插入新信息。</li><li>相同Net和相同下一跳，<strong>覆盖距离信息</strong>。</li><li>相同Net和不同下一跳，距离不同则使用，若<strong>相等则都保留并负载均衡</strong>。</li></ul><h4 id="RIP存在的问题"><a href="#RIP存在的问题" class="headerlink" title="RIP存在的问题"></a>RIP存在的问题</h4><p>如果网络出现故障，由于远处的路由器获知这个消息慢，先发出了自己的更新报文，则可能造成路由器之间互相认为对方可以到达一个不可达的网络，形成<strong>网络环路</strong>。</p><p>解决方法<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-3a055002b79a9cda.webp"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><h4 id="RIP的优缺点"><a href="#RIP的优缺点" class="headerlink" title="RIP的优缺点"></a>RIP的优缺点</h4><blockquote><p>RIP 协议的优缺点<br>优点：</p><ol><li>实现简单，开销较小。<br>缺点：</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p>开放最短路径优先 OSPF (<em>Open Shortest Path First</em>)。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f5dc77f36b5b1047.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="OSPF五种分组类型"><a href="#OSPF五种分组类型" class="headerlink" title="OSPF五种分组类型"></a>OSPF五种分组类型</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a2a83ab2654e270f.webp"></p><h5 id="基本工作过程-1"><a href="#基本工作过程-1" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-339786779f0e1a82.webp"></p><p>部分细节：<br><strong>Hello分组</strong><br>建立并维护路由器关系的分组。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f9c642e76e871651.webp"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong><br>包含具体的路由信息，被封装在<strong>LSU分组</strong>中<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bbed8a0d31bf19c3.webp"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b8e10e2d82cfa6f.webp"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-4239eee0b6040f52.webp"></p><div class="note note-primary">            <p>总结，OSPF是一个路由器通过获取AS内所有路由器之间边信息，然后建立一个以自己为根节点的无环图的过程。<br>具体地，相邻路由器会通过Hello分组维护关系，并互相简单介绍自己已知的路由信息，然后各自通过路由信息请求、路由信息返回、路由信息确认等过程逐步获得整个AS内的路由信息，最后构建各自的路由表。</p>          </div><h4 id="OSPF存在的问题"><a href="#OSPF存在的问题" class="headerlink" title="OSPF存在的问题"></a>OSPF存在的问题</h4><h5 id="大量多播分组"><a href="#大量多播分组" class="headerlink" title="大量多播分组"></a>大量多播分组</h5><p>多点接入（较多路由器互联）时，会产生大量的多播分组，通讯量过大。<br><strong>解决方法</strong></p><ol><li><p>屏蔽部分路径，因此只与部分路由器进行数据交换。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6420e503df73b7ef.webp"><br>DR出现问题后使用BDR替换。</p></li><li><p>路由分区，<strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-725b3aab5aa350b1.webp"></p><blockquote><p>实现细节：</p><ul><li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域，每个区域都有一个32比特的区域标识符，主干区域的区域标识符必须为0，主干区域用于连通其他区域，其他区域的区域标识符不能为0且不相同。</li><li>每个区域一般不应包含路由器超过200个。</li><li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量。</li></ul></blockquote></li></ol><h4 id="OSPF的优缺点"><a href="#OSPF的优缺点" class="headerlink" title="OSPF的优缺点"></a>OSPF的优缺点</h4><div class="note note-primary">            <p>优点：</p><ul><li>从算法上避免了环路的产生。</li><li>基于链路状态，相比RIP考虑了更多对链路代价的影响因素。</li><li>不限制网络规模（没有最长距离限制）</li></ul><p>缺点：</p><ul><li>实现较复杂。</li><li>路由器需要获取AS内所有路由器信息，通信量大，可以通过<strong>指定路由器</strong>和<strong>划分区域</strong>的手段解决。</li></ul>          </div><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（<em>Border Gateway Protocol</em>） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><strong>为何需要BGP？</strong><br>AS之间没有统一度量，且需要一个网关去解决AS之间通讯时的相关策略问题（政治、经纪、安全等），因此需要一个外部网关协议。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5aae9c53795e17a7.webp"></p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-04fe6f98036db57c.webp"><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bc71c2ee5976ac53.webp"><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-b472dd1a51f30666.webp"></p><h5 id="BGP-4四种分组类型"><a href="#BGP-4四种分组类型" class="headerlink" title="BGP-4四种分组类型"></a>BGP-4四种分组类型</h5><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-67b837e6c27d5e9c.webp"></p><div class="note note-primary">            <p>总结，BGP协议要求每个AS有一个发言人，发言人之间建立TCP连接建立会话，交换路由信息。类似于OSPF协议，发言人也会构造一个无环路的AS连通图。<br>注意，<strong>BGP不保证最好路由，只选择较好路由</strong>。</p>          </div><h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-40cf22cbd65e9ed8.webp"></p><h1 id="五、IPv4数据包格式"><a href="#五、IPv4数据包格式" class="headerlink" title="五、IPv4数据包格式"></a>五、IPv4数据包格式</h1><h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><blockquote><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li></ul></blockquote><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-73800cce52c3a91e.webp"></p><h3 id="固定部分"><a href="#固定部分" class="headerlink" title="固定部分"></a>固定部分</h3><p><strong>基本信息</strong><br>主要记录一些版本，服务约定，和后续数据长度。</p><ul><li>版本：占4比特，目前最广泛的是4（IPv4）</li><li>首部长度：占4比特，该字段的取单位为<strong>4个字节</strong>（即上图的一行）。<ul><li>最小十进制取值为5，即20字节固定部分</li><li>最大十进制取值为15，即20字节固定部分和40字节可变部分</li></ul></li><li>区分服务：占8比特，需要区分服务（不同等级的服务质量）时才起作用，一般不适用该字段。</li><li>总长度：占16比特，表示<strong>单位为字节</strong>的IP数据报总长度（包括首部长度）。最大值为65535，即2^16-1</li></ul><p><strong>分片信息</strong><br>主要用于IP数据报分片<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a014cde6b0ff9691.webp"></p><ul><li>标识：占16比特，同一个IP数据包的分片应该有同一个标识，类似IP</li><li>标志：占3比特：<ul><li>DF位：1个比特，1表示不允许分片；0表示允许分片。</li><li>MF位：1个比特，1表示不是最后一个分片，0表示是最后一个分片。</li><li>保留位：1个比特。</li></ul></li><li>片偏移：占13比特，表示分片数据包的“数据载荷部分”相比原数据报中的“数据载荷部分”偏移了多少。（<strong>单位为8字节</strong>，注意，由于这里的偏移量比特位小于总长比特位，为了完成表达必须使用更大的单位。）<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5d538557f988dc41.webp"></li></ul><p><strong>解析信息</strong></p><ul><li>生存时间TTL：占8比特，以“跳数”为单位，每次路由器转发该IP数据包，TTL-1，若为0则丢弃。</li><li>协议：占8比特，指明IPv4数据包的数据部分向上交付给什么协议。<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-94a3b7c0b1f01488.webp"></li><li>首部检验和：占16比特，检测首部在传输过程中是否出现差错。比CRC检验码简单，被称为因特网检验和。（由于TTL、片偏移、标志等可能发生变化，每次路由器转发时都要重新计算该值，耗时太大，在IPv6中已经不再计算首部校验和）</li></ul><p><strong>地址信息</strong><br>目的IP和源IP地址：各占32比特。</p><h3 id="可变部分"><a href="#可变部分" class="headerlink" title="可变部分"></a>可变部分</h3><ul><li>可选字段：长度从1到40字节不等</li><li>填充字段：确保<strong>首部长度为4字节</strong>（呼应首部长度的单位是4个字节）的整数倍，使用全0填充。</li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h3><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><div class="note note-primary">            <p>简而言之，需要一个与路由器之间的协议来<strong>监测数据的转发情况</strong>。</p>          </div><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8739d970a0300acc.webp"></p><blockquote><p><strong>ICMP报文会被封装到IP数据报中，但其不是高层协议，而是IP层的特殊协议（起控制作用，所以也叫网际控制报文协议ICMP）。</strong></p></blockquote><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6a02675fccdc2958.webp"></p><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p><strong>终点不可达</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-855edabd9c1e6298.webp"><br><strong>源点抑制</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e7f27ef6c93c9621.webp"><br><strong>时间超过</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-49d82185c88813fe.webp"><br><strong>参数问题</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e2457fe1291c9bca.webp"><br><strong>改变路由（重定向）</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0ef50227f921ca79.webp"></p><p><strong>另外，不应发送ICMP差错报告报文情况</strong><br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a0c3a21bb04ede42.webp"></p><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（<em>Packet InterNet Groper</em>）</h4><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-75d7bc12ca942415.webp"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（<em>traceroute</em>）</h4><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-185af899d5e5a922.webp"><br>实现原理：<br>使用从1开始递增的TTL发送多个报文，报文在路由器超时时会返回给源主机ICMP差错报告，从而得到各跳的信息。</p><h1 id="六、虚拟专用网VPN与网络地址转换NAT"><a href="#六、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="六、虚拟专用网VPN与网络地址转换NAT"></a>六、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（<em>Virtual Private Network</em>）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>虚拟专用网络</strong>VPN的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><div class="note note-primary">            <p>顾名思义，指一种利用公网实现专用网访问的技术。</p><p>简单的说就是两个专用网络之间通过公网IP进行加密通讯。VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>          </div><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ad9e5dcca8c0a1c9.webp"></p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6731dbc8b1ee1abc.webp"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（<em>Network Address Translation</em>）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>目的：大量的办公室网络和家庭网络导致IP地址仍然不够，需要实现IP复用。NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p>专有NAT软件的路由器叫做NAT路由器，其有至少一个公网IP地址。</p><p>以上只解决了发送信息的问题，为了实现接受消息后的对内网用户的分发需要使用NAPT技术，具体见以下实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-05d3e1e3fd4b1998.webp"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>外网无法直接访问内网<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d2fd109d060e4853.webp"></li><li>NAT对内网主机提供了一定的安全保护<br><img src="/2022/12/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ff43ea52e61da271.webp"></li></ul>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第3章（数据链路层）</title>
    <link href="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>物理层已经保证了数据在物理层面上的传输功能，但无法避免传输中发生的错误。数据链路层作为网络层、物理层之间的桥梁，<strong>主要的职责则是保证数据传输过程的差错控制和可靠传输</strong>，即识别、纠正传输中发生的错误。</p><p>网络中的主机、路由器、交换机等都必须实现数据链路层。</p><p>术语：</p><ul><li><strong>链路</strong>（<em>Link</em>）表示一段没有交换节点<strong>物理</strong>线路</li><li><strong>数据链路</strong>（<em>Data Link</em>）表示具有通讯协议的软硬件实现的<strong>链路</strong>。</li></ul><div class="note note-primary">            <p>数据链路层的协议是多样的，两个主机之间的数据传输，可能会经过多个不同协议数据链路，他们只需要保证实现数据链路层的功能和对网络层的服务相同即可。</p>          </div><p>使用的信道类型分类：</p><ul><li>点对点信道</li><li>广播信道</li></ul><blockquote><p><strong>局域网属于数据链路层</strong><br>局域网虽然也是个互联网，但我们不将其放在网络层考虑，因为网络层的主要职责是将分组从一个网络通过路由器发送到另一个网络。而局域网的功能，使用交换机即可实现。<br>PS：路由器也可以称为三级交换机，我们平时说的交换机就是二级交换机。</p></blockquote><h2 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong><br><strong>封装成帧</strong>：将数据加上帧头和帧尾，用于<strong>帧定界</strong><br><strong>差错控制</strong>：识别传输中的错误。<br><strong>可靠传输</strong>：识别错误后确保重传。</p><blockquote><p>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决，如帧识别（确认是发给自己的帧）、数据碰撞问题（共享信道的问题）。下面我们只讲PPP的例子。</p></blockquote><blockquote><p>目前，在有线（局域网）领域使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>已经取代了<del>共享式局域网</del><br>而在无线局域网中仍然使用的是共享信道技术</p></blockquote><h1 id="二、主要职责"><a href="#二、主要职责" class="headerlink" title="二、主要职责"></a>二、主要职责</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-bf6fe42eeea3f376.webp"><br>封装成帧的目的是识别帧分界，不同数据链路层协议对此的实现是不同的：</p><ul><li>PPP，帧头和帧尾有1字节的标识符</li><li>EtherNet的V2的MAC帧，使用一个前导码，例如：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f1441c531b4d740e.webp"></li></ul><blockquote><p>为了实现定界，需要一个开始和结尾符，以太网规定开始符为前导码，结尾符的功能通过保持帧的间距（以太网还规定了帧间间隔为96比特时间）实现（说明PPP的帧是连续的？也合理，点对点连着传）</p><p>前导码包括前同步码和帧开始定界符</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧（这里是从右往左看）</li></ul></blockquote><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，因此我们要避免上层数据中也出现帧定界符导致的解析混淆。</p><p><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (<em>byte stuffing</em>) 或<strong>字符填充</strong> (<em>character stuffing</em>)，面向比特的物理链路使用比特填充的方法实现透明传输。</p><p>具体的:</p><ul><li>发送端对于上层交付数据中出现的与定界符相同的字符，在其前插入转义字符“ESC”（十六进制编码是1B），若上层数据本身有该转义字符，则再其前插入一个转义字符。</li><li>接受端将内容中的转义字符剔除即可。</li></ul><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-9d3f61fdd96b7dee.webp"></p><p>最大传送单元MTU 规定了帧的<strong>数据部分</strong>的长度上限。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><strong>比特差错</strong>：1变0，0变1<br><strong>误码率BER</strong>(<em>Bit Error Rate</em>)：错误bit占总bit的比率。</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>使用1位bit来标记 数据中“1”个数的奇偶性，只要出现两个相同类型误码就会漏检。</p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(<em>Cyclic Redundancy Check</em>)</h3><p>约定好一个生成多项式G(x)，其实就是一段bit串，如：10111<br>将这个bit串作为除数，原数据作为被除数，得到余数，这个数称为<strong>检错码</strong>，也称为<strong>帧校验序列 FCS</strong></p><blockquote><p>检错码只有检查错误的能力，<strong>不知道错误发送的位置</strong><br><strong>纠错码</strong>可以进行前向纠错，但成本高，使用少<br>CRC非常易于硬件实现，被<strong>广泛应用于数据链路层</strong><br>检查出错误后，是丢弃还是重传，往往取决于数据链路层向上层提供的是<strong>可靠传输服务</strong>还是<strong>不可靠传输服务</strong>。</p></blockquote><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><strong>比特差错</strong></p><ul><li>对于可靠传输要求实现重传，对于不可靠传输，交给上层协议处理。</li><li><strong>一般而言</strong>，有限链路不要求可靠，无线链路要求可靠（误码率高）。</li></ul><p><strong>分组丢失、分组失序、分组重复</strong><br>一般不发生在数据链路层，而是发送在上层。</p><div class="note note-primary">            <p>理解：在单条数据链路上，数据一般不会丢失。失序、重复，这些问题往往发生在网络层。</p>          </div><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/Pic0.png"></p><p>为了解决以上错误，有以下三种可靠协议，这三种协议更多体现的是一种事件确认思想，因此可以应用到各层的协议中。</p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><h4 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>发送端发送数据DATA0后，等待接受方返回一个确认信息ACK0后，再发送下一条数据DATA1。</li><li>为了防止数据的丢失、错误，需要设置<strong>重传时间</strong></li><li>为了防止数据重传造成的重复发送、接受，需要设置一个<strong>Bit位标识数据</strong>区别</li></ul><div class="note note-primary">            <p>这部分的各种特殊情况比较复杂，我们按照事件的发生进行梳理。<br>在数据传输过程中有三个基本问题需要解决：<br><strong>数据丢失</strong>（没传到）、<strong>数据错误</strong>（传错了）、<strong>数据延迟</strong>（传慢了）。</p><p>为了解决<strong>数据丢失</strong>和<strong>数据错误</strong>的问题，发送端需要重发数据，所以设置了一个超时时间，超过时间就会进行<strong>重传</strong>。（实际上对于<strong>数据错误</strong>，接受端也可以主动回复NAK提醒发送端尽快重发，但有线网内这种情况较少，一般只在误码率较高的时候进行）。</p><p>对于<strong>数据延迟</strong>的问题，理想情况其实是等待数据达到，即不需要我们解决。但实际上无法确定是数据是延迟还是丢失，也会导致触发重传，这里就衍生出了一个新问题，即<strong>发送端和接受端都可能接受到两条甚至更多相同的数据</strong>（因为接受端对每条信息都会回复确认，所以发送端也会收到两条确认ACK信息），显然我们要对后面的数据进行忽略，因此需要一个数据标识符做区分，在这里体现为一个bit。</p><p>至此，我们解决了3个基本问题和1个衍生问题。</p>          </div><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-8dbdfdbac8087fd21.webp"></p><h5 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3b4b0d81e5dd78eb.webp"></li></ul><blockquote><p>停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><div class="note note-warning">            <p>为了解决RTT过长的问题，有以下两种协议。</p>          </div><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cc9d42f63bd259cc.webp"></p><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-2a7141766ab1aa80.webp"></p><ul><li>发送方可以一次性<strong>连续发送</strong>多个数据分组，接受方每接受到一个数据就移动一次窗口，且不需要对每个分组逐个确认，一般设置在接受到若干个数据分组，对接受到的最后一个数据分组进行一次<strong>累计确认</strong>即可。</li><li>传递发生错误时，例如5号分组出现错误则丢弃，此后接收方每接受到一个不是5号的信息都会<strong>主动回复</strong>一个ACK4，请求发送端尽快发送DATA5（发送端在收到多少个ACK4后会提前发送DATA5，由具体实现决定，实际上就算收不到，也会超时重发。）<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-215e8704b22ef7f2.webp"></li><li><strong>使用n位bit标识分组</strong>，则编号范围为0~2^n-1，发送窗口大小必须小于2^n-1，否则接收方会出现误判。</li></ul><div class="note note-primary">            <p>相对SW协议，GBN协议为了提高信道利用率，采用了<strong>连续发送与累计确认、主动回复</strong>等方式，在具体的实现上出现了新的问题和解决：</p><ul><li>针对<strong>连续发送与累计确认</strong>，为了识别正确接受顺序，需要使用多bit位标识数据，bit的位数也限制了发送窗口大小。</li><li>针对<strong>主动回复</strong>，客户端之前接受到错误信息和重复分组时会直接舍弃。现在客户端只舍弃错误信息，也因此会接收到许多错误分组信息（不是当前需要的分组），对这些都要进行重复确认ACK。</li></ul><p>当然，超时重传的性质依然存在，这是避免信息丢失的必要手段，主动回复只是一种加速，不是一种保证。</p>          </div><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><h5 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li><strong>扩大接受窗口的尺寸</strong>，接收方可以不用按照顺序接受分组，避免浪费。发送方也可以只重传错误分组。</li><li>由于不再按顺序接受分组，所以需要<strong>逐条确认</strong>，累计确认不再有效。发送，接受方都需要逐个确认。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=27&vd_source=7324e975d0c1b4b4719d1194e3649ff8">视频参考</a></li></ul><div class="note note-primary">            <p>相当于对分组进行批量的发送接受，只重传错误分组，重传机制仍是超时判断。接收方根据接受到的分组DATA滑动窗口，发送方根据接受到的ACK滑动窗口。</p>          </div><h1 id="三、点对点协议PPP"><a href="#三、点对点协议PPP" class="headerlink" title="三、点对点协议PPP"></a>三、点对点协议PPP</h1><ul><li>点对点协议PPP（<em>Point-to-Point Protocol</em>）是目前使用最广泛的点对点数据链路层协议。</li></ul><div class="note note-primary">            <p>端对端是P2P(Peer-to-Peer)。</p>          </div><h2 id="职责实现"><a href="#职责实现" class="headerlink" title="职责实现"></a>职责实现</h2><p>上文介绍了数据链路层的主要职责和方法，具体协议则需要对各功能做具体实现。</p><h3 id="封装成帧-1"><a href="#封装成帧-1" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>使用了帧头帧尾和对应的转义字符。<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-b384615e861000f3.webp"></p><h4 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h4><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d40da4575c590f5c.webp"></li><li>面向比特的同步链路：比特填充法（插入“比特0”）<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6290c73d8957ee8d.webp"></li></ul><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>使用FCS计算帧部分，立即丢弃错误帧。<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-501e6b9dd2afcee3.webp"></p><h1 id="四、媒体接入控制——广播信道"><a href="#四、媒体接入控制——广播信道" class="headerlink" title="四、媒体接入控制——广播信道"></a>四、媒体接入控制——广播信道</h1><blockquote><p><em>Medium Access Control</em>翻译成媒体接入控制，有些翻译成<strong>介质访问控制</strong>，是一种主要用于局域网的数据链路层的广播通信方式。</p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>网络拓扑结构：星形、总线、环形</p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><div class="note note-primary">            <p>PPP协议是目前使用最广泛的点对点数据链路层协议，但数据链路层需要解决局域网问题，局域网常常会有共享信道，广播等需求。对于不同类型的局域网，这些需求的解决方式也不尽相同，因此又将数据链路层分为两层，一层解决类似PPP（PPP基本没有第二层问题，其独占信道）的问题，另一层解决传输媒体（主要是信道冲突）上的问题。</p>          </div><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3d6792f6b442b459.webp"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><div class="note note-primary">            <p>PPP协议对应的交换机技术可以很好的解决共享信道问题，但是无线网络仍需要共享媒体。信道复用问题之前在物理层也提过，但由于物理层主要只解决01传递的问题，这种与传媒相关的问题则交给了数据链路层的MAC子层解决。</p>          </div><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>频分复用FDM</strong> (<em>Frequency Division Multiplexing</em>)</p><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。<br><strong>时分复用TDM</strong> (<em>Time Division Multiplexing</em>)</li><li><strong>时分复用</strong>则是将时间划分为一段段<strong>等长</strong>的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。  </li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong><br><strong>波分复用 WDM</strong>(<em>Wavelength Division Multiplexing</em>)</li><li>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。<br><strong>码分复用 CDM</strong> (<em>Code Division Multiplexing</em>)<blockquote><p>复用：信道分为多个子信道，用户使用子信道。<br>多址：动态分配信道给用户，用户暂时占用信道。<br>因此码分复用更多的被称为码分多址。</p></blockquote></li></ul><p>具体实现：使用多个bit位表示1个bit位，解释如下：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-91ed6f416ae8fad6.webp"><br>这样，接受方通过向量计算即可从叠加信号中解析中指定发送方发出的信息。</p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>总线局域网</strong>使用CSMA&#x2F;CD（<em>Carrier Sense Multiple Access&#x2F;Collision Detection</em>）协议，即载波监听多址接入&#x2F;碰撞检测。<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-00eb7fba113030d2.webp"><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-574d77a51611a634.webp"></p><div class="note note-primary">            <p>CD的硬件实现：判断总线电压摆动值变大超过门限。<br>为什么需要CD：CS具有传播延迟。</p>          </div><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1.准备发送-&gt;2.载波监听（信道忙则回到1）-&gt;3.发送并碰撞检测（碰撞则停止并等待一段时间回到1）-&gt;4.发送直到完毕</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a77d88a950995527.webp"></p><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-423fe21ffdbacb81.webp"></p><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-fa63a8f164fb9191.webp"></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-93f832e4b0a569ae.webp"></p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dc35877bb4bead1a.webp"></p><h4 id="帧接受过程"><a href="#帧接受过程" class="headerlink" title="帧接受过程"></a>帧接受过程</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cf2d95546ecf2664.webp"></p><div class="note note-primary">            <p>以上特性、限制都是为了在保证<strong>数据不碰撞</strong>的情况下保证<strong>合理性</strong>。<br><strong>保证不碰撞</strong>：<strong>争用期</strong>，<strong>最小帧长</strong>都是为了保证能检测信道是否有碰撞。<br><strong>合理性</strong>：<strong>最大帧长</strong>，单帧不能过长占用信道，<strong>截断二进制指数退避算法</strong>，灵活延迟避让时间，防止多次重传。</p>          </div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。<br><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong><br><strong>主要的无线网标准：802.11标准</strong><br>为什么无线局域网要使用CSMA&#x2F;CA协议：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dd01f296832d017a.webp"></p><div class="note note-primary">            <p>分布式协调功能DCF是各站点争用的方式。<br>点协调功能PCF则有一个中心站做协调，但使用较少。</p>          </div><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6c9fe4ae6927eb02.webp"><br>相比载波监听，有信道空闲持续时间限制，其控制了帧的发送间隔。</p><blockquote><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul></blockquote><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a756ebbd569e600a.webp"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><ul><li>防止多个站点同时发送数据而产生碰撞</li></ul></blockquote><p><strong>使用退避算法的时机</strong><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f0d70f0b26645fb4.webp"></p><p><strong>CSMA&#x2F;CA协议的退避算法</strong><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-1de197cb6f859f3c.webp"></p><p>示例：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-12262e66fc986d52.webp"></p><div class="note note-primary">            <p><strong>碰撞检测CD</strong>的思想类似于<strong>乐观锁</strong>，即先发送，发送后碰撞则进行退避处理。<br><strong>碰撞避免CA</strong>的思想类似于<strong>悲观锁</strong>，需要尽可能的保证信道通畅（通过退避的方式）然后再发送。<br>载波监听则是一种判断是否有锁的工具。</p><p>在CD中，如果当前信道空闲则直接发送信号，失败后则停止发送并等待，随后尝试重新发送。<br>在CA中，如果当前信道空闲，<strong>首先要等待一个DIFS时间</strong>，等待<strong>优先级</strong>更高的站点先尝试获取信道，这个时间之后，<strong>再根据信道的状况判断是否需要进行退避。</strong></p><ul><li><strong>DIFS时间是DCF模式（分布式协调功能）下的退避时间的基本单位。</strong></li><li><strong>默认的DIFS间隔时间并不在退避算法中</strong>。其是整个共享信道的处理完一个帧之后的间隙时间，各个站点以通过信道的这个间隙时间来判断信道进入了空闲状态（空闲了一个DIFS时间），然后解冻倒计时，进行<strong>优先级</strong>争夺。</li></ul>          </div><h4 id="信道预约和虚拟载波监听"><a href="#信道预约和虚拟载波监听" class="headerlink" title="信道预约和虚拟载波监听"></a>信道预约和虚拟载波监听</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-98353d62c0ef033f.webp"><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ac35b15f5f22bf7d.webp"></p><div class="note note-primary">            <p>以上为可选功能，通过向目的站发送“要发送数据帧”的请求（<strong>信道预约</strong>），目的站同意这个请求后发出“允许发送数据帧”的广播，此时其他站点就不能使用该信道了。由于RTS、CTS都携带了下次传递的大数据帧信息，因此其他站点知道本次信道会被占用的时间，实现了<strong>虚拟载波</strong>。<br>此时，如果其他站只能监听到目的站信息，监听不到源站信息，其也可以收到CTS从而避免在这个时间段内发送信息，减少了隐蔽站的问题。</p>          </div><h1 id="五、MAC地址、IP地址、ARP地址"><a href="#五、MAC地址、IP地址、ARP地址" class="headerlink" title="五、MAC地址、IP地址、ARP地址"></a>五、MAC地址、IP地址、ARP地址</h1><p>三者的关系：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ede2c92a0c809e6c.webp"></p><h2 id="MAC-Media-Access-Control-地址"><a href="#MAC-Media-Access-Control-地址" class="headerlink" title="MAC(Media Access Control)地址"></a>MAC(<em>Media Access Control</em>)地址</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><div class="note note-primary">            <p>注意：MAC地址的主要作用标记目的物理地址和源物理地址，在<strong>广播信道</strong>中，所有站点都会接受到MAC帧（也可以由交换机进行调度），然后根据目的物理地址是自身而决定是否舍弃该帧，但对于<strong>点对点的信道（不是协议）</strong> 则不需要MAC帧。</p>          </div><blockquote><ul><li><strong>MAC地址又称为硬件地址或物理地址</strong>。但其属于数据链路层而不是物理层。</li><li>MAC地址是对网络上各接口的唯一标识。</li></ul></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-70ee74506eca1df4.webp"></p><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。<br>无效MAC帧：</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；<br>（防止bit丢失）</li><li>用收到的帧检验序列 FCS 查出有差错；<br>（防止bit错误）</li><li>数据字段的长度不在 46 ~ 1500 字节之间。<br> (防止bit增加)<br>以太网检测到无效MAC帧直接丢弃。</li></ul><p>MAC帧发送顺序</p><ul><li>从第一字节发到第六字节</li><li>每字节从b0发到b7</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>单播（单选）：根据站点根据目标地址与自己是否相符决定是否舍弃。</li><li>广播（全选）：<strong>广播MAC地址为全F</strong>，所有站点都接受该帧</li><li>多播（多选）：只发送给指定的若干目的站点。<strong>多播MAC帧的目的地址的第一个bit为1</strong>，即第一个字节的b0位为1。其他站点是否接受则根据自身多播组列表设置。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴。</p><ul><li>对于局域网而言MAC地址即可区分设备（但现在实际上还是会使用IP地址而不是MAC地址）。</li><li>对于因特网而言MAC地址无法区分一个网络，需要使用IP地址加MAC地址。</li><li>例子：<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-77c204bc8181b3ed.webp"></li></ul><div class="note note-primary">            <p>参考现实中根据地图导航。<br><strong>IP地址</strong>用来标记起点和终点，从起点到终点需要经过很多交通工具。<br><strong>MAC地址</strong>根据目的IP地址选择当前交通应该在哪站下车然后换乘。<br>这个根据IP地址选择下车站的方法就是<strong>ARP协议</strong></p>          </div><h2 id="ARP协议（地址解析协议Address）"><a href="#ARP协议（地址解析协议Address）" class="headerlink" title="ARP协议（地址解析协议Address）"></a>ARP协议（地址解析协议Address）</h2><p>主机都有一个ARP高速缓存表，其中记录了IP地址和MAC地址的映射。</p><ul><li>如果表中记录了IP地址对应的MAC地址，则可以直接填写目的MAC地址发送MAC帧。</li><li>如果不知道，则发送<strong>ARP请求报文</strong>（广播）。目的IP地址的主机接受到该请求后会给源主机回复自己的MAC地址。</li></ul><p><strong>ARP高速缓存表</strong><br>有动态记录和静态记录。</p><ul><li>动态记录为自动获取，有持续时间、过期作废（默认两分钟）</li><li>静态记录为手工设置，始终保存（实际上依赖于操作系统的实现）。</li></ul><blockquote><p>ARP是逐段链路进行的。即主机只记录和自己直接连接主机的MAC地址，跨网络的地址则不管。</p></blockquote><div class="note note-primary">            <p>这里的ARP的作用主要是让机器通过广播形式学习和自己直连的设备的IP-MAC映射关系，<strong>方便其填入MAC帧的目的地址</strong>，并不能告知他应该如何把数据准确的发送到哪个主机。</p><p>ARP没有安全验证机制，可能<strong>存在ARP欺骗（攻击）问题</strong>。</p><p>ARP表中记录<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>          </div><h1 id="六、集线器和交换机"><a href="#六、集线器和交换机" class="headerlink" title="六、集线器和交换机"></a>六、集线器和交换机</h1><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>在总线型网络中，所有站点共享一个信道。但总线的拓扑结构在<strong>物理层</strong>实现很不方便，所以可以使用集线器作为中点，网络结构则变成了<strong>星型结构</strong>。</li><li>但实际上其在以太网上仍是一个<strong>总线型网络</strong>。集线器也只工作在物理层，并没有网络管理作用。</li><li>集线器是也可以看做多口<strong>中继器</strong>，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>扩展网络（<strong>扩大广播域</strong>），两个集线器直接连接即构成了更大的总线网络。但<strong>碰撞域</strong>却增大了。</p><blockquote><p><strong>碰撞域</strong>（<em>collision domain</em>）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p></blockquote><div class="note note-primary">            <p>集线器工作在物理层，而下文中的交换机工作在数据链路层。</p>          </div><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是网桥的替代品，是一个多接口的网桥。<br><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃（<strong>具有管理作用</strong>）。<br><strong>交换机</strong></li><li>1990 年问世的交换式集线器 (<em>switching hub</em>) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (<em>switch</em>) 或<strong>第二层交换机</strong> (<em>L2 switch</em>)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul><p>相对于集线器，其可以进行ARP自学习，并将数据帧定向转发。</p><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度</li><li>不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d5c429a2f92149ff.webp"></p><p><strong>扩大广播域</strong>的同时，<strong>隔离碰撞域</strong></p><blockquote><p><strong>广播域</strong>（<em>broadcast domain</em>）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。注意要与前面的碰撞域做区分。</p></blockquote><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-25db1be3ca96bc2f.webp"></p><h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>以太网交换机通过<strong>自学习算法</strong>建立<strong>帧交换表</strong></p><h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><ul><li>交换机接受到一个数据帧后就会记录这个帧的<strong>源地址</strong>和对应的交换机<strong>端口</strong>（没有则插入，有则更新）</li></ul><h4 id="转发行为"><a href="#转发行为" class="headerlink" title="转发行为"></a>转发行为</h4><ul><li>交换接的帧交换表中如果有该帧<strong>目标地址</strong>对应的端口，则直接将消息转发到该端口，否则发送<strong>广播</strong>（但不对源地址发送）。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每条记录都有有效时间，有效时间到期后删除。（主机可能换网卡，交换机可能改接另一台主机）</li></ul><div class="note note-primary">            <p>注意本处的自学习和前面提到的ARP的异同：<br>异：</p><ul><li>ARP记录的是IP和MAC地址之间的映射关系，记录在ARP高速缓存表中。交换机的自学习记录的是MAC地址与自己的端口的关系，记录在帧交换表中。</li><li>ARP高速缓存表主要用于根据上层的目的IP地址填入目的MAC地址。交换机帧纪录表则用于根据目的MAC地址选择往哪个端口发送。</li><li>实现在不同层面，ARP的实现在逻辑上，依赖于非目标主机会自行舍弃帧；交换机实现在物理上，依赖于只发送给目标机。可以认为交换机是对ARP的总线结构下的一种信道层面优化，减少了各个客户端识别帧的负担并解决碰撞问题。<br>同：</li><li>有已知记录时都会直接发送，没有时都会进行广播学习。</li></ul>          </div><h1 id="七、生成树协议STP"><a href="#七、生成树协议STP" class="headerlink" title="七、生成树协议STP"></a>七、生成树协议STP</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>想要提高以太网的<strong>可靠性</strong>，可以尽可能多的添加交换机之间的连线（<strong>冗余链路</strong>）。这样两个交换机之间就不会因为一条链路出现故障而无法通讯。但这样会造成重复广播等问题，因此需要避免<strong>逻辑上的环路</strong>（保留物理上的环路以备用）。</p><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a65d811129786ec6.webp"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</p></blockquote><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (<em>Spanning Tree Protocol</em>)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><h1 id="八、虚拟局域网VLAN"><a href="#八、虚拟局域网VLAN" class="headerlink" title="八、虚拟局域网VLAN"></a>八、虚拟局域网VLAN</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>集线器和交换机扩大了广播域，但是广播域过于又会造成广播风暴，我们希望能够实现局部广播功能。</p><p><strong>广播风暴</strong><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a2a78b40ae5307db.webp"></p><h2 id="分割局域网的方法"><a href="#分割局域网的方法" class="headerlink" title="分割局域网的方法"></a>分割局域网的方法</h2><ol><li>使用路由器</li><li>VLAN(<em>Virtual LAN</em>)虚拟局域网</li></ol><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>： <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li></ul></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>本质上是要求使用<strong>交换机</strong>实现逻辑上将一个局域网划分成几个虚拟局域网（将一个交换机分成多个交换机），即判断一条广播消息属于哪一个组，因此这种MAC帧需要多一个明确的标识符以供交换机判断。</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧<br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-5d3549cc02f9a3b4.webp"><br><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6af352f81b800a98.webp"></li></ul><h3 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h3><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-44a2e259c33ecfd3.webp"></p><h4 id="Truck端口"><a href="#Truck端口" class="headerlink" title="Truck端口"></a>Truck端口</h4><p><img src="/2022/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a93996aae716c6aa.webp"></p><h4 id="Hybrid端口"><a href="#Hybrid端口" class="headerlink" title="Hybrid端口"></a>Hybrid端口</h4><p>是华为私有的端口类型，既可以用于交换机之间或交换机与路由器之间互连，也可以用于交换机与计算机之间互联。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-primary">            <p>数据链路层主要要负责将数据正确的送到目的地。</p><p>其需要在逻辑上实现其职责(逻辑链路控制LLC)：封装帧、差错检测和可靠重传。典型实现是PPP。</p><p>也需要与物理层的交界处实现对共享媒体控制(媒体接入控制MAC)：控制共享媒介的使用策略。典型实现是CSMA&#x2F;CA协议。</p><p>以上内容保证了数据的完整性，但我们还需要保证数据能正确送到指定主机或进行广播。因此需要ARP表来指明目的主机的MAC地址。</p><p>集线器与普通总线结构网络没有区别，而交换机则在可以根据目标MAC地址定向转发MAC帧，避免了碰撞问题，扩大了广播域。</p><p>最后，由于广播域的扩大会造成广播风暴，也有以下两种解决方法：</p><ul><li>为了避免循环广播，需要生成树协议。</li><li>为了避免广播到不必要的区域，需要VLAN。</li></ul>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/6b82134a4325">计算机网络第3章（数据链路层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第2章（物理层）</title>
    <link href="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、物理层的基本概念"><a href="#一、物理层的基本概念" class="headerlink" title="一、物理层的基本概念"></a>一、物理层的基本概念</h1><p>物理层主要考虑如何传输数据比特流。</p><h1 id="二、物理层传输媒体"><a href="#二、物理层传输媒体" class="headerlink" title="二、物理层传输媒体"></a>二、物理层传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><ol><li>同轴电缆（已被淘汰）</li><li>双绞线（主要用于局域网）</li><li>光纤（主要用于ISP接入服务）<ul><li>多模光纤：允许多条不同角度的光纤同时传输</li><li>单模光纤：如同一根波导，没有反射</li></ul></li><li>电力线（主要用于家庭网络扩展：猫）</li></ol><h2 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h2><ol><li>无线电波（波长1m-10km）</li><li>微波（波长1mm-1m）</li><li>红外线（已淘汰，只能直线传输）</li><li>可见光（LIFI）</li></ol><h1 id="三、传输方式"><a href="#三、传输方式" class="headerlink" title="三、传输方式"></a>三、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><strong>串行传输</strong>：数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可<br><strong>并行传输</strong>：一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p><div class="note note-primary">            <p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>          </div><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><strong>同步传输</strong>：以<strong>比特流</strong>的形式传输。字节之间没有间隔。<br><strong>异步传输</strong>：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</p><p>同步传输需要解决时钟问题，即数据的接收方如何判断哪一部分是一个字节：<br>对于同步传输，有两种方式同步时钟：</p><ul><li>外同步：添加独立时钟信号线</li><li>内同步：通过编码信息判断</li></ul><p>异步传输把字节之间断开，根据字节开始和结尾判断即可：</p><ul><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><h2 id="单双工"><a href="#单双工" class="headerlink" title="单双工"></a>单双工</h2><p>信道（<em>channel</em>）：信道一般都是用来表示向某一个方向传送信息的媒体。</p><p>单工：单向传输<br>半双工；双向（不能同时，需要两条信道）<br>双工：双向（同时，需要两条信道）</p><h1 id="四、编码和调制"><a href="#四、编码和调制" class="headerlink" title="四、编码和调制"></a>四、编码和调制</h1><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-acc59055804f0890.webp"></p><blockquote><p>术语：<br><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote><div class="note note-primary">            <p>编码和调制主要解决如何将0，1比特流转化为可以传输的信号形式。<br>码元（code）：对于本章的学习，可以理解为表示一个比特的单元波形。<strong>实际上，根据编码的不同，一个码元可以对应于几个比特，但也可以是几个码元对应于一个比特</strong>。</p><p>基带信号：表示数据传输前的原始信号。</p><p>针对不同的信道（媒介）有不同的方式：</p><ul><li>对于数字信道，其可以清楚的区分电平的高低，因此可以采用<strong>编码</strong>的方式处理原始信号。</li><li>对于模拟信道，一般使用波作为媒介，需要通过控制信号的频率和相位（即<strong>调制</strong>）的方式处理原始信号</li></ul>          </div><blockquote><p>严格来说，传输媒体 ≠ 信道，使用信道复用技术时，一条传输媒体可以包含多个信道。</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>不归零编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-0732d0edc74846b5.webp"><br>缺点：没有时钟同步。<br><strong>归零编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-8aa838a116fdafb4.webp"><br>缺点：每个码元都要归零，数据量太大，编码效率低。<br><strong>曼彻斯特编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-a34a686a9d052e9c.webp"><br>通过跳变方向判断比特位。</p><div class="note note-primary">            <p>相对归零编码，省去了当比特变化为<code>10101010</code>样式时的归零行为，不过对于<code>00000000</code>形式的编码，数据量仍比较大，每次上升后需要在码元间隙下降，如上图的第二个0后面，以便于下一次上升。</p><p>问题：<br>这个码元间隙的下降行为是否导致时钟的误判问题。<br>解释：<br>所谓时钟同步，可以理解为一个打点计时器（？），设备根据打点瞬间电信号的电平判断这个比特位为0还是1，所以若是打点计时器的频率或初始时间与发送端不一致，就会得到失真的信号，这种现象也叫时钟滑移。<br>而曼彻斯特码元间的下降&#x2F;上升行为其实不会被视为下降沿&#x2F;上升沿，因为其实这种编码还是有一个隐藏时钟。对于设备来说，其可以判断接受到的电信号的最短时间间隔，从而判断一个码元的时间长度。（1个码元时间&#x3D;2个最短时间间隔），这样就解决了频率问题。<br>而一个码元单元必然有一个跳变，码元之间不一定有，从而解决了相位问题。</p>          </div><p><strong>差分曼彻斯特编码</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-9a758474e374329a.webp"><br>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li>跳变仅表示时钟</li><li>码元开始处电平是否变换表示数据<br>优点：比曼彻斯特编码的变化少，曼彻斯特编码为了得到正确的跳变方向有时需要在码元结束时置反，即（连续1和连续0时会导致码元间置反），而这里连续0<strong>或</strong>连续1时（具体看规定变化为0还是1），不需要进行置反。变化相对少一些。</li></ul><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。<br>每个基本波形只能表示1比特信息量。</li></ul><h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><ul><li>在编码中两个电位（一个表示时钟一个表示值）的信息即可表示1比特信息。而对于模拟信号，其有更多维度的信息（同上调制的基本方法），因此可以尝试使用一个码元表示多个比特。</li><li>频率就是相位的变化速率，因此两者不可同时调制。</li></ul><p><strong>正交振幅调制QAM</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1cb6de826ba63b70.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1e2617434d904ce4.webp"></p><ul><li>给出了12个相位（角度），其中有4个角度（45°）有两个振幅，则共有：8 * 1 + 4 * 2 &#x3D; 16种码元。</li><li>故一个码元的信息量为 2^4，可以表示4位bit。</li></ul><h1 id="五、信道的极限容量"><a href="#五、信道的极限容量" class="headerlink" title="五、信道的极限容量"></a>五、信道的极限容量</h1><p>传输信号时会产生各种失真。</p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p>如何尽可能地避免失真：</p><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-b90918937a54faa6.webp"></p><div class="note note-primary">            <p>奈氏准则主要给出一条信道的最高码元传输效率（理论）<br>波特率：码元传输速率<br>比特率&#x3D;波特率 * 每波特携带比特数<br>那么要提高比特率，则要提高每波特携带比特数。</p>          </div><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-57e105e5df793b93.webp"></p><div class="note note-primary">            <p>信噪比：理解起来可以视为信号相对噪音的占比，这个值越大，极限传输速率越高。</p>          </div><div class="note note-info">            <p>奈氏准则主要指出<strong>码元比特量</strong>对传输极限的影响。<br>香农准则主要指出<strong>信噪比</strong>对传输极限的影响。</p>          </div><h1 id="六、信道复用技术"><a href="#六、信道复用技术" class="headerlink" title="六、信道复用技术"></a>六、信道复用技术</h1><h2 id="复用技术类型"><a href="#复用技术类型" class="headerlink" title="复用技术类型"></a>复用技术类型</h2><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽（频率带宽）资源</strong><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-bcb9321a6a8a3d7a.webp"></li><li><strong>时分复用TDM</strong>（<em>Time Division Multiplexing</em>）则是将时间划分为一段段等长的**时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。（可能浪费）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-cb9a20b7ce00d497.webp"></li><li><strong>统计时分复用 STDM</strong> (<em>Statistic TDM</em>)，弥补时分中的浪费，按需分配。<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-7f0b54d1c14702ca.webp"></li><li><strong>波分复用WDM</strong>(<em>Wavelength Division Multiplexing</em>)<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-039cdf67599ebe3b.webp"></li><li><strong>码分复用</strong>（<em>Code Division Multiplexing</em>），常用的名词是<strong>码分多址</strong> CDMA (<em>Code Division Multiple Access</em>)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/792648675640">计算机网络第2章（物理层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第1章（概述）</title>
    <link href="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <url>/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong>互连网</strong>（<em>internet</em>）：多个网络通过路由器互连起来构成的网络（通用名词，可使用任意协议）<br><strong>因特网</strong>（<em>Internet</em>）：是世界上最大的互连网（专有名词，使用TCP&#x2F;IP协议）<br><strong>ISP</strong>（<em>Internet Service Provider</em>）：因特网服务提供者，如电信、联通、移动。</p><p><strong>端系统之间通信</strong>：主机 A 的某个进程和主机 B 上的另一个进程进行通信。</p><div class="note note-primary">            <p>端对端通讯分为两大类：C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p>          </div><h1 id="二、交换方式"><a href="#二、交换方式" class="headerlink" title="二、交换方式"></a>二、交换方式</h1><h2 id="1-电路交换（Circuit-Switching）"><a href="#1-电路交换（Circuit-Switching）" class="headerlink" title="1.电路交换（Circuit Switching）"></a>1.电路交换（<em>Circuit Switching</em>）</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-acb87df045723236.webp"></p><blockquote><p>步骤：<br>1.建立连接 2.通话 3.释放连接</p></blockquote><h2 id="2-分组交换（Packet-Switching）"><a href="#2-分组交换（Packet-Switching）" class="headerlink" title="2.分组交换（Packet Switching）"></a>2.分组交换（<em>Packet Switching</em>）</h2><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>称为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方：</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器：</p><ul><li>缓存分组</li><li>转发分组</li></ul><p>接收方：</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h2><p>报文交换对报文的大小没有限制，主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="4-对比"><a href="#4-对比" class="headerlink" title="4.对比"></a>4.对比</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e655a213714d1871.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-c56f91f290cbc92b.webp"></p><h1 id="三、定义与分类"><a href="#三、定义与分类" class="headerlink" title="三、定义与分类"></a>三、定义与分类</h1><h2 id="按覆盖范围"><a href="#按覆盖范围" class="headerlink" title="按覆盖范围"></a>按覆盖范围</h2><ul><li>广域网WAN（<em>Wide Area Network</em>）</li><li>城域网MAN（<em>Metropolitan</em>）</li><li>局域网LAN（<em>Local</em>）</li><li>个域网PAN（<em>Personal</em>）</li></ul><h2 id="按结构"><a href="#按结构" class="headerlink" title="按结构"></a>按结构</h2><ul><li>总线<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-4ed63e74d9ced719.webp"></li><li>星型<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f6a1849bcc443935.webp"></li><li>环形<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ca133aaaf8fe8659.webp"></li><li>网络<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-d0d30cddc7356396.webp"></li></ul><h1 id="四、性能指标"><a href="#四、性能指标" class="headerlink" title="四、性能指标"></a>四、性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ba6c4e627a62c05e.webp"></p><div class="note note-primary">            <p>速率的k一般指1000，数据量的k为1024</p>          </div><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f4b18e0039f4a6c6.webp"></p><div class="note note-primary">            <p>带宽在模拟信号中指频率范围，在计网中指最高<strong>速率</strong>。<br>关联在于，频率越高，速率越高。</p>          </div><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位时间通过某网络的数据量</p><div class="note note-primary">            <p>带宽相当于理论值、吞吐量为真实值。</p>          </div><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</p><blockquote><p>有时会把排队时延看成<strong>处理时延的一部分</strong><br>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><div class="note note-primary">            <p>m &#x3D; 2 * 10^8</p>          </div><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><div class="note note-primary">            <p>表示链路上有多少个bit正在流动</p>          </div><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>RTT(<em>Round-Trip Time</em>)</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-62d6da59682ef67f.webp"></p><div class="note note-primary">            <p>信道利用率针对具体信道，网络针对全网络信道，都是对时间的利用统计。</p>          </div><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>一定时间范围内，丢失分组数量与总分组数量的比率</p><h1 id="五、体系结构"><a href="#五、体系结构" class="headerlink" title="五、体系结构"></a>五、体系结构</h1><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b5174af1551d6cee.webp"></p><div class="note note-primary">            <p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。<br>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>          </div><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6800e214b18c47c3.webp"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="1-发送"><a href="#1-发送" class="headerlink" title="1.发送"></a>1.发送</h3><p>应用层（<strong>HTTP请求报文</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ac36f7a9544dde9f.webp"><br>传输层（<strong>TCP报文段</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-cc2b73b1736d5809.webp"><br>网络层（<strong>IP数据报</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-dc02183dcf759d9e.webp"><br>数据链路层（<strong>帧</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f8cf8ce4a6bfdb54.webp"><br>物理层（<strong>比特流</strong>）<br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e7285afa504bce0d.webp"></p><h3 id="2-路由转发"><a href="#2-路由转发" class="headerlink" title="2.路由转发"></a>2.路由转发</h3><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b9824f4625354b9b.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-09a0b27933c9895e.webp"><br><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6eace5a882cca26d.webp"><br>再整个封装回去。</p><div class="note note-primary">            <p>路由器主要作用在网络层及以下，主要根据路由表查询端口转发IP数据包。</p>          </div><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>实体：任意可发送或接受信息的硬件或进程</li><li>对等实体：相同层次的实体</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-01d621fd0afde0a2.webp"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合<br>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><img src="/2022/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f9bd7898a7f2dadd.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/541d4f0c0f1e">计算机网络第1章（概述）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-基础篇</title>
    <link href="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP-x2F-IP网络模型"><a href="#一、TCP-x2F-IP网络模型" class="headerlink" title="一、TCP&#x2F;IP网络模型"></a>一、TCP&#x2F;IP网络模型</h1><p>主要针对TCP&#x2F;IP网络模型。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层</strong>（<em>Application Layer</em>）只专注于提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="传输层"></p><p>传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p><strong>TCP</strong> 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p><strong>UDP</strong> 只负责发送数据包，不保证数据包是否能抵达对方。但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><h3 id="应用层与传输层的交互"><a href="#应用层与传输层的交互" class="headerlink" title="应用层与传输层的交互"></a>应用层与传输层的交互</h3><p>应用需要传输的数据可能会非常大，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E6%AE%B5.png" alt="TCP段"></p><p>传输层其实并不负责整个传输过程，它的作用是相对应用层而言的，即它可以帮助应用层实现数据传输。</p><p>到传输层数据到达目标设备时，传输层则要负责把数据包传给应用，但一台设备有多个应用，这时需要使用端口号将应用区分开来。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层报文中携带端口号，因此可以识别数据要发给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>如上所述，传输层其实主要做区分应用，把应用数据下发的作用，真正使数据在互联网上传输的功能在<strong>网络层</strong>（<em>Internet Layer</em>）上。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/12.jpg" alt="MAC"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p><p>将IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>配合<strong>子网掩码</strong>，可以将一个网络号同时给多个主机使用，子网掩码则用于计算 网络号和主机号。</p><p>如10.100.122.0&#x2F;24后面的<code>/24</code>表示就是 <code>255.255.255.0</code>，将IP地址与子网掩码按位与，得到网络号，与子网掩码的取反按位与，则得到主机号。</p><p>寻找目标地址的过程，就是一个寻找网络-&gt;寻找主机的过程。</p><p><strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网路接口层"><a href="#网路接口层" class="headerlink" title="网路接口层"></a>网路接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="网络接口层"></p><p>网络层实现了信息在互联网上传输的功能，而要将信息传输到互联网，我们还需要经过网络接口层。</p><p>网络接口层的功能主要体现在以太网技术上，即通过局域网把网络包发送到目的地。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务。个人理解是在数据的传输中，数据包会经过很多交换机，交换机会将数据包解包至网络接口层，然后再封装，发送。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>使用 MAC 地址，我们可以标识网络上的设备，实现在以太网、WiFi 这样的底层网络上发送原始数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="tcpip参考模型"></p><p>封装格式：</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.png" alt="封装"></p><div class="note note-info">            <p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>          </div><blockquote><p>应用层负责将应用产生的数据传递给传输层，将从传输层接受到的数据组合，返回给应用。</p><p>传输层负责将从应用层接受到的数据包传递给网络层，这个过程会携带应用端口</p><p>网络层负责将从传输层接受到的数据包发送到网络，这个过程会携带IP地址（网络号+主机号&#x2F;子网掩码）</p><p>网络接口层负责将网络层的数据通过以太网技术的方式发送到数据库</p></blockquote><h1 id="二、浏览器请求过程"><a href="#二、浏览器请求过程" class="headerlink" title="二、浏览器请求过程"></a>二、浏览器请求过程</h1><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/2.webp"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-解析URL"><a href="#1-解析URL" class="headerlink" title="1.解析URL"></a>1.解析URL</h3><p>浏览器先解析URL地址，然后生成给WEB服务器的信息。<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/3.webp"><br>如果省略资源路径，则会访问Web服务根目录的<code>index.html</code>或<code>default.html</code></p><h3 id="2-生成HTTP请求信息"><a href="#2-生成HTTP请求信息" class="headerlink" title="2.生成HTTP请求信息"></a>2.生成HTTP请求信息</h3><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/4.webp"></p><div class="note note-primary">            <p>HTTP报文三要素：</p><ul><li>请求报文：请求行(req)+请求头(head)+请求体(body)</li><li>响应报文：状态行(status)+消息头(head)+消息体(body)</li></ul>          </div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>消息发送前需要<strong>查询服务器域名对应的 IP 地址</strong><br>因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DNS是一种服务器，其专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>，这与中文相反。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。即<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><p>所以实际上是 .  –&gt; .com –&gt;server<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/5.webp"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><p>也就是说，查询域名IP时：</p><ol><li>客户端只会向最近的本地DNS服务器请求ip地址。</li><li>本地DNS服务器若记录了ip地址，则直接返回，若没有记录，则进行以下操作。</li><li>本地DNS向根DNS服务器请求ip地址，根DNS将.com的DNS服务器给本地DNS服务器。</li><li>本地DNS服务器再向.com的DNS（顶级域名服务器）请求ip地址，顶级域名服务器将<a href="http://www.server.com的权威/">www.server.com的权威</a> DNS 服务器给本地DNS服务器。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接。</li></ol><div class="note note-warning">            <p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明目标服务器的位置。</p>          </div><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/6.webp"></p><blockquote><p>DNS 域名解析的过程是一个<strong>只指路不带路</strong>的过程。</p></blockquote><div class="note note-primary">            <p>当然，浏览器、操作系统、hosts文件都有缓存，在这些地方都找不到时才会向本地DNS服务器发请求。</p>          </div><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<strong>协议栈</strong>。</p><div class="note note-primary">            <p>注意这里开始进入操作系统层面。</p>          </div><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/7.webp"></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。</p><p>协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><p>进入协议栈后，就依靠各层协议一步一步完成数据传输。 </p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>HTTP 是<strong>基于 TCP 协议</strong>传输的，TCP报文格式如下：<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/8.webp" alt="TCP报文"></p><p>理解：</p><ul><li><strong>源端口号</strong>和<strong>目标端口</strong>号：这是与应用层交互的关键识别信息。</li><li>包<strong>序</strong>号，防止乱序</li><li><strong>确认号</strong>，防止丢包</li><li><strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>：TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，从而实现<strong>拥塞控制</strong>：即控制发送的速度。</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓的握手就是使通讯双方维护一个状态机。<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"></p><blockquote><p>SYN指<strong>SYN：同步序列编号</strong>（ Synchronize Sequence Numbers ）<br>ACK指<strong>ACK：确认字符</strong>（Acknowledge character）</p></blockquote><div class="note note-success">            <p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>          </div><div class="note note-primary">            <p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>          </div><h3 id="TCP数据分割"><a href="#TCP数据分割" class="headerlink" title="TCP数据分割"></a>TCP数据分割</h3><p>若HTTP请求报文较长，超过了 <code>MSS</code> 的长度则需要拆解。<br><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/11.webp"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p><img src="/2022/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/12.webp"></p><p>拆分出来的每一块数据都会被放进单独的网络包中，分别加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p>todo:<br>TCP报文生成<br><a href="https://cloud.tencent.com/developer/article/1875682#:~:text=%E5%BD%93%E8%B7%AF%E7%94%B1%E5%99%A8%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90%E5%87%BAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%20%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%20%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1%E8%A1%A8%EF%BC%8C%E4%BE%9D%E6%8D%AE,%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3%E6%88%96%E8%80%85%E5%87%BA%E6%8E%A5%E5%8F%A3%E5%B0%86%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91%E5%87%BA%E5%8E%BB%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%20%E8%B7%AF%E7%94%B1%20%E3%80%82">https://cloud.tencent.com/developer/article/1875682#:~:text=%E5%BD%93%E8%B7%AF%E7%94%B1%E5%99%A8%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90%E5%87%BAIP%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%AD%E7%9A%84%20%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%20%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%B9%E6%8D%AE%E7%9B%AE%E7%9A%84IP%E5%9C%B0%E5%9D%80%E6%9F%A5%E6%89%BE%E8%B7%AF%E7%94%B1%E8%A1%A8%EF%BC%8C%E4%BE%9D%E6%8D%AE,%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3%E6%88%96%E8%80%85%E5%87%BA%E6%8E%A5%E5%8F%A3%E5%B0%86%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91%E5%87%BA%E5%8E%BB%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%20%E8%B7%AF%E7%94%B1%20%E3%80%82</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIwOTcyNjA3Mw==&mid=2247500748&idx=1&sn=08b9a324a2c33a6c80e26a7711cfef96&chksm=976dfcdaa01a75ccc0cf85569f92ed3d0597bfaeac736a3a3114e0d34fac821b1c0458269fb9&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzIwOTcyNjA3Mw==&amp;mid=2247500748&amp;idx=1&amp;sn=08b9a324a2c33a6c80e26a7711cfef96&amp;chksm=976dfcdaa01a75ccc0cf85569f92ed3d0597bfaeac736a3a3114e0d34fac821b1c0458269fb9&amp;scene=21#wechat_redirect</a><br><a href="https://www.cnblogs.com/mefj/p/14543955.html#:~:text=%E4%B8%80%E3%80%81%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B6%E4%B8%AD%E6%8E%A9%E7%A0%81%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E7%94%B1%20%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%B8%8B%E5%BD%93%E6%9C%89%2F24%E5%92%8C%2F25%E4%BD%8D%E7%9A%84%E6%8E%A9%E7%A0%81%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%EF%BC%8C%E9%80%89%E6%8B%A9%2F25%E7%9A%84%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%A3E0%E3%80%82%20%E4%BA%8C%E3%80%81%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB,%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E6%8E%A9%E7%A0%81%E4%B8%80%E6%A0%B7%20%28%E8%B7%B3%E8%BF%87%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%29%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%E4%B8%80%E6%A0%B7%20%28%E7%9B%B8%E5%90%8C%E5%8D%8F%E8%AE%AE%2C%E8%BF%99%E6%97%B6%E5%80%99%E8%B7%B3%E8%BF%87%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%29%E3%80%82%20%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%86%85%E5%88%A4%E5%BA%A6%E9%87%8F%E5%80%BC%20%E6%80%BB%E7%BB%93%EF%BC%9A%20%E4%BD%9C%E8%80%85%EF%BC%9A%20%E8%BF%90%E7%BB%B4%E5%AF%86%E7%A0%81">https://www.cnblogs.com/mefj/p/14543955.html#:~:text=%E4%B8%80%E3%80%81%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%20%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%80%89%E6%8B%A9%E5%85%B6%E4%B8%AD%E6%8E%A9%E7%A0%81%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E7%94%B1%20%E4%BE%8B%EF%BC%9A%E5%A6%82%E4%B8%8B%E5%BD%93%E6%9C%89%2F24%E5%92%8C%2F25%E4%BD%8D%E7%9A%84%E6%8E%A9%E7%A0%81%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%EF%BC%8C%E9%80%89%E6%8B%A9%2F25%E7%9A%84%E8%B7%AF%E7%94%B1%E6%8E%A5%E5%8F%A3E0%E3%80%82%20%E4%BA%8C%E3%80%81%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%20%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB,%EF%BC%9A%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%B7%AF%E7%94%B1%E9%83%BD%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E6%8E%A9%E7%A0%81%E4%B8%80%E6%A0%B7%20%28%E8%B7%B3%E8%BF%87%E6%9C%80%E9%95%BF%E6%8E%A9%E7%A0%81%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%29%EF%BC%8C%E4%B8%94%E8%BF%99%E6%97%B6%E5%80%99%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%E4%B8%80%E6%A0%B7%20%28%E7%9B%B8%E5%90%8C%E5%8D%8F%E8%AE%AE%2C%E8%BF%99%E6%97%B6%E5%80%99%E8%B7%B3%E8%BF%87%E7%AE%A1%E7%90%86%E6%80%A7%E8%B7%9D%E7%A6%BB%20%28AD%29%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%29%E3%80%82%20%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%E5%86%85%E5%88%A4%E5%BA%A6%E9%87%8F%E5%80%BC%20%E6%80%BB%E7%BB%93%EF%BC%9A%20%E4%BD%9C%E8%80%85%EF%BC%9A%20%E8%BF%90%E7%BB%B4%E5%AF%86%E7%A0%81</a><br><a href="https://bbs.huaweicloud.com/blogs/359221">https://bbs.huaweicloud.com/blogs/359221</a><br><a href="https://zhuanlan.zhihu.com/p/61805945">https://zhuanlan.zhihu.com/p/61805945</a><br><a href="https://www.cnblogs.com/liyuanhong/p/13585654.html">https://www.cnblogs.com/liyuanhong/p/13585654.html</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/">小林coding-图解网络</a></p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
      <category>计算机网络</category>
      
      <category>复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyFirstBlog</title>
    <link href="/2022/12/09/MyFirstBlog/"/>
    <url>/2022/12/09/MyFirstBlog/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h1><p>这是我的第一个条博文，为了建立这个博客我花费了整整一晚上。<br>有时候真希望我是一个好的前端程序员，因为我看不懂这些layout的设置:)<br>下面测试一下功能</p><h1 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h1><blockquote><p>引用</p></blockquote><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>Hello.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是反斜杠方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><a href="https://hexo.bootcss.com/docs/tag-plugins.html" title="" target="">引用网址</a><h1 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h1><img src="/2022/12/09/MyFirstBlog/test.png" class=""><p>或使用markdown标记相对资源</p><p><img src="/2022/12/09/MyFirstBlog/test.png" alt="测试图片"></p><h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><h1 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h1><span class="label label-primary">Label</span>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
