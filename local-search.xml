<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微服务常见问题</title>
    <link href="/2023/10/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、RPC"><a href="#一、RPC" class="headerlink" title="一、RPC"></a>一、RPC</h1><h2 id="RPC概念"><a href="#RPC概念" class="headerlink" title="RPC概念"></a>RPC概念</h2><p><em>什么是RPC？</em><br><strong>Remote Procedure Calls</strong> 远程过程调用（RPC）是<strong>一种协议（规范）</strong>，就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。<br><strong>RPC的核心在于业务不需要了解底层网络技术的协议。在OSI网络通信模型中，其跨越了传输层和应用层。</strong></p><p><em>RPC调用分类？</em></p><ul><li>同步调用<ul><li><strong>WebService</strong>：基于web容器，底层使用<strong>http协议</strong>，适合<strong>异构系统</strong>；</li><li><strong>RMI</strong>：<strong>Remote Method Invocation远程方法调用</strong>，应用编程接口API，<strong>是Java对RPC的实现</strong>；</li></ul></li><li>异步调用<ul><li><strong>JMS</strong>：Java Message Service，主要实现为MQ。</li></ul></li></ul><p><em>RPC需要解决的问题</em></p><ul><li>通讯问题：需要<strong>通讯框架</strong></li><li>寻址问题：需要<strong>注册中心</strong>，<strong>服务发现</strong></li><li>序列化与反序列化问题：需要<strong>序列化协议</strong></li></ul><p><img src="/2023/10/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230902002916.png"></p><p><em>各功能具体实现</em></p><ul><li>通讯框架：<ul><li>大部分RPC框架都是基于TCP协议（应用层由语言自己实现，如java会基于netty开发对应的通讯框架）</li><li>少量基于HTTP协议、UDP协议</li></ul></li><li>注册中心：<ul><li>dubbo注册中心</li><li>eureka注册中心</li><li>zookeeper注册中心</li><li>其他</li></ul></li><li>序列化协议：<ul><li>Java序列化</li><li>Hession序列化</li><li>ProtoBuf序列化</li><li>Thrift序列化</li><li>其他</li></ul></li></ul><p><em>应用级服务框架</em><br><strong>应用级服务框架(RPC协议)</strong> 需要同时解决网络通讯、服务发现、序列化协议的问题，是对RPC的实现。</p><ul><li>Dubbo</li><li>SpringCloud</li><li>gRPC</li><li>Thrift</li></ul><p><em>RPC、RPC协议、RPC框架</em></p><ul><li>RPC协议是对RPC的实现，而RPC框架是一种整体解决方案，由用户直接使用。</li><li>RPC协议的实现是不依赖于注册中心的，注册中心提供的是动态感知服务变化的能力。</li></ul><p><em>gRPC和RPC的关系？</em><br>gRPC是一个高性能、通用的<strong>开源RPC框架</strong>，其由Google 2015年主要面向移动应用开发。需要定义<strong>proto文件</strong>供各端使用，其<strong>基于HTTP&#x2F;2协议</strong>标准而设计（Java版本使用Netty库），性能更高。<strong>基于ProtoBuf序列化</strong>协议开发，二进制保证了更高的安全性。</p><p><em>使用的RPC框架是gRPC协议吗？</em><br>Triple 协议是 <strong>Dubbo3</strong> 设计的基于 HTTP 的 RPC 通信协议规范，它完全兼容 gRPC 协议，也是基于ProtoBuf序列化协议开发。</p><h1 id="二、注册中心"><a href="#二、注册中心" class="headerlink" title="二、注册中心"></a>二、注册中心</h1><p><em>各注册中心对比</em><br><img src="/Pasted%20image%2020230901161634.png"></p><blockquote><p><a href="https://juejin.cn/post/7068065361312088095">注册中心对比和选型：Zookeeper、Eureka、Nacos、Consul和ETCD</a></p></blockquote><p><em>Zookeeper的模式</em><br>推拉结合（只推送更新事件，由客户端拉取信息）</p><p><em>Zookeeper为什么不适用于注册中心？</em><br>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。但Zookeeper选主时会出现不可用（强一致性），而<strong>作为注册中心，可用性的要求要高于一致性！</strong></p><p><em>Eureka特点</em></p><ul><li>去中心化，不同于 ZooKeeper 的选举 leader 的过程，Eureka Server 采用的是Peer to Peer 对等通信。无 master&#x2F;slave 之分，每一个 Peer 都是对等的，节点之间通过互相注册实现可用性，每个节点都可被视为其他节点的副本。</li><li>Eureka 为了保障注册中心的高可用性，容忍了数据的非强一致性，服务节点间的数据可能不一致， Client-Server 间的数据可能不一致。<strong>比较适合跨越多机房、对注册中心服务可用性要求较高的使用场景。</strong></li></ul><p><em>Nacos特点</em></p><ul><li>Nacos是阿里开源的，支持基于 DNS 和基于 RPC 的服务发现。</li><li>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。</li><li><strong>动态配置</strong>消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</li><li><strong>Nacos的注册中心支持CP也支持AP</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis笔记</title>
    <link href="/2023/10/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Mybatis/Mybatis%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Mybatis/Mybatis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h1><p><em>说一说什么是 MyBatis</em><br>Mybatis 是一个半 ORM（对象关系映射）的持久层框架，它内部封装了JDBC、加载驱动、创建连接、创建 statement 等繁杂的过程，开发者开发时只需要关注如何编写 SQL 语句，可以严格控制 SQL 执行性能，灵活度高。</p><p><em>那什么是持久化</em><br>将程序数据在持久状态和瞬时状态间转换的机制，即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）的机制。</p><p><em>为什么说 MyBatis 是半自动的 ORM 映射工具</em></p><ul><li>Hibernate 属于全⾃动 ORM 映射⼯具，使⽤ Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全⾃动的。</li><li><strong>Mybatis 在查询关联对象或关联集合对象时，需要⼿动编写 sql 来完成，所以，称之为半⾃动 ORM 映射⼯具</strong>。</li></ul><h1 id="二、框架原理"><a href="#二、框架原理" class="headerlink" title="二、框架原理"></a>二、框架原理</h1><h2 id="Mybatis生命周期"><a href="#Mybatis生命周期" class="headerlink" title="Mybatis生命周期"></a>Mybatis生命周期</h2><p><em>MyBatis 的生命周期</em></p><ol><li>SqlSessionFactoryBuilder 通过配置文件生成 SqlSessionFactory；</li><li>SqlSessionFactory 在 MyBatis 中以单例模式存在，创建于程序开始，销毁于程序结束，类似于线程池；</li><li>sqlSession 类似于线程池中的一个线程，线程结束后就归还于线程池；</li><li>Mapper 是 SqlSession 创建的一个具体的业务，一旦处理完了这个业务，就可以销毁它。</li></ol><table><thead><tr><th>类名</th><th>作用域</th></tr></thead><tbody><tr><td>SqlSessionFactoryBuilder</td><td>方法作用域</td></tr><tr><td>SqlSessionFactory</td><td>全局作用域</td></tr><tr><td>SqlSession</td><td>方法作用域</td></tr><tr><td>Mapper</td><td>方法作用域</td></tr></tbody></table><h2 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h2><p><em>说一说 MyBatis 的缓存</em><br>MyBatis 中默认定义了两级缓存：一级缓存和二级缓存。</p><ul><li>一级缓存，又称为本地缓存，是 SqlSession 级别的缓存，默认情况下是开启的；</li><li>二级缓存是基于 namespace 级别的缓存，则需要手动开启和配置。</li></ul><p><strong>查询缓存的顺序</strong>：二级缓存 → 一级缓存 → 数据库。</p><p><em>说一说 MyBatis 的一级缓存</em><br>与数据库同一次会话期间查询到的数据会放在一级缓存中，以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库。</p><p>一级缓存失效的四种情况：</p><ul><li>SqlSession 相同，两次查询中出现了增删改。</li><li>SqlSession 相同，但查询不同的东西。</li><li>SqlSession 相同，手动清除一级缓存。</li><li>SqlSession 不同时。</li></ul><p><em>说一说 MyBatis 的二级缓存</em><br>一级缓存当会话关闭后就会释放，所以我们需要一个这个情况下数据依然存在的缓存。<br><strong>查出的数据都会被默认先放在一级缓存中，只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中。</strong></p><h1 id="三、使用方式"><a href="#三、使用方式" class="headerlink" title="三、使用方式"></a>三、使用方式</h1><p><em>#{} 和 ${} 的区别是什么</em><br><strong>#{} 是预编译处理，${} 是字符串替换</strong>。</p><p><em>Mybatis 是如何进行分页的？分页插件的原理是什么？</em></p><ol><li>使用 limit 进行分页；</li><li>使用 RowBounds 分页，这个属于逻辑分页，即实际上 sql 查询的是所有的数据，在业务层进行了分页而已，比较占用内存，而且数据更新不及时，可能会有一定的滞后性；</li><li>使用分页插件（jar 包）进行分页；</li></ol>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quartz笔记</title>
    <link href="/2023/10/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Quartz/Quartz%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Quartz/Quartz%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Quartz基础"><a href="#一、Quartz基础" class="headerlink" title="一、Quartz基础"></a>一、Quartz基础</h1><p><em>核心类</em><br>Quartz 的核心类有以下部四部分：</p><ul><li><strong>任务 Job</strong>： 需要实现的任务类，实现 <code>execute()</code> 方法，执行后完成任务。</li><li><strong>任务实例 JobDetail</strong>：表示一个具体的可执行的调度程序，包含了这个任务调度的方案和策略。</li><li><strong>触发器 Trigger</strong>： 包括 <code>SimpleTrigger</code> 和 <code>CronTrigger</code>。</li><li><strong>调度器 Scheduler</strong>： 任务调度器，负责基于 <code>Trigger</code>触发器，来执行 <code>JobDetail</code>任务。</li></ul><p><img src="/Pasted%20image%2020231005164838.png"></p><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p><em>JobDetail</em><br>JobDetail 的作用是绑定 Job，是一个任务实例，它为 Job 添加了许多扩展参数。</p><p><em>为什么设计成JobDetail + Job，不直接使用Job？</em><br>JobDetail 定义的是任务数据，而真正的执行逻辑是在Job中。<br>这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。<br>而<code>JobDetail &amp; Job</code> 方式，Sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。</p><p><em>JobExecutionContext</em><br>当 <code>Scheduler</code> 调用一个 job，就会将 <code>JobExecutionContext</code> 传递给 Job 的 <code>execute()</code> 方法，Job 能通过 <code>JobExecutionContext</code> 对象访问到 Quartz 运行时候的环境以及 Job 本身的明细数据。</p><p><em>Job 状态参数</em><br>有状态的 job 可以理解为多次 job调用期间可以持有一些状态信息，这些状态信息存储在 <code>JobDataMap</code> 中。<br>而默认的无状态 job，每次调用时都会创建一个新的 <code>JobDataMap</code>。</p><p><em>Job与JobDetail示例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Job类,主要定义execute方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Job</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException &#123;<br>System.err.println(context.getJobDetail().getKey());<span class="hljs-comment">// JobDetail的key又他的name和group组成</span><br>System.err.println(context.getTrigger().getKey());<span class="hljs-comment">// Trigger的key又他的name和group组成</span><br>System.err.println(<span class="hljs-string">&quot;hello,quartz&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// JobDetail实例</span><br><span class="hljs-type">JobDataMap</span> <span class="hljs-variable">jobDataMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobDataMap</span>();<br>jobDataMap.put(<span class="hljs-string">&quot;jobcc&quot;</span>, <span class="hljs-string">&quot;哈哈&quot;</span>);<br><span class="hljs-type">JobDetail</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> JobBuilder.newJob(HelloJob.class)<br>  .withIdentity(<span class="hljs-string">&quot;helloJob&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-comment">//给job命名并分组</span><br>  .usingJobData(<span class="hljs-string">&quot;jobdd&quot;</span>, <span class="hljs-string">&quot;hello job&quot;</span>)<span class="hljs-comment">//通过JobBuilder的usingJobData方法给JobDataMap中塞</span><br>  .usingJobData(jobDataMap)<br>  .build();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Job在执行过程中，可以从jobdata中取出数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Job</span> &#123;<br><span class="hljs-keyword">private</span> String jobAdata;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setJobAdata</span><span class="hljs-params">(String jobAdata)</span> &#123;<br><span class="hljs-built_in">this</span>.jobAdata = jobAdata;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(JobExecutionContext context)</span> <span class="hljs-keyword">throws</span> JobExecutionException &#123;<br>System.err.println(<span class="hljs-string">&quot;当前运行的job实例的key:&quot;</span> + context.getJobDetail().getKey().toString());<br>System.err.println(context.getJobDetail().getKey());<span class="hljs-comment">// JobDetail的key又他的name和group组成</span><br>System.err.println(context.getTrigger().getKey());<span class="hljs-comment">// Trigger的key又他的name和group组成</span><br>System.err.println(context.getJobDetail().getJobDataMap().get(<span class="hljs-string">&quot;jobcc&quot;</span>));<br>System.err.println(context.getJobDetail().getJobDataMap().get(<span class="hljs-string">&quot;jobdd&quot;</span>));<br>System.err.println(context.getJobDetail().getJobDataMap().get(<span class="hljs-string">&quot;jobaa&quot;</span>));<br>System.err.println(<span class="hljs-string">&quot;jobA中的数据：&quot;</span> + jobAdata);<br>System.err.println(<span class="hljs-string">&quot;hello,quartz&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">JobDetail</span> <span class="hljs-variable">jobA</span> <span class="hljs-operator">=</span> JobBuilder.newJob(HelloJob.class)<br>  .withIdentity(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;hello_A&quot;</span>)<br>  .usingJobData(<span class="hljs-string">&quot;jobAdata&quot;</span>, <span class="hljs-string">&quot;hello A&quot;</span>)<br>  .build();<br><br></code></pre></td></tr></table></figure><p>如果你在<code>Job</code>类中，为<code>JobDataMap</code>中存储的数据的<code>key</code>增加<strong>set方法</strong>，那么Quartz的默认<code>JobFactory</code>实现在job被实例化（使用<code>usingJobData()</code>）的时候会自动调用这些<strong>set方法</strong>，这样你就不需要在<code>execute()</code>方法中显式地从map中取数据了。</p><p><em>JobDataMap</em><br>在Job执行时，<code>JobExecutionContext</code>中的<code>JobDataMap</code>是<code>JobDetail</code>中的<code>JobDataMap</code>和<code>Trigger</code>中的<code>JobDataMap</code>的并集，但是如果存在相同的数据，则后者会覆盖前者的值。<br>如果在job运行中，从<code>JobExecutionContext</code>分别获取<code>JobDetail</code>和<code>Trigger</code>，然后再分别获取它们中的<code>JobDataMap</code>，就算有相同的key，也是没有什么影响的，只有当调用<code>getMergedJobDataMap()</code>方法时才会获取它们的<code>JobDataMap</code>合并后的数据，或者用set方法获取也是获取到覆盖后的值。</p><h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p><em>作用</em><br><code>Trigger</code> 可以设置任务的开始结束时间， <code>Scheduler</code> 会根据参数进行触发。</p><p><em>SimpleTrigger</em><br>较简单的一类触发器，能实现很多基础的应用：</p><ul><li>在指定时间段内，执行一次任务</li><li>在指定时间段内，循环执行任务</li><li>立即开始，指定时间结束</li></ul><p><em>主要线程</em><br>quartz中线程主要分为<strong>执行线程</strong>和<strong>调度线程</strong></p><ul><li>执行线程：线程池，在需要执行任务的时候使用</li><li>调度线程：分为regular Scheduler Thread和Misfire Scheduler Thread：<ul><li>Regular Thread 轮询Trigger，如果有将要触发的Trigger，则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；</li><li>Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理。</li></ul></li></ul><h2 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h2><p><em>核心类之间的关系</em><br>由SchedulerFactory创建Scheduler调度器后，由调度器去调取即将执行的Trigger，执行时获取到对于的JobDetail信息，找到对应的Job类执行业务逻辑。</p><p><em>使用方式</em><br>创建一个job类，然后创建多个与该job关联的JobDetail实例，每一个实例都有自己的属性集和JobDataMap，最后，将所有的实例都加到scheduler中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloQuartz</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SchedulerException &#123;<br><span class="hljs-comment">//构建SchedulerFactory实例</span><br><span class="hljs-type">SchedulerFactory</span> <span class="hljs-variable">schedFact</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdSchedulerFactory</span>();<br><span class="hljs-comment">//获取Scheduler实例</span><br><span class="hljs-type">Scheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> schedFact.getScheduler();<br><span class="hljs-type">JobDetail</span> <span class="hljs-variable">jobA</span> <span class="hljs-operator">=</span> JobBuilder.newJob(HelloJob.class)<br>                  .withIdentity(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;hello_A&quot;</span>)<br>                  .usingJobData(<span class="hljs-string">&quot;jobAdata&quot;</span>, <span class="hljs-string">&quot;hello A&quot;</span>)<br>                  .build();<br><span class="hljs-type">JobDetail</span> <span class="hljs-variable">jobB</span> <span class="hljs-operator">=</span> JobBuilder.newJob(HelloJob.class)<br>.withIdentity(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;hello_B&quot;</span>)<br>.usingJobData(<span class="hljs-string">&quot;jobBdata&quot;</span>, <span class="hljs-string">&quot;hello B&quot;</span>)<br>.build();<br><span class="hljs-comment">//构建Trigger实例</span><br><span class="hljs-type">SimpleTrigger</span> <span class="hljs-variable">triggerA</span> <span class="hljs-operator">=</span> TriggerBuilder.newTrigger()<br>                              .withIdentity(<span class="hljs-string">&quot;helloTriggerA&quot;</span>, <span class="hljs-string">&quot;helloA&quot;</span>)<br>                              .startNow()<br>                              .withSchedule(SimpleScheduleBuilder<br>                              .simpleSchedule().withIntervalInSeconds(<span class="hljs-number">5</span>).repeatForever())<br>                              .build();<br><span class="hljs-type">SimpleTrigger</span> <span class="hljs-variable">triggerB</span> <span class="hljs-operator">=</span> TriggerBuilder.newTrigger()<br>   .withIdentity(<span class="hljs-string">&quot;helloTriggerB&quot;</span>, <span class="hljs-string">&quot;helloB&quot;</span>)<br>   .startNow()<br>   .withSchedule(SimpleScheduleBuilder<br>.simpleSchedule().withIntervalInSeconds(<span class="hljs-number">10</span>).repeatForever())<br>   .build();<br><span class="hljs-comment">//将JobDetail实例和Trigger实例加入到调度容器</span><br>scheduler.scheduleJob(jobA, triggerA);<br>scheduler.scheduleJob(jobB, triggerB);<br><span class="hljs-comment">//启动容器</span><br>scheduler.start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、Quartz运行"><a href="#二、Quartz运行" class="headerlink" title="二、Quartz运行"></a>二、Quartz运行</h1><h2 id="Quartz初始化"><a href="#Quartz初始化" class="headerlink" title="Quartz初始化"></a>Quartz初始化</h2><p>Quartz启动后会初始化Schedule，加载任务，具体执行逻辑如下：<br><img src="/Pasted%20image%2020231005165527.png"><br>流程图简要说明：</p><ol><li>读取配置文件</li><li>初始化SchedulerFactoryBean</li><li>初始化SchedulerFactory</li><li>实例化执行线程池（TheadPool）</li><li>实例化数据存储（JobStore，用于加载定时任务）</li><li>初始化QuartzScheduler(为Scheduler的简单实现，包括调度作业、注册JobListener实例等方法。)</li><li>new一个QuartzSchedulerThread调度线程（负责执行在QuartzScheduler中注册的触发触发器的线程），并开始运行</li><li>调度开始，注册监听器，注册Job和Trigger</li><li>SchedulerFactoryBean初始化完成后执行start()方法</li><li>创建ClusterManager线程并启动线程（该线程用来进行集群故障检测和处理）</li><li>创建MisfireHandler线程并启动线程（该线程用来进行misfire任务的处理）</li><li>置QuartzSchedulerThread的paused&#x3D;false，调度线程真正开始调度，开始执行run方法</li></ol><h2 id="QuartzSchedulerThread执行"><a href="#QuartzSchedulerThread执行" class="headerlink" title="QuartzSchedulerThread执行"></a>QuartzSchedulerThread执行</h2><p>执行<code>QuartzSchedulerThread</code>类的<code>run()</code>方法：<br><img src="/Pasted%20image%2020231005171615.png"></p><ol><li>获取执行线程池中可用线程数量</li><li>从JobStore通过trigger表获取30s内要执行的trigger（没有则随机等待一个30s内的时间）：<ol><li>通过select..for update获取这些trigger的锁</li><li>更新trigger的状态<code>wait -&gt; acquired</code></li><li>插入trigger到firedtrigger表，状态为acquired</li><li>释放trigger锁</li></ol></li><li>当获取到的最早的trigger会在2ms内执行时<ol><li>通过select…for update获取trigger的锁</li><li>更新firedtrigger的状态<code>acquired -&gt; executing</code></li><li>更新trigger的下次执行时间</li><li>更新trigger的状态：无状态的<code>trigger-&gt;WAITING</code>，有状态的<code>trigger-&gt;BLOCKED</code>，若<code>nextFireTime == null -&gt; COMPLETE</code></li><li>释放trigger锁</li></ol></li><li>对每个要执行的trigger，创建JobRunShell，并放入线程池执行<ol><li>执行job</li><li>通过select…for update获取trigger的锁</li><li>更新trigger状态：<code>BLOCKED-&gt;WAITING</code>,<code>PAUSED_BLOCKED-&gt;BLOCKED</code></li><li>若@PersistJobDataAfterExecution，则<code>updateJobData</code></li><li>释放锁</li></ol></li></ol><h2 id="MisfireHandler执行"><a href="#MisfireHandler执行" class="headerlink" title="MisfireHandler执行"></a>MisfireHandler执行</h2><p>Quartz对于任务的超时是有容忍度的，<strong>只有超过这个容忍度(默认1min)才会判定位misfire。</strong></p><p><em>出现Misfired的原因</em></p><ol><li>系统因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；</li><li>Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；</li><li>线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；</li><li>有状态任务在下次触发时间到达时，上次执行还没有结束；</li></ol><p><em>处理策略</em><br>Quartz 中为 trigger定义了处理策略：</p><ul><li>MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 Misfired job马上执行一次；</li><li>MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；</li><li>MISFIRE_INSTRUCTION_SMART_POLICY（默认）：该策略在CronTrigger中&#x3D;MISFIRE_INSTRUCTION_FIRE_ONCE_NOW</li></ul><p><em>实现</em><br>Misfire线程默认1分钟执行一次：</p><ol><li>若配置（默认为true，可配置）成获取锁前先检查是否有需要recovery的trigger，先获取misfireCount；</li><li>获取trigger锁</li><li>获取misfired的trigger（在一个事务中，默认一次最多recovery 20个）</li><li>获取misfired的策略，将nextFireTime等更新到trigger表；</li><li>释放trigger锁</li></ol><h2 id="并行控制"><a href="#并行控制" class="headerlink" title="并行控制"></a>并行控制</h2><p>Quartz定时任务默认都是并发执行的，不会等待上一次任务执行完毕，只要间隔时间到就会执行, 如果定时任执行太长，会长时间占用资源，导致其它任务堵塞。<br><em>@DisallowConcurrentExecution</em><br>注解在Job上，表示该Job下的相同的JobDetail不能被同时执行，不同的JobDetail可以同时执行。</p><p><em>@PersistJobDataAfterExecution</em><br>表示当正常执行完Job后, JobDataMap中的数据应该被改动, 以被下一次调用时用。当使用<code>@PersistJobDataAfterExecution</code> 注解时, 为了避免并发时, 存储数据造成混乱, 强烈建议把<code>@DisallowConcurrentExecution</code>注解也加上。</p><p><em>实现：StatefulJob</em><br>有状态的 job 不能被并行执行，只有上一次触发的任务被执行完之后，才能触发下一次执行。<br>Job 和 StatefulJob 在框架中使用中存在两个关键差异：</p><ul><li>有状态的Job会<strong>在每次执行之后将JobDataMap重新持久化到JobStore中</strong>，这样就确保对 Job 数据的改变直到下次执行仍然保持着；而无状态的Job不会更新JobStore中的JobDataMap。</li><li>有状态的Job在被取出后状态会置为<code>BLOCKED</code>（表示真正执行），只有该次任务真正执行完成后才会变成<code>WAIT</code>状态；而无状态的Job在被取出后就会变成<code>WAIT</code>状态。</li></ul><div class="note note-primary">            <p>限制并发的对象是JobDetail，而不是Job或Trigger。因此若两个Trigger试图同一时刻执行相同的JobDetail会有一个Trigger阻塞等待。</p>          </div><h1 id="三、Quartz集群"><a href="#三、Quartz集群" class="headerlink" title="三、Quartz集群"></a>三、Quartz集群</h1><h2 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h2><p><em>定义</em><br>一个<strong>Quartz集群中的每个节点是一个独立的Quartz应用</strong>，在Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是<strong>通过同一个数据库表来感知到另一Quartz应用的</strong>。<br><img src="/Pasted%20image%2020231005184310.png"></p><p><em>集群配置</em></p><ol><li>配置Quartz集群数据库</li><li>为每个Quartz应用配置属性，同一集群下：<ul><li>instanceName必须相同</li><li>instanceId可自动生成</li><li>isClustered为true</li><li>持久化存储，指定数据库类型对应的驱动类和数据源连接。</li></ul></li></ol><h2 id="集群高可用"><a href="#集群高可用" class="headerlink" title="集群高可用"></a>集群高可用</h2><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p><em>数据行锁避免重复执行</em><br>一个调度器实例在执行涉及到分布式问题的数据库操作前，<strong>首先要获取QUARTZ_LOCKS表中对应的行级锁</strong>，获取锁后即可执行其他表中的数据库操作，<strong>随着操作事务的提交，行级锁被释放，供其他调度实例获取</strong>。集群中的每一个调度器实例都遵循这样一种严格的操作规程。</p><h3 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h3><p><em>故障发现</em></p><ol><li>每个节点Scheduler实例由<code>集群管理线程ClusterManager</code>周期性（默认是15 秒）定时检测CHECKIN数据库，遍历集群各兄弟节点的实例状态，检测集群各个兄弟节点的健康情况。</li><li>当集群中一个节点的Scheduler实例执行CHECKIN时，它会查看是否有其他节点的Scheduler实例在到达它们所预期的时间还未CHECKIN。若检测到有节点在预期时间未CHECKIN，则认为该节点故障。判断节点是否故障与节点Scheduler实例最后CHECKIN的时间有关，而判断条件：<code>LAST_CHECKIN_TIME + Max(检测周期，检测节点现在距上次最后CHECKIN的时间) + 7500ms &lt; currentTime。</code></li><li>集群管理线程检测到故障节点，就会更新触发器状态，状态更新如下：<br><img src="/Pasted%20image%2020231005185301.png"></li><li>集群管理线程删除故障节点的实例状态（<code>qrtz_scheduler_state</code>表），重置所有故障节点触发的任务。故障任务和正常任务一样就交由调度处理线程处理：<ul><li>任何标记为恢复的作业（在JobDetail上都具有“请求恢复(<code>requests recovery</code>)”属性）将被剩余的节点重新执行，已达到失效任务转移。</li><li>没有标记为恢复的作业将在下一次相关的Triggers触发时简单地被释放以执行。</li></ul></li></ol><p><em>负载均衡</em><br>负载平衡自动发生，群集的每个节点都尽可能快地触发Jobs。<strong>当Triggers的触发时间发生时，获取它的第一个节点（通过在其上放置一个锁定）是将触发它的节点</strong>。 因此哪个节点运行任务是随机的。<br>先获取Trigger的节点会修改其状态和下一次触发时间，保证了其他节点不会重复触发该任务。</p><blockquote><p>参考资料：<br><a href="https://zhuanlan.zhihu.com/p/128567942">quartz核心元素及底层原理介绍</a><br><a href="https://blog.csdn.net/wh_07/article/details/111063023">详解Quartz中的注解：@DisallowConcurrentExecution和@PersistJobDataAfterExecution</a><br><a href="https://www.cnblogs.com/MrSaver/p/11835374.html">Quartz学习笔记：集群部署&amp;高可用</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Quartz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Quartz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列常见问题</title>
    <link href="/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p><em>消息丢失可能出现的地方</em></p><ol><li>消息生产阶段产生消息丢失<ul><li>网络传输中丢失消息</li><li>MQ发送异常</li></ul></li><li>消息转发阶段产生消息丢失<ul><li>MQ成功接收消息后，内部处理出错</li><li>Broker宕机</li></ul></li><li>消息消费阶段产生消息丢失<ul><li>采用消息自动确认模式，消费者取到消息后未完成消费（或业务逻辑未执行完）</li></ul></li></ol><p><em>如何保证消息不会丢失？</em></p><ol><li>生产者：<ul><li>事务机制：开启事务后投递消息，若投递失败则事务回滚，然后重试。由于需要同步等待消息投递结果，造成阻塞，造成吞吐量下降。</li><li>确认机制：如RabbitMQ每次写的消息都会分配一个唯一的 ID。Broker在收到消息后，会返回一个Ack信号给生产者，确认消息发送成功。可以异步进行，不会产生阻塞。</li></ul></li><li>消息队列：开启持久化机制，对于集群多副本队列，保证至少写入若干台机器后才回复消息确认（具体写入多少台取决于对可用性的要求）</li><li>消费者：手动确认模式，消费者成功消费消息后，再确认。</li></ol><div class="note note-primary">            <p>基于ack机制在高并发模式下的限流控制：为了避免消费者积压大量消息导致OOM，可以为某channel设置最大unack消息数量，当超过该值时，停止向消费者推送消息。</p>          </div><p><em>如何解决重复消费的问题？</em><br><em>重复生产</em><br>消息队列对一个消息ID只做一次处理。具体地，消息队列会给每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID，消息队列的服务端会存储 &lt; 生产者 ID，最后一条消息 ID&gt; 的映射。当某一个生产者产生新的消息时，消息队列服务端会比对消息 ID 是否与存储的最后一条 ID 一致，如果一致，就认为是重复的消息，服务端会自动丢弃。</p><p><em>重复消费</em><br>为了保证消息不丢失，「失败重试」机制是必不可少的，必须考虑保证消费端的幂等性：</p><ul><li>通用层：消息ID幂等，对每个消息ID只做一次处理，但需要使用事务保证消息的消费和消息ID的持久化的一致性，代价较大。</li><li>应用层：业务上实现幂等，如乐观锁、状态机等。</li></ul><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p><em>有序性场景</em><br>保证消息按顺序执行，即保证「有序性」。「有序性」可分为全局有序和局部有序，全局有序要求所有消息按照投递顺序消费，局部有序则只要求某组消息实现顺序消费（如只需要对同一来源的消息进行顺序消费）</p><p><em>有序性实现</em></p><ol><li>全局有序：<ul><li>只能由一个生产者向 Topic 发送消息，并且一个 Topic 内部只能有一个队列（分区）</li><li>消费者也必须是单线程消费这个队列</li></ul></li><li>局部有序：<ul><li>将 Topic 内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中</li><li>每个队列对应一个单线程处理的消费者</li></ul></li></ol><h1 id="消息积压"><a href="#消息积压" class="headerlink" title="消息积压"></a>消息积压</h1><h3 id="消息积压概念"><a href="#消息积压概念" class="headerlink" title="消息积压概念"></a>消息积压概念</h3><p><em>原因</em><br>消费端消费消息过慢，导致大量消息积压在 MQ 中。<br><em>后果</em></p><ul><li>消息被丢弃：例如 RabbitMQ 有一个消息过期时间 TTL，过期的消息会被扔掉，这样消息就彻底没有了。</li><li>如果堆积量太大，可能导致磁盘空间不足，那么新消息就进不来了。</li><li>如果消息没过期，并且磁盘空间也够用，那么就是产生海量消息等待被消费，Consumer 的噩梦。</li></ul><h3 id="解决消息积压"><a href="#解决消息积压" class="headerlink" title="解决消息积压"></a>解决消息积压</h3><p><em>事前：预防与监控</em></p><ul><li>建设监控措施：监控broker的入口&#x2F;出口流量，便于快速发现和定位问题。</li><li>建设弹性扩容能力：根据监控动态提高消费者实例数量，需要公司有一定的弹性架构基础。</li></ul><p><em>事中：评估业务影响，止血</em></p><ul><li>发布方：系统降级，关闭一些不重要业务，减少发送方发送数据量，最低限度让系统还能正常运转。</li><li>中间件：<ul><li>消息丢弃：判断消息的丢弃是否是业务能容忍的，如果可容忍，则可以限制<strong>队列、消息的TTL</strong>或<strong>限制队列的大小、长度</strong>，丢掉队列中的消息或将其投递到死信队列。</li><li>磁盘空间：系统通常都是有监控的，达到空间阈值时就会发警报，在其他机器上创建临时的消息队列，再写一个临时的 Consumer，作为消息的中转，把消息积压队列中的消息取出来，放到临时队列里面去。</li><li>消费模式：更改消费模式，如拉-&gt;推-&gt;批推，消费者也要提前做相应改造。</li></ul></li><li>消费端：扩大消费者数量，通过提高消费速度实现快速处理：<ul><li>不需要保证顺序的，使用多线程&#x2F;多实例加快处理。</li><li>需要保证顺序的或无法扩大消费者数量的场景，按合理的顺序（局部有序）分发到多个指定队列中，即让消费者再次分流消息，实现快速处理。</li></ul></li></ul><p><img src="/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230922010212.png"><br><em>事后：快速处理海量积压消息</em><br>同事中，扩大消费者数量，通过提高消费速度实现快速处理。</p><div class="note note-primary">            <p><strong>在扩容消费者的实例数的同时，必须同步扩容主题 Topic 的队列（分区）数量，确保消费者的实例数和分区数相等。如果消费者的实例数超过了分区数，由于分区是单线程消费，所以这样的扩容就没有效果。</strong><br>比如在 Kafka 中，一个 Topic 可以配置多个 Partition（分区），数据会被写入到多个分区中。但在消费的时候，Kafka 约定一个分区只能被一个消费者消费，Topic 的分区数量决定了消费的能力，所以，可以通过增加分区来提高消费者的处理能力。</p>          </div><blockquote><p><a href="https://www.cnblogs.com/linwenbin/p/13382753.html">消息队列面试连环问：如何保证消息不丢失？处理重复消息？消息有序性？消息堆积处理？</a></p></blockquote><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="延迟队列概念"><a href="#延迟队列概念" class="headerlink" title="延迟队列概念"></a>延迟队列概念</h2><p><em>延迟队列定义</em><br>生产者把消息发送到消息队列中以后，并不期望被立即消费，而是等待指定时间后才可以被消费者消费，这类消息通常被称为<strong>延迟消息</strong>。</p><p><em>延迟队列应用场景</em><br>延迟消息的应用场景其实是非常的广泛，比如以下的场景：</p><ul><li>订单提交成功后1个小时内未支付，订单需要及时关闭并且释放对应商品的库存。</li><li>用户超过15天未登录时，给该用户发送召回推送。</li><li>工单提交后超过24小时未处理，向相关责任人发送催促处理的提醒。</li></ul><p><em>为什么要使用延迟队列？</em><br>如果不使用延迟队列，把任务存入数据库定期扫描（很多定时任务的实现方式）也能实现，但是会有一个问题：如果扫描时间间隔长了，执行时间不准，如果扫描间隔时间短了，那么对数据库压力比较大。</p><h2 id="延迟队列实现"><a href="#延迟队列实现" class="headerlink" title="延迟队列实现"></a>延迟队列实现</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>将消息按照到期时间（执行时间）排序，取队头元素判断是否到期：</p><ul><li>若不存在队头元素或队头元素没有到期则等待一小会后再次执行。</li><li>若队头元素到期了则继续取出下一个队头元素判断，直到所有到期的消息被取出。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><em>JDK的DelayQueue</em><br>JDK中的DelayQueue，其底层通过PriorityQueue、Condition实现。线程可以从中取出已经到期的消息，支持阻塞和非阻塞方式（没有到期元素则返回null）。</p><p><em>Redis的Zset</em><br>元素的score为预期执行时间，完整方案如下：<br><img src="/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230930214852.png"><br>如果到达了执行时间，执行 <code>zrem member</code>，<code>ZREM</code>执行这个命令有两个目的：</p><ol><li>从延迟队列中删除这条消息防止其它线程再次获取；</li><li>可能存在多个线程同时获取到这条消息，所以这里靠 zrem 只有返回 &gt; 0，才说明当前线程成功获取到消息，可以消费消息，如果返回 &#x3D; 0，说明已有其它线程抢先获取到消息了，当前线程不可以消费消息。</li></ol><p>缺点：</p><ul><li>单个有序集合无法支持太大的数据量。</li><li>定时任务不断读取可能造成不必要的请求。</li></ul><h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><code>wheel</code> ：时间轮，图中的圆盘可以看作是钟表的刻度，当需要添加任务时，将任务添加到当前时间指针的后 <code>延迟时间/每格时间</code> 格上（可以超过一圈，所以与hash的取模有点类似），其时间轮可以用简单的数组或者是环形链表来实现，该数据结构最重要的是两个指针：</p><ol><li>触发任务的函数指针</li><li>触发的总第几圈数</li></ol><p><img src="/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230930233227.png"><br>相比优先队列的数据结构，时间轮在算法复杂度上有一定优势。优先队列由于涉及到排序，需要调整数据的位置，插入和移除的复杂度是 <code>O(lgn)</code>，而时间轮在插入和移除的复杂度都是 <code>O(1)</code>。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p><em>netty的HashedWheelTimer</em><br>HashedWheelTimer是netty的一个工具类，该类用来计划执行非精准的I&#x2F;O超时。其默认时间间隔为100ms，格数为512格。</p><blockquote><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/21%20%20%E6%8A%80%E5%B7%A7%E7%AF%87%EF%BC%9A%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%E4%B9%8B%E6%97%B6%E9%97%B4%E8%BD%AE%20HashedWheelTimer.md">21 技巧篇：延迟任务处理神器之时间轮 HashedWheelTimer</a></p></blockquote><h3 id="定时扫描"><a href="#定时扫描" class="headerlink" title="定时扫描"></a>定时扫描</h3><p><em>Redis的过期回调</em><br><code>Redis</code> 的<code>key</code>过期回调事件，也能达到延迟队列的效果，开启监听key是否过期的事件，一旦key过期会触发一个callback事件。<br>Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 0 ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔。<br>因此， Redis 产生 expired 通知的时间为过期键被删除的时候， 而不是键的生存时间变为 0 的时候。</p><p><em>RabbitMQ的实现</em></p><ol><li>消息TTL：为消息设置TTL，当消息在TTL时间内未被消费时会被投递到死信队列，通过消费死信队列即可实现消息延迟，该方式只判断队头是否过期，因此若队头消息的TTL过大，后续的消息即使过期，也不一定会被马上丢弃。</li><li>队列TTL：为队列设置TTL，即队列中所有的消息在DTL时间内未被消费时都会被投递到死信队列，该方式会对队列进行定期扫描，只要消息生存时间超过队列TTL，就会立即被丢弃。</li><li>延迟队列插件：为消息声明TTL。延迟消息不会立刻投递到目标队列，而是会被存储在mnesia表中，RabbitMQ通过定期扫描，判断队列中到达可投递时间的消息，然后将其投递到对应的队列。</li></ol><p>前两种方案本质上是优先队列方案，其只会判断队头元素的过期时间，由于RabbitMQ的架构，master单节点会导致性能瓶颈，吞吐量受限。</p><p><em>ActiveMQ的实现</em><br>类似RabbitMQ的延迟队列插件，缺点也一致。</p><p><em>RocketMQ的实现</em><br>在开源版的RocketMQ中，支持延迟消息，但是不支持任意时间精度的延迟消息，只支持特定级别的延迟消息。如果要支持任意时间精度，不能避免在Broker层面做消息排序，再涉及到持久化的考量，那么消息排序就不可避免产生巨大的性能开销。Rocket通过规范延迟的时间精度，每个延迟时间级别对应一个独立的队列，因此只需要判断这些队列的队头消息是否到达延迟时间即可。<br>优点是支持分布式、高吞吐量、高性能、高可靠，缺点则是仅支持18个特定级别的延时，且无法自定义延时时间。</p><p><em>RocketMQ的改造</em><br>不支持自定义延时时间的RocketMQ是开源版的，在阿里云中商业版的RocketMQ是支持的。对于开源版，分析其原理：<br><img src="/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231001005533.png" alt="改造前"><br>可以将规范的的延迟时间作为基本延迟单位，为消息做多次延迟实现自定义延迟时间。<br><img src="/2023/09/22/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231001005540.png" alt="改造后"></p><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><p><em>JAVA的定时任务</em><br>ScheduledExecutorService底层通过<code>ReentrantLock.newCondition().awaitNanos(long nanosTimeout)</code>方法实现的定时等待，其在每次执行完成后会调用<code>setNextRunTime()</code>来设置下次需要调度的时间，然后根据当前时间和下次执行时间的差值进行<code>await()</code>。</p><div class="note note-primary">            <p><em>延迟队列与定时任务的关系？</em><br>延迟队列本身就是对定时任务的一种实现，只是指定了该任务的行为是消息投递行为，因此所有对定时任务的在计时层面上的实现都可以适用于延迟队列。</p>          </div><blockquote><p><a href="https://segmentfault.com/a/1190000039354865">延迟队列的几种实现方案</a><br><a href="https://www.cnblogs.com/heihaozi/p/14266311.html">延迟消息的五种实现方案</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>消息队列常见问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java常见问题</title>
    <link href="/2023/09/18/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/18/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><em>ArrayList和LinkedList插入速度？</em></p><ul><li>结论：ArrayList在绝大部分时候的性能都明显要强于LinkedList，LinkedList只有在头部插入元素的时候，性能会明显优于ArrayList。</li><li>原因：<ul><li>头部插入时，LinkedList直接维护了头节点，而ArrayList需要重排数组，故LinkedList快。</li><li>中间插入时，两者都需要遍历，但ArrayList底层是数组（内存上是连续的，遍历更快），故ArrayList快</li><li>尾部插入时，ArrayList不需要重排数组，故ArrayList快</li></ul></li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><em>Java序列化有什么风险隐患？</em></p><ul><li>我们使用Java原生功能序列化出<code>byte[]</code>后在网络或磁盘上进行共享、传输，可能会被在数据层面上篡改。</li><li>Java反序列化过程中，会首先调用<code>readObject</code>。且当我们在序列化&#x2F;反序列化过程中需要实现特殊签名时，可以自行实现<code>readObject</code>方法，这会导致代码注入，其可能会包括恶意代码。</li></ul><p><em>泛型可以序列化吗？</em></p><ul><li>结论：可以，但反序列化时需要指明泛型类型</li><li>现象：对于泛型类的对象，其反序列化后得到的时LinkedHashMap。</li><li>原因：泛型擦除导致JVM运行时不知道泛型的具体类型，如<code>List&lt;User&gt;</code>，反序列化时系统只知道还原成List，于是Jaskson就使用了默认的<code>List&lt;LinkedHashMap&gt;</code>，所以需要指明泛型类型才能正确的反序列化。</li></ul><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><em>Java如何保证线程安全？</em><br>线程安全在三个方面体现：原子性、可见性、有序性：</p><ol><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作（atomic,synchronized）；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到（synchronized,volatile,final）；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序（volatile,synchronized,happens-before原则）。</li></ol><div class="note note-primary">            <p>线程安全中的原子性实际上指的是一种互斥性：其他线程获取操作的变量时，<strong>只能获取操作前的变量值和操作后的变量值</strong>，不能获取到操作过程中的中间值，在操作过程中其他操作需要获取变量值，需要进入<strong>阻塞状态</strong>等待操作结束。</p>          </div><p><em>Lock和Synchronize的区别？</em></p><ul><li>层次上：lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</li><li>底层上：synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁&#x2F;争抢锁，依赖字节码；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得&#x2F;争抢，依赖CAS乐观锁。</li><li>锁的功能上：<ul><li>synchronized锁隐式的<strong>限定了锁的获取和释放位置</strong>，导致某线程获取锁的顺序总是先获取先释放（栈式），满足不了更多的需要，而lock手动获取释放；</li><li>synchronized只实现了<strong>互斥锁</strong>，且无法被中断（而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去）；</li><li>lock可以选择是否<strong>公平</strong>；</li><li>condition上，synchronized只有一个waitset，而lock可以有多个condition。</li></ul></li><li>锁的使用：<ul><li>获取：synchronized获取锁失败会阻塞，lock则可以通过tryLock非阻塞的获取锁。</li><li>释放：synchronized方法异常后会自动放弃锁，lock必须手动finally释放；</li><li>可中断：lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li><li>性能上：在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态，但lock可以实现读写分离。</li></ul></li></ul><p><em>原子类原理</em><br>原子变量提供的原子性来自CAS操作，CAS来自Unsafe，然后由CPU的cmpxchg指令来保证。</p><p><em>原子类能保证线程安全吗</em><br>Atomic所说的线程安全只是保证了原子方法的线程安全，并不能保证整个方法（如多个连续原子操作）是线程安全的，因此，原子类往往还是需要结合锁来共同实现线程安全。</p><p><em>ABA问题</em><br>ABA问题的实质是：在并发编程中，仅靠检查变量的值是无法知道这个变量是否被改动过的，还要加上一个版本号（当变量改变就改变其版本号）才能确定变量保持不变。<br>AtomicStampedReference实现了此功能，它保存变量引用的同时，还赋予此变量一个版本号。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><em>线程池的基本参数</em><br>共七个参数，一般使用前五个参数。</p><ul><li><strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>阻塞队列</strong>是限制大小的。</li><li><strong>存活时间</strong>和<strong>单位</strong>是管理非核心线程的。</li><li><strong>工厂</strong>管理生成线程策略（默认为<strong>正常优先级、非守护线程</strong>）。</li><li><strong>处理器</strong>决定饱和策略（默认为<strong>拒绝执行并抛出异常</strong>）。</li></ul><p><em>execute和submit的区别</em></p><ul><li>execute用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li><li>submit用于提交需要返回值的任务，线程池会返回一个 Future 类型的对象。</li></ul><p><em>怎么中断线程池</em></p><ul><li>方法：<ul><li>shutdown：禁止添加新任务</li><li>shutdownNow：禁止添加新任务，禁止执行队列中的任务</li></ul></li><li>原理：<ul><li>状态：shutdown将线程池标记为<code>SHUTDOWN</code>状态，shutdownNow将线程池标记为<code>STOP</code>状态，待线程池数量变为0后进入<code>TIDYING</code>状态，最后变为<code>TERMINATED</code>状态。</li><li>线程：shutdown会对所有空闲线程调用中断，shutdownNow会对所有线程调用中断。</li></ul></li><li>工作方式：根据线程池状态，一个线程可以判断当前任务执行完成后的行为：<ul><li>shutdown：继续从任务队列中取任务执行，直到没有任务后执行<code>tryTerminate()</code></li><li>shutdownNow：直接执行<code>tryTerminate()</code></li></ul></li></ul><p><em>线程池中线程如何实现复用，终止</em><br>通过<code>addWorker()</code>方法新增的线程，通过<code>getTask()</code>循环从任务队列中取出任务执行，若返回null则该线程终止。<br><code>getTask()</code>会做一系列的判断：</p><ol><li>线程池状态判断：<code>SHUTDOWN+队列无任务</code> 或 <code>STOP</code>会直接返回空对象。</li><li>线程池大小判断：（<code>线程数量&gt;最大线程数量</code> 或 <code>线程数量&gt;核心线程数量+本线程获取任务超时</code> ） 且任务队列中无任务时，直接返回空对象。</li></ol><div class="note note-primary">            <p>若任务队列中无任务，且线程数量大于核心线程数量并超时，即可终止该线程。</p>          </div><p><em>创建线程的方式？</em></p><ol><li>继承Thread</li><li>new Thread + Runnable</li><li>new Thread + Future(Callable)</li></ol><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p><em>垃圾回收算法有哪些？</em></p><ul><li>标记：引用计数算法和可达性算法（root包括栈和方法区引用，同步锁对象，脏表上的对象等）。<ul><li>判断对象是否可直接回收，finalize()方法可能复活，需要交付给F-Queue队列执行finalize方法，执行后GC再扫描该队列看是否可触及。</li></ul></li><li>回收：标记-清除算法、复制算法、标记-压缩算法、增量收集（G1）</li><li>分配内存方法：指针碰撞法、空闲列表法</li></ul><p><em>应用</em><br>复制算法一般在YoungGC中，迁移到Survivor。<br>标记压缩算法一般在OldGC中。<br>标记清除算法一般在CMS或G1的GC中，因为其需要并发标记清除。<br>增量收集只在G1中。</p><p><em>垃圾回收器分类</em></p><ul><li>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。  </li><li>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。  </li><li>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。  </li><li>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</li></ul><p><em>经典垃圾回收器</em><br><img src="/2023/09/18/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230326233958.png"></p><ul><li>Serial GC&#x2F;Serial Old GC：单线程、STW、复制&#x2F;标记压缩算法（JDK8下的默认Client）</li><li>ParNew：多线程版Serial GC</li><li>Parallel Scavenge&#x2F;Parallel Old：多线程、STW、复制&#x2F;标记压缩算法，追求吞吐量（JDK8下的默认Server）</li><li>CMS（JDK9中已过时）：单&#x2F;多线程，重新标记时使用多线程，低延迟。（三色标记法，若对象A新增了指向其他对象的指针，则将A标记为灰色）</li><li>G1：延迟可控的情况下吞吐量，一般设置延迟和最大堆内存即可。<ul><li>YoungGC：复制算法，整理Region</li><li>MixedGC：<ul><li>并发标记：先做一次YoungGC，然后并发标记（三色标记法若对象B被取消了指针，将B标记为灰色），区域排序，并发清理（清理全为垃圾的区域）</li><li>混合回收：分8次回收所有区域，每次回收与YoungGC类似（复制算法整理Region）</li></ul></li><li>FullGC：复制算法时没有空的内存分段，回退到FullGC</li></ul></li></ul><p><em>JVM调优过吗？怎么调整的？</em><br>数据采集类的程序需要进行大量的IO操作，属于IO密集型系统，这种系统的年轻代持续会产生大量的垃圾，导致了频繁的YoungGC，为了避免频繁的YoungGC导致的卡顿，选择提高年轻代的比例：<code>-XX:NewRatio = 2</code>，表示 <code>新生代:老年代 = 1:2</code><br>另外，系统需要预加载的类较多：<code>-XX:MetaspaceSize</code>，设置初始元空间大小，设置大一点，以免项目启动时为了调整元空间大小频繁Full GC。</p><p><em>其他JVM配置</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">//大小设置<br>-Xms&lt;size&gt; 设置初始 Java 堆大小  <br>-Xmx&lt;size&gt; 设置最大 Java 堆大小  <br>-Xss&lt;size&gt; 设置 Java 线程堆栈大小<br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8  <br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br><br>//快照<br>-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件<br><br>//GC选择<br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务<br>//GC信息<br>-XX:+PrintGC 打印简要日志信息<br>-verbose:gc 打印简要日志信息，等效于PrintGC<br>-XX:+PrintGCDetails 输出详细GC日志<br>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息<br>-XX:+TraceClassLoading 监控类的加载<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br><br>[GC(原因)][GC回收器：年轻代回收前内存占用-&gt;年轻代回收后内存占用（区域总内存）]总内存变化，时间][时间：用户时间，核心时间，实际时间]<br></code></pre></td></tr></table></figure><p><em>JVM排查工具</em></p><ul><li><code>jps</code>，查看java进程</li><li><code>jstat</code>，查看统计信息</li><li><code>jinfo</code>，JVM参数</li><li><code>jmap</code>，内存dump文件</li><li><code>jstack</code>，线程快照</li><li><code>Arthas</code>：在线远程排查，需要在服务端开启arthas，客户端对其进行连接；<ul><li>启动：<code>java -jar arthas-boot.jar</code>，选择进程后开启监控面板；</li><li><code>thread 1</code>打印线程id为1的栈；</li></ul></li><li><code>JProfiler</code>：有样本采集（每隔一段时间快照）和重构模式（侵入式统计）两种模式。</li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>JAVA NIO是同步非阻塞IO。<br><strong>同步和异步说的是消息的通知机制，阻塞非阻塞说的是线程的状态 。</strong></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><p><em>有哪些常见的事务传播级别？</em></p><ul><li>REQUIRED（默认值）：在有transaction状态下执行；如当前没有transaction，则创建新的transaction；</li><li>REQUIRES_NEW：创建新的transaction并执行；如果当前已有transaction，则将当前transaction挂起；</li><li>NESTED ：和 Propagation.REQUIRED 效果类似，区别在于：子事务的提交依赖于主事务，但子事务的回滚不依赖于主事务（即如果子事务异常会直接回滚，而主事务如果catch掉了这个异常，则主事务不会回滚）</li><li>MANDATORY：必须在有transaction状态下执行，如果当前没有transaction，则抛出异常IllegalTransactionStateException；</li><li>SUPPORTS：如当前有transaction，则在transaction状态下执行；如果当前没有transaction，在无transaction状态下执行；</li><li>NOT_SUPPORTED：在无transaction状态下执行；如果当前已有transaction，则将当前transaction挂起；</li><li>NEVER：在无transaction状态下执行；如果当前已有transaction，则抛出异常IllegalTransactionStateException。</li></ul><p><em>事务传播级别使用需要注意什么？</em></p><ol><li>业务需求，对于事务中开启的新事务，需要理清它们之间的一致性关系。</li><li>使用注意：<ol><li>同类中的@Transaction方法无法互相调用，原因是AOP的机制</li><li>嵌套类型，需要考虑外层事务与嵌套事务是否一起回滚，不能随意的catch异常。</li></ol></li></ol><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p><em>观察者模式</em><br><strong>观察者模式</strong>也称作监听模式，即观察与被观察的关系，其是指对象之间<strong>一对多</strong>的依赖关系，每当那个特定对象改变状态时，所有依赖于它的对象都会得到通知并被自动更新。</p><p><em>对同一方法而言，不同执行顺序会产生不同事件结果，应该选择哪种设计模式？</em><br>状态模式、建造者模式</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java常见问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记</title>
    <link href="/2023/09/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/Spring%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/Spring%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><h2 id="IOC概念"><a href="#IOC概念" class="headerlink" title="IOC概念"></a>IOC概念</h2><p><em>IOC定义</em><br>控制反转指的是在程序中，<strong>原本需要手动创建的对象现在可以由 Spring 的 IoC 容器帮助创建和注入依赖对象</strong>，只需要告诉容器什么时候创建对象、创建什么对象，完全不用考虑对象是怎么创建出来的。</p><p><em>传统程序设计与IOC模式的区别</em></p><ul><li>传统程序设计：用户主动创建对象并将其关联</li><li>IOC：只需要通知IOC容器执行</li></ul><p><em>Spring Bean定义</em><br>bean 是对象，由 Spring  IOC 管理，Spring应用程序由一个个bean构成。</p><p><em>生成bean的方式有哪些？</em></p><ul><li>@Component ：通⽤的注解，可标注任意类为 Spring 组件，如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注；</li><li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作；</li><li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑；</li><li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯。</li><li>@Bean：@Configuration 标识一个Spring Boot 配置类，Spring将会扫描该类中是否存在@Bean 注解的方法，创建方法的返回值。</li><li>@Import：创建指定类的对象并注入容器中。</li><li>ImportSelector&#x2F;ImportBeanDefinitionRegistrar：使用这些接口，配合@Import实现。</li><li>DefaultListableBeanFactory：通过<code>registerSingleton(String beanName,Object object);</code>手动注入。</li></ul><p><em>bean 的作用域</em></p><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>在Spring ioc 容器中仅存在一个Bean实例，Bean以单例方式存在，默认值</td></tr><tr><td>prototype</td><td>每次从容器中调用Bean时，都会返回一个新的实例，即每次调用getBean()时，相当于执行new XXxBean()</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td></tr><tr><td>session</td><td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td></tr><tr><td>global-session</td><td>一般用于Portlet应用环境，该作用域仅适用于WebApplicationContext环境，全局会话，所有会话共享一个实例。</td></tr></tbody></table><p><em>单例bean的线程安全问题</em></p><ul><li>原因：因为成员变量是存放在堆内存中，而堆内存又是线程共享的，这就造成了<strong>线程安全问题</strong></li><li>解决：<ul><li>在类中定义ThreadLocal成员变量，实现线程之间的资源隔离。</li><li>只要求实现可见性的对象，可以通过volatile+CAS或悲观锁实现。</li></ul></li></ul><p><em>Spring IOC容器初始化过程（Bean创建过程）</em><br><img src="/Pasted%20image%2020231006143551.png"></p><ol><li><strong>读取Bean定义信息</strong>：通过BeanDefinitionReader这个接口解析xml配置、配置类或其他的一些方式定义的类，得到BeanDefinition（Bean定义信息）</li><li><strong>实例化Bean</strong>：通过<code>BeanPostProcessor</code>这个接口（增强器）可以对<strong>BeanDefinition进行一些修改</strong>，然后BeanFactory通过反射实例化Bean对象，但是此时的Bean对象还没有进行初始化，没有填充属性等操作。</li><li><strong>初始化Bean</strong>：<ol><li>自定义属性赋值是用 set 方法赋值populateBean()</li><li>容器对象的属性赋值是用实现Aware接口的方式来赋值（invokeAwareMethods()），如BeanNameAware</li><li>调用BeanPostProcessor的前置处理方法</li><li>调用init初始化方法：init-method</li><li><strong>调用BeanPostProcessor的后置处理方法（AOP在这里实现）</strong></li><li>获得一个完整的对象，并将对象放入map中（通过Context.getBean()可以获取到Bean对象并使用）</li></ol></li><li><strong>销毁Bean</strong>：Spring容器关闭时会调用DisposableBean的Destory()方法，如果在这个Bean中配置了destory-method属性，会自动调用指定的销毁方法。</li></ol><p><em>Bean的生命周期</em></p><ol><li>通过解析配置类、注解类或者以其他方式定义的类，得到BeanDefinition（Bean定义信息）</li><li>BeanFactory通过获取到的BeanDefinition，利用反射创建Bean对象</li><li>通过populateBean()方法对Bean对象进行属性填充</li><li>通过invokeAwareMethods()方法对Bean对象进行赋值</li><li>调用BeanPostProcessor的初始化前置方法</li><li>调用init-method方法，进行初始化操作</li><li>调用BeanPostProcessor的初始化后置方法（AOP在此处进行）</li><li>将创建好的Bean对象放入map容器中</li><li>通过Context.getBean()方法获得Bean对象并使用</li><li>spring容器关闭时会调用DisposableBean的destory()方法销毁Bean对象（如果配置了destory-method属性，spring会自动调用指定的销毁方法）</li></ol><h2 id="DI概念"><a href="#DI概念" class="headerlink" title="DI概念"></a>DI概念</h2><p><em>DI定义</em><br>依赖注入（DI）是控制反转的具体实现方式，指的是程序所依赖的组件在运行时会动态地加载到程序中。</p><p><em>依赖注入的原理</em><br>依赖注入就是通过反射给成员变量赋值，方式有三种：</p><ol><li>通过构造器给变量赋值</li><li>通过set方法给变量赋值</li><li>直接给属性赋值</li></ol><p><em>依赖注入的方式有哪些？</em></p><ul><li>@Autowired：默认是根据<strong>类型</strong>注入，默认byType，存在多个同类型则根据bean名称注入。可以用于构造器、字段、方法注入。</li><li>@Qualifier：常常组合@Autowired一起使用，用来指明具体名字的自动装配。</li><li>@Resource：由J2EE提供，默认byName，相当于 @Autowired + @Qualifier。</li><li>@Value：用来注入基本类型和String类型，可以使用SpEL表达式。</li><li>构造器注入：编写构造器方法并配置xml</li><li>set方法注入：编写set方法并配置xml</li></ul><blockquote><p>@Autowired的属性不需要写set方法，Spring通过反射为属性直接进行赋值。</p></blockquote><p><em>Spring三级缓存？</em><br>Spring在启动过程中，使用到了三个map，称为三级缓存：</p><ul><li>一级缓存singletonObjects</li><li>二级缓存earlySingletonObjects</li><li>三级缓存singletonFactories</li></ul><p>不允许循环依赖时，使用一级缓存即可，允许循环依赖时，需要使用二、三级缓存。</p><p><em>Spring如何解决循环依赖</em><br>获取一个bean的方式：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">getBean<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> creatBeanInstance<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> populateBean<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> initailizeBean<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> 后置处理AOP -&gt; 加入单例池<br></code></pre></td></tr></table></figure><ul><li>问题：当创建<code>BeanA</code>时，在填充属性阶段需要使用到<code>BeanB</code>，则调用<code>getBean(&quot;B&quot;)</code>。但若<code>BeanB</code>也依赖<code>BeanA</code>，则会调用<code>getBean(&quot;A&quot;)</code>，造成死循环。</li><li>解决思路：引入半成品池，在<code>BeanA</code>实例化时将其放入半成品池，这样<code>BeanB</code>获取<code>BeanA</code>时则先从单例池找，找不到再到半成品池中找，即可解决循环依赖。</li><li>为什么需要引入三级缓存：因为二级缓存解决不了AOP代理问题，AOP代理发生在初始化后，其会对Bean进行包装。所以通过半成品池获取到的是对象本身，而不是<code>Proxy$A</code>。</li><li>三级缓存：<code>BeanA</code>实例化时，先放入工厂池，即<code>factory(A)</code>,当<code>BeanB</code>填充属性时调用<code>getBean(&quot;A&quot;)</code>时，在工厂池中找到<code>factory(A)</code>，调用其<strong>提前引用方法（getEarlyBeanReference）</strong>，即提前创建AOP对象，再将其放入半成品池供<code>BeanB</code>依赖。</li></ul><div class="note note-primary">            <p>简而言之，由于AOP默认发生在初始化Bean后，而在循环依赖中需要将AOP提前，因此多引入一个工厂池：</p><ul><li>当发生循环依赖时则将工厂池中对象提前AOP并放入半成品池。</li><li>若无循环依赖则直接将对象放入半成品池，依然使用后置AOP。</li></ul>          </div><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p><em>什么是Spring MVC</em><br>在 Spring MVC 下，⼀般把后端项⽬分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层。</p><p><em>SpringMVC 的核心入口类是什么</em><br>DispatchServlet</p><p><em>SpringMVC 的控制器是不是单例模式？</em><br>是单例模式，所以在多线程访问的时候有线程安全问题，但不能使用<code>synchronize</code>，会影响性能的，其解决方案是在控制器提供属性，即无状态。</p><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p><strong>OOP（面向对象编程）</strong> 针对业务处理过程的<strong>实体及其属性和行为进行抽象封装</strong>，以获得更加清晰高效的逻辑单元划分，但<strong>无法聚焦提供某一功能，如日志</strong>。<br><strong>AOP（面向切面编程）针对业务处理过程中的切面进行提取</strong>，它所面对的是<strong>处理过程</strong>中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。<br><strong>AOP是OOP的延续</strong>，是函数式编程的一种衍生范型。</p><h2 id="SpringAOP与AspectJ"><a href="#SpringAOP与AspectJ" class="headerlink" title="SpringAOP与AspectJ"></a>SpringAOP与AspectJ</h2><h3 id="框架定位"><a href="#框架定位" class="headerlink" title="框架定位"></a>框架定位</h3><ul><li>Spring AOP是基于Spring IoC实现的，它解决大部分常见的需求（<strong>方法级织入</strong>），属于动态代理。</li><li>AspectJ旨在提供完整的AOP方案，属于静态代理</li></ul><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>Spring依赖于AspectJ，但Spring AOP只是使用了aspectJ的注解，并没有使用它的编译期和织入器。</p><blockquote><p>Aspectj的拦截器会被解析成AOP中的advice，最终被适配成MethodInterceptor，这些都是Spring自动完成的，底层见Spring AOP实现。</p></blockquote><h3 id="主要对比"><a href="#主要对比" class="headerlink" title="主要对比"></a>主要对比</h3><p><img src="/Pasted%20image%2020230914220440.png"></p><p>Spring AOP动态代理使用了Cglib代理和JDK动态代理，与AspectJ的对比如下：<br><img src="/Pasted%20image%2020230914223332.png"></p><h4 id="织入方式对比"><a href="#织入方式对比" class="headerlink" title="织入方式对比"></a>织入方式对比</h4><h5 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h5><p><strong>运行前织入</strong>，分为三类：</p><ul><li>编译时织入：如果类A使用AspectJ添加了一个属性，类B引用了A，这种场景就需要进行编译期织入。</li><li>编译后织入：如果已经生成了class文件，需要增强处理，则需要编译后织入。</li><li>加载时织入：如果需要在加载类的时候增强，则需要加载时织入。</li></ul><p>因此，AspectJ是需要<strong>AspectJ编译器</strong>支持。</p><h5 id="Spring-AOP-1"><a href="#Spring-AOP-1" class="headerlink" title="Spring AOP"></a>Spring AOP</h5><p><strong>运行时织入</strong>，主要分两类：</p><ul><li>CGlib代理（SpringBoot 2.x默认，为了解决动态代理可能导致的类型转化异常）</li><li>JDKProxy（Spring默认，如果未实现接口，则使用CGlib代理）</li></ul><blockquote><p>在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项<code>spring.aop.proxy-target-class=false</code>来进行修改，<code>proxyTargetClass</code>配置已无效。</p></blockquote><p><em>CGLib vs JDKProxy</em></p><ul><li>jdk动态代理生成类速度快（8倍），调用慢，cglib生成类速度慢，但后续调用快（10倍），因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反正，则比较适用JDK动态代理。</li><li>随着jdk升级，jdk动态代理的速度越来越快：<ul><li>jdk6，JDK动态代理的速度要比CGLib动态代理的速度要慢。</li><li>jdk7，谁快取决于调用次数，1W次时JDK动态代理快，10W次时CGLib快。</li><li>jdk8，JDK动态代理的速度已经比CGLib动态代理的速度快很多了。</li></ul></li></ul><p><img src="/Pasted%20image%2020230914205347.png"></p><p><em>为什么jdk动态代理比cglib快？</em><br>CGLib底层采用ASM字节码生成框架，使用字节码技术生成被代理类的一个代理子类。</p><p><em>为什么spring体系整体转投Cglib呢，jdk动态代理又有什么缺点呢？</em><br>jdk动态代理只能基于接口，代理生成的对象只能赋值给接口变量，而Cglib就不存在这个问题，Cglib是通过生成子类来实现的，代理对象既可以赋值给实现类，又可以赋值给接口。</p><h5 id="同类方法调用"><a href="#同类方法调用" class="headerlink" title="同类方法调用"></a>同类方法调用</h5><p><em>同类方法调用</em><br>调用同一类中的方法时，不会调用 Spring AOP 提供的代理的方法。如果我们需要这个功能，那么我们必须在不同的 bean 中定义一个单独的方法，或者使用 AspectJ。</p><h4 id="增强点对比"><a href="#增强点对比" class="headerlink" title="增强点对比"></a>增强点对比</h4><p><img src="/Pasted%20image%2020230914214834.png"></p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><p>编译织入会比较运行时织入快很多，Spring AOP是使用代理模式在运行时才创建对应的代理类，效率没有AspectJ高。（AspectJ快8-35倍）</p><h4 id="其他对比"><a href="#其他对比" class="headerlink" title="其他对比"></a>其他对比</h4><p><em>为什么有AspectJ还要使用Spring AOP？</em><br>Spring AOP 显然更简单, 因为它不会在我们的构建过程中引入任何额外的编译器或织入。它使用运行时编织, 因此它与我们通常的构建过程无缝集成。<br>但是，要使用 AspectJ, 我们需要引入 AspectJ 编译器 (ajc) 并重新打包所有的库 (除非我们切换到编译后或加载时间的织入)。</p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li><strong>框架</strong>: 如果应用程序没有使用 spring 框架, 那么我们就别无选择, 只能放弃使用 spring AOP 的想法, 因为它无法管理任何超出 spring 容器范围的东西。但是, 如果我们的应用程序是完全使用 spring 框架创建的, 那么我们可以使用 spring AOP, 因为它是简单的学习和应用</li><li><strong>灵活性</strong>: 由于有限的 joinpoint 支持, Spring aop 不是一个完整的 aop 解决方案, 但它解决了程序员面临的最常见的问题。尽管如果我们想深入挖掘和开发 AOP 以达到其最大能力, 并希望得到广泛的可用 joinpoints 的支持, 那么最好选择 AspectJ</li><li><strong>性能</strong>: 如果我们使用的是有限的切面, 那么就会有细微的性能差异。但有时, 应用程序有成千上万个切面的情况。我们不想在这样的情况下使用运行时编织, 所以最好选择 AspectJ。AspectJ 已知的速度比 Spring AOP 快8到35倍</li><li><strong>两者的最佳之处</strong>: 这两个框架都是完全兼容的。我们总是可以利用 Spring AOP； 只要有可能, 仍然可以在不支持前者的地方使用 AspectJ 获得支持。</li></ul><h2 id="使用与原理"><a href="#使用与原理" class="headerlink" title="使用与原理"></a>使用与原理</h2><h3 id="AspectJ-1"><a href="#AspectJ-1" class="headerlink" title="AspectJ"></a>AspectJ</h3><p><em>五种通知类型</em><br><img src="/Pasted%20image%2020230915103103.png"><br><img src="/Pasted%20image%2020230914222648.png"><br>可以使用<code>@Order</code>注解配置Aspect的优先级。</p><p><em>使用方式</em></p><ul><li>使用AspectJ语言，该语言类似于Java，只是多了一些关键词。</li><li>使用Java语言，并使用@Aspect注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ControllerAspect</span> &#123;<br><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.test.springboot.controller..*.*(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPointcut</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Before(&quot;testPointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;------test aop doBefore start------&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>        log.info(<span class="hljs-string">&quot;------test aop doBefore end------&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">// around的参数是ProcedingJoinPoint，其继承了JoinPoint，但暴露了proceed()方法，即继续执行拦截器链</span><br>    <span class="hljs-meta">@Around(&quot;testPointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.info(<span class="hljs-string">&quot;------test aop doAround start------&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        log.info(<span class="hljs-string">&quot;Execution Time: &quot;</span> + (end - start) + <span class="hljs-string">&quot; ns&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;------test aop doAround end------&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>配置织入时机</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 编译期织入，用于编译.aj文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">complianceLevel</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">complianceLevel</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">showWeaveInfo</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">showWeaveInfo</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Xlint</span>&gt;</span>ignore<span class="hljs-tag">&lt;/<span class="hljs-name">Xlint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>test-compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--编译后织入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">complianceLevel</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">complianceLevel</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">weaveDependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">weaveDependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.javadoop<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectj-learning-share<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">weaveDependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">weaveDependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--加载后织入，需要修改JVM启动参数，并添加aop.xml文件，见下面参考文档--&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>AspectJ本质是通过使用<strong>Acj编译器</strong>来编译<code>.aj</code>文件为<code>.class</code>文件，然后在编译目标类时织入，即先编译aspect类再编译目标类。</p></blockquote><h3 id="Spring-AOP-2"><a href="#Spring-AOP-2" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="切面原理"><a href="#切面原理" class="headerlink" title="切面原理"></a>切面原理</h4><h5 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h5><p><img src="/Pasted%20image%2020230915122813.png"><br><em>通知类型</em><br>spring aop中4种通知（Advice）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.aopalliance.intercept.MethodInterceptor org.springframework.aop.MethodBeforeAdvice org.springframework.aop.AfterReturningAdvice org.springframework.aop.ThrowsAdvice<br></code></pre></td></tr></table></figure><p>所有的通知最终都需要转换为<code>MethodInterceptor</code>类型的通知，然后组成一个<code>MethodInterceptor列表</code>，一般称之为方法调用链或者拦截器链。</p><p><em>MethodInterceptor使用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建方法通知</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是MethodInterceptor start&quot;</span>);<br>        <span class="hljs-comment">// proceed执行中，会一次调用MethodBeforeAdvice、AfterReturningAdvice/AfterThrowingAdvice</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;我是MethodInterceptor end&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>Advice使用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建前置通知</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMethodBeforeAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] args, <span class="hljs-meta">@Nullable</span> Object target)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是MethodBeforeAdvice&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MethodBeforeAdvice</code>最终会被包装为<code>MethodBeforeAdviceInterceptor</code>类型，然后放到拦截器链中去执行。其他类型Advice同理。</p><p><em>执行顺序</em><br><img src="/Pasted%20image%2020230915115925.png"></p><h5 id="Aspect"><a href="#Aspect" class="headerlink" title="@Aspect"></a>@Aspect</h5><p><em>通知类型</em><br><code>@Aspect</code>本身是AspectJ的注解，Spring AOP使用了这个注解，但底层使用了MethodInterceptor实现，五大通知对应：<br><img src="/Pasted%20image%2020230915115049.png"><br>执行顺序如下，与AspectJ中的执行逻辑一致。<br><img src="/Pasted%20image%2020230915120540.png"></p><p><em>Advisor与Aspect？</em></p><ul><li>相同点：Advisor是一种特殊的Aspect，其专注于定义某一个通知。</li><li>不同点：<ul><li>定义：aspect用于定义切面，advisor用于定义通知器。</li><li>场景：在面向<strong>切面编程</strong>时，常使用&lt; aop:aspect&gt;；在进行<strong>事务管理</strong>时，常使用&lt; aop:advisor&gt;。</li><li>使用：aspect可以定义多个pointcut和多个advice，类似@Aspect；advisor定义一个通知及其切点，通知的实现类需要实现MethodInterceptor接口，类似Advice。</li></ul></li><li>总结：advisor和aspect其实都是将通知和切面进行了封装，原理基本上是一样的，只是使用的方式不同而已。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- advisor，自定义myAdvisor继承MethodBeforeAdvice即可 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *.sleep(..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sleepPointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;myAdvisor&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;sleepPointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- aspect,--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *.sleep(..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sleepPointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sleepHelperAspect&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--前置通知--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;beforeSleep&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;sleepPointcut&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--后置通知--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterSleep&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;sleepPointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="多Advisor和-Aspect的执行顺序"><a href="#多Advisor和-Aspect的执行顺序" class="headerlink" title="多Advisor和@Aspect的执行顺序"></a>多Advisor和@Aspect的执行顺序</h5><p><em>@Aspect指定顺序</em><br>使用@Order注解，值越小，优先级越高</p><p><em>Advisor指定顺序</em><br>自定义的<code>Advisor</code>通过<code>org.springframework.core.Ordered</code>接口来指定顺序，这个接口有个<code>public int getOrder()</code>方法，用来返回通知的顺序。<br>spring为我们提供了一个<code>Advisor</code>类型的抽象类<code>org.springframework.aop.support.AbstractPointcutAdvisor</code>，这个类实现了<code>Ordered</code>接口，spring中大部分<code>Advisor</code>会是继承<code>AbstractPointcutAdvisor</code>，若需要自定义<code>Advisor</code>，也可以继承这个类。</p><p><em>排序规则</em><br>在spring容器中获取@Aspect、Advisor类型的所有bean，得到一个列表，对这个列表按照order升序排列，然后分别对其内部通知进行排序。</p><p><em>执行规则</em><br>在Around通知中执行proceed会调用下一个Aspect，与AspectJ逻辑一致。<br><img src="/Pasted%20image%2020230914222648.png"></p><h4 id="代理原理"><a href="#代理原理" class="headerlink" title="代理原理"></a>代理原理</h4><h5 id="JDK动态代理原理"><a href="#JDK动态代理原理" class="headerlink" title="JDK动态代理原理"></a>JDK动态代理原理</h5><ol><li>首先通过实现一个 InvocationHandler 接口得到一个切面类。</li><li>然后利用 Proxy 糅合目标类的类加载器、接口和切面类得到一个代理类。</li><li>生成的代理类是会先在静态块中通过反射把所有方法都拿到存在静态变量中。</li><li>代理类的逻辑就是执行切入逻辑，把所有接口方法的调用转发到InvocationHandler 的 invoke() 方法上，然后根据反射调用目标类的方法。</li></ol><h5 id="CGLIb代理原理"><a href="#CGLIb代理原理" class="headerlink" title="CGLIb代理原理"></a>CGLIb代理原理</h5><p>CGLIB 是基于ASM 字节码生成工具，它是通过继承的方式来实现代理类，因此无法增强final方法。</p><h5 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h5><p><em>作用</em><br><code>@EnableAspectJAutoProxy</code> 可以使spring中的<code>@Aspect</code>生效。一般而言，不需要特意注解@EnableAspectJAutoProxy。</p><blockquote><p>在springboot环境下，由于存在<code>spring-boot-autoconfigure</code>依赖，默认会注入<code>AopAutoConfiguration</code>配置类，该类的作用等同于<code>@EnableAspectJAutoProxy</code>注解，所以在这种情况下可以不加<code>@EnableAspectJAutoProxy</code>注解，<code>AopAutoConfiguration</code>可以通过<code>spring.aop.auto</code>属性控制；</p></blockquote><p><em>原理</em><br><code>@EnableAspectJAutoProxy</code>会在spring容器中注册一个bean：<code>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</code>。<br>这个Bean<code>AnnotationAwareAspectJAutoProxyCreator</code>是<code>BeanPostProcessor</code>类型的，即后置处理器，可以在bean声明周期中对bean进行操作，比如对bean生成代理等。<br>Spring在初始化bean之后，就会遍历并执行所有的<code>BeanPostProcessor</code>中的<code>postProcessAfterInitialization</code>方法中的逻辑，从而实现对bean的生成代理。</p><h5 id="动态代理创建对象的时机"><a href="#动态代理创建对象的时机" class="headerlink" title="动态代理创建对象的时机"></a>动态代理创建对象的时机</h5><p>Spring会在启动时几乎实例化所有的bean，实现依赖注入并提前暴露问题（如果有bean创建失败会报错），根据是否有代理和循环依赖，spring有两个生成代理对象的时刻：</p><ul><li>非提前生成代理对象：对于没有循环依赖关系的bean：<ol><li>在属性填充<code>populateBean</code>完成之后，执行了<code>initializeBean</code></li><li>该方法会执行<code>applyBeanPostProcessorsAfterInitialization</code>，其会遍历所有<code>BeanPostProcessor</code></li><li>对每个<code>BeanPostProcessor</code>执行<code>postProcessAfterInitialization</code>方法，得到最终代理对象</li></ol></li><li>提前生成代理对象：对于有循环依赖关系的bean：<ol><li>先创建目标对象的工厂对象（进入三级缓存）</li><li>其他对象创建时又依赖目标对象时，调用<code>doGetBean()</code>方法，其中会调用<code>getSingleton</code>方法，该方法会依次从一、二、三级缓存获取对象，此时会在三级缓存通过<code>getObject()</code>获取到目标对象的工厂对象</li><li>此时会获取<code>SmartInstantiationAwareBeanPostProcessor</code> 执行<code>getEarlyBeanReference()</code>，该方法调用<code>wrapIfNecessary</code>()，得到目标对象的代理对象（进入二级缓存，即提前生成的代理对象的缓存）</li><li>此时其他对象获取到了需要注入的对象，进入一级缓存</li><li>目标对象也获取到了构建完成的B对象，完成属性填充，进入一级缓存。</li></ol></li></ul><p><em>为什么需要提前生成代理对象</em><br>假设动态代理不提前，那么在构建B对象进行属性填充的时候，填充的A对象是还没有进行动态代理的A。<br>此时B就完成了它的生命周期到了单例池当中，而后A执行完属性填充之后，再进行动态代理，生成一个被代理的A对象。放入到单例池当中。此时B中的A和单例池中的被代理的A对象不是同一个对象。</p><h2 id="为什么有字节码增强技术还需要aop"><a href="#为什么有字节码增强技术还需要aop" class="headerlink" title="为什么有字节码增强技术还需要aop"></a>为什么有字节码增强技术还需要aop</h2><p>虽然字节码增强技术本身已经提供了一种在代码层面进行修改和增强的能力，但是在某些情况下，使用AOP（Aspect-Oriented Programming）仍然是有价值的：</p><ol><li><strong>抽象级别：</strong> AOP提供了更高级别的抽象，允许开发者更直观地声明横切关注点，而无需深入研究字节码。这使得代码更具可读性和可维护性，同时也减少了开发者需要了解底层技术细节的负担。</li><li><strong>可维护性：</strong> AOP可以将横切关注点的逻辑与主要业务逻辑分开，使代码更易于维护。使用AOP，开发者可以将跨越多个模块的共同逻辑集中管理，而不会将这些逻辑分散在各个方法中。</li><li><strong>可重用性：</strong> AOP可以将切面逻辑抽象为可重用的模块，可以在多个应用程序中共享和重用。这使得相同的横切关注点可以在不同的场景中轻松应用，而不需要重新编写和修改字节码。</li><li><strong>解耦和聚焦：</strong> AOP使得开发者可以将不同的关注点隔离开来，从而实现更好的模块化。它遵循“单一职责原则”，使得代码更加聚焦，每个模块只需要关注自己的主要逻辑，而不必关心横切关注点。</li><li><strong>可配置性：</strong> AOP允许通过配置文件或注解来管理切面逻辑的应用范围。这使得开发者可以在不改变源代码的情况下，通过配置来控制切面的应用，从而实现更灵活的控制。</li><li><strong>跨越多种技术栈：</strong> AOP不仅限于Java平台，还可以在其他编程语言和技术栈中使用。这使得可以将相同的横切关注点逻辑应用于不同的技术栈和平台。</li></ol><blockquote><p>参考文献：<br><a href="https://juejin.cn/post/7269049833365192723"><strong>深入探析切面编程：解密 AspectJ 与 Spring AOP 的 AOP 魔法</strong></a><br><a href="https://www.jianshu.com/p/692463eb3db6">aspectj和Spring AOP的关系</a><br><a href="https://www.jianshu.com/p/872d3dbdc2ca">Aspectj与Spring AOP比较</a><br><a href="https://juejin.cn/post/7005800109766082590#heading-18">AspectJ五大通知注解</a><br><a href="https://www.jianshu.com/p/3c5b09f6f563">AspectJ使用介绍</a><br><a href="https://www.jianshu.com/p/87171860901c">Spring AOP执行顺序</a><br><a href="https://juejin.cn/post/7264920384888471610">搞懂Java三种代理模式：静态代理、动态代理和cglib代理</a><br><a href="https://juejin.cn/post/7053459590251282445">jdk动态代理和cglib代理到底谁快</a><br><a href="https://www.qinglite.cn/doc/3629643f4f5ba304c">什么鬼?弃用JDK动态代理,Spring5 默认使用 CGLIB 了?</a><br><a href="https://blog.csdn.net/gongsenlin341/article/details/111240114">Spring IOC—AOP代理对象生成的时机</a></p></blockquote><h1 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><em>本地缓存与redis缓存</em></p><ol><li>本地缓存 使用内存进行缓存，速度快，缺点是不能持久化，一旦项目关闭，数据就会丢失。而且不能满足分布式系统的应用场景（比如数据不一致的问题）。</li><li>Redis 缓存 利用数据库等进行缓存，最常见的就是 Redis。Redis 的访问速度同样很快，可以设置过期时间、设置持久化方法。缺点是会受到网络和并发访问的影响。</li></ol><p><em>定义</em><br>Spring Cache就是一个缓存解决方案。Spring Cache 并没有提供缓存的实现，提供的是一整套的接口和代码规范、配置、注解等。这样，通过 Spring Cache 就可以整合各种缓存方案了，比如 Redis、EhCache等，这些方案通过实现Cache接口提供功能。</p><p><em>缓存方案</em></p><ol><li>caffeine</li><li>couchbase</li><li>generic</li><li>hazelcast</li><li>infinispan</li><li>jcache</li><li>redis</li><li>simple（使用本地内存作为缓存）</li><li>none（没有缓存）</li></ol><p><em>使用方式</em></p><ol><li>添加<code>spring-boot-starter-cache</code>依赖</li><li>在启动类加上<code>@EnableCaching</code>注解</li><li>在要缓存的方法上面添加<code>@Cacheable</code>注解</li></ol><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ul><li><code>@Cacheble</code>缓存方法返回值，下次执行时直接返回缓存值，常用于查询方法。</li><li><code>@CachePut</code>缓存方法返回值到指定缓存，供其他方法使用，常用于新增方法。</li><li><code>@CacheEvict</code>清空指定缓存，<strong>一般用在更新或者删除的方法上</strong>。</li><li><code>@Caching</code>用于组合多个缓存操作</li><li><code>@CacheConfig</code>是一个类注解，提取该类下缓存注解的公共属性。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/Pasted%20image%2020230915151412.png"><br><em>Advisor</em><br>Spring使用了<code>BeanFactoryCacheOperationSourceAdvisor</code>来对缓存注解进行切面增强：获取了<code>CacheOperationSource</code>（是一个接口，实现类为<code>AnnotationCacheOperationSource</code>）并调用它的<code>getCacheOperations()</code>方法，最终调用了<code>SpringCacheAnnotationParser</code>了。</p><p><em>CacheInterceptor</em><br>Spring Cache使用的是一个叫做<code>CacheInterceptor</code>的拦截器，其继承了<code>CacheAspectSupport</code>类，会执行这个类的execute方法：</p><ol><li>首先会判断该缓存操作是否是同步的（并发时是否同步执行）</li><li>判断是否满足触发缓存的条件（注解上的condition属性，是一个EL表达式）</li><li>计算缓存key（支持用户自定义keyGenerate，否则使用框架自带的<code>SimpleKeyGenerator</code>，取入参的所有维度，但这里不指定类名和方法，所以可能会出现重复key，因此还是自定义较好）</li><li>从CacheManager（默认为ConcurrentMapCacheManager）中取出指定的Cache（即注解中的cacheNames，在同步模式只支持配置一个）</li><li>调用Cache.get(Object,Callcable)，该方法先尝试根据key获取缓存，如果取不到则使用Callble函数，然后加载在缓存中。</li></ol><p><em>缓存击穿</em><br>采取同步模式（sync &#x3D; true），这样缓存不存在时只允许一个线程执行对应方法，其他线程将阻塞，避免缓存击穿。</p><p><em>缓存穿透</em><br>当使用redis时，可使用配置<code>spring.cache.redis.cache-null-values=true</code>，避免缓存穿透。</p><blockquote><p>参考文档：<br><a href="https://juejin.cn/post/7099310776409653256">Spring中缓存操作</a><br><a href="https://juejin.cn/post/6992909985025884197">一文搞定spring-cache</a><br><a href="https://juejin.cn/post/6997440726627778597">Spring Cache</a></p></blockquote><h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><em>定义</em><br>事务管理是应用系统开发中必不可少的一部分。Spring 事务管理分为编码式和声明式的两种方式，其中编码式由<code>TransactionTemplate</code>实现，声明式由<code>@Transaction</code>实现，下面主要介绍<code>@Transaction</code>。</p><p><em>事务属性</em></p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td></tr><tr><td>propagation</td><td>事务的传播行为，默认值为 REQUIRED。</td></tr><tr><td>isolation</td><td>事务的隔离度，默认值采用 DEFAULT。</td></tr><tr><td>timeout</td><td>事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td></tr><tr><td>read-only</td><td>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td></tr><tr><td>rollback-for</td><td>用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td></tr><tr><td>no-rollback- for</td><td>抛出 no-rollback-for 指定的异常类型，不回滚事务。</td></tr></tbody></table><p><em>类级别事务支持</em><br><code>@Transactional</code>  注解也可以添加到类级别上。当把<code>@Transactional</code>注解放在类级别时，表示所有该类的公共方法都配置相同的事务属性信息，也可以在类上打<code>@Transactional</code>注解实现覆盖。</p><blockquote><p>不建议这样设计，应该明确切面的作用范围，避免错误切面和无效切面的消耗。</p></blockquote><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><ol><li>Spring根据<code>@Transaction</code>的配置判断是否需要使用<code>TransactionInterceptor</code>来使用拦截。</li><li>在TransactionInterceptor拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑，最后根据是否出现异常，利用抽象事务管理器<code>AbstractPlatformTransactionManager</code>操作数据源<code>DataSource</code>提交或回滚事务。</li></ol><p><img src="/Pasted%20image%2020230915171249.png" alt="以CGlib代理为例"></p><ol><li>事务开始时，通过AOP机制，生成一个代理connection对象，并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的容器中。在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库， 执行所有数据库命令。</li><li>事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，然后关闭该代理 connection 对象。</li></ol><blockquote><p>如果关闭自动提交后，若事务一直未完成，即未手动执行 commit 或 rollback 时如何处理已经执行过的SQL操作？<br>取决于JDBC连接池的特性，C3P0默认自动rollback。</p></blockquote><h3 id="TransactionManager"><a href="#TransactionManager" class="headerlink" title="TransactionManager"></a>TransactionManager</h3><p><img src="/Pasted%20image%2020230915171650.png" alt="事务管理器类结构"></p><ul><li>事务管理的框架是由抽象事务管理器 <code>AbstractPlatformTransactionManager</code> 来提供的，而具体的底层事务处理实现，由 <code>PlatformTransactionManager</code> 的具体实现类来实现，如事务管理器 <code>DataSourceTransactionManager</code>。</li><li><strong>不同的事务管理器管理不同的数据资源</strong> <code>DataSource</code>，比如 <code>DataSourceTransactionManager</code> 管理 JDBC 的 <code>Connection</code>。</li></ul><h3 id="Connection和Session"><a href="#Connection和Session" class="headerlink" title="Connection和Session"></a>Connection和Session</h3><p><em>定义</em></p><ul><li>连接(connection)是一个物理的概念，它指的是一个通过网络建立的客户端和mysql服务器的一个网络连接。</li><li>会话(session)是不同的用户，与mysql实例(进程)建立的。</li><li>一个connection可以拥有多个session也可以没有session，同一个连接上的不同会话之间不会相互影响。</li><li>一个session可以创建多个transaction</li><li>一个transaction只能由一个session产生</li></ul><blockquote><p>可以理解为connection是物理连接，session是逻辑连接，session建立依赖于connection，但session之间互相独立。</p></blockquote><p><em>JDBC代码</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加载驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 通过DriverManager获取连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (Connection) DriverManager.getConnection(url, username, password);<br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement(); <span class="hljs-comment">// 执行语句</span><br>statement.execute(sql);<br></code></pre></td></tr></table></figure><p>为了避免每次执行sql都从数据库获取新连接导致数据库连接数超限，引入了连接池，对connection进行复用。</p><p><em>连接池</em><br><strong>数据库连接池</strong>的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。真正解决我们连接复用的问题的，是像 Druid、hikari 这样的连接池组件，而不是Mybatis、JPA这种持久层框架。</p><p>从JDBC2.0后java推荐使用<code>DataSource</code>来代表一个db数据源并从中获取与db的连接，Druid、hikari 对该接口进行了实现，此后获取一个连接的方式变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> datasource.getConnection(username, password);<br></code></pre></td></tr></table></figure><p><em>SQLSession与Connection关系</em><br>MyBatis <strong>每次</strong>执行一个SQL语句时，并不是直接对应一个<code>connection</code>，而是每次都要创建一个叫做<code>SqlSession</code>的类的对象，每个<code>sqlSession</code>对象都对应一个<code>connection</code>。</p><blockquote><p>可以认为<code>sqlSession</code>是对<code>Connection</code>操作的高级封装，其会在执行SQL时被创建并使用，执行提交后关闭。</p></blockquote><p><em>SQLSession与事务关系</em><br>事务意味着一系列SQL语句都要依赖于同一个<code>Connection</code>（也就是<code>SqlSession</code>）。因此在 Spring 中，如果声明了事务，每个线程都会缓存当前创建的 <code>sqlSession</code> 对象，不同线程之间的<code>sqlSession</code>对象是完全隔离的，即<code>transaction</code>与<code>sqlSession</code>一对一。</p><p>具体地，MyBatis 每创建一个<code>sqlSession</code>对象前，都会先判断当前线程是否存在事务：</p><ol><li>没有事务时：创建sqlSession，执行完sql语句后提交并关闭该sqlSession</li><li>有事务时，会根据当前是否存在sqlSession决定直接使用或新建sqlSession（<code>REQUEIRED</code>），且执行完成后不会立即提交和关闭<code>sqlSession</code>，而是由SpringAOP代理执行。</li></ol><blockquote><p>基于AOP，事务是在@Transaction方法最开始的时候创建的，所以要控制@Transaction方法的内容，尽可能只保留真正需要事务执行的业务。</p></blockquote><p><em>SQLSession如何获取连接池连接</em></p><ol><li>根据Mybatis配置获取<code>SqlSessionFactory</code></li><li>调用<code>sqlSessionFactory.openSession()</code>获取<code>sqlSession</code><ol><li>调用到<code>openSessionFromDataSource()</code><ol><li>创建了一个<code>JdbcTransaction</code>对象</li><li>使用<code>JdbcTransaction</code>对象创建了一个<code>Executor</code>对象</li><li>使用<code>Executor</code>对象创建了一个<code>sqlSession</code>对象</li></ol></li></ol></li><li>某<code>sqlSession</code>首次调用查询语句：<code>sqlSession.selectOne(&quot;xxx&quot;)</code></li><li>然后调用<code>SimpleExecutor#doQuery()</code>执行语句<ol><li>调用到<code>prepareStatement(handler,ms.getStatementLog())</code><ol><li>调用到<code>getConnection(statementLog)</code><ol><li>最后调用到<code>JdbcTransaction.getConnection()</code><ol><li><code>JdbcTransaction</code>会一直走到<code>DataSource</code>中去取数据库连接</li></ol></li></ol></li></ol></li></ol></li></ol><p><img src="/Pasted%20image%2020230917010559.png"></p><p>总而言之，mybatis创建的<code>sqlSession</code>在<strong>第一次执行sql时</strong>需要从事务中获取连接，其最终从<code>DataSource</code>中获取连接。</p><h3 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h3><p>Spring 事务的底层实现主要使用的技术：AOP + ThreadLocal（隔离线程间的资源） + try&#x2F;catch。<br><img src="/2023/09/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/Spring%E7%AC%94%E8%AE%B0/Pasted-image-20230213140151.jpg"></p><h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><h3 id="事务传播级别"><a href="#事务传播级别" class="headerlink" title="事务传播级别"></a>事务传播级别</h3><p>Propagation，事务传播级别，默认值为Propagation.REQUIRED。</p><ul><li>REQUIRED（默认值）：在有transaction状态下执行；如当前没有transaction，则创建新的transaction；</li><li>REQUIRES_NEW：创建新的transaction并执行；如果当前已有transaction，则将当前transaction挂起；</li><li>SUPPORTS：如当前有transaction，则在transaction状态下执行；如果当前没有transaction，在无transaction状态下执行；</li><li>MANDATORY：必须在有transaction状态下执行，如果当前没有transaction，则抛出异常IllegalTransactionStateException；</li><li>NOT_SUPPORTED：在无transaction状态下执行；如果当前已有transaction，则将当前transaction挂起；</li><li>NEVER：在无transaction状态下执行；如果当前已有transaction，则抛出异常IllegalTransactionStateException。</li><li>NESTED ：和 Propagation.REQUIRED 效果类似，区别在于：子事务的提交依赖于主事务，但子事务的回滚不依赖于主事务（即如果子事务异常会直接回滚，而主事务如果catch掉了这个异常，则主事务不会回滚）</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>isolation ：事务的隔离级别，默认值为 Isolation.DEFAULT。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><p><em>Spring 的事务隔离级别是如何做到和数据库一致的</em><br>Spring 的事务隔离级别本质上还是通过数据库来控制的，具体是在执行事务前先执行命令修改数据库隔离级别：<br><code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED</code></p><h2 id="Transaction失效情形"><a href="#Transaction失效情形" class="headerlink" title="@Transaction失效情形"></a>@Transaction失效情形</h2><ol><li>避免Spring的AOP的自调用：即避免同类中<code>@Transaction</code>方法的互相调用，如有必要，可使用<code>AspectJ</code>或<code>TransactionTemplate</code>实现。</li><li>禁止手动捕获异常而不抛出：<code>@Transaction</code>依赖Runtime异常回滚，手动捕获而不抛出会导致回滚失败。</li><li>错误设置Rollback属性：<code>@Transactional</code>注解默认的rollbackFor是<code>RuntimeException</code>，只会对其及其子类异常回滚，对于其他异常不会回滚。</li><li>错误添加切面：AOP 切面顺序导致事务不能正确回滚，事务切面的优先级最低，但若其他切面与事务切面优先级相同，且捕获了业务异常，会导致2中提到的情况。</li><li>Transactional业务实现中并没有保证原子性行为</li><li>多线程：新线程不由Spring托管，其注入不了spring的bean，<code>@Transactional</code>失效。</li><li><code>@Transactional</code>只有应用到<code>public</code>方法才有效：Spring AOP时需要使用反射获取注解中的事务属性配置信息，若方法不为public则获取不到。</li></ol><p><em>多线程下使用事务</em><br>多线程或线程池因为不由Spring托管，其无法获取Spring中的bean，解决方案有：</p><ul><li>实现ApplicationContextAware接口</li><li>线程内部构造方法</li><li>将线程作为内部类实现，此时内部类可以获取外部类成员</li></ul><p>获取到springbean后，即可使用spring中被注解增强过的实例了，另外，使用多线程事务的情况下，进行回滚，比较麻烦，因为Thread的run方法不会抛出异常，其吃掉异常后直接终止，外部线程想要感知到这个异常，需要设置相应的处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">innerThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(threadOperation);  innerThread.setUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;  <br><span class="hljs-keyword">try</span> &#123;<br>             serviceB.delete();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>        e1.printStackTrace(); <br>        &#125;<br>      &#125;<br>  &#125;);<br>innerThread.start();<br></code></pre></td></tr></table></figure><p><em>开启事务批量执行</em><br>由于事务机制，批量操作时如果使用循环，则每次操作被视为一个事务，执行效率较低，可以通过事务批量化处理提高效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">transactionStatus</span> <span class="hljs-operator">=</span> dataSourceTransactionManager.getTransaction(transactionDefinition); <br><span class="hljs-keyword">try</span> &#123; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-comment">//db operation</span><br>&#125;<br>dataSourceTransactionManager.commit(transactionStatus);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>dataSourceTransactionManager.rollback(transactionStatus);<br><span class="hljs-keyword">throw</span> e; &#125;<br></code></pre></td></tr></table></figure><p><em>@Transaction事务方法必须为public的详细原因</em><br>TransactionInterceptor在拦截目标方法前，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用AbstractFallbackTransactionAttributeSource的computeTransactionAttribute 方法，用以获取注解事务属性配置信息，若方法不为public则获取不到。</p><h2 id="事务挂起原理"><a href="#事务挂起原理" class="headerlink" title="事务挂起原理"></a>事务挂起原理</h2><p><em>事务和线程的关系</em><br>Spring中，当事务创建时，就会被绑定到一个线程上。该线程会伴随着事务整个生命周期，直到事务提交、回滚或挂起(临时解绑)。<strong>线程和事务的关系是1:1的</strong>。</p><p><em>事务挂起原理</em><br>事务本质上就是与<strong>数据库的会话session和事务相关配置</strong>，其在内部会被封装成事务资源，如果线程的当前事务尚未结束，又需要临时解绑事务（REQUIRES_NEW&#x2F;NOT_SUPPORTED），此时则需要对当前事务资源做临时存储，即事务挂起。等待执行完成后，再将之前临时存储的资源重新绑定到该线程上。</p><p><img src="/Pasted%20image%2020230916132048.png"></p><h2 id="事务通知"><a href="#事务通知" class="headerlink" title="事务通知"></a>事务通知</h2><p>为了便于我们在事务提交后再触发某时间来进行其他操作，Spring为我们提供了两种方式：</p><ol><li><code>@TransactionalEventListener</code>注解。  </li><li>事务同步管理器<code>TransactionSynchronizationManager</code>。</li></ol><h3 id="TransactionalEventListener"><a href="#TransactionalEventListener" class="headerlink" title="@TransactionalEventListener"></a>@TransactionalEventListener</h3><p>Spring的事件监听机制（发布订阅模型）实际上并不是异步的（默认情况下），而是<strong>同步的</strong>来将代码进行解耦。@TransactionEventListener也是通过这种方式，通过加入回调的方式，在事务进行Commited，Rollback…等时候才去进行Event的处理，来达到事务同步的目的。</p><h4 id="事件使用"><a href="#事件使用" class="headerlink" title="事件使用"></a>事件使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义事件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> &#123;<br>&#125;<br><br><br><span class="hljs-comment">// 发布事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">implements</span> MyService &#123;<br>    <br><span class="hljs-meta">@Autowired</span><br>    ApplicationEventPublisher eventPublisher;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span>&#123;<br>eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEvent</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 监听器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserListener</span> &#123;<br><span class="hljs-comment">// 指明自身监听的事件和时点</span><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT, classes = MyEvent.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMyEvent</span><span class="hljs-params">(MyEvent event)</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编程式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>        context.addApplicationListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyListener</span>());<br>        context.refresh();<br>        context.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事务通知-1"><a href="#事务通知-1" class="headerlink" title="事务通知"></a>事务通知</h4><ul><li>注册点：Spring对事务监控的处理逻辑在<code>TransactionSynchronization</code>接口中，该接口定义了若干方法，该接口是一个注册点，在事务执行中，会获取当前所有注册的<code>TransactionSynchronization</code>并执行对应的方法。</li><li>注册过程：Spring会注册一个TransactionalEventListenerFactory类型的bean到Spring容器中，该bean可以对所有注释了<code>@TransactionalEventListener</code>的方法创建一个<code>ApplicationListenerMethodTransactionalAdapter</code>对象，该对象是一个<code>ApplicationListener</code>，即Spring的事件监听器。</li><li><code>ApplicationListenerMethodTransactionalAdapter</code>在监听到事件时，会创建一个<code>TransactionSynchronization</code>对象，并将其注册到<code>TransactionManager</code>中。</li></ul><blockquote><p>参考文档：<br><a href="https://zhuanlan.zhihu.com/p/347319485">@Transactional 详解</a><br><a href="https://juejin.cn/post/7152703572059095054#heading-6">Java多线程批量操作，居然有人不做事务控制？</a><br><a href="https://juejin.cn/post/7132359716021370888">Spring 事务、MyBatis SqlSession、连接池、DB 之间的关系</a><br><a href="https://blog.csdn.net/qq_41378597/article/details/105748703?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169485700916800226574087%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169485700916800226574087&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-105748703-null-null.142%5Ev94%5Einsert_down1&utm_term=@TransactionalEventListener%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187">@TransactionalEventListener的使用和实现原理</a><br><a href="https://blog.csdn.net/qq_36850813/article/details/86167819">MyBatis事务—–JdbcTransaction</a><br><a href="https://blog.csdn.net/crave_shy/article/details/46597239">Mybatis深入之获取数据库连接</a></p></blockquote><h1 id="Spring常见注解"><a href="#Spring常见注解" class="headerlink" title="Spring常见注解"></a>Spring常见注解</h1><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p><em>场景</em></p><ul><li>使用在类上，用于快速将实例注入到spring容器</li><li>相比@Component，@Import可以用于导入第三方包，作用类似于@Bean，但比其方便。</li></ul><p><em>用法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 表示将类名1，类名2的类实例导入spring容器</span><br><span class="hljs-meta">@Import(&#123; 类名1.class , 类名2.class... &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p><em>注意</em><br>@Import导入类实例 比 类本身注解得到实例 的 优先级高。</p><h2 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h2><p><em>场景</em></p><ul><li>使用在方法上，将该方法标记为异步方法</li></ul><p><em>用法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootApplication</span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-meta">@Async(&quot;xxxExecutor&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p><em>注意</em></p><ul><li>线程池：通过value指定线程池。默认会使用org.springframework.core.task.TaskExecutor类的实例作为线程池，找不到则寻找name为taskExecutor的线程池，都没有则会创建一个SimpleAsyncTaskExecutor。</li><li>方法返回值：只能是void或Future</li><li>异常处理：默认使用SimpleAsyncUncaghtExeceptionHandler，该处理器只会输出错误日志。若异步方法是void，无法传出异常信息给调用者，若方法有返回值，则异常也会被返回给调用者，调用者需要处理该异常，否则会被中断。</li><li>AOP限制：方法应该是public的，且调用同类中的异步方法时注解会失效，原因与<code>@Transaction</code>失效相同。</li></ul><h2 id="Autowire"><a href="#Autowire" class="headerlink" title="@Autowire"></a>@Autowire</h2><p>使用@Autowire时，可以免写set方法，Spring可以通过反射修改成员的访问权限<code>setAccessible()</code>，绕过set方法实现属性注入。</p><h2 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h2><p>用于懒加载实例化bean，直到第一次调用时才实例化，用法：</p><ol><li>@Configuration类上标注@Lazy，该类中所有bean实现懒加载</li><li>同时在@Component和@Autowired上标注@Lazy，则该单例bean实现懒加载</li></ol><h1 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h1><blockquote><p><a href="https://blog.csdn.net/zzuhkp/article/details/108914282">Spring 事件处理机制详解，带你吃透 Spring 事件</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（JUC）</title>
    <link href="/2023/04/30/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88JUC%EF%BC%89/"/>
    <url>/2023/04/30/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88JUC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、多线程循环打印问题"><a href="#一、多线程循环打印问题" class="headerlink" title="一、多线程循环打印问题"></a>一、多线程循环打印问题</h1><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p><em>释放&#x2F;等待锁的前提</em><br>无论是释放lock锁还是等待lock锁的condition，都需要先获取锁再执行该方法。</p><p><em>unlock和wait的语义</em></p><ul><li>unlock：线程放弃锁，且离开了锁中的所有队列，直接继续执行，是一种非阻塞的行为。</li><li>wait：线程放弃锁，但加入锁的等待队列，等待事件唤醒后重新获取锁后继续执行，是一种阻塞的行为。</li></ul><p><em>notify和notifyAll的语义</em><br>notify&#x2F;notifyAll只是一个标记，其不会立即执行，而当该线程释放锁时，通知其他等待该锁的线程。<br>notify和notifyAll之间的关键区别在于notify只会<strong>随机</strong>唤醒一个线程，而notifyAll方法将唤醒所有线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> lock.newCondition();  <br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);  <br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);  <br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);  <br>    <span class="hljs-type">ThreadPrinter</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPrinter</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>,lock,c1,c2,s1,s2);  <br>    <span class="hljs-type">ThreadPrinter</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPrinter</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>,lock,c2,c3,s2,s3);  <br>    <span class="hljs-type">ThreadPrinter</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPrinter</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>,lock,c3,c1,s3,s1);  <br>    t1.start();  <br>    <span class="hljs-keyword">try</span>&#123;  <br>        Thread.sleep(<span class="hljs-number">3000</span>);  <br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;  <br>  <br>    &#125;    t2.start();  <br>    t3.start();  <br>&#125;  <br><br><span class="hljs-comment">// 线程类，可以分别记录自己需要执行的次数和执行的条件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPrinter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;  <br>    <span class="hljs-type">int</span> str;  <br>    <span class="hljs-type">int</span> time;  <br>  <br>    Lock lock;  <br>  <br>    Condition cur;  <br>  <br>    Condition next;  <br>  <br>    Semaphore curS;  <br>  <br>    Semaphore nextS;  <br>  <br>    ThreadPrinter(<span class="hljs-type">int</span> str,<span class="hljs-type">int</span> time,Lock lock,Condition cur,Condition next,Semaphore curS,Semaphore nextS) &#123;  <br>        <span class="hljs-built_in">this</span>.str = str;  <br>        <span class="hljs-built_in">this</span>.time = time;  <br>        <span class="hljs-built_in">this</span>.lock = lock;  <br>        <span class="hljs-built_in">this</span>.cur = cur;  <br>        <span class="hljs-built_in">this</span>.next = next;  <br>        <span class="hljs-built_in">this</span>.curS = curS;  <br>        <span class="hljs-built_in">this</span>.nextS = nextS;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 1.syn/lock,unlock会释放锁，且释放后会继续执行，因此需要通过while去重新获取锁，判断是否得到了它想要状态</span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> time;  <br>        <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;  <span class="hljs-comment">// or lock.lock();  </span><br>                <span class="hljs-keyword">if</span>(total % <span class="hljs-number">3</span> == str)&#123;  <br>                    System.out.println((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span>+str));  <br>                    count--;  <br>                    total++;  <br>                &#125;  <br>            &#125; <span class="hljs-comment">// lock.unlock;  </span><br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 2   notifyAll/wait,为了避免对锁的释放（因为我们的目的是等待条件满足），因此可以通过wait临时释放锁</span><br>    <span class="hljs-comment">// 2.1 其被唤醒时需要判断是否处于它可以执行的状态，外围需要使用while  </span><br>    <span class="hljs-comment">// 2.2 这样保证了一个线程只需要获取锁5次，其余时间会进入待队列而不是反复尝试竞争，减少了锁冲突  </span><br>    <span class="hljs-comment">// 2.3 notifyAll只是一个标记，其含义是当该线程释放锁时，通知其他等待该锁的线程  </span><br>    <span class="hljs-comment">// 2.4 Lock的单condition和这个作用类似，不再重复说明  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> time;  <br>        <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-keyword">while</span>(total % <span class="hljs-number">3</span> != str) &#123;  <br>                    <span class="hljs-keyword">try</span>&#123;  <br>                        lock.wait();  <br>                    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;  <br>  <br>                    &#125;<br>                &#125;  <br>                System.out.println((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span>+str));  <br>                count--;<br>                total++;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 3. condition: await/signal  </span><br>    <span class="hljs-comment">// 3.1 与object不同，一个lock可以有多个condition  </span><br>    <span class="hljs-comment">// 3.2 这意味着可以更加细粒度的实现线程释放后被通知的线程集合,因此不再需要使用while来判断唤醒后的条件是否可继续执行  </span><br>    <span class="hljs-comment">// 3.3 疑问：如果signal或notify操作会不会没有提醒到其他线程(其他线程在前一个线程通知后在执行wait())，导致其一直等待？  </span><br>    <span class="hljs-comment">// 不可能，当前锁执行signal的前提就是获取到了锁，而其获取到锁的前提就是它的上一个节点进入了wait或者该节点是头节点  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> time;  <br>        <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)&#123;  <br>            lock.lock();  <br>            <span class="hljs-keyword">if</span>(total % <span class="hljs-number">3</span> != str)&#123;  <br>                <span class="hljs-keyword">try</span>&#123;  <br>                    cur.await();  <br>                &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;  <br>  <br>                &#125;  <br>            &#125;  <br>            System.out.println((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span>+str));  <br>            count--;  <br>            total++;  <br>            next.signal();  <br>            lock.unlock();  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 4. Semaphore,类似lock但更轻量  </span><br>    <span class="hljs-comment">// 4.1 可利用其实现数组，解决使用N个线程完成100个数字打印的问题  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> time;  <br>        <span class="hljs-keyword">while</span>(count&gt;<span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                curS.acquire();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>            &#125;  <br>            System.out.println((<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span>+str));  <br>            count--;  <br>            nextS.release();  <br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（SQL）</title>
    <link href="/2023/04/30/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88SQL%EF%BC%89/"/>
    <url>/2023/04/30/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88SQL%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、表达式规则"><a href="#一、表达式规则" class="headerlink" title="一、表达式规则"></a>一、表达式规则</h1><p><em>等于</em></p><ul><li>任何值与NULL比较都返回<code>NULL</code>，而不是<code>1</code>或<code>0</code></li><li>不等于：<code>!=</code> 或 <code>&lt;&gt;</code></li><li>安全等于：<code>&lt;=&gt;</code>，两个值都为NULL时返回1，一个值为NULL时返回0</li></ul><p><em>其他</em></p><ul><li><code>between a and b</code>，是一个闭合区间</li></ul><p><em>分组</em></p><ul><li><code>group</code>会将所有null值视为同一项</li></ul><p><em>count</em></p><ul><li><code>count(列名)</code>不统计该列为null的记录</li><li><code>count(distinct 列名)</code>可以去重</li><li><code>count(1)与count( * )</code>包含null的记录</li><li>条件写法：<ul><li>性质：<code>count(任意数) = 1</code>，<code>count(NULL)=0</code></li><li>条件计数：<code>count(布尔表达式 or null) = count(if(布尔表达式,1,null)) = sum(布尔表达式)</code></li><li>条件比例：<code>avg(布尔表达式) = sum(布尔表达式)/count(1)</code></li><li>条件统计：<code>sum(if(条件,列名,0))</code></li></ul></li></ul><blockquote><p>count执行速度区别：</p><ul><li>速度上：<code>count(主键)&gt;count(1)≈count(*)&gt;count(其他列)</code></li><li>无主键时：<code>count(1)&gt;count(*)</code></li><li>只有一个字段时：<code>count(*)&gt;count(1)</code></li></ul></blockquote><p><em>if</em></p><ul><li><code>if(条件,表达式1,表达式2)</code>，根据条件为1或0取值</li><li><code>ifnull(表达式1,表达式2)</code>，如果表达式1&#x3D;null，返回表达式2，否则返回表达式1</li><li><code>nullif(表达式1,表达式2)</code>，如果表达式1&#x3D;表达式2，返回null，否则返回表达式1</li><li><code>isnull(表达式1)</code>，表达式1为null时返回1，否则返回0</li></ul><p><em>union</em></p><ul><li>union用于合并多个select的结果，会合并重复项</li><li>union all不会合并重复项</li></ul><p><em>join</em></p><ul><li>cross join就是笛卡尔积，使用on则从该结果集中筛选满足条件的连接行</li><li>full join可以保证连接同时保留不满足条件的连接行，但mysql中不支持，可以通过left join、union、right join三步实现替换</li></ul><p><em>group_concat</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 例子</span><br><span class="hljs-keyword">select</span><br>    sell_date,<br>    <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> product) num_sold,<br>    group_concat(<br>        <span class="hljs-keyword">distinct</span> product<br>        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> product<br>        separator <span class="hljs-string">&#x27;,&#x27;</span><br>    ) products<br><span class="hljs-keyword">from</span> <br>    Activities<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sell_date<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sell_date<br></code></pre></td></tr></table></figure><p><em>limit</em></p><ul><li>limit 1 第一行数据</li><li>limit m,n（从第m+1行开始，共展示n行）</li><li>limit n offset m（从第m+1行开始，共展示1行）</li></ul><blockquote><p>另外要注意limit中不支持运算。</p></blockquote><h1 id="二、语句结构处理"><a href="#二、语句结构处理" class="headerlink" title="二、语句结构处理"></a>二、语句结构处理</h1><p><em>子查询与交叉连接</em></p><ul><li>一般都用于要在本表中找到分组中某列最大的一条记录，子查询和交叉连接在此处都是可以的，两者区别在于：</li><li>子查询是先查询筛选再连接，需要考虑子查询出的记录数量决定语句编写逻辑，交叉连接则先连接再筛选。</li></ul><p><em>隐式交叉连接</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> O.ID, O.ORDER_NUMBER, C.ID, C.NAME<br><span class="hljs-keyword">FROM</span> ORDERS O , CUSTOMERS C<br><span class="hljs-keyword">WHERE</span> O.ID<span class="hljs-operator">=</span>C.ID;<br></code></pre></td></tr></table></figure><p><em>虚拟表</em><br>可以用于枚举不存在于表中的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">with</span> a <span class="hljs-keyword">as</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;High Salary&#x27;</span> category<br><span class="hljs-keyword">union</span> <br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Low Salary&#x27;</span><br><span class="hljs-keyword">union</span> <br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Average Salary&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="三、API"><a href="#三、API" class="headerlink" title="三、API"></a>三、API</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p><em>小数处理</em></p><ul><li>round(数值，保留小数位数)，返回浮点数</li><li>format(数据或字符串，格式)，可以用于格式化日期和小数，处理小数时用法同round，但返回的是字符串</li></ul><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p><em>日期差</em></p><ul><li>datediff(日期1,日期2)，返回整数天</li><li>timestampdiff(单位,时间1,时间2)，可以额外指定时间差的单位</li></ul><p><em>日期计算</em></p><ul><li>date(日期+1)，加一天，这种用法额外要求日期数据类型为date，不可为字符串，其他函数不受限制</li><li>date_add(日期,interval 1 day)，加1天</li><li>date_sub(日期,interval 1 day)，减1天</li></ul><p><em>变量</em></p><ul><li>赋予初值：<code>SELECT @pre := 0</code></li><li>操作：<code>@pre := @pre+1</code></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><em>正则表达式</em><br><a href="https://www.runoob.com/mysql/mysql-regexp.html">菜鸟</a></p><ul><li>用法：<code>WHERE str REGEXP &#39;正则表达式&#39;;</code></li><li>注意：空格可以用<code>\s</code>表示，但mysql也要一个<code>\</code>，所以使用<code>\\s</code>表示空格。</li></ul><p><em>字符串拼接</em><br><code>concat(str1,str2,...)</code></p><p><em>子串</em><br><code>substr(str,pos,len)</code><br><strong>注意，这里的pos从1开始计算。</strong></p><p><em>字符串截取</em></p><ul><li>截取左端：<code>left(str,int)</code></li><li>截取右端：<code>right(str,int)</code></li></ul><p><em>字符串大小写</em></p><ul><li>大写：<code>UPPER(str)</code></li><li>小写：<code>LOWER(str)</code></li></ul><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p><em>用法</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">[你要的操作] <span class="hljs-keyword">OVER</span> ( <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span>  <span class="hljs-operator">&lt;</span>用于分组的列名<span class="hljs-operator">&gt;</span><br>                    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>按序叠加的列名<span class="hljs-operator">&gt;</span> <br>                    <span class="hljs-keyword">ROWS</span> <span class="hljs-operator">&lt;</span>窗口滑动的数据范围<span class="hljs-operator">&gt;</span> )<br></code></pre></td></tr></table></figure><p><em>操作函数</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">rank</span>() 排名函数，允许并列排名，并列者也占用名次<br><span class="hljs-built_in">dense_rank</span>() 允许并列排名后，并列者不占用名次<br><span class="hljs-built_in">row_number</span>() 不允许并列，强制连续排名<br><span class="hljs-built_in">LEAD</span>(exp,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;xxx&#x27;</span>) exp为表达式，<span class="hljs-number">1</span>表示当前行的前<span class="hljs-number">1</span>行，<span class="hljs-string">&#x27;xxx&#x27;</span>表示没有前一行时的默认值。<br></code></pre></td></tr></table></figure><p><em>滑动窗口数据范围</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">当前行 <span class="hljs-operator">-</span> <span class="hljs-keyword">current</span> <span class="hljs-type">row</span><br>之前的行 <span class="hljs-operator">-</span> preceding<br>之后的行 <span class="hljs-operator">-</span> following<br>无界限 <span class="hljs-operator">-</span> unbounded<br>表示从前面的起点 <span class="hljs-operator">-</span> unbounded preceding<br>表示到后面的终点 <span class="hljs-operator">-</span> unbounded following<br><br>例子：<br><span class="hljs-keyword">ROWS</span> <span class="hljs-number">6</span> preceding <span class="hljs-comment">--当前行和前6行，共7行</span><br><span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">between</span> <span class="hljs-number">6</span> preceding <span class="hljs-keyword">and</span> <span class="hljs-keyword">current</span> <span class="hljs-type">row</span> <span class="hljs-comment">--同上</span><br><span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> preceding <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> folowing <span class="hljs-comment">--前后5行加当前行，共11行</span><br></code></pre></td></tr></table></figure><h1 id="四、例题"><a href="#四、例题" class="headerlink" title="四、例题"></a>四、例题</h1><p><a href="https://leetcode.cn/problems/game-play-analysis-iv/">550. 游戏玩法分析 IV</a><br>分析问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-comment">-- 注册日记录</span><br><span class="hljs-comment">-- select player_id,min(event_date) from activity group by player_id</span><br><br><span class="hljs-comment">-- 筛选第二天记录，发现注册日记录可以顺便统计总数：</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-built_in">count</span>(a1.games_played<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">null</span>)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),<span class="hljs-number">2</span>) fraction<br><span class="hljs-keyword">from</span> activity a1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span><br> (<span class="hljs-keyword">select</span> player_id,<span class="hljs-built_in">min</span>(event_date) event_date <span class="hljs-keyword">from</span> activity <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> player_id) a2<br><span class="hljs-keyword">on</span> a1.event_date <span class="hljs-operator">=</span> <span class="hljs-type">date</span>(a2.event_date<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br><span class="hljs-keyword">and</span> a1.player_id <span class="hljs-operator">=</span> a2.player_id;<br><br><span class="hljs-comment">-- 也可以不使用join加count(条件)，而是使用where</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>)<span class="hljs-operator">/</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> player_id) <span class="hljs-keyword">from</span> activity),<span class="hljs-number">2</span>) fraction<br><span class="hljs-keyword">from</span> activity a1 <br><span class="hljs-keyword">where</span> (player_id,event_date) <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> player_id,<span class="hljs-type">date</span>(<span class="hljs-built_in">min</span>(event_date)<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">from</span> activity <br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> player_id<br>)<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/last-person-to-fit-in-the-bus/">1204. 最后一个能进入电梯的人</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 自连接写法，有点类似交叉连接后筛选</span><br><span class="hljs-keyword">SELECT</span> a.person_name<br><span class="hljs-keyword">FROM</span> Queue a, Queue b<br><span class="hljs-keyword">WHERE</span> a.turn <span class="hljs-operator">&gt;=</span> b.turn<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.person_id <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">SUM</span>(b.weight) <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.turn <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">1</span><br><br><br><span class="hljs-comment">-- 变量写法，在from中赋初值，select中迭代</span><br><span class="hljs-keyword">SELECT</span> a.person_name<br><span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> person_name, <span class="hljs-variable">@pre</span> :<span class="hljs-operator">=</span> <span class="hljs-variable">@pre</span> <span class="hljs-operator">+</span> weight <span class="hljs-keyword">AS</span> weight<br><span class="hljs-keyword">FROM</span> Queue, (<span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@pre</span> :<span class="hljs-operator">=</span> <span class="hljs-number">0</span>) tmp<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> turn<br>) a<br><span class="hljs-keyword">WHERE</span> a.weight <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.weight <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/restaurant-growth/">1321. 餐馆营业额变化增长</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 滑动窗口<br># 过滤最早的<span class="hljs-number">6</span>天<br><span class="hljs-keyword">SELECT</span> visited_on,amount,average_amount<br><span class="hljs-keyword">FROM</span> (<br>    #统计每个日期及其前<span class="hljs-number">6</span>个日期的消费量<br>    <span class="hljs-keyword">SELECT</span> visited_on,<br>           <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> visited_on <span class="hljs-keyword">ROWS</span> <span class="hljs-number">6</span> PRECEDING) <span class="hljs-keyword">AS</span> amount,<br>           ROUND(<span class="hljs-built_in">AVG</span>(amount)<span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> visited_on <span class="hljs-keyword">ROWS</span> <span class="hljs-number">6</span> PRECEDING),<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> average_amount<br>    <span class="hljs-keyword">FROM</span> (<br>        #先统计每日消费量<br>        <span class="hljs-keyword">SELECT</span> visited_on,<span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> amount<br>        <span class="hljs-keyword">FROM</span> Customer<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> visited_on<br>    ) TABLE_1<br>) TABLE_2<br><span class="hljs-keyword">WHERE</span> DATEDIFF(visited_on,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(visited_on) <span class="hljs-keyword">FROM</span> Customer)) <span class="hljs-operator">&gt;=</span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/department-top-three-salaries/">185. 部门工资前三高的所有员工</a><br>top n问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 连接员工与部门<br><span class="hljs-keyword">select</span> d.name department,e1.name employee,e1.Salary Salary<br><span class="hljs-keyword">from</span> employee e1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> department d<br><span class="hljs-keyword">on</span> e1.departmentId <span class="hljs-operator">=</span> d.id<br># 公司里前 <span class="hljs-number">3</span> 高的薪水意味着有不超过 <span class="hljs-number">3</span> 个工资比这些值大。<br><span class="hljs-keyword">where</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> (<br>    # 获取同部门中，比e1的薪水高的薪水种类，如果小于<span class="hljs-number">3</span>则说明e1为前<span class="hljs-number">3</span><br>    <span class="hljs-keyword">SELECT</span><br>        <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> e2.Salary)<br>    <span class="hljs-keyword">FROM</span><br>        Employee e2<br>    <span class="hljs-keyword">WHERE</span><br>        e2.Salary <span class="hljs-operator">&gt;</span> e1.Salary <span class="hljs-keyword">AND</span> e1.DepartmentId <span class="hljs-operator">=</span> e2.DepartmentId<br>)<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/second-highest-salary/">176. 第二高的薪水</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ifNull(<br>    (<br>    <span class="hljs-keyword">select</span> e1.salary<br>    <span class="hljs-keyword">from</span> Employee e1,Employee e2<br>    <span class="hljs-keyword">where</span> e1.salary<span class="hljs-operator">&lt;</span>e2.salary<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> e1.salary<br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> e2.salary) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    )<br>,<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">as</span> SecondHighestSalary;<br><br><span class="hljs-comment">-- 另解</span><br><span class="hljs-keyword">select</span> ifNull((<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> salary<br><span class="hljs-keyword">from</span> Employee <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Salary <span class="hljs-keyword">Desc</span><br>limit <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">as</span> SecondHighestSalary;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/highest-grade-for-each-student/">1112. 每位学生的最高成绩</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> student_id, <span class="hljs-built_in">min</span>(course_id) <span class="hljs-keyword">AS</span> course_id, grade <span class="hljs-keyword">FROM</span> enrollments <span class="hljs-keyword">WHERE</span> (student_id, grade) <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> student_id, <span class="hljs-built_in">MAX</span>(grade) <span class="hljs-keyword">AS</span> grade <span class="hljs-keyword">FROM</span> Enrollments <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> student_id ) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> student_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> student_id<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> p1 <span class="hljs-keyword">FROM</span> Person p1,<br>    Person p2<br><span class="hljs-keyword">WHERE</span><br>    p1.Email <span class="hljs-operator">=</span> p2.Email <span class="hljs-keyword">AND</span> p1.Id <span class="hljs-operator">&gt;</span> p2.Id<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-users-with-valid-e-mails/">1517. 查找拥有有效邮箱的用户</a><br>正则表达式</p><p><a href="https://leetcode.cn/problems/sellers-with-no-sales/">1607. 没有卖出的卖家</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> seller_name <span class="hljs-keyword">AS</span> SELLER_NAME<br><span class="hljs-keyword">FROM</span> Seller<br><span class="hljs-keyword">WHERE</span> Seller.seller_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> seller_id <span class="hljs-keyword">AS</span> id<br><span class="hljs-keyword">FROM</span> Orders<br><span class="hljs-keyword">WHERE</span> DATE_FORMAT(sale_date, &quot;%Y&quot;) <span class="hljs-operator">=</span> <span class="hljs-number">2020</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SELLER_NAME;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/grand-slam-titles/">1783. 大满贯数量</a><br>笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> p.player_id, p.player_name, <span class="hljs-built_in">SUM</span>(p.player_id <span class="hljs-operator">=</span> c.Wimbledon) <span class="hljs-operator">+</span> <span class="hljs-built_in">SUM</span>(p.player_id <span class="hljs-operator">=</span> c.Fr_open) <span class="hljs-operator">+</span> <span class="hljs-built_in">SUM</span>(p.player_id <span class="hljs-operator">=</span> c.US_open) <span class="hljs-operator">+</span> <span class="hljs-built_in">SUM</span>(p.player_id <span class="hljs-operator">=</span> c.Au_open) grand_slams_count <br><span class="hljs-keyword">FROM</span> Championships c, Players p<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> p.player_id<br><span class="hljs-keyword">HAVING</span> grand_slams_count <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/game-play-analysis-ii/">512. 游戏玩法分析 II</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cte <span class="hljs-keyword">AS</span>(<br>    <span class="hljs-keyword">SELECT</span> <br>    player_id, <br>    device_id, <br>    <span class="hljs-built_in">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> player_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> event_date <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">AS</span> ranking<br>   <span class="hljs-keyword">FROM</span> Activity<br>)<br><br><span class="hljs-keyword">SELECT</span><br>player_id, device_id<br><span class="hljs-keyword">FROM</span> cte<br><span class="hljs-keyword">WHERE</span> ranking<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-most-recent-three-orders/">1532. 最近的三笔订单</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    c.name customer_name,<br>    c.customer_id, <br>    t.order_id, <br>    t.order_date<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span>  <br>        order_id,<br>        order_date,<br>        customer_id,<br>        <span class="hljs-built_in">row_number</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> customer_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_date <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">as</span> rank_tag<br>    <span class="hljs-keyword">FROM</span> orders ) t<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customers c  <br>    <span class="hljs-keyword">ON</span> t.customer_id <span class="hljs-operator">=</span> c.customer_id    <br><span class="hljs-keyword">WHERE</span> <br>    rank_tag <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>    name, customer_id, order_date <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-start-and-end-number-of-continuous-ranges/">1285. 找到连续区间的开始和结束数字</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br><span class="hljs-built_in">min</span>(log_id) start_id,<br><span class="hljs-built_in">max</span>(log_id) end_id<br><span class="hljs-keyword">from</span> (<br><span class="hljs-keyword">select</span><br>log_id,<br>log_id <span class="hljs-operator">-</span> <span class="hljs-built_in">row_number</span>() <span class="hljs-keyword">over</span>() diff<br><span class="hljs-keyword">from</span> logs<br>) temp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> diff<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-most-frequently-ordered-products-for-each-customer/">1596. 每位顾客最经常订购的商品</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> t.customer_id,t.product_id,p.product_name<br><span class="hljs-keyword">from</span> (<br>    <span class="hljs-keyword">select</span> customer_id,product_id,<span class="hljs-built_in">rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> customer_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">desc</span>) ranking<br>    <span class="hljs-keyword">from</span> orders o<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> customer_id,product_id<br>) t<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> products p<br><span class="hljs-keyword">on</span> t.product_id <span class="hljs-operator">=</span> p.product_id<br><span class="hljs-keyword">where</span> t.ranking <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/biggest-window-between-visits/">1709. 访问日期之间最大的空档期</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    user_id,<br>    <span class="hljs-built_in">max</span>(datediff(next_visit_date,visit_date)) biggest_window<br><span class="hljs-keyword">FROM</span> (<br>  <span class="hljs-keyword">SELECT</span><br>    user_id,<br>    visit_date,<br>    <span class="hljs-built_in">LEAD</span>(visit_date, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2021-01-01&#x27;</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> visit_date) <span class="hljs-keyword">AS</span> next_visit_date<br>  <span class="hljs-keyword">FROM</span><br>    UserVisits<br>) <span class="hljs-keyword">AS</span> subquery<br><span class="hljs-comment">-- Group the result by user_id</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<br><span class="hljs-comment">-- Order the result by user_id</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-quiet-students-in-all-exams/">1412. 查找成绩处于中游的学生</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> t1.student_id,s.student_name<br><span class="hljs-keyword">from</span><br>(<br>    <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>,<br>    if(<span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> exam_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score <span class="hljs-keyword">desc</span>)<span class="hljs-operator">=</span><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) d_rank,<br>    if(<span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> exam_id <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score )<span class="hljs-operator">=</span><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) a_rank<br>    <span class="hljs-keyword">from</span> Exam<br>) t1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Student s<br><span class="hljs-keyword">on</span> t1.student_id <span class="hljs-operator">=</span> s.student_id<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> t1.student_id<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">sum</span>(d_rank)<span class="hljs-operator">=</span><span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">sum</span>(a_rank)<span class="hljs-operator">=</span><span class="hljs-number">0</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> student_id<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-subtasks-that-did-not-execute/">1767. 寻找没有被执行的任务对</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> TT(task_id, subtask_id) <span class="hljs-keyword">AS</span> (<br>    <span class="hljs-keyword">SELECT</span> task_id, subtasks_count <span class="hljs-keyword">FROM</span> Tasks<br>        <span class="hljs-keyword">UNION</span><br>    <span class="hljs-keyword">SELECT</span> task_id, (subtask_id<span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> subtasks_count <br>    <span class="hljs-keyword">FROM</span> TT <br>    <span class="hljs-keyword">WHERE</span> subtask_id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TT<br><span class="hljs-keyword">WHERE</span> (task_id, subtask_id) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Executed )<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/report-contiguous-dates/">1225. 报告系统状态的连续日期</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> type <span class="hljs-keyword">as</span> period_state, <span class="hljs-built_in">min</span>(<span class="hljs-type">date</span>) <span class="hljs-keyword">as</span> start_date, <span class="hljs-built_in">max</span>(<span class="hljs-type">date</span>) <span class="hljs-keyword">as</span> end_date<br><span class="hljs-keyword">from</span><br>(<br>    <span class="hljs-keyword">select</span> type, <span class="hljs-type">date</span>, subdate(<span class="hljs-type">date</span>,<span class="hljs-built_in">row_number</span>()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> type <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-type">date</span>)) <span class="hljs-keyword">as</span> diff<br>    <span class="hljs-keyword">from</span><br>    (<br>        <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;failed&#x27;</span> <span class="hljs-keyword">as</span> type, fail_date <span class="hljs-keyword">as</span> <span class="hljs-type">date</span> <span class="hljs-keyword">from</span> Failed<br>        <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br>        <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;succeeded&#x27;</span> <span class="hljs-keyword">as</span> type, success_date <span class="hljs-keyword">as</span> <span class="hljs-type">date</span> <span class="hljs-keyword">from</span> Succeeded<br>    ) a<br>)a<br><span class="hljs-keyword">where</span> <span class="hljs-type">date</span> <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;2019-12-31&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> type,diff<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> start_date<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch基础</title>
    <link href="/2023/03/31/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/ElasticSearch/ElasticSearch%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/31/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/ElasticSearch/ElasticSearch%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><em>ELK</em><br>ELK(elastic stack)是一个日志数据分析、监控技术栈，包括如下技术：<br><img src="/Pasted%20image%2020230423185915.png"></p><ul><li>Beats：面向轻量采集器平台；</li><li>Logstash：动态数据收集管道，支持不同来源采集数据；</li><li>ElasticSearch：对数据进行<strong>搜索、分析和存储</strong>；<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html">手册</a></li><li>Kibana：数据可视化，以图表方式展示。<a href="https://www.elastic.co/guide/cn/kibana/current/index.html">手册</a></li></ul><blockquote><p>用户密码为：elastic、elastic</p></blockquote><p><em>Elastic Search</em><br>基于lucene，是一个基于Java语言的搜索引擎类库。</p><p><em>日志最佳实践</em><br><img src="/Pasted%20image%2020230423225047.png"></p><p><em>应用性能管理最佳实践</em><br><img src="/Pasted%20image%2020230423225105.png"></p><p><em>高可用方案</em><br><img src="/Pasted%20image%2020230423225241.png"></p><p><em>多数据源上传</em><br><img src="/Pasted%20image%2020230423225310.png"></p><p><em>跨集群搜索</em><br><img src="/Pasted%20image%2020230423225329.png"></p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><em>目的</em><br>正向索引如mysql在进行模糊搜索时需要进行全表扫描，效率过低，因此引入倒排索引。</p><p><em>概念</em></p><ul><li>文档：用于数据搜索，每条数据就是一个文档。</li><li>词条：对文档数据或用户搜索数据，利用分词器进行分词，得到若干词条。</li><li>倒排索引：对文档进行分词，保存在<strong>倒排索引表</strong>中；搜索时分词，匹配词条搜索；</li></ul><p><em>正向与倒排</em></p><ul><li>正向：根据文档找词条，对非索引字段只能全表扫描</li><li>倒排：根据词条找文档，不能对字段创建索引</li></ul><p><em>与SQL对比</em></p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引库(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p><em>Mapping</em></p><ul><li>type：字段数据类型：常见的有<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li><li>地理位置：geopoint（坐标点）、geo_shape（由坐标点组成的复杂图像）</li></ul></li><li>index：是否创建索引（与索引库是两个概念），默认为true</li><li>analyzer：使用的分词器</li><li>properties：子字段</li><li>copy_to：表示会将该字段拷贝到指定字段，通过该方式可以将多个字段合并以供搜索</li></ul><p><em>分词器</em></p><ul><li>查询粒度设置：<ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员学习java太棒了&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>词条设置：修改<code>IkAnalyzer.cfg.xml</code>文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h1><h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><p><em>增加索引库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /<span class="hljs-punctuation">&#123;</span>索引库名称<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;子字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// ...略</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>修改索引库</em><br><strong>无法修改mapping中已有的字段</strong>，否则需要重建倒排索引，过于复杂。但允许新增字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>查询索引库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库库名称<br></code></pre></td></tr></table></figure><p><em>删除索引库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名<br></code></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><p><em>新增文档</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>查询文档</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库名称/_doc/文档id<br></code></pre></td></tr></table></figure><p><em>修改文档</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//全量修改</span><br>PUT /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">//增量修改</span><br>POST /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;新的值&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意到增量修改url中使用了<code>_update</code>，json中需要补充<code>&quot;doc&quot;</code>表示修改文档。</p></blockquote><h2 id="JavaClient"><a href="#JavaClient" class="headerlink" title="JavaClient"></a>JavaClient</h2><p><em>依赖与配置</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据SpringBoot的需要，可能要覆盖默认版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建客户端</span><br><span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure><p><em>索引操作</em><br><img src="/Pasted%20image%2020230424195524.png"></p><p><em>操作模板</em><br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-getting-started.html">官网API</a></p><ul><li>创建请求对象：<code>[Create][Index]Request</code><ul><li>根据需要，<code>Create</code>可替换为<code>Get</code>、<code>Delete</code></li><li>修改文档时，<code>Create</code>改为<code>Index</code>，不写第二个<code>Index</code></li></ul></li><li>携带请求参数：<code>request.source(json文本，XContentType.JSON)</code></li><li>发起请求：<code>client.indices().[create](request,RequestOptions.DEFAULT)</code>，同理<code>Create</code>可替换为其他参数</li><li>批量请求：可创建<code>BulkRequest</code>对象然后将其他请求add进来一起发送</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>ElasticSearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>生成密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C renyu.jin@outlook.com<br></code></pre></td></tr></table></figure><h1 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下配置如果不使用global则只在当前仓库生效</span><br>git config --global user.name 用户名<span class="hljs-comment">#设置用户签名</span><br>git config --global user.email 邮箱<span class="hljs-comment">#设置用户email地址</span><br></code></pre></td></tr></table></figure><h1 id="本地命令"><a href="#本地命令" class="headerlink" title="本地命令"></a>本地命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基础操作</span><br>git init<span class="hljs-comment">#初始化本地库</span><br>git status<span class="hljs-comment">#当前工作目录的状态，包括已修改的文件、未跟踪的文件、已暂存的文件等信息</span><br>git add 文件名<span class="hljs-comment">#添加到暂存区</span><br>git diff <span class="hljs-comment">#比较文件或提交之间差异的 Git 命令</span><br>git diff <span class="hljs-comment">#比较工作目录与暂存区差异</span><br>git diff HEAD <span class="hljs-comment">#比较工作目录中的未提交更改与最新提交之间的差异（可以使用 -- filename指定具体比较文件）</span><br>git diff commit1 commit2 <span class="hljs-comment">#显示两个提交之间的差异</span><br>git diff filename <span class="hljs-comment">#显示指定文件的差异</span><br>git diff branch1..branch2 <span class="hljs-comment">#显示两个分支的差异</span><br>git commit -m “日志信息” 文件名<span class="hljs-comment">#提交到本地库</span><br><br><span class="hljs-comment"># 本地版本</span><br>git reflog<span class="hljs-comment">#查看所有历史记录</span><br>git <span class="hljs-built_in">log</span> <span class="hljs-comment">#查看版本信息</span><br>git reset --hard 版本号<span class="hljs-comment">#版本穿梭</span><br>git reset --hard HEAD^ <span class="hljs-comment">#回退到上一个版本(有几个^就是几个版本前)</span><br>git reset filename <span class="hljs-comment"># 撤销暂存区文件的更改</span><br>git checkout -- filename <span class="hljs-comment">#将暂存区/版本库的文件覆盖到工作区(使用--指定文件)</span><br>git <span class="hljs-built_in">rm</span> filename <span class="hljs-comment">#删除版本库中的指定文件</span><br><span class="hljs-comment"># 也可以先手动删除，然后再git add filename，这样也会把删除操作添加到暂存区</span><br></code></pre></td></tr></table></figure><blockquote><p>注意<code>git reset filename</code>只恢复暂存区内容，<code>git checkout -- filename</code>只恢复工作区内容。</p></blockquote><p><em>工作区和暂存区</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120040900.png"><br>commit后暂存区即为空。</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote -v <span class="hljs-comment">#查看当前所有远程地址别名</span><br>git remote add origin git@github.com:michaelliao/learngit.git <span class="hljs-comment">#添加远程仓库并取别名为origin</span><br>git push 远程仓库别名 远程分支 <span class="hljs-comment">#把本地分支推送到远程master分支，可以添加 -u命令</span><br>git push -u origin master <span class="hljs-comment"># 这样会把本地分支推送到远程的master，并添加分支关联关系，折后就可以直接使用git push origin master了</span><br>git <span class="hljs-built_in">clone</span> 远程地址 <span class="hljs-comment">#将远程仓库的内容克隆到本地</span><br></code></pre></td></tr></table></figure><p><em>初始提交问题</em><br>由于创建仓库时的配置（<code>.gitignore</code>或<code>README.md</code>）会导致远程仓库存在一个初始提交（与本地的仓库存在不相关历史），解决办法有：<br><strong>1.重写本地历史</strong><br><code>git clone</code>远程仓库后，将本地仓库文件复制到新仓库并提交更改。</p><p><strong>2.合并本地和远程历史</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/username/repository.git<br>git pull origin master --allow-unrelated-histories <span class="hljs-comment"># 拉取远程仓库并允许不相关历史</span><br><span class="hljs-comment"># 解决冲突</span><br>git commit -m <span class="hljs-string">&quot;Merged remote and local histories&quot;</span><br>git push origin master<br></code></pre></td></tr></table></figure><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">分支切换</span><br>git branch # 查看当前分支<br>git branch 分支名  # 创建分支<br>git branch -d 分支名 # 删除分支<br>git branch -D 分支名 # 强制删除分支（一般由于有提交未合并到其他分支）<br>git branch -v     #查看分支<br>git checkout 分支名# 切换分支<br>git checkout -b 分支名  # 创建并切换分支<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以使用switch替换checkout</span><br>git switch 分支名 = git checkout 分支名<br>git switch -c 分支名 = git checkout -b 分支名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">暂存</span><br>git stash # 将工作区和暂存区内容缓存起来<br>git stash list # 列出所有stash内容<br>git stash apply [stashid,可选] # 恢复缓存内容（stash内容并不删除）<br>git stash drop # 删除stash<br>git stasg pop = git stash apply+git stash drop<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将一个commit应用于当前分支（避免使用整个合并）</span><br>git cherry-pick [commitid]<br></code></pre></td></tr></table></figure><p><em>checkout操作</em></p><ul><li>行为：<ul><li>对于工作区：如果做了修改但未暂存，则Git会检查更改与新分支上文件的冲突。</li><li>对于暂存区：会随着分支切换出现在新分支的暂存区。</li></ul></li><li>处理：<ul><li>若需要更改到当前分支：需要先<code>add</code>，<code>commit</code></li><li>若暂时不想提交：需要使用<code>git stash</code>保存工作区和暂存区内容</li><li>若要放弃更改：使用<code>git checkout -- &lt;file&gt;</code>放弃更改。</li></ul></li></ul><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --graph <span class="hljs-comment"># 查看提交历史和分支图</span><br>git merge 分支名<span class="hljs-comment"># 把指定的分支合并到当前分支上</span><br>git merge 分支名 -m <span class="hljs-string">&quot;comment&quot;</span> --no-ff <span class="hljs-comment"># 添加描述 &amp; 禁用快进模式</span><br></code></pre></td></tr></table></figure><p><em>merge操作</em><br>行为：</p><ul><li>对于工作区：将工作区、当前分支和merge分支的合并结果添加到工作区（包括冲突文件）</li><li>对于暂存区：如果merge合并成功，则文件会被自动添加到暂存区并提交。若出现冲突，需要手动将冲突文件add进暂存区再手动<code>commit</code>。</li></ul><p>处理：</p><ul><li>merge行为会使用暂存区，因此最好先<code>commit</code>好暂存区再<code>merge</code>。</li><li>merge行为会将利用三个文件（工作区、版本库、merge分支）合并，因此如果工作区存在需要先添加到版本库的更改也要先进行<code>add</code>、<code>commit</code>。</li></ul><p>模式：</p><ul><li>Fast-forward模式（快进模式）：如果目标分支dev是本分支master的child（本分支在merge前相对dev没有其他提交），则本分支的指针会直接指向目标分支实现合并（以dev分支的最新提交作为本分支状态），这样的方式会屏蔽掉dev分支的改动细节，如下图所示。</li></ul><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120211227.png"></p><ul><li>No Fast-forward：当无法快进（即存在冲突）或强制禁用快进模式（使用–no-ff）时，会在merge时生成新的commit，如下图所示。</li></ul><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120214755.png"></p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase main <span class="hljs-comment"># 换基为main的最新提交，然后将本分支的commit应用在这个最新提交上。</span><br></code></pre></td></tr></table></figure><p><em>对比merge与rebase</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120222948.png"><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120223014.png"><br>rebase的场景一把是创建分支后，原分支有了一些新的提交，此时可以使用rebase将本分支的基更换为新提交，其优缺点如下：</p><ul><li>优点：让项目提交历史变得非常干净整洁，形成线性的项目提交历史。</li><li>缺点：失去了安全性和可追溯性，因为这相当于对该分支的历史进行了修改，且其会为本分支的提交生成新的提交信息（commit id会变化）</li></ul><p><em>可交互式rebase</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout feature<br>git rebase -i main<br></code></pre></td></tr></table></figure><p>执行以上命令会打开一个文本编辑器，其中内容为分支中需要移动的所有提交列表：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pick</span> <span class="hljs-number">33</span>d5b7a Message for commit #<span class="hljs-number">1</span><br><span class="hljs-attribute">pick</span> <span class="hljs-number">9480</span>b3d Message for commit #<span class="hljs-number">2</span><br><span class="hljs-attribute">pick</span> <span class="hljs-number">5</span>c67e61 Message for commit #<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以将<code>pick</code>修改成<code>fixup</code>，表示将<code>commit #1</code>和<code>commit #2</code>合并。<br>当保存并关闭这个文件之后，Git会根据调改结果执行rebase操作。</p><h3 id="rebase使用"><a href="#rebase使用" class="headerlink" title="rebase使用"></a>rebase使用</h3><p><em>rebase使用黄金法则</em><br><strong>永远不要在公共分支上使用它</strong>，它会改变该分支的历史，导致其他使用该分支的用户出现历史错乱。</p><p><em>Force-Pushing</em><br>背景：如果确实对main分支进行了rebase操作，然后想把main分支推送到远程仓库。这时Git会因为本地分支的提交与远程分支的提交发生了冲突，而阻止这次的推送。<br>但是仍然可以通过使用–force选项来强行进行推送，这样会将远程仓库的历史更换为本地仓库的历史。<br>建议不要这样做，除非远程仓库的工作流确实需要被变更。此时仍要确认是否有其他也在这个分支上协作的用户。</p><p><em>本地清理</em><br>可以利用rebase重塑历史的能力对本地的多次提交进行修改、合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout feature<br>git rebase -i HEAD~3<br></code></pre></td></tr></table></figure><p>上面命令将允许编辑HEAD前的3个提交，如下图所示：<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120233513.png"><br>如果我们希望从基节点开始重塑feature，可以调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge-base feature main<br></code></pre></td></tr></table></figure><p>该命令会返回原始base的commit ID，便于我们使用<code>rebase -i</code>重塑feature的提交。这种不同于<code>rebase -i main</code>，它不会换基到main的最新提交上，只是单纯的重塑提交。</p><blockquote><p>参考文档：<a href="https://zhuanlan.zhihu.com/p/493953965">Git使用Merge和Rebase区别及心得技巧</a></p></blockquote><h1 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h1><h2 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h2><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240120215010.png"><br>在多人合作开发中，本地仓库分支状态：</p><ul><li>master分支需要时刻与远程同步</li><li>dev分支也需要时刻与远程同步</li><li>bug分支无需推送到远程</li><li>feature分支根据需要推送到远程</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --set-upstream-to=origin/dev dev[可选，默认本分支] <span class="hljs-comment"># 建立分支关联</span><br>git branch -u origin/dev dev[可选，默认本分支] <span class="hljs-comment"># 简写</span><br>git branch -vv <span class="hljs-comment"># 查看本地分支和远程分支跟踪情况</span><br>git pull = git fetch + git merge<br>git pull --rebase <span class="hljs-comment"># 将merge操作替换为rebase</span><br>git push origin &lt;branch-name&gt; <span class="hljs-comment"># 推送修改</span><br>git push -u origin &lt;branch-name&gt; <span class="hljs-comment"># 同时推送并建立分支关联</span><br><br></code></pre></td></tr></table></figure><ul><li>Clone下来时，本地只有<code>master</code>分支，需要使用<code>git checkout -b dev origin/dev</code>拉取远程的<code>dev</code>分支。</li><li>正常情况，可以直接在本地修改<code>dev</code>分支后<code>push</code>到远端；但此时远端已经发生变换时，需要先<code>pull</code>合并解决<code>dev</code>分支的冲突后再<code>push</code>上去。</li></ul><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag 标签 <span class="hljs-comment"># 为当前commit加标签</span><br>git tag 标签 提交ID <span class="hljs-comment"># 为目标提交ID加标签</span><br>git tag -a 标签 -m <span class="hljs-string">&quot;comment&quot;</span> 提交ID <span class="hljs-comment">#为目标提交ID加标签，并加描述</span><br>git tag -d 标签 <span class="hljs-comment"># 删除标签</span><br><br><span class="hljs-comment"># 上面的操作只存在于本地，若要推送到远端，需执行：</span><br>git push origin 标签 <span class="hljs-comment"># 推送指定标签</span><br>git push origin --tags <span class="hljs-comment"># 推送所有标签</span><br><br>git push origin :refs/tags/标签 <span class="hljs-comment">#删除远程指定标签</span><br></code></pre></td></tr></table></figure><h1 id="管理规范"><a href="#管理规范" class="headerlink" title="管理规范"></a>管理规范</h1><h2 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h2><ul><li>master：主分支，部署生产环境</li><li>develop：开发分支，保持最新完成</li><li>feature：基于dev分支，命名为<code>feature/module</code>，module为开发的功能模块</li><li>test：测试环境，相对稳定</li><li>release：预发模块，由test或hotfix分支合并，不建议在release上修改代码</li><li>hotfix：以master为基线，创建hotfix分支及时修复，需要合并到master分支和develop分支</li></ul><h2 id="分支与环境"><a href="#分支与环境" class="headerlink" title="分支与环境"></a>分支与环境</h2><ul><li>DEV 环境（Development environment）：用于开发者调试使用。</li><li>FAT环境（Feature Acceptance Test environment）：功能验收测试环境，用于测试环境下的软件测试者测试使用。</li><li>UAT环境 （User Acceptance Test environment）：用户验收测试环境，用于生产环境下的软件测试者测试使用。</li><li>PRO 环境（Production environment）：生产环境。</li></ul><h2 id="合并规范"><a href="#合并规范" class="headerlink" title="合并规范"></a>合并规范</h2><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/Pasted-image-20240121001345.png"></p><h2 id="Commit-Message规范"><a href="#Commit-Message规范" class="headerlink" title="Commit Message规范"></a>Commit Message规范</h2><p><em>简易版</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>):<span class="hljs-tag">&lt;<span class="hljs-name">subject</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>标准版</em></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><ul><li>type：提交类型  </li><li>scope：可选项，本次 commit 波及的范围  </li><li>subject：简明扼要的阐述下本次 commit 的主旨，在<code>Angular Git Commit Guidelines</code>中强调了三点。使用祈使句，首字母不要大写，结尾无需添加标点  </li><li>body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机  </li><li>footer: 描述下与之关联的 issue 或 break change</li></ul><p><em>type规范</em></p><ul><li>feat: 新增功能  </li><li>fix: 修复bug  </li><li>docs: 仅文档更改  </li><li>style: 不影响代码含义的更改（空白、格式设置、缺失 分号等）  </li><li>refactor: 既不修复bug也不添加特性的代码更改  </li><li>perf: 改进性能的代码更改  </li><li>test: 添加缺少的测试或更正现有测试  </li><li>chore: 对构建过程或辅助工具和库（如文档）的更改</li></ul><p>此外还有：</p><ul><li>delete：删除功能或文件  </li><li>modify：修改功能  </li><li>build：改变构建流程，新增依赖库、工具等（例如webpack、gulp、npm修改）  </li><li>test：测试用例的新增、修改  </li><li>ci：自动化流程配置修改  </li><li>revert：回滚到上一个版本</li></ul><p><em>单次提交注意事项</em></p><ul><li>提交问题必须为同一类别  </li><li>提交问题不要超过3个  </li><li>提交的commit发现不符合规范，需要通过进行以下的任一策略解决：<ul><li><code>git commit --amend -m &quot;新的提交信息&quot;</code>补充提交（该语句可以补充提交的文件内容，并修改message）。</li><li><code>git reset --hard HEAD</code> 重新提交一次。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>常用工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Git</tag>
      
      <tag>常用工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><em>NAT（VMnet8）</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/v2-cba959e53f730199ecfb6b001e0497ea_1440w.webp"><br>每台虚拟机有自己的虚拟网卡与虚拟交换机通讯，本处未标出来。<br>为整个虚拟网络设置了一个虚拟DHCP服务器，并为该DHCP服务器分配了一个子网。后续Linux操作系统开启时，自动获得IP。<br><strong>每个虚拟机和主机不需要在同一个网段，而是通过NAT转换实现借用主机网关发送请求。</strong></p><p><em>Briged（VMnet0）</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/v2-3c4584024508a5632e1932b5e524ecdf_1440w.webp"><br>每台虚拟机有自己的虚拟网卡与虚拟交换机通讯，本处未标出来。<br><strong>虚拟机和主机要在同一个网段，相当于只是借用主机网关向真路由器发请求。</strong></p><p><em>Only Host（VMnet1）</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/v2-f3d48608da3167419b71c740e11d6c37_1440w.webp"><br>只与主机内网通讯。</p><h2 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h2><p>1.本地生成RSA公钥和密钥，将公钥上传到Linux服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp C:\Users\Jin\.ssh\id_rsa.pub root@192.168.196.128<br></code></pre></td></tr></table></figure><p>2.远程连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@192.168.196.128<br></code></pre></td></tr></table></figure><p>3.输入密码：root</p><h1 id="二、Linux"><a href="#二、Linux" class="headerlink" title="二、Linux"></a>二、Linux</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><em>用户相关</em></p><ul><li>&#x2F;bin：二进制文件</li><li>&#x2F;sbin：超级管理员二进制文件</li><li>&#x2F;home：普通用户的主目录，相当于Users，其下每一个文件夹代表一个用户的文件</li><li>&#x2F;root：超级管理员的主目录</li></ul><p><em>应用程序</em></p><ul><li>&#x2F;usr：相当于program files，可安装应用的核心文件</li><li>&#x2F;etc：配置文件和子目录</li></ul><p><em>文件相关：</em></p><ul><li>&#x2F;mnt：挂载文件系统</li><li>&#x2F;opt：额外安装软件使用的目录，如数据库内存</li><li>&#x2F;usr&#x2F;local：也是供本机额外安装软件的目录</li><li>&#x2F;var：日志文件等经常修改的文件</li></ul><p><em>系统相关：</em><br>常用：</p><ul><li>&#x2F;boot：Linux启动核心文件</li><li>&#x2F;lib：动态连接共享库，应用程序都需要用到这个文件夹下的文件</li><li>&#x2F;lost+found：非法关机后存放临时文件</li></ul><p>不常用（不要修改）：</p><ul><li>&#x2F;proc：虚拟目录，是内存映射</li><li>&#x2F;srv：service缩写</li><li>&#x2F;sys：文件系统</li></ul><p><em>设备相关：</em></p><ul><li>&#x2F;dev：设备管理器</li><li>&#x2F;media：外接设备</li></ul><p><em>磁盘挂载</em>：<br>磁盘的不同分区会挂载在文件系统的不同目录中</p><h1 id="三、Vi与Vim"><a href="#三、Vi与Vim" class="headerlink" title="三、Vi与Vim"></a>三、Vi与Vim</h1><p>基本概念：</p><ul><li><code>vim 文件</code>后进入<strong>一般模式</strong></li><li>使用<code>i</code>或<code>a</code>或<code>r</code>进入<strong>编辑模式</strong>，ESC返回一般模式</li><li>使用<code>:</code>或<code>/</code>进入<strong>命令模式</strong>，ESC返回一般模式，命令模式下使用<code>:wq</code>、<code>:q</code>、<code>:q!</code>等退出vim。</li></ul><p><em>快捷键</em></p><ul><li>拷贝：<code>yy</code>，拷贝当前行下5行 5yy</li><li>删除：<code>dd</code>，删除当前行下5行 5dd</li><li>命令模式下：<code>/关键词</code></li></ul><h1 id="四、开机、重启"><a href="#四、开机、重启" class="headerlink" title="四、开机、重启"></a>四、开机、重启</h1><p><em>关机、重启</em></p><ul><li>shutdown -h now 现在关机</li><li>shutdown -h 1 1分钟后关机</li><li>shutdown -r now 现在重启计算机</li><li>halt 关机</li><li>reboot 重启</li><li>sync 内存同步到磁盘</li></ul><blockquote><p>所有关机操作都会先执行sync</p></blockquote><p><em>用户登录和注销</em></p><ul><li>su user 切换到user用户</li><li>sudo cmd 允许临时使用超级管理员身份执行cmd，需要输入密码</li><li>logout 登出</li></ul><h1 id="五、用户管理"><a href="#五、用户管理" class="headerlink" title="五、用户管理"></a>五、用户管理</h1><p><em>用户管理</em></p><ul><li>useradd 添加用户</li><li>userdel 删除用户</li><li>su user 切换用户（高权限可随意切低权限，低权限切高权限要密码）</li><li>passwd user 修改用户密码</li><li>whoami 查询用户名</li></ul><p><em>组管理</em></p><ul><li>groupadd 添加组</li><li>groupdel 删除组</li></ul><p><em>用户与组</em></p><ul><li>useradd -g 用户组 用户名</li><li>usermod -g 用户组 用户名</li></ul><p><em>权限</em><br>权限分类：rwx，可读&#x2F;可写&#x2F;可执行，通过<code>ll</code>命令可查看权限：第一位为文件类型，后面三组，分别是所属用户&#x2F;所属组&#x2F;其他用户的权限。</p><ul><li>ls -ahl 查看文件管理者</li><li>chown 用户名 文件名 修改文件管理者</li><li>chgrp 组名 文件名 将文件转入该组</li><li>chmod ?+? 修改权限，前一个？可以为u、g、o代表不同所属，后一个？可以为rwx。</li></ul><h1 id="六、实用指令"><a href="#六、实用指令" class="headerlink" title="六、实用指令"></a>六、实用指令</h1><p><em>运行级别</em><br>例子：0：关机 3：多用户有网络 5：图形界面<br>指令：init n</p><p><em>获取帮助</em></p><ul><li>man cmd，包括shell外部信息</li><li>help cmd，只包括shell内部信息</li></ul><p><em>文件目录类</em></p><ul><li>pwd 当前目录绝对路径</li><li>ls 当前目录下文件和目录 <code>-l</code>以列表形式给出</li><li>cd 移动</li><li>mkdir 生成目录 <code>-p</code>生成多级目录</li><li>rmdir 删除目录，只能删除空目录，删除非空目录：<code>rm -rf 文件夹</code></li></ul><p><em>文件类</em></p><ul><li>touch 生成空文件</li><li>cp source target 拷贝文件 <code>-r</code>递归复制</li><li>rm 删除</li><li>mv old new 移动&#x2F;重命名文件</li></ul><p><em>文件查看</em></p><ul><li>cat 查看 <code>-n</code>显示行号</li><li>more 查看文本查看器，内置了很多翻页的快捷键，如空格翻页</li><li>less 查看文本查看器，更强大的文本查看器</li><li>echo 将内容输出到控制台</li><li>head 显示文件前10行</li><li>tail 显示文件后10行，<code>-f</code> 可以追踪文件更新，实时监控</li></ul><p><em>写入和追加</em></p><ul><li><code>&gt;</code>:ls -l&gt;文件 写入文件</li><li><code>&gt;&gt;</code>:ls -al&gt;&gt;文件 追加到文件末尾</li></ul><p><em>常用的文件查找</em></p><ul><li>find 查找起点 查找文件名 递归查找文件 eg: <code>find /home hello.txt</code></li><li>locate 文件名 快速定位文件 eg:<code>locate hello.txt</code></li><li><strong>grep 查找内容 源文件</strong>，可以将源文件以管道的形式传入，eg：<code>cat /home/hello.txt |grep &quot;yes&quot;</code></li></ul><p><em>其他</em></p><ul><li>ln -s sourse 链接名， 创建一个软连接</li><li>history 查看历史命令</li><li>data “+%Y-%m-%d %H:%M:%S” 显示年月日时分秒 <code>-s</code>设置</li></ul><p><em>打包压缩</em></p><ul><li>gzip&#x2F;gunzip</li><li>zip&#x2F;unzip</li><li>tar xxx.tar.gz 打包内容 （打包到压缩文件，格式未.tar.gz）</li></ul><h1 id="七、定时任务"><a href="#七、定时任务" class="headerlink" title="七、定时任务"></a>七、定时任务</h1><p><em>任务调度</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.crontab -e<br>2.*/1 * * * * * 任务内容<br>2.或sh脚本<br></code></pre></td></tr></table></figure><p><em>cron其他</em></p><ul><li>crontab -r终止</li><li>crontab -l查看</li></ul><p><em>定时任务（一次性）</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.at 5pm + 2days<br>2.任务内容<br></code></pre></td></tr></table></figure><p><em>at其他</em></p><ul><li>atrm删除</li><li>atq查看</li></ul><h1 id="八、进程管理"><a href="#八、进程管理" class="headerlink" title="八、进程管理"></a>八、进程管理</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>-a</code>显示所有，<code>-u</code>显示详情，<code>-x</code>显示其他使用者的线程<br><code>-e</code>显示所有进程<br><code>-f</code>全格式<br>常用： ps -ef|grep xxx</p><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p>pstree，可以看进程树，<code>-u</code>查看用户</p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><code>-P</code>按CPU使用率排序，默认<br><code>-M</code>按内存使用率排序<br><code>-N</code>按PID排序</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill -9 pid，-9表示强制<br>killall name，支持通配符杀进程</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>服务本质就是运行在后台的守护进程，在&#x2F;etc&#x2F;init.d中执行程序<br>service xxx start&#x2F;stop&#x2F;reload&#x2F;status<br>可以为服务设置在对应的运行级别下是否自动开启关闭。<br>chkconfig –level 3 服务名 off</p><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><strong>systemctl兼容了service</strong>，也会去&#x2F;etc&#x2F;init.d中执行程序<br>systemctl start xxx服务</p><p>systemctl start farewalld 开启防火墙<br>firewall-cmd –premanent -add-port&#x3D;端口 打开端口<br>firewall-cmd –premanent -remove-port&#x3D;端口 打开端口</p><h1 id="九、Shell编程"><a href="#九、Shell编程" class="headerlink" title="九、Shell编程"></a>九、Shell编程</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>key&#x3D;value，定义变量</li><li>unset key 撤销变量</li><li>readonly key&#x3D;value，定义静态变量（无法撤销）</li><li>read -p “aaaaaa&#x3D;” num1 阻塞获取控制台输入，赋值给变量num1</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>export key&#x3D;value 设置环境变量</li><li>source 配置文件 修改后信息立刻生效</li><li>echo $key 查询环境变量</li></ul><h2 id="shell内置变量"><a href="#shell内置变量" class="headerlink" title="shell内置变量"></a>shell内置变量</h2><ul><li><code>$1</code>，获取执行shell脚本时携带的参数</li><li><code>$*</code>，获取执行shell脚本时携带的所有</li><li><code>$#</code>，获取执行shell脚本时携带的参数列表</li><li><code>$$</code>，当前进程号</li><li><code>$!</code>，后台运行的最后一个进程号</li><li><code>$?</code>，上一个指令的返回状态，0为成功</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul><li>$计算，使用<code>()或[]</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">res=$((2+3)*4)<br>echo &quot;res=$res&quot;<br></code></pre></td></tr></table></figure></li><li>expr计算<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">res=`expr 2+3`<br></code></pre></td></tr></table></figure></li></ul><h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><p><em>包下载器</em><br>rpm、yum、apt-get（Unbuntu）</p><p><em>环境变量配置</em><br>vim &#x2F;etc&#x2F;profile 系统环境变量<br>vim ~&#x2F;.bashrc 用户环境变量</p><p><em>备份与恢复</em><br>dump、restore，需要下载</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>常用工具</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>常用工具</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><em>定义</em></p><ul><li>事务：一次大型活动，其中所有活动要么全部成功要么全部失败</li><li>本地事务：基于关系型数据库的事务，利用数据库本身的事务性质实现</li><li>分布式事务：<strong>跨数据库连接的事务</strong>，如多服务多数据库，单服务多数据库，多服务单数据库</li></ul><p><em>分布式事务产生的原因</em></p><ul><li>数据库拆分（同应用不同库）</li><li>服务拆分（不同应用不同库）</li></ul><h1 id="二、分布式事务概述"><a href="#二、分布式事务概述" class="headerlink" title="二、分布式事务概述"></a>二、分布式事务概述</h1><h3 id="ACID（事务规范）"><a href="#ACID（事务规范）" class="headerlink" title="ACID（事务规范）"></a>ACID（事务规范）</h3><p><em>定义</em><br>参照事务的基本规范：</p><ul><li>原子性：分布式事务无法保证原子性，是逐个分支事务提交（刚性事务近似原子）；</li><li>一致性：分布式事务一般只保证最终一致性（刚性事务接近实时原子）；</li><li>隔离性：分布式事务所操作的业务数据是否会因为被其他事务脏写，取决于框架实现；</li><li>持久性：分布式事务能实现持久性。</li></ul><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p><em>定义</em><br>一致性，可用性，分区容错性</p><p><em>概念</em></p><ul><li>分区容错性：因为不可能保证网络的可靠，所以系统必须实现分区容错性</li><li>一致性与可用性的矛盾：分区的存在导致数据同步存在延迟，如果要保证一致性，就只能让尚未实现同步的数据不可用。</li></ul><p><em>模式</em></p><ul><li>AP模式：允许数据短暂不一致，只要求最终一致</li><li>CP模式：强一致，数据在同步完成前不可用</li></ul><h3 id="柔性事务（BASE理论）"><a href="#柔性事务（BASE理论）" class="headerlink" title="柔性事务（BASE理论）"></a>柔性事务（BASE理论）</h3><p><em>定义</em><br>基本可用（Basice Avaliable）、柔性状态（Soft state）、最终一致性（Eventually consistent），BASE理论是对AP理论的扩展。</p><p><em>概念</em></p><ul><li>基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li><li>软状态：由于不要求强一致，所以系统中会存在中间状态，这个状态不影响系统可用性。</li><li>最终一致性：最终一致指结果一段时间后，所有节点数据都将达到一致。</li></ul><p><em>分类</em></p><ul><li>两阶段型（XA等）</li><li>补偿型（TCC、SAGA、AT等，实际上是<strong>两阶段的业务层实现</strong>）</li><li>异步确保型（消息事务，将同步阻塞的事务变成异步）</li><li>最大努力通知型（消息）</li></ul><h3 id="2PC两阶段协议"><a href="#2PC两阶段协议" class="headerlink" title="2PC两阶段协议"></a>2PC两阶段协议</h3><p><em>定义</em><br><strong>分布式事务的基础协议</strong>，将整个事务流程分为两个阶段，准备阶段P、提交阶段C。</p><p><em>执行</em><br>由TM(Transaction Manager)协调多个资源管理器RM(Resource Manager)，一阶段各RM汇报自身活动状态，二阶段TM决定事务提交或回滚。</p><p><em>特点</em></p><ul><li>超时：<ul><li><strong>事务协调者具有一阶段超时机制</strong>，当一阶段超时时仍未收到个别参与者的响应，会判断事务失败，发送回滚命令。</li><li><strong>事务参与者二阶段不具有超时机制</strong>，当其接受不到二阶段命令时，不会进行操作，此时会有<strong>不一致现象</strong>。</li></ul></li><li>一致性：<strong>刚性事务（刚性事务并不能完全保证一致性，只是理论事务的提交时间是同一时刻）</strong></li></ul><p><em>规范</em><br>DTP模型：分布式事务处理模型，由国际开放标准组织Open Group定义处理模型，DTP模型（Distributed Transaction Processing Reference Model）定义如下角色。</p><ul><li>AP（Application Program）：即<strong>应用程序</strong>，可以理解为使用DTP分布式事务的程序。</li><li>RM（Resource Manager）：即<strong>资源管理器</strong>，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对数据库进行控制，资源管理器控制着分支事务。</li><li>TM（Transaction Manager）：即<strong>事务管理器</strong>，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即一个全局事务。</li></ul><p><em>实现</em><br>XA协议，是X&#x2F;OPEN组织提出的，定义了TM与RM之间的通信接口，从而在<strong>数据库层面</strong>实现的2PC，是刚性事务（虽然是刚性事务，但也无法保证数据一致性）</p><blockquote><p><strong>Percolator协议</strong></p><ul><li>介绍：2PC的改进，基于分布式存储系统BigTable建立的模型</li><li>思想：</li><li>准备阶段，A、B事务执行完成后，在A事务的记录上添加锁标记，B事务的记录上添加执向A事务的锁指针，此时两个记录对外不可见。</li><li>提交阶段，找到A事务锁，抹去，此时A事务完成提交，B事务无需提交，当其找不到A事务的锁的时候即视为提交。</li></ul></blockquote><h3 id="3PC三阶段协议"><a href="#3PC三阶段协议" class="headerlink" title="3PC三阶段协议"></a>3PC三阶段协议</h3><p><em>定义</em><br>三阶段协议在两阶段前加入了一个CanCommit阶段，用于判断各节点健康状态，若存在不健康节点，则不会发起两阶段，避免了健康节点执行PreCommit后又回滚的成本。</p><blockquote><p>3PC以一种非阻塞的方式决定了事务是否开启。</p></blockquote><p><em>特点</em></p><ul><li>超时：<ul><li><strong>事务协调者具有二阶段超时机制</strong>，当二阶段超时时仍未收到个别参与者的响应，会判断事务失败，发送回滚命令。</li><li><strong>事务参与者三阶段具有超时机制</strong>，当参与者一直接受不到三阶段命令时，会进行超时提交（因为三阶段协议下，认为其他节点能执行成功是大概率时间），因此会有<strong>不一致现象</strong>。</li></ul></li><li>一致性：<strong>刚性事务（刚性事务并不能完全保证一致性，只是理论事务的提交时间是同一时刻）</strong></li></ul><h1 id="三、实现方案"><a href="#三、实现方案" class="headerlink" title="三、实现方案"></a>三、实现方案</h1><h2 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h2><p><em>定义</em><br>业务上实现try、comfirm、cancel三个接口，其中try接口起到预占资源的作用，所以一阶段成功后，二阶段是不允许在业务层出现失败的（但可能网络故障，需要重试提交）</p><blockquote><p>TCC本质上是两阶段的业务层实现。</p></blockquote><p><em>特点</em></p><ul><li>超时：机制同2PC的，仅协调者一阶段存在超时机制。</li><li>一致性：柔性事务（当然也不能保证一致性，且达成一致性的时间差比刚性事务要久）</li></ul><p><em>衍生问题</em><br>TCC模式需要业务处理以下问题：防悬挂、空回滚、幂等。<br>详细解决见下文XTS实现。</p><p><em>TCC变体</em></p><ul><li>无try的TCC：一阶段执行业务操作，二阶段confirm无实际操作，二阶段cancel回滚，适用无法使用占用的场景，要重点关注回滚操作是否被及时执行，避免长时间不一致。</li><li>异步TCC：对于不需要实时操作的事务，可以使用异步TCC，即二阶段消息化。</li></ul><h2 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h2><p><em>定义</em><br>自动模式，由框架代理的两阶段提交协议，也叫FMT。</p><p><em>基本原理</em></p><ul><li>一阶段：业务数据和回滚日志（解析sql，保存原快照和改后数据，分别用于回滚和脏写校验）在同一个本地事务中提交</li></ul><p>![[Pasted image 20230904210508.png]]</p><ul><li>二阶段：<ul><li>提交：异步提交，删除回滚日志即可</li><li>回滚：利用回滚日志进行回滚并删除</li></ul></li></ul><p>![[Pasted image 20230904211549.png]]</p><blockquote><p><strong>redo log 与 undo log</strong></p><ul><li>redo log：写后数据</li><li>undo log：写前数据<br>如果redo log与数据库数据不一致，说明发生了脏写，需要人工干预。</li></ul></blockquote><p><em>与TCC的对比</em></p><table><thead><tr><th>模式</th><th>TCC</th><th>FMT</th></tr></thead><tbody><tr><td>原子性</td><td>2PC业务实现</td><td>2PC框架实现</td></tr><tr><td>一致性</td><td>天然实现</td><td>天然实现</td></tr><tr><td>隔离性</td><td>放宽一致性协议条件，最终一致（读已修改）</td><td>1.如果读加锁，串行化隔离级别；2.读不加锁，读已修改隔离级别</td></tr><tr><td>持久性</td><td>天然实现</td><td>天然实现</td></tr><tr><td>写并发控制</td><td>加锁（业务实现，资源锁+业务锁）</td><td>加锁（资源锁 + 框架行锁）</td></tr><tr><td>CAP一致性</td><td>放宽一致性协议条件，最终一致</td><td>1.如果读加锁，强一致；2.读不加锁，最终一致</td></tr></tbody></table><h2 id="SAGA模式"><a href="#SAGA模式" class="headerlink" title="SAGA模式"></a>SAGA模式</h2><p><em>定义</em><br>一系列本地事务串行执行，有以下两种模式：</p><ul><li>基于事件的模式：每个服务执行完本地事务后产生一个事件（消息），其他服务会监听这个事件，从而触发后续服务的执行，回滚时也通过事件发出。只适用于小业务场景，可能出现环形监听、失控。</li><li>基于命令的模式：通过状态机维护事务的阶段和状态，需要一个协调者进行状态推进。</li></ul><p><em>场景</em><br>长事务的解决方案，适用于业务流程多且长的情况，避免TCC事务嵌套。</p><ul><li>正向恢复（Forward Recovery）：如果 Ti 事务提交失败，则一直对 Ti 进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，比如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。</li><li>反向恢复（Backward Recovery）：如果 Ti 事务提交失败，则一直执行 Ci 对 Ti 进行补偿，直至成功为止（最大努力交付）。这里要求 Ci 必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</li></ul><p><em>缺点</em><br>无法保证事务隔离性，也需要空补偿、防悬挂、幂等。</p><p><em>与TCC的对比</em><br>与 TCC 相比，SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。</p><h2 id="最终一致性方案"><a href="#最终一致性方案" class="headerlink" title="最终一致性方案"></a>最终一致性方案</h2><h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>![[Pasted image 20230906195026.png]]<br><em>步骤</em><br>2. 事务发起方把要处理的业务事务和写消息表这两个操作放在同一个本地事务里<br>3. 事务发起方有一个定时任务轮询消息表，把没处理的消息发送到消息中间件<br>4. 事务被动方从消息中间件获取消息后，返回成功<br>5. 事务发起方更新消息状态为已成功</p><p><em>缺点</em><br>业务耦合过强，无法共用、影响性能。</p><h3 id="事务消息-可靠消息"><a href="#事务消息-可靠消息" class="headerlink" title="事务消息(可靠消息)"></a>事务消息(可靠消息)</h3><p>![[Pasted image 20230906200711.png]]<br>见MsgBroker，对比本地消息表，其将消息数据的写入放置在了MQ侧，MQ通过消息回查来处理异常情况。</p><p><em>缺点</em><br>业务需要暴露接口供MQ做消息回查，需要保证接口的安全性，且若由于网络问题一直投递失败，下游无法感知，主要用于内部系统。</p><h3 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h3><p>对比MQ事务消息，其发布者会暴露第三方查询接口供外部访问，下游等待MQ超时后也可以主动查询事务结果，主要用于外部系统。<br>![[Pasted image 20230906200801.png]]</p><blockquote><p>事务消息与最大努力通知的区别：</p><ol><li>解决方案思想不同：事务消息中消息的可靠性由消息发送方保证，最大努力通知中消息的可靠性由消息接受方保证。</li><li>业务场景不同：可靠消息一致性关注的是事务中的一致性，最大努力通知关注的是事务后的通知。</li></ol></blockquote><h2 id="XTS实现原理"><a href="#XTS实现原理" class="headerlink" title="XTS实现原理"></a>XTS实现原理</h2><p><em>基本原理</em></p><ul><li>XTS基于2PC原理。</li><li>事务的发起方作为TM。</li><li>事务发起方在本地事务（必须在本地事务模板中执行）中调用分支事务，该本地事务的最终状态决定整个分布式事务的最终状态。</li><li>框架代理实现二阶段的提交和回滚。</li></ul><blockquote><p><strong>最末参与者优化（LPO）</strong><br>由于两阶段提交的“准备”操作的实现复杂性和效率都会在实际业务中产生影响，支付宝分布式事务 在两阶段提交中引入一个简单的优化——最末参与者优化(Last Participant Optimization)。<br>在这个模型中将<strong>有一个参与者不参加两段提交的过程</strong>（称为单阶段参与者），而是在其余两阶段参与者都准备好之后，再请求单阶段参与者提交，单阶段参与者的提交结果将决定整个分布式事务的结果。如果单阶段参与者提交成功，那么协调者要求其余参与者提交，如果提交失败则协调者要求其余参与者事务回滚。<br>在较新版本的 XTS 中，LPO 这个思想已经演变成了另外一种呈现形式：<strong>所谓的“单阶段参与者”在 XTS 中扮演发起方的角色</strong>，它的功能和两阶段提交中的协调者非常相似但又不尽相同。</p></blockquote><p>![[Pasted image 20230904213122.png]]</p><p><em>状态机</em><br><strong>主事务</strong><br>![[Pasted image 20230904220141.png]]<br><strong>分支事务</strong><br>![[Pasted image 20230904220705.png]]</p><p><em>恢复机制</em><br>二阶段执行出现异常时，恢复系统会自动捞取没有提交成功的参与者进行重试直到提交成功。</p><p><em>防悬挂</em><br>需要一个防悬挂表，一、二阶段都可以执行悬挂记录。</p><ul><li>一阶段到达时先尝试插入幂等表：<ul><li>若能插入说明是首次执行，正常执行即可；</li><li>若无法插入，且发现是一阶段插入的记录，执行幂等操作即可；</li><li>若无法插入，且发现是二阶段插入的记录，拒绝执行。</li></ul></li><li>二阶段到达时先查询悬挂表，若有记录说明一阶段执行完成，执行回滚，否则执行空回滚并插入悬挂记录。</li></ul><p><em>嵌套事务</em><br>嵌套事务在一阶段执行完成后，不会立马提交，需要等待全局事务提交后自己才提交。</p><ul><li>嵌套事务需要认知到自己是一个嵌套事务，一阶段完成后不立马提交；</li><li>嵌套事务在接受到提交请求时，将本地事务提交，并开始提交下游分支事务；</li><li>嵌套事务需要知道自己的根节点事务，以便在出现超时等异常时知道自己的状态。</li></ul><p><em>性能优化</em></p><ul><li>二阶段异步化：一阶段完成后直接返回执行成功，可能由于二阶段执行超时导致数据临时不一致。</li><li>二阶段并发：二阶段的请求并发执行，减少耗时</li></ul><p><em>参与者系统设计规范</em><br>框架层面</p><ul><li>实现两阶段接口：二阶段入参一般只包括事务信息，需要参与者自己做好一二阶段的操作关联。</li><li>业务幂等：同一笔事务只能成功一次</li><li>空回滚：一二阶段乱序时，防止二阶段实际回滚</li><li>防悬挂：一二阶段乱序时，防止一阶段悬挂</li></ul><p><em>业务层面</em></p><ul><li>数据可见性：数据的中间状态对客表达要友好</li><li>隔离性控制：多个事务操作同一个资源时（如余额），需要控制好隔离性</li></ul><blockquote><p>参考资料：<a href="http://wwyz-study.oss-cn-hangzhou.aliyuncs.com/XTS%20%E6%94%AF%E4%BB%98%E5%AE%9D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97.pdf">XTS支付宝分布式事务学习指南</a></p></blockquote><p><em>代码实现</em></p><ul><li>发起者二阶段的提交、回滚以来本地事务的提交、回滚，具体而言，是通过为事务注册事务同步管理器TransactionSynchronizationManager，实现对本地事务提交前的上下文清理，提交后的事务状态修改。</li><li>参与者二阶段的自动提交，来自于一阶段对action的拦截，具体而言，需要参与者将暴露的try接口打上TCC注解（标注了actionName和本类中二阶段对应的两个方法名），发起者启动时便会建立action和方法及其bean的联系，执行一阶段时会插入对应分支事务记录，二阶段时便可以找到分支事务执行对应的方法。</li></ul><h1 id="四、MIT6-824-分布式事务"><a href="#四、MIT6-824-分布式事务" class="headerlink" title="四、MIT6.824 分布式事务"></a>四、MIT6.824 分布式事务</h1><p><em>组成</em><br>分布式事务主要有两部分组成：并发控制、原子提交</p><p><em>隔离性与可序列化</em></p><ul><li><strong>隔离性</strong>意味着<strong>可序列化</strong>，可序列化指并行执行的一些事务得到的结果与按照某种串行的顺序来执行这些事务可以得到相同的结果。</li><li><strong>可序列化</strong>可以确保可以安全的写事务，就像没有其他事情发生一样，如果这些被操作的数据之间没有交集，则事务之间具有<strong>隔离性</strong>。</li></ul><p><em>并发控制</em></p><ul><li>并发控制类型主要分悲观锁，乐观锁两类</li><li><strong>二阶段锁</strong>是一种悲观并发控制，其内容为：<ul><li>在执行任何数据读写之前，需要先<strong>获取锁</strong></li><li>只有事务提交或回滚后，才允许事务<strong>释放锁</strong></li></ul></li></ul><p><em>故障点分析</em></p><ul><li>发起者没有收到一阶段回复，此时发起者会发起二阶段回滚、参与者状态未知：参与者需要实现<strong>幂等、空回滚、防悬挂</strong>。</li><li>一阶段成功，参与者接受到二阶段命令前故障：参与者需要记录本事务的业务信息，以得知在收到二阶段命令后如何执行业务。</li><li>一阶段成功，参与者接受到二阶段命令后故障：这不是分布式事务的特有问题，需要参与者实现二阶段事务的原子性和幂等。</li><li>一阶段成功，参与者回复二阶段时故障：参与者实现二阶段回滚即可。</li></ul><p><em>Commit Point选择</em><br>comimit point即决策整体事务提交or回滚的时点，该时点状态也是事务恢复时依赖的状态。</p><ol><li>使用协调者的提交记录作为commit point，如XA事务（需要防止单点故障），恢复事务时依赖该记录状态。</li><li>所有参与者完成第一阶段时作为commit point，即收集到所有参与者的一阶段ACK，恢复事务时重新问各参与者是否可执行，优势是延迟最小，如OceanBase。</li><li>某一个特殊参与者完成二阶段时为commit point，即从参与者中选出一个primary，提交二阶段时，协调者优先把请求发送给Primary，以Primary提交成功作为事务的Commit Point，缺点是延迟较高，如TiDB。</li></ol>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>分布式事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式事务</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一、消息队列概念"><a href="#一、消息队列概念" class="headerlink" title="一、消息队列概念"></a>一、消息队列概念</h1><h2 id="基本概念与场景"><a href="#基本概念与场景" class="headerlink" title="基本概念与场景"></a>基本概念与场景</h2><p><em>MQ是什么？</em><br>Message Queue（MQ）主要用于不同进程&#x2F;线程之间的通讯，本质是一个队列。</p><p><em>消息队列的作用</em><br>异步、解耦、削峰、日志（如kafka）</p><p><em>与java阻塞队列之间的区别</em><br>消息队列可以实现高可用（集群、分布式），持久化，pull与push两种消费方式，去重、排序等功能。</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p><em>重TOPIC</em><br>实现有kafka、JMS（ActiveMQ），该模式下key≈queue<br><em>轻TOPIC</em><br>实现有RabbitMQ（或者说是AMQP），该模式下需要Broker根据规则计算key所对应的queue，即需要交换机。<br><em>无Broker</em><br>实现有ZeroMQ，其认为MQ是更高级的Socket，致力于解决通讯问题，故其被设计成了一个库而不是一个中间件。</p><h2 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h2><h4 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h4><p><em>Push</em><br>服务端推送。实时性高，但无法获取消费者状态，面对多消费者无法处理消费速度差异。<br><em>Batch Push</em><br>缓冲数组，Broker缓存消息后批量推送，减少推送次数，但需要考虑更多丢包、顺序问题。</p><h4 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h4><p><em>Pull</em><br>客户端拉取。实时性较差。<br><em>Long-Polling</em><br>长请求，服务器有消息时才返回。<br><em>Batch Pull</em><br>long-polling请求+缓冲数组，每次polling请求时，从Broker批量获取消息，减少请求次数，但需要考虑更多丢包、顺序问题。</p><h4 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h4><p><em>Dynamic Pull&#x2F;Push</em><br>polling请求+缓冲数组，每次polling请求时，告知Broker当前消费者的消费能力，发送端尽可能的投递消息到订阅端（不超过订阅端可接受数据量）。</p><h3 id="推拉模型讨论"><a href="#推拉模型讨论" class="headerlink" title="推拉模型讨论"></a>推拉模型讨论</h3><p><em>推vs拉</em></p><ul><li>延迟：拉模型下，一个消息最大要延迟3r+i（3个传输时间+1个拉取间隔）的时间。推模型下，一个消息正常只会延迟1r（1个传输时间）的时间。</li><li>吞吐量：拉模式更高，其一次拉取多条消息，推模式为了追求降低延迟，每条消息独立推送（当然这里也可以优化，类比TCP的延迟ack）。</li><li>消费速率：消费速率上的差异并非是推拉模型上的差异，而是消息的业务需求（顺序性、流控能力）与底层实现（推、拉）做了绑定。<ul><li>认知上推的速率不可控，这是因为中间件的定位，如实时、无序所决定的。</li><li>如果业务方提供了消息的优先级决策策略，推模式也可以实现按需消费和流量控制。</li></ul></li><li>其他差异：消息抗积压能力也并非模型上的差异，而是实现上（DB存储）体现的结果。能否抗积压本质取决于<strong>存储设备是否有足够的空间</strong>以及<strong>设计上是否会因为数据量增大导致读写性能下降</strong>。</li></ul><p><em>结合两者的优势</em><br><strong>问题本质</strong><br>“推拉模型”的选择实际上是发送端发送能力和消费端消费能力的平衡选择：</p><ul><li>发送端速率&gt;消费端速率：“推模型”不安全，可能导致订阅端处理失败或加重其负担。</li><li>发送端速率&lt;消费端速率：“拉模型”不够快，延迟较高。</li></ul><p><strong>动态推拉</strong><br>订阅端通知发送端其可接受的消息量，发送端尽可能的投递消息到订阅端（不超过订阅端可接受数据量）；再结合一些优化，订阅端按需“及时上报”并更新可接受的数据量，可在<strong>安全情况</strong>下达到<strong>接近推</strong>的效率。</p><h2 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h2><ul><li>一个消费者群组消费一个主题中的消息，这种消费模式又称为<code>点对点</code>的消费方式，点对点的消费方式又被称为<strong>消息队列</strong>。</li><li>一个主题中的消息被多个消费者群组共同消费，这种消费模式又称为<code>发布-订阅</code>模式。</li></ul><h2 id="重复消息问题"><a href="#重复消息问题" class="headerlink" title="重复消息问题"></a>重复消息问题</h2><p><em>重复生产</em><br>消息队列对一个消息ID只做一次处理。具体地，消息队列会给每一个生产者一个唯一的 ID，并且为生产的每一条消息赋予一个唯一 ID，消息队列的服务端会存储 &lt; 生产者 ID，最后一条消息 ID&gt; 的映射。当某一个生产者产生新的消息时，消息队列服务端会比对消息 ID 是否与存储的最后一条 ID 一致，如果一致，就认为是重复的消息，服务端会自动丢弃。</p><p><em>重复消费</em><br>为了保证消息不丢失，「失败重试」机制是必不可少的，必须考虑保证消费端的幂等性：</p><ul><li>通用层：消息ID幂等，对每个消息ID只做一次处理，但需要使用事务保证消息的消费和消息ID的持久化的一致性，代价较大。</li><li>应用层：业务上实现幂等，如乐观锁、状态机等。</li></ul><h2 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h2><p><em>消息丢失可能出现的地方</em></p><ol><li>消息生产阶段产生消息丢失<ul><li>网络传输中丢失消息</li><li>MQ发送异常</li></ul></li><li>消息存储阶段产生消息丢失<ul><li>MQ 成功接收消息后，内部处理出错</li><li>Broker 宕机</li></ul></li><li>消息消费阶段产生消息丢失<ul><li>采用消息自动确认模式，消费者取到消息后未完成消费（或业务逻辑未执行完）</li></ul></li></ol><p><em>如何保证消息不会丢失？</em></p><ol><li>生产者：<ul><li>事务机制：开启事务后投递消息，若投递失败则事务回滚，然后重试。由于需要同步等待消息投递结果，造成阻塞，造成吞吐量下降。</li><li>确认机制：如RabbitMQ每次写的消息都会分配一个唯一的 ID。Broker 在收到消息后，会返回一个 Ack 信号给生产者，确认消息发送成功。可以异步进行，不会产生阻塞。</li></ul></li><li>消息队列：开启持久化机制，对于集群多副本队列，保证至少写入两台机器后才回复消息确认（具体写入多少台取决于对可用性的要求）</li><li>消费者：手动确认模式，消费者成功消费消息后，再确认。</li></ol><div class="note note-primary">            <p>基于ack机制在高并发模式下的限流控制：为了避免消费者积压大量消息导致OOM，可以为某channel设置最大unack消息数量，当超过该值时，停止向消费者推送消息。</p>          </div><h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p><em>同步重试</em><br>处理失败后立刻执行几次（可能消息堆积）<br><em>异步重试</em><br>写入重试表，稍后重试（影响消费顺序）</p><h2 id="消息顺序问题"><a href="#消息顺序问题" class="headerlink" title="消息顺序问题"></a>消息顺序问题</h2><p>保证消息按顺序执行，即保证「有序性」。「有序性」可分为全局有序和局部有序</p><ol><li>全局有序：<ul><li>只能由一个生产者向 Topic 发送消息，并且一个 Topic 内部只能有一个队列（分区）</li><li>消费者也必须是单线程消费这个队列</li></ul></li><li>局部有序：<ul><li>将 Topic 内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中</li><li>每个队列对应一个单线程处理的消费者</li></ul></li></ol><p>分布式环境下，将同一个来源的消息发到同一个partion上。</p><h2 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><em>原因</em><br>消费端消费消息过慢，导致大量消息积压在 MQ 中。<br><em>后果</em></p><ul><li>消息被丢弃：例如 RabbitMQ 有一个消息过期时间 TTL，过期的消息会被扔掉，这样消息就彻底没有了。</li><li>如果堆积量太大，可能导致磁盘空间不足，那么新消息就进不来了。</li><li>如果消息没过期，并且磁盘空间也够用，那么就是产生海量消息等待被消费，Consumer 的噩梦。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><em>事前：预防与监控</em></p><ul><li>建设监控措施：监控broker的入口&#x2F;出口流量，便于快速发现和定位问题。</li><li>建设弹性扩容能力：根据监控动态提高消费者实例数量，需要公司有一定的弹性架构基础。</li></ul><p><em>事中：评估业务影响，止血</em></p><ul><li>发布方：系统降级，关闭一些不重要业务，减少发送方发送数据量，最低限度让系统还能正常运转。</li><li>中间件：<ul><li>消息丢弃：判断消息的丢弃是否是业务能容忍的，如果可容忍，则可以限制<strong>队列、消息的TTL</strong>或<strong>限制队列的大小、长度</strong>，丢掉队列中的消息或将其投递到死信队列。</li><li>磁盘空间：系统通常都是有监控的，达到空间阈值时就会发警报，在其他机器上创建临时的消息队列，再写一个临时的 Consumer，作为消息的中转，把消息积压队列中的消息取出来，放到临时队列里面去。</li><li>消费模式：更改消费模式，如拉-&gt;推-&gt;批推，消费者也要提前做相应改造。</li></ul></li><li>消费端：扩大消费者数量，通过提高消费速度实现快速处理：<ul><li>不需要保证顺序的，使用多线程&#x2F;多实例加快处理。</li><li>需要保证顺序的或无法扩大消费者数量的场景，按合理的顺序（局部有序）分发到多个指定队列中，即让消费者再次分流消息，实现快速处理。</li></ul></li></ul><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20230922010212.png"><br><em>事后：快速处理海量积压消息</em><br>同事中，扩大消费者数量，通过提高消费速度实现快速处理。</p><div class="note note-primary">            <p><strong>在扩容消费者的实例数的同时，必须同步扩容主题 Topic 的队列（分区）数量，确保消费者的实例数和分区数相等。如果消费者的实例数超过了分区数，由于分区是单线程消费，所以这样的扩容就没有效果。</strong><br>比如在 Kafka 中，一个 Topic 可以配置多个 Partition（分区），数据会被写入到多个分区中。但在消费的时候，Kafka 约定一个分区只能被一个消费者消费，Topic 的分区数量决定了消费的能力，所以，可以通过增加分区来提高消费者的处理能力。</p>          </div><h2 id="主流消息队列"><a href="#主流消息队列" class="headerlink" title="主流消息队列"></a>主流消息队列</h2><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-0f4f29094907bd57584b0caeb6242177_1440w.webp"></p><h1 id="二、RabbitMQ"><a href="#二、RabbitMQ" class="headerlink" title="二、RabbitMQ"></a>二、RabbitMQ</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20230331215449.png"></p><ul><li>Vitual host：虚拟分组，实现用户隔离</li><li>Exchange：对消息进行路由发配，匹配查询表中的routing key，并分发到queue中。</li></ul><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><em>docker启动</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name rabbitmq -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> rabbitmq:<span class="hljs-number">3</span>.<span class="hljs-number">11</span>-management<br></code></pre></td></tr></table></figure><p><em>用户管理</em><br>默认会有一个guest用户为administrator。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl add_user root root<br>rabbitmqctl set_user_tags root administrator<br>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;<br>rabbitmqctl list_users<br></code></pre></td></tr></table></figure><p><em>进程管理</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl stop_app<br>rabbitmqctl reset<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><em>java库</em><br>java需要使用（amqp-client依赖），生产者和消费者都需要使用用户名和密码与MQServer建立Connection，并通过Channel向Server发送请求。</p><p><em>基本组成</em></p><ul><li>生产者发布消息时：<ul><li>需要先声明队列；</li><li>需要指明是否持久化该消息；</li><li>需要指明<strong>交换机和路由</strong>，以及消息体；</li></ul></li><li>消费者消费消息时：<ul><li>需要指明消费<strong>路由</strong></li><li>消费成功后是否自动应答</li><li>消费消息的回调函数（手动应答发送在回调函数中）</li><li>消费被中断（如消息队列被删除）时的回调函数。</li></ul></li></ul><p><em>消息应答</em><br>mq收到消息应答后即可移除消息。</p><ul><li>关闭(none)</li><li>自动应答(auto)：消费者收到消息即回复，只用于消费者消费能力很强的时候。</li><li>手动应答(manual)：<ul><li><code>channel.basicAck(tag,true)</code>，可通过参数指定是否批量应答。</li><li><code>channel.basicNack(tag)</code>，消费失败。</li><li><code>channel.basicReject(tag)</code>，拒绝该消息（可能是死信）。</li></ul></li></ul><p><em>不公平分发实现与预取值</em><br>消费者指定自己的qos等级，其值表示该消费者通道上允许的未确认消息的最大数量。这个值可以在测试中调节到最优。</p><p><em>持久化</em></p><ul><li>队列持久化：声明队列时指定，如果该队列已存在需要先删除。</li><li>消息持久化：生产消息时指定，通知MQ对该消息持久化（默认持久化，不需要特别指定）。</li></ul><h3 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h3><p><em>基本原理</em></p><ul><li>生产者可以将<strong>通道</strong>设置成confirm模式，此后所有的发布的消息都会被指定唯一id（由mq指定，java可以通过<code>getNextPublishSeqNo()</code>获取）。</li><li>生产者消息投递到队列上后，Broker会异步返回消息，告知生产者已经收到消息。<ul><li>如果是持久化队列，Broker会在在完成持久化后返回</li><li>如果MQ出现错误，会返回nack给生产者</li></ul></li></ul><p><em>发布模式</em></p><ul><li>单个确认(<code>simple</code>)：生产者只有确认消息投递成功后，才投递下一条消息。</li><li>批量确认：批量确认，确认前需要保存批量信息在内存中，出现问题时，需要定位出错的消息。</li><li>异步确认(<code>correlated</code>)：生产者通过回调函数来处理投递情况，配合<code>ConcurrentSkipListMap</code>缓存消息，收到ack后移除对应消息或比该消息小的所有消息（取决于mq返回的确认信息时批量确认还是单个确认）</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p><em>临时队列</em><br>如果希望在连接时临时生成一个队列，断开连接后将队列删除，可使用<code>channel.queueDecalare().getQueue()</code>。</p><p><em>bindings</em><br>exchange可以和queue进行绑定，这段绑定关系可以用一个routingKey指定。<br><code>channel.queueBind(queueName,EXCHANGE_NAME,&quot;routingKey&quot;)</code>。</p><p><em>类型分类</em><br>fanout、direct、topic、headers</p><p><em>fanout</em><br>广播交换机，该交换机会把消息转发到所有与其绑定的队列中。</p><p><em>direct</em><br>直连交换机，交换机与各队列绑定时指定了routingKey，只有发布消息时携带的routingKey与绑定key一致时才转发到对应队列，支持多重绑定（不同队列使用同一个routingKey绑定，匹配时都会转发到这些队列中）。</p><p><em>topic</em><br>话题交换机（类似redis的基于模式匹配），使用<code>*</code>代替一个单词，使用<code>#</code>代替0或多个单词。<br>eg:<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20230401221735.png"></p><p><em>headers</em><br>不使用<code>routingKey</code>，而是使用若干<code>key:value</code>与队列绑定。生产者发送消息时，需要以requestHeader的方式携带<code>key:value</code>，只有与绑定时的某个<code>key:value</code>匹配时才转发到对应队列。</p><p><em>默认交换机</em><br>空字符串即可指定默认交换机，是一个direct型的交换机；创建queue时，会自动为该交换机绑定以队列名为routingKey与队列进行绑定。</p><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p><em>概念</em><br>work模型，即多消费者。</p><p><em>公平性配置</em><br>队列会默认平均分发消息，可配置消费者的<code>listener.simple.prefetch</code>指定一次最多获取消息的数量，消息处理完成回复ack后才会接受新的消息。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p><em>死信来源</em></p><ul><li>TTL：可以为消息和队列设置TTL</li><li>队列达到最大长度</li><li>消息被拒绝（reject）或nack且requeue&#x3D;false（否则会尝试重新获取）</li></ul><p><em>如何使用死信队列</em></p><ul><li>死信交换机：每个需要使用死信的业务队列都需要配置一个死信交换机，死信交换机的类型也是可选择的。同项目可共用一个死信交换机，不过需要为每个队列分配一个独立的路由key。</li><li>死信队列：为死信交换机配置死信队列并将其绑定在死信交换机上，不同死信队列也用不同的路由key绑定。一般每个业务队列都会配置一个死信队列以处理。</li><li>死信路由：每个业务队列可配置一个<code>x-dead-letter-routing-key</code>参数，当某个消息被判定为死信时，其路由会变成该参数的值；若不配置，则保持原路由。</li></ul><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p><em>两种TTL区别</em></p><ul><li>队列TTL：消息在队列中存活超过TTL后立刻被丢弃（或路由到死信交换机）</li><li>消息TTL：消费者消费时判断是否过期，因此会存在消息过期仍未丢弃的情况，且如果先投递的消息延迟时间很久，后面的消息即使会过期了也会一直积压。</li></ul><p><em>延迟队列的实现</em></p><ul><li>利用消息丢弃，可以拒绝一些超时未完成的业务。</li><li>利用死信队列，可以实现一些定时任务，即<strong>延迟队列</strong>。</li></ul><p><em>优化</em></p><ul><li>安装延迟队列插件，其提供了新的路由器类型，其支持消息在路由器的数据表中存储，到达投递时间时，才会投递到对应队列，实现延迟。</li></ul><p><em>其他延迟队列实现</em><br>Java的DelayQueue，Redis的zset，Quartz，Kafka的时间轮。</p><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="可靠投递"><a href="#可靠投递" class="headerlink" title="可靠投递"></a>可靠投递</h3><h4 id="生产者处理投递失败"><a href="#生产者处理投递失败" class="headerlink" title="生产者处理投递失败"></a>生产者处理投递失败</h4><p><em>投递交换机确认（ConfirmCallback）参数配置</em><br><code>spring.rabbitmq.publisher-confirm-type</code>，有以下参数可选：</p><ul><li>NONE：禁用发布确认模式</li><li>CORRELATED：发布消息成功到交换器触发回调方法ConfirmCallback</li><li>SIMPLE：发布消息成功到交换器触发回调方法waitForConfirm等待交换机路由队列的结果，根据结果判断下一步的逻辑。</li></ul><blockquote><p>ConfirmCallBack可以在rabbitTemplate上全局注册，也可以注册在具体消息的关联数据CorrelationData上：<code>correlationData.getFuture().addCallback(result-&gt;&#123;&#125;)</code>。</p></blockquote><h4 id="生产者处理路由失败"><a href="#生产者处理路由失败" class="headerlink" title="生产者处理路由失败"></a>生产者处理路由失败</h4><p><em>路由到队列确认（ReturnCallback）参数配置</em><br><code>spring.rabbitmq.publisher-returns</code>，有以下参数可选：</p><ul><li>false：关闭失败回调</li><li>true：开启失败回调，失败时触发ReturnCallback</li></ul><blockquote><p>在RedisTemplate中可以通过<code>setMandatory(boolean mandatory)</code>方法或者在yml配置文件中通过<code>template.mandatory: true</code>来配置当消息没能路由到指定队列时消息是重回生产者还是丢弃。</p></blockquote><h4 id="备份交换机处理路由失败"><a href="#备份交换机处理路由失败" class="headerlink" title="备份交换机处理路由失败"></a>备份交换机处理路由失败</h4><p><em>目的</em><br>无法路由的消息返回生产者也很难处理，在集群下更需要统一处理。</p><p><em>功能实现</em><br>为原交换机配置备份交换机，当原交换机无法路由消息时，将其转发到备份交换机（Fanout），从而实现对无法路由的消息的消费（单独做报警）</p><p><em>其他</em><br>备份交换机和madatory参数优先级中，备份交换机优先级更高。</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>在业务上一般而言，保证<strong>消费者</strong>的幂等性即可，重复投递是为了保证消息不丢失的必然措施，且mq对每条消息都有一个全局唯一id，可以判断重复的消息。</p><h4 id="重复投递"><a href="#重复投递" class="headerlink" title="重复投递"></a>重复投递</h4><p><em>原因</em><br>队列发送的投递成功的ack丢失，可能造成生产者重复投递。<br><em>解决</em><br>消息队列MQ本身有全局唯一id，可判断重复消息。</p><h4 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h4><p><em>原因</em><br>消费者发送消费成功的ack丢失，可能造成队列向其重复发送。<br><em>解决</em></p><ul><li>全局唯一ID，消费前先去db查询该消息（有性能瓶颈），不存在则正常消费，然后写入db。</li><li>消费者使用redis消费，set&#x2F;setnx操作天然具有幂等性</li></ul><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p><em>优先队列</em><br>将队列设置为优先级队列，投递消息时指定消息的优先级。</p><p><em>惰性队列</em><br>将队列设置成惰性队列，队列会将消息存入磁盘，只有被消费时加载到内存中，主要解决消费者因各种原因可能宕机导致消息堆积的情况。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="集群基础"><a href="#集群基础" class="headerlink" title="集群基础"></a>集群基础</h3><p><a href="https://cloud.tencent.com/developer/article/1174657?from=article.detail.1795578&areaSource=106000.2&traceId=JELSFIqWoI8zLnesxfh4Q">集群全解与docker搭建</a><br><a href="https://juejin.cn/post/7085011568991141919#heading-3">镜像队列策略全解</a></p><p><em>为什么集群？</em><br>高并发、高性能、高可用的需求</p><p><em>节点类型</em></p><ul><li>内存节点</li><li>磁盘节点<ul><li>单节点模式下必须使用磁盘节点，否则可能丢数据。</li><li>集群中至少要有一个磁盘节点，其他节点离开时必须通知磁盘节点。（启动时先启动磁盘节点，关闭时最后关闭磁盘节点）</li><li>如果唯一的磁盘节点崩溃了，不允许对rabbitmq集群做任何修改，只能使用已有的交换机、队列进行生产消费。</li></ul></li></ul><p><em>集群模式</em></p><ul><li>普通模式：分布式集群，节点可转发请求，无法实现高可用</li><li>镜像模式：主从集群，一般3节点以上，同时持有彼此的副本实现高可用</li><li>仲裁队列：与镜像模式类似，由于镜像模式不是强一致的，仲裁队列通过Raft协议保证一致性</li></ul><p><em>rabbitmq集群基础</em></p><ul><li>节点之间通过domain域名识别，所以要修改各节点host文件</li><li>rabbitmq集群基于erlang集群，需要让所有节点的cookie文件值相同，具体为复制一个节点的cookie文件到其他节点覆盖。</li><li>启动一个节点，其他节点逐一加入集群。</li></ul><p><em>docker启动</em></p><ul><li>启动的时候指定hostname和containName，并通过 <code>--link</code>指定其他节点的<code>containName:alias</code>进行连接，alias表示别名。</li><li>其他节点containName,alias都可以作为其hostname由当前节点访问，所以分别进入容器执行mq的集群相关命令</li></ul><p><em>镜像模式配置</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl set_policy mypolicy &quot;^amp*&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2&#125;&#x27;<br></code></pre></td></tr></table></figure><ul><li>name：名称，随意填</li><li>“匹配规则”：正则表达式，匹配集群内的交换机或队列</li><li>“镜像队列：”json：{}<ul><li>ha-mode：镜像模式，可使用all&#x2F;exactly&#x2F;nodes，all表示备份所有队列，excaclt表示随机存储部分数量节点，nodes，表示存储指定存储节点。</li><li>ha-params：作为mode的补充，指定数量或节点名称</li><li>ha-sync-mode：同步方式，automatic表示自动向master同步数据，manually表示手动向master同步数据。</li></ul></li></ul><p><em>集群异常</em></p><ul><li>消息持久化，节点掉线后上线可恢复。</li><li>消息未持久化，双活冗余队列和镜像队列实现可靠性。</li></ul><h4 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式</h4><h5 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h5><p><em>从节点晋升策略</em><br><code>ha-promote-on-shutdown</code>、<code>ha-promote-on-failure</code>分别配置在主节点正常关闭和掉线时，从节点是否需要保证数据同步才提升。</p><p><em>主队列选择策略</em><br><code>queue-master-locator</code>，主队列应该绑定在哪个节点的策略。</p><p><em>多少镜像合适？</em><br>建议复制到<code>（N/2+1）</code>个节点。</p><p><em>生产者确认机制</em><br>允许生产者开启事物，只有完成对主队列和所有镜像队列的投递时才收到执行完成的消息。</p><p><em>流控</em><br>生产者只有收到所有镜像授予的信用许可后才能发送新的消息，否则会阻塞。</p><p><em>消费者取消消费</em><br>从镜像队列中消费的客户端希望感知到队列的失败转移，使用<code>x-cancel-on-ha-failover</code>参数进行消费，故障转移发生时，该消费会被取消。此时创建新的消费者进行消费。</p><h5 id="镜像队列数据流"><a href="#镜像队列数据流" class="headerlink" title="镜像队列数据流"></a>镜像队列数据流</h5><p><em>客户端连接主节点时</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/051f3722fd064e08b961581611ab3e04_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"><br><em>客户端连接从节点</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/e1f636d367614a798ae701766d750dd5_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h5 id="镜像队列实现原理"><a href="#镜像队列实现原理" class="headerlink" title="镜像队列实现原理"></a>镜像队列实现原理</h5><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/ab1e1b406af641e883bb00c0ec1ab4fb_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><ul><li>amqqueue_process处理协议</li><li>backing_queue是主从节点上特殊的queue</li><li>GM分两部分，一部分负责广播，一部分负责接受消息并回调。其中主节点的回调函数是<code>coordinator</code>、从节点上则是<code>mirror_queue_slave</code>。</li></ul><p><em>GM</em><br>原子广播，所有节点形成链表，消息循环传播回自己则说明同步完成。</p><h5 id="镜像队列缺点"><a href="#镜像队列缺点" class="headerlink" title="镜像队列缺点"></a>镜像队列缺点</h5><ul><li>broker重新上线：此时是否应该从leader同步？可能会丢弃其所有数据。</li><li>同步阻塞：同步镜像耗时太长。</li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>RabbitMQ中使用Keepalived和HaProxy实现集群的高可用和负载均衡。<br><em>HAProxy</em><br>负载均衡代理，但本身单机也可能宕机，需要集群。<br><em>Keepalived</em><br>协助HAProxy集群，自身也是集群，起类似哨兵的作用，只允许一个master HAProxy，统一了访问路径。（提供一个虚拟IP，由HAProxy集群的节点争夺）<br><em>VRRP</em><br>虚拟路由冗余协议，keepalived这种提供虚拟IP的机制属于VRRP</p><h3 id="集群之间"><a href="#集群之间" class="headerlink" title="集群之间"></a>集群之间</h3><p>为了实现高可用，有一些模式：</p><ul><li>主备模式：主备节点共享存储空间。</li><li>镜像模式：节点之间互相备份的镜像模式。</li><li>远程模式：Shovel集群，模型会变成<strong>近端同步确认</strong>、<strong>远端异步确认</strong>两步。近端集群同步确认后转发给远端。</li><li>多活模式：基于AMQP协议实现多中心通讯（不同于集群），连接双方可以使用不同users和vhost，不同版本MQ。某节点使用federated exchange，实现向远程另一节点订阅消息的功能，并放入本地队列。</li></ul><h2 id="实战代码风格"><a href="#实战代码风格" class="headerlink" title="实战代码风格"></a>实战代码风格</h2><ul><li>使用一个Config类文件，通过@Bean的方式生成所有的队列、交换机、绑定关系。</li><li>使用@RabbitListener做消息回调函数。</li><li>引入依赖，修改序列化方式，在启动类上添加消息转换器：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、Kafka"><a href="#三、Kafka" class="headerlink" title="三、Kafka"></a>三、Kafka</h1><h2 id="核心概念-1"><a href="#核心概念-1" class="headerlink" title="核心概念"></a>核心概念</h2><p><em>定义</em><br>Kafka是一个分布式、支持分区的（partition）、多副本的 （replica），基于zookeeper协调的分布式消息系统。<br>Kafka借鉴了JMS规范的思想，但是并<strong>没有完全遵循JMS规范</strong>。</p><p><em>使用场景</em></p><ul><li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li><li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li><li><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li><li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li><li><strong>流式处理</strong>：比如spark streaming和storm</li><li><strong>事件源</strong></li></ul><p><em>基础术语</em></p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>Broker</td><td>消息中间件处理节点，⼀个Kafka节点就是⼀个broker，⼀个或者多个Broker可以组成⼀个Kafka集群</td></tr><tr><td>Topic</td><td>Kafka根据topic对消息进⾏归类，发布到Kafka集群的每条消息都需要指定⼀个topic</td></tr><tr><td>Producer</td><td>消息⽣产者，向Broker发送消息的客户端</td></tr><tr><td>Consumer</td><td>消息消费者，从Broker读取消息的客户端</td></tr><tr><td>ConsumerGroup</td><td>每个Consumer属于⼀个特定的Consumer Group，⼀条消息可以被多个不同的Consumer Group消费，但是⼀个Consumer Group中只能有⼀个Consumer能够消费该消息</td></tr><tr><td>Partition</td><td>物理上的概念，⼀个topic可以分为多个partition，每个partition内部消息是有序的</td></tr><tr><td>Controller</td><td>Kafka节点里面的一个主节点，借助zookeeper。</td></tr></tbody></table><p><em>主题与分区</em><br>在 Kafka 中，消息以<strong>主题（Topic）</strong> 来分类，每一个主题都对应一个「消息队列」，通过分区实现主题的水平扩展。</p><p><em>集群架构</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004183831.png"><br>若干个 Broker 组成一个集群（Cluster），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。<br>在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。<br>服务端(brokers)和客户端(producer、consumer)之间通信通过 <strong>TCP协议</strong> 来完成。</p><p><em>负载均衡</em><br><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</p><p><em>日志保留</em><br>Kafka 的一个关键性质是日志保留（retention），我们可以配置主题的消息保留策略，譬如只保留一段时间的日志或者只保留特定大小的日志。当超过这些限制时，老的消息会被删除。我们也可以针对某个主题单独设置消息过期策略，这样对于不同应用可以实现个性化。<br>需要注意的是，<strong>kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能</strong>！</p><p><em>多集群</em><br>随着业务发展，我们往往需要多集群，通常出于下面几个原因：</p><ul><li>基于数据的隔离；</li><li>基于安全的隔离；</li><li>多数据中心（容灾）</li></ul><p>分区复制冗余机制只适用于同一个 Kafka 集群内部，对于多个 Kafka 集群消息同步可以使用 Kafka 提供的 MirrorMaker 工具。<br>本质上来说，MirrorMaker 只是一个 Kafka 消费者和生产者，并使用一个队列连接起来而已。它从一个集群中消费消息，然后往另一个集群生产消息。</p><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>基于磁盘存储</em><br>如果是针对磁盘的顺序访问，某些情况下它可能比随机的内存访问都要快，甚至可以和网络的速度相差无几。任何发布到 Partition 的消息都会被追加到 Partition 数据文件的尾部，这样的顺序写磁盘操作让 Kafka 的效率非常高。</p><blockquote><p>现代的操作系统针对磁盘的读写已经做了一些优化方案来加快磁盘的访问速度。比如，<strong>预读</strong>会提前将一个比较大的磁盘快读入内存。<strong>后写</strong>会将很多小的逻辑写操作合并起来组合成一个大的物理写操作。并且，操作系统还会将主内存剩余的所有空闲内存空间都用作<strong>磁盘缓存</strong>，所有的磁盘读写操作都会经过统一的磁盘缓存（除了直接 I&#x2F;O 会绕过磁盘缓存）。</p></blockquote><p><em>磁盘上的Partition</em><br><strong>Topic 其实是逻辑上的概念，面相消费者和生产者，物理上存储的其实是 Partition</strong><br>每一个 Partition 最终对应一个<strong>目录</strong>，里面存储所有的消息和索引文件。默认情况下，每一个 Topic 在创建时如果不指定 Partition 数量时只会创建 1 个 Partition，Partition的命名规则是：<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code>。<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004150146.png"><br>每一条消息被发送到 Broker 中，会根据 Partition 规则选择被存储到哪一个 Partition。如果 Partition 规则设置的合理，所有消息可以均匀分布到不同的 Partition中。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><em>底层文件结构</em><br>在 Kafka 的文件存储中，同一个 Topic 下有多个不同的 Partition，每个 Partition 都为一个目录，而每一个目录又被平均分配成多个大小相等的 <strong>Segment File</strong> 中。<br>Segment File 又由 index file 和 data file 组成，他们总是成对出现，后缀 <code>.index</code> 和 <code>.log</code> 分别表示 Segment 索引文件和数据文件（默认1G）。</p><p><em>Segment</em><br><strong>Segment 是 Kafka 文件存储的最小单位。</strong><br>Segment 文件命名规则：Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用0填充。如 00000000000000368769.index 和 00000000000000368769.log。<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004150509.png"></p><p>索引文件中<strong>index并不是从0开始，也不是每次递增1的</strong>，因为 Kafka 采取稀疏索引存储的方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，使得能够把 index 映射到内存，降低了查询时的磁盘 IO 开销，同时也并没有给查询带来太多的时间消耗。</p><p><em>Message</em><br>在 Partition 中的每一条 message 都包含了以下三个属性：</p><ul><li>offset：表示 message 在当前 Partition 中的偏移量，是一个逻辑上的值，唯一确定了 Partition 中的一条 message，可以简单的认为是一个 id；</li><li>messagesize：表示 message 内容 data 的大小；</li><li>data：message 的具体内容</li></ul><p><em>二分查找</em><br>因为其文件名为上一个 Segment 最后一条消息的 offset ，所以当需要查找一个指定 offset 的 message 时，通过在所有 segment 的文件名中进行二分查找就能找到它归属的 segment ，再在其 index 文件中找到其对应到文件上的物理位置，就能拿出该 message 。<br>由于消息在 Partition 的 Segment 数据文件中是顺序读写的，且消息消费后不会删除（删除策略是针对过期的 Segment 文件），这种顺序磁盘 IO 存储设计师 Kafka 高性能很重要的原因。</p><h2 id="特性及实现"><a href="#特性及实现" class="headerlink" title="特性及实现"></a>特性及实现</h2><h4 id="高性能（零拷贝）"><a href="#高性能（零拷贝）" class="headerlink" title="高性能（零拷贝）"></a>高性能（零拷贝）</h4><p>正常消费者读取数据流程：<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004152936.png"><br>零拷贝：kafka linux sendfile技术<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004153025.png"></p><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p><em>架构演进</em><br>单Reactor：<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004213002.png"><br>多Reactor：<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004212939.png"><br>Kafka网络架构：<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004213059.png"><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004214241.png"></p><ol><li><code>Acceptor</code> 初始化的时候会注册 <code>OP_ACCEPT</code> 事件，当有客户端连接进来时，会触发该事件并将该事件 <code>轮询</code> 的方式分发给 <code>Processor</code> 处理。</li><li><code>Processor</code> 收到 <code>Acceptor</code> 分发的连接时，会注册<code>OP_READ</code> 事件并与内部的 <code>selector</code> 绑定，当下次客户端发送信息时，直接触发 <code>Processor</code> 的 <code>OP_READ</code> 事件进行处理。</li><li><code>Processor</code> 将客户端的连接请求放入 <code>RequestQueue（仅有一个）</code> 里面，所有的 <code>Processor</code> 共用一个 <code>RequestQueue</code></li><li><code>KafkaRequestHandler</code> 从 <code>RequestQueue</code> 中取出请求，通过调用 <code>KafkaApis</code> 得到响应结果，将响应结果放入到 <code>ResponseQueues</code> ，这里需要注意一点：<code>Processor</code> 有多个 <code>responseQueue</code></li><li><code>Processor</code> 从对应的 <code>ResponseQueue</code> 中取出 <code>response</code>，将其通过 <code>SockerChannel</code> 发送给对应的客户端</li></ol><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><em>定义</em><br>Kafka的核心组件，它的主要作用是在Zookeeper的帮助下管理和协调整个Kafka集群。集群中任意一个Broker都能充当控制器的角色，但在运行过程中，只能有一个Broker成为控制器。</p><p><em>功能</em></p><ol><li>主题管理：创建、删除Topic，以及增加Topic分区等操作都是由控制器执行。</li><li>分区重分配：执行Kafka的reassign脚本对Topic分区重分配的操作，也是由控制器实现</li><li>Preferred leader选举</li><li>集群成员管理</li><li>元数据存储</li></ol><p><em>选举原理</em></p><ul><li>启动时：<ul><li>集群中第一个启动的Broker会通过在Zookeeper中创建临时节点&#x2F;controller来让自己成为控制器。</li><li>其他Broker启动时也会在zookeeper中创建临时节点，但是发现节点已经存在，所以它们会收到一个异常，意识到控制器已经存在，那么就会在Zookeeper中创建watch对象，便于它们收到控制器变更的通知。</li></ul></li><li>异常时：<ul><li>Controller异常重新选主：那么如果控制器由于网络原因与Zookeeper断开连接或者异常退出，那么其他broker通过watch收到控制器变更的通知，就会去尝试创建临时节点&#x2F;controller，如果有一个Broker创建成功，那么其他broker就会收到创建异常通知，也就意味着集群中已经有了控制器，其他Broker只需创建watch对象即可。</li><li>Broker异常导致Partition重新选主：如果集群中有一个Broker发生异常退出了，那么控制器就会检查这个broker是否有分区的副本leader，如果有那么这个分区就需要一个新的leader，此时控制器就会去遍历其他副本，决定哪一个成为新的leader，同时更新分区的ISR集合。</li></ul></li><li>恢复时：如果有一个Broker加入集群中，那么控制器就会通过Broker ID去判断新加入的Broker中是否含有现有分区的副本，如果有，就会从分区副本中去同步数据。</li></ul><p><em>防止控制器脑裂</em><br>通过版本解决：ZooKeeper中还有一个与Controller有关的持久节点&#x2F;controller_epoch，存放的是一个整形值的epoch number（纪元编号，也称为隔离令牌），集群中每选举一次控制器，就会通过Zookeeper创建一个数值更大的epoch number，如果有broker收到比这个epoch数值小的数据，就会忽略消息。</p><h4 id="分区副本"><a href="#分区副本" class="headerlink" title="分区副本"></a>分区副本</h4><p><em>分区副本</em><br>创建主题时，可以指定分区，也可以指定副本个数，副本角色：</p><ul><li><strong>leader partition</strong>：<ol><li>写数据、读数据操作都是从leader partition去操作的。</li><li>会动态维护一个ISR（in-sync-replica）列表（是所有副本的子集），但是会根据一定的规则删除ISR列表里面的值。生产者发送来一个消息，消息首先要写入到leader partition中写完了以后，还要把消息写入到ISR列表里面的其它副本分区，写完后才算这个消息提交</li></ol></li><li><strong>follower partition</strong>：周期性地从leader partition同步数据（pull）</li></ul><p>注意，<strong>消费者只会找partition的leader节点拉取数据</strong>。</p><p><em>HW与LEO</em></p><ul><li><code>HW</code>（high watermark）：副本的高水印值，通过它可以得知副本中已提交或已备份消息的范围，leader副本中的HW，决定了消费者能消费的最新消息能到哪个offset。注意HW最多达到LEO值时，这时可见范围不会包含HW值对应的那条消息。<ul><li><strong>leader HW</strong>：比较所有满足条件的副本的LEO，包括自己的LEO和remote LEO，选取最小值作为更新后的leader HW。</li><li><strong>follower HW</strong>：更新发生在follower副本更新LEO之后，一旦follower向log写完数据，它就会尝试更新HW值。</li></ul></li><li><code>LEO</code>（log end offset）：日志末端位移，代表日志文件中下一条待写入消息的offset，这个offset上实际是没有消息的。当leader副本收到生产者的一条消息，LEO通常会自增1，而follower副本需要从leader副本fetch到数据后，才会增加它的LEO，最后leader副本会比较自己的LEO以及满足条件的follower副本上的LEO，选取两者中较小值作为新的HW，来更新自己的HW值。<ul><li><strong>leader LEO</strong>：leader的LEO就保存在其所在的broker的缓存里，当leader副本log文件写入消息后，就会更新自己的LEO。</li><li><strong>remote LEO</strong>：remote LEO是<strong>保存在leader副本上</strong>的follower副本的LEO，可以看出leader副本上保存所有副本的LEO。</li><li><strong>follower LEO</strong>：follower LEO就是<strong>follower副本的LEO</strong>，在follower副本得到leader副本发送的数据并随后写入到log文件，就会更新自己的LEO</li></ul></li></ul><p><em>ISR维护</em></p><ul><li>0.9.0.0 版本之前：参数 replica.lag.max.messages 决定的，即允许 follower 副本落后 leader 副本的消息数量，超过这个数量后，follower 会被踢出 ISR。（这种设计在消息量大时应该设置的大一点，但丢失消息的风险也更大，因此有缺陷的设计）</li><li>0.9.0.0 版本之后的设计：参数 replica.lag.time.max.ms 决定的，允许 follower 副本不同步消息的最大时间值，即只要在 replica.lag.time.max.ms 时间内 follower 有同步消息，即认为该 follower 处于 ISR 中，这就很好地避免了在某个瞬间生产者一下子发送大量消息到 leader 副本导致该分区 ISR 频繁收缩与扩张的问题了。</li></ul><p><em>如果所有的ISR副本都失败了怎么办？</em><br>有以下两种方案：</p><ol><li>等待ISR集合中的副本复活</li><li>选择任何一个立即可用的副本，而这个副本不一定是在ISR集合中。</li></ol><p>这两种方法各有利弊，实际生产中按需选择。等待ISR副本复活，虽然可以保证一致性，但可能需要很长时间。而如果选择立即可用的副本，则很可能该副本并不一致。</p><p><em>分区Leader选择算法</em><br>由controller执行：</p><ul><li>从Zookeeper中读取当前分区的所有ISR(in-sync replicas)集合</li><li>调用配置的分区选择算法选择分区的leader</li></ul><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004204211.png"><br>这些分区选择算法其实都会选择Prefer的分区（ISR中的第一个分区作为leader），区别是选择分区后的操作不同。</p><p><em>可靠性保证</em></p><ul><li>有序性：对于一个分区来说，它的消息是有序的。如果一个生产者向一个分区先写入消息A，然后写入消息B，那么消费者会先读取消息A再读取消息B。</li><li>分区副本：当消息写入所有<code>in-sync</code>状态的副本后，消息才会认为<strong>已提交（committed）</strong>。这里的写入有可能只是写入到文件系统的缓存，不一定刷新到磁盘。生产者可以等待不同时机的确认，比如等待分区主副本写入即返回，或者等待所有<code>in-sync</code>状态副本写入才返回。</li><li>持久化：一旦消息已提交，那么只要有一个副本存活，数据不会丢失。</li><li>隔离性：消费者只能读取到已提交的消息。</li></ul><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="发送原理"><a href="#发送原理" class="headerlink" title="发送原理"></a>发送原理</h3><p><em>发送原理</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004155001.png"><br>Kafka Broker 在收到消息时会返回一个响应，如果写入成功，会返回一个RecordMetaData 对象，<strong>它包含了主题和分区信息，以及记录在分区里的偏移量，上面两种的时间戳类型也会返回给用户</strong>。如果写入失败，会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败的话，就返回错误消息。</p><p><em>分区原理</em></p><ol><li><strong>没有设置key</strong>：消息就会被轮训的发送到不同的分区。</li><li><strong>设置了key</strong>：kafka自带的分区器会根据key计算出来一个hash值，这个hash值会对应某一个分区。如果key相同的，那么hash值必然相同，key相同的值，必然是会被发送到同一个分区。</li><li><strong>自定义分区</strong>：可以指定分区或通过配置自定义分区器。</li></ol><h3 id="发送策略"><a href="#发送策略" class="headerlink" title="发送策略"></a>发送策略</h3><p><em>发送方式</em></p><ul><li>按批次发送（默认方式）</li><li>同步发送</li><li>异步发送（可提供回调函数）</li></ul><p><em>如何提升吞吐量</em></p><ul><li><code>buffer.memory</code>：设置发送消息的缓冲区，默认值是33554432，就是32MB</li><li><code>compression.type</code>：默认是none，不压缩，但是也可以使用lz4压缩，效率还是不错的，<strong>压缩</strong>之后可以减小数据量，提升吞吐量，但是会加大producer端的cpu开销。（在 Kafka 中，压缩&#x2F;解压会发生在两个地方：Kafka Producer 和 Kafka Consumer）</li><li><code>batch.size</code>：设置batch的大小，如果batch太小，会导致频繁网络请求，吞吐量下降；如果batch太大，会导致一条消息需要等待很久才能被发送出去，而且会让内存缓冲区有很大压力，过多数据缓冲在内存里，默认值是：16384，就是16kb，也就是一个batch满了16kb就发送出去。</li><li><code>linger.ms</code>：配合batch.size使用，表示一个batch的数据最多延迟多少毫秒后被发出。</li></ul><p><em>确认机制</em></p><ul><li><code>request.required.acks</code>：确认机制等级，影响投递的可靠性<ul><li><code>0</code>表示投递后直接返回，不关心有没有写成功。</li><li><code>1</code>表示当leader partition写入成功以后，才算写入成功。（存在丢数据的可能）</li><li><code>-1(all)</code>表示需要ISR列表里面，所有副本都写完以后，这条消息才算写入成功。</li></ul></li><li><code>min.insync.replicas</code>：最小同步的副本。一个leader partition会维护一个ISR列表，该值就是限制ISR列表里面<strong>至少得有几个副本</strong>。</li></ul><div class="note note-primary">            <p>想要设计一个高可用的方案，需要<code>acks = -1</code>，<code>min.insync.replicas &gt;= 2</code>。</p>          </div><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消费原理"><a href="#消费原理" class="headerlink" title="消费原理"></a>消费原理</h3><p><em>消费者与消费组</em><br>Kafka消费者是<strong>消费组</strong>的一部分，当多个消费者形成一个消费组来消费主题时，每个消费者会收到不同分区的消息。<br><strong>每个分区只能被一个消费者消费</strong>，所以同时扩展消费者和分区数量可以提高消费能力，消费者群组带来了<strong>高可用性</strong>和<strong>伸缩性</strong>。</p><p><em>多消费组</em><br>Kafka只需写入一次消息，可以支持任意多的应用读取这个消息。只要消费者处于不同的消费组，即可对消息进行重复消费。</p><p><em>Partition性质</em><br>Kafka 只会保证在 Partition 内消息是有序的<br><em>Partition消息删除</em><br>无论消息是否被消费，除非消息到期 Partition 从不删除消息。<br><em>Partition与消费模型</em><br>Partition 会为每个 Consumer Group 保存一个偏移量，记录 Group 消费到的位置。 如下图：<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004151833.png"></p><p><em>Partition的偏移量维护</em><br>每个consumer内存里数据结构保存对每个topic的每个分区的消费offset，定期会提交offset：</p><ul><li>老版本：是写入zk，但是那样高并发请求zk是不合理的架构设计，zk是做分布式系统的协调的，轻量级的元数据存储，不能负责高并发读写，作为数据存储。</li><li>新版本：提交offset发送给kafka内部topic：<code>_consumer_offsets</code>，提交过去的时候，key是<code>group.id+topic+分区号</code>，value就是当前<code>offset</code>的值，每隔一段时间，kafka内部会对这个topic进行<code>compact</code>（合并），也就是每个<code>group.id+topic+分区号</code>保留最新数据。</li></ul><blockquote><p>可以通过<code>Kafka Manager</code>监控偏移量</p></blockquote><p><em>为什么 Kafka 是 pull 模型</em></p><ul><li>push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。</li><li>pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。</li><li>对于 Kafka 而言，pull 模式更合适。pull 模式可<strong>简化 broker 的设计</strong>，Consumer 可自主控制消费消息的速率，同时 Consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</li></ul><h3 id="消费策略"><a href="#消费策略" class="headerlink" title="消费策略"></a>消费策略</h3><p><em>消费策略</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004153203.png"><br>消费者还可以指定分区、指定offset、从指定时间点开始进行消费。</p><p><em>提交策略</em></p><ul><li>自动提交：消费者定期自动把从 poll() 方法轮询到的最大偏移量提交上去。</li><li>提交当前偏移量：应用程序决定何时提交偏移量，使用 <code>commitSync()</code> 提交由 poll() 方法返回的最新偏移量。</li><li>异步提交：异步提交 <code>commitAsync()</code> 与同步提交 <code>commitSync()</code> 最大的区别在于异步提交不会进行重试，同步提交会一直进行重试。</li><li>同步和异步组合提交：一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大的问题，因为如果提交失败是因为临时问题导致的，那么后续的提交总会有成功的。但是<strong>如果在关闭消费者或再均衡前的最后一次提交，就要确保提交成功</strong>，因此，<strong>在消费者关闭之前一般会组合使用commitAsync和commitSync提交偏移量</strong>。</li><li>提交特定的偏移量：消费者API允许调用 <code>commitSync()</code> 和 <code>commitAsync()</code> 方法时传入希望提交的 <code>partition</code> 和 <code>offset</code> 的 <code>map</code>，即提交特定的偏移量。</li></ul><p><em>消费相关配置</em></p><ul><li><code>max.poll.records</code>：一次poll返回消息的最大条数，默认是500条</li><li><code>connection.max.idle.ms</code>：consumer跟broker的socket连接如果空闲超过了一定的时间，此时就会自动回收连接，但是下次消费就要重新建立socket连接，这个建议设置为-1。</li><li><code>enable.auto.commit</code>：开启自动提交偏移量 </li><li><code>auto.commit.interval.ms</code>：每隔多久提交一次偏移量，默认值5000毫秒</li><li><code>auto.offset.reset</code>：如果消息没有经过确认或打回，那么这个消息将在下次启动<code>consumer</code>的时候根据<code>auto.offset.reset</code>重新消费消息。<ul><li>earliest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费。</li><li>latest：当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据。</li><li>none：当各分区下有已提交的offset时，从提交的offset开始消费；只要有一个分区不存在已提交的offset，则抛出异常。</li></ul></li></ul><h3 id="分区重平衡"><a href="#分区重平衡" class="headerlink" title="分区重平衡"></a>分区重平衡</h3><p><em>定义</em><br>当出现以下场景时，会触发分区<strong>重平衡（rebalance）</strong>，即对消费组与分区关系的再分配：</p><ol><li>消费组成员个数发生变化，例如有新的 Consumer 实例加入或离开该消费组。</li><li>订阅的 Topic 个数发生变化。</li><li>订阅 Topic 的分区数发生变化。</li></ol><p><em>性质</em><br>重平衡是 Kafka 一个很重要的性质，这个性质保证了高可用和水平扩展。<strong>不过，在重平衡期间，所有消费者都不能消费消息，因此会造成整个消费组短暂的不可用。</strong> 而且，将分区进行重平衡也会导致原来的消费者状态过期，从而导致消费者需要重新更新状态，这段期间也会降低消费性能。</p><p><em>group coordinator</em></p><ul><li>定义：每个consumer group都会选择一个broker作为自己的coordinator，他是负责监控这个消费组里的各个消费者的心跳，以及判断是否宕机，然后开启rebalance。</li><li>选择原理：<code>ID = hash(groupId)%_consumer_offsets的分区数量(默认为50)</code>，该主题的第ID号分区所在的broker就是该消费组的<strong>coordinator</strong></li><li>运行原理：<ol><li>每个consumer都发送JoinGroup请求到Coordinator</li><li>Coordinator从一个consumer group中选择一个consumer作为<strong>leader</strong></li><li>把consumer group成员信息和订阅信息发送给这个leader</li><li>这个leader会负责制定消费方案：即哪个consumer负责消费哪些topic的哪些partition。</li><li>通过SyncGroup发给Coordinator：leader会将这个方案封装进SyncGroup请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。</li><li>接着Coordinator就把消费方案下发给各个consumer，它们会从指定的分区的leader broker开始进行socket连接以及消费消息</li></ol></li></ul><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231004164046.png"></p><blockquote><p>每个Consumer都通过一个<code>Consumer Coordinator</code>组件与<code>Group Coordinator</code>通讯。</p></blockquote><p><em>rebalance策略</em></p><ul><li>range（默认）：<strong>range范围分区策略是对每个topic而言的</strong>，对于每个TOPIC，消费者按区间均分Partition。</li><li>round-robin：把所有的 partition 和所有的 consumer 都列出来，然后按照 hashcode 进行排序，最后通过轮询算法来分配 partition 给到各个消费者。<ul><li>同一消费组内所有消费者订阅的消息都相同：可实现均等分配</li><li>同一消费组内存在消费者订阅的消息不相同：由于存在TOPIC只有部分消费者订阅，所以分配可能不均匀。</li></ul></li><li>sticky：尽可能保证在rebalance的时候，让原本属于这个consumer 的分区还是属于他们，然后把多余的分区再均匀分配过去。</li><li>自定义分区策略</li></ul><blockquote><p>重平衡后，依赖<code>_consumer_offsets</code>队列中的消息整理出消费组对<code>Partition</code>最新的消费进度，根据偏移量提交机制的不同，可能出现消息漏消费或重复消费的情况。</p></blockquote><p><em>心跳监控</em><br>消费者通过定期发送心跳（hearbeat）到一个作为组协调者（group coordinator）的 broker 来保持在消费组内存活。这个 broker 不是固定的，每个消费组都可能不同。</p><ul><li>早期版本：当消费者拉取消息或者提交时，便会发送心跳。</li><li>0.10.1 版本：心跳与拉取消息行为分离。</li><li>更高版本：Kafka 支持配置一个消费者多长时间不拉取消息但仍然保持存活，这个配置可以避免活锁（livelock）。活锁，是指应用没有故障但是由于某些原因不能进一步消费。</li></ul><p><em>避免重平衡</em><br>重平衡在做结构调整时是必要的，但有时消费者也会被误判下线导致重平衡，因此可以合理的调整相关配置：</p><ul><li><code>heartbeat.interval.ms</code>：多久发送一次心跳</li><li><code>session.timeout.ms</code>：kafka多长时间感知不到一个consumer后判断其故障了，默认是10秒</li><li><code>max.poll.interval.ms</code>：如果在两次poll操作之间，超过了这个时间，那么就会认为这个consume处理能力太弱了，会被踢出消费组</li></ul><h2 id="架构总结"><a href="#架构总结" class="headerlink" title="架构总结"></a>架构总结</h2><p><em>三高</em><br>Kafka的高并发、高可用、高性能：</p><ul><li>高可用：多副本机制</li><li>高并发：网络架构设计，三层架构：多selector -&gt; 多线程 -&gt; 队列的设计（NIO）</li><li>高性能：<ul><li>写数据<ul><li>把数据先写入到OS Cache </li><li>写到磁盘上面是顺序写，性能很高</li></ul></li><li>读数据：<ul><li>根据稀疏索引，快速定位到要消费的数据</li><li>零拷贝机制 减少数据的拷贝 减少了应用程序与操作系统上下文切换</li></ul></li></ul></li></ul><p><em>主节点</em><br>Kafka中有很多主从结构：</p><ul><li>Broker集群的主：Controller，默认为创建临时序号节点中序号最小的，用于管理Broker的新增、修改、退出，为Partition选主。</li><li>Partition多副本的主：Master，由Controller选举，用于提供该Partition的读写，Slave需要向其同步消息。</li><li>Consumer组的协调器：Coordinator，随机选取，用于管理消费组中消费者的新增、修改、退出，即Rebalance。</li><li>Consumer组的Leader：消费组Leader，默认为首个消费者，负责Rebalance过程中消费分配方案的制定。</li></ul><h2 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h2><h3 id="延时任务"><a href="#延时任务" class="headerlink" title="延时任务"></a>延时任务</h3><p><em>场景</em><br>kafka会将延迟任务放到DelayedOperationPurgatory（延时管理器）中，如写入同步的过程：</p><ul><li>acks为-1时，需要等待所有follower写入成功，因此有超时时间，超时返回异常。</li><li>follower拉取master消息时，若没有新消息会等待，因此有超时时间，超时返回空。</li></ul><p><em>原理</em><br>多级时间轮<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20231005145519.png"><br>中间的大轮是工作轮，只有在它上的任务才会被执行；当低级轮转动一圈时，高一级轮转动一格，同时会将高一级轮上的任务重新分配到低级轮上。从而实现了多级轮级联的效果，所有任务最终都会迁移到工作轮上而被调度执行。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p><em>防止消息丢失</em></p><ul><li>生产者配置ack为all</li><li>消费者手动ack并实现幂等</li></ul><p><em>顺序消费问题</em></p><ul><li>生产者同步生产，保证生产有序</li><li>只投递到一个分区，Partition内消息有序</li><li>只用一个消费者消费该分区消息，且手动确认</li></ul><p><em>消息挤压问题</em></p><ul><li>消费者多线程消费</li><li>同时增加Partition与消费者数量</li><li>消费者对消息进行再分发</li></ul><p><em>延迟队列</em><br>手动实现：实现多级延迟队列，消费者通过队头消息判断是否消费</p><p><em>Kafka舍弃ZooKeeper的理由</em><br>Kafka目前强依赖于ZooKeeper：ZooKeeper为Kafka提供了元数据的管理，例如一些Broker的信息、主题数据、分区数据等等，还有一些选举、扩容等机制也都依赖ZooKeeper。</p><ol><li>运维复杂度：运维Kafka的同时需要保证一个高可用的Zookeeper集群，增加了运维和故障排查的复杂度。</li><li>性能差<ul><li>在一些大公司，Kafka集群比较大，分区数很多的时候，ZooKeeper存储的元数据就会很多，性能就会变差。</li><li>ZooKeeper需要选举，选举的过程中是无法提供服务的。</li><li>Zookeeper节点如果频繁发生Full Gc，与客户端的会话将超时，由于无法响应客户端的心跳请求，从而与会话相关联的临时节点也会被删除。</li></ul></li></ol><p><strong>所以Kafka 2.8版本上支持内部的quorum服务来替换ZooKeeper的工作。</strong></p><blockquote><p>参考文档：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/74063251">Kafka【入门】就这一篇</a></li><li><a href="https://cloud.tencent.com/developer/article/1547380">学习 Kafka 入门知识看这一篇就够了！（万字长文）</a></li><li><a href="https://cloud.tencent.com/developer/article/1536646">Kafka ISR 副本同步机制</a></li><li><a href="https://cloud.tencent.com/developer/article/1790732">Kafka Partition Leader选举机制原理详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1852157">一文理解Kafka的选举机制与Rebalance机制</a></li><li><a href="https://bright-boy.gitee.io/technical-notes/#/kafka/kafka?id=%e4%b9%9d%e3%80%81kafka%e9%9b%86%e7%be%a4controller%e3%80%81rebalance%e5%92%8chw">Kafka入门到精通</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><em>分布式架构</em><br>分布式是一种架构，具有松耦合、扩展性好等特点。</p><p><em>微服务</em><br>微服务则是分布式架构的一种方案。</p><p><em>落地实现</em></p><ul><li>SpringCloud</li><li>Dubbo</li></ul><p><em>微服务架构</em><br><img src="/Pasted%20image%2020230418212829.png"><br><img src="/Pasted%20image%2020230418212907.png"></p><blockquote><p>Dubbo是一个微服务框架，其实现了RPC和服务治理。现常利用其RPC能力，并将其与SpringCloud进行整合。</p></blockquote><p><em>服务拆分原则</em><br>不同服务访问不同的数据库。</p><h1 id="二、SpringCloud"><a href="#二、SpringCloud" class="headerlink" title="二、SpringCloud"></a>二、SpringCloud</h1><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p><em>概念</em><br><strong>SpringCloud</strong>常用的注册中心，其本身也是一个微服务组件。</p><p><em>启动eureka</em></p><ol><li>创建独立项目，添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>启动类上标注：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br></code></pre></td></tr></table></figure><ol start="3"><li>配置文件：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># eureka server占用端口</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-comment"># 为eureka client配置server url，这里配置是因为eureka本身也是client</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><p><em>配置eureka客户端</em></p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件同eureka服务配置，修改<code>spring.application.name</code>即可。</li></ol><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p><em>概念</em><br>阿里开源的注册中心。</p><p><em>依赖</em><br>nacos本身是打包好的服务端，直接运行即可，而对于客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>配置</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br><br><span class="hljs-comment"># 引入nacos的负载均衡规则，实现集群优先</span><br><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><ul><li>添加了Cluster配置的微服务注册到nacos中会被自动分类。</li><li>nacosrule功能为调用优先在同一集群内执行，随机选取。</li></ul><p><em>权重配置</em><br>在nacos可视化界面修改节点权重，默认为1，越小越不可能被随机。</p><p><em>环境隔离</em><br>nacos有默认命名空间，也可以为服务指定命名空间，不同命名空间之间的服务完全隔离，互相不可见。</p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p><em>配置管理</em><br>可将需要热更新的配置放置在nacos管理，新增时填写配置id和分组、配置信息即可，其中id一般命名为<code>appname-dev.yaml</code>形式。</p><p><em>配置拉取</em><br>bootstrap.yml文件会在application.yml文件之前被读取<br><img src="/Pasted%20image%2020230422170242.png"></p><p><em>依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>拉取规则</em><br>bootstrap.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p>会从server-addr拉取<code>userservice-dev.yaml</code>配置文件。</p><p><em>热更新</em></p><ul><li>方式一：在@Value注入的变量的<strong>类</strong>上注解@RefreshScope。</li><li>方式二：使用@ConfigurationProperties注解一个配置类，该类的变量会得到热更新，其他类可以通过引用该配置类获取配置。</li></ul><p><em>配置共享</em><br>nacos中配置id不标注环境，即为：application.name.yaml时，可被多环境共享。</p><p><em>配置优先级</em><br><img src="/Pasted%20image%2020230422171030.png"></p><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><ul><li>配置数据库：nacos0.7版本后提供数据库存储数据，使用nacos-mysql.sql语句初始化数据库<code>nacos-config</code>，然后配置<code>application.properties</code>文件的数据库访问url；</li><li>修改每个nacos服务目录下的<code>application.properties</code>文件，修改端口；</li><li>修改每个nacos服务目录下的<code>cluster.conf.example</code>文件，并将其后缀<code>.example</code>删除，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">ip1:port1<br>ip2:port2<br>ip3:port3<br></code></pre></td></tr></table></figure><h3 id="注册中心对比"><a href="#注册中心对比" class="headerlink" title="注册中心对比"></a>注册中心对比</h3><p><em>实例类型</em><br>nacos有临时实例和非临时实例两种实例，其中临时实例在宕机超时后会被剔除。</p><p><em>心跳对比</em><br><img src="/Pasted%20image%2020230419003048.png"></p><ul><li>Eureka：实例主动向注册中心发送心跳。</li><li>Nacos：临时实例主动向注册中心发送心跳，注册中心主动询问非临时实例的心跳</li></ul><p><em>服务发现</em></p><ul><li>Eureka：只支持拉取。</li><li>Nacos：支持拉取和注册中心主动推送，实现更新。</li></ul><p><em>CAP</em></p><ul><li>Eureka：AP模式（保证可用性）</li><li>Nacos：默认AP，集群中存在非临时实例时，使用CP（保证一致性）</li></ul><h2 id="调用组件"><a href="#调用组件" class="headerlink" title="调用组件"></a>调用组件</h2><h3 id="负载均衡（Ribbon）"><a href="#负载均衡（Ribbon）" class="headerlink" title="负载均衡（Ribbon）"></a>负载均衡（Ribbon）</h3><p><strong>Ribbon</strong>是SpringCloud<strong>默认</strong>依赖的负载均衡类。<br><em>LoadBalanced</em><br>需要<strong>手动</strong>配合RestTemplete可以实现负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-keyword">public</span> RestTemplete <span class="hljs-title function_">restTemplete</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplete</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><em>底层实现</em></p><ul><li>RestTemplete使用服务名替换域名发起请求。</li><li>@LoadBalanced实现切面，发起请求时先到注册中心拉取服务名对应的服务节点列表，并实现负载均衡。</li></ul><p><img src="/Pasted%20image%2020230418223553.png"></p><p><em>修改负载均衡</em></p><ol><li>代码方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置方式</li></ol><p>对需要做负载均衡的服务（如本服务希望以指定的负载均衡方式调用userservice），则可以将本配置添加到本服务配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code>属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>较好的策略是ZoneAvoidanceRule，即优先轮询同一个区域内的服务器。</p><p><em>饥饿加载</em><br>默认懒加载，开启以下配置则开启饥饿加载。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><p><em>服务列表更新</em><br>Ribbon定时向服务器拉取服务列表并缓存（默认）和Ribbon订阅事件两种方式。</p><h3 id="远程调用（Feign）"><a href="#远程调用（Feign）" class="headerlink" title="远程调用（Feign）"></a>远程调用（Feign）</h3><p><em>概念</em><br>上文提到默认使用了restTemplete发起请求，但代码可读性和可维护性较差。因此引入Feign，其是一个<strong>声明式http客户端</strong>。</p><p><em>依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类上添加注解开启Feign功能：<code>@EnableFeignClients</code></p><p><em>使用</em><br>编写客户端，本质上就是写一个调用<strong>接口</strong>，创建了一个针对userservice服务的客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>配置使用</em></p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE（默认值）、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign.contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign.retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr><tr><td>配置文件方式：</td><td></td><td></td></tr></tbody></table><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>代码方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写以下类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfiguration</span>  &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在启动类上添加@EnableFeignClients注解，表示全局配置</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br><br><span class="hljs-comment">//在Feign类上添加@EnableFeignClients注解，表示局部配置</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span><br></code></pre></td></tr></table></figure><p>显然代码方式可以做到更细的颗粒度。</p><p><em>优化</em><br>Feign底层发起http请求依赖于其他框架，实现有：</p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>可替换其底层框架使用连接池优化，具体为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure><p><em>最佳实践</em><br>FeignClient与被调用方的Controller很类似，希望能减少代码重复编写。</p><ul><li>继承方式：编写一个UserAPI接口，FeignClient和Controller分别继承该接口。<ul><li>特点：简单、实现了代码共享；耦合度高、且注解映射无法继承，Conrtoller必须再次声明发布方法、参数列表、注解。<strong>基本不考虑使用。</strong></li></ul></li><li>抽取方式：将Feign的Client抽取到一个feign-api包中，所有微服务可引用该依赖包来实现对其他微服务的调用。<ul><li>特点：为所有微服务只需要编写一个feign-api包即可，实现所有微服务的Feign代码共享。</li><li>使用：需要解决包扫描问题，引入feign-api包后，需要全局修改启动类<code>@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</code>扫描包。</li></ul></li></ul><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p><em>核心功能</em><br><img src="/Pasted%20image%2020230422175957.png"></p><ul><li>权限控制</li><li>路由和负载均衡</li><li>限流</li></ul><p><em>网关实现</em></p><ul><li>Zuul：基于Servlet实现，阻塞式编程</li><li>SpringCloud GateWay：基于WebFlux实现，响应式编程，性能更好</li></ul><h3 id="SpringCloud-GateWay"><a href="#SpringCloud-GateWay" class="headerlink" title="SpringCloud GateWay"></a>SpringCloud GateWay</h3><p><em>依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>配置</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><h4 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h4><p>断言本质就是一种条件判断，不同的断言工厂提供了不同的判断条件，通过条件判断的请求才会被路由。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理,在servicename中，权重值为x</td><td>-Weight&#x3D;servicename,5</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p><img src="/Pasted%20image%2020230422181240.png"></p><p><em>过滤器种类</em></p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><p><em>使用</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>  <span class="hljs-comment"># 只对通过断言的请求执行对应的过滤器</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <br>        <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 添加请求头</span><br>      <span class="hljs-comment">#对所有路由执行的过滤器</span><br>      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># 默认过滤项</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <br></code></pre></td></tr></table></figure><p><em>自定义全局过滤器</em><br>自定义过滤器可以实现更具体的登录状态、限流、权限功能，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();<br>        <span class="hljs-comment">// 2.获取authorization参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.校验</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 4.拦截</span><br>        <span class="hljs-comment">// 4.1.禁止访问，设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-comment">// 4.2.结束处理</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>过滤器执行顺序</em></p><ul><li>按照各过滤器的order值，越小越先执行；</li><li>路由过滤器和默认过滤器的order由spring指定，默认按声明顺序从1递增；</li><li>order相同时，按照defaultFilter&gt;routeFilter&gt;globalFilter顺序执行；<br><img src="/Pasted%20image%2020230422182309.png"></li></ul><p><em>跨域问题</em><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域问题介绍</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 。。。</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 </span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure><h1 id="X、服务保护"><a href="#X、服务保护" class="headerlink" title="X、服务保护"></a>X、服务保护</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><em>雪崩问题</em><br>某个服务出现故障，依赖该服务的的服务也会被阻塞，从而形成级联失败。<br><img src="/Pasted%20image%2020230420153707.png" alt="服务D故障导致链路服务都发生故障"></p><p><em>解决方案</em></p><ul><li>超时处理：请求超时没得到响应即返回，不会无休止等待。</li><li>仓壁模式：业务线程限制，限制每个业务的最大线程数，避免影响其他业务。</li><li>断路器：统计<strong>异常比例</strong>，超出阈值则熔断。</li><li>限流（预防性措施）：为服务做限流处理。</li></ul><p><em>实现</em></p><table><thead><tr><th></th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离&#x2F;信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="介绍与使用"><a href="#介绍与使用" class="headerlink" title="介绍与使用"></a>介绍与使用</h3><p><em>介绍</em><br><a href="https://sentinelguard.io/zh-cn/index.html">官网</a></p><p><em>依赖</em><br>为微服务引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改微服务配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>完成后，对该微服务的端点调用会触发sentinel监控。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><em>簇点链路</em><br>Controller -&gt; Service -&gt;Mapper调用链是一个簇点链路，每个节点都是一个<strong>资源</strong>。资源是流控、降级、热点参数限流、授权的基本控制单元。</p><p><em>流控阈值设置</em></p><ul><li>QPS：限制每秒最大请求数</li><li>线程数：限制业务最大线程数（需要配合FeighClient一起使用）</li></ul><p><em>流控模式</em></p><ul><li>直接：根据自身的QPS或线程数控制流量</li><li>关联：当<strong>关联资源</strong>触发阈值时，对<strong>当前资源</strong>限流</li><li>链路：只有从<strong>指定入口</strong>进入当前资源的请求才会被限流。</li></ul><blockquote><p>其中：</p><ul><li>关联模式常用于两个竞争关系资源，可限制优先级，比如写业务频繁则限制读业务。</li><li>链路模式用于存在调用关系的资源，即限制某个资源对当前资源的调用。</li></ul><p>另外，Sentinel默认会给进入MVC的请求设置同一个资源，即将一个服务调用（Controller-&gt;Service-&gt;Mapper）视为一个资源节点，如果需要将Service类中的方法单独视为资源，应该：主动为其添加注解@SentinelResource(“resource_name”)</p></blockquote><p><em>流控效果</em></p><ul><li>快速失败：达到阈值后直接返回flowexception。</li><li>warm up：预热模式，根据设置的<strong>预热时间</strong>，阈值从1&#x2F;3最大阈值逐渐升高到最大阈值</li><li>排队等待：超阈值请求排队等待，如果排队等待的预计等待时间（前面的请求数 × 平均请求处理时间）超过<strong>指定时间</strong>，则返回flowexception。</li></ul><p><em>热点参数限流</em></p><ul><li>全局参数限流：设置参数索引、单机阈值、统计窗口。表示<strong>统计窗口</strong>内<strong>参数索引</strong>位置上相同的参数的请求不能超过<strong>阈值</strong>。</li><li>热点参数限流：在全局参数限流的基础上，独立限制某个<strong>具体参数的请求值</strong>的阈值。</li></ul><blockquote><p>在热点参数限制中，MVC中所有资源无效，需要利用@SentinelResource注解标记资源。</p></blockquote><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p><em>机制</em><br>断路器使用了状态机实现功能：<br><img src="/Pasted%20image%2020230420210113.png"></p><p><em>熔断策略</em></p><ul><li>慢调用：<strong>统计时间</strong>内，时长超过<strong>最大RT</strong>的请求比例大于<strong>比例阈值</strong>，且总请求数大于<strong>最小请求数</strong>，则熔断<strong>指定时长</strong>。</li><li>异常比例：<strong>统计时间</strong>内，异常请求数量大于<strong>比例阈值</strong>，且总请求数大于<strong>最小请求数</strong>，则熔断<strong>指定时长</strong>。</li><li>异常数：<strong>统计时间</strong>内，异常请求数量大于<strong>异常数</strong>，且总请求数大于<strong>最小请求数</strong>，则熔断<strong>指定时长</strong>。</li></ul><h3 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h3><p>TODO，GateWay学完后补充</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><em>数据流</em><br>dashboard是sentinel控制台，core是微服务的sentinel依赖。</p><ul><li>sentinel dashboard启动在指定的ip和port上；</li><li>sentinel core通过配置dashboard的ip和port与dashboard建立连接；</li><li>sentinel core通过HeartbeatSender向dashboard发送自己的存活信息，包括ip和port，dashboard将该信息保存；</li><li>sentinel core通过CommandCenter向dashboard提供数据请求服务，dashboard通过http向sentinel core请求数据。<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5417792-3d9042c0162c45c0.webp"></li></ul><p><em>实现原理</em></p><ul><li>每个资源都通过一个Entry对象维护资源的流量控制功能；</li><li>整个调用链路是通过 Entry 的父子指针来描述的，SphU.Entry对象有如下属性：<ul><li>上下文对象context，贯穿整个请求的过程，保存于ThreadLocal中，每次调用链路开始都会创建一个context实例。保存有入口名称、调用根节点、调用源、当前执行点Entry。</li><li>资源对象，包括资源名、入口&#x2F;出口流量，资源类型。</li><li>ProcessSlot链，一个责任链，判断请求是否能否进入，通过SpiOrder可以设置各slot优先级。</li></ul></li></ul><p><img src="/Pasted%20image%2020230420213145.jpg"></p><ul><li>entry.exit()：资源访问完毕后退出，为每个slot做一些资源清理和数据统计。</li></ul><blockquote><p>集群环境统计某一资源的所有访问量，Sentinel 中还对统计量进行了聚合，聚合后的统计节点会包含某一资源在不同入口下的所有访问量（称之为 ClusterNode），Sentinel 为了能够根据访问源进行流控还会针对每一个资源的每一类访问源分别进行流量统计（称之为 OriginNode）：</p></blockquote><p><img src="/Pasted%20image%2020230420214041.png"><br><em>资源访问链</em></p><ul><li>资源的根节点为machine-root</li><li><code>ContextUtil.enter(resourceName,appname)</code>表示调用进入该resourceName节点，该节点将被作为入口节点。</li><li><code>SphU.entry(&quot;nodeA&quot;)</code>表示调用进入nodeA节点，并会经过该资源节点entry的slot链（entry中的clusterNode节点记录并提供资源的统计数据）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;entrance1&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>); <br><span class="hljs-type">Entry</span> <span class="hljs-variable">nodeA</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>); <br><span class="hljs-type">Entry</span> <span class="hljs-variable">nodeB</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeB&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker&amp;K8S</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&amp;K8S/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&amp;K8S/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Docker"><a href="#一、Docker" class="headerlink" title="一、Docker"></a>一、Docker</h1><h2 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h2><ol><li><a href="https://cloud.tencent.com/developer/article/1632429">docker安装</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc">镜像站</a></li><li>切换镜像源后，使用<code>systemctl restart docker.service</code>重启docker引擎</li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><em>结构</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230331231005.png"></p><p><em>运行中</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230331231228.png"></p><p><em>命令</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 80:80 --name containerName nginx<br></code></pre></td></tr></table></figure><blockquote><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 </li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li><li>e xxx&#x3D;”xxx” 环境变量</li></ul></blockquote><p><em>进入容器</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it containerName bash<br>docker attach containId<br></code></pre></td></tr></table></figure><blockquote><ul><li>docker exec ：进入容器内部，执行一个命令</li><li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li><li>containerName ：要进入的容器的名称</li><li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed 修改文本，具体使用参考相关案例，一般不这样做，很不方便<br></code></pre></td></tr></table></figure><p><em>退出容器</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br>Ctrl + D<br></code></pre></td></tr></table></figure><p><em>其他</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs -f （持续）查看日志<br>docker ps -a 查看（所有）容器<br>docker stop containId 停止<br>docker restart containId 重启<br>docker container prune 清理停止的容器<br></code></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><em>创建数据卷</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230331233025.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><blockquote><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息，可查看volume位置。</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul></blockquote><p><em>挂载数据卷</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name containName -v html:/root/html -p 8080:80 nginx \<br></code></pre></td></tr></table></figure><blockquote><p><code>:</code>，相关的指令一般本机在前，宿主机在后<br><code>v</code>，也可以挂载目录，可自定义，但需要我们自己管理目录</p></blockquote><h2 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h2><p>只需要告知docker，镜像的基本依赖、项目文件、启动脚本即可构建。<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230401000841.png"><br><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer，在DockerFile文本所在目录下，执行build：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t imageName:v1.0<br></code></pre></td></tr></table></figure><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p><em>Compose文件</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230401003504.png"></p><p>分布式应用编排，解决命令行逐个运行容器的过程。<br><code>docker-compose.yml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &quot;3.8&quot;<br>services:<br>  nacos:<br>    image: nacos/nacos-server<br>    environment:<br>      MODE: standalone<br>    ports:<br>      - &quot;8848:8848&quot;<br>  mysql:<br>    image: mysql:5.7.25<br>    environment:<br>      MYSQL_ROOT_PASSWORD: 123<br>    volumes:<br>      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;<br>      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;<br>  userservice:<br>    build: ./user-service<br>  orderservice:<br>    build: ./order-service<br>  gateway:<br>    build: ./gateway<br>    ports:<br>      - &quot;10010:10010&quot;<br></code></pre></td></tr></table></figure><p>文件中<code>build:</code>表示这是一个临时起的DOCKER镜像，其中都有DockerFile文件。</p><p><em>通讯修改</em><br>服务之间的通讯不再通过<code>ip</code>，而是通过容器名称。（可以理解为容器之间根据容器名实现了一个DNS）。</p><p><em>部署</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><p>使用本地仓库必须先tag:名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p><em>推送仓库</em></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0<br></code></pre></td></tr></table></figure><p><em>拉取镜像</em></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><h2 id="原理理解"><a href="#原理理解" class="headerlink" title="原理理解"></a>原理理解</h2><h3 id="docker镜像分层"><a href="#docker镜像分层" class="headerlink" title="docker镜像分层"></a>docker镜像分层</h3><p><em>镜像层次</em><br><img src="/Pasted%20image%2020240222144015.png"><br>所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。<br><strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的</strong></p><p><em>文件操作说明</em></p><table><thead><tr><th>文件操作</th><th>说明</th></tr></thead><tbody><tr><td>添加文件</td><td>在容器中创建文件时，新文件被添加到容器层中。</td></tr><tr><td>读取文件</td><td>在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。</td></tr><tr><td>修改文件</td><td>在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</td></tr><tr><td>删除文件</td><td>在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。（只是记录删除操作）</td></tr></tbody></table><blockquote><p>参考文档：<br><a href="%E5%8F%B2%E4%B8%8A%E8%AE%B2%E8%A7%A3%E6%9C%80%E5%A5%BD%E7%9A%84Docker%E6%95%99%E7%A8%8B">https://cloud.tencent.com/developer/article/1885678</a></p></blockquote><h3 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a>docker网络类型</h3><p><em>docker的网络类型</em></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>None</td><td>不为容器配置任何网络功能，没有网络 –net&#x3D;none</td></tr><tr><td>Container</td><td>与另一个运行中的容器共享Network Namespace，–net&#x3D;container:containerID</td></tr><tr><td>Host</td><td>与主机共享Network Namespace，–net&#x3D;host</td></tr><tr><td>Bridge</td><td>Docker设计的NAT网络模型（默认类型）</td></tr><tr><td>Bridge默认docker网络隔离基于网络命名空间，在物理机上创建docker容器时会为每一个docker容器分配网络命名空间，并且把容器IP桥接到物理机的虚拟网桥上。</td><td></td></tr></tbody></table><p><em>复习VMware的网络模式</em><br>VMnet0：用于桥接模式下的虚拟交换机<br>VMnet1：用于仅主机模式下的虚拟交换机<br>VMnet8：用于NAT模式下的虚拟交换机<br><img src="/Pasted%20image%2020240222144340.png"></p><div class="note note-primary">            <p>桥接模式下的所有虚拟机都是和主机是在同一网段的，可以把它们看成是”平等”的关系，这就会带来一些麻烦，比如192.168.1段下只有254个主机地址，所以桥接模式下虚拟机和物理的总数不能超过这个数字！</p>          </div><p><img src="/Pasted%20image%2020240222144351.png"></p><div class="note note-primary">            <p>可见NAT模式下主机更像是虚拟机们的”路由器”，通过VMnet8虚拟网卡为虚拟机分发地址。所以虚拟机和主机不在同一网段下，这也就是为什么桥接模式没有VMnet0这个虚拟网卡，因为桥接模式下的虚拟机和主机是”平等”的，共用同一个路由器呀。</p>          </div><p><img src="/Pasted%20image%2020240222144406.png"></p><div class="note note-primary">            <p>仅主机模式可有看成是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。</p>          </div><p>Host-Only情况下也可以实现外网访问，详见<a href="https://zhuanlan.zhihu.com/p/366372725">vmware 虚拟机三种网络模式 的区别</a></p><h1 id="二、K8S"><a href="#二、K8S" class="headerlink" title="二、K8S"></a>二、K8S</h1><p>TODO<br><a href="https://zhuanlan.zhihu.com/p/339008746">https://zhuanlan.zhihu.com/p/339008746</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>容器技术</category>
      
      <category>Docker&amp;K8S</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>Docker&amp;K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java复习</title>
    <link href="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h1><h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><p>开单依接里迪合</p><ul><li>开放封闭原则：对扩展开放，对修改关闭。</li><li>单一职责原则：一个类、接口或方法只负责一个职责。</li><li>依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。</li><li>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。</li><li>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。</li><li>迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。</li><li>合成复用原则：聚合 &gt; 继承，降低耦合度。</li></ul><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul><li>创建型模式：单抽工建原</li><li>结构型模式：适装代外桥组享</li><li>行为型模式：策模观迭责命，状备访中解</li></ul><p><em>单例模式</em><br>双重校验锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>工厂</em><br>简单工厂模式：根据方法参数返回不同子类<br>工厂方法模式：对接口进行不同子类实现<br>抽象工厂模式：创建对象家族</p><p><em>外观模式</em><br>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><p><em>桥接模式</em><br>将抽象与实现分离开来，使它们可以独立变化。</p><p><em>享元模式</em><br>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><p><em>观察者模式</em><br>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><p><em>访问者模式</em><br>为数据结构中的每个元素提供多种访问方式。它将<strong>对数据的操作与数据结构进行分离</strong>。</p><h1 id="二、Java基础复习"><a href="#二、Java基础复习" class="headerlink" title="二、Java基础复习"></a>二、Java基础复习</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p><em>类型转换</em><br>字面浮点数是double类型的。<br>字面整数是int类型的。<br><code>+=</code>可以隐式转换。</p><p><em>缓存池</em><br>boolean、bytes、short、int、char有-128~127的缓存池，<code>valueOf()</code>可以获取。</p><p><em>String</em></p><ul><li>不可变，便于hash使用和网络传输，线程安全</li><li>StringBuffer线程安全，StringBuilder线程不安全</li><li>JDK8及之前是<code>char[]</code>(UTF-16)，JDK9时是<code>byte[]</code>（Latin-1），动态调整字符集。</li></ul><p><em>字符串常量池</em><br>规范上在方法区，1.6在永久代，1.7在堆，1.8在堆中。</p><p><em>运算</em><br>%向0取整，mod向下取整</p><p><em>位运算</em><br><code>&gt;&gt;&gt;</code>无符号右移<br><code>~</code>以-0.5为轴反转</p><p><em>switch</em><br>byte,short,char,int,枚举(jdk5.0)，String对象(jdk7.0)，但不能使用long类。<strong>对String的支持是语法糖</strong>。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>封装、继承、多态（编译时多态：<strong>重载</strong>、运行时多态：<strong>重写</strong>）。</p><p><em>权限修饰符</em><br>private、default（包可见）、protected（包、子类可见）、public<br>类修饰符只有default和public。</p><p><em>static</em><br>静态类不依赖于外部类实例。<br>静态变量可以不赋予初值，在链接阶段的准备过程会赋予默认值。</p><p><em>对象构造</em><br>一个类至少一个构造器，显示定义构造器后，默认的无参构造器失效。</p><p><em>初始化顺序</em></p><ul><li>类初始化（static从上至下）</li><li>默认初始化（0，false）</li><li>构造初始化（普通赋值和普通代码块从上至下）</li><li>构造函数</li></ul><p><em>super</em><br>super()父类构造函数</p><p><em>toString</em><br>默认返回对象类型 + @ + 16进制的hashCode()</p><p><em>Clone</em><br>native的clone()是<strong>浅拷贝</strong>。</p><ul><li>继承Cloneable接口</li><li>重写clone()</li><li>抛出CloneNotSupportedException</li></ul><p><em>Enum</em><br>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>  <br>&#123;  <br>RED, GREEN, BLUE;  <br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;  <br>RED(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">1</span>), GREEN(<span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">2</span>), BLANK(<span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-number">3</span>), YELLO(<span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">4</span>);  <br><span class="hljs-comment">// 成员变量  </span><br><span class="hljs-keyword">private</span> String name;  <br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;  <br><span class="hljs-comment">// 构造方法  </span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> index)</span> &#123;  <br><span class="hljs-built_in">this</span>.name = name;  <br><span class="hljs-built_in">this</span>.index = index;  <br>&#125;  <br><span class="hljs-comment">// 普通方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br><span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;  <br><span class="hljs-keyword">if</span> (c.getIndex() == index) &#123;  <br><span class="hljs-keyword">return</span> c.name;  <br>&#125;  <br>&#125;  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;  <br>get,set...  <br>&#125;<br></code></pre></td></tr></table></figure><p><em>Externalizable</em><br>继承<code>externalizable</code>，重写<code>writeExternal</code>和<code>readExternal</code>。</p><p><em>序列化</em><br>声明为static和transient类型的数据不能被序列化，只存在内存，Externalizable不受影响。<br>serialVersionUID可用于验证对象类的版本一致性。</p><p><em>finally</em><br>finally必然执行，其会插入在return语句前：</p><ul><li>如果在finally中return，会影响return结果。</li><li>如果在finally中对try&#x2F;catch中的return结果修改，不会影响return结果。</li></ul><p><em>局部变量手动赋值</em><br>都进行一次初始化消耗太大。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li>成员内部类<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>非成员内部类<ul><li>局部内部类、匿名内部类</li></ul></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>继承角度：</p><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口（is a和like a）</li></ul><p>构造角度：</p><ul><li>抽象类可以有构造方法, 接口没有构造方法</li></ul><p>成员变量角度：</p><ul><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能<strong>public static final</strong>(默认)</li></ul><p>成员方法角度：</p><ul><li>抽象类方法可以是public、protected；</li><li>接口方法在JDK8之前只有public abstract；接口方法在JDK8可以有default方法，在JDK9中允许有private方法。</li><li>抽象类可以有静态方法；接口在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）；</li></ul><p>实用角度：</p><ul><li>接口：多重继承，主要用于表示实现类拥有具体方法。  </li><li>抽象类：主要用于在相关类中共享代码。</li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><em>作用</em></p><ul><li>屏蔽真实角色</li><li>增强功能，如添加权限，访问控制和申计</li><li>延迟加载</li></ul><p><em>条件</em><br>被代理类A实现接口C，使用类B实现代理：</p><ul><li>静态代理：类B实现接口C，聚合A类对象；</li><li>动态代理：<ul><li>类B实现<code>InvocationHandler</code>接口，聚合A类对象，并重写<code>invoke</code>方法；</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>创建代理对象。</li></ul></li><li>Cglib代理：<ul><li>类B实现<code>MethodInterceptor</code>接口，重写<code>intercept</code>方法;</li><li>使用<code>Enhancer</code> 类设置类加载器，被代理类A，代理类B，并使用<code>create()</code>创建代理类；</li></ul></li></ul><p><em>对比</em></p><ul><li><strong>静态代理与动态代理</strong><ul><li><strong>灵活性</strong>：动态代理更灵活</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul></li><li><strong>JDK 动态代理和 CGLIB 动态代理对比</strong><ul><li>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。（另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。）</li><li>大部分情况都是 JDK 动态代理更优秀。</li></ul></li></ul><blockquote><ul><li>JDK动态代理是面向接口的，在创建代理实现类时比CGLib要快，创建代理速度快。</li><li>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么代理会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。</li></ul></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><em>目的</em><br>代码复用，使用一个代码流程适配多个类型，提供类型检查。</p><p><em>“真泛型”与“伪泛型”的区别</em><br>Java属于伪泛型：</p><ul><li>真泛型：泛型中的类型是真实存在的。</li><li>伪泛型：仅于编译时类型检查，在运行时擦除类型信息。</li></ul><p><em>用法</em><br>泛型类、泛型接口、泛型方法、使用泛型类参数的普通方法</p><p><em>上下限</em><br>extends（生产T）、super（消费T）提供上下限检查</p><p><em>泛型类的数组</em></p><ul><li>不能<code>new ArrayList&lt;String&gt;[n]</code></li><li>可以<code>new ArrayList&lt;?&gt;[n]</code></li></ul><p><em>泛型擦除</em><br>编译前做检查，编译后类型擦除<br><code>extends T</code>会替换成T<br><code>super T</code>会提换成Object</p><blockquote><p><a href="https://www.jianshu.com/p/4a75bad9f65f">为什么Java的泛型要用”擦除”实现</a><br>因为“真泛型”的引入，势必会为原本不支持泛型的 API 平行添加一套泛型 API，为了引入泛型，又不影响原有的项目，使用了泛型擦除的方式。</p></blockquote><p><em>泛型方法</em></p><ul><li>不指定泛型，为同一父类的最小级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span><br></code></pre></td></tr></table></figure><ul><li>指定泛型，则必须为该泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float</span><br></code></pre></td></tr></table></figure><p><em>泛型多态</em><br>类A继承了泛型类并重写方法，编译器会为该类A生成桥方法，桥方法实现了父类方法的重写，并在其中调用用户写的方法。</p><p><em>获取泛型参数</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericType&lt;String&gt; genericType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;  <br><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> genericType.getClass().getGenericSuperclass();<br></code></pre></td></tr></table></figure><p><strong>Type</strong>是Java所有类型实现的<strong>公共接口</strong>。</p><p><em>注意</em></p><ul><li>基本类型不能作为泛型类型</li><li>泛型数组不能初始化</li><li>泛型数组如何正确初始化，使用集合</li><li>异常中使用泛型，可以抛出，不能捕获（会导致错误捕获）</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><em>注解的作用</em></p><ul><li><strong>生成文档</strong></li><li><strong>编译检查</strong></li><li><strong>编译时动态处理</strong></li><li><strong>运行时动态处理</strong></li></ul><p><em>元注解</em></p><ul><li>@Target</li><li>@Retention，保留时间</li><li>@Document</li><li>@Inherited，子类是否继承</li><li>@Reaptable</li><li>@Native</li></ul><p><em>内置注解</em></p><ul><li>@Override，内置注解</li><li>@Deprecated，已过时</li><li>@WarningSupress，警告抑制</li><li>@Repeatable</li></ul><p><em>注解与反射接口</em><br><code>Annotation[] getAnnotations()</code></p><p><em>注解原理</em></p><ul><li>注解之间无法继承</li><li>注解是一个继承自Annotation的接口，里面每一个属性其实是一个接口的抽象方法。</li></ul><p><em>应用</em></p><ul><li>框架注解化</li><li>AOP</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324213918.png"></p><p><strong>throw</strong> – 用于<strong>抛出</strong>异常。<br><strong>throws</strong> – 用在方法签名中，用于声明该方法<strong>可能抛出</strong>的异常。</p><p><em>异常表</em><br>按catch顺序记录：from、to、type、target。</p><p><em>finally</em><br>可能硬编码到try、catch中。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><em>获取class对象</em></p><ul><li>Class.class</li><li>object.getClass()</li><li>Class.forName()</li><li>loadClass()</li></ul><p><em>构造器</em><br>可以通过class对象获取该类的构造器。</p><ul><li>getConstructors() 获取所有public构造器</li><li>getDeclaredConstructors() 获取所有声明的构造器</li></ul><blockquote><p>以上两个方法不构成覆盖关系，getDeclaredConstructors能获取私有构造器，却无法获取继承到的public构造器。</p></blockquote><p><em>method</em><br>invoke</p><p><em>深入反射</em><br><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324214405.png"></p><p>ReflectionData存在Class对象中，<strong>软引用</strong>，使用<code>reflection()</code>方法获取缓存。</p><p><em>线程安全</em></p><ul><li>反射保证线程安全，对于method会先copy一份（数据隔离）再invoke，最终都是由JVM执行<code>invoke0()</code>方法。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324214713.png"></p><p><em>ArrayList</em></p><ul><li><code>Object[]</code>、size；</li><li>扩容<code>ensureCapacity()</code>1.5倍；</li><li>modCount拥有Fail-Fast机制。</li></ul><p><em>LinkedList</em></p><ul><li>fisrt Node、last Node、size；</li><li>clear()会迭代清空，help GC</li></ul><p><em>ArrayDeque</em><br>循环数组</p><ul><li><code>Object[]</code>、size、head、tail</li><li>addFisrt：<code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code></li><li>扩容<code>doubleCapacity()</code>2倍，先复制head右侧的部分</li></ul><p><em>PriorityQueue</em></p><ul><li><code>Object[]</code>、size</li><li><code>leftNode = parentNode*2+1</code></li><li>扩容<code>grow()</code>，复制原数组到新数组</li></ul><p><em>HashMap&amp;HashSet JDK7</em><br><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324215427.png" alt="JDK7"></p><ul><li>组成：<ul><li><code>Entry[]</code></li><li>初始容量(<em>inital capacity</em>)：16</li><li>负载系数(<em>load factor</em>)：0.75</li></ul></li><li>添加：<ul><li>头插法</li><li>先判断是否扩容再插入</li></ul></li><li>扩容：<ul><li>rehash 2倍</li></ul></li></ul><p><em>HashMap&amp;HashSet JDK8</em><br><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324215507.png"></p><ul><li>组成：<ul><li><code>Node[]</code></li><li>初始容量(<em>inital capacity</em>)：16</li><li>负载系数(<em>load factor</em>)：0.75</li></ul></li><li>添加：<ul><li>判断头节点类型，看使用链表尾插还是红黑树（超过8个转红黑树）</li><li>先插入再判断是否扩容（有时put只会覆盖不会生产新节点，先插入后扩容可以避免不必要的扩容发生）</li></ul></li><li>扩容：<ul><li>rehash 2倍</li></ul></li></ul><div class="note note-primary">            <p>java7是先扩容再插值，java8是先插值再扩容，猜测的原因为：</p><ul><li>java7基于头插法，先扩容后可以直接计算目标值hash，插入扩容后的集合。</li><li>java8基于尾插法，且使用了红黑树结构，先将元素插入后在改变结构更方便。</li></ul>          </div><p><em>Hash的计算方法</em></p><ul><li>Integer类的hashCode()为其ascii值</li><li>String类的hashCode()为其各字符的ascii值（前一位字符相比后一位字符多×32）</li><li>Object类的hashCode的方法返回的哈希值是该对象在内存中的地址值。</li></ul><p><em>LinkedHashMap</em><br>HashMap的子类，使用双向链表将所有entry相连接，遍历更快。</p><p><em>WeakHashMap</em><br>弱引用管理，可用作缓存。</p><p><em>TreeMap</em><br>基于红黑树，性质有：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li><strong>根节点必须是黑色</strong></li><li><strong>红色节点不能连续</strong>。</li><li><strong>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。</strong></li></ol><p>调整要点：</p><ul><li>尽量调整颜色完成调整</li><li>尽量调整叶子节点，如删除时可考虑前继&#x2F;后继节点</li><li>左右旋转能借到节点最好，否则使用父节点迭代。</li></ul><p><em>ConcurrentHashMap JDK1.7</em><br>分段锁：</p><ul><li>组成：<ul><li><code>Segment[]</code>，每个Segment有一个<code>Entry[]</code></li><li>初始容量(<em>inital capacity</em>)：16个Segment，每个Segment16个Entry</li><li>负载系数(<em>load factor</em>)：Segement数组初始化后不可修改，Entry负载系数0.75，可扩容</li></ul></li><li>添加：<ul><li>先使用二次hash定位segment</li><li>加锁，使用一次hash定位entry所在位置，并添加，失败则自旋，自旋失败次数过大则阻塞。</li><li>先插入再判断是否扩容(每个Segment内部判断、扩容)</li></ul></li><li>扩容：<ul><li>rehash 2倍</li></ul></li></ul><p><em>ConcurrentHashMap JDK1.8</em></p><ul><li>组成：<ul><li><code>Node[]</code></li><li>初始容量(<em>inital capacity</em>)：16</li><li>负载系数(<em>load factor</em>)：0.75</li><li>创建时指定大小(<code>sizeCtl</code>)，但不实例化</li></ul></li><li>添加：<ul><li>初始化整个对象（<strong>初始化被延迟到第一次put</strong>，且该操作通过CAS修改sizeCtl保证只执行一次）</li><li>对于空桶，CAS尝试写入，失败则自旋。</li><li>若hashCode &#x3D;&#x3D; -1，则需要<strong>扩容</strong>。</li><li>对桶头部加锁，判断类型并执行添加。</li></ul></li><li>扩容：<a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">图文参考</a><ul><li>触发条件：达到载荷&#x2F;putAll空间不足&#x2F;某链表长度达到8，但数组长度小于64。</li><li>红黑树转化条件：链表长度达到8，且数组长度大于64。（即优先扩容数组，后转红黑树）</li><li>根据CPU个数、判断每个线程负责的桶个数，从右至左，使用<code>transferIndex</code>标识迁移工作的发配工作进度，每个线程扩容时，移动该指针即可。</li><li>链表迁移：先将原链表复制出来分成两个链表，再分别放入桶中。（涉及一个lastrun节点概念）</li><li>红黑树迁移：先将原红黑树复制出来分成两个链表，根据大小判断直接放入桶中还是构建红黑树。</li><li>扩容时读：每个桶有一个标记，标识其迁移中还是迁移完成。原桶迁移完成中仍存在，直接读原桶即可；迁移完成后，直接读新桶即可。</li><li>扩容时写：阻塞</li><li>多线程迁移：使用sizeCtl判断完成，完成后最后一个线程检查整个table。</li></ul></li></ul><p><em>CopyOnWriteArrayList JDK1.8</em></p><ul><li><code>Object[]</code>、Lock</li><li>写时加锁，创建一个大小比当前数组大1的数组，并复制原数组到新数组</li><li>然后将新数组设置成原数组</li></ul><h1 id="三、JUC"><a href="#三、JUC" class="headerlink" title="三、JUC"></a>三、JUC</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><em>用户空间与内核空间</em><br>这是基于<strong>内存</strong>的划分，运行在用户空间的进程叫处于用户态，运行在内核空间的进程叫处于内核态。</p><p><em>线程实现</em></p><ul><li>用户空间实现：不需要切换进程到内核态，但会发生阻塞影响整个进程。</li><li>内核空间实现：CPU时间片，分一对一、一对多、多对多（线程池）。</li></ul><p><em>Java线程</em><br>采用宿主机的线程库实现。</p><p><em>虚拟机栈</em><br>Java线程上下文需要保存虚拟机栈，切换的原因一般有：</p><ul><li>GC线程</li><li>CPU用完</li><li>获取锁失败阻塞</li><li>主动等待</li></ul><p><em>JAVA并发的问题</em></p><ul><li>原子性：原子操作（lock、unlock、read、write、load、store、use、assign），锁，CAS</li><li>可见性：final、volatile、synchronized</li><li>有序性：<ul><li>单线程：as-if-serial</li><li>多线程：happens-before（程管V启中终对传）</li></ul></li></ul><p><em>操作系统线程五态模型</em><br><img src="/Pasted%20image%2020230325220625.png"><br>实际上还有阻塞挂起和就绪挂起。</p><p><em>Java线程六态模型</em><br><img src="/Pasted%20image%2020230325220630.png"></p><p><em>创建线程</em></p><ul><li>创建一个类并继承Thread</li><li>创建一个类并实现Runnable，将该类对象作为参数传入Thread的构造器</li><li>创建一个类并实现Callable，使用FutureTask包装该Callable对象成Runnable，传入Thread的构造器</li></ul><h2 id="三大关键字"><a href="#三大关键字" class="headerlink" title="三大关键字"></a>三大关键字</h2><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li>synchronized 关键词是悲观锁、可重入锁、(某些状态下可自旋)、非公平锁、排他锁。</li><li>Lock接口的实现是悲观锁、可重入锁<ul><li>ReentrantLock是排他锁、有公平和非公平两种实现。</li><li>ReentrantReadWriteLock读锁是共享的，写锁是排他的。</li></ul></li><li>JUC原子类是乐观锁，自旋锁（可以认为，自旋操作的实现就是CAS，但乐观锁的实现不只CAS）。</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><em>锁住的对象</em></p><ul><li>普通方法：调用实例对象，底层加ACC_SYNCHRONIZED</li><li>静态方法：Class对象，底层加ACC_SYNCHRONIZED</li><li>同步块：synchonized括号中的对象，底层使用monitorenter和monitorexit字节码。</li></ul><p><em>内存语义</em></p><ul><li>释放对象时写主内存</li><li>获取对象是读主内存（实际上是在写内存时就无效了）</li></ul><p><em>ObjectMonitor对象</em><br><img src="/Pasted%20image%2020230325224306.png"></p><ul><li><code>count</code>计数器</li><li><code>_WaitSet</code></li><li><code>_EntryList</code></li><li><code>_owner</code></li></ul><p><em>wait</em><br>只有在synchronized中才可以调用wait</p><p><em>Java对象头</em><br><img src="/Pasted%20image%2020230325224258.png"></p><ul><li>大小：2或3个字宽（一个字宽为32或64bit）</li></ul><p><em>MarkWord</em><br>32位：<br><img src="/Pasted%20image%2020230325224333.png"><br>64位：<br><img src="/Pasted%20image%2020230325224349.png"></p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p><em>等级</em><br>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p><p><em>无锁（自旋）</em><br>自旋-&gt;适应性自旋（自旋成功率高才自旋，默认10次获取不到锁就阻塞）</p><p><em>轻量级锁</em><br>栈帧上使用LockRecord（displace hdr、owner）记录获得到的锁对象头，步骤：<br><img src="/Pasted%20image%2020230325225005.png"></p><ol><li>确定对象的无锁状态</li><li>创建<code>Lock Record</code></li><li>复制对象头到<code>Lock Record</code>中的<code>displace hdr</code></li><li><strong>CAS</strong>替换对象头成本记录的指针</li></ol><ul><li>判断重入时：重入时复制创建空LockRecord</li><li>CAS失败时：膨胀成重量级锁</li></ul><p><em>偏向锁（JDK15已废除）</em><br>轻量级的CAS还是太麻烦了，使用偏向锁，获取该锁时不需要替换Lock Record，只需要检查对象头中的Thread ID，且线程不会主动释放锁。工作流程：<br>（1）判断是否可偏向（<strong>偏向锁</strong>标识为1 且 <strong>锁标志位</strong> 为 01）。<br>（2）判断其Thread ID是否指向自己，指向自己则直接执行，否则尝试<strong>CAS</strong>替换这个Therad ID：<br>    - CAS成功：获取偏向锁<br>    - CAS失败：判断Thread ID线程是否退出同步块：<br>        - 若退出了，则先将该锁变成无锁状态，然后可以通过CAS<strong>重偏向</strong>。<br>        - 若没退出，则让Thread ID线程将其升级为<strong>轻量级锁</strong>（<strong>撤销</strong>）。</p><p><em>批量重偏向和批量撤销</em><br>批量重偏向：<strong>某个类</strong>的所有对象的锁，锁<strong>撤销（偏向锁-&gt;轻量级）次数</strong>大于20时，认为是有可能最初偏向错了，再对该对象加锁时则<strong>重偏向（偏向锁-&gt;偏向锁）</strong>。<br>批量撤销：<strong>某个类</strong>的所有对象的锁，锁<strong>撤销（偏向锁-&gt;轻量级）次数</strong>大于40时，认为这个类的对象的锁确实要撤销，把该类的所有偏向锁<strong>撤销</strong>，再创建<strong>新对象也默认不可偏向</strong>。</p><div class="note note-primary">            <p>重偏向和升级轻量级是两个对立的行为，通过判断锁的情况来决定如何选择该行为。</p>          </div><p><em>锁消除</em><br>如果编译器认定一个锁只会被单个线程访问（即无<strong>线程逃逸</strong>），那么这个锁就可以被消除，即<strong>同步省略</strong>。</p><p><em>PS：逃逸分析类型</em></p><ul><li>方法逃逸</li><li><strong>线程逃逸</strong></li></ul><p><em>PS：逃逸优化</em></p><ul><li><strong>同步省略</strong></li><li>栈上分配</li><li>标量替换</li></ul><p><em>锁粗化</em><br>连续的加锁操作合并成一个</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>保证<strong>可见性</strong>和<strong>有序性</strong>，不能保证<strong>原子性</strong>。</p><p><em>可见性</em><br>通过写内存的内存语义，写时会直接将工作内存同步到主内存并无效其他线程中的内存。</p><p><em>有序性</em><br>volatile写：前插入storestore内存屏障，后插入storeload内存屏障。<br>volatile读：后插入loadload，loadstore内存屏障。</p><p><em>双重校验锁</em><br>单例模式的健全版</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>保证<strong>可见性</strong>。<br><strong>不可变对象永远是线程安全的。</strong>（只要发生方法逃逸）</p><p><em>重排序规则</em></p><ul><li><strong>禁止编译器</strong>将final的写指令重排序到构造函数外，在写指令<strong>后</strong>插入一个storestore屏障<strong>禁止处理器</strong>重排序。</li><li><strong>禁止编译器</strong>将final的读指令重排序到对对象的读之前，在读指令<strong>前</strong>插入一个loadload屏障<strong>禁止处理器</strong>重排序。</li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><em>概念</em><br>Compare And Swap，可用于无锁编程，底层处理器有相关指令实现。</p><p><em>问题</em></p><ul><li>ABA问题：使用版本号解决<code>AtomicStampedReference</code></li><li>作用对象问题：使用锁或将变量合并，操作后再拆解（<code>AtomicReference</code>）</li><li>循环开销：JVM支持<code>pause</code>指令，允许竞争失败后短暂睡眠，防止空转。</li></ul><p><em>Unsafe类</em><br>底层类，不建议直接使用，有native的CAS方法，支持类、数组、引用、字段的原子更新。</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p><em>lock与synchronized的使用区别</em></p><ul><li>lock更灵活。</li><li>lock可以实现共享锁。</li><li>lock可以被中断，synchronized不能被中断，可能阻塞。</li><li>lock效率相对较低。</li></ul><p><em>lock接口方法</em></p><ul><li><code>lock()</code></li><li><code>lockInterruptibly()</code></li><li><code>tryLock()</code></li><li><code>tryLock(long time,TimeUnit unit)</code></li><li><code>unlock()</code></li><li><code>newCondition()</code></li></ul><p><em>lock接口具体实现</em><br><code>Lock</code>接口的具体实现类，如<code>ReentrantLock</code>都聚合了一个<strong>AQS的子类</strong>，来实现同步。</p><ul><li>AQS(<code>AbstractQueuedSynchronizer</code>)：抽象类，内部实现了状态量和同步队列，提供了共享模式的方法和独占模式的方法。</li><li><code>ReentrantLock</code>中实现了内部抽象类<code>Sync</code>，继承了<code>AQS</code>，对部分方法进行了重写</li></ul><p><em>AQS字段</em></p><ul><li><code>volatile int state</code>表示同步状态</li><li><code>CLH</code>队列实现同步</li><li>内部类Node:<ul><li>记录线程</li><li>Node：prev、next、nextWaiter</li><li>身份（共享、排他）</li><li>模式（CANCELLED取消、SINGAL<strong>后继节点</strong>正在挂起）</li></ul></li></ul><p><em>AQS模板方法</em></p><ul><li><code>acquire(int arg)</code>，被final修饰，<strong>不可被重写</strong>，其中调用的<code>tryAcqure(arg)</code>，<strong>可被子类重写</strong>。</li></ul><p><em>AQS共享模式</em></p><ul><li><code>tryAcquireShared(int)</code>，返回值为int。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p><em>ReentrantLock获取锁</em><br>lock()方法工作流程：</p><ul><li>cas state为1<ul><li>成功则获取锁</li><li>失败则调用<code>acquire</code><ul><li><code>acquire</code>调用重写后的<code>tryAquire(arg)</code></li><li>tryAquire失败则入队：<ul><li><code>addWaiter()</code>方法，其中使用了<code>compareAndSetTail</code>做CAS操作，CAS失败则进入<code>enq()</code>方法做死循环保证节点添加）</li><li><code>acquireQueued()</code>会获取到<code>addWaiter</code>添加队列成功的节点，然后做<strong>死循环</strong>（目的是防止虚假wake up）访问前驱节点，如果前驱节点是头节点，本节点则会尝试获取<code>tryAquire</code>：<ul><li>成功则修改头指针并退出循环</li><li>失败则进入等待</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReentrantLock Method</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))   <br>        <span class="hljs-comment">// CAS 成功，即没有线程持有锁，此时当前线程可直接获取锁，不需要再CAS入队</span><br>        setExclusiveOwnerThread(Thread.currentThread()); <br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// CAS 失败，acquire会调用被重写的tryAquire(arg)再次尝试获取，失败则入队</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//AQS Method</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 此方法会尝试去获取锁</span><br>        <span class="hljs-comment">// 将当前线程加入 CLH 队列中</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Pasted%20image%2020230326135302.png"></p><p><em>ReentrantLock释放锁</em><br>unlock工作流程：</p><ul><li>调用被重写的<code>tryRelease</code>，成功则唤醒后续节点<code>unparkSuccessor</code>：<ul><li>改变头节点waitStatus</li><li>校验后继节点waitStatus</li><li>唤醒后继节点，由后继节点来执行移出头节点等事件</li></ul></li></ul><p><em>ReentrantLock重入实现</em><br>tryAcquire() -&gt; nonfairTryAcquire() -&gt; state++;</p><p><em>公平锁与非公平锁</em><br><img src="/Pasted%20image%2020230326142111.png"><br>ReentrantLock默认非公平实现，也可传true实现公平<br><img src="/Pasted%20image%2020230326142306.png"><br>底层区别在于tryAcuire中CAS state之前判断当前是否有排队。</p><p><em>调用链</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock.lock -&gt; NonfairSync/FairSync.lock -&gt; AQS.acquire -&gt; NonfairSync/FairSync.tryAcquire() -&gt; AQS.acquireQueued(addWaiter());<br></code></pre></td></tr></table></figure><p><em>总结</em><br>AQS实现了队列的主要功能：</p><ul><li>只开放了tryAcquire和tryRelease这样的方法：以供子类来做是否公平的实现，改写内容一般是对state的CAS处理</li><li>不论被重写成什么样，失败后都走的AQS的排队方法，获取者会死循环直到添加成功；释放者也会死循环直到释放成功。</li></ul><p><em>ReentrantReadWriteLock</em><br><img src="/Pasted%20image%2020230326142621.png"><br>使用一个state同时维护读、写状态，将 32 位的整型变量 state 切分成两个部分，高 16 位表示读，低 16 位表示写：<br>[<img src="/Pasted-image-20230203170539.png"></p><p><em>锁降级</em><br>读写锁中的锁降级指的是，<strong>写锁降级成为读锁</strong>。</p><p><em>Condition</em><br><img src="/Pasted%20image%2020230326142914.png"><br>步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Codition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Codition</span>()<br>condition.await()<br>condition.signal()<br>condition.signalAll()<br></code></pre></td></tr></table></figure><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p><em>CountDownLatch</em><br>倒计时器，替代join()，更灵活，信号量通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);  <br>countDownLatch.countDown();<br>countDownLatch.await(); <span class="hljs-comment">// 阻塞线程，等待countdown为0</span><br></code></pre></td></tr></table></figure><p><em>CyclicBarrier</em><br>同步屏障，可添加释放前方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>,function());<br>cyclicBarrier.await(); <span class="hljs-comment">// 子线程已达到屏障</span><br>cyclicBarrier.await(); <span class="hljs-comment">// 主线程已到达屏障</span><br></code></pre></td></tr></table></figure><p><em>Semaphore</em><br>信号量，用于流量控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">20</span>);<br>s.acquire()<br>s.release()<br></code></pre></td></tr></table></figure><p><em>Exchanger</em><br>线程之间交换对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">strA</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;大佬 A 的钥匙&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">strB</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;大佬 B 的钥匙&quot;</span>);<br></code></pre></td></tr></table></figure><p><em>ThreadLocal</em><br>ThreadLocalMap由线程独有，其Entry以ThreadLocal为键，value为值。<br><img src="/Pasted%20image%2020230326143937.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  <br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>  <br>    Object value;<br>    <span class="hljs-comment">//private ThreadLocal referent; 继承字段</span><br>  <br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  <br>        <span class="hljs-built_in">super</span>(k);  <span class="hljs-comment">// referent = k</span><br>        value = v;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意ThreadLocalMap.Entry中：</p><ul><li>key是<strong>弱引用</strong>，因为ThreadLocal过多时会出现内存泄漏，而在强引用下其是不可回收的。</li><li>value是<strong>强引用</strong>，因为value可能还存在其他引用，不可盲目回收，且要避免key还在而value为null的情况。</li></ul><p>因此，需要手动的remove(key)实现资源释放。</p>          </div><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><img src="/Pasted%20image%2020230326145701.png"><br><em>工作流程</em><br><img src="/Pasted%20image%2020230326145908.png"></p><p><em>Executors</em><br>封装了6种方法，对应6种线程池：</p><ul><li>FixedThreadPool：核心线程n，最大线程n</li><li>CachedThreadPool：核心线程0，最大线程无穷，动态回收创建</li><li>SingleThreadExecutor：核心线程1，最大线程1</li><li>WorkStealingPool：任务抢占式执行的线程池</li><li>ScheduledThreadPool：定时线程池</li><li>SingleThreadScheduledExecutor：单核定时线程池</li></ul><div class="note note-primary">            <p>不建议使用Executors，应该使用ThreadPoolExecutor暴露细节。</p>          </div><p><em>ThreadPoolExecutor</em><br><img src="/Pasted%20image%2020230326150521.png"><br><strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>阻塞队列</strong>是限制大小的。<br><strong>存活时间</strong>和<strong>单位</strong>是管理非核心线程的回收的。<br><strong>工厂</strong>管理生成线程策略。<br><strong>处理器</strong>决定饱和策略。</p><p>拒绝策略：</p><ul><li>AbortPolicy (默认策略)：拒绝执行并抛出异常</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy：抛弃阻塞队列头部（最旧）的一个任务，并执行当前任务</li><li>DiscardPolicy：忽略并抛弃当前任务</li></ul><p><em>Executor</em><br>是一个线程池框架<br><img src="/Pasted%20image%2020230326155236.png"><br><img src="/Pasted%20image%2020230326154737.png"></p><p><em>Executors、Executor、ExecutorService</em></p><ul><li>ExecutorService接口继承了Executor接口，加强对线程任务的控制支持，如提供了submit()方法，允许shutdown()等。</li><li>Executors只是一个工具类，用过来生成ExecutorService接口的实现类，不推荐使用。</li></ul><p><em>配置线程池经验</em></p><ul><li>重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>。</li><li>根据线上线下：<ul><li>线上要求高响应速度，调高 <code>corePoolSize</code> 和 <code>maxPoolSize</code></li><li>线下要求高处理速度，调高调整合适的<code>corePoolSize</code>(一般为处理器数量+1)去设置处理任务的核心线程数。</li></ul></li><li>根据任务类型：<ul><li>CPU密集型，设置<code>corePoolSize</code>为CPU数量+1。</li><li>IO密集型，尽可能多的配置核心线程，IO等待时让其他线程占用CPU。</li></ul></li></ul><h1 id="四、JVM"><a href="#四、JVM" class="headerlink" title="四、JVM"></a>四、JVM</h1><h2 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h2><ul><li>基于栈的指令集架构（另一种是基于寄存器的，移植性差）</li><li>生命周期：<ul><li>启动：引导类加载器创建初始类完成。</li><li>退出：Error，exit，操作系统错误。</li></ul></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><em>加载类的过程</em></p><ul><li>加载：二进制字节流 &#x3D;&gt; 方法区运行时数据结构</li><li>链接<ul><li>验证：<ul><li>文件格式验证(文件格式、魔数、长度等)</li><li>元数据验证（继承关系是否合法等）</li><li>字节码验证（方法体是否合法等）</li><li>符号引用验证（引用类型是否存在等）</li></ul></li><li>准备：分配内存，赋默认值</li><li>解析：符号引用转化为直接引用</li></ul></li><li>初始化：<code>&lt;clinit&gt;</code>，该过程会加锁</li></ul><p><em>加载类的来源</em><br>本地、网络、数据库、动态生成等</p><p><em>类加载器分类</em><br>父子关系：<br><img src="/Pasted%20image%2020230326192426.png"><br>实现关系：<br><img src="/Pasted%20image%2020230326192822.png"></p><ul><li>引导类加载器由C、C++编写</li><li>系统类加载器也叫应用程序类加载器AppClassLoader</li><li>底层<code>loadClass()</code>模板方法实现了双亲委派，一般重写<code>findClass()</code>即可。</li></ul><p><em>为什么需要自定义加载器</em><br>隔离加载类、扩展加载源、自定义加载方式（还可防止源码泄漏）</p><p><em>如何自定义加载器</em><br>一般继承URLClassLoader，再重写findClass即可。</p><p><em>两个相同的class对象</em><br>同加载器（在同一个命名空间里）、同完整类名。</p><p><em>双亲委派</em><br>加载类时向上委托，父加载器加载不了时才主动加载，保证了可见性和单一性。</p><p><em>双亲委派机制的破坏</em></p><ul><li>早期的loadClass()方法被重写</li><li>线程上下文加载器：为了实现系统类调用用户类（<strong>引导类加载器</strong>无法找到 SPI 的实现类）</li><li>热替换&#x2F;热部署</li></ul><p><em>线程上下文加载器</em><br>ContextClassLoader其实只是一个概念，是Thread的一个成员变量。如果没有主动设置则默认继承父线程的上下文加载器（默认为System ClassLoader）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-keyword">private</span> ClassLoader contextClassLoader;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContextClassLoader</span><span class="hljs-params">(ClassLoader cl)</span> &#123;<br>       <span class="hljs-comment">// 省略：安全检查</span><br>       contextClassLoader = cl;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> ClassLoader <span class="hljs-title function_">getContextClassLoader</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 省略：安全检查</span><br>       <span class="hljs-keyword">return</span> contextClassLoader;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了能让应用程序访问到这些jar包中的实现类，即用<code>appClassLoarder</code>去加载这些实现类。可以用<code>getContextClassLoader</code>取得当前线程的<code>ClassLoader</code>（即<code>appClassLoarder</code>），然后去加载这些实现类，就能让应用访问到。</p><p><em>Tomcat的类加载器设计</em></p><ul><li>目的：容器不希望它下面的webapps之间能互相访问到</li><li>实现：<ul><li>cataline类加载器：tomcat新建了一个sharedClassLoader。其父加载器类为commonClassLoader，再父加载器类是appClassLoarder，默认情况下，sharedClassLoader和commonClassLoader是同一个urlClassLoader实例。</li><li>app类加载器：对于每个webapp，为其新建一个webappClassLoader，用于加载webapp下面的类。且webappClassLoader加载。</li></ul></li><li>注意：tomcat的ClassLoader没有使用双亲委派，其自身优先加载类，加载不到才委托给父类（java核心类除外）</li></ul><p><em>类主动使用</em><br>使用静态字段、静态方法、生成实例、forName()</p><p><em>数组类加载</em><br>由数组对应的类的类加载器加载。</p><p><em>static与static final</em><br>两者都在堆中，跟随class对象：</p><ul><li>对于基本类型&#x2F;字符串字面量，前者初始化时赋值，后者链接环节赋初值。</li><li>对于引用对象类型，初始化时赋值。</li></ul><p><em>类的卸载前提</em></p><ul><li>类对象全回收</li><li>类的引用全回收</li><li>类的加载器被回收</li></ul><p><em>沙箱安全机制</em><br>JDK1.0<br><img src="/Pasted%20image%2020230327001401.png"><br>JDK1.1<br><img src="/Pasted%20image%2020230327001408.png"><br>JDK1.2<br><img src="/Pasted%20image%2020230327001421.png"><br>JDK1.6<br><img src="/Pasted%20image%2020230327001429.png"></p><p><em>Java9特性</em></p><ul><li>URLClassLoader &#x3D;&gt; BuiltinClassLoader</li><li>ExtClassLoader &#x3D;&gt; PlatformClassLoader</li><li>SystemClassLoader由java实现</li><li>双亲委派机制现在可以跨级直接委托</li></ul><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="/Pasted%20image%2020230326193259.png"></p><p><em>JVM系统线程</em><br>虚拟机线程（管理、调度线程）、GC线程、编译线程、周期任务线程、信号调度线程。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><em>PC寄存器</em><br>线程私有，执行native方法时为Undefined。</p><p><em>虚拟机栈</em><br>由栈帧构成，栈帧由：</p><ul><li>局部变量表（slot数组，一个slot占32位，一个64位的变量占2个slot，可复用）。</li><li>操作数栈（栈顶缓存技术:<strong>将栈顶元素全部缓存在物理CPU的寄存器中</strong>，降低内存读写消耗）</li><li>方法返回地址（返回调用该方法的指令的下一条指令；异常退出时返回到异常表的target，且不返回值）</li><li>动态链接（指向方法区中本类的Vtable）</li></ul><p><em>Vtable</em></p><ul><li>非虚方法：静态链接对应早期绑定，编译期确定方法</li><li>虚方法：动态链接对应晚期绑定，运行期确定方法</li><li>绑定：符号引用变成直接引用的过程</li></ul><p><em>本地方法栈</em><br>native修饰的方法，每个线程只有一个。HotSpot中，虚拟机栈与本地方法栈是一体的。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><em>堆结构</em><br>JDK7.0：新生区（Eden区和Survivor区8:1:1）、养老区、永久区<br>JDK8.0：新生区、养老区、元空间</p><p><em>对象分配原则</em></p><ul><li>小对象分配：Eden出生，MinorGC后Survivor，15次后进Old。</li><li>大对象分配：Old。</li><li>动态对象年龄分配：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保（-XX:HandlerPromotionFailure，已经废除）：开启后MinorGC前检查老年代是否还有可用的<strong>连续空间</strong>：若有，则GC；若没有，则根据历次GC后移动到老年代的平均对象大小评估是否可以冒险GC，评估失败或冒险失败后FullGC。</li></ul><p><em>TLAB</em><br>JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。</p><p><em>GC分类</em></p><ul><li>Minor&#x2F;Young</li><li>Major&#x2F;Old，绝大多数(CMS除外)会同时触发YoungGC</li><li>Full，注意FullGC是可以回收方法区的。</li><li>Mixed，G1回收期特有的混合回收。</li></ul><p><em>堆外对象？</em><br>栈上分配、标量替换都未实现，所以对象都在堆上。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><em>存储内容</em></p><ol><li>类信息，包括类本身、字段、方法的所有信息。</li><li>运行时常量池，静态常量池（class文件中）加载后就变成了运行时常量池（方法区中），符号引用被转化为真实地址。</li><li>字符串常量池，逻辑上在方法区，<strong>实际上在堆中</strong>。</li></ol><blockquote><p>JDK1.7时，字符串常量池和静态变量就从永久代移动到了堆中，后续又取消了永久代，变成元空间。</p></blockquote><p><em>元空间</em><br>元空间可以使用直接内存。</p><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ol><li>执行类、父类、接口的加载、初始化</li><li>内存分配</li><li>对象准备（赋默认值）</li><li>设置对象头</li><li>init初始化（赋显示初值、构造器最后执行）</li></ol><p><img src="/Pasted%20image%2020230326230516.png"></p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><em>解释器</em><br>字节码 &#x3D;&gt; 机器码<br>HotSpotVM中，解释器由Interpreter模块和Code模块构成：</p><ul><li>Interpreter模块：实现了解释器的核心功能，将字节码翻译为机器码</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><p><em>编译器</em><br>前端编译器AOT：java代码 &#x3D;&gt; 字节码<br>后端编译器JIT：字节码 &#x3D;&gt; 机器码</p><p><em>JIT编译器分类</em><br>C1：方法内联（把引用的函数编译到引用处）、去虚拟化（对唯一的实现类进行内联）、冗余消除（折叠不执行的代码）。<br>C2：标量替换、栈上分配、同步消除。</p><p><em>JIT热点代码</em><br>计数器：方法调用计数器+回边计数器<br>热点衰退：GC时进行，半衰</p><h2 id="StringPool"><a href="#StringPool" class="headerlink" title="StringPool"></a>StringPool</h2><p>底层是HashTable（默认大小：JDK6&#x3D;1009；JDK7&#x3D;60013），JDK6及以前在永久代，JDK7后在堆中。</p><p><em>intern()</em><br>JDK6中调用intern，将其复制一份在pool中并返回；<br>JDK7中调用intern，pool中创建堆该string的引用。</p><p>G1中String回收<strong>去重</strong><br>将候选string放入hashtable，发现重复时则将引用改成hashtable中的string并释放本string。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p><em>finalize()</em><br>Object原生方法，一个对象只会执行一次。</p><p><em>垃圾回收算法</em></p><ul><li>标记：引用计数算法和可达性算法（root包括栈和方法区引用，同步锁对象，脏表上的对象等）。<ul><li>判断对象是否可直接回收，finalize()方法可能复活，需要交付给F-Queue队列执行finalize方法，执行后GC再扫描该队列看是否可触及。</li></ul></li><li>回收：标记-清除算法、复制算法、标记-压缩算法、增量收集（G1）</li><li>分配内存方法：指针碰撞法、空闲列表法</li></ul><p><em>应用</em><br>复制算法一般在YoungGC中，迁移到Survivor。<br>标记压缩算法一般在OldGC中。<br>标记清除算法一般在CMS或G1的GC中，因为其需要并发标记清除。<br>增量收集只在G1中。</p><p><em>System.gc()</em><br>不一定立刻生效</p><p><em>STW</em><br>枚举GCRoots和修正标记结果时必须STW。</p><p><em>GCRoots</em><br>枚举出整个“GC Roots”是非常麻烦的，在<strong>HotSpot</strong>的解决方案中，使用了一组称为<strong>OopMap</strong>的数据结构来存放这些对象的引用。即当用户线程暂停下来之后，并不需要一个不漏的检查完所有的执行上下文和全局的引用位置。而是直接通过OopMap来获取栈上或寄存器里哪里有GC管理的指针（引用指针）。</p><p><em>安全点</em><br>如果每次执行一条字节码指令都去生成一个<strong>OopMap</strong>那就必须消耗大量额外的存储空间，因此HotSpot并没有让每条指令都生成<strong>OopMap</strong>，而是只在特定的位置生成OopMap，这个位置就被称为安全点（safe point）。<br>放置的安全点不能太多，当然也不能太少。放置安全点的位置一般是以“是否具有让程序长时间执行特征”为标准进行选定，当线程运行到安全点时，其状态是确定的。不同虚拟机对于自己safe point的实现不一定一样，对于HotSpot：</p><ul><li>解释器：每一段字节码的边界都可以作为一个safe point，因为对于解释器来说找到完整的执行状态实在是一件非常容易的事。</li><li>JIT：对于来说则是以每个方法临返回前，以及所有的非 counted loop（可数循环） 循环回跳之前，放置一个safe point。并且在每个safepoint生成一些“调试符号信息”，方便VM找到需要的运行状态。</li></ul><p><em>中断方式</em></p><ul><li>抢占式（让线程在安全点时中断）：几乎没有虚拟机采用这种实现</li><li>主动式（线程在安全的主动询问）：主流的实现方式，由于询问也有开销，所以安全点不宜过多。</li></ul><p><em>安全区域</em><br>扩大的安全点（某个不会不会发生引用关系变化的区域）例如：线程被挂起，或者线程执行JNI函数等等。</p><p><em>引用</em><br>强&#x2F;软&#x2F;弱&#x2F;虚。软引用空间不足时回收，弱引用GC则回收，虚引用关联一个引用队列，可以获取其回收通知。<br>终结器引用，GC时，终结器引用进入F-QUEUE，Finalizer线程执行队列中对象的finalize()方法。</p><p><em>并行与并发</em><br>并行（Parallel）：<strong>多条GC线程</strong>同时执行GC。<br>串行（Serial）：<strong>单GC线程</strong>执行GC。<br>并发（Concurrent）：<strong>用户线程与GC线程</strong>交替执行。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><em>分类</em><br>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。<br>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。<br>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。<br>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p><p><em>性能指标</em><br>主要关注<strong>吞吐量</strong>和<strong>响应速度</strong></p><p><em>经典垃圾回收器</em><br><img src="/Pasted%20image%2020230326233958.png"></p><p><em>Serial GC&#x2F;Serial Old GC</em><br>单线程、STW、复制&#x2F;标记压缩算法（JDK8下的默认Client）</p><p><em>ParNew</em><br>多线程版Serial GC</p><p><em>Parallel Scavenge&#x2F;Parallel Old</em><br>多线程、STW、复制&#x2F;标记压缩算法，追求吞吐量（JDK8下的默认Server）</p><p><em>CMS（JDK9中已过时）</em><br>追求低延迟。<br><img src="/Pasted%20image%2020230326234445.png"></p><ul><li>单&#x2F;多线程，重新标记时使用多线程，低延迟。</li><li>因为并发清理，所以使用了标记清除算法，存在内存碎片</li><li>三色标记法，修正时不考虑浮动垃圾，若A新增了指向B的指针，则把A标记为灰色。</li></ul><p><em>G1</em><br>延迟可控的情况下吞吐量，一般设置延迟和最大堆内存即可。<br><strong>现在互联网的项目，基本都是使用G1。</strong></p><p><em>G1分区</em><br>H区装大对象，Region之间使用空闲链表，Region内部使用指针压缩。<br><img src="/Pasted%20image%2020230326234923.png"></p><p><em>Rset</em><br>记忆集，避免全表扫描的关键，也用于其他分代GC。脏表是其具体实现，一个表512B，基于卡精度。<br>在发生引用关系变化时插入内存屏障（与volatile内存屏障是不同的概念），实现AOP的作用。<br><img src="/Pasted%20image%2020230326235238.png"></p><p><em>G1回收模式</em><br>Young GC：<br><img src="/Pasted%20image%2020230326235543.png"><br><strong>年轻代空间不足触发</strong>，回收Eden和Survivor区，STW，复制算法。</p><p>Mixed GC：</p><ul><li>并发标记<ul><li>STW，Root扫描使可达的年轻代晋级，然后触发一次YGC</li><li>并发标记，扫描区域回收价值</li><li>再次标记，三色标记法，B被取消引用时，将B标记为灰色</li><li>排序回收区域</li><li>并发清理（清除全为垃圾的Region）</li></ul></li><li>混合回收<ul><li>分8次回收，每次回收的流程与YoungGC类似（整理垃圾碎片）</li></ul></li></ul><p>Full GC：<br>复制算法时没有空的内存分段，回退到FullGC</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p><em>优化步骤</em><br>监控 &#x3D;&gt; 分析 &#x3D;&gt; 优化</p><p><em>指标</em><br>吞吐量、并发数、内存占用</p><p><em>监控依据</em></p><ul><li>日志</li><li>Exception堆栈</li><li>线程快照</li></ul><p><em>常用命令</em></p><ul><li>jps，查看java进程</li><li>jstat，查看统计信息</li><li>jinfo，JVM参数</li><li>jmap，内存dump文件</li><li>jstack，线程快照</li></ul><p><em>GUI</em></p><ul><li>Arthas：在线远程排查，需要在服务端开启arthas，客户端对其进行连接；<ul><li>启动：<code>java -jar arthas-boot.jar</code>，选择进程后开启监控面板；</li><li><code>thread 1</code>打印线程id为1的栈；</li></ul></li><li>JProfiler：有样本采集（每隔一段时间快照）和重构模式（侵入式统计）两种模式。</li></ul><p><em>火焰图</em><br>对栈的采样，横轴不代表时间，仅仅将顶部方法按字母排列，但宽度更宽的表示采样中出现的频率越多，可能是性能瓶颈。</p><p><em>运行参数</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">//大小设置<br>-Xms&lt;size&gt; 设置初始 Java 堆大小  <br>-Xmx&lt;size&gt; 设置最大 Java 堆大小  <br>-Xss&lt;size&gt; 设置 Java 线程堆栈大小<br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8  <br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br><br>//快照<br>-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件<br><br>//GC选择<br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务<br>//GC信息<br>-XX:+PrintGC &lt;==&gt; -verbose:gc 打印简要日志信息<br>-XX:+TraceClassLoading 监控类的加载<br></code></pre></td></tr></table></figure><p><em>GC日志</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br><br>[GC(原因)][GC回收器：年轻代回收前内存占用-&gt;年轻代回收后内存占用（区域总内存）]总内存变化，时间][时间：用户时间，核心时间，实际时间]<br></code></pre></td></tr></table></figure><p><em>JVM调优实际案例</em></p><ul><li>合理配置JVM参数，如栈(-xss)、堆内存(-xms,-xmx)，选择合适的GC回收器。（IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</li><li>项目应用中，就适当调大了young区，因为接收到的大多数产线数据处理后即回收。</li><li>-XX:MetaspaceSize，初始元空间大小，建议设置大一点，以免项目启动时为了调整元空间大小频繁Full GC。</li></ul><p><em>其他概念</em></p><ul><li>浅堆：对象本身的内存</li><li>保留集：对象及其可访问的对象</li><li>深堆：保留集中对象的内存</li><li>对象实际大小：深堆</li><li>支配树：如果所有指向B的支配路径都经过A，则A支配B，如果A离B最近，则A是B的直接支配者。</li><li>内存泄漏：有不用或不常用的垃圾无法回收</li><li>内存溢出：内存泄漏常常导致内存溢出</li></ul><h1 id="五、IO"><a href="#五、IO" class="headerlink" title="五、IO"></a>五、IO</h1>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java复习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习</title>
    <link href="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、硬件结构"><a href="#一、硬件结构" class="headerlink" title="一、硬件结构"></a>一、硬件结构</h1><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p><em>图灵机</em><br>栈式读取操作数和操作指令并执行</p><p><em>冯诺依曼模型</em><br>组成：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp"></p><p><em>内存</em><br>以字节byte为单位的存储空间，从0开始编号。</p><p><em>CPU</em><br>包括控制单元、寄存器（包括通用寄存器、程序计数器、指令寄存器）、逻辑运算单元。32位CPU一次计算4字节，64位CPU一次计算8字节，对于小数字而言，64位和32位的运算速度接近。</p><p><em>总线</em><br>当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：</p><ul><li>首先要通过「地址总线」来指定内存的地址；</li><li>然后通过「控制总线」控制是读或写命令；</li><li>最后通过「数据总线」来传输数据；</li></ul><p><em>线路位宽</em></p><ul><li>地址总线的条数（线路位宽）决定了指定一个内存地址需要在地址总线上进行几次传输。</li><li>CPU的位宽应该不小于线路位宽，否则其无法操作所有内存。</li><li>32位CPU最大操作4GB内存，64位CPU最大寻址空间为<code>2^64</code>。</li></ul><p><em>程序执行过程</em></p><ol><li>程序计数器：存储了指令的内存地址（硬件位宽指CPU的位宽，软件位宽指的是指令的位宽，两者相等才能正常运作）。</li><li>控制单元：操作地址总线指定指令的内存地址，通过数据总线获取指令，将指令存储到指令寄存器中，程序计数器自增。</li><li>CPU：分析指令寄存器中指令：计算类将给逻辑运算单元处理；读写类交给控制单元处理。</li></ol><p><em>指令周期</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/CPU%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.webp"><br>获取指令-&gt;指令译码(控制单元完成)-&gt;执行指令(算数逻辑单元完成)-&gt;数据回写</p><p><em>指令执行速度</em><br>时钟周期是CPU执行时间的基本单位，执行时间：<br><code>CPU执行时间 = 指令数 * CPI(平均每个指令的周期数) * 时钟周期</code></p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><em>结构</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/CPU-Cache.webp"></p><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.webp"><br>访问内存数据时，逐层查看是否有缓存。</p><p><em>内存</em><br>DRAM （_Dynamic Random Access Memory_，动态随机存取存储器），基于电容，需要不断刷新才能存储数据。</p><p><em>SSD&#x2F;HDD硬盘</em></p><ul><li>SSD固体硬盘，结构与内存类似，比HDD快。</li><li>HHD机械硬盘，传统结构，速度很慢。</li></ul><h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>CPU Cache是内存体系中的组成部分，但硬件上属于CPU。<br><em>Cache与内存的映射</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%B1%82%E6%A8%A1%E6%98%A0%E5%B0%84%E7%AD%96%E7%95%A5.webp"><br>内存块(Block)会按照地址求模映射到Cache Line上。</p><p><em>结构</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%9B%B4%E6%8E%A5Cache%E6%98%A0%E5%B0%84.webp"></p><ul><li>有效位：本记录是否有效；</li><li>组标记：记录本CacheLine当前记录的Block；</li><li>实际数据：内存块的数据缓存。</li></ul><blockquote><p>CPU读取数据时，需要以块为单位将内存加载到缓存，但不需要读取整个块，所以还会指定偏移量。</p></blockquote><p><em>如何提高CPU速度？</em></p><ul><li>提高数据缓存命中率：尽量访问连续内存，如顺序访问数组。</li><li>提高指令缓存命中率：CPU有分支预测器，如果某条件判断的跳转大概率成立，则会缓存跳转后的相关指令。</li><li>提高多核CPU命中率：一个用户线程绑定在一个CPU核心上，防止切换CPU对缓存命中率的影响。</li></ul><h4 id="CPU-Cache一致性"><a href="#CPU-Cache一致性" class="headerlink" title="CPU Cache一致性"></a>CPU Cache一致性</h4><p><em>两种同步方案</em></p><ul><li>写直达(Write Through)：把数据同时写入内存和 Cache 中</li><li>写回(Write Back)：只把数据写入Cache Block中（标记为脏块），当其被替换时，才写回内存。</li></ul><p><em>缓存一致性问题</em><br>CPU的不同核心同时对相同的内存块进行操作。</p><p><em>需要解决的问题</em><br>要解决缓存一致性，需要解决两个问题：</p><ul><li>写传播（可见性）：某CPU写内存后对其他CPU可见。</li><li>事物串行化（有序性）：其他CPU收到的写传播顺序与原CPU写入顺序一致。</li></ul><p><em>总线嗅探</em><br>某CPU修改内存数据后，通过总线广播到其他CPU，实现了<strong>写传播</strong>。</p><p><em>MESI协议</em><br>概念：Cache Line具有4种状态（Modified、Exclusive、Shared、Invalidated）。<br>工作原理：</p><ul><li>某CPU核心读取内存后为Cache Line独占模式</li><li>此时其他CPU也读取相同内存，对应的Cache Line都变成共享模式。</li><li>某CPU要对共享模式的Cache Line写入时，将其他CPU的Cache Line标记为无效，然后再更新。</li></ul><p><em>伪共享问题</em></p><ul><li>定义：由于Cache是以块为单位读取的，会出现两个线程操作同一个块中不同的变量却导致彼此反复失效的情况，严重消耗性能。</li><li>解决：为变量后面填充空白，使2个相邻变量其在内存中位于不同的Block。</li></ul><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p><em>十进制与二进制</em><br>十进制转二进制：小数使用乘2取整法，可能会产生无限循环的二进制表达，但计算机位数有限，造成了精度损失。</p><p><em>浮点数的存储</em><br>默认整数部分为1，且省略。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/float.webp"></p><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>磁盘调度算法：</p><ul><li>先来先服务：寻找最早请求的扫描点，效率低下；</li><li>最短寻道时间优先算法：寻找距离当前磁头最近的扫描点，折返的无效路径较多；</li><li>扫描算法：往一个方向访问完到终点后转头，效率高，但中间部分扫描频率更高；</li><li>循环扫描算法：总是从同一个方向开始扫描，解决扫描算法响应频率不均匀的问题，但效率会低一些；</li><li>LOOK与C-LOOK算法：优化了扫描和循环扫描算法，即不需要扫描到终点，只扫描到最远处的请求即转向。</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-SCAN%E7%AE%97%E6%B3%95.webp"></p><h2 id="流水线数据冲突"><a href="#流水线数据冲突" class="headerlink" title="流水线数据冲突"></a>流水线数据冲突</h2><p><em>流水线数据冲突包括哪些分类</em><br>在计算机体系结构和指令级并行处理中，流水线数据冲突通常分为以下几种主要分类：</p><ol><li><strong>结构冲突（Structural Hazard）</strong>：<ul><li>结构冲突是由于硬件资源的冲突引起的。例如，多个指令需要访问同一硬件单元（如内存或寄存器文件）时，会发生结构冲突。这通常需要硬件设计来解决，如多端口内存或多写寄存器文件。</li></ul></li><li><strong>数据冒险（Data Hazard）</strong>：<ul><li>数据冒险分为以下三种类型：<ul><li><strong>写后读冲突（Read After Write, RAW）</strong>：当一个指令在之前的指令写入数据之后尝试读取相同数据时，会发生RAW冲突。这需要在流水线中引入暂停或数据前推等技术来解决。</li><li><strong>写后写冲突（Write After Write, WAW）</strong>：当两个或多个指令尝试写入相同的寄存器或内存位置时，会发生WAW冲突。通常只允许一个写入操作完成，而其他写入操作需要等待。</li><li><strong>读后写冲突（Write After Read, WAR）</strong>：当一个指令尝试在之前的指令读取相同数据之后写入相同数据时，会发生WAR冲突。这也需要通过暂停或数据前推来解决。</li></ul></li></ul></li><li><strong>控制冲突（Control Hazard）</strong>： <ul><li>控制冲突是由于分支指令的执行和分支结果的未知性引起的。当流水线中的指令序列受到条件分支指令的影响，需要等待分支结果解决这种冲突。解决控制冲突的方法包括分支预测和延迟槽等。</li></ul></li><li><strong>资源冲突（Resource Hazard）</strong>： <ul><li>资源冲突指的是多个指令需要同时访问特定的资源，但该资源在某一时刻只能被一个指令占用。这种情况通常需要硬件设计来解决，例如使用多个功能部件（如整数单元、浮点单元）以允许并行执行。</li></ul></li></ol><h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Kernel_Layout.webp"><br>操作系统内核是应用连接硬件设备的桥梁。</p><p><em>内存空间</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/systemcall.webp"><br>操作系统将内存分为了<strong>用户空间</strong>和<strong>系统空间</strong>，<strong>当程序使用用户空间时</strong>，称程序在<strong>用户态</strong>执行，当程序使用内核空间时，程序在<strong>内核态</strong>执行。</p><p><em>Linux 内核设计的理念</em></p><ul><li>MultiTask，多任务。支持并发、并行。</li><li>SMP，对称多处理。即每个CPU地位相等。</li><li>ELF，可执行文件链接格式。</li><li>Monolithic Kernel，宏内核。即系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li></ul><p><em>Window 内核设计的理念</em></p><ul><li>MultiTask和SMP</li><li>PE，可移植执行文件。</li><li>Mix Kernel，混合内核。即内核中有一个微内核，其他模块在这个微内核的基础上搭建，一起组成整个内核。</li></ul><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><em>概念</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/72ab76ba697e470b8ceb14d5fc5688d9.webp"></p><ul><li>程序所使用的内存地址叫做虚拟内存地址</li><li>硬件所使用的空间地址叫做物理内存地址</li><li><strong>MMU</strong>（内存管理单元负责虚拟内存地址和物理内存地址的映射）</li></ul><p><em>映射方式</em></p><ul><li>内存分段</li><li>内存分页</li></ul><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/a9ed979e2ed8414f9828767592aadc21.webp"></p><ul><li>段选择因子：确定了段描述符，可以得到段的元信息。</li><li>段内偏移量：确定了地址在段内的偏移量</li></ul><p><em>内存分段的问题</em></p><ul><li>存在外部内存碎片：<ul><li>分段做到了按需求分配内存，<strong>不会出现内部内存碎片</strong>。</li><li>段之间<strong>存在外部内存碎片</strong>。可以使用内存交换，通过挂起后唤醒程序的方式调整。</li></ul></li><li>内存交换效率低：内存空间不足时，需要将段换出到硬盘上，频繁的swap会导致效率低下。</li></ul><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/7884f4d8db4949f7a5bb4bbd0f452609.webp"><br>当进程访问<strong>页表</strong>中查不到的虚拟地址时，产生<strong>缺页异常</strong>，会进入物理地址分配物理内存并更新<strong>页表</strong>。</p><p><em>缺页异常</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.webp"></p><p><em>内存分页的问题</em></p><ul><li>存在<strong>内部内部碎片</strong><ul><li>页与页之间紧密排列，<strong>不会出现外部碎片</strong>。</li><li>页是最小的内存分配单元，可能造成浪费，即<strong>内部内存碎片</strong>。</li></ul></li><li>内存交换效率高：内存空间不足时，每次只会把其他运行进程中最近没有被使用的少数内存页面换出到硬盘上。</li></ul><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>简单分页会导致页表过于庞大。因此引入多级页表。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/19296e249b2240c29f9c52be70f611d5.webp"></p><ul><li>多级页表中，一级页表映射了全部虚拟地址。</li><li>对于没有使用的一级页表，可以不创建其对应的二级页表，从而实现页表空间的节省。</li></ul><p><em>64位系统</em></p><ul><li>全局页目录项 PGD（Page Global Directory）；</li><li>上层页目录项 PUD（Page Upper Directory）；</li><li>中间页目录项 PMD（Page Middle Directory）；</li><li>页表项 PTE（Page Table Entry）；</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.webp"></p><p><em>TLB</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/a3cdf27646b24614a64cfc5d7ccffa35.webp"><br>为了解决多级页表访问速度慢的问题，加入了TLB（Translation Lookaside Buffer），常称为页表缓存。CPU寻址时，先搜索TLB，找不到再搜索页表。</p><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>将内存先划分成有意义的段，然后按页分配。地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/8904fb89ae0c49c4b0f2f7b5a0a7b099.webp"></p><h3 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h3><p><em>Intel处理器内存</em><br>历史问题：先有段式内存管理，后续的页式管理就只能基于这个段式上做映射。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/bc0aaaf379fc4bc8882efd94b9052b64.webp"></p><p><em>Linux内存</em><br>页式管理：为了屏蔽段式管理，每个段都是0-&gt;4GB的整个虚拟空间。</p><p><em>虚拟地址空间分布</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.webp"><br>所有进程虚拟地址空间中的内核空间关联了相同的物理内存：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/48403193b7354e618bf336892886bcff.webp"></p><p><em>用户空间的段分布</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.webp"></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><em>malloc分配内存</em><br>malloc函数有两种方式申请<strong>虚拟内存</strong>，申请后访问时出现缺页中断才会申请<strong>物理内存</strong>：</p><ul><li>brk()从堆中分配内存</li><li>mmap()在文件映射区中分配内存</li></ul><p>malloc(1)</p><p><em>free()释放内存</em></p><ul><li>brk()申请的内存：free释放内存时，会将内存缓存在内存池中以便复用，进程退出后才释放。</li><li>mmap()申请的内存：free释放内存时直接归还资源给操作系统。</li><li>内存块头信息：每个内存块有16Byte记录头信息，因此free时知道需要释放多少内存。</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/cb6e3ce4532ff0a6bfd60fe3e52a806e.webp"></p><p><em>mmap()的缺点</em><br>mmap会对操作系统频繁的申请、释放内存。频繁的缺页中断和切换运行态，对CPU造成了较大的消耗。</p><p><em>brk()的缺点</em><br>free释放的内存不归还操作系统，造成内存碎片。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/75edee0cb75450e7987a8a482b975bda.webp"></p><p><em>申请超过物理内存的虚拟内存</em></p><ul><li>32位：进程理论最大申请3GB虚拟内存，超出则申请失败。</li><li>64位：不会受理论最大空间限制。如果访问超出物理内存的虚拟内存，要看系统有没有 Swap 分区：<ul><li>如果没有 Swap 分区，OOM杀死进程。</li><li>如果有 Swap 分区，正常运行。</li></ul></li></ul><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p><em>申请内存过程</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/2f61b0822b3c4a359f99770231981b07.webp"></p><p><em>内存阈值</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/166bc9f5b7c545d89f1e36ab8dd772cf.webp"></p><ul><li>超过页低阈值时开始异步回收</li><li>超过最小阈值时直接回收</li></ul><p><em>回收哪些内存</em></p><ul><li>文件页：直接释放，需要时再从磁盘读即可</li><li>匿名页：Swap机制，将内存换入磁盘</li></ul><p><em>回收算法</em><br>使用了<strong>LRU算法</strong>，维护了active和inactive两个双向链表，优先淘汰inactive。</p><p><em>回收性能消耗</em><br>文件页回收时脏页的写回、匿名页回收时的Swap操作都有较大的内存消耗。</p><p><em>回收性能优化</em></p><ul><li>调整文件页和匿名页的回收倾向，如多回收文件页，这样干净的文件页就不需要磁盘IO。</li><li>尽早触发kswapd异步回收内存，如调整页低阈值。</li></ul><p><em>NUMA架构</em></p><ul><li>一致性存储访问UMA架构：所有CPU共享硬件（总线、内存、IO等），导致CPU数量变多时，每个CPU资源变少。</li><li>非一致性存储访问NUMA架构：CPU分组，每组为一个Node，一个Node独立拥有硬件资源，访问远端资源时比本地内存耗时。</li></ul><p><em>NUMA架构下的垃圾回收</em><br>垃圾回收策略zone_reclaim_mode：</p><ul><li>0（默认）：回收本地内存前，在其他Node中寻找空闲内存。</li><li>1：只回收本地内存。</li><li>2：只回收本地内存，回收脏页。</li><li>4：只回收本地内存，回收匿名页</li></ul><p><em>OOM</em><br>OOM会对进程打分，因素有：</p><ul><li>内存使用的物理内存页面</li><li>OOM分数<code>oom_score_adj</code>，默认为0，范围-1000~1000。</li></ul><p>为了防止进程被OOM杀死，可调节其<code>oom_score_adj</code>为-1000，但不建议这样做。</p><h2 id="页面置换调度算法"><a href="#页面置换调度算法" class="headerlink" title="页面置换调度算法"></a>页面置换调度算法</h2><p><em>页面置换</em><br>页面置换算法指的是：解决当出现缺页异常，需调入新页面而内存已满时，如何选择被置换的物理页面的问题。为了实现页面置换算法，页表项有一些相关字段：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.webp"></p><ul><li>状态位：是否是有效页</li><li>访问字段：一段时间内的被访问次数</li><li>修改位：是否为脏页</li><li>硬盘地址：页在硬盘上的地址</li></ul><p><em>最佳页面置换算法</em><br>置换在「未来」最长时间不访问的页面。是理想状态，但无法实现。</p><p><em>先进先出置换算法</em><br>选择在内存驻留时间很长的页面进行中置换。性能较差。</p><p><em>最近最久未使用的置换算法</em><br>LRU算法，理论上可行，但链表更新的时间复杂度较高，不常用。</p><p><em>时钟页面置换算法</em><br>与LRU类似，但更方便实现。优先置换访问频率低的页面，否则对页的访问频率计数降级。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.webp"></p><p><em>最不常用算法</em><br>LRU算法，当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。这种方法需要对计数做热点衰减以实现模拟近期的频率。</p><h3 id="Linux-内存页面置换"><a href="#Linux-内存页面置换" class="headerlink" title="Linux 内存页面置换"></a>Linux 内存页面置换</h3><p>Linux使用了双LRU链表实现页面置换算法，并对其做了一些优化。<br><em>预读失效和缓存污染</em><br>内存预读的目的是提高效率，但其可能造成预读失效和缓存勿污染，导致命中率下降。</p><p><em>预读失效</em></p><ul><li>定义：使用预读提前加载进来的页并没有被访问。</li><li>解决：没有被真正使用的页应该被视为冷数据：<ul><li>Linux使用了活跃LRU链表和非活跃LRU链表。</li><li>Mysql将LRU链表分为了young区和old区</li></ul></li></ul><p><em>缓存污染</em></p><ul><li>定义：只使用了一次的页占用热数据。</li><li>解决：降低热数据的门槛：<ul><li>Linux只有数据被访问第二次时才加入活跃链表。</li><li>Mysql只有数据两次访问时间之差<strong>超过1秒</strong>时才加入young区</li></ul></li></ul><h1 id="四、进程管理"><a href="#四、进程管理" class="headerlink" title="四、进程管理"></a>四、进程管理</h1><h2 id="进程、线程与调度"><a href="#进程、线程与调度" class="headerlink" title="进程、线程与调度"></a>进程、线程与调度</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><em>进程七态模型</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.webp"><br>为了避免阻塞的进程浪费物理内存，将其换出到硬盘，运行时再换回。</p><p><em>进程控制块PCB组成</em></p><ul><li>进程描述信息（pid，userid）</li><li>进程控制和管理信息（状态、优先级）</li><li>资源分配（内存地址空间信息）</li><li>CPU寄存信息</li></ul><p><em>进程控制块PCB组织</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.webp"></p><p><em>进程的控制</em><br>进程的控制主要包括<strong>创建、终止、阻塞、唤醒</strong>。具体的过程总结下来就是：</p><ul><li>查找&#x2F;创建PCB</li><li>判断PCB状态，根据指令改变进程状态。</li><li>申请&#x2F;释放资源</li><li>删除&#x2F;移动PCB</li></ul><p><em>进程上下文切换</em><br>进程阻塞或时间片用完等情况时需要切换线程，此时会把CPU上下文（寄存器和程序计数器）保存到PCB中，下次运行时恢复。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><em>定义</em><br>线程是进程当中的一条执行流程。</p><p><em>进程与线程对比</em></p><ul><li>进程是资源分配的单位，线程是CPU调度的单位。</li><li>线程信息只有寄存器和栈，创建、释放、上下文切换更快速。</li><li>线程之间通过同一个进程的内存实现数据共享。</li></ul><p><em>CPU分配？</em></p><ul><li>进程是CPU分配资源的基本单位</li><li>线程是CPU调度的基本单位</li><li>CPU时间片不是先分给进程然后再由进程分给进程下的线程的，CPU时间片是直接分配给线程的，线程拿到CPU时间片就能执行了。</li></ul><p><em>线程实现</em></p><ul><li>用户线程：多对一，用户空间实现线程管理TCB</li><li>内核线程：一对一，线程TCB由操作系统管理</li><li>轻量级进程：内核支持的用户线程，与内核线程一对一</li></ul><p><em>各种线程实现的注意点</em></p><ul><li>用户线程不需要切换内核态调度，但可能阻塞饿死其他线程。内核线程相反。</li><li>用户线程可以在轻量级进程上再实现M：N的线程对应模型。</li></ul><p><em>一个进程可以创建多少线程</em><br>进程需要为线程在虚拟内存空间中创建栈空间：</p><ul><li>32位：主要受线程的栈空间大小和<strong>用户态虚拟内存空间</strong>（Linux下为3G）大小的限制。</li><li>64位：虚拟内存足够，主要受系统参数和性能的限制。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><em>协程</em></p><ul><li>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li><li>一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。</li></ul><blockquote><p>协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的。一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。</p></blockquote><p><em>协程的作用</em><br>不被操作系统内核所管理，而完全是由程序所控制，没有内核态的开销，<strong>协程的开销远远小于线程的开销。</strong></p><p><em>线程与协程之间的区别？</em></p><ul><li>协程仅仅是一个<strong>特殊的函数</strong>，协程与进程和线程不是一个维度的。</li><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程。</li><li>线程进程都是同步机制，而协程则是异步。</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li><li>线程是抢占式，而协程是非抢占式的，所以<strong>需要用户自己释放使用权来切换到其他协程</strong>，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li><li>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源，协程是组织好的代码流程，协程需要线程来承载运行，线程是协程的资源，但协程不会直接使用线程，协程直接利用的是执行器(Interceptor)，执行器可以关联任意线程或线程池，可以使当前线程，UI线程，或新建新程。</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><em>需要调度的情况</em></p><ul><li>线程就绪态 -&gt; 运行态</li><li>线程运行态 -&gt; 阻塞态</li><li>线程运行态 -&gt; 结束态</li><li>其他优先级等因素导致的调度</li></ul><p><em>时钟中断</em><br>以某个时间频率检查进程状态，考虑是否调度CPU资源。<br>根据是否使用时钟中断，调度算法分：</p><ul><li>非抢占式调度算法：让进程运行到阻塞或退出再调度。</li><li>抢占式调度算法：触发时钟中断，然后将CPU资源给调度程序，执行调度程序后再给进程分配CPU资源。</li></ul><p><em>调度相关指标</em></p><ul><li>CPU利用率：CPU工作时间&#x2F;总时间</li><li>系统吞吐量：单位时间CPU完成的进程数量</li><li>进程周转时间：运行+阻塞+等待的时间</li><li>等待时间：进程处于就绪态的时间</li><li>响应时间：用户请求到返回的时间</li></ul><p><em>调度算法</em><br>针对长、短作业：</p><ul><li>先来先服务FCFS：对长作业有利，但短作业等待时间太久。</li><li>最短作业优先SJF：对短作业有利，但长作业饿死。</li><li>高响应比优先HRRN：平衡长、短作业。但要求服务时间无法预估，其无法实现。</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.webp"></p><ul><li>时间片轮转RR：时间上公平。但时间片太短会造成上下文切换频繁资源浪费，太长则短作业浪费CPU资源。</li></ul><p>引入优先级：</p><ul><li>最高优先级HPF：优先级分静态优先级和动态优先级（进程优先级随等待时间变化），处理分非抢占式和抢占式。但低优先级一直得不到执行。</li><li>多级反馈队列MFQ：设置多级的就绪队列，高优先级作业获得执行后若没结束会降低优先级，低优先级作业能获得更多的时间片。兼顾了长短作业，短作业在前面的队列即完成执行，长作业也可以获得更长的运行时间。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.webp"></li></ul><h2 id="Linux-CPU调度"><a href="#Linux-CPU调度" class="headerlink" title="Linux CPU调度"></a>Linux CPU调度</h2><p>Linux的CPU调度方式类似多级反馈队列算法：分实时作业和普通作业，实现优先级；根据进程已经获得的执行时间动态调节其优先级，保证公平。<br><em>线程调度</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%BB%BB%E5%8A%A1.webp"><br>所有线程在Linux调度器中都是一个task_struct。</p><p><em>任务分类</em></p><ul><li>实时任务：优先级0-99范围。</li><li>普通任务：优先级100-129范围。</li></ul><p><em>调度类</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%B0%83%E5%BA%A6%E7%B1%BB.webp"></p><p><em>调度策略</em><br>DeadLine和RT调度器用于实时任务，调度策略：</p><ul><li>SCHED_DEADLINE：按照deadline优先级调度。</li><li>SCHED_FIFO：优先级高的先服务，相同优先级先到先服务。</li><li>SCHED_RR：高优先级的任务可以抢夺低优先级任务的时间，相同优先级的任务轮流执行。</li></ul><p>Fair调度类用于普通任务，调度策略：</p><ul><li>SCHED_NORMAL：普通任务使用的调度策略。</li><li>SCHED_BATCH：后台任务的调度策略。</li></ul><p><em>完全公平调度</em><br>CFS调度器会通过计算vruntime保证任务公平，优先执行vruntime少的任务：<br>vruntime +&#x3D; 实际运行时间delta_exec * NICE_0_LOAD&#x2F;权重</p><p><em>CPU运行队列</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/CPU%E9%98%9F%E5%88%97.webp"><br>优先级如下：Deadline &gt; Realtime &gt; Fair</p><p><em>默认优先级</em><br>默认情况下，任务都是普通任务，调度类为Fair，若想要调整任务优先级，可以启动时指定nice值。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%85%88%E7%BA%A7.webp"></p><p><em>中断</em><br>从调度的角度，中断是一种抢占性的任务调度行为；<br>从程序的角度，中断是一种异步的事件处理机制，操作系统收到了中断请求，会打断其他进程的运行，并执行中断处理程序。</p><p><em>软中断</em><br>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p><ul><li>上半部分处理硬件请求（硬中断）：短暂关闭中断请求，立即执行中断处理程序。</li><li>下半部分由内核触发（软中断）：使用内核线程ksoftirqd延迟处理中断回调函数。</li></ul><h2 id="进程之间的通讯方式"><a href="#进程之间的通讯方式" class="headerlink" title="进程之间的通讯方式"></a>进程之间的通讯方式</h2><p><em>管道</em></p><ul><li>单向传输</li><li>命名管道<code>mkfifo</code>保存在文件中、匿名管道保存在内存中。本质上就是内存中的一串缓存。</li><li>会阻塞直到管道内容被读取</li><li>匿名管道只能在父子关系的进程中通过共享文件描述符的方式通讯，eg:shell中使用<code>A|B</code>：</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/8-%E7%AE%A1%E9%81%93-pipe-shell.webp"></p><p><em>消息队列</em></p><ul><li>异步，但通讯不及时</li><li>大小有限制，本质上是内核中的消息链表</li><li>存在内核态切换开销</li></ul><p><em>共享内存</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.webp"></p><p><em>信号量</em></p><ul><li>整形计数器，支持P、V操作。<ul><li>P操作：-1，发现≥0后执行，否则阻塞。</li><li>V操作：+1，发现≤0后唤醒阻塞线程。</li></ul></li><li>初始化为1可实现互斥（先P后V），初始化为0可实现序列化（先V后P）</li></ul><p><em>信号</em><br><code>kill -?</code><br>进程间<strong>唯一的异步通讯机制</strong>，进程对接受到的信号可执行默认操作，也可以捕捉处理信号。（SIGKILL和SIGSTOP无法被捕捉忽略，即强制结束或中断）</p><blockquote><p>线程崩溃了，进程会崩溃吗？<br>不一定，崩溃本身是系统通过信号通知进程执行退出的过程。如Java对部分信号如SIGSEGV进行了捕获，不会直接退出整个JVM。</p></blockquote><p><em>Socket</em><br>实现跨网络和主机的进程通讯，系统调用参数有：</p><ul><li>协议：IPV4、IPV6或本地等（本地socket不需要绑定ip和端口，而是绑定本地文件，效率比网络socket高）。</li><li>类型：UDP、TCP等。</li><li>协议：默认0，已经废弃。</li></ul><h2 id="线程冲突与死锁"><a href="#线程冲突与死锁" class="headerlink" title="线程冲突与死锁"></a>线程冲突与死锁</h2><p><em>互斥与同步的定义</em></p><ul><li>互斥：临界区代码是互斥的，只允许一个线程在临界区执行。</li><li>同步：并发线程在某些时间点要形成互相等待与互通消息。</li></ul><p><em>互斥量与信号量的区别</em></p><ul><li>互斥量用于线程的互斥，信号量用于线程的同步。也就是互斥与同步的区别。<ul><li>互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性，但不保证访问顺序。</li><li>同步：在互斥的基础上（大多数情况下），通过其它机制实现访问者对资源的有序访问。</li></ul></li><li>互斥量值只能为0&#x2F;1，信号量值可以为非负整数：一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。</li><li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li></ul><p><em>互斥同步的实现</em></p><ul><li>锁：实现互斥</li><li>信号量：init 1实现互斥，init 0实现同步</li></ul><p><em>死锁的条件</em><br>只有同时满足以下4个条件才能形成死锁。</p><ul><li>互斥条件：唯一资源</li><li>不可剥夺：不会主动释放</li><li>持有等待：等待另一个唯一资源</li><li>环路等待：形成了环路等待</li></ul><p><em>排查死锁</em><br><code>jstack</code>可排查死锁</p><p><em>避免死锁</em><br>一般会破坏环路等待，即编码时使资源的获取有序。</p><h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p><em>生产者消费者问题</em><br>通知是在做V操作后发现信号量≤0时触发的，需要控制互斥的同时，实现对生产者，消费者的通知。</p><ul><li>一个互斥信号量实现访问互斥</li><li>一个同步信号量初始化为0实现notEmpty通知（通知消费者消费，生产者每次投递时++，消费者消费时–）</li><li>一个同步信号量初始化为n实现notFull通知（通知生产者投递，生产者每次投递时–，消费者消费时++）</li></ul><p><em>哲学家就餐问题</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/23-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E6%A8%A1%E5%9E%8B.webp"><br>哲学家需要同时拿起左右两侧的叉子才吃面，如何防止死锁：</p><ul><li>一个互斥信号量代表当前是否有人拿起筷子：只有没人拿起筷子时，才允许拿筷子，效率较低。（全局互斥）</li><li>五个互斥信号量代表叉子：偶数先拿左边，奇数先拿右边。（打破环形等待）</li><li>五个互斥信号量代表人：只有两个邻居都没有拿起筷子时，才允许拿筷子。（原子性获取资源）</li></ul><p><em>读者-写者问题</em><br>为了保证读者和写者都不被饿死，读者和写者应该在同一个队列中等待，实现FIFO：</p><ul><li>一个普通量记录读者数量</li><li>一个互斥信号量控制对读者数量的修改</li><li>一个互斥信号量控制写者写操作</li><li><strong>一个互斥信号量保证写者排队时，后续读者阻塞</strong>。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>银行家算法是资源分配层面上避免死锁的著名方法。<br><em>条件</em></p><ul><li>系统当前可利用资源向量Avaliable</li><li>进程最大需求矩阵Max</li><li>进程当前分配矩阵Allocate</li><li>进程需求矩阵Need（进程需求矩阵 &#x3D; 进程最大需求矩阵-进程当前分配矩阵）</li></ul><p><em>银行家算法</em></p><ul><li>进程请求资源大于其最大需求资源时出现错误，不分配</li><li>进程请求资源大于可利用资源时，不分配</li><li>否则，可以尝试分配，执行安全性算法。</li></ul><p><em>安全性算法</em><br>安全性算法的目的就是找到一个安全执行序列，难点在于如何判断找不到该安全序列。</p><ol><li>第一轮：先假定一个序列，逐个判断进程是否能被执行。</li><li>第二轮：第一轮中能够被执行的进程添加到安全序列中，再次遍历该序列，这次只针对第一轮中判断无法被执行的进程判断。</li><li>如果第二轮中发现了新的可被执行进程，则循环第二轮；如果某轮发现剩余进程都无法执行，则说明找不到安全序列。</li></ol><h1 id="五、文件系统"><a href="#五、文件系统" class="headerlink" title="五、文件系统"></a>五、文件系统</h1><h2 id="文件系统组成和基本使用"><a href="#文件系统组成和基本使用" class="headerlink" title="文件系统组成和基本使用"></a>文件系统组成和基本使用</h2><p><em>概念</em></p><ul><li>文件：普通的文件，其数据块中记录文件数据，保存在硬盘中。</li><li>目录：特殊的文件，其数据块中记录文件信息（文件名和文件inode号，并使用一个hash表维护inode号和块号），保存在硬盘中。</li><li>目录项：内核维护的数据结构，缓存在内存中，其既可以表示目录，也可以表示文件。</li></ul><p><em>硬链接与软连接</em><br>硬链接：是<strong>多个目录项中的「索引节点」指针指向一个文件</strong>，也就是指向同一个inode。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.webp"></p><p>软连接：创建独立的inode，可以跨文件系统。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%BD%AF%E9%93%BE%E6%8E%A5.webp"></p><p><em>基本结构</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.webp"></p><ul><li>超级块：存储文件系统信息，文件系统挂载时进入内存。</li><li>索引节点：存储索引节点，文件被访问时进入内存。</li></ul><blockquote><p>用户进程对文件的基本操作单位是<strong>字节</strong>，文件系统的基本操作单位是<strong>数据块</strong>，文件系统则屏蔽了这种操作差异。</p></blockquote><p><em>虚拟文件系统</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp"><br>操作系统需要为用户提供统一的文件接口，根据存储位置不同，分为：</p><ul><li>磁盘文件系统（如Ext 2）</li><li>内存文件系统（如<code>/proc</code>）</li><li>网络文件系统（如NFS）</li></ul><p><em>文件的使用</em><br><code>open()</code>、<code>write()</code>、<code>read()</code>。<br>每个进程会维护一个打开文件表，每一项通过一个文件描述符，记录：</p><ul><li>文件指针</li><li>打开计数器</li><li>文件磁盘位置</li><li>访问权限</li></ul><h2 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h2><p><em>连续空间存储方式</em><br>文件头需要指定起始块位置和长度。会造成<strong>磁盘空间碎片</strong>和<strong>文件长度不易扩展</strong>的问题。</p><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.webp"></p><p><em>非连续空间存放方式</em></p><ul><li><p>隐式链表：每个数据块用一个指针存放下一块的位置。缺点为必须遍历访问；稳定性差，若一个指针丢失则文件不可用。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.webp"></p></li><li><p>显式链表：使用<strong>文件分配表</strong>，显示的记录文件使用的磁盘块链，遍历到-1说明结束。缺点为由于文件分配表存在于内存中，其不适用大磁盘。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.webp"></p></li><li><p>索引方式：为每个文件创建<strong>索引数据块</strong>，相当于文件的数据块目录。当文件过大一个索引块不够用时，可以使用<strong>链式索引块</strong>或<strong>多级索引块</strong>。</p></li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.webp"><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.webp"><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.webp"></p><p><em>文件存储方式对比</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.webp"></p><h4 id="Unix文件实现"><a href="#Unix文件实现" class="headerlink" title="Unix文件实现"></a>Unix文件实现</h4><p>Linux Ext 2&#x2F;3文件系统方案如下，其适用于不同大小的文件索引需求：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Unix-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.webp"></p><h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p><em>空闲表法</em><br>为所有空闲空间建立一张表，空间消耗大且查询效率较低。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.webp"></p><p><em>空闲链表法</em><br>主存只需要保存一个指针，简单，但无法随机访问，查询效率低。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.webp"></p><p><em>位图法</em><br>使用bitmap记录磁盘块的使用情况，Linux中采用的方案。位图存储在磁盘中。</p><p><em>文件系统结构</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%9D%97%E7%BB%84.webp"></p><blockquote><p>块组0类似数据库设计中表空间的第一个页的作用。</p></blockquote><h2 id="文件缓存与I-x2F-O"><a href="#文件缓存与I-x2F-O" class="headerlink" title="文件缓存与I&#x2F;O"></a>文件缓存与I&#x2F;O</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/72568a29816fa9b505f15edac68adee2.webp"><br><em>概念</em></p><ul><li>Page Cache是操作系统中的内存缓存，其由多个page组成。</li><li>Swap out时换出的内存Swap Cached也可以被视为Page Cache。</li><li>Page Cache用于缓存文件的页数据，与文件系统同级；buffer cache用于缓存块设备（如磁盘）的块数据，与驱动程序同级；现在两者已经几乎被统一了，统称为<code>Page Cache</code>。</li></ul><p><em>预读机制</em><br>read时，内核调用了readhead。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/ae8252378169c8c14b8b9907983f7d8b-20230309235145646.webp"></p><p><em>一致性与可靠性保证</em><br>Linux 下以两种方式实现文件一致性：</p><ul><li>写穿(Write Through)：同步写入磁盘，保证一致性。</li><li>写回(Write Back)：默认方案，定时任务将Page Cache刷回脏数据块，无法保证一致性。</li></ul><p><em>文件I&#x2F;O</em></p><ul><li>缓冲与非缓冲 I&#x2F;O：根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲 I&#x2F;O。</li><li>直接与非直接I&#x2F;O：根据是「否利用操作系统的缓存（Page Cache）」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O。直接I&#x2F;O不会发生内核缓存和用户程序之间数据复制。</li><li>阻塞与非阻塞I&#x2F;O：见后文I&#x2F;O模型。</li></ul><h1 id="六、设备管理"><a href="#六、设备管理" class="headerlink" title="六、设备管理"></a>六、设备管理</h1><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230409194607.png"><br><em>概念</em></p><ul><li>每个设备都有一个叫<strong>设备控制器（Device Control）</strong>。</li><li>控制器是有三类寄存器：<ul><li>状态寄存器（Status Register）：命令执行状态</li><li>命令寄存器（Command Register）：具体命令</li><li>数据寄存器（Data Register）：命令参数</li></ul></li><li>按照数据存在位置可分为两大类：<ul><li>块设备（Block Device）：硬盘等数据保存在块中的设备</li><li>字符设备（Character Device）：鼠标等数据只以字符形式在数据流中存在的设备。</li></ul></li><li>按通讯方式可以分两大类：<ul><li>端口I&#x2F;O：每个寄存器分配一个端口</li><li>内存映射：将寄存器映射到内存空间</li></ul></li></ul><p><em>I&#x2F;O控制方式</em></p><ul><li>轮询等待：CPU轮询寄存器</li><li>中断机制：包括硬中断、软中断</li></ul><p><em>设备驱动程序</em><br>设备驱动程序会提供<strong>统一的接口</strong>给操作系统，它会及时<strong>响应控制器发来的中断请求</strong>，并根据这个中断的类型调用响应的<strong>中断处理程序</strong>进行处理。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%B8%AD%E6%96%AD%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.webp"></p><p><em>块设备管理</em><br>为了屏蔽不同块设备差异，Linux通过统一的<strong>通用块层</strong>来管理块设备。通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，其向上提供标准接口，向下实现I&#x2F;O调度和管理。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.webp"></p><p><em>键盘敲入字母后，发生了什么？</em></p><ul><li>键盘控制器扫描到数据，将其缓冲到寄存器中并发起<strong>中断请求</strong>。</li><li>CPU收到中断请求，保存当前CPU上下文，<strong>调用键盘的中断处理程序</strong>。</li><li>中断处理程序<strong>读取寄存器缓冲区数据并识别处理</strong>，将识别到的字符放入显示设备的<strong>读缓冲区队列</strong>。</li><li>显示设备将<strong>读缓冲区队列</strong>数据放入<strong>写缓冲区队列</strong>，然后写入到显示设备的<strong>寄存器数据缓冲区</strong>。</li><li><strong>恢复被中断的进程上下文</strong>。</li></ul><h1 id="七、网络系统"><a href="#七、网络系统" class="headerlink" title="七、网络系统"></a>七、网络系统</h1><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p><strong>直接内存访问</strong>(Direct Memory Access)：将I&#x2F;O设备与内存间的数据传输工作交给DMA控制器。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/DRM-I_O-%E8%BF%87%E7%A8%8B.webp"></p><h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><ul><li><p>传统文件传输<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.webp"><br>发生了4次状态切换和4次拷贝。</p></li><li><p>mmap+write</p></li></ul><p><img src="/mmap%20+%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.webp"><br>发生了4次状态切换和3次拷贝。</p><ul><li>sendfile</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.webp"><br>发生了2次状态切换和3次拷贝。</p><ul><li>sendfile(网卡支持SG-DMA时)</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.webp"><br>发送了2次状态切换和2次拷贝。</p><h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><p><em>内核缓冲区</em><br>内核缓冲区本质上是page cache，零拷贝中使用到了这个技术。但对于过大的文件（GB级别），使用零拷贝会过度占用page cache。因此，<strong>传输大文件时不应该使用零拷贝技术</strong>。</p><p><em>大文件传输方案</em><br>在高并发的场景下，针对大文件的传输的方式，应该使用 <strong>「异步 I&#x2F;O + 直接 I&#x2F;O」</strong> 来替代零拷贝技术：</p><ul><li>直接 I&#x2F;O 绕过了 PageCache</li><li>异步 I&#x2F;O 避免了直接 I&#x2F;O效率较慢的阻塞</li></ul><p><em>总结</em></p><ul><li>小文件用零拷贝技术</li><li>大文件用异步I&#x2F;O+直接I&#x2F;O技术</li></ul><h2 id="Unix-I-x2F-O模型"><a href="#Unix-I-x2F-O模型" class="headerlink" title="Unix I&#x2F;O模型"></a>Unix I&#x2F;O模型</h2><h3 id="IO阶段"><a href="#IO阶段" class="headerlink" title="IO阶段"></a>IO阶段</h3><p>一个输入操作通常包括<strong>两个阶段</strong>:</p><ol><li>等待数据准备</li><li>等待从内核向进程复制数据</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><em>同步IO</em></p><ul><li>阻塞式I&#x2F;O(<code>recvfrom</code>)</li><li>非阻塞式I&#x2F;O(<code>recvfrom</code>)</li><li>多路复用I&#x2F;O(<code>select</code>或<code>poll</code>+<code>recvfrom</code>)</li><li>信号驱动式I&#x2F;O(<code>sigaction</code>+<code>recvfrom</code>)</li></ul><p><em>异步IO</em></p><ul><li>异步I&#x2F;O(<code>aio_read</code>)</li></ul><p><em>文件、网络I&#x2F;O</em></p><ul><li>多路复用I&#x2F;O模型中的<strong>select等方法</strong>主要针对socket的读写，是网络I&#x2F;O模型。</li><li>其他I&#x2F;O模型既可以用于网络I&#x2F;O，又可以用于文件I&#x2F;O。</li></ul><h4 id="阻塞式-I-x2F-O"><a href="#阻塞式-I-x2F-O" class="headerlink" title="阻塞式 I&#x2F;O"></a>阻塞式 I&#x2F;O</h4><p>应用调用<code>recvfrom</code>，被阻塞，直到数据复制到应用进程缓冲区中才返回。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213143753.png"><br>阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。</p><h4 id="非阻塞式I-x2F-O"><a href="#非阻塞式I-x2F-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h4><p>应用进程不断的执行<code>recvfrom</code>来获知 I&#x2F;O 是否完成，这种方式称为轮询(<code>polling</code>)。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213143817.png"><br>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><h4 id="多路复用I-x2F-O"><a href="#多路复用I-x2F-O" class="headerlink" title="多路复用I&#x2F;O"></a>多路复用I&#x2F;O</h4><ol><li>使用<code>select</code>或者<code>poll</code>等待数据（<strong>支持阻塞和非阻塞</strong>），并且可以<strong>等待多个套接字</strong>中的任何一个变为可读，当某一个套接字可读时返回。</li><li>使用<code>recvfrom</code>把数据从内核复制到进程中。</li></ol><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150145.png"><br>I&#x2F;O多路复用本质上仍然是<strong>阻塞IO</strong>，只不过其将阻塞等待数据准备的过程交给了操作系统进行监听，且一次可以注册多个socket，从而使单个进程具有处理多个I&#x2F;O事件的能力。</p><h4 id="信号驱动I-x2F-O"><a href="#信号驱动I-x2F-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h4><ol><li>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回(非阻塞)。</li><li>内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。</li></ol><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150246.png"></p><h4 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h4><ol><li>应用进行 aio_read 系统调用立即返回。</li><li>内核会在所有操作完成之后向应用进程发送信号。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150315.png"></li></ol><h3 id="I-x2F-O模型比较"><a href="#I-x2F-O模型比较" class="headerlink" title="I&#x2F;O模型比较"></a>I&#x2F;O模型比较</h3><h4 id="阻塞、非阻塞、同步、非同步"><a href="#阻塞、非阻塞、同步、非同步" class="headerlink" title="阻塞、非阻塞、同步、非同步"></a>阻塞、非阻塞、同步、非同步</h4><p><em>阻塞的概念</em><br>阻塞是一般指，应用程序调用某系统函数后，是否需要等待操作系统准备好资源。</p><p><em>IO场景</em><br>具体到IO场景，等待分「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程，做出了以下分类。</p><p><em>阻塞与非阻塞</em></p><ul><li>强调的是应用行为，即在等待函数执行结果时的行为，如果一直阻塞等待则是阻塞的，如果直接返回了当前的状态则是非阻塞的。</li><li>阻塞IO与非阻塞IO：讨论的是第一阶段是否需要阻塞，即应用程序是否等待资源准备好。</li></ul><p><em>同步与异步</em></p><ul><li>强调的是通讯机制，应用执行异步函数时直接返回（异步肯定是非阻塞的），执行完毕后通知应用结果。</li><li>同步IO与异步IO：讨论的是第二阶段是否需要阻塞，即应用程序是否等待资源拷贝到用户空间内存。</li></ul><p><em>阻塞socket与非阻塞socket</em><br>首先明确，socket本身只是一个文件描述符，执行函数时会根据其模式判断执行方式。</p><ul><li>Windows和Linux，创建<code>socket</code>都是阻塞模式的；</li><li>Linux中,可以在创建<code>socket</code>时直接将它设置为非阻塞模式；</li></ul><p><em>accept&#x2F;connect&#x2F;recv&#x2F;read&#x2F;send&#x2F;write</em><br>在网络I&#x2F;O中，这些函数根据socket的模式决定是否阻塞等待资源准备好。</p><ul><li>其中，recv&#x2F;read等待的资源是应用程序接受缓冲区。</li><li>其中，send&#x2F;write等待的资源是内核缓存区，如果缓冲区满了且在非阻塞状态会返回发送失败。</li></ul><p><em>select&#x2F;poll&#x2F;epoll</em><br>这些函数始终是<strong>阻塞函数</strong>，可以设置超时时间实现<strong>类似</strong>非阻塞的状态。</p><h4 id="五大I-x2F-O模型比较"><a href="#五大I-x2F-O模型比较" class="headerlink" title="五大I&#x2F;O模型比较"></a>五大I&#x2F;O模型比较</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150509.png"><br>这些I&#x2F;O模型描述的是一次I&#x2F;O行为的过程，而一个网络应用需要处理大量不同类型的Socket，故会使用多种I&#x2F;O模型组合的架构。</p><h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><h4 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h4><p>基于阻塞I&#x2F;O。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230405144258.png"></p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>基于阻塞I&#x2F;O，但节省了进程创建销毁的开销。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230405144507.png"></p><h4 id="网络I-x2F-O多路复用"><a href="#网络I-x2F-O多路复用" class="headerlink" title="网络I&#x2F;O多路复用"></a>网络I&#x2F;O多路复用</h4><p>之前的方法在进行网络I&#x2F;O时都需要至少一个线程维护一个socket，造成了大量的浪费，I&#x2F;O多路复用使用一个线程监听多个socket上的事件，并对其逐一处理。</p><h5 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h5><p><em>过程</em></p><ul><li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select&#x2F;poll 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生。</li><li>内核<strong>遍历</strong>检查发现事件后，将该Socket标记，并<strong>拷贝</strong>回用户态。</li><li>用户态再<strong>遍历</strong>找到可读、可写的事件并处理。</li></ul><p><em>select</em><br>使用bitmap存储文件描述符集合，只能监听1024个socket。</p><p><em>poll</em><br>使用链表存储文件描述符集合，突破了1024个，但仍然受系统限制。</p><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p><em>过程</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/epoll.webp"></p><ul><li>epoll在为应用在内核中维护一个<strong>文件描述符</strong>红黑树，用户需要新增加socket时，只需要调用<code>epoll_ctl()</code>即可，不再需要拷贝整个集合。</li><li>epoll使用了一个链表记录就绪事件，当用户调用<code>epoll_wait()</code>时，只会复制就绪链表中的socket到用户态进行处理。</li></ul><p><em>触发模式</em></p><ul><li>LT 水平触发：进程调用epoll_wait()，当有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，<strong>支持阻塞I&#x2F;0和非阻塞I&#x2F;0</strong>，是默认的触发模式。</li><li>ET 边缘触发：进程调用epoll_wait()，服务器端只会从 epoll_wait 中苏醒一次，只支持<strong>非阻塞I&#x2F;O</strong>。</li></ul><p><em>触发模式对比</em></p><ul><li>LT是默认的触发模式；</li><li>ET模式因为要循环读完所有数据后要正常返回而不是阻塞，所以只支持非阻塞I&#x2F;O；</li><li>ET模式因为epoll_wait苏醒的次数少，效率更高。</li></ul><h3 id="I-x2F-O复用模型对比"><a href="#I-x2F-O复用模型对比" class="headerlink" title="I&#x2F;O复用模型对比"></a>I&#x2F;O复用模型对比</h3><ul><li>select实时性更高，一致性更好</li><li>poll无最大描述符限制</li><li>epoll处理大量文件描述符时最好</li></ul><h2 id="高性能网络模式"><a href="#高性能网络模式" class="headerlink" title="高性能网络模式"></a>高性能网络模式</h2><p>基于I&#x2F;O多路复用模型的特性，在应用程序中实现高性能的网络模式，主要有Reactor、Proactor模型。</p><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>非阻塞同步网络模式，组成有Reactor、Acceptor、Handler。<br><em>单Reactor单线程</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.webp"></p><ul><li>说明：Reactor通过select监听事件，根据监听到的事件类型分发给acceptor或handler</li><li>缺点：无法充分利用CPU。</li><li>应用：Redis中使用的方案。</li></ul><p><em>单Reactor多线程</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp"></p><ul><li>说明：普通多线程模型中每个线程需要负责一个socket，Reactor中多线程只是完成业务处理，Socket的维护都交给了Reactor对象。</li><li>缺点：单Reactor容易成为并发时的性能瓶颈。</li></ul><p><em>多Reactor多线程</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp"></p><ul><li>说明：不再由一个Reactor对象负责所有Socket管理，而是由主Reactor负责监听Accptor事件，子Reactor负责业务处理。</li><li>应用：Netty中使用的方案。</li></ul><h3 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h3><p>异步网络模式。使用了异步I&#x2F;O技术，但在Linux下目前不完善，Window支持较好。<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Proactor.webp"></p><h3 id="网络模式对比"><a href="#网络模式对比" class="headerlink" title="网络模式对比"></a>网络模式对比</h3><ul><li>Reactor 是非阻塞<strong>同步网络模式</strong>，感知的是就绪可读写事件。</li><li>Proactor 是<strong>异步网络模式</strong>， 感知的是已完成的读写事件。</li></ul><h1 id="八、性能指标"><a href="#八、性能指标" class="headerlink" title="八、性能指标"></a>八、性能指标</h1><p><em>性能指标</em></p><ul><li>带宽：b&#x2F;s</li><li>延时：s</li><li>吞吐率：B&#x2F;s</li><li>PPS：包&#x2F;s</li></ul><p><em>查看配置</em></p><ul><li>网络配置：<code>ifconfig</code>、<code>ip</code></li><li>socket信息：<code>netstat</code>、<code>ss</code></li><li>吞吐率和PPS：<code>sar -n</code></li><li>连通性和延时：<code>ping</code></li></ul><p><em>查看日志</em><br>原则：尽量不要使用<code>cat</code>，应该使用<code>less</code>查看。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统常见问题</title>
    <link href="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><em>进程</em></p><ul><li>进程是程序一次动态执行的过程，是<strong>程序运行的基本单位</strong>。</li><li>每个进程都有自己的独立内存空间，不同进程通过<strong>进程间通信</strong>来通信。</li><li>进程占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、页表、文件句柄等）比较大，但相对比较稳定安全。</li></ul><p><em>线程</em></p><ul><li>线程又叫做轻量级进程，是CPU调度的最小单位。</li><li>线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</li></ul><p><em>协程</em></p><ul><li>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</li><li>一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。</li></ul><blockquote><p>协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的。一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。</p></blockquote><p><em>线程和进程之间的区别？</em></p><ul><li><strong>进程是资源分配的单位，线程是CPU调度的单位。</strong></li><li><strong>线程信息只有寄存器和栈，创建、释放、上下文切换更快速。</strong></li><li>一个进程可以有多个线程，但至少有一个线程。</li><li>线程之间通过同一个进程的内存实现数据共享。</li><li>线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</li></ul><p><em>线程与协程之间的区别？</em></p><ul><li>协程仅仅是一个<strong>特殊的函数</strong>，协程与进程和线程不是一个维度的。</li><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程。</li><li>线程进程都是同步机制，而协程则是异步。</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li><li>线程是抢占式，而<strong>协程是非抢占式</strong>的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li><li>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源，协程是组织好的代码流程，协程需要线程来承载运行，线程是协程的资源，但协程不会直接使用线程，协程直接利用的是执行器(Interceptor)，执行器可以关联任意线程或线程池，可以使当前线程，UI线程，或新建新程。</li></ul><p><em>上下文切换区别？</em></p><ul><li><strong>进程的切换者是操作系统</strong>，切换内容包括<strong>页全局目录</strong>、<strong>内核栈和硬件上下文</strong>。切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。</li><li><strong>线程的切换者是操作系统</strong>，切换内容包括<strong>内核栈和硬件上下文</strong>。切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。</li><li><strong>协程的切换者是用户</strong>，协程的切换内容是<strong>硬件上下文</strong>。切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。</li></ul><p><em>CPU分配？</em></p><ul><li>进程是CPU分配资源的基本单位</li><li>线程是CPU调度的基本单位</li><li>CPU时间片不是先分给进程然后再由进程分给进程下的线程的，CPU时间片是直接分配给线程的，线程拿到CPU时间片就能执行了。</li></ul><p><em>线程的实现</em></p><ul><li>用户线程：多对一，用户空间实现线程管理TCB</li><li>内核线程：一对一，线程TCB由操作系统管理</li><li>轻量级进程：内核支持的用户线程，与内核线程一对一</li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul><li>先来先服务FCFS：对长作业有利，但短作业等待时间太久。</li><li>最短作业优先SJF：对短作业有利，但长作业饿死。</li><li>高响应比优先HRRN：平衡长、短作业。但要求服务时间无法预估，其无法实现。</li><li>时间片轮转RR：时间上公平。但时间片太短会造成上下文切换频繁资源浪费，太长则短作业浪费CPU资源。</li><li>最高优先级HPF：优先级分静态优先级和动态优先级（进程优先级随等待时间变化），处理分非抢占式和抢占式。但低优先级一直得不到执行。</li><li>多级反馈队列MFQ：设置多级的就绪队列，高优先级作业获得执行后若没结束会降低优先级，低优先级作业能获得更多的时间片。兼顾了长短作业，短作业在前面的队列即完成执行，长作业也可以获得更长的运行时间。</li></ul><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.webp"></p><h2 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h2><p><em>进程之间通讯的方式？</em></p><ul><li>管道：单向管道、双向管道等，会阻塞直到被读取<ul><li>命名管道：使用<code>mkfifo</code>，保存在<strong>文件</strong>中。</li><li>匿名管道：只能在父子关系的进程中通过共享文件描述符的方式通讯，保存在<strong>内存</strong>中。</li></ul></li><li>消息队列：异步，但通讯不及时，需要内核开销，本质上是内核中的消息链表。</li><li>共享内存：两进程共享一篇物理空间</li><li>信号：进程间<strong>唯一的异步通讯机制</strong>，进程对接受到的信号可执行默认操作，也可以捕捉处理信号，如<code>kill -?</code></li><li>信号量：整形计数器，支持P、V操作。<ul><li>P操作：先-1，发现≥0后执行，否则阻塞。</li><li>V操作：先+1，发现≤0后唤醒阻塞线程。</li><li>初始化为1可实现互斥（先P后V），初始化为0可实现同步（先V后P）</li></ul></li><li>Socket：实现跨网络和主机的进程通讯，系统调用参数有：<ul><li>协议：IPV4、IPV6或本地等（本地socket不需要绑定ip和端口，而是绑定本地文件，效率比网络socket高）。</li><li>类型：UDP、TCP等。</li></ul></li></ul><h2 id="互斥与同步"><a href="#互斥与同步" class="headerlink" title="互斥与同步"></a>互斥与同步</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><em>定义</em></p><ul><li>互斥：临界区代码是互斥的，只允许一个线程在临界区执行，着重于不能同时执行。</li><li>同步：并发线程在某些时间点要形成互相等待与互通消息，着重于执行的先后关系。</li></ul><p><em>互斥同步的实现</em></p><ul><li>锁：实现互斥</li><li>信号量：init 1实现互斥，init 0实现同步</li></ul><p><em>死锁的条件</em><br>只有同时满足以下4个条件才能形成死锁。</p><ul><li>互斥条件：唯一资源</li><li>不可剥夺：不会主动释放</li><li>持有等待：等待另一个唯一资源</li><li>环路等待：形成了环路等待</li></ul><p><em>互斥量与信号量的区别</em></p><ul><li>互斥量用于线程的互斥，信号量用于线程的同步。也就是互斥与同步的区别。<ul><li>互斥：指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性，但不保证访问顺序。</li><li>同步：在互斥的基础上（大多数情况下），通过其它机制实现访问者对资源的有序访问。</li></ul></li><li>互斥量值只能为0&#x2F;1，信号量值可以为非负整数：一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。</li><li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li></ul><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p><em>生产者消费者问题</em><br>通知是在做V操作后发现信号量≤0时触发的，需要控制互斥的同时，实现对生产者，消费者的通知。</p><ul><li>一个互斥信号量实现访问互斥</li><li>一个同步信号量初始化为0实现notEmpty通知（通知消费者消费，生产者每次投递时++，消费者消费时–）</li><li>一个同步信号量初始化为n实现notFull通知（通知生产者投递，生产者每次投递时–，消费者消费时++）</li></ul><p><em>哲学家就餐问题</em><br>哲学家需要同时拿起左右两侧的叉子才吃面，如何防止死锁：</p><ul><li>一个互斥信号量代表当前是否有人拿起筷子：只有没人拿起筷子时，才允许拿筷子，效率较低。（全局互斥）</li><li>五个互斥信号量代表叉子：偶数先拿左边，奇数先拿右边。（打破环形等待）</li><li>五个互斥信号量代表人：只有两个邻居都没有拿起筷子时，才允许拿筷子。（原子性获取资源）</li></ul><p><em>读者-写者问题</em><br>为了保证读者和写者都不被饿死，读者和写者应该在同一个队列中等待，实现FIFO：</p><ul><li>一个普通量记录读者数量</li><li>一个互斥信号量控制对读者数量的修改</li><li>一个互斥信号量控制写者写操作</li><li><strong>一个互斥信号量保证写者排队时，后续读者阻塞</strong></li></ul><h1 id="C10K问题"><a href="#C10K问题" class="headerlink" title="C10K问题"></a>C10K问题</h1><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p><strong>最初的服务器都是基于进程&#x2F;线程模型</strong>的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，那么操作系统是无法承受的。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook，Google，雅虎才有财力购买如此多的服务器。这就是C10K问题的本质。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><em>每个进程&#x2F;线程同时处理多个连接（IO多路复用）</em></p><ol><li>传统思路：一个线程循环遍历连接进行处理，但存在阻塞问题，不可行</li><li>select：提供<strong>非阻塞</strong>的方案，用一个<code>fd_set</code>结构体来告诉内核同时监控多个文件句柄，根据连接状态是否为ready判断是否处理<ol><li>思路：有连接请求抵达了再检查处理。</li><li>问题：句柄上限+重复初始化+逐个排查所有文件句柄状态效率不高。</li></ol></li><li>poll：用一个<code>pollfd</code>数组向内核传递需要关注的事件，<strong>消除文件句柄上限</strong>，使用不同字段标注关注事件和发生事件，来<strong>避免重复初始化</strong><ol><li>思路：设计新的<a href="http://lib.csdn.net/base/datastructure" title="算法与数据结构知识库">数据结构</a>提供使用效率。</li><li>问题：逐个排查所有文件句柄状态效率不高。</li></ol></li><li>epoll：调用返回的时候只给应用提供发生了状态变化（很可能是数据 ready）的文件句柄。（与前两者的区别在于其记录了连接信息，因此可以快速的定位应该响应的连接）<ol><li>思路：只返回状态变化的文件句柄。</li><li>问题：依赖特定平台（Linux）。</li></ol></li><li>libevent：异步方案，当一个文件描述符的特定事件（如可读，可写或出错）发生了，或一个定时事件发生了，libevent就会自动执行用户指定的回调函数，来处理事件。</li></ol><h2 id="新的挑战"><a href="#新的挑战" class="headerlink" title="新的挑战"></a>新的挑战</h2><p><em>问题</em><br>epoll 已经可以较好的处理 C10K 问题，但是如果要进一步的扩展，例如支持 10M 规模的并发连接，原有的技术就无能为力了。</p><p><em>思路</em><br>要高效的去阻塞，让 CPU 可以干核心的任务。所以，千万级并发实现的秘密：<strong>内核不是解决方案，而是问题所在。</strong><br>即不要让内核执行所有繁重的任务。<strong>将数据包处理，内存管理，处理器调度等任务从内核转移到应用程序高效地完成</strong>。让Linux只处理控制层，数据层完全交给应用程序来处理。</p><p><em>解决</em><br><strong>协程</strong>，用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。每个协程所独占的系统资源往往只有栈部分。而且，各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种 callback 类似），不需要内核参与，可以很方便的实现异步。</p><p><em>本质</em><br>底层库在执行recv时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到EventLoop中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行。<strong>协程是异步非阻塞的另外一种展现形式。</strong></p><p><em>异步回调和协程哪个性能好</em><br>协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换。所以协程虽然比操作系统进程性能要好，但总还是有<strong>额外消耗</strong>的。而<strong>异步回调是没有切换开销</strong>的，它等同于顺序执行代码。所以<strong>异步回调程序的性能是要优于协程模型</strong>的。</p><blockquote><p><a href="https://www.cnblogs.com/jjzd/p/6540205.html">C10K问题及解决方案</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网复习</title>
    <link href="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><em>端对端通信的方式</em><br>C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p><p><em>互联网与因特网的区别</em><br>互联网通用名词，因特网是专有名词（指基于TCP&#x2F;IP的世界最大的互联网）</p><p><em>信号的交换方式</em><br>电路交换、报文交换、分组交换，特点：</p><ul><li>电路交换：需要提前建立连接预约信道。</li><li>报文交换：时延较高、需要较大的缓存空间。</li><li>分组交换：存在分组乱序、重复、丢失的问题。</li></ul><p><em>网络按覆盖范围分类</em><br>广域网（WAN）、城域网（MAN）、局域网（LAN）、个域网（PAN）</p><p><em>性能指标</em></p><ul><li>速率：kb&#x2F;s，其中k是1000<ul><li>带宽：最高速率</li><li>吞吐量：实际速率</li></ul></li><li>时延：时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</li><li>时延带宽积：时延带宽积 &#x3D; 传播时延 * 带宽</li><li>往返时间：RTT</li><li>利用率：信道上有数据流动的时间&#x2F;总时间</li><li>丢包率：丢失分组&#x2F;总分组</li></ul><p><em>体系结构</em><br>物数网传会表应</p><p><em>协议三要素</em></p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><p><em>物理层的责任</em><br>传输比特流</p><p><em>串行与并行传输</em></p><ul><li>串行传输（主要用于传输链路上）：一条信道</li><li>并行传输（主要用于计算机内部）：多条信道</li></ul><p><em>同步与异步传输</em></p><ul><li>同步传输：以<strong>比特流</strong>的形式传输，字节之间没有间隔。</li><li>异步传输：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</li></ul><p><em>单工与双工传输</em></p><ul><li>单工：单向传输</li><li>半双工：双向（不能同时）</li><li>双工：双向（同时）</li></ul><p><em>编码与调制</em></p><ul><li>码元：基本波形</li><li>处理信号的方式：编码（数字信号）、调制（模拟信号）。</li><li>编码方式：不归零编码 -&gt; 归零编码 -&gt; 曼彻斯特编码（跳变方向决定0，1） -&gt; 差分曼彻斯特编码（码元开始处是否跳变决定0,1）</li><li>调制方式：调幅、调频、调相，其中调频和调相不同时进行。</li></ul><p><em>信道极限容量</em></p><ul><li>奈氏准则：最高码元速率 &#x3D; 2 * W 信道带宽（Hz） * 每秒码元数（Baud）</li><li>香农公式：极限传输速率 &#x3D; W * log(1+S&#x2F;N)，主要体现信噪比对极限的影响</li></ul><p><em>信道利用率</em><br>发送时延&#x2F;(发送时延+往返时间+接受时延)</p><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><p><em>数据链路层的责任</em><br>数据链路层传送的协议数据单元是<strong>帧</strong>，要实现<strong>封装成帧</strong>，<strong>差错控制</strong>，<strong>可靠传输</strong>的功能。</p><blockquote><p>相关协议：PPP协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议、ARP协议。</p></blockquote><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><h3 id="MAC帧与PPP帧"><a href="#MAC帧与PPP帧" class="headerlink" title="MAC帧与PPP帧"></a>MAC帧与PPP帧</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/24878825-bf6fe42eeea3f376.webp"></p><p>MAC帧(6624)：MAC，MAC，类型，FCS<br>PPP帧(111221)：标志F、地址A、控制C、协议P、FCS、标志</p><p><em>前导码</em><br>MAC帧有前导码，其包括前同步码与帧定界符，同时维持帧间间隔（96比特时间）作为分界点。<br>PPP帧有前后标志符。</p><p><em>透明传输</em><br>为了实现透明传输，使用了转义字符防止混淆定界符。</p><p><em>MTU(Max Transfer Unit)</em><br>1500，MAC帧携带的数据载荷不能超过MTU。</p><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>CRC（<em>Cyclic Redundancy Check</em>）循环冗余校验。<br>错误时是丢弃还是重传取决于向上提供可靠的传输服务还是不可靠的传输服务。</p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>对于比特差错：根据要求实现重传或交由上层处理。<br>对于分组差错（丢失、失序、重复）：数据链路一般是单条链路的，分组差错一般发生在上层（网络层）。</p><p><em>可靠协议</em><br>核心是超时重传机制、标识符ID，也可以有快速重传。其思想不仅用于数据链路层，而是被更广泛的应用于传输层和应用层。</p><ul><li>停止等待：发送窗口 &#x3D; 1，接受窗口 &#x3D; 1。</li><li>回退N帧：发送窗口 &#x3D; n，接受窗口 &#x3D; 1，累计确认。</li><li>选择重传：发送窗口 &#x3D; n，接受窗口 &#x3D; n，逐条确认。</li></ul><h2 id="具体协议"><a href="#具体协议" class="headerlink" title="具体协议"></a>具体协议</h2><p>针对不同信道有不同实现</p><h3 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h3><h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/24878825-b384615e861000f3.webp"><br>PS：端对端是P2P(Peer-to-Peer)。</p><h3 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h3><ul><li>CSMA&#x2F;CD协议：载波监听、多址接入、碰撞检测。（因为交换机的出现，现在不会发生碰撞，该协议已经过时）</li><li>CSMA&#x2F;CA协议：载波监听、多址接入、碰撞避免。（主要用于无线网）。实现细节有帧间间隔、退避算法、信道预约。</li></ul><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p><em>Media Access Control</em><br>点对点信道中不需要，但广播信道中需要地址识别，因此有MAC地址，又称<strong>硬件地址或物理地址</strong>。</p><ul><li>长度：6字节</li><li>广播：FFFFFF</li><li>多播：第一个bit为1，其余根据多播列表设置。</li></ul><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>根据IP地址获取MAC地址，工作于数据链路层。</p><p><em>ARP高速缓存表</em><br>根据IP地址在<strong>ARP高速缓存表</strong>（自动获取的会过期，也可手动设置）中搜索MAC地址。</p><p><em>ARP请求报文</em><br>MAC帧广播（数据链路层协议），目的IP地址的主机接受到请求后返回其对应的MAC地址。</p><blockquote><p>数据的转发过程中，源IP和目的IP地址不会变动，而源MAC地址和目的MAC地址会变动。</p></blockquote><p><em>帧交换表</em><br>交换机需要通过自学习算法（也会广播搜索），获取MAC地址对端口的映射关系，并记录在帧交换表中。</p><p><em>生成树协议STP</em><br>避免网络环路带来的广播风暴，从逻辑上切断某些链路实现无环路的树状结构，故障时再启用。</p><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>为避免广播风暴，建立虚拟局域网（逻辑上），隔离广播域。</p><h1 id="四、网际层"><a href="#四、网际层" class="headerlink" title="四、网际层"></a>四、网际层</h1><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong><br>MAC 的作用是实现「直连」的两个设备之间通信，而 IP 负责在「没有直连」的两个网络之间进行通信传输。</p><blockquote><p>相关协议：IP协议、网际控制报文协议ICMP、网际组管理协议IGMP。</p></blockquote><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p><em>首部格式</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/24878825-73800cce52c3a91e.webp"><br>版首服总标标片，生协首源目。</p><blockquote><p>IP数据报，源IP在目的IP前；TCP报文，源端口在目标端口前。<br>但对于MAC帧的MAC地址，则是目地MAC地址在源MAC地址前。</p></blockquote><p>具体：</p><ul><li>标志（3bit）：<ul><li>DF位：是否允许分片；</li><li>MF位：是否是最后一个分片；</li><li>保留位。</li></ul></li><li>片偏移：单位为8字节。</li></ul><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>分类编址 -&gt; 划分子网 -&gt; 无分类编址</p><h4 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/7.webp"></p><p><em>广播</em><br>主机号全0即发送广播。</p><ul><li>本网络内的广播叫本地广播。</li><li>不同网络之间的广播叫直接广播。（有安全问题，默认为不转发）</li></ul><p><em>多播</em><br><strong>D类和E类地址是没有主机号的，所以不可用于主机 IP</strong><br>D类常被用于<strong>多播</strong>，后28位为组号，E类是预留的分类，暂时未使用。</p><p><em>缺点</em></p><ul><li>同一网络下没有地址层次</li><li>不能很好的与现实网络匹配</li></ul><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>子网掩码（划分子网纯属一个单位内部的事情，对外部网络透明）。</p><h4 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a>无分类编址</h4><p>不再有分类和子网概念。</p><p><em>路由聚合</em><br>为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。（配合最长路径匹配原则，解决路径寻优和静态路由配置产生的错误聚合问题。）</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6 的地址是 <code>128</code> 位的，每 16 位作为一组，每组用冒号 「:」 隔开。（与IPv4不兼容）<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/29.webp"><br>IPv6的本地唯一地址范围是从<code>fc00::/7</code>到<code>fdff::/7</code>。</p><p><em>与IPv4分类上的区别</em></p><ul><li><strong>链路本地单播地址</strong>表示不经过路由器的同链路通信</li><li><strong>唯一本地地址</strong>相当于私有IP</li><li><strong>全局单播地址</strong>相当于公有IP</li></ul><p><em>与IPv4头部的区别</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/31.webp"></p><ul><li><strong>取消了首部校验和字段。</strong>（数据链路和传输层都校验，这里就省略了）</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong>（路由器不再可以分片，只允许源与目标主机分片重组）</li><li><strong>取消选项字段。</strong>（变成了下一个首部）。</li></ul><h2 id="IP数据包转发过程"><a href="#IP数据包转发过程" class="headerlink" title="IP数据包转发过程"></a>IP数据包转发过程</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/25.webp"></p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>目标IP地址与本网络掩码做与运算，判断是否属于本网段，若不属于则交付给默认网关。<br>当IP数据包大小大于MTU时，IP数据包就会被分片，TCP通过MSS提前分片，避免整个IP数据包重传。</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><ul><li>静态路由配置：手动配置，可能出现配置错误和聚合错误的问题。</li><li>动态路由配置：适应大规模网络，分层次，同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</li></ul><h3 id="交换机层次"><a href="#交换机层次" class="headerlink" title="交换机层次"></a>交换机层次</h3><ul><li>路由选择部分：路由表。通过与其他路由器之间交互得到最优的【目标IP、掩码、下一跳IP】。</li><li>分组转发部分：转发表，由路由表生成并存储更多的内容。另外包括了【MAC地址、端口、标记等】。</li></ul><blockquote><p>对比：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。</li><li>转发表：以上三表的组合。记录目标IP地址，子网掩码，网关，接口，跃点数等。</li><li>网关为空时默认已经到达目标地址</li><li>否则需要再转发</li></ul></blockquote><h3 id="路由选择协议-1"><a href="#路由选择协议-1" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><ul><li>RIP(<em>Routing Information Protocol</em>)，路由信息协议（自治系统内部，UDP）。以最短距离为最优，只和与本节点直接相连的路由器通讯，存在坏消息传的慢问题。</li><li>OSPF(<em>Open Shortest Path First</em>)，开放最短路径优先（自治系统内部）。以代价最低为最优，</li><li>BGP(<em>Border Gateway Protocol</em>)，边界网关协议（不同自治系统，TCP），自治系统选出发言人，由发言人进行可达性信息的交互，构造自治系统之间的联通图。</li></ul><blockquote><p>与ARP的STP生成树协议对比，STP协议是为了消除环路，而OSPF是为了找最佳路径。</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS域名解析，将域名转换为IP地址，是一个<strong>应用层协议</strong>（DNS是基于UDP的，其报文长度较短。）</p><p><em>运行机制</em><br>客户端向<strong>本地DNS服务器</strong>获取域名对应的地址，本地DNS通过<strong>迭代</strong>的域名解析方式寻找对应的IP地址，最后返回给客户端。</p><p><em>缓存</em><br>有浏览器缓存和操作系统缓存，且有时间限制。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>工作在<strong>传输层</strong>，在因为和IP地址的配置关系较密切，所以放在这里，基于UDP广播。<br>与 ARP 协议正好相反，它是<strong>已知MAC地址求IP地址</strong>。<br>通过提前配置RARP服务器，客户端可以发请求获取自己的IP地址，这是一种静态配置的方式。</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>动态IP地址配置，全部基于UDP广播，是<strong>应用层协议</strong>。<br><em>流程</em></p><ol><li>客户端发起：DHCP DISCOVER报文+事务ID</li><li>服务端们回复：DHCP OFFER报文（包括自身信息和分配IP信息，租期）+事务ID</li><li>客户端发起：DHCP REQUEST报文（选择服务端和IP，租期）+事务ID</li><li>服务端回复：DHCP ACK报文</li></ol><p><em>续租</em></p><ol><li>客户端发起：DHCP REQUSET</li><li>服务端回复：DHCP ACK&#x2F;NACK</li></ol><p><em>中继代理</em><br>不同网段共用同一个DHCP服务器，通过路由器做中继代理。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p><em>Internet Control Message Protocol</em><br>网际控制报文协议，ICMP报文是基于IP数据报的。</p><h3 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h3><p><em>五种差错报文</em></p><ul><li>终点不可达：网络&#x2F;主机&#x2F;协议&#x2F;端口等找不到或由于路由器不支持分片导致不可达。</li><li>源点抑制：线路拥堵</li><li>超时：TTL超时</li><li>参数问题</li><li>重定向：发现不是最优路径</li></ul><h3 id="查询报文"><a href="#查询报文" class="headerlink" title="查询报文"></a>查询报文</h3><p><em>两种询问报文</em></p><ul><li>回送请求和响应：收到报文的主机必须回复</li><li>时间戳请求和响应：请求端填写时间戳、接收端也要填写时间戳</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><em>Ping</em><br>Packet InterNet Groper，分组网间探测，基于ICMP，基于UDP，封装在IP数据包中。<br>用于测试可达性和RTT，每条消息序号不同保证RTT的正确性。</p><p><em>traceroute</em><br>跟踪路由。原理是从1开始递增TTL发送报文，封装在IP数据包中，基于UDP。<br>故意不设置分片，可以确定路径的MTU。</p><h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><p><strong>IGMP是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p><p><em>工作机制</em></p><ol><li>路由器<strong>周期性</strong>发起<strong>IGMP 常规查询报文</strong>。</li><li>主机收到并随机延时后，回复<strong>IGMP成员关系报告报文</strong>，如果延时时收到其他主机的关系报文，则不再发送，减少网络中IGMP报文数量。</li><li>路由器接受到被注册的多播地址，则会进行转发。</li></ol><p><em>离开机制</em></p><ol><li>主机主动发起IGMP离开广播</li><li>路由器询问是否还有组成员</li><li>若有，则之后会继续转发该组播消息；否则，不再转发。</li></ol><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p><em>VPN</em><br>虚拟专用网（<em>Virtual Private Network</em>），功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p><em>NAT</em><br>网络地址转换（<em>Network Address Translation</em>），目的是IP复用，NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p><em>NATP</em><br>网络地址与端口转换，即同时进行端口转换。</p><p><em>缺点</em></p><ul><li>外部无法与内部客户端建立连接。</li><li>性能开销。</li><li>NAT路由器重置后所有TCP连接重置。</li></ul><p><em>解决</em></p><ul><li>IPv6</li><li>NAT穿透技术，应用程序主动绑定公网IP和端口</li></ul><h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><p><em>ping</em></p><ul><li>ping 是应用层协议</li><li>ping 127.0.0.1时，软中断时会使消息直接返回，<strong>不走网卡</strong>。</li><li>ping 真实本地IP和ping 127.0.0.1一样，软中断直接返回，<strong>不走网卡</strong>。</li></ul><p><em>127.0.0.1与localhost</em></p><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑（</strong>没有走物理层</strong>），最后在快要出网卡前<strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h1 id="四、传输层"><a href="#四、传输层" class="headerlink" title="四、传输层"></a>四、传输层</h1><p>传输层的作用是<strong>向上面的应用层提供通信服务</strong>。只有位于网络边缘部分的主机的协议栈才有运输层，<strong>NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议</strong>。</p><p><em>端口号</em><br>端口号由16bit表示，范围为0-65535，<strong>不同的传输层协议（TCP、UDP）可以使用相同的端口，这是两个不同的通信模块。</strong><br>常见端口号：HTTP（80）、HTTPS（443）、FTP（20&#x2F;21）、DNS（53）</p><h2 id="TCP与UDP对比"><a href="#TCP与UDP对比" class="headerlink" title="TCP与UDP对比"></a>TCP与UDP对比</h2><blockquote><p><em>记忆思路</em><br>从TCP的特点来看：</p><ul><li><strong>面向连接、基于字节流、可靠性</strong>；</li></ul><p>然后对比UDP展开细节：</p><ul><li>UDP无连接，所以服务对象也可以是多播和广播</li><li>UDP以包为单位发送，包头小，不分片</li><li>UDP不基于流，没有滑动窗口的限制，因此无法实现流量控制和拥塞控制，无法防止乱序</li><li>UDP不可靠，只能尽可能交付。</li></ul></blockquote><p>根据上述思路，以下内容尽可能地阐述即可：<br><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 <strong>MSS</strong> 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 <strong>MTU</strong> 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><em>应用场景</em></p><ul><li>TCP用于文件传输、HTTP传输</li><li>UDP用于总量较少的数据如DNS，视频音频、广播通讯</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。<br><em>头结构</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207114528.png"></p><p><em>TCP连接本质</em><br>四元组、滑动窗口、序列号的信息组合，在Linux中就是一个文件。针对系统、用户、进程，有最大个数文件描述符数量限制。</p><p><em>唯一的TCP连接</em><br>源地址、源端口、目标地址、目标端口。</p><p><em>TCP为什么分片MSS</em><br>将重传的基本单位由整个IP数据包缩小到TCP报文，实现最高的传输效率。</p><p><em>MSS与MTU</em><br>MTU &#x3D; IP头+TCP头+MSS</p><p><em>基于字节流</em><br>一条消息可能分为多个TCP报文，两个消息可能被分到同一个TCP报文。<br>由于TCP是基于流式处理的（UDP是基于数据包的），可能会导致粘包问题，需要手动解决，一般交给应用层：</p><ul><li>固定消息长度</li><li>指定边界字符（HTTP）</li><li>自定义消息结构</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><h4 id="TCP握手过程"><a href="#TCP握手过程" class="headerlink" title="TCP握手过程"></a>TCP握手过程</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp"><br>客户端状态：SYN_SEND-&gt;ESTABLISHED<br>服务端状态：LISTEN-&gt;SYN_RCVD-&gt;ESTABLISHED<br>（第三次握手时，可以携带数据）</p><p><em>三次握手原因</em><br>1.同步序列号（没必要四次） 2.避免历史连接（至少三次） 3.避免服务端资源浪费（至少三次）</p><p><em>随机初始化序列号的目的</em><br>1.防止历史消息 2.防止伪造消息（若初始化序列号总是相同则可能被伪装）</p><p><em>如何初始化序列号</em><br>client_isn &#x3D; M + F(四元组)</p><ul><li>其中M是计时器，4微妙加1，4.55小时一个循环。</li><li>其中F是Hash函数，推荐使用MD5防止被推测。</li></ul><div class="note note-primary">            <p>只有初始化序列号的生成是随机的，后续序列号随字节数增长，循环的速度会很快，一圈大概为4G，所以有时需要开启时间戳额外判断历史报文。</p>          </div><h4 id="TCP握手丢失"><a href="#TCP握手丢失" class="headerlink" title="TCP握手丢失"></a>TCP握手丢失</h4><p><em>第一次握手丢失</em></p><ul><li>客户端以相同序列号重传第一次握手。重发次数取决于<code>tcp_syn_retries</code>，默认为5次，初始重传时间为1s，总共耗时63s。</li><li>如果一直丢失，则重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>第二次握手丢失</em></p><ul><li>客户端以相同序列号重传第一次握手，细节同上。</li><li>服务端以相同序列号重传第二次握手。重发次数取决于<code>tcp_synack_retries</code>，默认为5次，初始重传时间为1s，总共耗时63s。</li><li>如果一直丢失，则<strong>客户端</strong>在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li><li>如果一直丢失，则<strong>服务端</strong>在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>第三次握手丢失</em></p><ul><li>服务端以相同序列号重传第二次握手，细节同上。</li><li>客户端收到第二次握手后回复第三次握手（不会主动重传ACK），如果一直丢失。</li><li>如果一直丢失，则<strong>服务端</strong>在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>总结</em></p><ul><li>SYN报文、SYNACK报文没收到回应会反复重传，直到次数用尽后自动关闭连接。</li><li>ACK报文不会重传。</li></ul><blockquote><p>对于非握手报文，重传的次数取决于<code>tcp_retries2</code>，默认为15次。</p></blockquote><p><em>TCP Fast Open</em><br>再次握手时简化握手流程，可设置<code>net.ipv4.tcp_fastopen</code>决定是否开启。<br>第一次连接时，由服务端在第二次握手时给客户端签发cookie，第二次连接时，直接在第一次握手时携带cookie和数据。</p><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230208000041.png"><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/3.webp"></p><h5 id="TCP半连接溢出"><a href="#TCP半连接溢出" class="headerlink" title="TCP半连接溢出"></a>TCP半连接溢出</h5><p><em>最大值</em><br>长度为max_syn_backlog和全连接队列长度中较小者的两倍。</p><p><em>策略</em><br>默认丢弃；若开启了tcp_syncookies（不使用 SYN 半连接队列的情况下成功建立连接，注意与TCP Fast Open区分），则不丢弃。</p><h5 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h5><p><em>方式</em><br>打满半连接队列</p><p><em>应对</em></p><ul><li>扩大半连接队列长度，扩大容量。</li><li>减少syn+ack重传次数，快速拒绝不合理的连接。</li><li>开启syncookies功能，绕过队列。</li></ul><h4 id="序列号和确认号"><a href="#序列号和确认号" class="headerlink" title="序列号和确认号"></a>序列号和确认号</h4><p>syn &#x3D; 上次syn + 上次数据长度len，（但SYN和FIN作为主动发出的控制，都需要占用1个syn）。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h4 id="TCP挥手过程"><a href="#TCP挥手过程" class="headerlink" title="TCP挥手过程"></a>TCP挥手过程</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207141651.png"><br>客户端状态：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE<br>服务端状态：ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSE</p><p><em>特殊情况：同时挥手</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/38.webp"><br>即在等待第二次握手时，直接收到了第三次握手需要的FIN。</p><p><em>四次挥手原因</em><br>关闭需要双方都没有数据再发送，两次FIN报文分别代表双方各自不再有数据发送。当然如果没有数据发送，且开启了<strong>TCP延迟确认机制</strong>功能，则可以变成3次。</p><p><em>TCP延迟确认机制</em></p><ul><li>没数据需要主动发送时延迟确认。</li><li>有数据发送时或再收到SYN时则立刻确认回复。</li></ul><p><em>两种关闭</em></p><ul><li><code>close</code>函数，该进程不再使用该连接，如果此时连接的引用计数变为0，则关闭该连接的读功能和写功能，并发送FIN报文。</li><li><code>shutdown</code>函数，立刻将该连接的写方向关闭，并发送FIN报文，更加优雅。</li></ul><div class="note note-primary">            <p><code>SHUTDOWN</code>比<code>CLOSE</code>优雅，但<code>CLOSE</code>仍然是主流的断开连接方式，并且可以指定<code>CLOSE</code>行为（挥手或直接RST）</p>          </div><p>当客户端调用<code>close</code>且发送FIN后，再收到服务端的数据时，会回复RST：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230208001214.png"></p><h4 id="TCP挥手丢失"><a href="#TCP挥手丢失" class="headerlink" title="TCP挥手丢失"></a>TCP挥手丢失</h4><p><em>第一次挥手丢失</em></p><ul><li>客户端重传第一次挥手。重发次数取决于<code>tcp_orphan_retries</code>，默认为8次。</li><li>如果一直丢失，则重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>第二次挥手丢失</em></p><ul><li>客户端重传第一次挥手，细节同上。</li><li>如果一直丢失，则重传次数用完后，等待2倍上次重传间隔时间后关闭连接。服务端在没有消息需要发送时，会发送第三次握手。</li></ul><p><em>第三次挥手丢失</em></p><ul><li>服务端重传第三次挥手，细节同上。</li><li>如果一直丢失，服务端在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。客户端的<strong>FIN_WAIT2状态超时</strong>后自动关闭（默认60s）。</li></ul><p><em>第四次挥手丢失</em></p><ul><li>服务端重传第三次挥手，细节同上。</li><li>客户端进入TIME_WAIT状态，接收到第三次挥手后继续回复第四次挥手，帮助服务端正常关闭。</li><li>如果一直丢失，服务端在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。客户端的<strong>TIME_WAIT状态超时</strong>后自动关闭（默认60s）。</li></ul><div class="note note-primary">            <p>FIN_WAIT2和TIME_WAIT的默认时间都是60s，为2 × MSL（最大生存时间），即一来一回的时间。</p>          </div><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p><em>TIME_WAIT作用</em></p><ul><li>帮助服务端正确关闭（进入CLOSE状态则会回复RST给服务端）。</li><li>处理本次会话中的历史消息，避免被后面相同的四元组连接接受。</li></ul><p><em>TIME_WAIT过多</em></p><ul><li>占用资源，端口</li></ul><p><em>TIME_WAIT优化</em></p><ul><li>增大<code>net.ipv4.tcp_max_tw_buckets</code>，超过时后面的TIME_WAIT状态直接重置。</li><li>开启<code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_timestamps</code>选项，将TIME_WAIT超过1s的连接随机取出复用。</li><li>开启SO_LINGER，更改close函数的行为变成直接发送RST跳过挥手环节。</li><li><code>tcp_tw_recycle</code>，其允许快速挥手TW状态，但由于PAWS判断历史报文机制的依据是IP而不是IP+端口，所以可能导致NAT条件（多设备复用IP）下不同设备时间戳不同引起的干扰问题，从而丢弃报文。</li></ul><div class="note note-primary">            <p>close函数成功关闭连接时，发送FIN，后续若接受到服务端的新数据时回复RST。<br>开启SO_LINGER后，直接发送RST。</p>          </div><p><em>服务端大量TIME_WAIT</em><br>注意只有主动关闭TCP连接的一方会有TIME_WAIT状态。</p><ul><li>HTTP未开启长连接，此时需要服务端主动关闭TCP连接。</li><li>HTTP长连接超时，此时需要服务端主动关闭TCP连接。</li><li>HTTP长连接请求数量达到上限，此时需要服务端主动关闭TCP连接。</li></ul><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>服务端和客户端都可以开启。<br>长时间没有消息来往，会每隔一段时间发送探测报文，如均无响应则关闭。默认为2小时开始发送，时间间隔为75s（均匀的时间），默认9次。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，客户端程序正常工作的。会响应探测信息，重置保活。</li><li>第二种，客户端程序崩溃，不会触发保活，操作系统会回收资源完成挥手。</li><li>第三种，客户端主机宕机并重启。回复RST，直接触发关闭。</li><li>第四种，客户端主机宕机或报文不可达。多次探测后关闭连接。</li></ul><h3 id="重传滑动窗口、流量控制、拥塞控制"><a href="#重传滑动窗口、流量控制、拥塞控制" class="headerlink" title="重传滑动窗口、流量控制、拥塞控制"></a>重传滑动窗口、流量控制、拥塞控制</h3><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><p>几种常见重传机制：</p><ul><li>超时重传（超时重传时间RTO略大于RTT，过小造成不必要的重传、过大导致传输效率低下）</li><li>快速重传（连续三个相同ACK则快速重传）</li><li>SACK，选择性确认（接受方回复已经收到的数据区间）</li><li><strong>D-SACK</strong>，重复确认（接受方回复接受到的重复数据区间），默认开启</li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>通过滑动窗口实现<strong>批量发送，累计确认、累计应答</strong>。<br>底层实现是数组，属性有数组长度以及相关指针。<br>发送窗口swnd &#x3D; min(拥塞窗口cwnd，接受窗口rwnd)，即窗口大小同时受接受方接受能力和网络负荷的影响。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方接受到ACK后移动窗口并调整发送窗口。<br>接受方接受到SEQ后移动窗口并调整接受窗口。</p><p>移动窗口和调整窗口本质上是指针的移动，考虑如下场景：<br>1）接受方应用程序读取较慢：</p><ol><li>首先窗口移动应用程序读走的字节数量（长度不变）</li><li>对于已经接受但来不及被应用程序读走的字节数，通过移动左指针的方式收缩窗口（长度变短），并通知发送方缩小窗口，发送方也只移动左指针。</li></ol><p>2）接受方资源紧张</p><ol><li>此时操作系统可能会直接减少<strong>接受缓冲区</strong>的大小，导致右指针左移（长度变短）。</li><li>由于应用程序来不及都走部分字节，导致左指针右移（长度变短）。</li><li>接受方通知发送方缩小窗口，但由于1中左移，可能导致发送方已经发出了接受方此时无法接受的消息。</li></ol><p>因此，TCP不允许同时<strong>缩小窗口</strong>和<strong>减少缓存</strong>，必须先缩小窗口，再减少缓存。（保证右端不会左移）。</p><p><em>零窗口探测报文</em><br>窗口大小为0时，可能造成双方的无限等待，因此发送方会在零窗口通知后启动计时器，默认每30s发送一个探测报文，发送3次，若均接受不到回复或窗口仍为0，则发送RST断开连接。<br>注意与保活报文对比，保活报文会在无消息后2小时以75秒为周期发送9次，零窗口探测报文会在窗口大小为0后以30s为周期发送3次。</p><p><em>糊涂窗口综合征</em><br>发送方为了几个字节而发送一个TCP包，叫做糊涂窗口综合症。</p><p><em>解决糊涂窗口综合征</em><br>1）Nagle算法</p><ol><li>接受方在<strong>窗口大小&lt;min(MSS，缓存空间&#x2F;2)</strong> 时，通知发送方窗口为0。</li><li>发送方开启Nagle算法，即只有<strong>窗口&gt;&#x3D;MSS且数据大小&gt;&#x3D;MSS</strong>或<strong>收到ACK包</strong>才发送。</li></ol><p>2)开启延迟确认<br>可以避免小报文，会导致4次挥手变成3次。</p><p>以上两种方案不能同时使用：<br>延迟确认和Nagle算法互锁，导致只能等接受方延迟超时回复，网络传输效率降低。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p><strong>拥塞窗口cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>主要有4种算法：<br>1.慢启动 2.拥塞避免 3.拥塞发生 4.快速恢复</p><p><em>慢启动</em><br>每收到一个ack（ack字节数，不是ACK报文数），cwnd大小加1，指数增长。</p><p><em>拥塞避免</em><br>每收到一个ack（ack字节数，不是ACK报文数），cwnd增加1&#x2F;cwnd，线性增长。</p><p><em>拥塞发生</em><br>1）如果是超时重传机制，则<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/299.webp"></p><ul><li><code>ssthresh</code> &#x3D; <code>cwnd/2</code>，即慢启动门限为当前窗口大小的一半。</li><li><code>cwnd</code> &#x3D; <code>1</code>，重置拥塞窗口。</li></ul><p>2）如果是快速重传机制，则：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230318013534.png"></p><ul><li><code>ssthresh = cwnd/2</code>，即慢启动门限为当前窗口大小的一半。;</li><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li>触发快速恢复算法</li></ul><p><em>快速恢复算法</em></p><ul><li><code>cwnd = ssthresh + 3</code>，快速重传丢失的数据包，收到新ACK后，恢复拥塞避免。</li><li><code>cwnd = ssthresh</code></li></ul><h3 id="TCP优化"><a href="#TCP优化" class="headerlink" title="TCP优化"></a>TCP优化</h3><p>主要是修改一些参数实现机制、性能的修改。</p><h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p><em>客户端优化</em><br>修改tcp_syn_retries</p><p><em>服务端优化</em></p><ul><li>tcp_synack_retries</li><li>扩大半&#x2F;全队列大小</li><li>tcp_syn_cookies</li><li>tcp_fastopen</li></ul><h4 id="挥手"><a href="#挥手" class="headerlink" title="挥手"></a>挥手</h4><p><em>客户端优化</em><br>1）FIN_WAIT1优化</p><ul><li>tcp_orphan_retries</li><li>tcp_max_orphans</li><li>SO_LINGER修改CLOSE默认行为为直接发送RST</li></ul><p>2）FIN_WAIT2优化</p><ul><li>修改FIN_WAIT2最长持续时间</li></ul><p>3）TIME_WAIT优化</p><ul><li>tw-reuse + timestamp（防止过期和绕回）</li><li>max_tw_buckets</li></ul><p><em>服务端优化</em><br>1）CLOSE_WAIT优化<br>tcp_orphan_retries</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>滑动窗口大小</li><li>缓存区大小</li><li>最大传输速度</li><li>TCP内存大小</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><em>SYN报文什么时候情况下会被丢弃</em></p><ul><li>半连接、全连接队列数量限制且没开syncookies设置。</li><li>为了复用TIME_WAIT开启<strong>tcp_tw_recycle</strong>，开启了时间戳，在NAT网络下消息过期被丢弃。</li></ul><p><em>已建立连接的TCP，收到SYN会发生什么</em></p><ul><li>客户端的SYN报文里的端口号与历史连接不相同：建立新连接。（如Socket编程中的accept）</li><li>客户端的SYN报文里的端口号与历史连接相同：<ul><li>服务端回复ACK（Challenge ACK：包含正确的序列号和确认号）。</li><li>客户端回复RST（即这个ACK处理不了）</li></ul></li></ul><p><em>发起RST的情况</em></p><ul><li>接受端在已经建立了TCP连接的情况下，收到SYN序列同步报文，回复一个Challenge ACK，发送端发现处理不了这个ACK，意味着发送端无法再发送正确的报文，从而回复RST。</li><li>主动端调用close，且使用了SO_LINGER行为。</li><li>主动端调用close关闭读和写方向后，服务端继续发送应用数据过来，回复RST。</li><li>接受端处于CLOSE状态，收到普通报文。</li><li>零窗口探测，窗口始终为0，发送RST</li></ul><p><em>收到乱序的FIN包如何处理</em><br>对方数据包发生延迟，导致先收到了对方的FIN报文，因此会将其放入到「乱序队列」，等待延迟数据包到达后，检查乱序队列并选择进入下一阶段。</p><p><em>在TIME_WAIT状态的TCP连接，收到SYN后会发生什么</em><br>判断序列号是否合法：若时间戳和syn序号都比期望大，说明是新连接请求</p><ul><li>合法SYN则重用</li><li>非法SYN则回复Challenge ACK，对方会回复RST，接受RST后根据策略选择抛弃RST或维持TIME_WAIT状态到结束。</li></ul><div class="note note-primary">            <p>接收方发现非法SYN会回复正确（Challenge）的ACK。<br>发送方发现非法ACK会回复RST。</p>          </div><p><em>TCP 连接，一端断电和进程崩溃有什么区别？</em><br>根据是否有数据传输、是否重启分类讨论。</p><p><em>拔掉网线后， 原本的 TCP 连接还存在吗？</em><br>本质就是数据丢包了。</p><p><em>tcp_tw_reuse 为什么默认是关闭的</em></p><ul><li>tw是很有必要的</li><li>要防止tcp_tw_recycle和PWSA机制带来的问题。</li></ul><p><em>TLS和TCP可以同时握手吗</em><br>只有以下两点同时满足，因为发TLS的前提是TCP的建立，跳过TCP的三步握手则需要TCP Fast Open，此时可以携带TLS信息发起握手，使用TLS1.3，直接通过Ticket实现快速连接。</p><ul><li><strong>客户端和服务端已经完成过一次通信。</strong></li><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li></ul><p><em>TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</em><br>TCP保活是探测目标是否存活的机制。<br>Http保活则是复用TCP连接。</p><p><em>TCP一定可靠吗？</em><br>只保证传输层的可靠性。</p><p><em>队列满了的行为</em></p><ul><li>半连接队列满了，根据cookies判断是否丢弃。</li><li>全连接队列满了，根据策略判断是丢弃还是RST。</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207115326.png"></p><p><strong>为什么UDP头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207115616.png"><br>UDP的头部理论上也可这样省略，保留的原因可能有：</p><ul><li>保持4的整数倍。</li><li>当年UDP协议可能不是基于IP发展的。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC是一个基于UDP的传输层协议，其实现了可靠传输。</p><p><em>特点</em></p><ul><li>无队头阻塞：不像TCP会发送传输层阻塞，本stream建立在传输层，不同stream之间不需要保证顺序。</li><li>快速连接：不像TCP要建立连接，且握手过程与TLS合并。</li><li>连接迁移：不像TCP通过4元组标识连接，而是通过连接id确定连接。</li></ul><p><em>连接过程</em><br>QUIC三次握手，交换连接id。同时合并TLS&#x2F;1.3的3次握手，实现1RTT握手。<br>再次连接时，通过连接id记录和TLS的Ticket技术，实现0RTT握手。</p><p><em>连接时间</em><br>以下是TCP+TLS1.2，TCL+TLS1.3，QUIC三种情况在首次和再次需要的RTT时间：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230206210341.png"></p><div class="note note-primary">            <p><strong>RTT是针对客户端建立连接耗时。</strong><br>TCP+TLS1.2：</p><ul><li>首次：TCP三次握手+TLS四次握手（TCP第三次握手合并TLS第一次握手，最后合并为6个）：3RTT</li><li>再次：TCP三次握手+TLS两次握手（TCP第三次握手合并TLS第一次握手，TLS使用Session技术，合并为4个）：2RTT<br>TCP+TLS1.3:</li><li>首次：TCP三次握手+TLS三次握手（TCP第三次握手合并TLS第一次握手，合并为5个）：2RTT</li><li>再次：TCP三次握手+TLS零次握手（TCP第三次握手合并TLS第一次握手，TLS使用Ticket技术，合并为3个）：1RTT<br>QUIC+TLC1.3：</li><li>首次：QUIC三次握手+TLS三次握手（全程合并，为3个）：1RTT</li><li>再次：QUIC一次握手+TLS零次握手（QUIC连接迁移，TLS使用Ticket技术，合并为1个）：0RTT</li></ul><p>RTT记忆：32,21,10。</p>          </div><h1 id="五、应用层"><a href="#五、应用层" class="headerlink" title="五、应用层"></a>五、应用层</h1><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>超文本传输协议，<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。<br>超文本：超越文本；<br>传输：双向协议；<br>协议：约定与规范。</p><p><em>状态码</em></p><ul><li>1xx，中间状态，提示信息</li><li>2xx，成功，如「<strong>200 OK</strong>」，「2O4 N0 Content」，「2O6 Partial Content」</li><li>3xx，重定向，如「<strong>301 Moved Permanently</strong>」，「302 Found」。</li><li>4xx，失败，如「<strong>400 Bad Request</strong>」，「403 Forbidden」，「<strong>404 Not Found</strong>」</li><li>5xx，服务器错误，如「<strong>500 Internal Server Error</strong>」，「<strong>502 Bad Gateway</strong>」</li></ul><p><em>常见字段</em></p><ul><li>Host：服务器域名</li><li>Connection：Keep-Alive</li><li>Accept：可接受格式</li><li>Content-Type：本次数据格式</li><li>Content-Length：数据长度</li><li>Content-Encoding：压缩方式</li></ul><p><em>GET和POST</em><br>get：语义是获取资源（<strong>可放入body也可放入url</strong>）<br>post：语义是操作资源（<strong>请求参数放入body</strong>）</p><p><em>安全和幂等</em><br>安全：不破坏服务器资源<br>幂等：多次执行结果不变<br>GET安全且幂等，POST不安全不幂等</p><blockquote><p>实际上开发者也可以不遵守这个规定。</p></blockquote><h3 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h3><p><em>强制缓存和协商缓存</em><br>强制缓存默认使用缓存，协商缓存可以每次询问服务器是否有更新，必须配合</p><p><em>两种强制缓存方式</em><br>HTTP响应头可以表示资源的缓存时间：</p><ul><li><code>Cache-Control</code>，是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p><em>两种协商缓存方式</em><br><strong>以下两种协商缓存需要配合强制缓存Cache-Control使用，强制缓存未命中时进行协商，尽可能减少服务器负担。</strong><br>方法一：时间戳</p><ul><li>响应头中的<code>Last-Modified</code>：资源最后的修改时间</li><li>请求头中的<code>If-Modified-Since</code>：告诉服务器上次接受资源的时间</li></ul><p>方法二：E-tag（优先级更高，更合理，因为时间戳是秒级的）</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：告诉服务器上次接受资源的ID。</li></ul><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p><em>特点</em></p><ul><li>HTTP长连接：复用TCP连接（可以指定时间，一般由服务器关闭）</li><li>管道网络传输（默认关闭，且未被浏览器使用）：解决请求的<strong>队头</strong>阻塞，但要按照接受到请求的顺序返回响应</li></ul><p><em>缺点</em><br>性能：数据量大、响应队头阻塞<br>安全性：不安全，明文</p><p><em>优化</em></p><ol><li>避免发送请求<ul><li>使用HTTP缓存</li></ul></li><li>减少发送请求<ul><li>减少重定向（代理服务器完成重定向）</li><li>合并请求</li><li>延迟请求</li></ul></li><li>减少响应数据大小（主要用于视频，音频）<ul><li>压缩数据</li><li>增量数据（在原帧上迭代）</li></ul></li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在TCP和HTTP层之间添加了SSL&#x2F;TLS 安全协议。</p><p><em>解决的问题</em><br>窃听，篡改，冒充</p><p><em>如何解决</em></p><ul><li><strong>混合加密</strong>，使用非对称加密交换密钥，使用对称加密加密信息防止<strong>窃听</strong></li><li>使用<strong>摘要算法</strong>防止<strong>篡改</strong></li><li>使用CA<strong>数字证书</strong>防止<strong>冒充</strong></li></ul><p><em>混合加密</em></p><ul><li>对称加密，一个密钥，速度快。</li><li>非对称加密，两个密钥，速度慢，公钥加密私钥解密防止窃听，私钥加密公钥解密防止冒充。</li></ul><p><em>摘要算法</em><br>使用摘要算法（Hash）计算内容，防止被篡改，一般算法有SHA系列。<br>但如果原文和摘要一起被替换，则无法保证安全。</p><p><em>数字证书</em><br>数字证书机构CA流程：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp"></p><ul><li>服务器可将自己的基本信息和公钥以及摘要注册到CA机构</li><li>CA机构使用自己的私钥加密摘要信息，并颁发CA证书</li><li>客户端只有使用CA的公钥解密服务器的摘要（保证是CA认证过的证书），再对比服务器发出的CA证书的摘要，才可确定是否可信。</li></ul><p>CA机制：</p><ul><li>信任链：一般操作系统和浏览器不会直接信任根CA，而是通过信任链的方式，确保根节点的安全性，进行多级隔离。</li><li>验证链：验证时，服务器找中间证书验证，中间证书找根证书认真，根证书自认证。</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p><em>SSL&#x2F;TLS</em><br>SSL标准化后变成TSL。<br>SSL（“_Secure Sockets Layer_”） 即「安全套接层」。<br>TLS（ “_Transport Layer Security_” ），即「传输层安全协议」。</p><h4 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h4><p>TLS 协议建立的详细流程：<br><em>1. ClientHello</em>（明文）<br>（1）客户端生产的随机数（<code>Client Random</code>）。<br>（2）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2.SeverHello</em>（明文）<br>（1）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。<br>（2）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</p><p><em>3.客户端回应</em>（服务器公钥加密）<br>验证CA证书，取出服务器公钥：<br>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><em>4. 服务器的最后回应</em><br>计算出本次通信的「会话秘钥」。<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><h4 id="握手算法"><a href="#握手算法" class="headerlink" title="握手算法"></a>握手算法</h4><p><em>RSA</em><br>无法前向加密，服务器私钥泄漏后第三个随机数可被解析，之前的密文都会被解密。</p><p><em>DH</em><br>非对称加密算法，使用私钥根据特定离散数学算法可以算出公钥，但无法反推。<br>双方各自计算非对称密钥并交换公钥，根据<strong>对方公钥和我方私钥</strong>，得到相同的密钥（交换律）。</p><ul><li>static DH，每次使用相同的密钥，废弃</li><li>DHE，动态生成密钥，常用</li></ul><p><em>ECDHE</em><br>使用椭圆曲线加速DHE的计算过程，需要协商曲线和基点，步骤：</p><ul><li>第一次握手类似，发出<strong>随机数1</strong>。</li><li>第二次握手回复<strong>随机数2</strong>，服务器选择DHE密码套件，并选择<strong>曲线和基点</strong>，<strong>使用RSA签名曲线公钥</strong>。</li><li>第三次握手客户端验证CA后，就可以计算出<strong>曲线私钥和曲线公钥</strong>，<strong>使用对称加密的方式加密公钥并回复</strong></li><li>第四次握手类似。</li></ul><blockquote><p>第二次握手时，双方共享了<strong>随机数1、随机数2、曲线、基点、服务端公钥</strong>。<br>最终密钥在结合椭圆曲线密钥混合结果的情况下，还混入了两个随机数，进一步加强保密性。</p></blockquote><h4 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/tls1.2and1.3-1.webp"><br><em>流程</em><br>默认使用ECDHE，跳过了密钥选择的过程，只需要3次握手。</p><ul><li>第一次握手，由客户端完成椭圆曲线、基点的选择并直接发送公钥</li><li>第二次握手，服务端根据椭圆生成私钥和公钥后，发送公钥</li><li>第三次握手，此时已经完成了密钥计算，进行验证，且可携带请求。</li></ul><p><em>Ticket</em><br>Ticket技术可以实现1RTT重连，但无法实现前向安全性。</p><p><em>Pre-shared Key</em><br>类似Ticket，0RTT重连，因为其会把HTTP请求与TLS连接一同发送给服务器。</p><h4 id="TLS底层实现"><a href="#TLS底层实现" class="headerlink" title="TLS底层实现"></a>TLS底层实现</h4><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议，指TLS握手交换密钥得到对称加密的密钥的过程。</li><li>TLS 记录协议，指使用对称加密密钥加密记录的过程。</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的<strong>切割</strong>，<strong>压缩</strong>，<strong>认证</strong>，<strong>加密</strong>，过程如下图：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p><em>HTTPS一定可靠吗？</em><br>一定，除非用户接受不可信的证书。</p><p><em>如何避免被抓包？</em></p><ol><li>不允许非法证书</li><li>HTTPS双向认证，服务端也要验证客户端的CA证书。</li></ol><p><em>优化</em></p><ul><li>选择特化算法的CPU</li><li>使用新协议，TLS&#x2F;1.3，ECDHE</li><li>证书优化<ul><li>证书吊销列表CRL维护复杂，淘汰</li><li>在线证书状态协议OCSP，由服务端在线维护证书。</li></ul></li><li>会话复用<ul><li><strong>Session ID</strong> 1RTT，不一定命中</li><li><strong>Session Ticket</strong> 1RTT，性能消耗，不具有前向安全性</li><li><strong>Pre-shard Key</strong> 0RTT，TLS1.3使用，原理与Ticket类似。</li></ul></li></ul><blockquote><p><strong>重放攻击</strong>：session或ticket被获取，从而模仿攻击，因此需要给session和ticket设置过期时间。</p></blockquote><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/25-HTTP2.webp"><br><em>特性</em></p><ul><li>头部压缩：HPACK算法<ul><li>维护头信息表：id-&gt;请求头</li><li>分静态和动态字典（有上限，到达后关闭）</li><li>使用Huffman编码</li></ul></li><li>二进制格式：<ul><li>不再使用换行来分隔，而是使用length来分割id和value。</li><li>数据帧会被分为控制帧和数据帧（头信息帧和数据帧）。</li></ul></li><li>并发传输<ul><li>引入strean概念，一个stream表示一次请求中双方会进行的所有通信。</li><li>多个stream复用一个TCP连接，不同的stream之间的frame互不干涉，同一个stream中的frame必须有序发送接受。</li></ul></li><li>主动推送<ul><li>服务器建立的stream id肯定为偶数，其可主动推送数据（如css文件）。需要在响应中通知客户端接下来将在哪个stream id中发送包体。</li></ul></li></ul><p><em>缺点</em><br>仍存在队头阻塞问题，问题出在TCP层面。</p><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p>UDP+QUIC<br>基于QUIC，帧格式也发生了变化：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230206225705.png"><br><em>特性</em></p><ul><li>头部压缩：QPACK，静态字典扩大了。且使用两个独立的单向流实现字典的请求和响应。</li><li>二进制：分为数据帧和控制帧</li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），远程过程调用</p><p><em>RPC与HTTP区别</em></p><ul><li>RPC可以找中间服务获取IP，然后对目标IP地址访问。</li><li>都支持长连接和连接池</li><li>RPC定制化程度更高，性能一般更好</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><em>建立</em></p><ol><li>客户端先通过HTTP请求申请升级协议（Connection: Upgrade），同时携带随机base64码。</li><li>服务端升级，将base64码使用公开算法变成另一个字符串并返回。</li><li>客户端也将base64码使用公开算法变成字符串，与服务端传回的对比，若相同则建立连接。</li></ol><p><em>消息格式</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207113622.png"></p><p><em>场景</em><br>全双工、频繁交互、实时响应。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>C&#x2F;S模式，监听21端口</p><h1 id="六、Linux网络"><a href="#六、Linux网络" class="headerlink" title="六、Linux网络"></a>六、Linux网络</h1><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/OSI%E4%B8%8ETCP.webp"></p><h2 id="各层交互"><a href="#各层交互" class="headerlink" title="各层交互"></a>各层交互</h2><p>网络接口层的传输单位是MAC帧（frame）<br>IP 层的传输单位是包（packet）<br>TCP 层的传输单位是段（segment）<br>HTTP 的传输单位则是消息.或报文（message）<br>但这些名词并没有什么本质的区分，可以统称为数据包。</p><h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/107.webp"></p><ol><li>解析URL</li><li>生成HTTP请求头</li><li>DNS获取IP地址</li><li>交付给操作系统协议栈</li><li>选择网卡，根据<strong>路由表规则</strong>，判断以哪个网卡作为源地址，都不匹配则选择默认网关。</li></ol><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E5%8D%8F%E8%AE%AE%E6%A0%88.webp"></p><h2 id="Linux接受包"><a href="#Linux接受包" class="headerlink" title="Linux接受包"></a>Linux接受包</h2><ol><li>DMA技术将网络包写到Ring Buffer中</li><li>触发<strong>硬件中断</strong>：<ul><li>触发中断：收到一个包就中断操作系统一次</li><li>NAPI机制：先屏蔽中断，并发起<strong>软中断</strong>，通知操作系统内核线程ksoftirqd来轮询获取数据，然后恢复被屏蔽的中断。</li></ul></li></ol><h2 id="Linux发送包"><a href="#Linux发送包" class="headerlink" title="Linux发送包"></a>Linux发送包</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/sk_buff.webp"></p><ol><li>应用程序调用socket发送数据，切换至内核态，将数据拷贝到<strong>Socket发送缓冲区</strong>（第一次sk_buff拷贝）。</li><li>如果是TCP协议处理，则对sk_buff进行切片、拷贝（第二次sk_buff拷贝），填充TCP头交给网络层。</li><li>网络层进行路由选择，填充IP头，切片（可能的第三次sk_buff）后交付网络接口层。</li><li>网络接口层通过ARP协议获取下一跳MAC地址，对sk_buff填充MAC帧头和帧尾，将其放入发送队列。</li><li>触发<strong>软中断</strong>通知网卡驱动程序发送，将sk_buff挂载在Ring Buffer中，并映射到网卡可访问的DMA区域，触发真实发送。</li><li>触发<strong>硬中断</strong>释放sk_buff内存和RingBuffer内存。</li></ol><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="ping回环"><a href="#ping回环" class="headerlink" title="ping回环"></a>ping回环</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230208114527.png"></p><h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><p><em>服务端大量CLOSE_WAIT</em><br>顾名思义，没有及时调用close函数，一般是代码问题。</p><h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207155558.png"></p><ul><li>accept职责是从全连接队列中取出一个已经建立好的连接。</li><li>TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207155715.png"></p><p><em>没有accept，能建立TCP连接吗？可以</em></p><ul><li>客户端可以自连接。</li><li>两个客户端同时发起SYN可以互连。</li></ul><p><em>不使用listen，可以建立连接吗？可以</em><br>情景与上一个问题相同。</p><p><em>服务端没有listen，可以建立连接吗？不可以</em><br>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。bind只是表示进程会占用该端口发送消息，只有listen后才会创建全连接队列，半连接队列。</p><p><em>多个TCP服务进程可以listen同一个端口吗？不可以</em></p><p><em>多个客户端可以bind同一个端口吗？</em><br>以下两种情况可以：</p><ol><li>绑定了不同的IP（不包括0.0.0.0）</li><li>绑定相同IP而开启了SO_REUSEADDR。</li></ol><blockquote><p>所谓bind，是一种手动选择端口的行为，后面调用connect时会跳过随机选择端口的过程而直接使用bind的端口。</p></blockquote><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.webp"></p><p><em>同一个TCP服务进程如何复用TCP连接</em><br>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？因为有TIME_WAIT状态，服务器进程可以bind前开启<strong>SO_REUSEADDR</strong>，即仅针对自己这个进程的TW复用。</p><p><em>绑定不同IP相同Port可行吗</em><br>可以，但如果有进程绑定了0.0.0.0的某个port，其他进程无法绑定该任意IP的该端口。<br>开启<strong>SO_REUSEADDR</strong>后，只要求IP和端口不完全一样即可，所以这个特例也变成可行的。</p><p><em>客户端的端口可以重复使用吗？</em><br>遵从4元组分析即可。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java-IO基础"><a href="#一、Java-IO基础" class="headerlink" title="一、Java IO基础"></a>一、Java IO基础</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="按数据分类"><a href="#按数据分类" class="headerlink" title="按数据分类"></a>按数据分类</h3><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/Pasted-image-20230213142717.png"></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/Pasted-image-20230213142723.png"></p><h4 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h4><ul><li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同。)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li><li>字节流名往往是Stream，字符流名往往是Reader&#x2F;Writer。</li></ul><blockquote><p>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。<br>char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p></blockquote><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputStream转Reader</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamReader</span><span class="hljs-params">(InputStream in,String charsetName)</span>;<br><span class="hljs-comment">//OutputStream转Writer</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">OutputStreamWriter</span><span class="hljs-params">(OutputStream out,String charsetName)</span>;<br></code></pre></td></tr></table></figure><h3 id="按操作对象分类"><a href="#按操作对象分类" class="headerlink" title="按操作对象分类"></a>按操作对象分类</h3><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/Pasted-image-20230213142850.png"></p><blockquote><p>根据操作对象分类的流，很多都需要套接在其他stream上，实现功能增强（装饰者模式）</p></blockquote><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>流的创建使用了装饰者模式：<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/Pasted-image-20230213143013.png"><br>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)。<br><em>eg：</em><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/Pasted-image-20230213143042.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath); <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>这些流都需要显示的关闭。</p>          </div><h2 id="Java-IO常见类"><a href="#Java-IO常见类" class="headerlink" title="Java IO常见类"></a>Java IO常见类</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String pathname)</span>;<br><span class="hljs-comment">//以parent为父路径，child为子路径创建File文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String parent,String child)</span>;<br><span class="hljs-comment">//常量，根据操作系统动态提供文件的分隔符</span><br>File.sepatator<br><span class="hljs-comment">//获取路径</span><br>String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//获取名称</span><br>String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//获取长度</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span><br><span class="hljs-comment">//将该地址视为目录并创建，若上层目录不存在则不创建</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//将该地址视为目录并创建，若上层目录不存在则仍创建</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>该对象包含记录指针，可标记当前读写位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打开文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file,String mode)</span><br><span class="hljs-comment">//获取文件指针</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getFilePointer</span><span class="hljs-params">()</span><br><span class="hljs-comment">//设置文件指针</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">seek</span><span class="hljs-params">(<span class="hljs-type">long</span> pos)</span>;<br></code></pre></td></tr></table></figure><h3 id="Path-x2F-Paths-x2F-Files"><a href="#Path-x2F-Paths-x2F-Files" class="headerlink" title="Path&#x2F;Paths&#x2F;Files"></a>Path&#x2F;Paths&#x2F;Files</h3><p>这几个类是在nio类中新增的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Paths</span><br><span class="hljs-comment">//目标文件不存在也可以获取</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(String url);<br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(URL url);<br><br><span class="hljs-comment">//Path</span><br><span class="hljs-comment">//Path转File</span><br>File <span class="hljs-title function_">toFile</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//Files</span><br><span class="hljs-comment">//文件复制</span><br>Path <span class="hljs-title function_">copy</span><span class="hljs-params">(Path src,Path dest,CopyOption ... how)</span>;<br></code></pre></td></tr></table></figure><h2 id="Java网络常见类"><a href="#Java网络常见类" class="headerlink" title="Java网络常见类"></a>Java网络常见类</h2><ul><li>InetAddress: 用于表示网络上的硬件资源，即 IP 地址；</li><li>URL: 统一资源定位符；</li><li>ServerSocket&#x2F;Socket: 使用 TCP 协议实现网络通信；</li><li>Datagram: 使用 UDP 协议实现网络通信。</li></ul><blockquote><p>URI：统一资源<strong>标识</strong>符：在某一规则下标识出一个资源的字符串。<br>URL：统一资源<strong>定位</strong>符：指定了访问机制（即网络位置）的URI。<br>URN：统一资源命名：指定了资源名称的URI。<br>URL和URN都是URI的子集。</p></blockquote><h1 id="二、Java-NIO基础"><a href="#二、Java-NIO基础" class="headerlink" title="二、Java NIO基础"></a>二、Java NIO基础</h1><p><code>NIO</code>(non blocking io)是库是在 JDK 1.4 中引入的包，其提供了<strong>高速的、面向块</strong>的 I&#x2F;O。<br>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，<strong>I&#x2F;O 以流(字节)的方式处理数据，而 NIO 以块（数据块）的方式处理数据</strong>。</p><h2 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><em>介绍</em><br>buffer用来缓冲读写数据，<strong>必须通过读写buffer来实现对channel的读写</strong>。缓冲区实质上是一个<strong>数组</strong>。</p><p><em>实现</em></p><ul><li>ByteBuffer：是一个抽象类，实现有：<ul><li>HeapByteBuffer：<code>ByteBuffer.allocate()</code></li><li>DirectByteBuffer：<code>ByteBuffer.allocateDirect()</code></li><li>MappedByteBuffer：<code>fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 1024)</code></li></ul></li><li>IntBuffer等其他所有基本类型的Buffer，实现有：<ul><li>IntBuffer：<code>IntBuffer.wrap(arr)</code></li><li>IntBuffer：<code>byteBuffer.asIntBuffer()</code>，若原ByteBuffer为Direct，则该Buffer也为Direct。</li></ul></li></ul><blockquote><p>其中MappedByteBuffer将filaChannel对应文件的0至1024个字节映射到了buffer中。</p></blockquote><p><em>结构</em></p><ul><li>capacity: 最大容量；</li><li>position: 当前指针；</li><li>limit: 可读&#x2F;写的最大指针。</li></ul><p><em>方法</em></p><ul><li><code>clear()</code>把buffer清空（<code>pos=0,limit=capacity</code>），进入<strong>写模式</strong>，此时能读、写。</li><li><code>compact()</code>会把未读完的部分压缩到前面（<code>arraycopy, pos= limit-pos，limit=capacity</code>），进入写模式，此时能读、写。</li><li><code>flip()</code>进入<strong>读模式</strong>（<code>limit=position,position=0</code>），此时不能读写。</li></ul><blockquote><p>写模式下可能会出现脏读的情况。所以一旦决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p></blockquote><p><em>操作</em><br>buffer是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成buffer</span><br><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//写数据，从channel数据流读出，写入buf</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br>buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br><br><span class="hljs-comment">//读数据，从buf中读出数据，写入channel</span><br><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br><br><span class="hljs-comment">//position标记与复位</span><br>buf.mark()<br>buf.reset()<br><br><span class="hljs-comment">//字符串转buffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><br><span class="hljs-comment">//buffer转字符串</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> buffer3.toString();<br></code></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><em>介绍</em><br>channel 类似于 stream，它就是读写数据的<strong>双向通道</strong>。channel 比 stream 更为底层，且是双向的。</p><p><em>实现</em></p><ul><li>FileChannel: 从文件中读写数据；</li><li>DatagramChannel: 通过 UDP 读写网络中数据；</li><li>SocketChannel: 通过 TCP 读写网络中数据；</li><li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><p><em>操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//channel常常不能直接获取，需要通过stream获取</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> FileInputStream.getChannel() <span class="hljs-comment">//只能读</span><br><br><span class="hljs-comment">//读取channel</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> channel.read(buffer);<br><span class="hljs-comment">//写入channel，应该循环保证全部写入</span><br><span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;<br>channel.write(buffer);<br>&#125;<br><br><span class="hljs-comment">//关闭，必须关闭，也可调用stream的close来间接关闭</span><br>channel.close();<br></code></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><em>介绍</em><br>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件。适合连接数特别多，但流量低的场景。实现了Reactor模型。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/1676302539083.png"></p><blockquote><p>FileChannel没有非阻塞模式，也不继承SelectableChannel，因此无法配合selector使用。</p></blockquote><p><em>操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建选择器</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//创建Channel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open(); ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//注册Channel到selector上</span><br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br><span class="hljs-comment">//一般会循环</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>    <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        keyIterator.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝，主要包括通过mmap和sendfile实现的I&#x2F;O。</p><p>在 Java NIO 中：</p><ul><li><strong>通道</strong>（Channel） 相当于操作系统的<strong>内核空间</strong>（kernel space）的缓冲区</li><li><strong>缓冲区</strong>（Buffer）相当于操作系统的<strong>用户空间</strong>（user space）中的缓冲区。</li></ul><h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><p>FileChannel调用map函数创建MappedByteBuffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> MappedByteBuffer <span class="hljs-title function_">map</span><span class="hljs-params">(MapMode mode, <span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p><em>底层原理</em></p><ul><li>调用链：<code>map()</code> -&gt; 本地方法<code>map0()</code> -&gt; Linux方法<code>mmap64()</code></li><li>会创建一个DirectByteBuffer（是MapeedByteBuffer的子类）对象引用在Java内存模型中，字节缓冲区在直接内存中。</li></ul><p><em>特点</em></p><ul><li>使用堆外内存。</li><li>处理大文件时，内存占用大</li><li>手动释放内存需要反射，麻烦</li></ul><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>ByteBuffer调用allocateDirect函数创建DirectByteBuffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectByteBuffer</span>(capacity); &#125;<br></code></pre></td></tr></table></figure><p><em>底层原理</em><br>对象引用在Java内存模型中，字节缓冲区在直接内存中，底层调用<code>malloc()</code>函数</p><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>并发环境下是线程安全的。<br><em>相关方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//把文件数据写入target Channel</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> count, WritableByteChannel target)</span> <span class="hljs-keyword">throws</span> IOException;<br><br><span class="hljs-comment">//把src Channel数据写入文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferFrom</span><span class="hljs-params">(ReadableByteChannel src, <span class="hljs-type">long</span> position, <span class="hljs-type">long</span> count)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p><em>底层原理</em><br>Linux <code>sendFile()</code></p><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>netty在用户态中对零拷贝进行了优化：</p><ul><li>DefaultFileRegion类，包装了<code>transferTo()</code>，直接将文件发送到输出Channel；</li><li>ByteBuf类，包装了ByteBuffer，避免了用户态中Buf之间的拷贝。</li></ul><h1 id="三、JAVA-I-x2F-O模式"><a href="#三、JAVA-I-x2F-O模式" class="headerlink" title="三、JAVA I&#x2F;O模式"></a>三、JAVA I&#x2F;O模式</h1><p>具体细节见操作系统章节，这里主要关注java代码实现。</p><h2 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h2><p><em>原始阻塞模式</em><br>单线程负责建立连接，并处理连接上数据的读写。<br>缺点：只能处理一条Socket连接上的请求。</p><p><em>多线程阻塞模式</em><br>单线程负责建立连接，为建立好的连接分配线程进行处理。<br>缺点：只解决了处理请求的并发问题，但没有解决接受请求的并发问题。且会消耗大量线程资源。</p><p><em>实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept(); <span class="hljs-comment">//阻塞</span><br><span class="hljs-comment">//以下可单/多线程完成</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>in.read() <span class="hljs-comment">//阻塞</span><br></code></pre></td></tr></table></figure><p><em>结论</em><br>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于<code>accept()</code>、<code>read()</code>的操作点都是被阻塞。</p><h2 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h2><p>NIO提供的<strong>SocketChannel</strong>可以代替Socket，可以将其设置为非阻塞。配合Buffer实现非阻塞模式。</p><p><em>多线程非阻塞模式</em><br><code>accept()</code>、<code>read()</code>的操作点都不会阻塞。</p><p><em>实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>ssc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span><br>    <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>        sc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br>        channels.add(sc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span><br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            debugRead(buffer);<br>            buffer.clear();<br>            log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>NIO提供的Selector，可以完成对多个Chaannel读写事件的控制。<br>目前流程的多路复用IO模型主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>：</p><table><thead><tr><th>IO模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA支持情况</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows&#x2F;Linux</td><td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>Linux</td><td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td></tr><tr><td>epoll</td><td>高</td><td>Reactor&#x2F;Proactor</td><td>Linux</td><td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>Linux</td><td>目前JAVA的版本不支持</td></tr></tbody></table><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reactor</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    serverSocket = ServerSocketChannel.open();  <span class="hljs-comment">// 创建服务端的ServerSocketChannel</span><br>    serverSocket.configureBlocking(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 设置为非阻塞模式</span><br>    selector = Selector.open();  <span class="hljs-comment">// 创建一个Selector多路复用器</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);<br>    serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));  <span class="hljs-comment">// 绑定服务端端口</span><br>    key.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Acceptor</span>(serverSocket));  <span class="hljs-comment">// 为服务端Channel绑定一个Acceptor</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        selector.select();  <span class="hljs-comment">// 服务端使用一个线程不断等待客户端的连接到达</span><br>        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-comment">//获取到连接，则将它交付给Acceptor</span><br>          dispatch(iterator.next());  <span class="hljs-comment">// 监听到客户端连接事件后将其分发给Acceptor</span><br>          iterator.remove();<br>        &#125;<br><br>        selector.selectNow();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 这里的attachement也即前面为服务端Channel绑定的Acceptor，调用其run()方法进行</span><br>    <span class="hljs-comment">// 客户端连接的获取，并且进行分发</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> (Runnable) key.attachment();<br>    attachment.run();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Acceptor负责获取连接并分发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">20</span>);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverSocket)</span> &#123;<br>    <span class="hljs-built_in">this</span>.serverSocket = serverSocket;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> serverSocket.accept();  <span class="hljs-comment">// 获取客户端连接</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != channel) &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(channel));  <span class="hljs-comment">// 将客户端连接交由线程池处理</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Selector selector;<br>  <span class="hljs-comment">//有一个私有客户端连接</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel channel;<br>  <span class="hljs-keyword">private</span> SelectionKey key;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">//线程池创建Handler</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(SocketChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-built_in">this</span>.channel = channel;<br>    channel.configureBlocking(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 设置客户端连接为非阻塞模式</span><br>    selector = Selector.open();  <span class="hljs-comment">// 为客户端创建一个新的多路复用器</span><br>    key = channel.register(selector, SelectionKey.OP_READ);  <span class="hljs-comment">// 注册客户端Channel的读事件</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (selector.isOpen() &amp;&amp; channel.isOpen()) &#123;<br>        Set&lt;SelectionKey&gt; keys = select();  <span class="hljs-comment">// 等待客户端事件发生</span><br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>          <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>          iterator.remove();<br>          <span class="hljs-comment">// 如果当前是读事件，则读取数据</span><br>          <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            read(key);<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>           <span class="hljs-comment">// 如果当前是写事件，则写入数据</span><br>            write(key);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这里处理的主要目的是处理Jdk的一个bug，该bug会导致Selector被意外触发，但是实际上没有任何事件到达，此时的处理方式是新建一个Selector，然后重新将当前Channel注册到该Selector上</span><br>  <span class="hljs-keyword">private</span> Set&lt;SelectionKey&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    <span class="hljs-keyword">if</span> (keys.isEmpty()) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> key.interestOps();<br>      selector = Selector.open();<br>      key = channel.register(selector, interestOps);<br>      <span class="hljs-keyword">return</span> select();<br>    &#125;<br>    <span class="hljs-keyword">return</span> keys;<br>  &#125;<br><br>  <span class="hljs-comment">// 读取客户端发送的数据</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    channel.read(input);<br>    <span class="hljs-keyword">if</span> (input.position() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    input.flip();<br>    process();  <span class="hljs-comment">// 对读取的数据进行业务处理</span><br>    input.clear();<br>    key.interestOps(SelectionKey.OP_WRITE);  <span class="hljs-comment">// 读取完成后监听写入事件</span><br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    output.flip();<br>    <span class="hljs-keyword">if</span> (channel.isOpen()) &#123;<br>      channel.write(output);  <span class="hljs-comment">// 当有写入事件时，将业务处理的结果写入到客户端Channel中</span><br>      key.channel();<br>      channel.close();<br>      output.clear();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-comment">// 进行业务处理，并且获取处理结果。本质上，基于Reactor模型，如果这里成为处理瓶颈，则直接将其处理过程放入线程池即可，并且使用一个Future获取处理结果，最后写入客户端Channel</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[input.remaining()];<br>    input.get(bytes);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, CharsetUtil.UTF_8);<br>    System.out.println(<span class="hljs-string">&quot;receive message from client: \n&quot;</span> + message);<br><br>    output.put(<span class="hljs-string">&quot;hello client&quot;</span>.getBytes());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、AIO"><a href="#四、AIO" class="headerlink" title="四、AIO"></a>四、AIO</h1><p>异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。</p><h2 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h2><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-IO/Java-IO/Pasted-image-20230213174047.png"><br><em>实现</em></p><ul><li>JAVA AIO框架在windows下使用windows IOCP技术</li><li>Linux下使用epoll多路复用IO技术模拟异步IO</li></ul><p><em>要点</em></p><ul><li>不再需要selector监听就绪事件，由channel通道注册监听已完成事件。</li><li>通过<code>AsynchronousServerSocketChannel</code>和<code>AsynchronousSocketChannel</code>实现异步功能。</li></ul><h1 id="五、Netty"><a href="#五、Netty" class="headerlink" title="五、Netty"></a>五、Netty</h1><p><em>特点</em></p><ul><li>处理了信息格式封装，如JSON。</li><li>可靠、易维护、高性能等。</li></ul><p>TODO</p><blockquote><p>参考资料：<br><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Netty%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E4%B8%8E%20RPC%20%E5%AE%9E%E8%B7%B5-%E5%AE%8C/21%20%20%E6%8A%80%E5%B7%A7%E7%AF%87%EF%BC%9A%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%E4%B9%8B%E6%97%B6%E9%97%B4%E8%BD%AE%20HashedWheelTimer.md">延迟任务处理神器之时间轮 HashedWheelTimer</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java-IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java-IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发规范</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h1><p><em>介绍</em><br>REST（英文：Representational State Transfer，简称REST，直译过来表现层状态转换）<strong>是一种软件架构风格、设计风格，而不是标准</strong>，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><em>REST架构特征</em></p><ul><li><strong>以资源为基础</strong> ：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。  </li><li><strong>统一接口</strong>: 对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。换言而知，使用RESTful风格的接口但从接口上你可能只能定位其资源，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其HTTP请求方法类型上进行判断。<ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul></li></ul><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Pasted-image-20231005220328.png"></p><ul><li><strong>URI指向资源</strong>：URI &#x3D; Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI包括URL和URN，在这里更多时候可能代指URL(统一资源定位符)。RESTful是面向资源的，每种资源可能由一个或多个URI对应，但一个URI只指向一种资源。</li><li><strong>无状态</strong>：服务器不能保存客户端的信息， 每一次从客户端发送的请求中，要包含所有必须的状态信息，会话信息由客户端保存， 服务器端根据这些状态信息来处理请求。 当客户端可以切换到一个新状态的时候发送请求信息， 当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中。 每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。</li></ul><p><em>REST架构限制条件</em><br>Fielding在论文中提出REST架构的6个<strong>限制条件</strong>，也可称为RESTful 6大原则， 标准的REST约束应满足以下6个原则：</p><ul><li><strong>客户端-服务端（Client-Server）</strong>: 这个更专注客户端和服务端的分离，服务端独立可更好服务于前端、安卓、IOS等客户端设备。</li><li><strong>无状态（Stateless）</strong>：服务端不保存客户端状态，客户端保存状态信息每次请求携带状态信息。</li><li><strong>可缓存性（Cacheability）</strong> ：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率。</li><li><strong>统一接口（Uniform Interface）</strong>：通过一定原则设计接口降低耦合，简化系统架构，这是RESTful设计的基本出发点。当然这个内容除了上述特点提到部分具体内容比较多详细了解可以参考这篇<a href="https://link.zhihu.com/?target=https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">REST论文内容</a>。</li><li><strong>分层系统（Layered System）</strong>：客户端无法直接知道连接的到终端还是中间设备，分层允许你灵活的部署服务端项目。</li><li><strong>按需代码（Code-On-Demand，可选）</strong>：按需代码允许我们灵活的发送一些看似特殊的代码给客户端例如JavaScript代码。</li></ul><p><em>URL设计规范</em></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">URL = scheme &quot;://&quot; host  &quot;:&quot;  port &quot;/&quot; path [ &quot;?&quot; query ][ &quot;#&quot; fragment ]<br>path = /&#123;version&#125;/&#123;resources&#125;/&#123;resource_id&#125;/action<br></code></pre></td></tr></table></figure><p>对于RESTful API的URL具体设计的规范如下：</p><ol><li>不用大写字母，所有单词使用英文且小写。</li><li>连字符用中杠<code>&quot;-&quot;</code>而不用下杠<code>&quot;_&quot;</code></li><li>正确使用 <code>&quot;/&quot;</code>表示层级关系,URL的层级不要过深，并且越靠前的层级应该相对越稳定</li><li>结尾不要包含正斜杠分隔符<code>&quot;/&quot;</code></li><li>URL中不出现动词，用请求方式表示动作</li><li>资源表示用复数不要用单数</li><li>不要使用文件扩展名</li></ol><p><em>安全与幂等</em><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Pasted-image-20231005220726.png"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>开发规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>开发规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发问题</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java"><a href="#一、Java" class="headerlink" title="一、Java"></a>一、Java</h1><p><em>jar包和war包的区别</em></p><ul><li>jar包：java类集合的压缩包，便于代码统一管理。</li><li>war包：包含整个web引用程序，是一个可直接运行的web模块，可直接部署在tomcat中发布。</li><li>ear包：企业引用程序，一般是多个jar包、war包的集合。</li></ul><blockquote><p>springboot项目中对比：</p><ul><li>可直接打jar包利用内置tomcat运行，所有tomcat的配置应该在springboot配置文件中修改；</li><li>可打包为war包，作为传统的应用交付方式，可灵活选择tomcat版本和修改配置。</li></ul></blockquote><p><em>同源政策</em><br><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源政策</a></p><ul><li>定义：浏览器政策，在一个页面中，浏览器只能访问同源（协议相同、域名相同、端口相同）的资源；</li><li>目的：保护cookie，避免cookie共享；</li><li>限制范围：主要限制cookie、LocalStorage、IndexDB、dom、ajax请求的发送；</li><li>规避方法：不同限制类型都有具体的规避方法，这里主要介绍ajax请求规避同源政策的一种方法：跨域CORS</li></ul><blockquote><p>Nginx代理请求可解决同源政策问题。</p></blockquote><p><em>跨域</em><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域详解</a></p><ul><li>CORS需要浏览器和服务器同时支持，具体地</li><li>对于简单请求：浏览器发送请求时会增加Origin字段，表示本次请求来源，服务器根据该值判断是否允许访问：<ul><li>如果不在许可范围，则返回正常HTTP响应，浏览器会对其进行拦截并抛出错误。</li><li>如果在许可范围内，响应头上会新增一些字段，如许可范围、是否接受cookie、允许查看的响应头字段。</li></ul></li><li>对于复杂请求（<code>PUT</code>或<code>DELETE</code>请求或<code>Content-Type</code>字段的类型是<code>application/json</code>的请求）：浏览器需要先询问服务器（预检），得到许可后才会发起正式的请求。</li></ul><h1 id="二、项目部署"><a href="#二、项目部署" class="headerlink" title="二、项目部署"></a>二、项目部署</h1><p><em>前端Vue项目部署</em></p><ul><li><code>vue.config.js</code>里的<code>publicPath</code>指的是打包后，所有资源相对根路径（nginx配置到的路径）所在的位置，如果应用被部署在一个子路径上，就需要用这个选项指定这个子路径。(同时需要注意静态资源的访问情况)</li></ul><p><em>开发环境代理</em><br>开发环境的devServer可实现页面请求的代理</p><p><em>若依部署</em><br><a href="https://blog.csdn.net/u014440968/article/details/115753615">ruoyi部署</a><br><a href="http://doc.ruoyi.vip/ruoyi-vue/document/hjbs.html#tomcat%E9%85%8D%E7%BD%AE">官方文档</a></p><h1 id="三、Ruoyi项目"><a href="#三、Ruoyi项目" class="headerlink" title="三、Ruoyi项目"></a>三、Ruoyi项目</h1><h2 id="ruoyi-server项目结构"><a href="#ruoyi-server项目结构" class="headerlink" title="ruoyi-server项目结构"></a>ruoyi-server项目结构</h2><ul><li>ruoyi-admin：主程序入口，依赖了framework、quartz、generator模块<ul><li><code>common</code>:包含&#x3D;&#x3D;验证码&#x3D;&#x3D;接口和&#x3D;&#x3D;文件上传&#x2F;下载&#x3D;&#x3D;接口（Service文件在framework中）</li><li><code>monitor</code>:包含&#x3D;&#x3D;缓存监控&#x3D;&#x3D;接口、&#x3D;&#x3D;服务器监控&#x3D;&#x3D;接口、&#x3D;&#x3D;系统访问记录&#x3D;&#x3D;接口、&#x3D;&#x3D;操作日志记录&#x3D;&#x3D;接口、&#x3D;&#x3D;在线用户监控&#x3D;&#x3D;接口。</li><li><code>system</code>:包含&#x3D;&#x3D;参数管理、部门管理、字典管理、登录认证、菜单管理、通告管理、岗位管理、个人信息管理、注册管理、角色管理、用户管理&#x3D;&#x3D;。（Service文件在System中）</li><li><code>tools</code>:有&#x3D;&#x3D;Swagger接口&#x3D;&#x3D;访问。</li><li><code>resources</code>:包含&#x3D;&#x3D;i18n、mybatis&#x3D;&#x3D;等配置。</li></ul></li><li>ruoyi-common：主要是一些通用功能。<ul><li><code>annotation</code>:主要注释</li><li><code>config</code>:配置文件，读取yml信息</li><li><code>constant</code>:常用常量</li><li><code>core</code>:常用基类:&#x3D;&#x3D;BaseController&#x3D;&#x3D;、&#x3D;&#x3D;系统类entity&#x3D;&#x3D;、&#x3D;&#x3D;登录对象model&#x3D;&#x3D;、&#x3D;&#x3D;AjaxResult&#x3D;&#x3D;、&#x3D;&#x3D;TreeEntity&#x3D;&#x3D;</li><li><code>enum</code>:常用枚举</li><li><code>exception</code>:包含各种&#x3D;&#x3D;异常entity&#x3D;&#x3D;</li><li><code>filter</code>:请求过滤器，包括&#x3D;&#x3D;包装可重复读取inputStream的request&#x3D;&#x3D;(因为多次读取会报错，我们缓存起来)和&#x3D;&#x3D;防止xss攻击&#x3D;&#x3D;</li><li><code>utils</code>:常用工具类,包括&#x3D;&#x3D;对象处理、文件处理、HTML处理、HTTP处理、IP地址获取处理、Excel处理、反射工具类、加密处理、Spring工具类、SQL处理、ID生成器、浮点数、时间、日期、异常、日志、安全、分页、字符串、线程等处理类。&#x3D;&#x3D;</li><li><code>xss</code>:防止xss注入的的&#x3D;&#x3D;validator&#x3D;&#x3D;和注解</li></ul></li><li>ruoyi-framework：主要为系统层的框架配置，如鉴权、限流、拦截、异常、校验等功能。<ul><li><code>aspectj</code>:切面，包括&#x3D;&#x3D;数据权限鉴别，多数据源切换，日志，限流&#x3D;&#x3D;切面</li><li><code>config</code>:配置文件</li><li><code>datasource</code>:&#x3D;&#x3D;多数据源&#x3D;&#x3D;</li><li><code>interceptor</code>:&#x3D;&#x3D;防止重复提交&#x3D;&#x3D;的拦截器</li><li><code>security</code>: 实现&#x3D;&#x3D;jwt功能&#x3D;&#x3D;</li><li><code>manager</code>: 异步任务管理器</li><li><code>web</code>: 服务器相关信息，&#x3D;&#x3D;全局异常处理器&#x3D;&#x3D;，&#x3D;&#x3D;权限实现服务，登录服务，注册校验方法，token验证处理，用户验证处理服务&#x3D;&#x3D;</li></ul></li><li>ruoyi-generator：代码生成器</li><li>ruoyi-quartz：定时任务</li><li>ruoyi-system：主要为system类的vo，mapper，service等，有用户角色等一些服务业务。</li><li>pom：管理子模块、管理公共依赖，子模块要依赖该公共依赖时，不用再指定版本。</li></ul><p><em>新功能编写步骤</em></p><ol><li>sql结构编写</li><li>配置好数据字典</li><li>前后台代码生成</li><li>部分服务代码修改，如导入导出代码、更新和插入判断重复代码</li></ol><h2 id="业务功能"><a href="#业务功能" class="headerlink" title="业务功能"></a>业务功能</h2><p><em>分页</em></p><ul><li>使用：<code>startPage()</code>会使下一个sql语句分页。</li><li>原理：<ul><li>从Request中获取分页参数（起始索引，每页记录，排序，排序方向）注入<code>PageDomain</code>实体，调用<code>PageHelper.startPage()</code>；</li><li><code>PageHelper.startPage()</code>将分页信息通过<code>setLocalPage</code>存入当前线程中；</li><li>SpringBoot启动时，为<code>SqlSessionFactory</code>添加了<code>PageHelperInterceptor</code>，其在SQL执行前为其添加分页信息；</li></ul></li><li>注意：<ul><li>该分页请求参数的获取基于GET请求的路径，所以其他如POST请求若有分页需求，需要将请求参数添加在请求路径上，eg：<code>?pageSize=20&amp;pageNum=1</code></li><li><code>startPage()</code>是一个重载函数，其可接受参数：<ul><li>pageNum(int)：起始页</li><li>pageSize(int)：每页数量</li><li>reasonable(bool)：是否允许非法的pageNum和pageSize</li><li><strong>count</strong>(bool)：是否预先执行一次count以得到本查询的结果总数。</li><li>pageSizeZero(bool)：该值为true时，如果 pageSize&#x3D;0就会查询出全部的结果，不进行分页。</li></ul></li></ul></li></ul><p><em>功能权限</em><br>基于角色和细分权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;@ss.hasRole(&#x27;user&#x27;)&quot;)</span><br><span class="hljs-meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;system:user:list&#x27;)&quot;)</span><br></code></pre></td></tr></table></figure><p><em>数据权限</em></p><ul><li>使用：在controller上注解<code>@DataScope</code>，并在mapper.xml中加上<code>&#123;params.dataScope&#125;</code></li><li>原理：<ul><li>通过用户id获取部门dept_id，根据用户的数据权限等级（超级管理员、本部门、部门及以下、本人）判断执行方式。</li><li>根据<code>@DataScope</code>获取当前查询的表别名，进行sql字符串拼接，添加到BaseEntity的params属性中。</li></ul></li></ul><p><em>日志</em><br>在接口上标注log，会在数据库中记录系统日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log(title = &quot;用户管理&quot;, businessType = BusinessType.INSERT)</span><br><span class="hljs-keyword">public</span> AjaxResult <span class="hljs-title function_">addSave</span><span class="hljs-params">(...)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> success(...);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>事务</em></p><ul><li><code>@Transactional</code>只回滚运行异常<code>（RuntimeException）</code>和程序错误<code>（Error）</code>，若需要回滚其他，需要标识<code>@Transactional(rollbackFor = Exception.class)</code></li><li>推荐服务层抛出异常，只在控制层处理异常</li></ul><h1 id="四、MyBatis"><a href="#四、MyBatis" class="headerlink" title="四、MyBatis"></a>四、MyBatis</h1><p><em>使用map传值</em></p><ul><li>Map接受值可能会忽略为null的值，需要在mybatis-config中配置：<code> &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;true&quot;/&gt;</code></li></ul><h1 id="五、数据类型对照"><a href="#五、数据类型对照" class="headerlink" title="五、数据类型对照"></a>五、数据类型对照</h1><h2 id="SQL-to-Java"><a href="#SQL-to-Java" class="headerlink" title="SQL to Java"></a>SQL to Java</h2><p><em>字符</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th></tr></thead><tbody><tr><td align="left">varchar</td><td align="left">java.lang.String</td></tr><tr><td align="left">char</td><td align="left">java.lang.String</td></tr><tr><td align="left">nchar</td><td align="left">java.lang.String</td></tr><tr><td align="left">nvarchar</td><td align="left">java.lang.String</td></tr><tr><td align="left">text</td><td align="left">java.lang.String</td></tr><tr><td align="left">ntext</td><td align="left">java.lang.String</td></tr></tbody></table><p><em>整数</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th><th align="left">描述</th><th>项目中使用</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">java.lang.Boolean</td><td align="left">tiny(1)的另一种写法</td><td>Boolean</td></tr><tr><td align="left">bit(1)&#x2F;bit(n)</td><td align="left">java.lang.Boolean&#x2F;byte[]</td><td align="left">根据n&#x3D;1和其他分别对应</td><td>Boolean&#x2F;byte[]</td></tr><tr><td align="left">tinyint</td><td align="left">java.lang.Integer</td><td align="left">n&#x3D;1时为boolean</td><td>Integer</td></tr><tr><td align="left">smallint</td><td align="left">java.lang.Integer</td><td align="left">有无符号都是Integer</td><td>Integer</td></tr><tr><td align="left">int</td><td align="left">java.lang.Integer&#x2F;Long</td><td align="left">无符号时为Long</td><td>Long</td></tr><tr><td align="left">bigint</td><td align="left">java.lang.Long</td><td align="left">无符号时是BigInteger</td><td>BigInteger</td></tr></tbody></table><p><em>浮点类</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">java.lang.Float</td></tr><tr><td align="left">double</td><td align="left">java.lang.Double</td></tr><tr><td align="left">decimal</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">money</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">smallmoney</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">numeric</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">real</td><td align="left">java.lang.Float</td></tr><tr><td align="left">说明：</td><td align="left"></td></tr></tbody></table><ul><li>Mysql中小数实际上只有<strong>float</strong> 和 <strong>decimal</strong>两种类型，分别是近似数值和精确数值。<code>double = float(53)</code>，<code>real = float(24) </code>，<code>numeric = decimal</code>。</li><li>float存在精度损失，实际上只有float(53)和float(24)两种类型，分别占用8byte和4byte。</li><li>decimal不存在精度损失，decimal(p,s)中p指定最大位数，s指定小数点右侧的最大位数。</li></ul><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422234611.png"></p><p><em>其他类</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th><th>项目中使用</th></tr></thead><tbody><tr><td align="left">date</td><td align="left">java.sql.Date</td><td>java.util.Date</td></tr><tr><td align="left">datetime</td><td align="left">java.sql.Timestamp</td><td>java.util.Date</td></tr><tr><td align="left">timestamp</td><td align="left">java.sql.Timestamp</td><td>java.util.Date</td></tr><tr><td align="left">binary</td><td align="left">byte[]</td><td></td></tr><tr><td align="left">image</td><td align="left">byte[]</td><td></td></tr><tr><td align="left">blob</td><td align="left">byte[]</td><td></td></tr><tr><td align="left">说明：</td><td align="left"></td><td></td></tr></tbody></table><ul><li><code>date</code>：YY-MM-DD</li><li><code>time</code>：HH:MM:SS</li><li><code>datetime</code>：YY-MM-DD HH:MM:SS</li><li><code>timestamp</code>：同datetime，可表示的时间范围不同，且受时区影响</li><li>实际上，mysql中datetime、timestamp可以表示到毫秒，只需要设置<code>datetime(3)/datetime(6)</code>或<code>timestamp(3)/timestamp(6)</code>即可。</li><li>java.sql.Date是java.util.Date的子类，前者无法表示毫秒而后者可以。</li></ul><h2 id="PLC-to-Java"><a href="#PLC-to-Java" class="headerlink" title="PLC to Java"></a>PLC to Java</h2><table><thead><tr><th>类型</th><th>精度(位)</th><th>说明（以java为基准）</th></tr></thead><tbody><tr><td><strong>bit</strong></td><td>1</td><td>相当于Boolean</td></tr><tr><td>Byte</td><td>8</td><td>byte</td></tr><tr><td>Int</td><td>?</td><td>与机器相关</td></tr><tr><td>Short</td><td>16</td><td>相当于short</td></tr><tr><td>Long</td><td>32</td><td>相当于int</td></tr><tr><td>Real</td><td>32</td><td>相当于float</td></tr><tr><td>Double</td><td>64</td><td>相当于double</td></tr></tbody></table><h2 id="OPCUA-to-Java"><a href="#OPCUA-to-Java" class="headerlink" title="OPCUA to Java"></a>OPCUA to Java</h2><table><thead><tr><th>类型</th><th>精度(位)</th><th>说明（以java为基准）</th></tr></thead><tbody><tr><td>Int8~Int64</td><td>8~64</td><td>相当于byte~long</td></tr><tr><td>Float</td><td>32</td><td>相当于float</td></tr><tr><td>Double</td><td>64</td><td>相当于Double</td></tr><tr><td>Boolean</td><td>1</td><td>相当于Boolean</td></tr></tbody></table><h1 id="六、MYSQL"><a href="#六、MYSQL" class="headerlink" title="六、MYSQL"></a>六、MYSQL</h1><p><em>MySQL多年份按月统计并补零</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>date_table.dates <span class="hljs-keyword">AS</span> <span class="hljs-type">date</span>,<br>IFNULL( temp.value, <span class="hljs-number">0</span> ) <span class="hljs-keyword">AS</span> line1,<br>IFNULL( temp1.value, <span class="hljs-number">0</span> ) <span class="hljs-keyword">AS</span> line2,<br><span class="hljs-keyword">FROM</span><br>(<br><span class="hljs-keyword">SELECT</span><br><span class="hljs-variable">@s</span> :<span class="hljs-operator">=</span> <span class="hljs-variable">@s</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> indexs,<br>DATE_FORMAT( <span class="hljs-type">DATE</span>( DATE_SUB( str_to_date(concat(<span class="hljs-keyword">YEAR</span>(NOW()),&quot;-12-31&quot;), <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>), <span class="hljs-type">INTERVAL</span> <span class="hljs-variable">@s</span> <span class="hljs-keyword">MONTH</span> ) ), <span class="hljs-string">&#x27;%m&#x27;</span> ) <span class="hljs-keyword">AS</span> dates<br><span class="hljs-keyword">FROM</span><br>mysql.help_topic,<br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span> :<span class="hljs-operator">=</span> <span class="hljs-number">-1</span> ) temp <br><span class="hljs-keyword">where</span><br><span class="hljs-variable">@s</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">11</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>indexs <span class="hljs-keyword">desc</span><br>) date_table<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount_all) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">value</span>,<br>IF(<span class="hljs-keyword">DAY</span>(t.day) <span class="hljs-operator">&lt;=</span> (<span class="hljs-keyword">select</span> count_day <span class="hljs-keyword">from</span> base_organization <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>),DATE_FORMAT(<span class="hljs-keyword">day</span>,<span class="hljs-string">&#x27;%m&#x27;</span>),DATE_FORMAT(DATE_ADD(<span class="hljs-keyword">day</span>,<span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>),<span class="hljs-string">&#x27;%m&#x27;</span>)) <span class="hljs-keyword">as</span> <span class="hljs-type">date</span><br><span class="hljs-keyword">FROM</span><br>monitor_daily t<br><span class="hljs-keyword">where</span> t.line_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> t.day<span class="hljs-operator">&gt;</span>DATE_FORMAT( <span class="hljs-type">DATE</span>( DATE_SUB( str_to_date(concat(<span class="hljs-keyword">YEAR</span>(NOW()),&quot;-12-31&quot;), <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">11</span> <span class="hljs-keyword">Month</span> ) ), <span class="hljs-string">&#x27;%Y-%m&#x27;</span> )<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">date</span><br>) temp <span class="hljs-keyword">ON</span> date_table.dates <span class="hljs-operator">=</span> temp.date<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>(<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(amount_all) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">value</span>,<br>IF(<span class="hljs-keyword">DAY</span>(t.day) <span class="hljs-operator">&lt;=</span> (<span class="hljs-keyword">select</span> count_day <span class="hljs-keyword">from</span> base_organization <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>),DATE_FORMAT(<span class="hljs-keyword">day</span>,<span class="hljs-string">&#x27;%m&#x27;</span>),DATE_FORMAT(DATE_ADD(<span class="hljs-keyword">day</span>,<span class="hljs-type">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">MONTH</span>),<span class="hljs-string">&#x27;%m&#x27;</span>)) <span class="hljs-keyword">as</span> <span class="hljs-type">date</span><br><span class="hljs-keyword">FROM</span><br>monitor_daily t<br><span class="hljs-keyword">where</span> t.line_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> t.day<span class="hljs-operator">&gt;</span>DATE_FORMAT( <span class="hljs-type">DATE</span>( DATE_SUB( str_to_date(concat(<span class="hljs-keyword">YEAR</span>(NOW()),&quot;-12-31&quot;), <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">11</span> <span class="hljs-keyword">Month</span> ) ), <span class="hljs-string">&#x27;%Y-%m&#x27;</span> )<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">date</span><br>) temp1 <span class="hljs-keyword">ON</span> date_table.dates <span class="hljs-operator">=</span> temp1.date<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br><span class="hljs-type">date</span> <span class="hljs-keyword">ASC</span><br></code></pre></td></tr></table></figure><h1 id="七、流媒体"><a href="#七、流媒体" class="headerlink" title="七、流媒体"></a>七、流媒体</h1><h2 id="ZLMediaKit"><a href="#ZLMediaKit" class="headerlink" title="ZLMediaKit"></a>ZLMediaKit</h2><p><em>工作原理</em><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422235927.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422235934.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422235940.png"></p><p><em>虚拟主机</em><br>虚拟主机的设置在没有域名的情况下作用不大，但是在关闭流和拉取流的时候，要使用正确的虚拟主机域才能正常使用，播放格式为：<code>http://132.186.192.100:8088/camera/1.flv?vhost=newwish</code></p><p><em>rtsp鉴权</em><br>在局域网内拉流会出现授权问题，需要在配置文件中修改参数为不鉴权。</p><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><p><em>摄像头配置问题</em><br>对于摄像头，需要注意是否开启音频，flv.js播放时可能会有点问题，解决方案：<br>1.设置海康威视摄像头的音频输出为第一个或ACC（默认的设置不行）；<br>2.可能在设置文件中把enable_audio关闭即可；</p><h1 id="X、部署"><a href="#X、部署" class="headerlink" title="X、部署"></a>X、部署</h1><ul><li>物联网模式下客户端的更新策略：<a href="https://blog.csdn.net/sinat_34820292/article/details/81513611#:~:text=%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%3A%201%20%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%8C%E5%92%8C%E5%BD%93%E5%89%8D%E7%89%88%E6%9C%AC%E5%88%A4%E6%96%AD%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%88%A4%E6%96%AD%E5%87%BA%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%9B%B4%E6%96%B0%202%20%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84jar%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%88%E6%89%80%E6%9C%89java%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8C%85%E5%90%AB%E6%9B%B4%E6%96%B0%E7%9A%84%E8%BF%99%E4%B8%80%E6%AE%B5%EF%BC%8C%E9%83%BD%E5%AF%BC%E5%87%BA%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84jar%EF%BC%89,3%20%E5%85%B3%E9%97%AD%E5%BD%93%E5%89%8D%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%A4%8D%E5%88%B6%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC%E8%A6%86%E7%9B%96%E8%BF%90%E8%A1%8C%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%20%28%E7%AC%94%E8%80%85%E6%9C%80%E5%BC%80%E5%A7%8B%E6%8B%85%E5%BF%83%E8%BF%99%E4%B8%AA%EF%BC%8C%20%E6%95%B2%E9%BB%91%E6%9D%BF%21%20%2C%E4%B8%8B%E9%9D%A2%E8%BF%99%E5%8F%A5%E6%98%AF%E9%87%8D%E7%82%B9%29">CSDN</a></li><li>JAVA项目服务化启动：<a href="https://blog.csdn.net/qiaodaima0/article/details/115266052">CSDN</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>开发问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>开发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>其他依赖</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Log"><a href="#一、Log" class="headerlink" title="一、Log"></a>一、Log</h1><p><em>主流依赖</em></p><ul><li>slf4j：日志的统一接口，@sLf4相当于为该类添加默认logger实例。</li><li>log4j：一种日志框架</li><li>logback：一种日志框架，Spring默认使用</li></ul><p><em>使用</em><br>在静态资源文件夹创建logback.xml配置文件。</p><ul><li>logger和root都是日志调度器，root是所有logger的父调度器</li><li>日志会根据最长包名匹配寻找处理自己的logger&#x2F;root</li><li>logger行为<ul><li>根据level对日志过滤</li><li>根据appender-ref调用处理器</li><li>根据additivity属性判断是否要传播该日志给父logger</li></ul></li></ul><blockquote><p>一般希望独立处理的日志可以使用logger拦截处理，并设置additivity不传播。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- property定义基本属性 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 日志存放路径 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.path&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;d:/data/logs/newwish/picker&quot;</span> /&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 日志输出格式 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;20&#125; - [%method,%line] - %msg%n&quot;</span> /&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- appender是日志的输出器，指定了将哪些日志输出到哪里 --&gt;</span><br>   <span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  <br>   <span class="hljs-comment">&lt;!-- 系统日志输出 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file_info&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!-- 循环政策：基于时间创建日志文件 --&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 日志文件名格式 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>  <br>         <span class="hljs-comment">&lt;!-- 日志最大的历史 60天 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 过滤的级别 --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 匹配时的操作：接收（记录） --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 不匹配时的操作：拒绝（不记录） --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file_error&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!-- 循环政策：基于时间创建日志文件 --&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 日志文件名格式 --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>  <br>         <span class="hljs-comment">&lt;!-- 日志最大的历史 60天 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 过滤的级别 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 系统模块日志级别控制,拦截这些日志，只通过info以上的日志  --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.newwish.picker&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span>  <br>   <span class="hljs-comment">&lt;!-- Spring日志级别控制，拦截这些日志，只通过warn以上的日志  --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;warn&quot;</span> /&gt;</span>  <br>  <br>    <span class="hljs-comment">&lt;!-- root是logger的根节点，会在控制台打印所有大于info的日志 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> /&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>  <br>   <span class="hljs-comment">&lt;!--系统操作日志，所有等级大于info的日志都会输出到appender--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file_info&quot;</span> /&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file_error&quot;</span> /&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、Maven"><a href="#二、Maven" class="headerlink" title="二、Maven"></a>二、Maven</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn clean</td><td>清理项⽬⽣产的临时⽂件,⼀般是模块下的target⽬录</td></tr><tr><td>mvn compile</td><td>编译源代码，⼀般编译模块下的src&#x2F;main&#x2F;java⽬录</td></tr><tr><td>mvn package</td><td>项⽬打包⼯具,会在模块下的target⽬录⽣成jar或war等⽂件</td></tr><tr><td>mvn test</td><td>测试命令,或执⾏src&#x2F;test&#x2F;java&#x2F;下junit的测试⽤例</td></tr><tr><td>mvn –version</td><td>显示版本信息</td></tr><tr><td>mvn install</td><td>将打包的jar&#x2F;war⽂件复制到你的本地仓库中,供其他模块使⽤</td></tr><tr><td>mvn deploy</td><td>将打包的⽂件发布到远程参考,提供其他⼈员进⾏下载依赖</td></tr><tr><td>mvn site</td><td>⽣成项⽬相关信息的⽹站</td></tr><tr><td>mvn eclipse:eclipse</td><td>将项⽬转化为Eclipse项⽬</td></tr><tr><td>mvn dependency:tree</td><td>打印出项⽬的整个依赖树</td></tr><tr><td>mvn archetype:generate</td><td>创建Maven的普通java项⽬</td></tr><tr><td>mvn tomcat7:run</td><td>在tomcat容器中运⾏web应⽤</td></tr><tr><td>mvn jetty:run</td><td>调⽤ Jetty 插件的 Run ⽬标在 Jetty Servlet 容器中启动 web 应⽤</td></tr></tbody></table><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maven模型版本，必须为4.0.0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目所属公司 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目标准名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 打包方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>maven01<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目描述 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>description<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多环境打包"><a href="#多环境打包" class="headerlink" title="多环境打包"></a>多环境打包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">env</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">env</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filters</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>config/$&#123;env&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filters</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--过滤配置文件作为配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>config/$&#123;env&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 除配置文件外也是资源文件，但不过滤 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>config/$&#123;env&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包命令：<br><code>mvn package -Pdev -Dmaven.test.skip=true</code>，<code>&lt;id&gt;</code>表示识别到<code>-P</code>携带了<code>dev</code>参数后，将env变量的值赋值为dev，然后maven到<code>resources/filter</code>中寻找配置文件。</p><blockquote><p><code>&lt;include&gt;</code>与<code>&lt;exclude&gt;</code>是用来圈定和排除某一文件目录下的文件是否是工程资源的。如果<code>&lt;include&gt;</code>与<code>&lt;exclude&gt;</code>划定的范围存在冲突时，以<code>&lt;exclude&gt;</code>划定的范围为准。大多数情况下，人们使用<code>&lt;include&gt;</code>和<code>&lt;exclude&gt;</code>是为了配合<code>&lt;filtering&gt;</code>实现过滤特定文件的需要。</p></blockquote><h2 id="多模块构建"><a href="#多模块构建" class="headerlink" title="多模块构建"></a>多模块构建</h2><p><em>依赖复用</em><br><code>&lt;dependencies&gt;</code>，父项目pom文件可以引入一些通用依赖，子模块会直接继承这些依赖。</p><p><em>版本管理</em><br><code>&lt;dependencyMangement&gt;</code>，父项目pom可以声明一些通用依赖，子模块在引用该依赖时则可以不指定版本号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--spring boot 2.2.2--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>模块依赖</em><br>子模块之间互相添加彼此的依赖以实现相互调用，打包时需要对各模块进行install，以供其他模块引入。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>其他依赖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>其他依赖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式七大原则"><a href="#一、设计模式七大原则" class="headerlink" title="一、设计模式七大原则"></a>一、设计模式七大原则</h1><p>开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。<br>单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。<br>依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。<br>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。<br>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。<br>迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。<br>合成复用原则：尽量使用组合(has-a)&#x2F;聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</p><div class="note note-primary">            <p>开单依接里迪合</p>          </div><h1 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h1><p><em>创建型模式</em>：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><em>结构型模式</em>：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><em>行为型模式</em>：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><div class="note note-primary">            <p>单抽工建原<br>适装代外桥组享<br>策模观迭责命<br>备状访中解</p>          </div><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>定义：</strong> 是确保某一个类只有一个实例，并且提供一个全局访问点。<br><strong>应用实例：</strong> 唯一序列号、web页面计数器</p><div class="note note-primary">            <p>若想实现线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">synchronized</span> (instance) &#123;<br>                           <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                           &#125;<br>                     &#125;<br>              &#125;<br>              <span class="hljs-keyword">return</span> instance;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><em>简单工厂模式</em>：一个工厂类根据传入的参量决定创建出那一种产品类的实例。<br>问题在于类的创建依赖工厂，扩展类时也要修改工厂类，不属于23类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePizzaFactory</span> &#123;<br>       <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">CreatePizza</span><span class="hljs-params">(String ordertype)</span> &#123;<br>              <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>              <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheesePizza</span>();<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;greek&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreekPizza</span>();<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;pepper&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PepperPizza</span>();<br>              &#125;<br>              <span class="hljs-keyword">return</span> pizza;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>工厂方法模式</em><br><strong>定义了一个创建对象的接口</strong>，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。（只实现某一实例的多样化生产）<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213113030.png"></p><p><em>抽象工厂模式</em><br><strong>定义一个接口用于创建对象族</strong>，无需指定它们的具体类。（实现某一类产品的多样化生产）<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213113259.png"></p><p>区别：<br>工厂方法重点在于<strong>方法</strong>：一个工厂（品牌）只能生产一种产品（鼠标），通过实现多个工厂扩展产品类型。<br>抽象工厂重点在于<strong>工厂</strong>：一个工厂（品牌）可以生产一系列不同产品（鼠标、键盘），通过实现多个工厂扩展产品系列的类型。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>封装一个<strong>复杂对象</strong>构造过程，并允许按步骤构造。<br>创建复杂一个对象需要为其装载很多属性，将这些装载属性的方法封装在不同方法中，子类继承时通过重写不同的方法，实现对对象创建的精准控制。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>复制现有实例：</p><ol><li>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</li><li>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</li></ol><blockquote><p>简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单(简)抽工建原</p><h2 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h2><p>适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>定义：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p><p>分类：</p><ul><li>类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li><li>对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li><li>接口适配器模式：当不需要全部实现接口提供的方法时，可先设计一个抽象类（接口）实现接口，并为该接口中每一个方法提供一个空方法，那么继承该抽象类的子类则会有选择的覆盖父类的某些方法来实现需求。</li></ul><p>简单来说就是希望一个类、对象、接口（抽象类）实现一个新的接口：</p><ul><li>类可以继承原类，实现新接口（少用）</li><li>对象可以实现新接口，聚合原类</li><li>使用抽象类实现接口，并提供空方法。子类继承抽象类时则可以有选择性的覆盖方法实现需求。</li></ul><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。</p><p>例子：为咖啡添加牛奶，但他们都属于饮品。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213123111.png"><br>代码上，先生成coffee，为其装饰时，将coffer作为参数传入milk的构造器，由milk中的方法对其进行修饰。</p><p><strong>装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。</strong></p><blockquote><p>根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。</p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ol><li>静态代理 2. 动态代理 3. CGLIB代理</li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>定义：</strong> 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213123610.png"><br>破坏了开放封闭原则</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>例子：<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213124307.png"><br>某个类可能在不同的功能方向进行扩展，如果使用继承会造成类爆炸。通过将不同方向的扩展转变成通过聚合来实现，实现解偶。本例中将软件作为成员提炼出来，此后软件的实现类就可以独立变化。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>定义：通过共享的方式高效的支持大量细粒度的对象。<br>简单来说：抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。<br><strong>应用实例：</strong> JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>适配器模式：转化对象接口。<br>装饰者模式、代理模式：增强原对象。<br>外观模式、桥接模式、组合模式、享受元模：系统封装、功能隔离、功能分级、功能共享。</p><p>适、装代、外桥组享</p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>定义：</strong> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><blockquote><p>可以理解成针对算法（策略）的工厂模式。</p></blockquote><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p><strong>定义：</strong> 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。<br><strong>应用实例</strong>：AQS</p><h3 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><strong>定义：</strong> 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>应用实例：</strong> JAVA 中的 iterator。</p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义：</strong> 如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。<br><strong>应用实例：</strong> Handler</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>定义：</strong> 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><h3 id="类的状态"><a href="#类的状态" class="headerlink" title="类的状态"></a>类的状态</h3><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p><strong>定义：</strong> 当对象的状态改变时，同时改变其行为<br><strong>应用实例：</strong> 如Reentrant锁的state</p><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><strong>定义：</strong> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><h3 id="通过中间类"><a href="#通过中间类" class="headerlink" title="通过中间类"></a>通过中间类</h3><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p><strong>定义：</strong> 将作用于某种数据结构中的各元素的操作分离出来<strong>封装成独立的类</strong>，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将<strong>对数据的操作与数据结构进行分离</strong>。</p><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p><strong>定义：</strong> 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p><strong>定义：</strong> 为语言创建解释器，通常由语言的语法和语法分析来定义。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>策模观迭责命<br>状备访中解</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p><em>设计模式七大原则：</em><br>开单依接里迪合</p><p><em>设计模式：</em><br>单抽工建原<br>适装代外桥组享<br>策模观迭责命<br>状备访中解</p><h1 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h1><h2 id="jdk中用到的设计模式盘点"><a href="#jdk中用到的设计模式盘点" class="headerlink" title="jdk中用到的设计模式盘点"></a>jdk中用到的设计模式盘点</h2><ul><li>装饰器模式：java.io中的流处理；</li><li>建造者模式：Http2&#x2F;client的构建；</li><li>单例模式： Runtime类， 单例模式主要在高并发的情况下，需要加入双检锁，或者直接使用枚举单例的方式。</li></ul><h2 id="spring中常用设计模式盘点"><a href="#spring中常用设计模式盘点" class="headerlink" title="spring中常用设计模式盘点"></a>spring中常用设计模式盘点</h2><ul><li>工厂模式：BeanFactory, ApplicationContext中的对象创建；  </li><li>观察者模式：各种事件的发布和通知；</li><li>模板模式： JdbcTemplate；</li><li>AOP: 综合了代理，装饰器，适配器模式；</li></ul><blockquote><p><a href="https://juejin.cn/post/6982587225368166436">再也不怕面试官问我设计模式使用场景了</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（内存与事务）</title>
    <link href="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Buffer-Poll"><a href="#一、Buffer-Poll" class="headerlink" title="一、Buffer Poll"></a>一、Buffer Poll</h1><h2 id="Buffer-Poll概念"><a href="#Buffer-Poll概念" class="headerlink" title="Buffer Poll概念"></a>Buffer Poll概念</h2><p><code>MySQL</code>服务器启动的时候就向操作系统申请了一片<strong>连续的内存</strong>，叫做<code>Buffer Pool</code>（缓冲池）。</p><h3 id="Buffer-Pool大小"><a href="#Buffer-Pool大小" class="headerlink" title="Buffer Pool大小"></a>Buffer Pool大小</h3><p>默认情况<code>Buffer Pool</code>只有<code>128M</code>，可以在启动服务器的时候配置<code>innodb_buffer_pool_size</code>参数的值来改变该值的大小。</p><h3 id="Buffer-Pool内部组成"><a href="#Buffer-Pool内部组成" class="headerlink" title="Buffer Pool内部组成"></a>Buffer Pool内部组成</h3><p><code>Buffer Pool</code>中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是<code>16KB</code>。<br>每一个缓存页都有一个<strong>控制块</strong>，来装一些<code>控制信息</code>，这些控制信息包括该页所属的表空间编号、页号、缓存页在<code>Buffer Pool</code>中的地址、链表节点信息、一些锁信息以及<code>LSN</code>信息。</p><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2b9d6dd1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="Buffer-Poll管理"><a href="#Buffer-Poll管理" class="headerlink" title="Buffer Poll管理"></a>Buffer Poll管理</h2><h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>Buffer Poll以<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建了一个Hash表，如果访问时命中则直接访问，否则在free链表中申请。</p><h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e300173c1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>链表的<code>基节点</code>占用的内存空间并不包含在<code>Buffer Pool</code>中，而是另外单独申请的一块内存空间，后续的各种链表基节点同理。</p></blockquote><h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><p>修改后的缓存页叫做<code>脏页</code>，为了避免频繁写磁盘影响性能，通过flush链表记录脏页，实现异步的写入磁盘。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2ec4572a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p><code>Buffer Pool</code>大小有限，有时需要将一些页淘汰出缓存。</p><h4 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h4><p>以<code>按照最近最少使用</code>的原则去淘汰缓存页，实现这个功能的链表被称为<code>LRU链表</code>（Least Recently Used）。<br>页面在被访问后就放在LRU链表的头部，淘汰时从尾部开始淘汰即可。</p><h4 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h4><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ol><li>InnoDB对于可能会读取的页面，会进行预加载，也叫<strong>预读</strong>。<ul><li>线性预读：如果访问某个区的页面超过56，则异步读取<strong>下一个区所有页面</strong>。</li><li>随机预读：如果缓存了某区的13个连续页面，则异步读取<strong>本区所有页面</strong>，默认关闭。</li></ul></li></ol><p>这会造成加载到Buffer Poll的页不一定用到，导致真正的热点数据淘汰。</p><ol start="2"><li>全表扫描</li></ol><p>非常多的使用频率偏低的页被同时加载到<code>Buffer Pool</code>时，可能会把那些使用频率非常高的页从<code>Buffer Pool</code>中淘汰掉。</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>InnoDB把这个<code>LRU链表</code>按照一定比例分成两截，分别是：</p><ul><li>一部分链表叫做<code>热数据</code>，或者称<code>young区域</code>。</li><li>另一部分叫做<code>冷数据</code>，或者称<code>old区域</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2a3fffa3_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>默认情况下，<code>old</code>区域在<code>LRU链表</code>中所占的比例是<code>37%</code>。</p><p>通过分区和访问策略，分别解决了预读和全表扫描的问题。</p><p><em>访问策略</em></p><ul><li>页面初次加载时，对应控制块放在old区头部。</li><li>在控制块上记录<strong>第一次访问时间</strong>，如果在特别短的时间（<code>innodb_old_blocks_time</code> &#x3D; 1s）内再次访问，不会将其移动到young区头部。</li></ul><h4 id="优化LRU链表"><a href="#优化LRU链表" class="headerlink" title="优化LRU链表"></a>优化LRU链表</h4><p>频繁操作头节点开销较大，要降低调整LRU链表的频率。选择只有被访问的缓存页位于<code>young</code>区域的<code>1/4</code>的后边，才会被移动到<code>LRU链表</code>头部。</p><h3 id="其他的一些链表"><a href="#其他的一些链表" class="headerlink" title="其他的一些链表"></a>其他的一些链表</h3><p>比如<code>unzip LRU链表</code>用于管理解压页，<code>zip clean链表</code>用于管理没有被解压的压缩页，<code>zip free数组</code>中每一个元素都代表一个链表，它们组成所谓的<code>伙伴系统</code>来为压缩页提供内存空间等等。</p><div class="note note-primary">            <p>Buffer Poll中有：HashMap、FREE链表、LRU链表、FLUSH链表、其他链表。</p>          </div><h3 id="空间释放"><a href="#空间释放" class="headerlink" title="空间释放"></a>空间释放</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，主要有两种刷新路径：</p><ul><li><code>BUF_FLUSH_LRU</code>：从<code>LRU链表</code>的冷数据中刷新一部分页面到磁盘</li><li><code>BUF_FLUSH_LIST</code>：从<code>flush链表</code>中刷新一部分页面到磁盘</li></ul><p><em>空间释放策略</em></p><ol><li>当空间不够时，用户线程看<code>LRU链表</code>尾部有没有可以释放未修改页面<ul><li>有则释放</li><li>没有则将LRU尾部脏页写盘后释放</li></ul></li><li>特别繁忙时，用户线程批量从<code>flush链表</code>中将脏页刷入盘中。</li></ol><h2 id="多Buffer-Pool实例"><a href="#多Buffer-Pool实例" class="headerlink" title="多Buffer Pool实例"></a>多Buffer Pool实例</h2><p>通过修改<code>innodb_buffer_pool_instances</code>设置Buffer Poll的个数。各Buffer Poll完全独立，提高了并发处理能力：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2abd79c1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>每个Buffer Poll内存大小</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure><p>即总共的大小除以实例的个数。</p><p><em>热更改</em></p><ul><li>MySQL5.7.5之前，只能在启动时配置Buffer Pool内存大小。</li><li>MySQL5.7.5之后，可以在运行时修改。<ul><li>如果想调整<code>Buffer Poll</code>大小，需要重新向操作系统申请连续内存空间，并将旧<code>Buffer Poll</code>复制过来。<strong>为了避免申请连续内存和复制的开销，MySQL将以<code>chunk</code>为单位向操作系统申请空间。</strong></li><li>一个<code>Buffer Pool</code>实例其实是由若干个<code>chunk</code>组成的，一个<code>chunk</code>就代表一片连续的内存空间。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2a5de8f2_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>上图表明，1个<code>Buffer Pool</code>由2个实例组成的，每个实例中又包含2个<code>chunk</code>。</p></blockquote><div class="note note-primary">            <p><code>chunk</code>是MySQL通过<code>innodb_buffer_pool_chunk_size</code>启动参数指定的，默认为128M，运行时无法修改。</p>          </div><blockquote><p>注意：</p><ul><li><code>innodb_buffer_pool_size</code>必须是<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的倍数，否则系统会自动调整<code>innodb_buffer_pool_size</code>的大小。</li><li>如果<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances&gt;innodb_buffer_pool_size</code>，则系统会自动调整<code>innodb_buffer_pool_chunk_size</code>大小。<br>即：</li><li>总大小 &lt; 分片 * 每片大小，则会调整每片大小</li><li>总大小 &gt; 分片 * 每片大小，但不是后者的整数倍，则会调节成后者的整数倍。</li></ul></blockquote><h2 id="Buffer-Pool中存储的其它信息"><a href="#Buffer-Pool中存储的其它信息" class="headerlink" title="Buffer Pool中存储的其它信息"></a>Buffer Pool中存储的其它信息</h2><p>链表和各种内存访问操作的统计数据。</p><h3 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h3><h4 id="Change-Buffer概念"><a href="#Change-Buffer概念" class="headerlink" title="Change Buffer概念"></a>Change Buffer概念</h4><p><em>change buffer介绍</em><br>change buffer是内存中的一块区域，它保存在Innodb的buffer pool中，它在磁盘上也有对应的持久化空间，在系统表空间ibdata中，其默认最大只能占用到innodb buffer pool的25%大小。</p><p><em>change buffer作用</em><br>更新一条数据记录的时：</p><ul><li>如果记录所在的数据页在内存中，直接更新内存中的数据页A；</li><li>如果记录所在的数据页不在内存中，Innodb会将这些更新操作缓存在change buffer中，当下次需要访问磁盘上的该数据页时，将数据页从磁盘上加载到内存里面，然后应用change buffer中与这个数据页有关的操作，即进行一次merge操作。</li></ul><p><em>merge触发</em></p><ol><li>访问数据页的时候</li><li>后台线程每秒都会merge</li><li>数据库正常关闭的情况下</li></ol><p><em>change buffer优点</em></p><ol><li>将原本2次的磁盘访问，整合成1次磁盘访问，并且能够保证数据的一致性。</li><li>数据页读入内存是需要占用内存空间的，这种方式能够避免内存的使用，提高内存的利用率。</li></ol><h4 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h4><p><em>执行差别</em></p><ul><li>搜索时：唯一索引找到符合条件的结果即返回；普通索引则会接着向后寻找其他满足条件的结果。</li><li>更新时：唯一索引的更新，不会使用到change buffer；普通索引的更新，会使用到change buffer。<ul><li>当要更新的记录在内存中的时候，两者差别不大：<ul><li>普通索引k会找到索引记录等于3和5的位置，然后在中间插入k&#x3D;4的记录；</li><li>唯一索引k会找到索引记录等于3和5的位置，然后判断没有冲突，插入k&#x3D;4的记录；</li></ul></li><li>当要更新的记录不在内存中的时候：<ul><li>唯一索引需要将数据页加载到内存中，判断这个值没有冲突，然后插入这个新值；</li><li>普通索引则是将更新记录在change buffer，语句执行就结束了。</li></ul></li></ul></li></ul><blockquote><p>普通索引利用了change buffer，减少了磁盘上的随机访问，对性能的提升比较明显。</p></blockquote><p><em>区别原因</em><br>唯一索引在做insert或者update的时候，需要判断索引记录的唯一性（因为更新操作可能造成索引冲突），而判断唯一性必须要在内存中判断，所以数据页会被加载到内存中，如果数据页已经加载到了内存中，直接更新内存更快。</p><h4 id="change-buffer使用场景"><a href="#change-buffer使用场景" class="headerlink" title="change buffer使用场景"></a>change buffer使用场景</h4><p>写多读少的业务中，change buffer能够发挥很好的作用。它可以将多次对磁盘的操作，合并成一次merge操作，从而提高MySQL的性能，一次性merge的操作越多，收益就越大。但需要注意，如果你的数据写入之后。立马会读取(也就意味着需要从磁盘读取到内存)，那么建议不要使用change buffer，因为在这种情况下，使用change buffer不会减低IO次数，反而多了change buffer的维护开销。</p><h4 id="change-buffer和redo-log的交互"><a href="#change-buffer和redo-log的交互" class="headerlink" title="change buffer和redo log的交互"></a>change buffer和redo log的交互</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230928165508.png"><br>当需要更新一条普通索引记录的时候：</p><ol><li>如果这条记录在内存中，那么直接更新内存；</li><li>如果该记录没有在内存中，那么就需要更新change buffer</li><li>更新完change buffer之后，MySQL会在redo log中记录下change buffer的修改，</li><li>事务就算完成了，后续binlog落盘，redo log commit</li><li>当需要读取不在内存中的记录时，会将该数据页从磁盘加载到内存，然后应用change buffer中的修改，也就是merge操作</li></ol><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjkzNjQwMQ==&amp;mid=2247485896&amp;idx=2&amp;sn=be8992054a608295f7e2afa3b104115a&amp;chksm=fa0679f6cd71f0e0ce99e547b3ea4d50b7d435534c9c4f014e6239ca87b217452545d39e263b&amp;scene=21#wechat_redirect">change buffer，你了解么？</a></p></blockquote><h1 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h1><h2 id="事务基本性质"><a href="#事务基本性质" class="headerlink" title="事务基本性质"></a>事务基本性质</h2><ul><li>原子性（<code>Atomicity</code>）：事务是不可分割的操作</li><li>一致性（<code>Consistency</code>）：保证数据库符合现实世界约束。</li><li>隔离性（<code>Isolation</code>）：两个并发事务之间不能互相影响。</li><li>持久性（<code>Durability</code>）：<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来。</li></ul><div class="note note-primary">            <p>ACID里的AID都是数据库的特征，也就是依赖数据库的具体实现。而唯独这个C,实际上它依赖于应用层，也就是依赖于开发者。这里的一致性是指系统从一个正确的状态迁移到另一个正确的状态。<br>即一致性是目的，AID是实现一致性的手段。</p>          </div><h2 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h2><h2 id="事务五态模型"><a href="#事务五态模型" class="headerlink" title="事务五态模型"></a>事务五态模型</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169d7fd5bd4ce2f1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持事务。</p></blockquote><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><ul><li><code>SET autocommit=0</code>：关闭自动提交（作用范围为session）</li><li><code>BEGIN</code></li><li><code>START TRANSACTION</code>：后面可接修饰符指定事务模式（默认为读写模式）：<ul><li><code>READ ONLY</code>：只读事务</li><li><code>READ WRITE</code>：读写事务</li><li><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读，此时会立即建立本事务的一致性读ReadView，即开始事务了；</li></ul></li></ul><p><em>事务开始时点</em><br>通过语句<code>SELECT * from information_schema.INNODB_TRX</code>测试，执行<code>start transaction</code>后不会立即开启事务，只有实际上执行了业务语句时才会开启该事务。</p><p><em>autocommit和start transaction的使用</em></p><ul><li>autocommit开启时：需要通过<code>start transaction</code>开启事务，此时自动提交将保持禁用状态，直到使用<code>COMMIT</code>或<code>ROLLBACK</code>结束事务。如果没有声明<code>start transaction</code>，则ROLLBACK语句是无效的（即使设置了save point）。</li><li>autocommit关闭时：可以不通过<code>start transaction</code>开启事务，也可以进行正常的提交和回滚。</li></ul><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><ul><li><code>COMMIT [WORK]</code></li></ul><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>，默认开启，表示每一条SQL语句是一个独立事务。</p><p><em>关闭自动提交</em></p><ul><li>显示开启事务。</li><li>修改系统变量<code>autocommit</code>为<code>true</code>。</li></ul><h4 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h4><p>有些语句会将本语句和之前的语句隐式提交</p><ul><li>定义或修改数据库对象的数据定义语言</li><li>使用或修改<code>mysql</code>数据库中的表</li><li>事务控制或关于锁定的语句</li><li>加载数据</li><li>复制（主从）语句</li></ul><h3 id="中止事务"><a href="#中止事务" class="headerlink" title="中止事务"></a>中止事务</h3><ul><li><code>ROLLBACK [WORK]</code></li></ul><h4 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h4><p>定义保存点和回滚保存点的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SAVEPOINT 保存点名称;<br>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;<br></code></pre></td></tr></table></figure><h1 id="三、redo日志"><a href="#三、redo日志" class="headerlink" title="三、redo日志"></a>三、redo日志</h1><h2 id="redo日志简介"><a href="#redo日志简介" class="headerlink" title="redo日志简介"></a>redo日志简介</h2><p>redo日志的目的是<strong>保证一致性</strong>（事务提交后一定执行）:</p><ul><li>若修改一个字段就对页进行一次刷盘，效率很低。</li><li>事务可能涉及多个页，随机I&#x2F;O效率低。</li></ul><p>mysql通过redo日志记录事务执行的结果，并持久化到硬盘，相比将脏页持久化到硬盘:</p><ul><li>效率更高。</li><li>顺序IO执行的。</li></ul><h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdec61898_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="简单redo日志"><a href="#简单redo日志" class="headerlink" title="简单redo日志"></a>简单redo日志</h3><p>只需要记录在某个页面修改&#x2F;写入了几字节值类型的redo日志叫做简单redo日志，也叫物理日志：</p><ul><li><code>MLOG_1/2/4/8BYTE</code>（<code>type</code>字段对应的十进制数字为<code>1/2/4/8</code>）：表示在页面的某个偏移量处写入<code>1/2/4/8</code>个字节的<code>redo</code>日志类型。</li><li><code>MLOG_WRITE_STRING</code>（<code>type</code>字段对应的十进制数字为<code>30</code>）：表示在页面的某个偏移量处写入一串数据，日志多了一个len字段。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdf053082_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdf3da823_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><div class="note note-primary">            <p>简单redo日志只记录在哪个地方写入了什么数据。</p>          </div><h3 id="复杂redo日志（插入日志）"><a href="#复杂redo日志（插入日志）" class="headerlink" title="复杂redo日志（插入日志）"></a>复杂redo日志（插入日志）</h3><p>插入新记录可能修改多个B+树，每个页面的统计信息也会更新：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdfa7d8ce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>解决方案</em></p><ul><li>方案一：在每个修改的地方都记录一条<code>redo</code>日志。</li><li>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。</li></ul><p><em>InnoDB的解决</em><br>提出了一些新的<code>redo</code>日志类型，比如：</p><ul><li><code>MLOG_REC_INSERT</code>（对应的十进制数字为<code>9</code>）：表示插入一条使用非紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_REC_INSERT</code>（对应的十进制数字为<code>38</code>）：表示插入一条使用紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>44</code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的<code>redo</code>日志类型。</li><li>等等…</li></ul><blockquote><p>逻辑上看，这些复杂redo日志无法用来直接记录修改结果，而是将修改时的行为记录下来，恢复时需要调用相关函数进行恢复。</p></blockquote><h2 id="redo日志分组"><a href="#redo日志分组" class="headerlink" title="redo日志分组"></a>redo日志分组</h2><h3 id="实现分组"><a href="#实现分组" class="headerlink" title="实现分组"></a>实现分组</h3><p>一条Sql语句可能产生多条redo日志，这些redo日志应该以组的形式写入磁盘，这是<strong>原子性</strong>的需要。</p><p><em>如何分组？</em></p><ul><li>每组的最后一条<code>redo</code>日志<strong>后边</strong>加上一条特殊类型的<code>redo</code>日志（分界符，只有一个type字段）</li><li>对于只有一条redo日志的组，通过<code>type</code>的第一个<code>bit</code>位标识即可，避免浪费。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489301685dcb4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h3><p>对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303b9e5c9f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="redo日志的写入"><a href="#redo日志的写入" class="headerlink" title="redo日志的写入"></a>redo日志的写入</h2><h3 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h3><p>通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。这里的页与前面16KB的页不同，可以将其称为<code>block</code>加以区分。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303bff8e20_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303c1fb389_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><em>LOG_BLOCK_HDR_NO是如何计算的</em><br>32位，前2位为0，所以该值最大为1G，意味着block块的个数不能超过1G。</p><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p><code>redo</code>日志也不能直接直接写到磁盘上，服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的<strong>连续内存空间</strong>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303ceeb982_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小（默认16MB）。</p><h3 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h3><p>redo日志的写入是顺序的，InnoDB通过一个全局变量<code>buf_free</code>指明后续应该写入到哪个地方。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694893043dc7344_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>一个事务对应多个mtr，一个mtr对应一组redo日志，即一个事务有多个redo日志组。<br>由于事务是并发进行的，所以两个事务的redo日志组可能交替存储：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489304969c9d7_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="redo日志写入磁盘"><a href="#redo日志写入磁盘" class="headerlink" title="redo日志写入磁盘"></a>redo日志写入磁盘</h2><p>在一些情况下redo日志会从log buffer中刷新到磁盘里，比如：</p><ul><li><code>log buffer</code>空间不足时</li><li>事务提交时（持久性）</li><li>将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中。</li><li>后台线程</li><li>正常关闭服务器时</li><li>做<code>checkpoint</code>时</li></ul><h3 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h3><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，两个文件循环写入：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899033f3b35d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>也可以修改配置指定多个文件，<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p><h3 id="redo日志文件格式"><a href="#redo日志文件格式" class="headerlink" title="redo日志文件格式"></a>redo日志文件格式</h3><p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</li></ul><blockquote><p>注意，这里都是以block作为单位，也就是一个日志存储单元的大小。</p></blockquote><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899033e1cb89_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>log file header：</em><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899065200011_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td>LOG_HEADER_FORMAT</td><td>4</td><td>redo日志的版本，在MySQL 5.7.21中该值永远为1</td></tr><tr><td>LOG_HEADER_PAD1</td><td>4</td><td>做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td>LOG_HEADER_START_LSN</td><td>8</td><td>标记本redo日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值（关于什么是LSN我们稍后再看哈，看不懂的先忽略）。</td></tr><tr><td>LOG_HEADER_CREATOR</td><td>32</td><td>一个字符串，标记本redo日志文件的创建者是谁。正常运行时该值为MySQL的版本号，比如：”MySQL 5.7.21”，使用mysqlbackup命令创建的redo日志文件的该值为”ibbackup”和创建时间。</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><p><em>checkpoint1</em><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899037defb21_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td>LOG_CHECKPOINT_NO</td><td>8</td><td>服务器做checkpoint的编号，每做一次checkpoint，该值就加1。</td></tr><tr><td>LOG_CHECKPOINT_LSN</td><td>8</td><td>服务器做checkpoint结束时对应的LSN值，系统崩溃恢复时将从该值开始。</td></tr><tr><td>LOG_CHECKPOINT_OFFSET</td><td>8</td><td>上个属性中的LSN值在redo日志文件组中的偏移量</td></tr><tr><td>LOG_CHECKPOINT_LOG_BUF_SIZE</td><td>8</td><td>服务器在做checkpoint操作时对应的log buffer的大小</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><h2 id="redo日志的id"><a href="#redo日志的id" class="headerlink" title="redo日志的id"></a>redo日志的id</h2><h3 id="log-sequence-number（LSN）"><a href="#log-sequence-number（LSN）" class="headerlink" title="log sequence number（LSN）"></a>log sequence number（LSN）</h3><p><code>log sequence number</code>是一个全局变量，初始值为8704。其帮助标识了<strong>每个mtr的redo日志组</strong>在log buffer中的起始和结束位置。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899037f19b86_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。</p><ul><li><code>log sequence number</code>：全局变量，初始值为8704，标识<strong>mtr的redo日志组</strong>在log buffer中的位置。</li><li><code>flushed_to_disk_lsn</code>：全局变量，表示刷新到磁盘中的<code>redo</code>日志量的全局变量。</li><li><code>buf_free</code>：全局变量（指针），标志下一个mtr写入指针。</li><li><code>buf_next_to_write</code>：全局变量（指针），标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899065ece690_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>总结：当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。</p><blockquote><p>lsn值和redo日志文件偏移量的对应关系：<br><code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（加上<code>log block header</code>和<code>log block trailer</code>的大小）</p></blockquote><h3 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h3><p>修改页内容后要将其控制块加入flush链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899094bcc632_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>每个控制块记录两个属性：</p><ul><li><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</li><li><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</li></ul><p><em>eg:</em><br>修改页顺序：</p><ul><li>mtr_1：a</li><li>mtr_2：b,c</li><li>mtr_3：b,d<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b89909693bfe9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><blockquote><p>一个mtr中修改的两个页的o_m和n_m字段是相同的，所以lsn的变动单位是一个mtr而不是一个redo日志！</p></blockquote><h2 id="redo日志的释放"><a href="#redo日志的释放" class="headerlink" title="redo日志的释放"></a>redo日志的释放</h2><h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><p>redo日志文件大小有限，需要循环写入，因此redo日志文件需要释放空间：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b8990a1ec0f87_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>脏页刷盘前，redo日志必须写入磁盘；</li><li>脏页刷盘后，redo日志可释放；</li></ul><p>脏页刷盘、释放redo日志的过程本质是增加<code>checkpoint_lsn</code>的操作：</p><ul><li>计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。</li><li>将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b8990aeb41002_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>checkpoint_lsn：脏页已持久化<br>flushed_to_dick_lsn：redo日志已持久化<br>lsn：当前redo日志序列</p><h3 id="批量从flush链表中刷出脏页"><a href="#批量从flush链表中刷出脏页" class="headerlink" title="批量从flush链表中刷出脏页"></a>批量从flush链表中刷出脏页</h3><p>当lsn增长过快时，系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘。</p><h3 id="innodb-flush-log-at-trx-commit的用法"><a href="#innodb-flush-log-at-trx-commit的用法" class="headerlink" title="innodb_flush_log_at_trx_commit的用法"></a>innodb_flush_log_at_trx_commit的用法</h3><p>如果对持久性要求不太高，可以修改<code>innodb_flush_log_at_trx_commit</code>系统变量</p><ul><li><code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志；</li><li><code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘；</li><li><code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中；（这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了）。</li></ul><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p><em>恢复的起点</em><br><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖。</p><p><em>恢复的终点</em><br>log buffer文件是顺序IO的，找到没写满的block即可</p><p><em>怎么恢复</em></p><ul><li>Hash：使用hash将同一个表中同一个页的redo日志放在一起处理。</li><li>跳过已经刷新到磁盘的页面：<code>checkpoint_lsn</code>之后的<code>redo</code>日志可能也已经刷盘，根据每个页的<code>File Header</code>部分中的lsn字段可以判断本页最后一次刷盘时的lsn号，若其大于<code>checkpoint_lsn</code>，也不用恢复。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>redo日志的作用：记录事务执行的结果&#x2F;过程，主要数据库崩溃时的恢复，实现持久性。</li><li>redo日志的结构：每条语句可能修改多个页面，对应着若干条redo日志记录，这些记录以组的形式（mtr）存在。</li><li>redo日志的存储：redo日志会先写入log buffer区，然后同步到系统上的log file中。<ul><li>log buffer分若干个block块</li><li>相比log buffer，log file的前4个块是固定的</li></ul></li><li>redo日志的释放：脏页被刷盘时，形成一个check-point事件（记录当前check point lsn），该lsn之前redo日志不再被需要，可以释放。</li><li>崩溃恢复时：从check point lsn开始恢复，遇到页的lsn记录大于check point lsn时略过。</li></ul><h1 id="四、undo日志"><a href="#四、undo日志" class="headerlink" title="四、undo日志"></a>四、undo日志</h1><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>redo是为了防止数据库崩溃（持久性），undo是为了防止事件回滚（原子性）。</p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><p>当一个事务涉及到对某个表执行了增、删、改操作时，会为其分配一个事务id。<br>事务id由一个全局变量维护，新事务id自增1，当事务id达到<code>256</code>的倍数时，会将其记录下来<code>Max Trx ID</code>，下次启动时在该值基础上加256，防止事务id冲突。</p><h2 id="undo日志的格式"><a href="#undo日志的格式" class="headerlink" title="undo日志的格式"></a>undo日志的格式</h2><p><code>undo日志</code>是被记录到类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。<br>类似于<code>redo日志</code>：</p><ul><li>一个事务操作对应多个mtr，一个mtr对应多个<code>undo日志</code>。</li><li><code>undo no</code>在<strong>一个事务</strong>中是从<code>0</code>开始递增的，也就是说只要事务没提交，每生成一条<code>undo日志</code>，那么该条日志的<code>undo no</code>就增1。<ul><li>redo是以组mtr为单位记录，复写的；</li><li>undo日志是以事务为单位记录、还原的？</li></ul></li><li><code>undo日志</code>也有很多种类。</li></ul><h3 id="行记录"><a href="#行记录" class="headerlink" title="行记录"></a>行记录</h3><h4 id="trx隐藏列"><a href="#trx隐藏列" class="headerlink" title="trx隐藏列"></a>trx隐藏列</h4><p>行格式中有一个<code>trx_id</code>字段，表示现在对该行进行修改的事务id。</p><h4 id="roll-pointer隐藏列"><a href="#roll-pointer隐藏列" class="headerlink" title="roll_pointer隐藏列"></a>roll_pointer隐藏列</h4><p>指向记录对应的<code>undo日志</code>的一个指针。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875af986df5c6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="undo日志类型"><a href="#undo日志类型" class="headerlink" title="undo日志类型"></a>undo日志类型</h2><h4 id="insert类"><a href="#insert类" class="headerlink" title="insert类"></a>insert类</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afa8857a9e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>只需要记录插入id即可，回滚时根据id删除。</p><h4 id="delete类"><a href="#delete类" class="headerlink" title="delete类"></a>delete类</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afcafda5bf_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>在对一条记录进行<code>delete mark</code>操作前，需要把该记录的旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都给记到对应的<code>undo日志</code>中来，形成版本链：</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afef7f83bf_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afd18e701d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>额外记录<strong>删除时记录各列数据</strong>和<strong>索引各列信息</strong>。</li></ul><p><em>删除页的过程：</em><br>1）将记录的<code>delete_mask</code>标识为改为1<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afc12f5533_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>2）删除事务提交后，有专门线程来将delete标识位为1的记录回收<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afc377e08f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h4 id="update类"><a href="#update类" class="headerlink" title="update类"></a>update类</h4><h5 id="不更新主键"><a href="#不更新主键" class="headerlink" title="不更新主键"></a>不更新主键</h5><ul><li>如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行<code>就地更新</code>。</li><li>否则，用户线程直接先删除记录（记录加入垃圾链表），然后插入新记录。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875b00a275e91_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h5 id="更新主键"><a href="#更新主键" class="headerlink" title="更新主键"></a>更新主键</h5><ul><li>将旧记录进行<code>delete mark</code>操作</li><li>创建新记录并插入</li></ul><blockquote><p>对应主键更新，可以delete mask，否则必须先硬删除记录再插入新记录。</p></blockquote><h2 id="undo页面"><a href="#undo页面" class="headerlink" title="undo页面"></a>undo页面</h2><p>FIL_PAGE_UNDO_LOG页面，该页面专门存储undo日志<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a7fd0d7f9fa_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16f3b5361c14d1b9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>TRX_UNDO_PAGE_TYPE</code>：本页面准备存储什么种类的<code>undo日志</code>。</li><li><code>TRX_UNDO_PAGE_START</code>：表示在当前页面第一条<code>undo日志</code>的起始偏移量。</li><li><code>TRX_UNDO_PAGE_FREE</code>：最后一条<code>undo</code>日志结束时的偏移量。</li><li><code>TRX_UNDO_PAGE_NODE</code>：代表一个<code>List Node</code>结构，连接前后的Undo页面（就像INODE页面一样）。</li></ul><h3 id="Undo页面链表"><a href="#Undo页面链表" class="headerlink" title="Undo页面链表"></a>Undo页面链表</h3><p>通过<code>TRX_UNDO_PAGE_NODE</code>形成链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a8074556f5d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>一个undo页只记录一种类型的undo日志，不同类型的undo页形成链表：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a808197ad5b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>针对普通表和临时表，又分别形成两组Undo日志。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80840261ec_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>这些链表是按需分配的。</p></blockquote><p>undo链表是属于事务的：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80bf9229a6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>每个事务分两组（普通&#x2F;临时），每组有两条链表（update&#x2F;insert），每个链表由若干该类型的undo页面连接构成。</p>          </div><h2 id="undo日志具体写入过程"><a href="#undo日志具体写入过程" class="headerlink" title="undo日志具体写入过程"></a>undo日志具体写入过程</h2><h3 id="undo-log-segment-header"><a href="#undo-log-segment-header" class="headerlink" title="undo log segment header"></a>undo log segment header</h3><p>每一个<code>Undo</code>链表都对应着一个<code>段</code>，称之为<code>Undo Log Segment</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80e0dadcce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>对于数据页，每个索引分两个段（叶子段&#x2F;非叶子段），每个段有若干页面。<br>对于undo页，每个链表就是一个段。</p></blockquote><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80e753a16e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>TRX_UNDO_STATE</code>：本<code>Undo</code>链表处在什么状态。<ul><li><code>TRX_UNDO_ACTIVE</code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入<code>undo日志</code>。</li><li><code>TRX_UNDO_CACHED</code>：被缓存的状态，等待被重用</li><li><code>TRX_UNDO_TO_FREE</code>：<code>insert undo</code>链表不能被重用</li><li><code>TRX_UNDO_TO_PURGE</code>：<code>update undo</code>链表不能被重用</li><li>处于<code>PREPARE</code>阶段的事务产生的<code>undo日志</code>。</li></ul></li><li><code>TRX_UNDO_LAST_LOG</code>：本<code>Undo页面</code>链表中最后一个<code>Undo Log Header</code>的位置。</li><li><code>TRX_UNDO_FSEG_HEADER</code>：本<code>Undo页面</code>链表对应的段的<code>Segment Header</code>信息</li><li><code>TRX_UNDO_PAGE_LIST</code>：<code>Undo页面</code>链表的基节点。</li></ul><blockquote><ul><li><code>undo page header</code> 主要记录本页的指针信息</li><li><code>undo log segment</code> 主要记录本undo log页链表的信息，便于快速搜索。</li><li><code>Segment Header</code> 可以用来快速定位本段的INODE Entry（INODE Entry用来管理一个段中各页面的链表）。</li></ul></blockquote><h3 id="undo-log-header"><a href="#undo-log-header" class="headerlink" title="undo log header"></a>undo log header</h3><p>定义：同一个事务向一个<code>Undo页面</code>链表中写入的<code>undo日志</code>算是一个组，在undo log header记录这些组信息。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f1d5b422_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>链表的第一个页面，会填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，之后才开始正式写入<code>undo日志</code>。</li><li>对于其他的页面只会填充<code>Undo Page Header</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f3cc070f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>如前面总结，一个事务会持有多个undo log页面链表，在第一个链表中放入：</p><ul><li>undo log segment header：记录本链表的状态（写入中？），并定位到INODE Entry，便于页面管理。</li><li>undo log header：记录本链表与事务相关的记录。</li></ul>          </div><h2 id="重用Undo页面"><a href="#重用Undo页面" class="headerlink" title="重用Undo页面"></a>重用Undo页面</h2><p><code>Undo页面</code>链表是否可以被重用的条件很简单：</p><ul><li>该链表中只包含一个<code>Undo页面</code>。</li><li>该<code>Undo页面</code>已经使用的空间小于整个页面空间的3&#x2F;4：<ul><li><code>insert undo</code>链表可立刻删除。</li><li><code>update undo</code>链表不能立刻删除。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f3f150f4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a81007cdf9f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h2><h3 id="Rollback-Segment-Header页面"><a href="#Rollback-Segment-Header页面" class="headerlink" title="Rollback Segment Header页面"></a>Rollback Segment Header页面</h3><p>在这个页面中存放了各个<code>Undo页面</code>链表的<code>frist undo page</code>的<code>页号</code>，他们把这些<code>页号</code>称之为<code>undo slot</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a810434772a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>每个链表的头部记录了链表的状态信息和事务信息<br>这个页面中通过引用各个链表头部对链表进行统一的管理，方便复用：</p><ul><li>事务从回滚段中申请Undo链表。</li><li>事务提交后，符合重用条件的可复用，不可重用的根据类型区分：</li><li>insert类型可释放</li><li>update类型需要放入history链表中。</li></ul></blockquote><h3 id="多个回滚段"><a href="#多个回滚段" class="headerlink" title="多个回滚段"></a>多个回滚段</h3><p>InnoDB中有127个回滚段，一个回滚段管理1024个undo链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a8116df4474_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="回滚段的分类"><a href="#回滚段的分类" class="headerlink" title="回滚段的分类"></a>回滚段的分类</h3><ul><li>普通表回滚段</li><li>临时表回滚段</li></ul><blockquote><p>划分原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p></blockquote><h3 id="回滚段相关配置"><a href="#回滚段相关配置" class="headerlink" title="回滚段相关配置"></a>回滚段相关配置</h3><ul><li>配置回滚段数量：启动参数<code>innodb_rollback_segments</code></li><li>通过<code>innodb_undo_directory</code>指定<code>undo表空间</code>所在的目录</li><li>通过<code>innodb_undo_tablespaces</code>定义<code>undo表空间</code>的数量</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>一个事务对应多个mtr，一个mtr对应多个undo日志</li><li>undo日志存在undo页中，undo页分update和insert类。</li><li>一个undo页不够记录一个事务的所有操作，所以要形成链表。每个事务持有2部分链表（普通&#x2F;临时），1部分链表包括2条链表（update&#x2F;insert）链表。（insert类型的undo页面在事务提交后就可以释放，update则不可以，这是处于版本链管理的需要）</li><li>一个链表就是一个undo页面段，其也有一个INODE结构来管理这个段中各个页面?</li><li>回滚段页面有各个链表头，实现对链表的管理。</li></ul><h1 id="五、事务并发控制"><a href="#五、事务并发控制" class="headerlink" title="五、事务并发控制"></a>五、事务并发控制</h1><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr><td>SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><h3 id="MySQL中支持的隔离级别"><a href="#MySQL中支持的隔离级别" class="headerlink" title="MySQL中支持的隔离级别"></a>MySQL中支持的隔离级别</h3><p>MySQL支持4种隔离级别，默认隔离级别为RR，在该隔离级别下，也可以<strong>一定程度上</strong>避免幻读问题的发生。</p><p><em>设置事务的隔离级别</em><br><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level</code>；</p><h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/b6c72ab37d5a42b9a431d737f3c3b5ee_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>注意insert操作提交后对应的undo日志就没用了。</p></blockquote><p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a33e277a98dbec_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说：<br>必须保证可以读到已经提交了的事务修改过的记录。</p><p>事务为了保证这种一致性，会在对应的时刻生成一个<code>ReadView</code>对象：</p><ul><li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的<code>事务id</code>列表。</li><li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</li><li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。</li><li><code>creator_trx_id</code>：表示生成该<code>ReadView</code>的事务的<code>事务id</code>。</li></ul><p>这样事务可以根据被访问版本的trx_id值判断：</p><ul><li>小于min_trx_id，说明trx_id事务已经被提交，可访问</li><li>大于max_trx_id，说明trx_id事务在本事务开启后开启的，不可访问</li><li>等于creator_trx_id，说明是本事务进行的修改，可访问</li><li>min与max之间，判断trx_id是否在m_ids中：若在则说明创建ReadView时trx_id事务未提交，不可访问，否则说明trx_id事务已经提交，可访问。</li></ul><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><h3 id="锁概念"><a href="#锁概念" class="headerlink" title="锁概念"></a>锁概念</h3><p><code>锁</code>其实是一个内存中的结构：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a680105d9425c2_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><h3 id="锁互斥"><a href="#锁互斥" class="headerlink" title="锁互斥"></a>锁互斥</h3><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230928191149.png"><br>对于<code>MyISAM</code>、<code>MEMORY</code>、<code>MERGE</code>这些存储引擎来说，它们只支持表级锁，也不支持事务。</p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p><em>使用</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 库级别锁<br>flush tables <span class="hljs-keyword">with</span> read lock<br><span class="hljs-operator">-</span> 锁释放<br>unlock tables<br></code></pre></td></tr></table></figure><p><em>范围与目的</em><br>整个数据库处于只读状态了，任何修改型语句都会被阻塞，用于全库逻辑备份。</p><p><em>优化</em></p><ul><li>问题：锁时无法执行修改业务</li><li>解决：通过MVCC解决，即开启可重复读的隔离级别，在事务中进行备份： <code>mysqldump –single-transaction</code></li></ul><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><h5 id="Table-Locks"><a href="#Table-Locks" class="headerlink" title="Table Locks"></a>Table Locks</h5><p><em>使用</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><span class="hljs-operator">-</span> 表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br><span class="hljs-operator">-</span> 释放当前会话所有表锁<br>unlock tables<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><code>unlock tables</code>语句会释放当前会话的所有锁，另一种锁释放的情形是加锁的会话断开。</p>          </div><h5 id="Meta-Data-Locks"><a href="#Meta-Data-Locks" class="headerlink" title="Meta-Data Locks"></a>Meta-Data Locks</h5><p><em>使用</em><br>一般不需要显示的使用 MDL（元数据锁），因为对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是<strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是<strong>MDL 写锁</strong>；</li><li>事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</li></ul><p><em>范围与目的</em><br>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。同理，对表结构进行操作时，阻塞CRUD操作。</p><h5 id="IS-x2F-IX-Locks"><a href="#IS-x2F-IX-Locks" class="headerlink" title="IS&#x2F;IX Locks"></a>IS&#x2F;IX Locks</h5><p><em>使用</em><br>意向锁是一种表锁，在对某表的记录加锁前先对该表加上意向锁。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="hljs-function"><span class="hljs-title">select</span></span> ... lock in share mode;<br><br><span class="hljs-comment">//先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="hljs-function"><span class="hljs-title">select</span></span> ... <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure><p><em>范围与目的</em><br>意向锁是一种表锁，在对某表的记录加锁前先对该表加上意向锁，想加<strong>表锁</strong>的事务可以通过查看本表有没有意向锁判断是否有其他事务已经加了<strong>行锁</strong>。</p><ul><li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li><li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li></ul><p><em>互斥性</em><br>IS锁和IX锁是兼容的：表示有事务在对表进行读、写（不是同一行）。</p><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h5 id="AUTO-INC-Locks"><a href="#AUTO-INC-Locks" class="headerlink" title="AUTO-INC Locks"></a>AUTO-INC Locks</h5><p><em>使用</em><br>主键设置为AUTO-INC后，插入记录时会自动使用AUTO-INT锁。</p><p><em>范围与目的</em><br>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。<strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p><em>优化</em></p><ul><li>问题：AUTO-INC 锁在对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</li><li>解决：在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增，在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</li><li>配置方式： 使用<code>innodb_autoinc_lock_mode</code>系统变量进行配置：<ul><li>0：为默认AUTO-INC锁</li><li>1：普通 insert 语句为轻量级锁，类似 insert … select 这样的批量插入数据的语句为AUTO-INC锁。</li><li>2：为轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li></ul></li><li>新的问题：当 <code>innodb_autoinc_lock_mode</code> &#x3D; 2 是性能最高的方式，但是当搭配 binlog 的日志格式 <strong>statement</strong> 一起使用的时候，在「主从复制的场景」中会发生<strong>数据不一致的问题</strong>。因为binlog只会记录原始语句，且从库在执行时会一个session事务一个session事务的执行，即不会像主库需要处理两个session的并发操作，这会导致从库id与主库id不一致。</li><li>新的解决：将binlog的日志格式配置为<strong>row</strong>即可。</li></ul><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><h5 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h5><p>即<strong>快照读</strong>，使用：<code>SELECT ...</code></p><h5 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h5><p>读操作：<strong>当前读</strong>，分为S锁和X锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> S锁：对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-operator">-</span> X锁：对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>写操作：</p><ul><li>INSERT：不加锁，但使用<strong>隐式锁</strong>保证新增记录在提交前无法被访问。</li><li>DELETE：X锁</li><li>UPDATE：<ul><li>原地更新字段时（长度无变化）：X锁</li><li>删除新增字段时（长度有变化）：先后执行<code>DELETE</code>和<code>INSERT</code>。</li><li>更新主键时：先后执行<code>DELETE</code>和<code>INSERT</code>。</li></ul></li></ul><h5 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h5><p>只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象，加锁后其他事务无法在锁记录前面的区间<code>(3，8)</code>插入新记录。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a5ddeea09f4b64_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>通过将锁放置在页面的最大记录上，即锁住了区间<code>(20,+∞)</code>，其他事务就不能插入新记录了。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd4244481b96_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是<strong>兼容</strong>的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。</p><h5 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h5><p>相当于<code>Record Locks</code>+<code>Gap Locks</code>，锁住了区间<code>(3,8]</code></p><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd42446ce8b5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><code>next-key lock</code> 是包含<strong>记录锁</strong>的，所以如果一个事务获取了 X 型的 <code>next-key lock</code>，那么另外一个事务在获取相同范围的 X 型的 <code>next-key lock</code> 时是会被<strong>阻塞</strong>的。</p><h5 id="Insert-Intention-Locks"><a href="#Insert-Intention-Locks" class="headerlink" title="Insert-Intention Locks"></a>Insert-Intention Locks</h5><p><code>Insert Intention Locks</code>：插入意向锁，事务在插入时被<code>gap lock</code>或者<code>next-key lock</code>阻塞，则生成一个<code>Insert Intention Locks</code>锁，其主要起唤醒作用。</p><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd424353495e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a72bf8133eb1dc_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><p>如果某事务A插入记录时，另一个事务B要读取这个记录，会产生冲突（此时初始化未完成）。</p><ul><li>对于聚簇索引，事务B发现记录的trx_id（即事务A）处于活跃状态时，会为事务A创建一个X锁，并为自己创建一个X锁，等待事务A释放X锁后，事务B即可访问新插入的数据。</li><li>对于二级索引，由于二级索引的记录不包含事务ID，因此通过Page Header中的<code>PAGE_MAX_TRX_ID</code>属性判断最后修改该页面的事务是否是已提交状态（与当前活跃事务的最小id对比），如果均已提交，则说明不存在冲突，否则需要回到聚簇索引进行判断。</li></ul><h3 id="锁的使用规则"><a href="#锁的使用规则" class="headerlink" title="锁的使用规则"></a>锁的使用规则</h3><h4 id="锁类型的使用场景"><a href="#锁类型的使用场景" class="headerlink" title="锁类型的使用场景"></a>锁类型的使用场景</h4><ul><li>在读已提交隔离级别下，行级锁的种类只有<strong>记录锁</strong></li><li>在可重复读隔离级别下，行级锁的种类除了有<strong>记录锁</strong>，还有<strong>间隙锁</strong>以及<strong>Next Key锁</strong>。</li></ul><h3 id="锁的获取与释放"><a href="#锁的获取与释放" class="headerlink" title="锁的获取与释放"></a>锁的获取与释放</h3><p>在 MySQL 中，行锁的获取和释放是自动进行的。当我们执行一条语句时，MySQL 会根据需要自动获取行锁，并在事务结束或者提交时自动释放行锁。行锁的获取和释放是基于事务的，只有在事务中操作的行才会被锁定。</p><h4 id="RR模式下的锁退化"><a href="#RR模式下的锁退化" class="headerlink" title="RR模式下的锁退化"></a>RR模式下的锁退化</h4><p><strong>加锁的对象是索引，RR模式下加锁的基本单位是 next-key lock</strong>。<br>next-key lock是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。但是，next-key lock 在一些场景下会退化成记录锁或间隙锁：<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。</p><h5 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h5><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成<strong>记录锁</strong>。</li><li>当查询的记录是「不存在」的，在索引树找到<strong>第一条</strong>大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成<strong>间隙锁</strong>。（部分解决幻读问题，查询不到某记录时，不允许其他事务再插入该记录）</li></ul><blockquote><p>例子：表中id有1,5,6时，查询id &#x3D; 2的记录时，会锁住<code>(1,5)</code>开区间。</p></blockquote><h5 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h5><p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁</strong>：</p><ul><li>情况一：针对「大于」的范围查询：<ul><li>命中大于条件的索引（包括最大索引）加 <strong>next-key 锁</strong>。</li></ul></li><li>情况二：针对「大于等于」的范围查询：<ul><li>命中大于条件的索引（包括最大索引）加 <strong>next-key 锁</strong>。</li><li>命中等于条件的索引的 next-key 锁会退化成<strong>记录锁</strong>。</li></ul></li><li>情况三：针对「小于」的范围查询：<ul><li>命中小于条件&#x2F;等于条件的索引加 <strong>next-key 锁</strong>。</li><li>恰好大于该条件的第一个索引或最大索引加<strong>间隙锁</strong>。</li></ul></li><li>情况四：针对「小于等于」的范围查询：<ul><li>命中小于条件的索引加 <strong>next-key 锁</strong>。</li><li>若命中等于条件的索引存在，对其加 <strong>next-key 锁</strong>。（这是因为主键的唯一性，在该索引上加next-key即满足要求）；若不存在，则恰好大于该条件的第一个索引或最大索引加<strong>间隙锁</strong>。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230921214706.png"></p><h5 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h5><ul><li>当查询的记录是「存在」时：<ul><li>命中等于条件的二级索引加 <strong>next-key 锁</strong>。</li><li>恰好大于该条件的第一个二级索引或最大二级索引加<strong>间隙锁</strong>。</li><li>对命中的记录的主键索引加 <strong>记录锁</strong>。</li></ul></li><li>当查询到的记录「不存在」时：<ul><li>恰好大于该条件的第一个二级索引或最大二级索引加<strong>间隙锁</strong>。</li></ul></li></ul><h5 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h5><p>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况，即：</p><ul><li>命中查询条件的二级索引（包括最大索引）加 <strong>next-key 锁</strong>。</li><li>对命中的记录的主键索引加 <strong>记录锁</strong>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230921214717.png"></p><div class="note note-primary">            <p><strong>读锁如果不涉及回表操作，不会对聚簇索引进行加锁</strong>：</p><ul><li>for update 加的是写锁，写锁默认认为会对数据做更改，不管查询有没有涉及到回表都会对聚簇索引(主键索引)加锁；</li><li>lock in share model 加的是读锁，如果没有涉及到回表（像覆盖索引），不会对聚簇索引(主键索引)加锁。</li></ul>          </div><h5 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="没有加索引的查询"></a>没有加索引的查询</h5><p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</strong></p><div class="note note-primary">            <p>在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了。<br>虽然这看起来效果和表锁类似，但其本质上还是若干行锁的叠加，不是真正的表锁（有文章说未命中索引会加表锁，结果测试，发现加的是行锁）</p>          </div><div class="note note-success">            <p>可以通过以下方式检查锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 查看InnoDB引擎的详细信息，找Transaction处：<br><span class="hljs-keyword">SHOW</span> ENGINE INNODB STATUS;<br><span class="hljs-operator">-</span> 查看当前被锁定的表信息：<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.innodb_locks;<br></code></pre></td></tr></table></figure>          </div><h4 id="如何避免锁全表"><a href="#如何避免锁全表" class="headerlink" title="如何避免锁全表"></a>如何避免锁全表</h4><p><em>问题</em><br>在 update、delete、select … for update 语句的 where 条件没有使用索引，就会全表扫描。即使使用了索引，也不一定会走索引，其关键还得看这条语句在执行过程中，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p><p><em>解决</em></p><ol><li>将 MySQL 里的 <code>sql_safe_updates</code> 参数设置为 1，<ul><li>update 语句必须满足如下条件之一才能执行成功：<ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>使用 limit；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul></li><li>delete 语句必须满足以下条件能执行成功：<ul><li>使用 where，并且 where 条件中必须有索引列；</li><li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li></ul></li></ul></li><li>如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><em>死锁检测</em><br>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。可以通过下面的指令查看死锁<code>show engine innodb status</code></p><p><em>死锁解除</em></p><ul><li>超时等待，事物超时自动回滚(innodb_lock_wait_timeout 默认50s)</li><li>主动死锁检测，事物请求锁的时候采用 wait-for graph 等待图的方式进行死锁检测（innodb_deadlock_detect 默认on）</li><li>发现死锁也可以人为 kill 进程</li></ul><p><em>各种锁发生死锁的情况</em></p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><blockquote><p><a href="https://juejin.cn/post/7200264747450531897">图解+示例，彻底把 MySQL锁搞懂了！</a></p></blockquote><h3 id="InnoDB锁结构"><a href="#InnoDB锁结构" class="headerlink" title="InnoDB锁结构"></a>InnoDB锁结构</h3><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a68cda54348429_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>事务信息：事务的指针</li><li>索引信息：加锁记录所属的索引</li><li>表锁／行锁信息：<ul><li>标记锁了哪个表：SpaceID</li><li>哪个表哪行记录：SpaceID,PageNumber,n_bits(一个数量，以便后面通过bit位标记页内哪些行加了锁)</li></ul></li><li>type_mode：这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：<ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。</li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。</li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。</li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。</li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在<code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。</li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。</li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示<code>正经记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。</li><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：也就是当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a864f3298df751_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>其他信息：为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</li><li>一堆比特位：数量由行锁信息的<code>n_bits</code>属性决定，每bit与页内记录的heap_no对应</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a69c2f7b413698_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="并发控制技术"><a href="#并发控制技术" class="headerlink" title="并发控制技术"></a>并发控制技术</h2><p>从宽泛意义上讲，目前有三种并发控制技术：</p><ul><li>悲观并发控制(PCC)：心态悲观，假定多用户并发的事物在处理时都会引起并发冲突，每次操作数据的时候都会上锁。先取锁再访问的策略，为数据的安全提供了保证，但是加锁会产生额外的开销，增加死锁的机会，只读型事物不会产生冲突也不需要加锁。</li><li>乐观并发(OCC)：心态乐观，假定多用户并发的事物在处理时不会彼此互相影响，只在提交时检查有没有其它事物修改了该数据可以获得更大的吞吐量，但是发生冲突事物就会回滚重新执行。</li><li>多版本并发(MVCC)：每个写操作都会创建一个新版本的数据，读操作根据可见性规则返回其中一个数据快照读 - 写冲突不加锁，非阻塞读的同时避免了脏读和不可重复读，但需要管理和挑选数据版本。</li></ul><p><strong>注意</strong>：</p><ul><li>MVCC不是与悲观、乐观并发控制对立的，很直观的一点MVCC可以在不加锁的情况下解决读-写冲突，并不能解决写-写冲突，写操作还是需要上锁</li><li>MVCC可以与悲观并发或乐观并发结合使用来提高并发的性能</li></ul><h3 id="事务隔离级别实现"><a href="#事务隔离级别实现" class="headerlink" title="事务隔离级别实现"></a>事务隔离级别实现</h3><p>事务隔离级别，其本质是并发事务之间可见性的等级，其重点在于多次读的结果是否一致：读行为会根据隔离级别有不同的实现。</p><p><code>MVCC</code>和<code>锁</code>则是实现事务隔离级别的手段：</p><ul><li>普通读：InnoDB通过MVCC实现了RC和RR，其通过读版本链中的数据避免对记录加锁产生的消耗（本质上是<strong>弱一致性读</strong>，也叫快照读，写操作依然需要<strong>一致性读</strong>）。</li><li>当前读：通过锁阻止其他事务对记录的更改（保证<strong>一致性</strong>，随着隔离级别的升高，使用的锁也不同）</li><li>写操作：<strong>除了Serializable，所有隔离级别都会上表级IX锁和行级记录X锁，事务提交后才释放</strong></li></ul><h4 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h4><p><em>实现</em><br>普通读时：无锁快照读，读最新值<br><em>性能</em><br>性能最好，但不会比其他级别好很多。<br><em>实用性</em><br>若事务回滚，其他事务会读到错误的信息，因此除非真的有必要，否则<strong>很少使用</strong>。</p><h4 id="Read-Commited"><a href="#Read-Commited" class="headerlink" title="Read Commited"></a>Read Commited</h4><p><em>实现</em></p><ul><li>普通读时：通过MVCC方式解决<strong>脏读</strong>，在事务中每一个查询语句执行时生成一个ReadView。</li><li>当前读时：通过<strong>记录锁</strong>解决了<strong>脏读&amp;不可重复读</strong>，此时其他事务要修改该记录会失败。</li></ul><p><em>性能</em><br>性能较好，<strong>半一致性读</strong>特性增加了update操作的<strong>并发性</strong>。</p><p><em>半一致性读</em><br>semi-consistent read是read committed与consistent read两者的结合：</p><ul><li>原理：执行update语句时：如果读到一行已经加锁的记录（可能其他事务正在更新），此时InnoDB返回记录最近<strong>提交的版本</strong>，由MySQL上层判断此版本是否满足update的where条件：<ul><li>若满足，则MySQL会重新发起一次读操作，此时会读取该行的最新版本并加锁等待。</li><li>若不满足，说明该记录加锁前就不满足条件，此时不会加锁。</li></ul></li><li>优点：减少同一行记录的锁冲突及锁等待；</li><li>条件：半一致读只会发生在RC隔离级别下，或者是参数<code>innodb_locks_unsafe_for_binlog</code>被设置为true时。</li><li>其他：<code>innodb_locks_unsafe_for_binlog</code> 参数在 8.0 版本中已被去除（可见，这是一个可能会导致数据不一致的参数，官方也不建议使用了）。</li></ul><blockquote><p>半一致性读基于一种假设：当前被加锁的记录如果之前不符合where条件，之后应该也不符合，所以对其进行了忽略。但该假设并不总是成立，在RC下，需要业务理解好半一致读的特性避免漏更新（即本质上两个事务按照不同的顺序执行时结果不一样）。因此也要避免使用statement模式的binlog，其会导致主从不一致。</p></blockquote><p><em>实用性</em><br>实用性较好，是大多数数据库的默认隔离级别。</p><h4 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h4><p><em>实现</em></p><ul><li>普通读时：通过MVCC方法解决了<strong>脏读、不可重复读</strong>，在事务中的<strong>第一个查询语句</strong>（事务真正开启的时点）时会生成一个ReadView。</li><li>当前读时：<strong>通过 next-key lock（记录锁+间隙锁）</strong> 方式解决了<strong>不可重复读&amp;大部分幻读</strong>，此时其他事务要在间隙锁的范围内插入记录会失败。</li></ul><p><em>性能</em><br>当前读时存在<strong>间隙锁</strong>，导致出现死锁的几率比RC大的多，且未命中索引会锁表！</p><p><em>未完全解决的幻读</em><br>当某个事务先对一个不存在的记录做<strong>普通读</strong>，后对该记录（已经被其他事务插入并提交）做<strong>当前读</strong>时，则会出现幻读。</p><p><em>实用性</em><br>可以解决幻读，但性能没有RC好，是MySQL（InnoDB）的默认数据库事务级别。</p><h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p><em>实现</em><br>不再支持快照读，所有普通<code>select</code>语句都会被隐式的转化为<code>select ... in share mode</code>，保证读写操作串行化运行，从而达到该级别的要求。</p><p><em>实用性</em><br>并发性能较低，实用性较差</p><h3 id="隔离级别比较"><a href="#隔离级别比较" class="headerlink" title="隔离级别比较"></a>隔离级别比较</h3><p><em>为什么大多数企业应用使用RC而不是RR？</em></p><ul><li>在RR隔离级别下，会产生间隙锁，这样在频繁的插入、更新过程中更容易产生锁等待。</li><li>在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行！</li><li>在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性！</li></ul><p>在真实业务场景下，幻读很少会成为影响业务的问题，如果一致性要求没那么强，可以使用提交读以提高并发性。</p><p><em>为什么Mysql默认使用RR？</em><br>binlog有几种格式：</p><ul><li>statement：记录的是修改SQL语句</li><li>row：记录的是每行实际数据的变更</li><li>mixed：statement和row模式的混合</li></ul><p>RC 隔离级别不支持 statement 格式的bin log，该格式的复制会导致主从数据的不一致，这也是为什么MySQL默认使用RR隔离级别的原因。<strong>复制时最好使用：binlog_format&#x3D;row</strong>。</p><h1 id="六、bin-log"><a href="#六、bin-log" class="headerlink" title="六、bin log"></a>六、bin log</h1><h3 id="redo-log与bin-log一致性"><a href="#redo-log与bin-log一致性" class="headerlink" title="redo log与bin log一致性"></a>redo log与bin log一致性</h3><p>橙色的流程在<code>InnoDB</code>内部执行，蓝色的部分在<code>MySQL Server</code>层的执行器中执行。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230928172633.png"></p><ul><li>Point A：如果服务器异常关闭发生在Point A以及之前的时间点，这个时候redolog 和 binlog都没有任何记录，事务还未提交，不会造成任何影响。</li><li>Point B：当服务器启动的时候发现redo log里处于prepare状态的记录，这个时候需要检查binlog是否完整包含此条redo log的更新内容（通过全局事务ID对应），发现binlog中还未包含此事务变更，则丢弃此次变更。</li><li>Point C：和Point B基本相同，只不过此时发现binlog中包含redo log的更新内容，此时事务会进行提交。</li><li>Point D：binlog中和数据库中均含有此事务的变更，没有任何影响。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（查询与优化）</title>
    <link href="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <url>/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单表访问"><a href="#一、单表访问" class="headerlink" title="一、单表访问"></a>一、单表访问</h1><h2 id="访问方法（access-method）"><a href="#访问方法（access-method）" class="headerlink" title="访问方法（access method）"></a>访问方法（access method）</h2><p>Mysql中查询的执行方式大致分两种：</p><ul><li>使用全表扫描进行查询</li><li>使用索引进行查询（使用xx索引的xx查询）</li></ul><p>访问方法分类：</p><ul><li>all：全表查询</li><li>system：该表只有一行（系统表）</li><li>const：命中主键(primary key)或者唯一索引(unique) 且被连接的部分是一个常量值(const)</li><li>ref：使用<strong>非唯一性索引</strong>或者唯一索引的前缀扫描</li><li>eq_ref：类似ref，区别就在使用的索引是<strong>唯一索引</strong></li><li>ref_or_null：二级索引 &#x3D; 常数 或 二级索引 &#x3D; null</li><li>range：利用索引进行范围查询</li><li>index：不用回表的二级索引搜索</li><li>index merge：使用到多个索引来完成一次查询</li></ul><h3 id="range优化"><a href="#range优化" class="headerlink" title="range优化"></a>range优化</h3><ul><li>多range合并</li><li>对于<code>range and 其他条件</code>，先根据range确定范围（将其他搜索条件替换为true，之后在筛选)。</li></ul><h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index merge"></a>index merge</h3><ul><li>Intersection合并，分别使用索引确定备选，然后取交集，出现以下情况才<strong>可能</strong>这样执行：<ul><li>情况一：二级索引列是等值匹配的情况。</li><li>情况二：主键列可以是范围匹配</li></ul></li><li>Union合并，分别使用索引确定备选，然后取并集，出现以下情况才<strong>可能</strong>这样执行：<ul><li>情况一：二级索引列是等值匹配的情况</li><li>情况二：主键列可以是范围匹配</li><li>情况三：与<code>Intersection的筛选结果</code>取并集</li></ul></li><li>Sort-Union合并，两个二级索引搜索结果先按照主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并。</li></ul><blockquote><p>注意：往往应该使用联合索引替代Intersection索引合并，即一个索引完成了两个列的范围搜索。</p></blockquote><h1 id="二、连接的原理"><a href="#二、连接的原理" class="headerlink" title="二、连接的原理"></a>二、连接的原理</h1><h2 id="连接本质"><a href="#连接本质" class="headerlink" title="连接本质"></a>连接本质</h2><p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户，如下，这样的结果集称为<code>笛卡尔积</code>。<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3feccc29_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><p><em>驱动表</em><br>第一个需要查询的表，这个表称之为<code>驱动表</code>。<br><em>被驱动表</em><br>使用<code>驱动表中的搜索结果</code>，每条记录都对<code>被驱动表</code>进行一次搜索，过滤得到满足连接的结果。</p><p><em>eg:</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2 <span class="hljs-keyword">WHERE</span> t1.m1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> t1.m1 <span class="hljs-operator">=</span> t2.m2 <span class="hljs-keyword">AND</span> t2.n2 <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;d&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3a02660b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p></blockquote><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><ul><li>对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录<strong>不会</strong>加入到最后的结果集。</li><li>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也<strong>仍然会</strong>加入到结果集。在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：<ul><li>左外连接：选取左侧的表为驱动表。</li><li>右外连接：选取右侧的表为驱动表。</li></ul></li></ul><h2 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h2><p>通用的两表连接过程如下图所示：<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3fa0f107_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上面过程。</p><blockquote><p>这是最简单和笨拙的连接查询算法。</p></blockquote><h3 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h3><p>加速连接查询主要是要加速被驱动表的查询。</p><ul><li>参考单表查询中索引的使用，建立合适的索引避免对被驱动表全表扫描。</li><li>为了避免被驱动表反复被加载到内存中，使用join buffer：<ul><li>执行连接查询前申请一块固定大小的内存，先把若干条<strong>驱动表结果集</strong>中的记录装在这个<code>join buffer</code>中</li><li>然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配</li></ul></li></ul><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3e5fa2f6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><blockquote><p>驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>。</p></blockquote><h1 id="三、查询成本优化"><a href="#三、查询成本优化" class="headerlink" title="三、查询成本优化"></a>三、查询成本优化</h1><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><p><code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p><ul><li><code>I/O</code>成本</li><li><code>CPU</code>成本</li></ul><p><em>成本常数</em></p><ul><li>读取一个页面花费的成本默认是<code>1.0</code>。</li><li>读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。</li></ul><h2 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h2><p>过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引（包括是否能使用联合索引）执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><h3 id="全表扫描成本计算"><a href="#全表扫描成本计算" class="headerlink" title="全表扫描成本计算"></a>全表扫描成本计算</h3><p>由于查询成本&#x3D;<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>I/O成本<br>聚簇索引页数 * <span class="hljs-number">1.0</span> + <span class="hljs-number">1.1</span><br><span class="hljs-regexp">//</span>CPU成本<br>rows * <span class="hljs-number">0.2</span> + <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="索引查询成本的代价"><a href="#索引查询成本的代价" class="headerlink" title="索引查询成本的代价"></a>索引查询成本的代价</h3><p><em>范围搜索</em><br>查询优化器粗暴的认为读取索引的<strong>一个范围区间</strong>的<code>I/O</code>成本和读取一个页面是相同的。</p><ul><li>对于范围搜索如<code>IN</code>，会预估rows：<ul><li>先获取<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，在统计两者之间的记录数量（<code>index dive</code>）</li><li>IN中参数过多（多于200）时，会使用基数估算索引。</li></ul></li></ul><p><em>使用索引处理对于range类型的查询条件</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>I/O成本<br><span class="hljs-regexp">//</span>根据索引搜索一个范围<br><span class="hljs-number">1.0</span><br><span class="hljs-regexp">//</span>回表<br>rows * <span class="hljs-number">1.0</span><br><br><span class="hljs-regexp">//</span>CPU成本<br><span class="hljs-regexp">//</span>读取二级索引<br>rows * <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span><br><span class="hljs-regexp">//</span>读取聚簇索引<br>rows * <span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><h2 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h2><p>查询成本由下边两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code><br>两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>全表扫描时，猜满足搜索条件的记录到底有多少条。</li><li>索引扫描，猜满足除索引搜索条件外的其他搜索条件的记录有多少条。</li></ul><h3 id="两表连接的成本分析"><a href="#两表连接的成本分析" class="headerlink" title="两表连接的成本分析"></a>两表连接的成本分析</h3><p>内连接时，分析不同驱动表的情形，重点优化查询被驱动表的成本。</p><h3 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h3><p>多表时，可能的搜索策略过多，MySQL有以下方法减少计算连接顺序的成本：</p><ul><li>提前结束某种顺序的成本评估：如果某次计算已经大于其他执行方式的成本，提前结束。</li><li>系统变量<code>optimizer_search_depth</code>：连接表大于该值时，只对该值数量的表进行穷举分析。</li><li>根据某些规则不考虑某些连接顺序：<code>启发式规则</code>，就是使用经验。</li></ul><h2 id="调节成本常数"><a href="#调节成本常数" class="headerlink" title="调节成本常数"></a>调节成本常数</h2><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>成本常数被存在mysql数据库中的server_cost表和engine_cost表中。</p><h1 id="四、统计数据的收集"><a href="#四、统计数据的收集" class="headerlink" title="四、统计数据的收集"></a>四、统计数据的收集</h1><h2 id="两种的统计数据存储方式"><a href="#两种的统计数据存储方式" class="headerlink" title="两种的统计数据存储方式"></a>两种的统计数据存储方式</h2><ul><li>永久性的统计数据：存硬盘</li><li>非永久性的统计数据：存内存</li></ul><p><code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，通过修改表可调整策略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (...) Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>); <br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="基于磁盘的永久性统计数据"><a href="#基于磁盘的永久性统计数据" class="headerlink" title="基于磁盘的永久性统计数据"></a>基于磁盘的永久性统计数据</h3><p>统计数据存储到了两个表里，都位于<code>mysql</code>系统数据库，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><h4 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h4><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>database_name</td><td>数据库名</td></tr><tr><td>table_name</td><td>表名</td></tr><tr><td>last_update</td><td>本条记录最后更新时间</td></tr><tr><td>n_rows</td><td>表中记录的条数</td></tr><tr><td>clustered_index_size</td><td>表的聚簇索引占用的页面数量</td></tr><tr><td>sum_of_other_index_sizes</td><td>表的其他索引占用的页面数量</td></tr></tbody></table><blockquote><p>n_rows是估计值</p></blockquote><h4 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h4><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>database_name</td><td>数据库名</td></tr><tr><td>table_name</td><td>表名</td></tr><tr><td>index_name</td><td>索引名</td></tr><tr><td>last_update</td><td>本条记录最后更新时间</td></tr><tr><td>stat_name</td><td>统计项的名称</td></tr><tr><td>stat_value</td><td>对应的统计项的值</td></tr><tr><td>sample_size</td><td>为生成统计数据而采样的页面数量</td></tr><tr><td>stat_description</td><td>对应的统计项的描述</td></tr></tbody></table><h4 id="定期更新统计数据"><a href="#定期更新统计数据" class="headerlink" title="定期更新统计数据"></a>定期更新统计数据</h4><ul><li><code>innodb_stats_auto_recalc</code>：系统变量。默认为开启状态，当发送变动的记录超过表大小的10%，即重新计算。</li><li><code>ANALYZE TABLE</code>：手动调用命令，重新计算。</li></ul><h3 id="基于内存的非永久性统计数据"><a href="#基于内存的非永久性统计数据" class="headerlink" title="基于内存的非永久性统计数据"></a>基于内存的非永久性统计数据</h3><p>非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><h4 id="innodb-stats-method"><a href="#innodb-stats-method" class="headerlink" title="innodb_stats_method"></a>innodb_stats_method</h4><p>是一个系统变量，设置对于<code>允许NULL的索引列</code>的基数计算策略：</p><ul><li><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。</li><li><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</li><li><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</li></ul><h1 id="五、基于规则优化"><a href="#五、基于规则优化" class="headerlink" title="五、基于规则优化"></a>五、基于规则优化</h1><h2 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h2><ul><li>基本语句：移除不必要的括号、移除没用的条件、常量传递、等值传递、表达式计算（必须是常量类型简单表达式，不支持函数类型和复杂表达式）。</li><li>条件合并：HAVING子句和WHERE子句的合并：没有出现聚集函数时，合并HAVING子句和WHERE子句。</li><li>常量表检测：表中只有一条数据或使用主键等值匹配的子句，优先执行。</li></ul><h2 id="外连接消除"><a href="#外连接消除" class="headerlink" title="外连接消除"></a>外连接消除</h2><p>WHERE子句中指定<code>被驱动表</code>的 <code>连接列</code> 不为NULL，则变成了内连接。</p><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><h3 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h3><p><em>按查询结果分类</em></p><ul><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ul><p><em>按与外层查询关系分类</em></p><ul><li>不相关子查询：子查询可以独立运行</li><li>相关子查询：子查询的执行需要依赖于外层查询的值（一般表现为子查询中有带有外层表的条件）</li></ul><p><em>子查询语法注意事项</em></p><ul><li>子查询必须用小括号扩起来。</li><li>在<code>SELECT</code>子句中的子查询必须是标量子查询。</li><li>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。（没有原因，InnoDB当前就是这样规定的）</li><li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li></ul><h3 id="子查询在MySQL中执行方式"><a href="#子查询在MySQL中执行方式" class="headerlink" title="子查询在MySQL中执行方式"></a>子查询在MySQL中执行方式</h3><p><em>原始子查询方式</em></p><ul><li>不相关子查询：先执行子查询，然后将结果作为外层参数。</li><li>相关子查询：对驱动表的每条记录执行一次子查询。</li></ul><h4 id="标量子查询、行子查询"><a href="#标量子查询、行子查询" class="headerlink" title="标量子查询、行子查询"></a>标量子查询、行子查询</h4><p>标量子查询或者行子查询，无论是否相关，查询方式都为原始的子查询方式。</p><h4 id="IN子查询优化（列子查询）"><a href="#IN子查询优化（列子查询）" class="headerlink" title="IN子查询优化（列子查询）"></a>IN子查询优化（列子查询）</h4><h5 id="物化表"><a href="#物化表" class="headerlink" title="物化表"></a>物化表</h5><p><em>物化表定义</em><br>将不相关子查询的结果集写入一个临时表（基于内存使用<code>Memory</code>存储引擎，使用哈希索引并自动去重，如果太大了就会转而使用磁盘和B+树存储），这个表叫做<strong>物化表</strong>。</p><p><em>物化表转连接</em><br>将物化表转化成内连接，此时可以根据成本选择使用外部表或物化表作为驱动表执行连接操作。</p><h5 id="semi-join"><a href="#semi-join" class="headerlink" title="semi-join"></a>semi-join</h5><p><em>semi-join定义</em><br><code>semi-join</code>只是在MySQL内部采用的一种执行子查询的方式，其目的是在不生成物化表的情况上实现内连接。<br>直接连接还需要解决去重问题，因为实际上IN子句查询只需要判断被驱动表中有否有与驱动表记录匹配的行即可，其无需关心被驱动表中有多少行与之匹配，而这种只判断存在匹配值，而不判断具体匹配行数量的连接就是半连接<code>semi-join</code>。</p><p><em>实现方式</em></p><ul><li>Table pullout （子查询中的表上拉）：连接列是被驱动表的<strong>唯一索引</strong>时，直接连接；</li><li>DuplicateWeedout execution strategy （重复值消除）：使用临时表对驱动表记录做去重（即每个驱动表记录只匹配一次）；</li><li>LooseScan execution strategy （松散扫描）：子查询排序后做驱动表，使用其结果扫描主表的各行结果是否满足条件，由于对子查询结果做了排序，相邻的相同的索引直接进行忽略；</li><li>Semi-join Materialization execution strategy：即物化表的方式；</li><li>FirstMatch execution strategy （首次匹配）：原始子查询方式，但只做首次匹配。</li></ul><div class="note note-primary">            <p>相关子查询无法使用物化表的方式执行。</p>          </div><h5 id="semi-join使用条件"><a href="#semi-join使用条件" class="headerlink" title="semi-join使用条件"></a>semi-join使用条件</h5><p><em>适用情况</em></p><ul><li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li><li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li><li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li><li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li></ul><p><em>不适用情况</em></p><ul><li>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来</li><li>使用<code>NOT IN</code>而不是<code>IN</code>的情况</li><li>在<code>SELECT</code>子句中的IN子查询的情况</li><li>子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况</li><li>子查询中包含<code>UNION</code>的情况</li></ul><h5 id="兜底策略"><a href="#兜底策略" class="headerlink" title="兜底策略"></a>兜底策略</h5><ol><li>不相关子查询：物化表查询</li><li>把<code>IN</code>子查询尝试转为<code>EXISTS</code>子查询</li></ol><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>满足转换为<code>semi-join</code>的条件时，查询优化器会优先把该子查询转换为<code>semi-join</code>，然后再考虑下边5种执行半连接的策略中哪个成本最低。</li><li>不满足转换<code>semi-join</code>的条件时，查询优化器会从下边<strong>两种策略</strong>中找出一种成本更低的方式执行子查询：<ul><li>先将子查询物化之后再执行查询</li><li>执行<code>IN to EXISTS</code>转换，<strong>转化后可能可以使用索引</strong></li></ul></li></ul><p>任意一个IN子查询都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">outer_expr <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where)<br><span class="hljs-comment">--可转化为：</span><br><span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where <span class="hljs-keyword">AND</span> outer_expr<span class="hljs-operator">=</span>inner_expr)<br></code></pre></td></tr></table></figure><h4 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY&#x2F;ALL子查询优化"></a>ANY&#x2F;ALL子查询优化</h4><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr …)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr …)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h4 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a><code>[NOT] EXISTS</code>子查询的执行</h4><ul><li>对于不相关子查询，先执行子查询，查出来true&#x2F;false结果后重写原语句</li><li>对于相关子查询，只能使用原始子查询</li></ul><h4 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h4><p><em>派生表的定义</em><br>子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code></p><div class="note note-primary">            <p>列子查询结果叫<strong>物化表</strong><br>表子查询结果叫<strong>派生表</strong></p>          </div><p><em>派生表优化</em></p><ul><li>派生表物化：将派生表物化为一个临时表。</li><li>派生表合并：将派生表与外层查询的表连接，并将派生表的查询条件也移动至外层的查询条件。（当派生表有一些特殊函数或处理时，不能使用派生表合并）。</li></ul><h1 id="六、Explain"><a href="#六、Explain" class="headerlink" title="六、Explain"></a>六、Explain</h1><p><code>EXPLAIN</code>是一个语句，能帮助我们查看查询语句的执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>输出结果的各列：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><ul><li>id，查询语句中每出现一个<code>SELECT</code>关键字，设计<code>MySQL</code>的大叔就会为它分配一个唯一的<code>id</code>值。<ul><li>若被转化为连接则与驱动表查询SELECT的id相同。</li><li>若创建了临时表，则临时表的id为null。</li></ul></li><li>select_type：<ul><li>SIMPLE：独立查询</li><li>PRIMARY：驱动表查询</li><li>UNION：被驱动表查询</li></ul></li><li>type：访问方法，如const,ref</li><li>filtered：估算满足驱动表查询条件的结果占比，用于估计扇出</li><li>Extra：一些可并列的额外信息</li></ul><h2 id="JSON格式的执行计划"><a href="#JSON格式的执行计划" class="headerlink" title="JSON格式的执行计划"></a>JSON格式的执行计划</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN FORMAT<span class="hljs-operator">=</span>JSON <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>输出json形式的查询语句执行策略，包括成本计算过程。</p><h2 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h2><p><code>optimizer trace</code>是一个系统变量，开启后可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。</p><p>优化过程大致分为了三个阶段：</p><ul><li><code>prepare</code>阶段</li><li><code>optimize</code>阶段（优化主要在这个阶段）</li><li><code>execute</code>阶段</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL高级（索引）</title>
    <link href="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89/"/>
    <url>/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、MySQL索引类型"><a href="#一、MySQL索引类型" class="headerlink" title="一、MySQL索引类型"></a>一、MySQL索引类型</h1><p><em>按结构分</em></p><ul><li>B+Tree 索引：即B+树索引。</li><li>R-Tree索引：即空间索引，仅支持<code>geometry</code>数据类型，优势在于范围查找。</li><li>S-Full-text索引：即全文索引，通过倒排索引实现。</li><li>Hash索引：不支持范围查询，主要用于内存临时表，实现O(1)时间复杂度的精准查找，对于范围查询、排序及组合索引效率不高。</li></ul><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89/Pasted-image-20230928184121.png"></p><p><em>按性质分</em></p><ul><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有null）</li><li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li><li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>全文索引：对文本的内容进行分词，进行搜索</li><li>前缀索引：在文本类型如BLOB、TEXT或者很长的VARCHAR列上创建索引时，可以使用前缀索引，数据量相比普通索引更小，可以指定索引列的长度，但是数值类型不能指定。</li><li>空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。</li></ul><h1 id="二、全文索引"><a href="#二、全文索引" class="headerlink" title="二、全文索引"></a>二、全文索引</h1><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>全文检索通常使用倒排索引(invertd index)来实现。倒排索引同B+树索引一样，也是一种索引结构。它在辅助表(auxiliary table)中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。</p><ul><li><code>inverted file index</code>, 其表现形式为 {单词，单词所在文档的ID}</li><li><code>full inverted index</code>, 其表现形式为 {单词，(单词所在文档的ID，在具体文档中的位置)}</li></ul><h2 id="InnoDB全文检索"><a href="#InnoDB全文检索" class="headerlink" title="InnoDB全文检索"></a>InnoDB全文检索</h2><p><em>实现</em><br>InnoDB存储引擎采用了 <code>full inverted index</code> 的方式，在 InnoDB存储引擎中，将 （DocumentId, Position）视为一个 “ilist”。因此在全文检索的表中，有两个列，一个是word字段，另一个是 ilist字段， 并且在word字段上设有索引。此外，由于 InnoDB 存储引擎在 ilist 字段中存放了 Position 信息，故可以进行 <code>Proximity Search</code>（邻近检索）。</p><p><em>相关表</em></p><ul><li><code>Auxiliary Table</code>（辅助表）是持久的表，存放于磁盘上，倒排索引需要将 word 字段存放到该表中。InnoDB 存储引擎会批量对 Auxiliary Table 进行更新，而不是每次插入后更新一次<code>Auxiliary Table</code>。</li><li><code>FTS Index Cache</code>（ 全文检索索引缓存表），其用来提高全文检索的性能。是一个红黑树结构，其根据（word, ilist）进行排序。对于InnoDB 存储引擎而言，其总是在事务提交时将分词写入到 <code>FTS Index Cache</code>，然后再通过批量更新写入到磁盘。</li></ul><p><em>FTS Document ID</em><br>在 InnoDB 存储引擎中，为了支持全文检索，有一个索引与word进行映射，在InnoDB 中这个列被命名为 FTS_DOC_ID，其类型必须是 BIGINT UNSIGNED NOT NULL。</p><p><em>索引删除</em><br>文档中分词的插入操作是在事务提交时完成，然而对于删除操作，其在事务提交时，不删除磁盘 Auxiliary Table 中的记录，而只是删除 FTS Index Cache 中的记录，并将其保存在 DELETED auxiliary table 中。在设置参数 innodb_ft_aux_table 后，用户同样可以访问 information_schema 库下的表 INNODB_FT_DELETED 来观察删除的 FTS Document ID。</p><blockquote><p>由于文档的DML 操作实际并不删除索引中的数据，相反还会在对应的DELETED 表中插入记录，因此随着应用程序的允许，索引会变得非常大，即使索引中的有些数据已经被删除，查询也不会选择这类记录。为此，InnoDB 存储引擎提供了一种方式，允许用户手动地将已经存储的记录从索引中彻底删除，该命令是 optimize table。</p></blockquote><p><em>故障恢复</em><br>当数据库关闭时，在 FTS Index Cache 中的数据库会同步到磁盘上的 Auxiliary Table 中。<br>当数据库发生宕机时，一些 FTS Index Cache 中的数据库可能未被同步到磁盘上。那么下次重启数据库时，当用户对表进行全文检索（查询或者插入操作）时，InnoDB 存储引擎会自动读取未完成的文档，然后进行分词操作，再将分词的结果放入到 FTS Index Cache 中。</p><p><em>stopword列表</em><br>该列表中的word 不需要对其进行索引分词操作。</p><p><em>其他限制</em><br>Innodb 存储引擎的全文检索还存在以下的限制：</p><ol><li><strong>每张表只能有一个全文检索的索引</strong></li><li>由多列组合而成的全文检索的索引列必须使用相同的字符集与排序规则。</li><li>不支持没有单词界定符（delimiter）的语言，如中文、日语、韩语等(这一点可以通过自定义分词器ngram来解决，下文有介绍)。</li></ol><h2 id="全文索引使用"><a href="#全文索引使用" class="headerlink" title="全文索引使用"></a>全文索引使用</h2><h3 id="建立全文索引"><a href="#建立全文索引" class="headerlink" title="建立全文索引"></a>建立全文索引</h3><p><em>创建表</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> fulltext (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    title <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>    body TEXT,<br>    FULLTEXT KEY content_fulltext(title,body) <span class="hljs-keyword">WITH</span> PARSER NGRAM<br>)  ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> UTF8;<br></code></pre></td></tr></table></figure><p>以NGRAM（一种中文分词器）为分词器为tile和body创建全文索引。</p><p><em>修改表</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> fulltext index content_fulltext <span class="hljs-keyword">on</span> fulltext_test(title,body);<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> fulltext <span class="hljs-keyword">add</span> fulltext index content_fulltext(title,body);<br></code></pre></td></tr></table></figure><p><em>删除全文索引</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX content_fulltext <span class="hljs-keyword">ON</span> fulltext;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> fulltext <span class="hljs-keyword">DROP</span> INDEX content_fulltext;<br></code></pre></td></tr></table></figure><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h3><p>MySQL数据库支持全文检索（Full-Text Search）的查询，其语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">MATCH</span> (col1, col2,...) AGAINST (expr [search_modifier])<br></code></pre></td></tr></table></figure><p>MATCH指定了需要被查询的列，AGAINST指定了使用何种模式去进行查询。<br><strong>注意：</strong> match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错。</p><h3 id="查询模式"><a href="#查询模式" class="headerlink" title="查询模式"></a>查询模式</h3><p><em>Natural Language模式（默认）</em><br>查找<code>body</code>字段中带有<code>&quot;porridge&quot;</code>的记录，可以替代<code>like &quot;porridge&quot;</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(body) against (<span class="hljs-string">&#x27;porridge&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">natural</span> <span class="hljs-keyword">language</span> mode);<br><span class="hljs-operator">-</span> 也可以简写为<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fts_a <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(body) against (<span class="hljs-string">&#x27;porridge&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在where条件中使用MATCH函数，查询返回的结果是根据相关性（Relevance）进行降序排序的，即相关性最高的结果放在第一位。相关性的值是一个非负的浮点数字，0表示没有任何相关性。根据MySQL官方文档可知，其相关性的计算依据以下四个条件：</p><ol><li>word是否在文档中出现。</li><li>word在文档中出现的次数。</li><li>word在索引列中的数量。</li><li>多少个文档中包含该word。</li></ol><p><em>Boolean模式</em><br>MySQL数据库允许使用 IN BOOLEAN MODE 修饰符来进行全文检索。当使用该修饰符时，查询字符串的前后字符会有特殊的含义。<br>例如下面的语句要求查询有字符串 Pease 但没有 hot 的文档，其中 + 和 - 分别表示这个单词必须出现，或者一定不存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fts_a <span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(body) against (<span class="hljs-string">&#x27;+Pease -hot&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-type">boolean</span> mode)\G;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E9%AB%98%E7%BA%A7%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89/Pasted-image-20230926181718.png"></p><p><em>Query Expansion模式（查询扩展）</em><br>这种查询通常在查询的关键词太短，用户需要implied knowledge（隐含知识）时进行。例如，对于单词database的查询，用户可能希望查询的不仅仅是包含database的文档，可能还指那些包含MySQL、oracle、DB2单词。而这时可以使用Query Expansion模式开启全文检索的implied knowledge。</p><p>通过在查询短语中添加 <code>WITH QUERY EXPANSION</code> 或 <code>IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION</code>可以开启blind query expansion，执行语句和方式如下：</p><ol><li>根据搜索的单词进行全文索引查询。</li><li>根据第一阶段产生的结果分词后再进行一次全文检索查询。</li></ol><blockquote><p><a href="https://zhuanlan.zhihu.com/p/377711689">InnoDB &amp; MySQL 全文索引</a></p></blockquote><h1 id="三、降序索引"><a href="#三、降序索引" class="headerlink" title="三、降序索引"></a>三、降序索引</h1><p>降序索引是索引的子集，其目的是弥补升序时执行特点查询语句带来的性能问题：</p><ul><li>性能代价：MySQL 5.7的优化器<strong>可以降序遍历升序索引</strong>，但这是需要成本代价的，正序访问可能会比降序访问的效率高15%左右。</li><li>排序代价：如果非最左索引的顺序与order by顺序不一致，还需要额外排序操作，即还可能使用到<code>filesort</code>。</li></ul><h2 id="降序索引"><a href="#降序索引" class="headerlink" title="降序索引"></a>降序索引</h2><p><em>使用限制</em></p><ul><li>MySQL5.7不支持降序索引，即使指定了降序排列，实际创建的索引里面也并没有按照降序排列。MySQL8.0支持降序索引。</li><li>降序索引只能在innodb存储引擎中使用，其他存储引擎不支持。</li><li>使用聚合函数如果没有使用 group by 子句，不能使用降序索引进行优化。</li><li>change buffer不支持二级索引或者主键包含降序字段。这可能会一定程度影响插入的性能。</li></ul><p><em>sql语句</em><br>例子：联合索引c1升序、c2降序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test (c1 <span class="hljs-type">int</span>,c2 <span class="hljs-type">int</span>,index idx_c1_c2(c1,c2 <span class="hljs-keyword">desc</span>));<br></code></pre></td></tr></table></figure><h2 id="降序索引使用"><a href="#降序索引使用" class="headerlink" title="降序索引使用"></a>降序索引使用</h2><p><em>单字段排序</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c1;<br></code></pre></td></tr></table></figure><p>降序的索引的执行计划中多了个Backward index scan反向索引扫描，与正向索引性能差别很小。</p><p><em>多字段不同方向</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c1,c2 <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><p>降序索引可以避免文件排序，如果是正向索引则需要使用<code>sort_buffer</code>，<code>sort_buffer</code>不够用时还需要<code>using filesort</code></p><p><em>降序索引group by</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c2 <span class="hljs-keyword">from</span> test <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> c2;<br></code></pre></td></tr></table></figure><p>group by具有隐式的排序功能，但如果group by 的是降序索引，则<strong>不再主动进行隐式排序</strong>。</p><h1 id="四、外键"><a href="#四、外键" class="headerlink" title="四、外键"></a>四、外键</h1><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p><em>外键的定义</em><br>表的外键是另一张表的<strong>主键</strong>。将两张表联系到一起。</p><p><em>外键的目的</em><br>保证数据的一致性</p><p><em>外键的要求</em></p><ol><li>父表与子表必须具有相同的存储引擎（InnoDB），而且禁用使用临时表；</li><li>外键列与参照列必须具有相似的数据类型，其中数字的长度或有无符号位必须相同，而字符的长度可以不同。</li><li>外键列和参照列必须创建索引，如果外键列不存在索引，mysql会自动创建索引。</li></ol><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>外键约束是一系列规则，目的是为了保证数据的完整性和一致性，有以下规则：</p><ol><li>CASCADE：从父表删除或更新会自动删除或更新子表中匹配的行</li><li>RESTRICT：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作，这个是ANSI SQL-92标准,从MySQL4.0.8开始支持）</li><li>NO ACTION：标准SQL的关键字，在mysql中与RESTRICT相同。</li><li>SET NULL：从父表删除或更新行，会设置子表中的外键列为NULL，但必须保证子表列没有指定NOT NULL</li><li>SET DEFAULT：从父表删除或更新行，会设置子表中的外键列为默认值，但必须保证子表列没有指定NOT NULL</li></ol>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Mysql</category>
      
      <category>Mysql高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL常见问题</title>
    <link href="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="外部临时表"><a href="#外部临时表" class="headerlink" title="外部临时表"></a>外部临时表</h2><p>通过<code>CREATE TEMPORARY TABLE</code> 创建的临时表，这种临时表称为外部临时表。<strong>这种临时表只对当前用户可见，当前会话结束的时候，该临时表会自动关闭。这种临时表的命名与非临时表可以同名（同名后非临时表将对当前会话不可见，直到临时表被删除）</strong>。</p><h2 id="内部临时表"><a href="#内部临时表" class="headerlink" title="内部临时表"></a>内部临时表</h2><h3 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h3><p>union场景需要去重，会建立一个临时表存储前一个表的记录。<br>如果是union all场景，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p><h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id<span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-keyword">as</span> m, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> c <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> m;<br></code></pre></td></tr></table></figure><ol><li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li><li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；</li><li>如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。</li></ol><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230924164439.png"><br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230924164530.png"></p><div class="note note-primary">            <p>上图为所有使用临时内存表<strong>排序</strong>的过程，不仅仅指在group by中需要排序的场景。</p>          </div><p><code>group by</code>默认会对分组字段排序如果你的需求并不需要对结果进行排序，那你可以在 SQL 语句末尾增加 order by null，也就是改成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id<span class="hljs-operator">%</span><span class="hljs-number">10</span> <span class="hljs-keyword">as</span> m, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> c <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> m <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>这样可以跳过最后的排序阶段。</p><h4 id="group-by优化方法-索引"><a href="#group-by优化方法-索引" class="headerlink" title="group by优化方法-索引"></a>group by优化方法-索引</h4><p><em>问题分析</em><br>group by需要临时表的根本原因是扫描顺序和分组顺序是无序的，因此需要将所谓分组维护到临时表中。</p><p><em>解决</em><br>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引，这样在以z为分组条件时即可以顺序扫描，<strong>不再需要临时表</strong>。</p><h4 id="group-by-优化方法-直接排序"><a href="#group-by-优化方法-直接排序" class="headerlink" title="group by 优化方法-直接排序"></a>group by 优化方法-直接排序</h4><p><em>问题分析</em><br>对于不适合加索引且数据量大的场景，先使用内存临时表，后发现超过限制而使用磁盘临时表是比较没必要的环节。</p><p><em>解决</em><br>在 group by 语句中加入 <code>SQL_BIG_RESULT</code> 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。相比使用索引，直接排序中通过数组保存所有的group by值，最后再排序。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>group by<ul><li>当group by 索引的时候，当数据量较小的时候不会使用临时表，当数据量（我测试的数据量在30万左右）大的时候会使用临时表</li><li>当group by不是索引的时候会使用临时表</li><li>order by子句和group by子句不同， 例如：order by price group by name；</li><li>ORDER BY中使用了DISTINCT关键字 ORDERY BY DISTINCT（price）</li></ul></li><li>使用 union 或 union distinct 关键字的 SQL 语句。</li><li>派生表（派生表是在外部查询的FROM子句中定义的，explain 输出结果的 select_type 列的值为 <code>DERIVED</code>）</li><li>子查询半连接物化（把子查询结果存到临时表，然后和主查询进行 join 连接）。</li><li>子查询物化（除半连接物化之外的场景，如<code>不相关子查询</code>，<code>半连接重复值消除</code>等）。</li><li>insert … select 语句的源表和目标表是同一个表，例如：insert into t_recbuf(i1, str1) select i1, str1 from t_recbuf）。</li></ul><h2 id="内存临时表与磁盘临时表"><a href="#内存临时表与磁盘临时表" class="headerlink" title="内存临时表与磁盘临时表"></a>内存临时表与磁盘临时表</h2><p><em>使用磁盘临时表的场景</em></p><ul><li>内存临时表的大小限制，参数 <code>tmp_table_size</code> 就是控制这个内存大小的，默认是 16M。当内存临时表空间不足时，Mysql就会把内存临时表转成磁盘临时表，磁盘临时表默认使用的引擎是 InnoDB（也可以选择MyISAM）。</li><li>表包含TEXT或者BLOB列；</li><li>GROUP BY 或者 DISTINCT 子句中包含长度大于512字节的列</li><li>使用UNION或者UNION ALL时，SELECT子句中包含大于512字节的列；</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><em>使用内部临时表的场景</em></p><ul><li>union去重</li><li>group by标记<ul><li>优化1：为group by的条件建立索引，实现顺序分组</li><li>优化2：使用sort buffer 或 磁盘缓存所有结果，然后排序，实现顺序分组</li></ul></li></ul><blockquote><p><a href="https://time.geekbang.org/column/article/80477">什么时候会使用内部临时表？</a></p></blockquote><h1 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h1><h2 id="连接算法"><a href="#连接算法" class="headerlink" title="连接算法"></a>连接算法</h2><h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><p><em>执行方式</em><br>连接条件为被驱动表的索引时，执行方式为：</p><ol><li>查找驱动表记录N</li><li>对每个被驱动表记录，通过索引找被驱动表索引</li><li>对每个被驱动表索引进行回表</li></ol><p><em>成本</em><br>扫描成本为<code>N + 2Nlog2(M)</code>，即驱动表行数 + 驱动表行数 × （被驱动表索引树查找复杂度 + 被驱动表回表）。<br>显然，N 对扫描行数的影响更大，因此应该让小表来做驱动表。</p><p><em>驱动表选择</em><br>在可以使用被驱动表索引时，使用小表做驱动表</p><h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p><em>执行方式</em><br>连接条件不为被驱动表的索引时，如果再按照<code>Index Nested-Loop Join</code>中的方式执行，会导致N × M的极高复杂度，此时执行方式为：</p><ol><li>把驱动表的数据读入线程内存 <code>join_buffer</code> 中，由于我们这个语句中写的是 select ，因此是把整个驱动表放入了内存；</li><li>扫描被驱动表，把被驱动表中的每一行取出来，跟 <code>join_buffer</code> 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li></ol><p><em>成本</em><br>扫描成本为<code>N+M</code>，即分别对驱动表和被驱动表进行了全表扫描。实际上时间复杂度与不使用 <code>join_buffer</code>是相同的，但Block Nested-Loop Join是内存操作，速度上会快很多，性能也更好。</p><p><em>join buffer大小</em><br>如果放不下驱动表的所有数据的话，就会分段放，即每次选出一组驱动表记录写入<code>join_buffer</code>，对被驱动表进行扫描，然后清空<code>join_buffer</code>，再选出一组驱动表记录进行相同的操作。<br>这个流程体现出了这个算法名字中“Block”的由来，表示“分块去 join”。</p><p><em>驱动表选择</em><br>驱动表越大，分块越多，因此使用小表做驱动表。如果连接查询还是很慢，可以把<code>join_buffer_size</code>改大一些，减少分块次数。</p><h2 id="连接结论"><a href="#连接结论" class="headerlink" title="连接结论"></a>连接结论</h2><p><em>可以使用join语句吗？</em></p><ol><li>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引；</li><li>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</li></ol><p>因此，判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现“Block Nested Loop”字样。</p><p><em>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</em><br>小表，这里的小表指的是两表指的是各表按where条件过滤后较小的表。</p><h2 id="连接优化"><a href="#连接优化" class="headerlink" title="连接优化"></a>连接优化</h2><h3 id="NLJ优化"><a href="#NLJ优化" class="headerlink" title="NLJ优化"></a>NLJ优化</h3><h4 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h4><p><em>回表操作是如何进行的？</em><br>回表：InnoDB 在普通索引 a 上查到主键 id 的值后，再根据一个个主键 id 的值到主键索引上去查整行数据的过程。而主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，<strong>回表肯定是一行行搜索主键索引的</strong>。<br>但是，如果对主键进行随机回表，就会出现随机IO，性能较差，因此若能够按照主键顺序进行回表，对磁盘的读比较接近顺序读，能够提升读性能。</p><p><em>MRR 优化思路</em></p><ol><li>根据索引 a，定位到满足条件的记录，将 id 值放入 <code>read_rnd_buffer</code> 中；</li><li>将 <code>read_rnd_buffer</code> 中的 id 进行递增排序；</li><li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li></ol><p><em>MRR 参数</em><br><code>read_rnd_buffer</code> 的大小是由 <code>read_rnd_buffer_size</code> 参数控制的。如果步骤 1 中，<code>read_rnd_buffer</code> 放满了，就会先执行完步骤 2 和 3，然后清空 <code>read_rnd_buffer</code>。之后继续找索引 a 的下个记录，并继续循环。</p><p><em>开启方式</em><br>如果你想要稳定地使用 <code>MRR</code> 优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。（官方文档的说法，是现在的优化器策略，判断消耗的时候，会更倾向于不使用 <code>MRR</code>，把 <code>mrr_cost_based</code> 设置为 <code>off</code>，就是固定使用 <code>MRR</code> 了。）</p><p><em>总结</em><br>MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p><h4 id="Batched-Key-Access-优化"><a href="#Batched-Key-Access-优化" class="headerlink" title="Batched Key Access 优化"></a>Batched Key Access 优化</h4><p><em>BKA 优化思路</em><br>MySQL 在 5.6 版本后开始引入的 <code>Batched Key Access(BKA)</code> 算法，该算法是对<code>NLJ(Index Nested-Loop Join)</code>算法的优化。<br><code>NLJ</code> 算法中，对于被驱动表来说，每次都是匹配一个值。这时，<code>MRR</code> 的优势就用不上了。<code>BKA算法</code>利用<code>join-buffer</code>空间，将驱动表记录放在<code>join-buffer</code>中，排序后再查找被驱动表，若<code>join-buffer</code>空间不足则分多次执行。</p><p><em>开启方式</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="BNL优化"><a href="#BNL优化" class="headerlink" title="BNL优化"></a>BNL优化</h3><p><em>BNL存在的问题</em><br>由于<code>join buffer</code>大小限制，可能需要对被驱动表进行多次扫描：</p><ol><li>冷表数据量小于整个BUFFER POLL的3&#x2F;8时：冷表数据进入LRU的old区后被多次访问，冷数据大量进入yound区。</li><li>冷表数据量大于整个BUFFER POLL的3&#x2F;8时：由于我们的 join 语句在循环读磁盘和淘汰内存页，进入 old 区域的数据页，很可能在 1 秒之内就被淘汰了。那么正常业务中本该进入yound区的数据也可能被淘汰，影响young区数据的正常刷新。</li></ol><p>为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数。</p><p><em>BNL问题总结</em></p><ul><li>可能会多次扫描被驱动表，占用磁盘 IO 资源；</li><li>判断 join 条件需要执行 M* N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li><li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li></ul><p><em>BNL优化</em><br>优化的常见做法是，给被驱动表的 join 字段加上索引，把 BNL 算法转成 BKA 算法：</p><ul><li>适合在被驱动表上建索引的情况：直接在被驱动表上建索引</li><li>不适合在被驱动表上建索引的情况：如被驱动表很大，但满足where筛选条件的行较少，而连接查询对于被驱动表的策略是先连接，再筛选，因此会造成大量的浪费。所以可以考虑使用<strong>临时表</strong>：<ol><li>把表 t2 中满足条件的数据放在临时表 tmp_t 中；</li><li>为了让 join 使用 BKA 算法，给临时表 tmp_t 的字段 b 加上索引；</li><li>让表 t1 和 tmp_t 做 join 操作。</li></ol></li></ul><p><em>sql例子</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> temporary <span class="hljs-keyword">table</span> temp_t(id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, index(b))engine<span class="hljs-operator">=</span>innodb;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> temp_t <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">where</span> b<span class="hljs-operator">&gt;=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">&lt;=</span><span class="hljs-number">2000</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">join</span> temp_t <span class="hljs-keyword">on</span> (t1.b<span class="hljs-operator">=</span>temp_t.b);<br></code></pre></td></tr></table></figure><p><em>BNL优化总结</em><br>不论是在原表上加索引，还是用有索引的临时表，我们的思路都是让 join 语句能够用上被驱动表上的索引，来触发 BKA 算法，提升查询性能。</p><h3 id="Hash-Join优化"><a href="#Hash-Join优化" class="headerlink" title="Hash Join优化"></a>Hash Join优化</h3><p>如果 join_buffer 里面维护的不是一个无序数组，而是一个哈希表的话，那么就不是 大量判断，而是 若干次 hash 查找。</p><blockquote><p>这正是MySQL的优化器和执行器一直被诟病的一个原因：不支持哈希 join。并且，MySQL 官方的 roadmap，也是迟迟没有把这个优化排上议程。</p></blockquote><p>因此，这个优化思路，我们可以自己实现在业务端。理论上，这个过程会比临时表方案的执行速度还要快一些。</p><h3 id="连接优化总结"><a href="#连接优化总结" class="headerlink" title="连接优化总结"></a>连接优化总结</h3><ul><li>NLJ优化（主要解决顺序问题）：<ul><li>MRR优化（回表上的优化）：将被驱动表搜索结果<strong>排序后</strong>批量回表</li><li>BKA优化（连接上的优化）：将驱动表记录<strong>排序后</strong>批量查被驱动表</li></ul></li><li>BNL优化（主要解决批量扫问题）：<ul><li>在被驱动表上加索引：类似BKA优化</li><li>使用索引临时表先处理被驱动表的筛选条件：避免被驱动表全表参与连接判断</li></ul></li></ul><blockquote><p><a href="https://time.geekbang.org/column/article/79700">到底可不可以使用join？</a><br><a href="https://time.geekbang.org/column/article/80147">join语句怎么优化？</a></p></blockquote><h2 id="on与where的区别？"><a href="#on与where的区别？" class="headerlink" title="on与where的区别？"></a>on与where的区别？</h2><p><em>执行顺序</em><br>在多表查询时，on和where都表示筛选条件，on先执行，where后执行<br><em>筛选结果</em></p><ul><li>内连接时，两者效果相同</li><li>外连接时，<ul><li>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回驱动表中的记录。</li><li>where条件是在临时表生成好后，再对临时表进行过滤的条件。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 该语句使用 <span class="hljs-keyword">on</span> 筛选B.id <span class="hljs-operator">!=</span> <span class="hljs-number">1</span>，最后得到的结果集中会出现A.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>的记录<br><span class="hljs-keyword">select</span> A.id,B.name <span class="hljs-keyword">from</span> A <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.id <span class="hljs-operator">=</span> B.id <span class="hljs-keyword">and</span> B.id <span class="hljs-operator">!=</span> <span class="hljs-number">1</span><br><span class="hljs-operator">-</span> 该语句使用 <span class="hljs-keyword">where</span> 筛选B.id <span class="hljs-operator">!=</span> <span class="hljs-number">1</span>，最后得到的结果集中不会出现A.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>的记录<br><span class="hljs-keyword">select</span> A.id,B.name <span class="hljs-keyword">from</span> A <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.id <span class="hljs-operator">=</span> B.id <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">!=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h1><h2 id="sort-buffer"><a href="#sort-buffer" class="headerlink" title="sort buffer"></a>sort buffer</h2><p><em>定义</em><br>MySQL 会为<strong>每个线程</strong>分配固定大小的 sort buffer 用作排序。sort buffer 是具有逻辑概念的内存区域，大小由 <code>sort_buffer_size</code> 参数控制，默认为 <strong>256 kb</strong>。</p><p><em>排序算法</em><br>根据 sort buffer 与 data（待排序数据量）的大小差值，可分为内部排序和外部排序：</p><ul><li><code>data &lt;= sort buffer</code>：sort buffer够用，只需要在内存中进行排序即可，内部排序使用的是<strong>快速排序</strong></li><li><code>data &gt; sort buffer</code>：sort buffer不够用，MySQL 需要借助外部“容器”（通常是文件）进行排序。通常会将待排序数据分成多个“小文件”，对各个“小文件”进行<strong>快速排序</strong>，再汇总成一个有序的“大文件”。外部排序使用的是<strong>归并排序</strong>。</li></ul><p><em>验证排序算法？</em><br>可以通过 <code>EXPLAIN</code> 命令来查看，如果在分析结果中的 <code>Extra</code> 字段里包含 <code>Using filesort</code> 字眼，说明执行了外部排序操作。</p><h3 id="排序策略"><a href="#排序策略" class="headerlink" title="排序策略"></a>排序策略</h3><p>基于sort buffer大小的考虑，Mysql有两种排序策略。</p><h4 id="单路排序（全字段排序）"><a href="#单路排序（全字段排序）" class="headerlink" title="单路排序（全字段排序）"></a>单路排序（全字段排序）</h4><p>「全字段排序是指，只要<strong>与最终结果集有关的字段</strong>都会被放进 sort buffer，而不管该字段本身是否参与排序。」</p><h4 id="双路排序（rowId-排序）"><a href="#双路排序（rowId-排序）" class="headerlink" title="双路排序（rowId 排序）"></a>双路排序（rowId 排序）</h4><p>「rowId 排序是指只将<strong>与排序相关的字段和 rowId</strong> 放入 sort buffer，其余结果集需要用到的数据在排序完成后，通过 rowId 回表取得。」</p><div class="note note-primary">            <p>双路排序不会等所有排序好的 id 回表完再返回，而是每个 id 回表一次，回表之后立即返回。</p>          </div><h3 id="排序策略选择"><a href="#排序策略选择" class="headerlink" title="排序策略选择"></a>排序策略选择</h3><p>由于 rowId 排序相对于全字段排序，不可避免的多了一次回表操作，回表操作意味着随机读，而随机 IO 是数据库中最昂贵的操作。<br>MySQL 会在尽可能的情况下选择全字段排序。通过参数 <code>max_length_for_sort_data</code> 可以控制用于排序的行数据最大长度，默认值为 1024 字节。当单行数据长度超过该值，MySQL 就会觉得如果还用全字段排序，会导致 sort buffer 容纳下的行数太少，从而转为使用 rowId 排序。</p><div class="note note-success">            <p>因此，在深翻页排序时最好利用子查询强制走<strong>双路索引</strong>进行排序，然后回表。</p>          </div><h2 id="临时表排序"><a href="#临时表排序" class="headerlink" title="临时表排序"></a>临时表排序</h2><p>在使用 <code>EXPLAIN</code> 进行执行过程分析的时候除了能看到 <code>Using filesort</code> 以外，还能看到 <code>Using temporary</code>，代表在排序过程中使用到了临时表。<br><strong>临时表触发条件</strong>：<code>order by rand()</code>，由于每个记录的order都是实时生成的，因此需要先创建临时表再进行排序。</p><h3 id="内存临时表排序"><a href="#内存临时表排序" class="headerlink" title="内存临时表排序"></a>内存临时表排序</h3><p><em>存储引擎</em><br>MySQL 优先使用内存临时表。当 MySQL 使用内存临时表时，<strong>临时表存储引擎为 memory</strong> 。<br><em>排序方式</em><br>如果当前 MySQL 使用的是<strong>内存临时表</strong>的话，将会<strong>直接使用 rowId 排序</strong>，因为这时候所谓的“回表”只是在内存表中读数据，操作不涉及硬盘的随机 IO 读。使用 rowId 可以在 sort buffer 容纳给多的行，避免或减少外部排序文件的使用。<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230924164530.png"></p><h3 id="磁盘临时表排序"><a href="#磁盘临时表排序" class="headerlink" title="磁盘临时表排序"></a>磁盘临时表排序</h3><p>通常对于一个<strong>执行较慢</strong>的排序语句，如果系统中很多需要使用临时表的排序语句执行，而又不加以限制，全都使用临时表的话，内存很快就会被打满。所以 MySQL 提供了 <code>tmp_table_size</code> 参数限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了<code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。<br><em>存储引擎</em><br>当使用磁盘临时表的时候，表储存引擎将不再是 memory，而是由 <code>internal_tmp_disk_storage_engine</code> 参数控制，默认为 <code>InnoDB</code> 。<br><em>排序方式</em><br>这时候 MySQL 会<strong>根据单行大小是否超过 <code>max_length_for_sort_data</code> 决定采用全字段排序还是 rowId 排序</strong>。</p><h2 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h2><p><em>排序算法</em><br><strong>优先队列算法</strong>：如果要取的有序元素个数比较少，MySQL会采取一种优先队列的算法来排序。</p><p><em>触发条件</em><br><code>有序行数 × 每一行的大小 &lt; sort_buffer_size 的大小</code><br>执行计划的OPTIMIZER_TRACE结果中，<code>filesort_priority_queue_optimization</code>这个部分的<code>chosen=true</code>，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的<code>number_of_tmp_files</code>是0。</p><h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><p>总结一下，MySQL 总是使用 <strong>「“最快”」</strong> 的排序方案：</p><ol><li>当排序数据量不超过 sort buffer 容量时，MySQL 将会在内存使用快速排序算法进行排序（内部排序）；当排序数据量超过 sort buffer 容量时，MySQL 将会借助临时磁盘文件使用归并排序算法进行排序（外部排序）</li><li>在进行真正排序时，MySQL 又会根据数据单行长度是否超过 <code>max_length_for_sort_data</code>而决定使用 <strong>rowId 排序还是全字段排序</strong>，优先选择全字段排序，以减少回表次数。</li><li>当需要借助临时表的时候，MySQL 会优先使用内存临时表（此时表引擎为 memory 引擎），回内存临时表取数据并不涉及随机读，也不涉及扫描行，效率较高。所以在配合内存临时表的时候，会使用 rowId 排序方式；当内存临时表大小超过 <code>tmp_table_size</code> 限制时，则需要将内存临时表转换为磁盘临时表，这时候由于回表意味着随机读，所以会搭配全字段排序方式。</li></ol><blockquote><p><a href="https://time.geekbang.org/column/article/73479">“order by”是怎么工作的？</a><br><a href="https://cloud.tencent.com/developer/article/1788764">MySQL 排序的艺术：你真的懂 Order By 吗？</a><br><a href="https://blog.csdn.net/qq_42230770/article/details/111311181">MySQL深度解析—临时表排序规则</a></p></blockquote><h1 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h1><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p><em>常见索引失效情形</em></p><ol><li>类型隐式转化（MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较）导致的索引失效：<ol start="2"><li>筛选条件类型与索引类型不一致导致的索引失效</li><li>关联表的两个字段类型不一致也会导致索引失效（解决：可以使用CAST、CONVERT等函数进行类型转化使类型一致）</li></ol></li><li>函数导致的索引失效：索引字段使用函数时索引失效（这里指的是对索引执行函数，如截取等）</li><li>运算符导致的索引失效：索引字段上使用了运算符时索引失效</li><li>OR引起的索引失效：如果OR连接的是同一个字段，那么索引不会失效，反之索引失效</li><li>模糊搜索导致的索引失效：搜索条件类似<code>&quot;%q&quot;</code>时索引失效。但是如果数据库表中的字段只有主键+二级索引，也可能不会走全表扫描（type&#x3D;all），而是走全扫描二级索引树(type&#x3D;index)，因为二级索引中没有额外的版本等主键索引中的信息，读取成本更低。</li><li>使用!&#x3D; 或者 &lt;&gt; 导致索引失效：但对于可使用覆盖索引的情形索引生效</li><li>NOT IN和NOT EXIST导致索引失效：但对于可使用覆盖索引的情形索引生效</li><li>IS NOT NULL导致所有失效：一般IS NULL会走索引，因为NULL被视为最小的索引。<strong>但是IS NOT NULL也是可能会走索引的</strong>，本质上在二级索引上先过滤掉所有的NULL值即可，但实际上很少这样执行。</li><li>组合索引<strong>不符合最左前缀原则</strong>导致索引失效：最左边的字段要出现在查询条件中。</li><li>两个索引列做比较导致的索引失效：在查询条件中对两索引列数据进行了对比操作，则会导致索引失效。</li><li>ORDER BY索引导致的索引失效：当查询条件涉及到order by、limit等条件时，是否走索引情况比较复杂，而且与Mysql版本有关，通常普通索引，如果未使用limit，则不会走索引。order by多个索引字段时，可能不会走索引。其他情况，建议在使用时进行expain验证。</li><li>范围查询导致的索引失效：当查询条件为大于等于、in等范围查询时，根据查询结果占全表数据比例的不同，优化器有可能会放弃索引，进行全表扫描。</li><li>成本原因导致的索引失效：Mysql优化器的其他优化策略，比如优化器认为在某些情况下，全表扫描比走索引快，则它就会放弃索引。</li></ol><blockquote><p><a href="https://cloud.tencent.com/developer/article/1992920">15个必知的Mysql索引失效场景，别再踩坑了</a></p></blockquote><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><p><em>索引的建立需要考虑哪些因素？</em></p><ol><li>查询频率：如果有些列会经常被用在查询条件中，那么这些列就应该被创建索引以提高查询效率。</li><li>数据唯一性：如果某个列的值都是唯一的，那么这个列就非常适合作为索引列，因为可以利用索引的唯一性来加速查询。</li><li>数据分布度：如果某个列的值分布很均匀，那么这个列就非常适合作为索引列，因为可以利用索引的分布度来加速查询。</li><li>数据量大小：如果表的数据量很大，那么索引设计就需要更加小心谨慎，因为索引的过多或者过少都会对查询效率产生负面影响。</li><li>索引类型：MySQL支持多种索引类型，包括B-Tree索引、哈希索引、全文索引等，不同类型的索引适用于不同的查询场景，需要根据具体情况进行选择。</li><li>数据库性能：索引虽然可以提高查询效率，但同时也会影响插入、更新、删除等操作的性能，需要综合考虑数据库的整体性能来进行索引设计。</li></ol><p><em>SQL索引使用注意点？</em></p><ul><li>事前：合理建立索引，适当建立覆盖索引，定期更新统计信息帮助优化器更准确的判断成本</li><li>事中：谨慎导致索引失效的场景，优化查询结构</li><li>事后：对数据表进行分区表优化</li></ul><p><em>最左匹配原则详细解释？</em><br>即从最左边开始匹配的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式，其针对的是<strong>联合索引</strong>。</p><h2 id="深度翻页问题"><a href="#深度翻页问题" class="headerlink" title="深度翻页问题"></a>深度翻页问题</h2><h3 id="常见翻页查询"><a href="#常见翻页查询" class="headerlink" title="常见翻页查询"></a>常见翻页查询</h3><p><em>无排序条件&#x2F;非索引排序</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,m_id, name, identity_no, address, create_time, modify_time <span class="hljs-keyword">from</span> t1 limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>扫描方式：全表扫描</li><li>效率：最低</li></ul><blockquote><p><strong>如果不带排序条件，MySQL默认是什么排序？</strong><br>通常认为是主键，但通过查资料发现并不一定，这里有个物理顺序和逻辑顺序的区别，如：删除原有数据后再插入复用旧id的数据，可能会由于存放在不同页上造成物理顺序与逻辑顺序不一致，此时可以通过优化表改善：optimize table table_name。</p></blockquote><p><em>主键索引排序</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,m_id, name, identity_no, address, create_time, modify_time <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>扫描方式：主键扫描，扫描了offset+limit行</li><li>效率：比不使用索引高。</li></ul><div class="note note-primary">            <p>即使业务上看起来没有任何条件也不需要排序，加上<code>order by 主键</code>也会让语句执行更快，因此这种场景应该总是加上排序功能。</p>          </div><p><em>二级索引排序</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,m_id, name, identity_no, address, create_time, modify_time <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">10000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>扫描方式：二级索引扫描，扫描了offset+limit行（如果不是覆盖索引，还需要回表）</li><li>效率：比使用主键索引效率低（回表消耗）</li></ul><div class="note note-primary">            <p>给常用的字段加索引，包括排序字段。</p>          </div><p><em>二级索引深翻页</em><br>虽然命中了二级索引，但分页更深：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,m_id, name, identity_no, address, create_time, modify_time <span class="hljs-keyword">from</span> t2 <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>扫描方式：可能全表扫描（因为mysql发现该查询行数超过一定比例）就会转为全表扫描</li><li>效率：最低</li></ul><p><em>强制二级索引深翻页</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,m_id, name, identity_no, address, create_time, modify_time <span class="hljs-keyword">from</span> t2 force index(idx_create_time) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>扫描方式：二级索引扫描，扫描了offset+limit行（如果不是覆盖索引，还需要回表）</li><li>效率：扫描大量索引，且需要回表，效率不一定比全表扫描高</li></ul><h3 id="深翻页为什么慢？"><a href="#深翻页为什么慢？" class="headerlink" title="深翻页为什么慢？"></a>深翻页为什么慢？</h3><p><em>针对深翻页问题，需要考虑的因素有哪些？</em></p><ol><li>是否加了order by：业务不需要order by时最好也加上<code>order by 主键</code></li><li>是否命中索引：没有命中索引需要全表扫描</li><li>是否为主键索引：非主键索引需要进行大量的回表</li></ol><p><em>深翻页问题的痛点？</em><br>出于业务需求，使用二级索引排序，但limit语句会先扫描offset+n行并回表，然后再丢弃掉前offset行，返回后n行数据。扫描更多的行数，也意味着<strong>回表</strong>更多的次数。</p><h3 id="如何解决深翻页？"><a href="#如何解决深翻页？" class="headerlink" title="如何解决深翻页？"></a>如何解决深翻页？</h3><h4 id="规范化语句"><a href="#规范化语句" class="headerlink" title="规范化语句"></a>规范化语句</h4><ol><li>无排序业务要求时：加主键排序，避免全表扫描</li><li>有排序业务要求时：强制走二级索引，避免基于成本的全表扫描</li></ol><h4 id="避免大量回表"><a href="#避免大量回表" class="headerlink" title="避免大量回表"></a>避免大量回表</h4><p><em>构建覆盖索引</em><br>构建覆盖索引，避免回表操作。</p><p><em>未知目标记录的索引或索引边界时</em><br>先以不回表&#x2F;少回表的方式确定目标范围记录的索引或索引边界</p><ul><li>边界子查询：将搜索条件转移到主键索引树<ul><li>使用<strong>子查询</strong>确定offset所在索引（该操作只<code>select 主键索引</code>，需要扫描offset + 1行）</li><li>以该索引为搜索条件搜索limit条记录。</li></ul></li><li>连表子查询：INNER JOIN：延迟关联<ul><li>类似于子查询，临时表检索目标记录的id（该操作只<code>select 主键索引</code>，需要扫描offset + limit行，不进行回表），然后将原表与连接表连接即可。</li></ul></li></ul><p><em>已知目标记录的索引或索引边界时</em><br>存在局限性：相比未知目标记录索引的情况，无法处理跳页，多排序字段等场景，常用于滑动加载下一页、只有上下页按钮的场景。</p><ul><li>标签记录法（相当于已知子查询结果）：应用上记录上一次翻页记录的id，下次直接使用该id做搜索条件</li><li>between..and…（相当于已知临时表结果）：业务上清楚该limit查询对应id范围，也可以直接使用id搜索</li></ul><div class="note note-primary">            <p><em>为什么使用子查询&#x2F;连表查询可以提高效率？</em><br>Mysql有两种排序策略：</p><ol><li>单路排序<ol><li>根据条件将所有查询字段数据取出到sort buffer缓冲区。</li><li>缓冲区满了根据排序字段执行一次排序（快排）把然后把排序后的数据写到临时文件。</li><li>将所有数据取出排序后，对所有临时文件按顺序做合并（归并排序）再写回到文件，直到最后所有文件合并完成。</li><li>从临时文件中读取满足分页条件所需数据返回，如果首次归并就可以取到分页数据则直接返回（浅分页）。</li></ol></li><li>双路排序<ol><li>根据查询条件将row_id和排序字段取出放到sort buffer （区别1）。</li><li>缓冲区满了根据排序字段执行一次排序（快排）把然后把排序后的数据写到临时文件。</li><li>将所有数据取出排序后，对所有临时文件按顺序做合并（归并排序）再写回到文件，直到最后所有文件合并完成。</li><li>从临时文件中读取满足分页条件的row_id，再通过row_id读取对应行数据返回（区别2）。</li></ol></li></ol><p>MySQL在4.1之前都是双路排序，之后优化改为满足条件默认单路排序，条件为：查询字段数据大小小于max_length_for_sort_data值，但改到最小值测试也没有看到变化。</p>          </div><h4 id="其他优化方式"><a href="#其他优化方式" class="headerlink" title="其他优化方式"></a>其他优化方式</h4><p><em>倒排表优化法</em><br>倒排表法类似建立索引，用一张表来维护页数，然后通过高效的连接得到数据，缺点是只适合数据数固定的情况，数据不能删除，维护页表困难<br><em>反向查找优化法</em><br>当偏移超过一半记录数的时候，先用排序，反转偏移。缺点是order by优化比较麻烦，要增加索引，索引影响数据的修改效率，并且要知道总记录数，且满足偏移大于数据的一半的条件</p><h2 id="慢查询问题"><a href="#慢查询问题" class="headerlink" title="慢查询问题"></a>慢查询问题</h2><h3 id="排查慢查询"><a href="#排查慢查询" class="headerlink" title="排查慢查询"></a>排查慢查询</h3><p><em>慢查询日志</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 开启慢查询日志<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>;<br><span class="hljs-operator">-</span> 设置慢查询阈值<br><span class="hljs-keyword">set</span> long_query_time<span class="hljs-operator">=</span><span class="hljs-number">0.3</span>;<br><span class="hljs-operator">-</span> 修改慢查询日志地址<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log_file<span class="hljs-operator">=</span>’<span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span><span class="hljs-keyword">local</span><span class="hljs-operator">/</span>mysql<span class="hljs-operator">/</span>data<span class="hljs-operator">/</span>slow_query.log’;<br></code></pre></td></tr></table></figure><p><em>慢查询日志分析工具</em></p><ul><li>mysqldumpslow：主要可以输出总执行次数，总时间，总数据行及其平均值等</li><li>pt_query_digest：比mysqldumpslow更完善，可以设置各种过滤条件</li></ul><p><em>排查慢查询</em><br>执行 EXPLAIN 命令<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230918124620.png"></p><p><em>检索方式(Type类型)</em></p><ul><li>all：全表查询</li><li>system：该表只有一行（系统表）</li><li>const：命中主键(primary key)或者唯一索引(unique) 且被连接的部分是一个常量值(const)</li><li>ref：使用<strong>非唯一性索引</strong>或者唯一索引的前缀扫描</li><li>eq_ref：类似ref，区别就在使用的索引是<strong>唯一索引</strong></li><li>ref_or_null：二级索引 &#x3D; 常数 或 二级索引 &#x3D; null</li><li>range：利用索引进行范围查询</li><li>index：不用回表的二级索引搜索</li><li>index merge：使用到多个索引来完成一次查询</li></ul><p><em>Extra额外信息</em></p><ul><li>Using index：查询的列被索引覆盖，并且 where 筛选条件是索引的是前导列，Extra 中为 Using index。意味着通过索引查找就能直接找到符合条件的数据，无须回表。</li><li>Using where：说明 MySQL 服务器将在存储引擎检索行后再进行过滤；即没有用到索引，回表查询。</li></ul><h3 id="解决慢查询"><a href="#解决慢查询" class="headerlink" title="解决慢查询"></a>解决慢查询</h3><ul><li>参考索引失效，避免<strong>索引失效</strong></li><li>参考深翻页，避免<strong>回表代价</strong></li><li>MySQL优化错误时：可以强制索引：<ul><li>强制使用一个索引：FORCE INDEX (index_name)、USE INDEX (index_name)；</li><li>强制忽略一个索引：IGNORE INDEX (index_name)。</li></ul></li><li>单表瓶颈：分表，单表数据量维持在2000W（理论上）以内</li><li>单库瓶颈：分库，做读写分离</li><li>单节点问题：集群部署</li></ul><h2 id="COUNT问题"><a href="#COUNT问题" class="headerlink" title="COUNT问题"></a>COUNT问题</h2><p><em>count性能</em><br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230918120438.png"><br>其中count(字段)不统计该字段为NULL的记录，其他则是全表记录统计。<br><em>count原理</em><br>count(?)的语义是指：对于所有记录，<code>?</code>这个表达式的值不为NULL的记录有多少条。</p><p>在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。</p><p>具体地：</p><ul><li><code>count(主键字段)</code>中，InnoDB<strong>根据成本选择遍历主键索引还是二级索引</strong>，逐个判断记录中主键值是否为NULL（虽然显然不会为空）。</li><li><code>count(1)</code>中，因为不需要判断主键是否为空，所以不会读取记录中的任何字段的值，因此效率比count(主键)高。同理，其也优先遍历二级索引，因为成本更低。</li><li><code>count(*)</code>中，<code>count(*)</code> 其实等于 <code>count(0)</code>。同理，其也优先遍历二级索引，因为成本更低。</li><li><code>count(字段)</code>，需要全表扫描，逐个判断字段是否为空，效率最低。</li></ul><p><em>MyISAM存储引擎的count</em><br>快于innodb，因为innodb需要遍历计数，其在每个事务中的执行结果可能不同，而MyISAM因为没有事务，可以直接维护一个全局<code>row_count</code>变量。</p><p><em>优化count</em></p><ol><li>二级索引：信息量更少，遍历更快</li><li>近似值：show table status 或者 explain 命令（不会真正查询）来表进行估算</li><li>额外表保存计数值：每次执行select 和 delete是修改计数</li></ol><h1 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h1><p><em>事务隔离级别</em></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr><td>SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr><tr><td>脏读：读到其他事务未提交的操作</td><td></td><td></td><td></td></tr><tr><td>不可重复读：读到其他事务已提交的UPDATE</td><td></td><td></td><td></td></tr><tr><td>幻读：读到其他事务已提交的INSERT&#x2F;DELETE</td><td></td><td></td><td></td></tr></tbody></table><p><em>InnoDB下的事务实现</em><br>MySQL InnoDB 引擎的默认隔离级别是<strong>可重复读</strong>，但它利用MVCC机制<strong>很大程度上</strong>也能避免幻读的发生：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，在事务中的第一个查询语句时会生成一个ReadView，其可以在 undo log 版本链找到事务开始时的数据。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，此时其他事务要在间隙锁的范围内插入记录会失败。</li></ul><blockquote><p>若开启事务时使用的是<code>start transaction with consistent snapshot</code>，则开启事务的时候就创建了ReadView，而不是执行第一个查询语句时。</p></blockquote><p><em>未完全解决的幻读</em><br>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读，如以下情形：<br>事务先快照读一个不存在的记录，再当前读该被插入了的记录。<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20230918145402.png"></p><p><em>事务使用</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">-</span> 关闭自动提交（作用范围为session）<br><span class="hljs-keyword">SET</span> autocommit<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br><br><span class="hljs-operator">-</span> 开启事务<br><span class="hljs-keyword">START</span> TRANSACTION<br><span class="hljs-operator">-</span> 提交事务<br><span class="hljs-keyword">commit</span><br><span class="hljs-operator">-</span> 回滚事务<br><span class="hljs-keyword">rollback</span><br></code></pre></td></tr></table></figure><p><em>autocommit和start transaction的使用</em></p><ul><li>autocommit开启时：需要通过<code>start transaction</code>开启事务，此时自动提交将保持禁用状态，直到使用<code>COMMIT</code>或<code>ROLLBACK</code>结束事务。如果没有声明<code>start transaction</code>，则ROLLBACK语句是无效的（即使设置了save point）。</li><li>autocommit关闭时：可以不通过<code>start transaction</code>开启事务，也可以进行正常的提交和回滚。</li></ul><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><h3 id="索引区别"><a href="#索引区别" class="headerlink" title="索引区别"></a>索引区别</h3><p><em>MyISAM可以没有主键吗？</em><br>MyISAM可以没有主键，因为其数据的存储不依赖于聚簇索引，其主键索引和二级索引也没有本质上的区别。对于没有主键的表不再需要维护索引树，直接到数据实际记录中扫描即可。<br>InnoDB按主键大小有序插入，MyISAM记录插入顺序，按记录插入顺序保存。</p><p><em>MyISAM如何实现查找，为什么比InnoDB快？</em><br>MyISAM通过索引直接找到记录的物理地址，根据物理地址进行回表；InnoDB只能通过二级索引找到记录的主键，还需要根据主键再做一次回表。即MyISAM必然需要回表操作，但其回表操作是更为快速。</p><h3 id="事务区别"><a href="#事务区别" class="headerlink" title="事务区别"></a>事务区别</h3><p><em>MyISAM为什么无法实现事务</em></p><ul><li>A：MyISAM不支持崩溃恢复，无法实现原子性。</li><li>C：一致性本身就是事务的目的，由于原子性和持久性都做不到，所以一致性也无法实现。</li><li>I：MyISAM支持表锁，只能实现串行化级别的隔离级别。</li><li>D：MyISAM不支持崩溃恢复，无法实现持久性。</li></ul><p><em>为什么InnoDB没有行数统计呢？</em></p><ul><li>原因：因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。</li><li>实现：InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。</li><li>优化：如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT&#x2F;DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><em>InnoDB与MyISAM的区别？</em></p><ul><li>事务相关：<ul><li>事务：InnoDB支持事务，MyISAM不支持</li><li>锁支持：InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁。InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。<strong>潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</strong></li><li>统计：InnoDB不保存表的具体行数，执行<code>select count(*) from table</code>时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li><li>恢复能力：InnoDB通过redo log实现崩溃恢复，MyISAM只能通过binlog进行恢复，而binlog恢复存在一致性问题。</li></ul></li><li>索引相关：<ul><li>索引：InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的；MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。</li><li>存储：InnoDB按主键大小有序插入，MyISAM记录插入顺序，按记录插入顺序保存。</li><li>主键：InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找&#x2F;生产一个隐藏列Row_id来充当默认主键），而MyISAM可以没有</li><li>全文索引：Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；（PS：5.7以后的InnoDB支持全文索引了）。</li><li>外键：InnoDB支持外键，而MyISAM不支持</li></ul></li><li>格式相关：<ul><li>压缩：MyISAM表格可以被压缩后进行查询操作。</li><li>文件格式：Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI<ul><li>Innodb：frm是表定义文件，ibd是数据文件</li><li>Myisam：frm是表定义文件，myd是数据文件，myi是索引文件</li></ul></li></ul></li><li>适用场景：<ul><li>MyISAM适合：插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择，没有事务。</li><li>InnoDB适合：可靠性要求比较高，或者要求事务；表更新和查询都相当的频繁， 大量的INSERT或UPDATE。</li></ul></li></ul><p><em>InnoDB相比MyISAM解决了什么问题？又有什么缺点？</em></p><ul><li>InnoDB优点：<strong>事务支持、行锁、崩溃恢复、主键索引查询效率更高、外键支持</strong></li><li>MyISAM优点：count查询支持，回表更快（利用查询），存储空间小</li></ul><blockquote><p>为什么MyISAM不支持行锁，因为其没有聚簇索引概念，锁记录的时候无法锁住行。</p></blockquote><p><em>为什么binlog进行故障恢复存在一致性问题？</em><br>数据文件更新和写入binlog的顺序有两种可能：</p><ol><li>先更新数据文件，再写入binlog：这种情况下若log写入失败，恢复时会有数据丢失</li><li>先写入binlog，再更新数据文件：这种情况下若数据文件写入失败，使用binlog文件进行恢复数据库（比如备库），则会导致数据库不一致的情况。</li></ol><p><em>为什么redo log进行故障恢复不会有一致性问题？</em><br><img src="/Pasted-image-20230928172633.png"><br>通过两阶段保证了redo log（本地持久化）和binlog的一致性。</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1417482">MySQL崩溃恢复功臣—Redo Log</a></p></blockquote><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失，MEMORY引擎<strong>默认使用哈希索引</strong>，将键的哈希值和指向数据行的指针保存在哈希索引中。</p><ul><li>优点：访问速度较快。  </li><li>缺点：哈希索引数据不是按照索引值顺序存储，无法用于排序，不支持部分索引匹配和范围查找。</li></ul><h2 id="ARCHIVE"><a href="#ARCHIVE" class="headerlink" title="ARCHIVE"></a>ARCHIVE</h2><p>ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。</p><p><em>Innodb引擎的4大特性</em><br>插入缓冲（insert buffer)，二次写(double write)，自适应哈希索引(ahi)，预读(read ahead)</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h2><p><em>存在形式</em></p><ol><li>MyISAM引擎的<strong>自增值保存在数据文件</strong>中</li><li>InnoDB引擎的自增值，在MySQL5.7及之前的版本，<strong>自增值保存在内存</strong>里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+步长作为这个表当前的自增值。在MySQL8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。</li></ol><p><em>自增ID机制？</em></p><ol><li>如果插入数据时id字段指定为0、null或未指定值，那么就把这个表当前的AUTO_INCREMENT值填到自增字段</li><li>如果插入数据时id字段指定了具体的值，就直接使用语句里指定的值。假设，某次要插入的值是X，当前的自增值是Y：<ol><li>如果X&lt;Y，那么这个表的自增值不变（当然，如果发生主键冲突会报错）</li><li>如果X&gt;&#x3D;Y，就需要把当前自增值修改为新的自增值（新的自增值生成算法是：从auto_increment_offset（初始值）开始，以auto_increment_increment（步长）为步长，持续叠加，直到找到第一个大于X的值，作为新的自增值。）</li></ol></li></ol><p><em>什么时候会出现自增ID不连续？</em><br>本质是申请了ID而没有实际使用造成的：</p><ol><li>插入事务回滚</li><li>插入时获取自增ID，但插入时出现了唯一键冲突，导致插入失败</li><li>事务做批量插入时，由于MYSQL优化，批量的申请了ID，但没有用完。</li></ol><p><em>批量插入优化</em><br>MySQL有一个批量申请自增id的策略：</p><ol><li>语句执行过程中，第一次申请自增id，会分配1个</li><li>1个用完以后，这个语句第二次申请自增id，会分配2个</li><li>2个用完以后，还是这个语句，第三次申请自增id，会分配4个</li><li>依次类推，同一个语句去申请自增id，每次申请到的自增id个数都是上一次的两倍</li></ol><p><em>自增锁的锁配置</em><br>在MySQL5.0版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放MySQL5.1.22版本引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值是1：</p><ol><li>该参数设置为0，表示采用之前MySQL5.0版本的策略，即语句执行结束后才释放锁</li><li>该参数设置为1：<ol><li>普通insert语句，自增锁在申请之后就马上释放</li><li>类似insert … select这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放<br>3.该参数设置为2，所有的申请自增主键的动作都是申请后就释放锁</li></ol></li></ol><p><em>自增锁可能导致的不一致</em></p><ul><li>问题：当binlog_format&#x3D;statement的时候，binlog记录语句时又是以session为单位记录，在 lock_mode &#x3D; 1的情形下，可能会造成主从不一致现象。</li><li>解决：<ol><li>让原库的批量插入（即insert … select&#x2F;replace … select&#x2F;load data）数据语句，固定生成连续的id值，自增锁直到语句执行结束才释放。</li><li>在binlog里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。也就是把innodb_autoinc_lock_mode设置为2，同时binlog_format设置为row。</li></ol></li></ul><p><em>自增键用完后</em><br>报主键冲突异常</p><p><em>ROW_ID什么时候启用？</em><br>InnoDB主键选择策略：</p><ol><li>在PRIMARY KEY表上定义a时，InnoDB将其用作聚簇索引。为您创建的每个表定义一个主键。如果没有逻辑唯一且非空的列或列集，请添加一个新的 自动递增 列，其值将自动填充。</li><li>如果您没有PRIMARY KEY为表定义，MySQL会UNIQUE在所有键列所在的位置找到第一个索引，NOT NULL并将 InnoDB其用作聚集索引。</li><li>如果表没有索引PRIMARY KEY或没有合适的 UNIQUE索引，则在InnoDB 内部生成一个隐藏的聚集索引GEN_CLUST_INDEX，该索引在包含行ID值的合成列上命名 （即ROW_ID）。</li></ol><p><em>为什么InnoDB表要建议用自增列做主键，rowID不行吗？</em><br>ROW_ID相比自增主键的缺点：</p><ul><li>无法使用：ROW_ID是一个隐藏的列，既不能被任何查询访问，也不能被内部使用。对我们的任何操作都没有什么用途。</li><li>性能较差：<strong>所有用ROW_ID列的表，共享同一个被保存在数据字典中的全局序列数</strong>，且下一个将要使用的值被保存在系统表空间的page 7（type SYS），数据字段头里（字段名为DICT_HDR_ROW_ID）。获取ROW_ID的操作是互斥的，其会导致sql语句随机性地碰到插入停顿。多张这种表并行插入就会遇到性能限制，因为共享计数器的共享互斥锁和缓存争用是串行的。此外，每生成256个ID就会需要日志写入和刷新，这些都会引起性能毛刺问题。</li></ul><div class="note note-primary">            <p>ROW_ID当增加到<strong>256的倍数的时会刷新到硬盘中</strong>，(dict_hdr_flush_row_id())，这个频率通过字段DICT_HDR_ROW_ID_WRITE_MARGIN定义。在启动的时候，InnoDB将保存在磁盘上的DICT_HDR_ROW_ID增加256，这样就能确保已经生成的ID，不管是否被持久化到磁盘上，都会小于新生成的值，所以生成的ID不会有任何冲突。<br>这与事务的trx_id的生成策略类似。</p>          </div><p><em>为什么MyISAM可以不设置自增ID？</em><br>MyISAM中主键并不是必须的，其他索引也不需要依赖主键来回表，而是根据记录的物理地址直接回表。</p><blockquote><p><a href="https://www.jianshu.com/p/0c452f829dd2">关于MySQL数据库自增主键，说几个容易被忽略的点</a></p></blockquote><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>基于规则，Mysql会对查询语句做一定的优化，这个过程也可以被称作<code>查询重写</code>：</p><ul><li>条件化简：<ul><li>表达式化简：移除不必要的括号、移除没用的条件、常量传递、等值传递、表达式计算（必须是常量类型简单表达式，不支持函数类型和复杂表达式）</li><li>条件合并：HAVING子句和WHERE子句的合并：没有出现聚集函数时，合并HAVING子句和WHERE子句。</li><li>常量表检测：表中只有一条数据或使用主键等值匹配的子句，优先执行。</li></ul></li><li>IN子查询：<ul><li>生成物化表（基于hash索引去重）后内连接</li><li>semi连接（在条件允许的情况下将子查询直接连接，并去重避免连接算法造成的多次匹配）</li><li>转化为exist语句，可能可以使用到索引</li></ul></li><li>ANY&#x2F;ALL子查询优化：将<code> &lt; ANY(子查询)</code> 转化为 <code>&lt; 子查询(MAX)</code>。</li><li>FROM子查询（派生表）：<ul><li>派生表物化：将派生表物化为一个临时表。</li><li>派生表合并：将派生表与外层查询的表连接，并将派生表的查询条件也移动至外层的查询条件。（当派生表有一些特殊函数或处理时，不能使用派生表合并）。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Mysql</category>
      
      <category>Mysql常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（InnoDB数据存储）</title>
    <link href="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/"/>
    <url>/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、InnoDB记录"><a href="#一、InnoDB记录" class="headerlink" title="一、InnoDB记录"></a>一、InnoDB记录</h1><h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>目前有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式<br>可以指定表的行格式：<code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></p><h2 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e8fafc21aa_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e8fe4ee6b0_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>按字段顺序，逆序存放各变长字段的长度（Null值除外）。<br>每个可变字段可能占1到2字节来表示长度。</p><p>前提：</p><ul><li>某个字符集中表示一个字符最多需要使用的字节数为<code>W</code></li><li>这种类型表示能存储最多<code>M</code>个字符，如VARCHAR(M)</li><li>它实际存储的字符串占用的字节数是<code>L</code></li></ul><p>策略：</p><ul><li>如果<code>M×W &lt;= 255</code>，使用1字节表示</li><li>如果<code>M×W &gt; 255</code>，则分为两种情况：<ul><li>如果<code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li><li>如果<code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li></ul></li></ul><blockquote><p>先判断<code>M*W</code>，然后通过判断第一个比特位是0或1即可知道是1字节存储还是2字节存储了。</p></blockquote><div class="note note-primary">            <p>尽量使用1字节来存储。<br>这个字段只记录变长字段如VARCHAR，长度固定的字段不用记录。<br>对于溢出数据，只保留只保留前<code>768</code>个字节和<code>20</code>个字节的溢出页面地址，所以2字节足够表达长度。</p>          </div><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e944a8af0c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>对于允许存null的字段，逆序排列，使用比特记录，0表示非空，1表示为空。<br>但是NULL值列表整体长度必须用字节表示，即未使用的高位会补0。</p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e97718ef01_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在本页（记录堆）的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h3 id="真实数据"><a href="#真实数据" class="headerlink" title="真实数据"></a>真实数据</h3><h4 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h4><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><blockquote><ul><li>transaction_id表示最后操作的事务</li><li>roll_pointer指向版本日志</li></ul></blockquote><p>对于主键，用户自行实现了就不会创建隐藏列，否则InnoDB为其添加<code>row_id</code>。</p><h4 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h4><h5 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h5><p>字符串的长度可能因为编码不同而不同，对于CHAR(M)：</p><ul><li>当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表</li><li>而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</li></ul><h2 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h2><p>古老的行格式<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e99a69ba3d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>特点是：</p><ul><li>通过<strong>偏移（相对偏移）</strong> 替代<strong>变长字段长度</strong>保存各字段记录结束处的长度。</li><li>对于溢出页，使用2字节存储地址即可。</li><li>使用字段偏移量的第一个Bit作为是否为Null的判断方法。</li><li>对于CHAR(M)，给出最大的空间，不会产生碎片</li></ul></blockquote><h2 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h2><h3 id="行数据上限"><a href="#行数据上限" class="headerlink" title="行数据上限"></a>行数据上限</h3><p>除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过<code>65535</code>个字节。（<code>4*16KB</code>，即需要4个页存储）<br>所以，对于<code>VARCHAR(M)</code>类型的列最多可以占用<code>65535</code>个字节。</p><p>在<code>Compact</code>和<code>Redundant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e9aab47ea5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h3><p><code>MySQL</code>中规定一个页中至少存放两行记录！所以当某列占用字节过多时就会溢出。</p><blockquote><p>如果一个页只放一个页面，B+树的目录层级会非常高！</p></blockquote><h2 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h2><p><code>5.7</code>版本的MYSQL默认行格式是<code>Dynamic</code>，只不过在处理<code>行溢出</code>数据时不一样，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9b2c2b71e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB"></p><h1 id="二、InnoDB数据页结构"><a href="#二、InnoDB数据页结构" class="headerlink" title="二、InnoDB数据页结构"></a>二、InnoDB数据页结构</h1><p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>，也可以叫<code>索引页</code>。</p><h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16f13ee1e2dfac7c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p>其中，<strong>FileHeader</strong>和<strong>FileTrailer</strong>是所有页的通用部分。</p><h2 id="文件头部（File-Header）"><a href="#文件头部（File-Header）" class="headerlink" title="文件头部（File Header）"></a>文件头部（File Header）</h2><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr><tr><td><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>，分别代表上一个页和下一个页之间的页号：</td><td></td><td></td></tr><tr><td><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c10eb9d61ce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></td><td></td><td></td></tr></tbody></table><blockquote><p>不是所有的页都有<code>File Header</code>属性。</p></blockquote><h2 id="文件尾部（File-Trailer）"><a href="#文件尾部（File-Trailer）" class="headerlink" title="文件尾部（File Trailer）"></a>文件尾部（File Trailer）</h2><p>这个部分由<code>8</code>个字节组成，可以分成2个小部分：<br>前4个字节代表页的校验和，后4个字节代表页面被最后修改时对应的日志序列位置（LSN）。</p><div class="note note-primary">            <p>文件首部和尾部都会记录校验和<code>checkSum</code>和最后日志序列位置<code>LSN</code>，如果某项校验不成功说明同步出现问题。</p>          </div><h2 id="页头（Page-Header）"><a href="#页头（Page-Header）" class="headerlink" title="页头（Page Header）"></a>页头（Page Header）</h2><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><p>用来存储一个数据页的基本信息。</p><h2 id="用户信息（User-Record）"><a href="#用户信息（User-Record）" class="headerlink" title="用户信息（User Record）"></a>用户信息（User Record）</h2><p>介绍行格式时提到过，InnoDB记录中，每条记录都有一个记录头：</p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><strong>n_owned</strong></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><strong>heap_no</strong></td><td>13</td><td>表示当前记录在本页中的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示本页最小记录，3表示本页最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>去除预留位，剩余的部分如下：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c1084c440b4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>heap_no，表示当前记录在<strong>本页</strong>中的位置，0代表最小记录，1代表最大记录，所以某个页中这个记录从2开始。</li><li>最小记录和最大记录是哑节点，各自保存了一个字符串，且没有放在User Records部分。</li><li>n_owned：记录当前记录所在的组有多少条数据。</li><li>next_record:记录当前记录到下一天记录的地址偏移量。</li></ul><p><img src="/16a95c1084c440b4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0%201.webp"></p><blockquote><p>链表会随着删除而变化，但删除时只会改变标记delete_mask，然后将其放入一个垃圾链表中，当新插入记录时，可以复用垃圾链表中旧记录的空间。</p></blockquote><div class="note note-primary">            <p>记录会按照索引从小到大通过链表连接，但不一定在空间上连续。</p>          </div><h2 id="页目录（Page-Directory）"><a href="#页目录（Page-Directory）" class="headerlink" title="页目录（Page Directory）"></a>页目录（Page Directory）</h2><p>为了避免查看某个页记录时通过遍历来查看索引，将正常记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组，每个组的最后一条记录通过<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</p><p>将每个组的最后一条记录的地址偏移量单独提取出来<strong>按顺序存储</strong>到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c10f2e61ad5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间。</p><blockquote><p>初始情况下有两个分组，先填充最大记录所在分组，然后创建新分组。</p></blockquote><p><em>从数据页中找数据分两步：</em><br><strong>通过二分法确认记录所在的组，通过next_record遍历找到组内对应的记录。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>。</li><li>一个数据页可以被大致划分为7个部分，见上文图中所示。</li><li>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</li><li><code>InnoDB</code>会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</li></ol><h1 id="三、B-树索引"><a href="#三、B-树索引" class="headerlink" title="三、B+树索引"></a>三、B+树索引</h1><h2 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h2><p>为了快速检索，将记录按索引顺序连接（同页或跨页），并为页其添加目录记录，和在页中将数据分组的思想类似。<br>目录记录一般叫做<code>目录项</code>，其中的两个列是<code>主键</code>和<code>页号</code>，其中主键记录的是某个页首个记录的id。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a01bd295fd42b5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a01bd2a6c7a65f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>满足以下条件的就是聚簇索引：</p><ul><li>聚簇索引使用记录主键值的大小进行记录和页的排序</li><li><code>B+</code>树的叶子节点存储的是完整的用户记录。</li></ul><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>满足以下条件的就是二级索引，也叫辅助索引：</p><ul><li>使用非主键做顺序进行记录和页的排序</li><li><code>B+</code>树的叶子节点存储的是二级索引和<strong>主键</strong></li></ul><p>通过二级索引查询时，若要找完整数据行数据则需要<strong>回表</strong>，即根据查到的ID再在聚簇索引中搜索一次。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>同时以多个列作为排序规则：</p><ul><li>同时以多个列作为排序规则，根据列出现的前后顺序，依次排序</li><li><code>B+</code>树的叶子节点存储的是联合索引和<strong>主键</strong></li></ul><h2 id="B-树变化过程"><a href="#B-树变化过程" class="headerlink" title="B+树变化过程"></a>B+树变化过程</h2><h3 id="B-树形成过程"><a href="#B-树形成过程" class="headerlink" title="B+树形成过程"></a>B+树形成过程</h3><ol><li>先在B+根节点上添加用户数据</li><li>根节点满后将记录复制到新页中，并对新页A进行分裂，得到新页A1和新页A2，新记录选择性的插入页A或页B，然后根节点升级成目录页。</li></ol><p><em>InnoDB的页分裂优化</em><br>分裂的方式：</p><ul><li>传统B+树页面分裂操作：原页面按照 <strong>50%</strong> 对半分裂成两页，然后将新记录插入其中一个页。<ul><li>优势：分裂之后，两个页面的<strong>空间利用率是一样的</strong>；如果新的插入是随机在两个页面中挑选进行，那么<strong>下一次分裂的操作就会更晚触发</strong>；</li><li>劣势：空间利用率不高；如果后续的插入不是随机，而是递增或递减的，则<strong>分裂频率较大</strong>。</li></ul></li><li>优化B+树分裂操作的优化：原页面不变动，将新记录插入到新的页中。<ul><li>优势：原记录<strong>空间利用率高</strong>(100%)；索引分裂的代价小：<strong>不需要移动记录</strong>；对于递增&#x2F;递减记录，<strong>分裂频率较低</strong>。</li><li>劣势：如果新的插入，不再满足递增插入的条件，而是插入到原有页面，那么就会导致原有页面再次进行50%分裂，<strong>增加了分裂的概率</strong>。</li></ul></li></ul><p>在InnoDB的实现中，为每个索引页面维护了一个上次插入的位置，以及上次的插入是递增&#x2F;递减的标识。根据这些信息，InnoDB能够判断出新插入到页面中的记录，是否仍旧满足递增&#x2F;递减的约束，若满足约束，则采用优化后的分裂策略；若不满足约束，则退回到50%的分裂策略。</p><h3 id="二级索引B-树"><a href="#二级索引B-树" class="headerlink" title="二级索引B+树"></a>二级索引B+树</h3><p>二级索引B+树的主键不唯一，可能导致无法确定唯一的索引方向，所以<strong>二级索引的非叶子节点</strong>也会保存<strong>主键</strong>列，以便快速确定新记录位置。</p><h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储。</p><ul><li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。</li><li><code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。</li></ul><blockquote><p>所以MyISAM搜索记录至少要进行一次回表。</p></blockquote><h2 id="MySQL如何创建-x2F-删除索引"><a href="#MySQL如何创建-x2F-删除索引" class="headerlink" title="MySQL如何创建&#x2F;删除索引"></a>MySQL如何创建&#x2F;删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> TALBE 表名 (<br>    各种列的信息 ··· , <br>    [KEY<span class="hljs-operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)<br>)<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名 (需要被索引的单个列或多个列);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名;<br></code></pre></td></tr></table></figure><blockquote><p>KEY和INDEX是同义词。</p></blockquote><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><ul><li><p>空间上的代价：建立一个索引需要耗费空间</p></li><li><p>时间上的代价：update类操作需要同时更新多个索引</p></li><li><p>对于二级索引：获取id后还要回到聚簇索引中搜索，这个过程称为<strong>回表</strong>。（一次顺序IO，一次随机IO），查询优化器会衡量回表消耗选择合适的搜索方式。</p></li></ul><h3 id="匹配方式"><a href="#匹配方式" class="headerlink" title="匹配方式"></a>匹配方式</h3><p>InnoDB会为每个索引都会建立一个B+树。<br>可以使用索引的方式有：</p><ul><li>全值匹配：搜索条件为<code>索引 = 常量</code>。</li><li>匹配左边的列：搜索条件为 <code>联合索引中的第一个索引 = 常量</code>。</li><li>匹配列前缀：搜索条件为 <code>索引 like &#39;A%&#39;</code>(‘%A’则不行)</li><li>匹配范围：搜索条件为 <code>索引&gt;常量 and 索引&lt;常量</code></li><li>精确匹配某一列并范围匹配另外一列：搜索条件为 <code>联合索引中的第一个索引 = 常量</code> + <code>联合索引中的第二个索引 &gt; 常量</code></li><li>用于排序：搜索条件为<code>order by 索引</code><ul><li>不可以使用索引进行排序的几种情况：<ul><li>ASC、DESC混用</li><li>排序列包含非同一个索引的列</li><li>排序列使用了复杂的表达式</li></ul></li></ul></li><li>用于分组：搜索条件为<code>group by 索引</code></li></ul><h3 id="如何选择索引"><a href="#如何选择索引" class="headerlink" title="如何选择索引"></a>如何选择索引</h3><ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li></ul><h1 id="四、MySQL数据目录"><a href="#四、MySQL数据目录" class="headerlink" title="四、MySQL数据目录"></a>四、MySQL数据目录</h1><p><code>数据目录</code>是用来存储<code>MySQL</code>在运行过程中产生的数据的。</p><h2 id="数据目录的结构"><a href="#数据目录的结构" class="headerlink" title="数据目录的结构"></a>数据目录的结构</h2><h3 id="InnoDB文件系统"><a href="#InnoDB文件系统" class="headerlink" title="InnoDB文件系统"></a>InnoDB文件系统</h3><h4 id="库在文件系统中的表示"><a href="#库在文件系统中的表示" class="headerlink" title="库在文件系统中的表示"></a>库在文件系统中的表示</h4><ol><li>在<code>数据目录</code>下创建一个和数据库名同名的子目录（或者说是文件夹）。</li><li>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，其中有数据库的基本属性。</li></ol><h4 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h4><p><em>表结构</em><br><code>InnoDB</code>和<code>MyISAM</code>这两种存储引擎都在<code>数据目录</code>下对应的<strong>数据库子目录</strong>下创建了一个专门用于描述<strong>表结构</strong>的文件<code>表名.frm</code></p><p><em>表空间</em></p><ul><li>系统表空间：对应文件系统上一个或多个实际的文件，默认情况下，<code>InnoDB</code>会在<code>数据目录</code>下创建一个名为<code>ibdata1</code>，该文件是自扩展的。（<strong>在MYSQL5.5.7到MYSQL5.6.6之间，所有表数据都默认存放在系统表空间</strong>）</li><li>独立表空间：<strong>MYSQL5.6.6之后，InnoDB为每一个表建立一个独立表空间</strong>，文件名为<code>表名.ibd</code>。</li><li>其他类型的表空间：通用表空间，undo表空间等。</li></ul><blockquote><p>将用户数据存在在系统表空间还是独立表空间是可以配置的，但只对新表有用。旧的表只能转移。</p></blockquote><div class="note note-primary">            <p>表空间是一个抽象的概念，对应系统中一个或多个文件。</p>          </div><h4 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h4><p>对于视图，不需要存储真实的数据的，只需要把它的结构存储起来就行了，只存储一个<code>视图名.frm</code>文件。</p><h3 id="MyISAM文件系统"><a href="#MyISAM文件系统" class="headerlink" title="MyISAM文件系统"></a>MyISAM文件系统</h3><p>没有表空间，表数据都放在数据库的子目录下，如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">test.frm <span class="hljs-regexp">//</span>表结构<br>test.MYD <span class="hljs-regexp">//</span>数据<br>test.MYI <span class="hljs-regexp">//</span>索引<br></code></pre></td></tr></table></figure><h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><p><code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li>服务器进程文件。</li><li>服务器日志文件。</li><li>默认&#x2F;自动生成的SSL和RSA证书和密钥文件。</li></ul><h2 id="MYSQL系统数据库"><a href="#MYSQL系统数据库" class="headerlink" title="MYSQL系统数据库"></a>MYSQL系统数据库</h2><ul><li><code>mysql</code>：存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</li><li><code>information_schema</code>：这个数据库保存着MySQL服务器维护的所有<strong>其他数据库的信息</strong>，有时候也称之为元数据。</li><li><code>performance_schema</code>：这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，MySQL服务器的一个性能监控。</li><li><code>sys</code>： 这个数据库主要是通过视图的形式把<code>information_schema</code> 和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</li></ul><h1 id="五、InnoDB表空间"><a href="#五、InnoDB表空间" class="headerlink" title="五、InnoDB表空间"></a>五、InnoDB表空间</h1><h2 id="页面回顾"><a href="#页面回顾" class="headerlink" title="页面回顾"></a>页面回顾</h2><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>BLOB页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><h3 id="页面通用部分"><a href="#页面通用部分" class="headerlink" title="页面通用部分"></a>页面通用部分</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f33c338667_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>File Header和File Trailder都保存了LSN！</p>          </div><h2 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h2><h3 id="区（Extent）"><a href="#区（Extent）" class="headerlink" title="区（Extent）"></a>区（Extent）</h3><p>物理概念，连续的64个页。+</p><h3 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h3><p>物理概念，连续的256个区。</p><blockquote><p>注意，这里的组与页里面几个记录为一组不是一个东西！</p></blockquote><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f33df9307a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>信息：</p><ul><li>第一个页<ul><li>表空间的在<strong>第一个组的第一个页</strong>中使用一个<code>FSP_HDR</code>的页来存储<strong>表信息和本组的页面信息</strong>。</li><li>除了第一个组，<strong>每个组的第一个页</strong>使用一个<code>XDES</code>的页来存储<strong>本组页面的信息</strong>。</li></ul></li><li>第二个页<ul><li><strong>每组的第二个页</strong>使用了一个<code>IBUF_BITMAP</code>页保存了本组页面的<code>INSERT BUFFER</code>的信息。</li></ul></li><li>第三个页<ul><li>第一个组的第三个页使用一个<code>INODE</code>页保存段信息。</li></ul></li></ul><div class="note note-primary">            <p><strong>为了管理，分配页空间</strong>，把每64个页作为一个区，每256个区作为一个组。<br>以<strong>组</strong>为单位维护组内<strong>各个区</strong>的<strong>页面</strong>使用情况。<br>目的在于尽可能让同一个索引树的数据在一个连续的空间中，实现顺序IO。即当数据量很大时，以区（64个页）为单位分配空间。</p>          </div><h3 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h3><p>段是一个抽象的概念，1个索引会生成2个段，一个叶子节点段，一个非叶子节点段。<br>为段分配空间的策略：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会<strong>以完整的区为单位</strong>来分配存储空间。</li></ul><h2 id="区的分类与管理"><a href="#区的分类与管理" class="headerlink" title="区的分类与管理"></a>区的分类与管理</h2><p>区有4种状态：</p><ul><li>空闲的区：现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>FREE</td><td>空闲的区</td></tr><tr><td>FREE_FRAG</td><td>有剩余空间的碎片区</td></tr><tr><td>FULL_FRAG</td><td>没有剩余空间的碎片区</td></tr><tr><td>FSEG</td><td>附属于某个段的区</td></tr></tbody></table><h3 id="XDES-Entry"><a href="#XDES-Entry" class="headerlink" title="XDES Entry"></a>XDES Entry</h3><p>为了集中管理区的状态，使用了<code>XDES Entry</code>结构保存区状态。<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f343654829_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>XDES Entry保存了这个区：</p><ul><li>State状态：是否为空，或者是否附属于什么段。</li><li>XDES指针(一前一后)：便于快速检索每个区的状态。</li><li>Segment ID：所属段ID。</li><li>Page State Bitmap：标记本区的各个页是否空闲。</li></ul><h3 id="XDES-Entry链表"><a href="#XDES-Entry链表" class="headerlink" title="XDES Entry链表"></a>XDES Entry链表</h3><h4 id="全局的XDES-Entry链表"><a href="#全局的XDES-Entry链表" class="headerlink" title="全局的XDES Entry链表"></a>全局的XDES Entry链表</h4><p>除了FSEG状态，<strong>每个表会维护以下三个链表</strong>：</p><ul><li><code>FREE</code>链表</li><li><code>FREE_FRAG</code>链表</li><li><code>FULL_FRAG</code>链表</li></ul><p>这样在为段分配新空间时就可以快速找到碎片区和空闲区</p><h4 id="段中的XDES-Entry链表"><a href="#段中的XDES-Entry链表" class="headerlink" title="段中的XDES Entry链表"></a>段中的XDES Entry链表</h4><p>向段中插入数据时：</p><ol><li>段中碎片少时先找碎片区，找<code>FREE_FRAG</code>链表</li><li>段占满32个离散的页后，开始申请完整的区，找<code>FREE</code>链表</li></ol><p>区被分配给段之后，<strong>每个段也会维护以下三个链表</strong>：</p><ul><li><code>FREE</code>链表</li><li><code>FREE_FRAG</code>链表</li><li><code>FULL_FRAG</code>链表</li></ul><p>这三个链表是属于具体的段的，这样为该段的新数据找区分配时也可以直接找，不需要找全局申请。</p><h3 id="链表基节点"><a href="#链表基节点" class="headerlink" title="链表基节点"></a>链表基节点</h3><p><code>List Base Node</code>的结构：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f388927e1c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>每个链表都有一个这样的头节点，来描述这个链表的基本属性。</p><div class="note note-primary">            <p>通过在全局维护不同类型区的链表和为每个段维护不同类型的区的链表，为管理区提供了条件。</p>          </div><h2 id="段的属性（INODE-Entry）"><a href="#段的属性（INODE-Entry）" class="headerlink" title="段的属性（INODE Entry）"></a>段的属性（INODE Entry）</h2><p>每个区使用了<code>XDES Entry</code>记录区的信息。<br>每个段使用了<code>INODE Entry</code>记录段的信息：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4087c4a56_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>这里可见，段使用<code>INODE Entry</code>结构记录自己的信息，通过引用链表基节点<code>List Base</code>访问记录各个区信息的<code>XDES Entry</code>结构来实现对本段持有的区的管理。</p>          </div><h2 id="各种类型页面"><a href="#各种类型页面" class="headerlink" title="各种类型页面"></a>各种类型页面</h2><p>上面介绍了<code>XDES Entry</code>和<code>INODE Entry</code>结构分别记录区信息和段信息，现在介绍这些结构实际存储在哪里。</p><h3 id="FSP-HDR页面"><a href="#FSP-HDR页面" class="headerlink" title="FSP_HDR页面"></a>FSP_HDR页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4733af475_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><code>FSR_HDR</code>是表空间中第一个组的第一个区的第一个页面，具体信息如下：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>File Space Header</td><td>表空间头部</td><td>112字节</td><td>表空间的一些整体属性信息</td></tr><tr><td>XDES Entry</td><td>区描述信息</td><td>10240字节</td><td>存储本组256个区对应的属性信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>5986字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><blockquote><p>这个页记录了：</p><ul><li>本表的属性</li><li>本组的各个区（256个区）的属性信息。</li></ul></blockquote><p><em>File Space Header</em></p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>Space ID</td><td>4字节</td><td>表空间的ID</td></tr><tr><td>Not Used</td><td>4字节</td><td>这4个字节未被使用，可以忽略</td></tr><tr><td>Size</td><td>4字节</td><td>当前表空间占有的页面数</td></tr><tr><td>FREE Limit</td><td>4字节</td><td>尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td></tr><tr><td>Space Flags</td><td>4字节</td><td>表空间的一些占用存储空间比较小的属性</td></tr><tr><td>FRAG_N_USED</td><td>4字节</td><td>FREE_FRAG链表中已使用的页面数量</td></tr><tr><td>List Base Node for FREE List</td><td>16字节</td><td>FREE链表的基节点</td></tr><tr><td>List Base Node for FREE_FRAG List</td><td>16字节</td><td>FREE_FRAG链表的基节点</td></tr><tr><td>List Base Node for FULL_FRAG List</td><td>16字节</td><td>FULL_FRAG链表的基节点</td></tr><tr><td>Next Unused Segment ID</td><td>8字节</td><td>当前表空间中下一个未使用的 Segment ID</td></tr><tr><td>List Base Node for SEG_INODES_FULL List</td><td>16字节</td><td>SEG_INODES_FULL链表的基节点</td></tr><tr><td>List Base Node for SEG_INODES_FREE List</td><td>16字节</td><td>SEG_INODES_FREE链表的基节点</td></tr></tbody></table><h3 id="XDES页面"><a href="#XDES页面" class="headerlink" title="XDES页面"></a>XDES页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f475c0ec2a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>这个页记录了：</p><ul><li>本组的各个区（256个区）的属性信息。</li></ul></blockquote><p>与<code>FSR_HDR</code>相似，只是没有<em>File Space Header</em>字段。</p><h3 id="IBUF-BITMAP页面"><a href="#IBUF-BITMAP页面" class="headerlink" title="IBUF_BITMAP页面"></a>IBUF_BITMAP页面</h3><p>记录页面是否有操作缓存</p><h3 id="INODE页面"><a href="#INODE页面" class="headerlink" title="INODE页面"></a>INODE页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16ef3a8df380813e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>前面说过每个段设计了一个<code>INODE Entry</code>结构，通过<code>INODE Entry</code>结构找<code>XDES Entry</code>实现段对区的管理。</p></blockquote><p>表空间在第一个组的第一个区的第三个页面保存这些<code>INODE</code>节点，具体：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>List Node for INODE Page List</td><td>通用链表节点</td><td>12字节</td><td>存储上一个INODE页面和下一个INODE页面的指针</td></tr><tr><td>INODE Entry</td><td>段描述信息</td><td>16320字节</td><td></td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>6字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>List Node for INODE Page List</code>：该页面只能创建85个<code>INODE Entry</code>，如果这个表空间的索引较多（一个索引对应两个段，一个段就有一个INODE Entry），则需要使用其他的页来记录，这里用来存储上一个和下一个INODE Entry页面。</p><p>为了管理INODE Entry页面，也创建了两个链表：</p><ul><li><code>SEG_INODES_FULL</code>链表：该链表中的<code>INODE</code>类型的页面中已经没有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li><li><code>SEG_INODES_FREE</code>链表：该链表中的<code>INODE</code>类型的页面中还有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li></ul><p>而这两个链表的基节点在<code>File Space Header</code>（在FSP_HDR页面中）。</p><h2 id="Segment-Header-结构"><a href="#Segment-Header-结构" class="headerlink" title="Segment Header 结构"></a>Segment Header 结构</h2><p>每个段用一个<code>INODE Entry</code>记录属性，同时也需要建立段中页面和<code>INODE Entry</code>的对应方式。</p><p>每个索引页都有一个Page Header部分（存放这个数据页的基本信息），对于每个索引的<strong>根节点</strong>，都有两个属性：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的根页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的根页定义</td></tr></tbody></table><p>这两个属性都对应一个<code>Segment Header</code>结构：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f48c4472a3_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>各个部分的具体释义如下：</p><table><thead><tr><th>名称</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td>Space ID of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的表空间ID</td></tr><tr><td>Page Number of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的页面页号</td></tr><tr><td>Byte Offset of the INODE Ent</td><td>2</td><td>INODE Entry结构在该页面中的偏移量</td></tr></tbody></table><div class="note note-primary">            <p>即<strong>索引的根节点</strong>的<strong>页头信息</strong>中记录了对<strong>该索引的两个段的INODE结构</strong>的指针。</p>          </div><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p><code>系统表空间 ID</code>（Space ID）是<code>0</code>。<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4911220d8_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>第一个区extend 0中有许多页来记录系统属性：</li></ul><table><thead><tr><th>页号</th><th>页面类型</th><th>英文描述</th><th>描述</th></tr></thead><tbody><tr><td>3</td><td>SYS</td><td>Insert Buffer Header</td><td>存储Insert Buffer的头部信息</td></tr><tr><td>4</td><td>INDEX</td><td>Insert Buffer Root</td><td>存储Insert Buffer的根页面</td></tr><tr><td>5</td><td>TRX_SYS</td><td>Transction System</td><td>事务系统的相关信息</td></tr><tr><td>6</td><td>SYS</td><td>First Rollback Segment</td><td>第一个回滚段的页面</td></tr><tr><td>7</td><td>SYS</td><td>Data Dictionary Header</td><td>数据字典头部信息</td></tr></tbody></table><ul><li><code>extent 1</code>和<code>extent 2</code>这两个区被称为双写缓冲区</li></ul><h3 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h3><p>InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIRTUAL</td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr><tr><td>这些系统表也被称为<code>数据字典</code>。</td><td></td></tr></tbody></table><h4 id="SYS-TABLES表"><a href="#SYS-TABLES表" class="headerlink" title="SYS_TABLES表"></a>SYS_TABLES表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>NAME</td><td>表的名称</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个表都有一个唯一的ID</td></tr><tr><td>N_COLS</td><td>该表拥有列的个数</td></tr><tr><td>TYPE</td><td>表的类型，记录了一些文件格式、行格式、压缩等信息</td></tr><tr><td>MIX_ID</td><td>已过时，忽略</td></tr><tr><td>MIX_LEN</td><td>表的一些额外的属性</td></tr><tr><td>CLUSTER_ID</td><td>未使用，忽略</td></tr><tr><td>SPACE</td><td>该表所属表空间的ID</td></tr></tbody></table><h4 id="SYS-COLUMNS表"><a href="#SYS-COLUMNS表" class="headerlink" title="SYS_COLUMNS表"></a>SYS_COLUMNS表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该列所属表对应的ID</td></tr><tr><td>POS</td><td>该列在表中是第几列</td></tr><tr><td>NAME</td><td>该列的名称</td></tr><tr><td>MTYPE</td><td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td></tr><tr><td>PRTYPE</td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td></tr><tr><td>LEN</td><td>该列最多占用存储空间的字节数</td></tr><tr><td>PREC</td><td>该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><h4 id="SYS-INDEXES表"><a href="#SYS-INDEXES表" class="headerlink" title="SYS_INDEXES表"></a>SYS_INDEXES表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该索引所属表对应的ID</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td>NAME</td><td>该索引的名称</td></tr><tr><td>N_FIELDS</td><td>该索引包含列的个数</td></tr><tr><td>TYPE</td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td>SPACE</td><td>该索引根页面所在的表空间ID</td></tr><tr><td>PAGE_NO</td><td>该索引根页面所在的页面号</td></tr><tr><td>MERGE_THRESHOLD</td><td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><h4 id="SYS-FIELDS表"><a href="#SYS-FIELDS表" class="headerlink" title="SYS_FIELDS表"></a>SYS_FIELDS表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>INDEX_ID</td><td>该索引列所属的索引的ID</td></tr><tr><td>POS</td><td>该索引列在某个索引中是第几列</td></tr><tr><td>COL_NAME</td><td>该索引列的名称</td></tr></tbody></table><h3 id="Data-Dictionary-Header页面"><a href="#Data-Dictionary-Header页面" class="headerlink" title="Data Dictionary Header页面"></a>Data Dictionary Header页面</h3><p>以上的四个系统表描述了用户表的元数据，而这四个系统表的元数据则通过固定页面（Data Dictionary Header）来存储。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16efe1e5a01aeac9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Data Dictionary Header</td><td>数据字典头部信息</td><td>56字节</td><td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td>Segment Header</td><td>段头部信息</td><td>10字节</td><td>记录本页面所在段对应的INODE Entry位置信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>16272字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>Data Dictionary Header</code>描述了整个系统分配下一个表空间ID，列ID等的策略。</p><blockquote><p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表，但可以参考。</p></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4a99c9a08_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>用户表空间结构：</p><ol><li>每个页通过将记录分成多组，使用页头管理</li><li>每个区由64个连续页组成，通过XDES结构管理每个页的状态</li><li>每个组由256个连续区组成，通过FSP_HDR&#x2F;XDES页面管理每个区的状态。</li><li>每个表由若干组组成，通过INODE页面管理本表的段。</li><li>每个索引由2个段组成，段是一个逻辑上的概念。</li></ol><p>空间分配：<br>当段占用的页面超过32个时，开始以区为单位分配空间，因此：</p><ol><li>每个表空间有3个全局链表，分别代表了不同状态的XDES结构。</li><li>每个段也有3个链表，维护属于本段的XDES结构。</li></ol>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（启动选项与字符集）</title>
    <link href="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/"/>
    <url>/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、启动选项"><a href="#一、启动选项" class="headerlink" title="一、启动选项"></a>一、启动选项</h1><h2 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h2><p><em>eg:</em><br><code>--skip-networking</code> 禁止网络<br><code>--default-storage-engine=MyISAM</code> 选择默认存储引擎</p><p>注意：</p><ul><li>选项有长形式和短形式<ul><li>长形式前面<code>--</code></li><li>短形式前面<code>-</code></li><li>一般短形式后面要直接加参数（不能空格）</li></ul></li><li>选项名是区分大小写的</li></ul><div class="note note-primary">            <p><code>mysqld_safe</code>会间接调用<code>mysqld</code></p>          </div><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可以在配置文件中修改启动参数。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p><h3 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h3><ul><li>不同配置文件和同一个配置文件中的相同选项，按扫描最后出现的为准。</li><li>可以<code>defaults-extra-file</code>指定额外的配置文件，这样会只使用该指定文件。</li></ul><h3 id="常见默认配置"><a href="#常见默认配置" class="headerlink" title="常见默认配置"></a>常见默认配置</h3><ul><li>最大连接数：151</li></ul><h1 id="二、系统变量"><a href="#二、系统变量" class="headerlink" title="二、系统变量"></a>二、系统变量</h1><h2 id="系统变量基本概念"><a href="#系统变量基本概念" class="headerlink" title="系统变量基本概念"></a>系统变量基本概念</h2><ul><li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li><li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li></ul><h2 id="系统变量基本操作"><a href="#系统变量基本操作" class="headerlink" title="系统变量基本操作"></a>系统变量基本操作</h2><h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><p><code>SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</code></p><h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><h4 id="启动时"><a href="#启动时" class="headerlink" title="启动时"></a>启动时</h4><ul><li>启动时指定</li><li>配置文件中配置</li></ul><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>设置不同作用范围的系统变量：<br><code>SET [GLOBAL|SESSION] 系统变量名 = 值;</code><br>或<br><code>SET [@@(GLOBAL|SESSION).]var_name = XXX;</code></p><blockquote><p>注意：</p><ul><li>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。</li><li>有些系统变量是只读的，并不能设置值。</li></ul></blockquote><h4 id="启动选项和系统变量的区别"><a href="#启动选项和系统变量的区别" class="headerlink" title="启动选项和系统变量的区别"></a>启动选项和系统变量的区别</h4><ul><li>大部分的系统变量都可以被当作启动选项传入。</li><li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>啥的。</li><li>有些启动选项也不是系统变量，比如<code>defaults-file</code>。</li></ul><h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><h3 id="查看状态变量"><a href="#查看状态变量" class="headerlink" title="查看状态变量"></a>查看状态变量</h3><p><code>SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</code></p><h1 id="三、字符集"><a href="#三、字符集" class="headerlink" title="三、字符集"></a>三、字符集</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>主要字符集：</p><ul><li><code>ASCII</code>字符集：128个字符，<strong>1字节</strong>编码</li><li><code>ISO 8859-1</code>字符集：256个字符，<strong>1字节</strong>编码</li><li><code>GB2312</code>字符集：汉字，ASCII中1字节编码，其他<strong>2字节</strong>编码</li><li><code>GBK</code>字符集：对<code>GB2312</code>扩充，<strong>1～2字节</strong>编码。</li><li><code>utf8</code>字符集：兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用<strong>1～4个字节</strong>。</li></ul><h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>每个字符集都有对应的若干个比较规则，如针对二进制编码比较，大小写比较等等。</p><h2 id="MySQL中支持的字符集和排序规则"><a href="#MySQL中支持的字符集和排序规则" class="headerlink" title="MySQL中支持的字符集和排序规则"></a>MySQL中支持的字符集和排序规则</h2><h3 id="utf8和utf8mb4"><a href="#utf8和utf8mb4" class="headerlink" title="utf8和utf8mb4"></a>utf8和utf8mb4</h3><ul><li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</li></ul><p>因为4字节的字符很少，有时可以使用utf8mb3。</p><h3 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h3><p><code>SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</code></p><h3 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h3><p><code>SHOW COLLATION [LIKE 匹配的模式];</code></p><table><thead><tr><th>后缀</th><th>英文释义</th><th>描述</th></tr></thead><tbody><tr><td><code>_ai</code></td><td>accent insensitive</td><td>不区分重音</td></tr><tr><td><code>_as</code></td><td>accent sensitive</td><td>区分重音</td></tr><tr><td><code>_ci</code></td><td>case insensitive</td><td>不区分大小写</td></tr><tr><td><code>_cs</code></td><td>case sensitive</td><td>区分大小写</td></tr><tr><td><code>_bin</code></td><td>binary</td><td>以二进制方式比较</td></tr></tbody></table><h3 id="字符集与比较规则的应用"><a href="#字符集与比较规则的应用" class="headerlink" title="字符集与比较规则的应用"></a>字符集与比较规则的应用</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><code>MySQL</code>有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别：系统变量</li><li>数据库级别：创建库时指定</li><li>表级别：创建表时指定</li><li>列级别：创建表时指定</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>在创建库&#x2F;表&#x2F;列时，若没有指定，默认使用上一级的参数。</li><li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li></ul><h4 id="客户端和服务器通信中的字符集"><a href="#客户端和服务器通信中的字符集" class="headerlink" title="客户端和服务器通信中的字符集"></a>客户端和服务器通信中的字符集</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/f87857b928f84edca6a6cf127b3fda5a_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>MYSQL会使用<code>character_set_client</code>字符集来解码客户端传来的二进制数据，然后将其编码成<code>character_set_connection</code>执行，最后将结果编码成<code>character_set_results</code>返回给客户端。</p><h4 id="比较规则的应用"><a href="#比较规则的应用" class="headerlink" title="比较规则的应用"></a>比较规则的应用</h4><p>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（API与常见模板）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整数处理"><a href="#整数处理" class="headerlink" title="整数处理"></a>整数处理</h3><p><em>取余</em><br>%是取余操作，向零取整，<strong>结果符号随被除数</strong>。</p><p><em>取模</em><br>mod，操作为<code>Math.floorMod(a,b)</code>，向下取整，<strong>结果符号随除数</strong>。</p><p><em>设置</em><br><code>int mod = (int)1e9+7;</code></p><p><em>交换</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.临时变量</span><br><span class="hljs-comment">//2.加减</span><br>x = x + y;<br>y = x - y;<br>x = x - y;<br><span class="hljs-comment">//3.或运算，存在缺陷，若x和y是同一个对象，会导致结果置0。</span><br>x = x^y;<br>y = x^y;<br>x = x^y;<br></code></pre></td></tr></table></figure><p><em>值传递</em><br>若需要维护整数全局遍历，应该使用<code>int[1]</code>实现整数对象在方法中的操作。</p><blockquote><p>Integer为什么不可行？<br>方法中若操作了Integer，本质上调用了Integer.valueOf()创建了一个新的Integer对象赋值给形参，此时形参指向的地址改变；若方法不对外返回这个Integer，外部方法的Integer仍为原值；</p></blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/Pasted-image-20230315234608.png"></p><ul><li>其他类型转Integer：Integer.valueOf()</li><li>其他类型转String：String.valueOf()</li><li>Integer转int：Integer.intValue();</li><li>String转int：Integer.parseInt(“123”)</li></ul><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>取<code>[0,val)</code>之间的随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>random.nextInt(val);<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><p>对比<code>int[]</code>、<code>Integer[]</code>、<code>List&lt;Integer&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a,b,c&#125;;<br>Integer[] aO = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;a,b,c&#125;;<br><br><span class="hljs-comment">//双括号初始化</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()&#123;&#123;<br>add(Integer i1);<br>add(Integer i2);<br>&#125;&#125;;<br><span class="hljs-comment">//生成一个不可变对象</span><br>List&lt;Integer&gt; list = Arrays.asList(o1,o2,o3);<br><span class="hljs-comment">//生成一个可变对象，基于new ArrayList&lt;&gt;(Collection&lt;&gt;);</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(o1,o2,o3));<br><br><span class="hljs-comment">//数组复制</span><br>System.arraycopy(nums,<span class="hljs-number">0</span>,nums2,<span class="hljs-number">0</span>,n);<br></code></pre></td></tr></table></figure><h3 id="数组转化"><a href="#数组转化" class="headerlink" title="数组转化"></a>数组转化</h3><ul><li>其他类型转<code>int[]</code>，使用流，转化为基本类型后<code>toArray()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer[] -&gt; int[]</span><br><span class="hljs-type">int</span>[] ints = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();<br><span class="hljs-comment">//List&lt;Integer&gt; --&gt; int[]</span><br><span class="hljs-type">int</span>[] ints = list.stream().mapToInt(Integer::valueOf).toArray();<br></code></pre></td></tr></table></figure><ul><li><code>int[]</code>转其他类型，使用流，做包装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//int[] --&gt; Integer[]</span><br>Integer[] integers = Arrays.stream(ints).boxed().toArray(Integer::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">//int[] --&gt; List&lt;nteger&gt;()</span><br>List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li>集合类型直接互相转化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer[] -&gt; List&lt;Integer&gt;</span><br>List&lt;Integer&gt; list = Arrays.asList(integers);<br><span class="hljs-comment">//List&lt;Integer&gt; --&gt; Integer[]</span><br>Integer[] integers = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//int[] / Integer[] 排序</span><br>Arrays.sort(T[],Comparator);<br><br><span class="hljs-comment">//list排序</span><br>Collections.sort(T[],Comparator);<br>list.sort(Comparator);<br><span class="hljs-comment">//特殊用法</span><br>list.sort(Comparator.comparing(a-&gt;a.getId()));<br>list.sort(Comparator.comparing(Employee:getName));<br><br><span class="hljs-comment">//搜索</span><br><span class="hljs-comment">//二分查找，若找不到，则会返回-index-1(index为其插入后应该有的位置。</span><br>Arrays.binarySearch(<span class="hljs-type">int</span>[],x);<br></code></pre></td></tr></table></figure><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><p>流式处理注意点：</p><ul><li>一个stream只能被消费依一次，类似Interator</li><li>stream操作必须有一个终端操作，否则中间操作不会执行（懒）</li><li>stream中不要修改数据源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 统计</span><br>Arrays.stream(ints).sum();<br>Arrays.stream(ints).max().getAsInt();<br><span class="hljs-comment">// 流的扁平化 flatmap</span><br>List&lt;String&gt; a = Arrays.stream(words)<br>.map(word -&gt; word.split(<span class="hljs-string">&quot;&quot;</span>))<br>.flatMap(Arrays::stream)<br>.collect(toList());<br></code></pre></td></tr></table></figure><p><em>stream效率问题</em><br>一般<code>stream</code>处理比<code>for</code>循环慢，但<code>parallelStream</code>利用了多线程（<code>ForkJoinPool</code>线程池，线程池大小为CPU个数），在大数据量时更快。</p><p><em>stream原理简述</em></p><ul><li>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。</li><li>中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果（比如排序）。</li><li>结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果（比如找到第一个满足条件的元素）。</li><li>中间操作是懒惰的，即中间操作不会对数据做任何操作，直到遇到了最终操作。而最终操作会往前回溯所有的中间操作，然后顺序执行。</li><li>Stream<strong>流水线</strong>，并不是采用每做一次中间操作产生一个完成处理的流后继续供下一个中间操作执行的，而是将各操作通过一个双向链表组织起来。利用<code>sink</code>接口包装操作，实现相邻操作之间的调用。这样本操作处理完一个元素后调用下游<code>sink</code>接口的<code>accept()</code>方法即可将该元素传递给后续元素，或处理结果传递。</li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/Pasted-image-20230916181510.png"></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/47478339">原来你是这样的 Stream —— 浅析 Java Stream 实现原理</a><br><a href="https://juejin.cn/post/6887072885291089934">请避开Java Stream流式编程常见的坑</a><br><a href="https://zhuanlan.zhihu.com/p/339472446">拥抱 Java 8 并行流：执行速度飞起 ！</a></p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="生成字符串"><a href="#生成字符串" class="headerlink" title="生成字符串"></a>生成字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以填入基本类型，包括char</span><br>String.valueOf()<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[]);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[],left,right-left+<span class="hljs-number">1</span>)  <span class="hljs-comment">//字符数组转化为字符串</span><br></code></pre></td></tr></table></figure><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转字符数组</span><br><span class="hljs-type">char</span>[] cs = string.toCharArray();<br><br><span class="hljs-comment">//formIndex可选</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> string.indexOf(<span class="hljs-type">int</span> ch);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> string.indexOf(String s,<span class="hljs-type">int</span> fromIndex);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> string.lastIndexOf(String s,<span class="hljs-type">int</span> fromIndex);<br><br><span class="hljs-comment">//分割，使用size来确定分成几分，字符中间发现分隔符连续出现时，会得到若干空元素。</span><br><span class="hljs-comment">//默认情况下，末尾的所有分隔符会被忽略。</span><br><span class="hljs-comment">//若将size设置为-1.末尾的所有分隔符也会计算出空元素。</span><br>String[] sArr = string.split(String str,<span class="hljs-type">int</span> size);<br><br><span class="hljs-comment">//子串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">substr</span> <span class="hljs-operator">=</span> string.substring(<span class="hljs-type">int</span> startIndex,<span class="hljs-type">int</span> endIndex);<br><br><span class="hljs-comment">//是否以suffix结尾</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">endwith</span> <span class="hljs-operator">=</span> string.endsWith(String suffix);<br><br><span class="hljs-comment">//替换字符/字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">repstr</span> <span class="hljs-operator">=</span> string.replace(<span class="hljs-type">char</span> oldChar,String newChar);<br><span class="hljs-type">String</span> <span class="hljs-variable">repstr</span> <span class="hljs-operator">=</span> string.replace(String oldString,String newString);<br><span class="hljs-type">String</span> <span class="hljs-variable">repstr</span> <span class="hljs-operator">=</span> string.replaceAll(String oldString,String newString);<br><br><span class="hljs-comment">//转小写</span><br><span class="hljs-type">String</span> <span class="hljs-variable">lowStr</span> <span class="hljs-operator">=</span> string.toLowerCase();<br></code></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除最后一个字符</span><br>sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br><span class="hljs-comment">//删除指定区间</span><br>sb.delete(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end);<br><span class="hljs-comment">//反转</span><br>sb.reverse();<br><span class="hljs-comment">//获取索引</span><br>sb.indexOf(String str);<br><span class="hljs-comment">//插入</span><br>sb.insert(<span class="hljs-type">int</span> offset,String string);<br></code></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><ul><li>数字(0 -&gt; 9)的ASCII，48-&gt;57;</li><li>小写字母(a-&gt;z)的ASCII，97-&gt;122;</li><li>大写字母(A-&gt;Z)的ASCII，65-&gt;90;</li></ul><p>应用：</p><ul><li>大小写之间隔了32，因此若要进行大小写转换，以90为界限，加减32即可。</li><li>若要保存数字+字母，使用<code>int[128]</code>即可</li><li>若只保存字母，使用<code>int[58]</code>即可，索引为<code>c-&#39;A&#39;</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断</span><br>Character.isLetterOrDigit()<br><span class="hljs-comment">//转化大小写，upper</span><br>Character.toLowerCase(<span class="hljs-type">char</span>)<br><br><span class="hljs-comment">//数字&lt;==&gt;字符</span><br><span class="hljs-number">8</span>+<span class="hljs-string">&#x27;0&#x27;</span><br><span class="hljs-string">&#x27;8&#x27;</span>-<span class="hljs-string">&#x27;0&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//常用</span><br>map.getOrDefault(key,<span class="hljs-number">0</span>);<br>map.putIfAbsent(key,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet())<br><span class="hljs-comment">//遍历器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> hashMap.entrySet().iterator();<br><span class="hljs-comment">//排序</span><br>List&lt;Map.Entry&lt;String, String&gt;&gt; entryList1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map.Entry&lt;String, String&gt;&gt;(map1.entrySet());<br>Collections.sort(entryList1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;String, String&gt; me1, Entry&lt;String, String&gt; me2)</span> &#123;<br><span class="hljs-keyword">return</span> me1.getKey().compareTo(me2.getKey()); <span class="hljs-comment">// 升序排序</span><br><span class="hljs-comment">//return me2.getKey().compareTo(me1.getKey()); // 降序排序</span><br>&#125;<br>&#125;);<br><br><span class="hljs-comment">//流处理（记不住）</span><br>Map&lt;String, String&gt; result1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, String&gt;();<br>map1.entrySet()<br>.stream().sorted(Map.Entry.comparingByKey())<br>.forEachOrdered(x -&gt; result1.put(x.getKey(), x.getValue()));<br><br><span class="hljs-comment">//按值排序</span><br>List&lt;Map.Entry&lt;String,String&gt;&gt; entrys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stu.entrySet());<br>Collections.sort(entrys, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;String, String&gt; me1, Entry&lt;String, String&gt; me2)</span> &#123;<br><span class="hljs-keyword">return</span> me1.getValue().compareTo(me2.getValue()); <span class="hljs-comment">// 升序排序</span><br><span class="hljs-comment">//return me2.getKey().compareTo(me1.getKey()); // 降序排序</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>常用LinkedList、ArrayDeque，可使用offer、poll(不会异常)操作结合fisrt、last使用。</p><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分搜索树，会自动去重并从小到大排列</span><br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();<br><span class="hljs-comment">//返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素,返回null。</span><br>set.ceiling(x);<br><span class="hljs-comment">//返回在这个集合中小于或等于给定元素的最大元素，如果不存在这样的元素,返回null。</span><br>set.floor(x);<br><span class="hljs-comment">//大于</span><br>set.higher(x);<br><span class="hljs-comment">//小于</span><br>set.lower(x);<br><span class="hljs-comment">//顺序遍历treeset的迭代器</span><br>Iterator&lt;Clazz&gt; iterator = set.iterator();<br><br><span class="hljs-comment">//二分搜索树，会自动去重并从小到大排列</span><br>Map&lt;Key,Value&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();<br><span class="hljs-comment">//顺序遍历key</span><br>Set&lt;String&gt; keys = map.keySet();<br><span class="hljs-comment">//顺序遍历value</span><br><span class="hljs-type">Collection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> map.values();<br>Iterator&lt;Clazz&gt; iterator = c.iterator();<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li>PriorityQueue（堆排）的iterator无法实现顺序遍历，元素无序。</li><li>Tree类（排序二叉树）可以，元素有序。</li><li>共同点，两者都是在添加元素时实现排序，若元素添加后再修改其内部结构，集合类不会重新调整排序。</li></ul>          </div><h3 id="常见方法-1"><a href="#常见方法-1" class="headerlink" title="常见方法"></a>常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反转</span><br>Collections.reverse(list);<br><span class="hljs-comment">//二分查找，若找不到，则会返回-index-1(index为其插入后应该有的位置。</span><br>Collections.binarySearch(list,x);<br><span class="hljs-comment">//排序，需要T实现Comparable，即重写compareTo。底层调用list.sort();</span><br>Collections.sort(list);<br><span class="hljs-comment">//创建单元素集合</span><br>Collections.singleton(T o)<br></code></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="控制台IO"><a href="#控制台IO" class="headerlink" title="控制台IO"></a>控制台IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//读该行剩下的所有内容并换行</span><br>in.readLine();<br><span class="hljs-comment">//越过空格和回车，读下一个int，再次遇到空格或回车后停止，因此如果在readInt后需要换行读取，需要执行一次空的in.readLine()读走换行符。</span><br>in.readInt();<br></code></pre></td></tr></table></figure><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字节IO</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath); <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br><span class="hljs-comment">//将字节读入数组，返回-1则说明读完了。</span><br>bufferedInputStream.read(<span class="hljs-type">byte</span>[] bytes);<br><br><span class="hljs-comment">//字符io</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);  <br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fileReader);  <br>bufferedReader.readLine();<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Optional 类是一个可以为<code>null</code>的容器对象。如果值存在则<code>isPresent()</code>方法会返回true，调用<code>get()</code>方法会返回该对象。</p><p><em>Optional相关API</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 空Optional</span><br>Optional.empty();<br><span class="hljs-comment">// 若传入空值会抛NPE</span><br>Optional.of(Object o);<br><span class="hljs-comment">// 若传入空值不会抛NPE</span><br>Optional.ofNullable(Object o);<br><span class="hljs-comment">// 如果对象不为空才执行</span><br>Optional.ifPresent(Consumer c);<br><span class="hljs-comment">// 如果对象为空则返回o，o若是一个函数无论Optional是否为空一定会被执行</span><br>Optional.orElse(Object o);<br><span class="hljs-comment">// 类似的有orElseGet，若Optional不为空，c不会执行</span><br>Optional.orElseGet(Consumer c)<br><br><span class="hljs-comment">// 常见用法</span><br>Optional.ofNullable(o).map(o -&gt; o.getName()).orElse(<span class="hljs-string">&quot;DefaultName&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>若是双指针二分，根据取中的方法，总数为偶数时最终中值会偏向一边的端点，代码要保证当偏向的那段的值为target时，另一边能一直收缩。<br>双指针本质上，是一个指针做判断，一个指针做范围压缩，而一般压缩不能越过正确值。</p><p>1.若想找到一个数，或有重复数的最左边，则以左指针做边界判断（+1），右指针做压缩，同时mid偏左。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>left = mid+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    right = mid;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.若想找到一个数的最右边，则以右指针作为边界判断（-1)，左指针做压缩，同时mid偏右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid]&lt;=target)&#123;<br>left=mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>right = mid-<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>注意点：数组的长度是n+1，0不存储元素，而是作为query的终止值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += a[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            a[x] += dt;<br>            x += lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br><span class="hljs-keyword">if</span>(i == len) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-comment">//记忆化，不记忆isLimit和非isNum的情况</span><br><span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] &gt;=<span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> dp[i][mask];<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(!isNum) res += dfs(i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=isNum?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,up=isLimit?s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;j&lt;=up;j++)&#123;<br><span class="hljs-keyword">if</span>(((mask&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>res += dfs(i+<span class="hljs-number">1</span>,mask|(<span class="hljs-number">1</span>&lt;&lt;j),isLimit&amp;&amp;(s[i]-<span class="hljs-string">&#x27;0&#x27;</span> == j),<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum)&#123;<br>dp[i][mask] = res;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-type">int</span>[] parent;<br><span class="hljs-type">int</span>[] size;<br><span class="hljs-type">int</span> setCount;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-built_in">this</span>.n = n;<br><span class="hljs-built_in">this</span>.setCount = n;<br><span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-built_in">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>Arrays.fill(size,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>parent[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//缩小集的操作在这里</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">return</span> parent[x] == x?x:(parent[x] = root(parent[x]));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>x = root(x);<br>y = root(y);<br><span class="hljs-keyword">if</span>(x == y)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>x = x^y;<br>y = x^y;<br>x = x^y;<br>&#125;<br>parent[y] = x;<br>size[x] += size[y];<br>setCount--;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">return</span> root(x) == root(y);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-comment">//可以使用数组</span><br>    <span class="hljs-keyword">public</span> Trie[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br><span class="hljs-comment">//也可以使用hash</span><br><span class="hljs-comment">//public Map&lt;?,Trie&gt; children = new HashMap&lt;&gt;();</span><br><br><span class="hljs-comment">//可以记录本节点是一个单词结束点，也可以记录本节点所对应的单词等</span><br>    <span class="hljs-comment">//boolean isEnd = null;</span><br>    <span class="hljs-comment">//public String word = null;</span><br><br><span class="hljs-comment">//获取指定字符的节点</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br><span class="hljs-comment">//插入单词</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>)<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            node = node.children[<span class="hljs-type">char</span>];<br>        &#125;<br>        <span class="hljs-comment">//node.isEnd = true;</span><br>        <span class="hljs-comment">//node.word = word;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Node head;<br>    Node tail;<br>    Node[] nodes;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[capacity];<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">this</span>.tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> getFromHash(key);<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        unlink(temp);<br>        insert(temp);<br>        <span class="hljs-keyword">return</span> temp.value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> getFromHash(key);<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>)&#123;<br>            temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value);<br>            insertToHash(temp);<br>            insert(temp);<br>            size++;<br>            <span class="hljs-keyword">if</span>(size &gt; capacity)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">needRemove</span> <span class="hljs-operator">=</span> tail.pre;<br>                unlink(needRemove);<br>                removeFromHash(needRemove.key);<br>                size--;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp.value = value;<br>            unlink(temp);<br>            insert(temp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> node.pre;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>        node.pre = <span class="hljs-literal">null</span>;<br>        node.next = <span class="hljs-literal">null</span>;<br>        pre.next = next;<br>        <span class="hljs-keyword">if</span>(next != <span class="hljs-literal">null</span>)&#123;<br>            next.pre = pre;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">oldHead</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-comment">//与头建立连接</span><br>        head.next = node;<br>        node.pre = head;<br>        <span class="hljs-comment">//与尾建立连接</span><br>        node.next = oldHead;<br>        <span class="hljs-keyword">if</span>(oldHead != <span class="hljs-literal">null</span>)&#123;<br>            oldHead.pre = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getFromHash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key%capacity;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nodes[hash];<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(temp.key == key)&#123;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp = temp.nextHash;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertToHash</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> node.key%capacity;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nodes[hash];<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>)&#123;<br>            nodes[hash] = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node.nextHash = nodes[hash];<br>            nodes[hash] = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFromHash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key%capacity;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nodes[hash];<br>        <span class="hljs-keyword">if</span>(temp.key == key) nodes[hash] = temp.nextHash;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> temp;<br>        <span class="hljs-keyword">while</span>(temp.nextHash != <span class="hljs-literal">null</span>)&#123;<br>            temp = temp.nextHash;<br>            <span class="hljs-keyword">if</span>(temp.key == key)&#123;<br>                last.nextHash = temp.nextHash;<br>                temp.nextHash = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            last = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> value;<br>    Node next;<br>    Node pre;<br>    Node nextHash;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Skiplist</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">P_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.25</span>;<br>    <span class="hljs-keyword">private</span> SkiplistNode head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> level;<br>    <span class="hljs-keyword">private</span> Random random;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Skiplist</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>(-<span class="hljs-number">1</span>, MAX_LEVEL);<br>        <span class="hljs-built_in">this</span>.level = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/* 找到第 i 层小于且最接近 target 的元素*/</span><br>            <span class="hljs-keyword">while</span> (curr.forward[i] != <span class="hljs-literal">null</span> &amp;&amp; curr.forward[i].val &lt; target) &#123;<br>                curr = curr.forward[i];<br>            &#125;<br>        &#125;<br>        curr = curr.forward[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">/* 检测当前元素的值是否等于 target */</span><br>        <span class="hljs-keyword">if</span> (curr != <span class="hljs-literal">null</span> &amp;&amp; curr.val == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        SkiplistNode[] update = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>[MAX_LEVEL];<br>        Arrays.fill(update, head);<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/* 找到第 i 层小于且最接近 num 的元素*/</span><br>            <span class="hljs-keyword">while</span> (curr.forward[i] != <span class="hljs-literal">null</span> &amp;&amp; curr.forward[i].val &lt; num) &#123;<br>                curr = curr.forward[i];<br>            &#125;<br>            update[i] = curr;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> randomLevel();<br>        level = Math.max(level, lv);<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>(num, lv);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lv; i++) &#123;<br>            <span class="hljs-comment">/* 对第 i 层的状态进行更新，将当前元素的 forward 指向新的节点 */</span><br>            newNode.forward[i] = update[i].forward[i];<br>            update[i].forward[i] = newNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        SkiplistNode[] update = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>[MAX_LEVEL];<br>        <span class="hljs-type">SkiplistNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">/* 找到第 i 层小于且最接近 num 的元素*/</span><br>            <span class="hljs-keyword">while</span> (curr.forward[i] != <span class="hljs-literal">null</span> &amp;&amp; curr.forward[i].val &lt; num) &#123;<br>                curr = curr.forward[i];<br>            &#125;<br>            update[i] = curr;<br>        &#125;<br>        curr = curr.forward[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">/* 如果值不存在则返回 false */</span><br>        <span class="hljs-keyword">if</span> (curr == <span class="hljs-literal">null</span> || curr.val != num) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>            <span class="hljs-keyword">if</span> (update[i].forward[i] != curr) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">/* 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一跳 */</span><br>            update[i].forward[i] = curr.forward[i];<br>        &#125;<br>        <span class="hljs-comment">/* 更新当前的 level */</span><br>        <span class="hljs-keyword">while</span> (level &gt; <span class="hljs-number">1</span> &amp;&amp; head.forward[level - <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span>) &#123;<br>            level--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lv</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/* 随机生成 lv */</span><br>        <span class="hljs-keyword">while</span> (random.nextDouble() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) &#123;<br>            lv++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lv;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkiplistNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    SkiplistNode[] forward;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkiplistNode</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> maxLevel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.forward = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkiplistNode</span>[maxLevel];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（数学）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p><a href="https://leetcode.cn/problems/recursive-mulitply-lcci/">面试题 08.05. 递归乘法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B)</span> &#123;<br>        <span class="hljs-keyword">return</span> B!=<span class="hljs-number">0</span>?multiply(A&lt;&lt;<span class="hljs-number">1</span>,B&gt;&gt;<span class="hljs-number">1</span>)+((B&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>?A:<span class="hljs-number">0</span>):<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加减乘除位运算"><a href="#加减乘除位运算" class="headerlink" title="加减乘除位运算"></a>加减乘除位运算</h3><p><a href="https://www.jianshu.com/p/7bba031b11e7">简书笔记</a><br><em>加法</em><br>本质通过异或和与运算，从而计算本位和进位，递归得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本加法：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>    <span class="hljs-keyword">if</span>(num2 == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> num1;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> num1 ^ num2;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> add(sum, carry);<br>&#125;<br><br><span class="hljs-comment">// 迭代写法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> num1 ^ num2;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">while</span>(carry != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sum;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> carry;<br>        sum = a ^ b;<br>        carry = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>减法</em><br>特殊的加法，使用<strong>补码运算（取反+1）</strong><br><code>-3 === add(~3,1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">substract</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subtractor</span> <span class="hljs-operator">=</span> add(~num2, <span class="hljs-number">1</span>);<span class="hljs-comment">// 先求减数的补码（取反加一）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> add(num1, subtractor); <span class="hljs-comment">// add()即上述加法运算　　</span><br>    <span class="hljs-keyword">return</span> result ;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>乘法</em><br>涉及到正负，需要先取绝对值，即如果a&#x3D;-3，使用-3的补码进行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*直接当作加法</span><br><span class="hljs-comment">* a: 被乘数</span><br><span class="hljs-comment">* b: 乘数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123; <br>    <span class="hljs-comment">// 取绝对值　　    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">multiplicand</span> <span class="hljs-operator">=</span> a &lt; <span class="hljs-number">0</span> ? add(~a, <span class="hljs-number">1</span>) : a;    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">multiplier</span> <span class="hljs-operator">=</span> b &lt; <span class="hljs-number">0</span> ? add(~b , <span class="hljs-number">1</span>) : b;<span class="hljs-comment">// 如果为负则取反加一得其补码，即正数　　    </span><br>    <span class="hljs-comment">// 计算绝对值的乘积　　    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">while</span>(count &lt; multiplier) &#123;        <br>        product = add(product, multiplicand);        <br>        count = add(count, <span class="hljs-number">1</span>);<span class="hljs-comment">// 这里可别用count++，都说了这里是位运算实现加法　　    </span><br>    &#125;<br>    <span class="hljs-comment">// 确定乘积的符号　　    </span><br>    <span class="hljs-keyword">if</span>((a ^ b) &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 只考虑最高位，如果a,b异号，则异或后最高位为1；如果同号，则异或后最高位为0；　　　　        </span><br>        product = add(~product, <span class="hljs-number">1</span>);    <br>    &#125;    <br>    <span class="hljs-keyword">return</span> product;<br>&#125;<br><br><span class="hljs-comment">//法二：乘法手算</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;　　<br>    <span class="hljs-comment">//将乘数和被乘数都取绝对值　</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">multiplicand</span> <span class="hljs-operator">=</span> a &lt; <span class="hljs-number">0</span> ? add(~a, <span class="hljs-number">1</span>) : a; 　　<br>    <span class="hljs-type">int</span> <span class="hljs-variable">multiplier</span> <span class="hljs-operator">=</span> b &lt; <span class="hljs-number">0</span> ? add(~b , <span class="hljs-number">1</span>) : b;　　<br>    　<br>    <span class="hljs-comment">//计算绝对值的乘积　　</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;　　<br>    <span class="hljs-keyword">while</span>(multiplier &gt; <span class="hljs-number">0</span>) &#123;　　　　<br>        <span class="hljs-keyword">if</span>((multiplier &amp; <span class="hljs-number">0x1</span>) &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 每次考察乘数的最后一位　　　　</span><br>            product = add(product, multiplicand);　　　　<br>        &#125; 　　　　<br>        multiplicand = multiplicand &lt;&lt; <span class="hljs-number">1</span>;<span class="hljs-comment">// 每运算一次，被乘数要左移一位　　　　</span><br>        multiplier = multiplier &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">// 每运算一次，乘数要右移一位（可对照上图理解）　　</span><br>    &#125; 　　<br>    <span class="hljs-comment">//计算乘积的符号　　</span><br>    <span class="hljs-keyword">if</span>((a ^ b) &lt; <span class="hljs-number">0</span>) &#123;　　　　<br>        product = add(~product, <span class="hljs-number">1</span>);　　<br>    &#125; 　　<br>    <span class="hljs-keyword">return</span> product;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>除法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;    <br>    <span class="hljs-comment">// 先取被除数和除数的绝对值    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dividend</span> <span class="hljs-operator">=</span> a &gt; <span class="hljs-number">0</span> ? a : add(~a, <span class="hljs-number">1</span>);    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> b &gt; <span class="hljs-number">0</span> ? b : add(~b, <span class="hljs-number">1</span>);    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 商    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 余数    </span><br>    <span class="hljs-comment">// 不断用除数去减被除数，直到被除数小于被除数（即除不尽了）    </span><br>    <span class="hljs-keyword">while</span>(dividend &gt;= divisor)&#123;<span class="hljs-comment">// 直到商小于被除数        </span><br>        quotient = add(quotient, <span class="hljs-number">1</span>);<br>        dividend = substract(dividend, divisor);<br>    &#125;    <br>    <span class="hljs-comment">// 确定商的符号    </span><br>    <span class="hljs-keyword">if</span>((a ^ b) &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 如果除数和被除数异号，则商为负数  </span><br>        quotient = add(~quotient, <span class="hljs-number">1</span>);    <br>    &#125;    <br>    <span class="hljs-comment">// 确定余数符号    </span><br>    remainder = b &gt; <span class="hljs-number">0</span> ? dividend : add(~dividend, <span class="hljs-number">1</span>);    <br>    <span class="hljs-keyword">return</span> quotient;<span class="hljs-comment">// 返回商</span><br>&#125;<br><br><span class="hljs-comment">//加速</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">divide_v2</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;   <br>    <span class="hljs-comment">// 先取被除数和除数的绝对值    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dividend</span> <span class="hljs-operator">=</span> a &gt; <span class="hljs-number">0</span> ? a : add(~a, <span class="hljs-number">1</span>);    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> b &gt; <span class="hljs-number">0</span> ? a : add(~b, <span class="hljs-number">1</span>);    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">quotient</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 商    </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 余数    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">//比较dividend是否大于divisor的(1&lt;&lt;i)次方，不要将dividend与(divisor&lt;&lt;i)比较，而是用(dividend&gt;&gt;i)与divisor比较，</span><br>        <span class="hljs-comment">//效果一样，但是可以避免因(divisor&lt;&lt;i)操作可能导致的溢出，如果溢出则会可能dividend本身小于divisor，但是溢出导致dividend大于divisor       </span><br>        <span class="hljs-keyword">if</span>((dividend &gt;&gt; i) &gt;= divisor) &#123;            <br>            quotient = add(quotient, <span class="hljs-number">1</span> &lt;&lt; i);            <br>            dividend = substract(dividend, divisor &lt;&lt; i);        <br>        &#125;    <br>    &#125;    <br>    <span class="hljs-comment">// 确定商的符号    </span><br>    <span class="hljs-keyword">if</span>((a ^ b) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 如果除数和被除数异号，则商为负数        </span><br>        quotient = add(~quotient, <span class="hljs-number">1</span>);    <br>    &#125;    <br>    <span class="hljs-comment">// 确定余数符号    </span><br>    remainder = b &gt; <span class="hljs-number">0</span> ? dividend : add(~dividend, <span class="hljs-number">1</span>);    <br>    <span class="hljs-keyword">return</span> quotient;<span class="hljs-comment">// 返回商</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>数学的除法规则：</p><ul><li>商的符号 &#x3D; f(被除数与除数)，同号为正，异号为负</li><li>余数的符号 &#x3D; 除数的符号（-5&#x2F;2 &#x3D; -3…..1）</li></ul><p>JAVA的符号：</p><ul><li>商的符号 &#x3D; f(被除数与除数)，同号为正，异号为负（-5&#x2F;2 &#x3D;-2 ）</li><li>余数的符号 &#x3D; 被除数的符号（-5%2 &#x3D; 2…-1）</li></ul>          </div><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://leetcode.cn/problems/fraction-to-recurring-decimal/">166. 分数到小数</a><br>注意分类讨论。</p><p><a href="https://leetcode.cn/problems/power-of-four/">342. 4的幂</a><br>4的幂必须：大于0、同时是2的幂、4的幂%3一定等于1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; n % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">multiply</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num1.equals(<span class="hljs-string">&quot;0&quot;</span>) || num2.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> num1.length(), n = num2.length();<br>        <span class="hljs-type">int</span>[] ansArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                ansArr[i + j + <span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            ansArr[i - <span class="hljs-number">1</span>] += ansArr[i] / <span class="hljs-number">10</span>;<br>            ansArr[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ansArr[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">while</span> (index &lt; m + n) &#123;<br>            ans.append(ansArr[index]);<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/24-game/">679. 24 点游戏</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TARGET</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>    <span class="hljs-comment">// 处理实数除法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">EPSILON</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e-6</span>;<br>    <span class="hljs-comment">// 运算方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ADD</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, MULTIPLY = <span class="hljs-number">1</span>, SUBTRACT = <span class="hljs-number">2</span>, DIVIDE = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judgePoint24</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;Double&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Double&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            list.add((<span class="hljs-type">double</span>) num);<br>        &#125;<br>        <span class="hljs-comment">// 初始4元素开始进行回溯</span><br>        <span class="hljs-keyword">return</span> solve(list);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(List&lt;Double&gt; list)</span> &#123;<br>        <span class="hljs-comment">// 终止判断</span><br>        <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 结果判断</span><br>        <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.abs(list.get(<span class="hljs-number">0</span>) - TARGET) &lt; EPSILON;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-comment">// 选出两个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != j) &#123;<br>                    List&lt;Double&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Double&gt;();<br>                    <span class="hljs-comment">// 将这两个元素以外的元素添加到新列表</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; size; k++) &#123;<br>                        <span class="hljs-keyword">if</span> (k != i &amp;&amp; k != j) &#123;<br>                            list2.add(list.get(k));<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 遍历这两个元素的操作</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                        <span class="hljs-comment">// +，*满足交换律，可以剪枝优化</span><br>                        <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">2</span> &amp;&amp; i &gt; j) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (k == ADD) &#123;<br>                            list2.add(list.get(i) + list.get(j));<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == MULTIPLY) &#123;<br>                            list2.add(list.get(i) * list.get(j));<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == SUBTRACT) &#123;<br>                            list2.add(list.get(i) - list.get(j));<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == DIVIDE) &#123;<br>                            <span class="hljs-comment">// 0不能做除数</span><br>                            <span class="hljs-keyword">if</span> (Math.abs(list.get(j)) &lt; EPSILON) &#123;<br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                list2.add(list.get(i) / list.get(j));<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 使用新的list2进行回溯，判断是否满足</span><br>                        <span class="hljs-keyword">if</span> (solve(list2)) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果不满足，则使用下一个操作</span><br>                        list2.remove(list2.size() - <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><em>非10进制转10进制</em><br>求每个数的加权和即可。</p><p><em>10进制转非10进制</em><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230521160307.png"><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230521160437.png"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/base-7/">504. 七进制数</a><br><a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toHex</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> (num &gt;&gt; (<span class="hljs-number">4</span> * i)) &amp; <span class="hljs-number">0xf</span>;<br>            <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span> || val &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> val &lt; <span class="hljs-number">10</span> ? (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;0&#x27;</span> + val) : (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + val - <span class="hljs-number">10</span>);<br>                sb.append(digit);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/XcKQwnwCh5nZsz-DLHJwzQ">36进制加法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">add36Strings</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>) &#123;<br>            x = i &gt;= <span class="hljs-number">0</span> ? getInt(num1.charAt(i)) : <span class="hljs-number">0</span>;<br>            y = j &gt;= <span class="hljs-number">0</span> ? getInt(num2.charAt(j)) : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> x + y + carry;<br>            res.append(getChar(temp % <span class="hljs-number">36</span>));<br>            carry = temp / <span class="hljs-number">36</span>;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.reverse().toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getInt</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> ch - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getChar</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">9</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>) (n + <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>) (n - <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;a&#x27;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>比较优雅的写法</p></blockquote><h2 id="常见位运算"><a href="#常见位运算" class="headerlink" title="常见位运算"></a>常见位运算</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230521160616.png"></p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a><br>使用<code>a&amp;(a-1)</code>加速处理<br><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a><br>使用<code>a&amp;(a-1)</code>加速处理<br><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">201. 数字范围按位与</a><br>转化为求最大相同前缀的问题（相同前缀后的数与后肯定为0），即求最小值和最大值的公共前缀。可以两数不断右移直到相等，或明汗法，对right每次将最右的1消除，直到right&lt;&#x3D;left，此时left&#x3D;前缀xxx，right&#x3D;前缀000。<br><a href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//统计每个位上1出现的次数，若为3的倍数，多出来的那个数肯定为0，若不是，则为1。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>            total += ((num &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (total % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;<br>            ans |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">//电路思路，避免上面方法逐步计算位的情况，使用2位二进制来代表当前位除以3的余数0,1,2。 (00)→(01)→(10)→(00)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">aNext</span> <span class="hljs-operator">=</span> (~a &amp; b &amp; num) | (a &amp; ~b &amp; ~num);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bNext</span> <span class="hljs-operator">=</span> ~a &amp; (b ^ num);<br>            a = aNext;<br>            b = bNext;<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/single-number-iii/">260. 只出现一次的数字 III</a><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230521173059.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumber(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">xorsum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            xorsum ^= num;<br>        &#125;<br>        <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lsb</span> <span class="hljs-operator">=</span> (xorsum == Integer.MIN_VALUE ? xorsum : xorsum &amp; (-xorsum));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">type1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, type2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> ((num &amp; lsb) != <span class="hljs-number">0</span>) &#123;<br>                type1 ^= num;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                type2 ^= num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;type1, type2&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/gray-code/">89. 格雷编码</a><br>每多一位数，结果的数量 <code>*2</code> ，而每一位数的结果也可以依赖于前一次运算：<br>例如，<code>i=k</code>时：<code>ans = [x1 x2 x3 x4]</code><br>则：<code>i=k+1</code>时：<code>ans = [0x1 0x2 0x3 0x4 1x4 1x3 1x2 1x1]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">grayCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">highBit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                list.add(list.get(j) + highBit);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/range-product-queries-of-powers/">2438. 二的幂数组中查询范围内的乘积</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-comment">// 预处理出2的幂</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] pow2;<br>    <span class="hljs-keyword">static</span> &#123;<br>        pow2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">500</span>];<br>        pow2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>            pow2[i] = (<span class="hljs-type">int</span>) (<span class="hljs-number">1l</span> * pow2[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> % MOD);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productQueries(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        s.add(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            s.add(s.get(s.size() - <span class="hljs-number">1</span>) + Integer.numberOfTrailingZeros(n));<br>            n &amp;= (n - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] q : queries) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> q[<span class="hljs-number">0</span>], r = q[<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> s.get(r + <span class="hljs-number">1</span>) - s.get(l);<br>            ans[m++] = pow2[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/can-make-palindrome-from-substring/">1177. 构建回文串检测</a><br>位运算表达奇偶性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title function_">canMakePaliQueries</span><span class="hljs-params">(String s, <span class="hljs-type">int</span>[][] queries)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            count[i + <span class="hljs-number">1</span>] = count[i] ^ (<span class="hljs-number">1</span> &lt;&lt; (s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>));<br>        &#125;<br>        List&lt;Boolean&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>], r = queries[i][<span class="hljs-number">1</span>], k = queries[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">bits</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, x = count[r + <span class="hljs-number">1</span>] ^ count[l];<br>            <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>                x &amp;= x - <span class="hljs-number">1</span>;<br>                bits++;<br>            &#125;<br>            res.add(bits &lt;= k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 法1，二分查找，假定目标为n，则≤n的数的数量应该为n，如果超出则说明目标数在左边。</span><br><span class="hljs-comment">// 法2：位统计，统计每位上为1的数字数量，同时统计完整序列的情况，根据1的数量比原始数量多or少，判断各位是0还是1</span><br><br><span class="hljs-comment">// 法3：快慢指针，快慢指针在有环的图上必定相遇</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">理解：两个相同的值说明会有两个节点的next指向同一个节点，其必然会形成环。</span><br><span class="hljs-comment">Q：最初会考虑，如果某个节点的索引与值相等时怎么办？其会导致指针进入死循环。</span><br><span class="hljs-comment">A：实际上这种情况就说明出现了相同的值：</span><br><span class="hljs-comment">- 初始索引为0，但不存在值为0的元素，因此指针不可能回到原点，且原点一定是可以进行下去的节点</span><br><span class="hljs-comment">- 如果指针会进入到一个“索引1=值1”的节点，则说明上一个节点的“值0”就等于现在节点的“索引1”，因此说明已经找到了相同元素。</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        &#125; <span class="hljs-keyword">while</span> (slow != fast);<br>        slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>正整数a,b的最大公约数记为gcd(a,b)，有定理：</p><ul><li>当<code>b = 0</code>时，<code>gcd(a,b) = a</code>；</li><li>当<code>b != 0</code>时，<code>gcd(a,b) = gcd(b, a mod b)</code>。</li><li>如果<code>gcd(a,b) = 1</code>，则a,b互质。</li></ul><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>如果<code>gcd(a,b) = c</code>，则对任意<code>x</code>和<code>y</code>，<code>ax+by</code>一定是<code>c</code>的倍数，且一定存在<code>ax+by=c</code>。<br>推论：若a,b互质，存在x,y使则ax+by&#x3D;c。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/155721651">裴蜀定理</a></p></blockquote><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线性筛</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;Integer&gt; primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span>[] isPrime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(isPrime, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i] == <span class="hljs-number">1</span>) &#123;<br>                primes.add(i);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; primes.size() &amp;&amp; i * primes.get(j) &lt; n; ++j) &#123;<br>                isPrime[i * primes.get(j)] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (i % primes.get(j) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> primes.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>埃式筛：每碰到一个质数，把这个质数的所有倍数都进行标记，最后统计所有质数。（对于<code>a × b = x</code>，只需要遍历将<code>a</code>遍历到<code>根号x</code>即可。）</li><li>线性筛，主要为了解决埃式筛重复标记的问题。将x与已知质数a做乘积标记，当遇到<code>x%a == 0</code>时终止。<ul><li>完整性：任何非质数都可以由质数与另一个数相乘得到。</li><li>剪枝：若 <code>x%a == 0</code>，则 <code>x*a = (x/a) * (a*a) </code>，此时剪枝，因为对于任意质数<code>b &gt; a</code>，肯定有<code>x*b = (x*b/a)*a</code>，即该值会被<code>x*b/a</code>遍历标记，所以此时可先结束标记。</li></ul></li></ul><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/">1250. 检查「好数组」</a><br>一组数可组合成1，等价于这组数的最大公约数为1，即裴蜀定理的推广情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGoodArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length &amp;&amp; divisor != <span class="hljs-number">1</span>; i++) &#123;<br>         divisor = gcd(divisor, nums[i]);<br>     &#125;<br>     <span class="hljs-keyword">return</span> divisor == <span class="hljs-number">1</span>;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>     <span class="hljs-keyword">while</span> (num2 != <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> num1;<br>         num1 = num2;<br>         num2 = temp % num2;<br>     &#125;<br>     <span class="hljs-keyword">return</span> num1;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/four-divisors/">1390. 四因数</a></p><p><a href="https://leetcode.cn/problems/bulb-switcher/">319. 灯泡开关</a><br>灯泡切换的次数是其约数的个数，而其约数总是成对出现，因此除了完全平方数，最终都会熄灭。<br>而1-n中完全平方数的个数为根号n，为了保证浮点运算，使用：<code>根号(n+1/2)</code>来确保在向下取整时的数据正确性。</p><p><a href="https://leetcode.cn/problems/closest-divisors/">1362. 最接近的因数</a><br>若 <code>(num+2)%i == 1</code>，说明<code>(num+1)%i == 0</code>，即满足题目要求，所以只要<code>(num+2)%i&lt;=1</code>就满足条件。<br>可以从大到小枚举i获得结果，但注意我们的假设是：当<code>(num+2)%i == 1</code>时，我们认为<code>(num+2)/i == (num+1)/i</code>，其在<code>num=1</code>时不成立，所以要对<code>num=1</code>时单独处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] closestDivisors(<span class="hljs-type">int</span> num) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> num == <span class="hljs-number">1</span>?num+<span class="hljs-number">1</span> :num + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(divisor);<br>        <span class="hljs-keyword">while</span> (divisor % i &gt; <span class="hljs-number">1</span>) &#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, divisor / i&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/factor-combinations/">254. 因子的组合</a><br>为了避免重复，我们保证要序列是非递减的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">getFactors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//表示可以从2开始遍历,实现减枝头</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">2</span>,n);<br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> startFactor,<span class="hljs-type">int</span> n)</span>&#123;<br>        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=startFactor;i&lt;=(<span class="hljs-type">int</span>)Math.sqrt(n+<span class="hljs-number">0.5</span>);i++)&#123;<br>            <span class="hljs-keyword">if</span>(n%i == <span class="hljs-number">0</span>)&#123;<br>                List&lt;Integer&gt; org = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                org.add(i);<br>                org.add(n/i);<br>                list.add(org);<br>                List&lt;List&lt;Integer&gt;&gt; nextTemp = dfs(i,n/i);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nextTemp.size();j++)&#123;<br>                    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    temp.add(i);<br>                    temp.addAll(nextTemp.get(j));<br>                    list.add(temp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="杨辉三角定理"><a href="#杨辉三角定理" class="headerlink" title="杨辉三角定理"></a>杨辉三角定理</h2><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230524212122.png"></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p><a href="https://leetcode.cn/problems/largest-number/">179. 最大数</a><br>任意两个数的最大排序都是固定的，也可证明这种顺序是可传递的（即如果ab&gt;ba,bc&gt;cb,则ac&gt;ca），因此，整体的数组也是有序了，排序后依次拼接即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Integer[] newNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            newNums[i] = nums[i];<br>        &#125;<br>        Arrays.sort(newNums,(x,y) -&gt; &#123;<br>            <span class="hljs-type">int</span> sx=<span class="hljs-number">10</span>,sy = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">while</span>(sx&lt;=x)&#123;<br>                sx *=<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(sy&lt;=y)&#123;<br>                sy *=<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(-sy*x-y+sx*y+x);<br>        &#125;);<br>        <span class="hljs-keyword">if</span>(newNums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sb.append(newNums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/xor-operation-in-an-array/">1486. 数组异或操作</a></p><ul><li>可以直接模拟</li><li>数学做法是，利用异或的交换律性质：</li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230525205534.png"><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20230525205644.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">xorOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> start &gt;&gt; <span class="hljs-number">1</span>, e = n &amp; start &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> sumXor(s - <span class="hljs-number">1</span>) ^ sumXor(s + n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ret &lt;&lt; <span class="hljs-number">1</span> | e;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">4</span> == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的质数分数</a><br>法1：自定义排序&#x2F;优先队列<br>法2：二分查找，通过双指针可以确定小于某个阈值的分数的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] kthSmallestPrimeFraction(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>, right = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, count = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 记录最大的分数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">while</span> ((<span class="hljs-type">double</span>) arr[i + <span class="hljs-number">1</span>] / arr[j] &lt; mid) &#123;<br>                    ++i;<br>                    <span class="hljs-keyword">if</span> (arr[i] * y &gt; arr[j] * x) &#123;<br>                        x = arr[i];<br>                        y = arr[j];<br>                    &#125;<br>                &#125;<br>                count += i + <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (count == k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;x, y&#125;;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count &lt; k) &#123;<br>                left = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h1><p><a href="https://leetcode.cn/problems/nim-game/">292. Nim 游戏</a><br>显然剩下1-3块时直接胜利，因此给对方留下4颗石头时必胜，对于先手，除了最初石头就是4的倍数的情况下都能获胜。<br><a href="https://leetcode.cn/problems/divisor-game/">1025. 除数博弈</a><br>当剩下的数字为1时为必败态，每次操作会改变n的奇偶性。<br><a href="https://leetcode.cn/problems/stone-game/">877. 石子游戏</a><br>先手方可以控制自己只拿奇&#x2F;偶数序号堆的石头，必胜</p><h3 id="Sprague-Grundy定理"><a href="#Sprague-Grundy定理" class="headerlink" title="Sprague-Grundy定理"></a>Sprague-Grundy定理</h3><p><em>定义</em><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20231101212256.png"></p><p><em>理解</em></p><ul><li>单状态<ul><li>场面可能的状态分胜态（存在操作可以保证胜利）、败态（无论怎么操作都无法胜利）</li><li>败态只能变成胜态，胜态可以变成败态。</li></ul></li><li>多状态（以两个状态为例）<ul><li>场面上为双败败态，进行一次操作后<strong>必然</strong>得到一胜一败，再次操作<strong>可以</strong>使局面变成双败态。因此<strong>双败态下先手必输。</strong></li><li>场面上有一胜一败态，进行一次操作后<strong>可以</strong>得到双败态。因此<strong>一胜一败态下先手必胜</strong>。</li><li>场面上有双胜态，进行一次操作后：<ul><li>变成一胜一败态，对方必胜，因此不会这样操作。</li><li>变成另一个双胜态，需要考察具体状态，因此，必须考虑<strong>胜态与胜态</strong>之间的转换关系以及<strong>双胜态的演化结果</strong>。</li></ul></li></ul></li><li>胜态转化（胜态分级）：<ul><li>只能变成败态的胜态为<strong>1级胜态</strong></li><li>可以变成1级胜态和败态的称为<strong>2级胜态</strong>。可以变成1至n-1级的所有胜态，则我们称之为<strong>n级胜态</strong>。</li><li>败态可以称为<strong>零级</strong>。</li></ul></li><li>双胜态烟花结果：<ul><li>双同级胜态：一方降低某胜态等级时，另一方降低另一个胜态到同样等级，最后先手方会得到双败态，因此<strong>双同级胜态下先手必败</strong>。</li><li>不同级胜态：一方可以将两胜态级数降到一致，对方面临双同级胜态，因此<strong>不同级胜态下先手必胜</strong>。</li></ul></li></ul><p><em>逻辑补充</em></p><ul><li>如果一个胜态A可以变成败态或二级胜态，但不能变成一级胜态，那么它应该算一级还是三级呢？<strong>根据胜态的定义，是一级胜态。</strong></li><li>如果胜态会升级，是否会出现意料外的结果？<strong>不会</strong>，如果定义为1级的胜态可以被升级为2级胜态，那么对手也可以将其降回原等级，避免先手方通过升级操作获取胜利。</li></ul><p><em>SG数的定义</em><br>通过定义胜态的级数，我们<strong>解决了两个胜态组合而成的母状态的胜负判定问题</strong>。事实上，我们定义的“级数”，就是传说中的Sprague-Grundy数（简称SG数）。SG数是一个从状态映射到非负整数的函数，它的形式化定义如下：<br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/Pasted-image-20231101214618.png"></p><p><em>多状态与母态</em><br>前面解决了两个状态组合的母态问题，对于若干个状态的组合，可以总结出结论：<strong>状态的组合对应着SG数的异或</strong>。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/20611132">10170 Sprague-Grundy定理是怎么想出来的</a></p></blockquote><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/flip-game-ii/">294. 翻转游戏 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// Sprague-Grundy 定理</span><br>    <span class="hljs-comment">// https://zhuanlan.zhihu.com/p/20611132</span><br>    <span class="hljs-comment">// https://edwiv.com/wp-content/uploads/2019/08/ACM-ICPC_Templates_201805.pdf</span><br>    <span class="hljs-comment">// https://oi-wiki.org/math/game-theory/impartial-game/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWin</span><span class="hljs-params">(String currentState)</span> &#123;<br>    <span class="hljs-comment">// 记录字符串中的各“连续+的状态”</span><br>        List&lt;Integer&gt; dec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        currentState = currentState + <span class="hljs-string">&quot;s&quot;</span>;<br>        <span class="hljs-comment">// 记录连续出现的+数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 记录最大的“连续+数量”</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dpSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : currentState.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dec.add(cnt);<br>                dpSize = Math.max(dpSize, cnt);<br>                cnt = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dpSize &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><span class="hljs-comment">// 最大只需要解决连续dpSize个“+”的问题，dp[i]代表该状态的SG值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[dpSize + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 枚举所有“连续若干个+”状态（0,1 时返回 false，从 2 开始遍历）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= dpSize; i++) &#123;<br>            <span class="hljs-comment">// set存储下一个状态的所有可能的sg值</span><br>            Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-comment">// 枚举当前状态拆分成的两个状态</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i / <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-comment">// 当前状态的sg值为等于各分解子状态（sg值）的异或和</span><br>                set.add(dp[j] ^ dp[i - j - <span class="hljs-number">2</span>]);<br>            &#125;<br>            <span class="hljs-comment">// 根据sg值的定义，由所有可能的下一个状态倒推当前状态的sg值</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= i / <span class="hljs-number">2</span>; k++) &#123;<br>                <span class="hljs-keyword">if</span> (set.contains(k)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i] = k;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 上面解决了原状态的每个分状态的sg值，最后根据定义计算当前状态的sg值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : dec) &#123;<br>            a ^= dp[b];<br>        &#125;<br>        <span class="hljs-comment">// 如果当前状态不是败态，则先手必胜。</span><br>        <span class="hljs-keyword">return</span> a != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 当然，也可以使用粗暴的记忆化，为字符串整体状态做记忆</span><br><span class="hljs-keyword">private</span> Map&lt;String,Boolean&gt; hmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWin</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">if</span>(hmap.containsKey(s)) <span class="hljs-keyword">return</span> hmap.get(s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> s.substring(<span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;--&quot;</span> + s.substring(i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(!canWin(ss)) &#123;<br>                hmap.put(ss,<span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            hmap.put(ss,<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h1><p><a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//求斜率，保存结果，但对斜率做了特殊处理保证精度</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] ps)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ps.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">// 由当前点 i 发出的直线所经过的最多点数量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> ps[i][<span class="hljs-number">0</span>], y1 = ps[i][<span class="hljs-number">1</span>], x2 = ps[j][<span class="hljs-number">0</span>], y2 = ps[j][<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x1 - x2, b = y1 - y2;<br>                <span class="hljs-comment">//求a,b的最大公约数，这样斜率相同的a/k_b/k才相同</span><br>                <span class="hljs-comment">//且这里没有求斜率，而是分数形式，类似（a/k) / (b/k)</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> gcd(a, b);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (a / k) + <span class="hljs-string">&quot;_&quot;</span> + (b / k);<br>                map.put(key, map.getOrDefault(key, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>                max = Math.max(max, map.get(key));<br>            &#125;<br>            ans = Math.max(ans, max + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//欧几里得算法，求a,b的最大公约数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>证明如下：<br>a可以表示成a &#x3D; kb + r；<br>假设d是a,b的一个公约数，记作d|a,d|b，即a和b都可以被d整除。<br>而r &#x3D; a - kb，两边同时除以d，r&#x2F;d&#x3D;a&#x2F;d-kb&#x2F;d，由等式右边可知m&#x3D;r&#x2F;d为整数，因此d|r 因此d也是b,a mod b的最大公约数。</p></blockquote><p><a href="https://leetcode.cn/problems/valid-square/">593. 有效的正方形</a><br>随机组合对角线，要求对角线长度相等，斜率相反，中点重合。</p><p><a href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/">497. 非重叠矩形中的随机点</a><br>前提是矩阵之间不会重叠，可以为矩阵设置权重，或者直接将点加入结果集，通过二分定位所在矩阵。</p><p><a href="https://leetcode.cn/problems/zui-xiao-ju-xing-mian-ji/">LCP 37. 最小矩形面积</a><br>本质上，就是求所有交点，然后得到最大、最小的x、y轴坐标，但遍历会超时，巧妙做法参考：<a href="https://leetcode.cn/problems/zui-xiao-ju-xing-mian-ji/solution/xiang-lin-liang-lie-jue-dui-bu-hui-shu-d-s95z/">问题转换</a></p><p><a href="https://leetcode.cn/problems/minimum-area-rectangle/">939. 最小面积矩形</a></p><ul><li>枚举边，找另一个边</li><li>枚举对角线，找另一个对角线</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按边枚举</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAreaRect</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        Map&lt;Integer, List&lt;Integer&gt;&gt; rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] point: points) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> point[<span class="hljs-number">0</span>], y = point[<span class="hljs-number">1</span>];<br>            rows.computeIfAbsent(x, z-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>()).add(y);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        Map&lt;Integer, Integer&gt; lastx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: rows.keySet()) &#123;<br>            List&lt;Integer&gt; row = rows.get(x);<br>            Collections.sort(row);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row.size(); ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; row.size(); ++j) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> row.get(i), y2 = row.get(j);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-number">40001</span> * y1 + y2;<br>                    <span class="hljs-keyword">if</span> (lastx.containsKey(code))<br>                        ans = Math.min(ans, (x - lastx.get(code)) * (y2-y1));<br>                    lastx.put(code, x);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans &lt; Integer.MAX_VALUE ? ans : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//按对角线枚举</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minAreaRect</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        Set&lt;Integer&gt; pointSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] point: points)<br>            pointSet.add(<span class="hljs-number">40001</span> * point[<span class="hljs-number">0</span>] + point[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; points.length; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; points.length; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] != points[j][<span class="hljs-number">0</span>] &amp;&amp; points[i][<span class="hljs-number">1</span>] != points[j][<span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">if</span> (pointSet.contains(<span class="hljs-number">40001</span> * points[i][<span class="hljs-number">0</span>] + points[j][<span class="hljs-number">1</span>]) &amp;&amp;<br>                            pointSet.contains(<span class="hljs-number">40001</span> * points[j][<span class="hljs-number">0</span>] + points[i][<span class="hljs-number">1</span>])) &#123;<br>                        ans = Math.min(ans, Math.abs(points[j][<span class="hljs-number">0</span>] - points[i][<span class="hljs-number">0</span>]) *<br>                                            Math.abs(points[j][<span class="hljs-number">1</span>] - points[i][<span class="hljs-number">1</span>]));<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        <span class="hljs-keyword">return</span> ans &lt; Integer.MAX_VALUE ? ans : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h1><p><a href="https://leetcode.cn/problems/bulb-switcher-ii/">672. 灯泡开关 Ⅱ</a></p><ol><li>每个灯只有0，1态，所以只需要考虑<code>4^2=16</code>种情况。</li><li>最大循环长度为6，即<code>2*3</code>，而2灯泡和6灯泡，3灯泡和5灯泡的特征一致。因此只需要考虑1，3，4，5这4个灯的情况即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">flipLights</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> presses)</span> &#123;<br>        Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//枚举情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-comment">//pressArr代表各按钮的状态。</span><br>            <span class="hljs-type">int</span>[] pressArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>                pressArr[j] = (i &gt;&gt; j) &amp; <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//sum代表按下的按钮的个数，显然这个数不能大于presses</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(pressArr).sum();<br>            <span class="hljs-comment">//枚举出按下按钮的个数与实际总按下按钮的奇偶性应该保持一致。因为枚举的按钮情况是由总按下次数逐渐-2得到的。</span><br>            <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> == presses % <span class="hljs-number">2</span> &amp;&amp; sum &lt;= presses) &#123;<br>            <span class="hljs-comment">//status表示灯的状态</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> pressArr[<span class="hljs-number">0</span>] ^ pressArr[<span class="hljs-number">2</span>] ^ pressArr[<span class="hljs-number">3</span>];<br>                <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">2</span>) &#123;<br>                    status |= (pressArr[<span class="hljs-number">0</span>] ^ pressArr[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">3</span>) &#123;<br>                    status |= (pressArr[<span class="hljs-number">0</span>] ^ pressArr[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">4</span>) &#123;<br>                    status |= (pressArr[<span class="hljs-number">0</span>] ^ pressArr[<span class="hljs-number">1</span>] ^ pressArr[<span class="hljs-number">3</span>]) &lt;&lt; <span class="hljs-number">3</span>;<br>                &#125;<br>                seen.add(status);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> seen.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/">1015. 可被 K 整除的最小整数</a></p><ol><li>不断尝试1、11、111即可，但每次尝试后可以令其整除K一次。如11%3&#x3D;2，此时会将其扩大为21，其与111（90+21）是等效的。</li><li>根据以上操作，可通过set去重，发现重复即出现死循环。当然数学上可以证明只有K是2、5的倍数时才会出现死循环。</li></ol><p><a href="https://leetcode.cn/problems/sum-of-square-numbers/">633. 平方数之和</a></p><ul><li>枚举，使用sqrt排除</li><li>双指针</li><li>费马平方和定理：一个非负整数c如果能够表示为两个整数的平方和，当且仅当 <strong>c</strong> 的所有形如 <code>4k+3</code>的<strong>质因子</strong>的幂均为偶数，即<code>c = x^a * y^b * (4k1+3)^c1 * (4k2+3)^c2</code>中<code>c1</code>,<code>c2</code>均为偶数。</li></ul><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a><br>探索同一个数的索引变化即可，本质上，奇数，偶数索引执行的操作都是 <code>*2%(n-1)</code></p><p><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">LCR 187. 破冰游戏</a><br>约瑟夫环：要有递归思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">iceBreakingGame</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i != num + <span class="hljs-number">1</span>; ++i) &#123;<br>            f = (target + f) % i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/hanota-lcci/">面试题 08.06. 汉诺塔问题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hanota</span><span class="hljs-params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> A.size();<br>        move(N, A, B, C);<br>    &#125;<br>    <span class="hljs-comment">// 将N个圆盘从A柱经由B柱移动到C柱</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> N, List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 直接将A柱的圆盘移动到C柱</span><br>            C.add(<span class="hljs-number">0</span>, A.remove(<span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将N-1个移到B</span><br>        move(N - <span class="hljs-number">1</span>, A, C, B);<br>        <span class="hljs-comment">// 最大的移到C</span><br>        C.add(<span class="hljs-number">0</span>, A.remove(<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 再将N-1个移到C</span><br>        move(N - <span class="hljs-number">1</span>, B, A, C);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h1><h2 id="摩尔排序"><a href="#摩尔排序" class="headerlink" title="摩尔排序"></a>摩尔排序</h2><p>参考多数元素Ⅰ。</p><ul><li>分析可知本题最多有2个满足条件的值。可假设存在2个答案。</li><li>预先选出2个指标，遍历元素并与当前的2个指标对比，若不等于当前任一指标，则各指标数量都应该-1。若等于某指标，则对应指标应该+1。</li><li>最后校验得到的指标是否是目标值。</li></ul><p><a href="https://leetcode.cn/problems/majority-element-ii/">229. 多数元素 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">vote1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">vote2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="hljs-number">3</span>) &#123;<br>            ans.add(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="hljs-number">3</span>) &#123;<br>            ans.add(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h1><p><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a><br>拒绝采样：生成一个更大范围的随机数并拒绝其中一些元素即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        row := rand7()<br>        col := rand7()<br>        idx := (row<span class="hljs-number">-1</span>)*<span class="hljs-number">7</span> + col<br>        <span class="hljs-keyword">if</span> idx &lt;= <span class="hljs-number">40</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (idx<span class="hljs-number">-1</span>)%<span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（排序）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><a href="https://leetcode.cn/leetbook/read/sort-algorithms/eu039h/">参考LeetBook</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h3><p>每个数与后一个数比较，如果逆序则交换，故每次可冒出一个最大值，经过n次操作得到有序数组</p><h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>                swap(arr, j, j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 交换元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-升级"><a href="#3-升级" class="headerlink" title="3.升级"></a>3.升级</h3><ul><li>有时整个数组已经有序了，不需要排n次，应该直接返回。  </li><li>有时数组的后半段已经有序了，不需要反复对比到结尾，应该直接进入下一个循环。</li></ul><h3 id="4-处理"><a href="#4-处理" class="headerlink" title="4.处理"></a>4.处理</h3><ul><li>记录每次循环是否发生过交换，若没有则直接返回。 </li><li>记录每次循环最后一个发生交换的索引，下次循环只需要遍历到这个索引，该索引后面的数组已经有序。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">swapped</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 最后一个没有经过排序的元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">indexOfLastUnsortedElement</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 上次发生交换的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">swappedIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (swapped) &#123;<br>        swapped = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>                swap(arr, i, i + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 表示发生了交换</span><br>                swapped = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 更新交换的位置</span><br>                swappedIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span><br>        indexOfLastUnsortedElement = swappedIndex;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 交换元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h3><p>每次遍历，然后把最小的放到最前面。<br>与冒泡有点相似，不过冒泡是每次循环中每次对比都做交换，选择排序一个循环只做一次交换。</p><h3 id="2-基本实现-1"><a href="#2-基本实现-1" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> minIndex;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最小值的下标</span><br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将最小元素交换至首位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><ul><li>每次同时记录最大，最小值，减半循环次数</li></ul><h3 id="4-处理-1"><a href="#4-处理-1" class="headerlink" title="4.处理"></a>4.处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> minIndex, maxIndex;<br>    <span class="hljs-comment">// i 只需要遍历一半</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length / <span class="hljs-number">2</span>; i++) &#123;<br>        minIndex = i;<br>        maxIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最小值的下标</span><br>                minIndex = j;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最大值的下标</span><br>                maxIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成</span><br>        <span class="hljs-keyword">if</span> (minIndex == maxIndex) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 将最小元素交换至首位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>        <span class="hljs-comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。</span><br>        <span class="hljs-keyword">if</span> (maxIndex == i) maxIndex = minIndex;<br>        <span class="hljs-comment">// 将最大元素交换至末尾</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span> - i;<br>        temp = arr[lastIndex];<br>        arr[lastIndex] = arr[maxIndex];<br>        arr[maxIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一般而言，冒泡排序是稳定的，选择排序是不稳定的。</p></blockquote><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1.思路"></a>1.思路</h3><p>把一个新的数插入到原先的有序数组中<br>插入排序有两种写法：</p><ul><li>交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</li><li>移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。</li></ul><h3 id="2-基本写法"><a href="#2-基本写法" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//交换法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// j 记录当前数字下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>            swap(arr, j, j - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 更新当前数字下标</span><br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br><br><span class="hljs-comment">//移动法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-1"><a href="#3-优化-1" class="headerlink" title="3.优化"></a>3.优化</h3><p>移动法本身就是一种优化，不需要每次都交换，一直把比当前数大的数往后移动就好了。</p><blockquote><p>稳定</p></blockquote><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="1.思路"></a>1.思路</h3><p>对插入排序的一种优化，将数组拆分分别做插入排序，不断缩减分组的间隔。<br><em>原理</em></p><div class="note note-primary">            <p>希尔排序与 O(n^2)级排序算法的本质区别：<br>排序算法本质上就是一个消除逆序对的过程。如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对。反过来说，基于交换元素的排序算法要想突破 O(n^2)级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>          </div><p><em>重要性质</em><br>D(k+1)间隔有序的序列，结果D(k)间隔排序后们仍然是D(k+1)间隔有序的：<br><a href="https://zhuanlan.zhihu.com/p/137355984">证明</a></p><h3 id="2-基本写法-1"><a href="#2-基本写法-1" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 间隔序列，在希尔排序中我们称之为增量序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 分组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">groupStartIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;<br>            <span class="hljs-comment">// 插入排序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> groupStartIndex + gap; currentIndex &lt; arr.length; currentIndex += gap) &#123;<br>                <span class="hljs-comment">// currentNumber 站起来，开始找位置</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[currentIndex];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> currentIndex - gap;<br>                <span class="hljs-keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;<br>                    <span class="hljs-comment">// 向后挪位置</span><br>                    arr[preIndex + gap] = arr[preIndex];<br>                    preIndex -= gap;<br>                &#125;<br>                <span class="hljs-comment">// currentNumber 找到了自己的位置，坐下</span><br>                arr[preIndex + gap] = currentNumber;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-2"><a href="#3-优化-2" class="headerlink" title="3.优化"></a>3.优化</h3><ul><li>对于计算机而言，连续的访问数组元素更加快捷</li><li>增量序列：增量序列的选择会极大地影响希尔排序的效率。增量序列如果选得不好，希尔排序的效率可能比插入排序效率还要低，常用序列有Hibbard，Knuth，Sedgewick等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSortByKnuth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 找到当前数组需要用到的 Knuth 序列中的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxKnuthNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (maxKnuthNumber &lt;= arr.length / <span class="hljs-number">3</span>) &#123;<br>        maxKnuthNumber = maxKnuthNumber * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 增量按照 Knuth 序列规则依次递减</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> maxKnuthNumber; gap &gt; <span class="hljs-number">0</span>; gap = (gap - <span class="hljs-number">1</span>) / <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// currentNumber 站起来，开始找位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">// 该组前一个数字的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;<br>                <span class="hljs-comment">// 向后挪位置</span><br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap;<br>            &#125;<br>            <span class="hljs-comment">// currentNumber 找到了自己的位置，坐下</span><br>            arr[preIndex + gap] = currentNumber;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其平均时间复杂度为n到n^2之间，普遍认为其最好时间复杂度为n^1.3。一般可以认为其是一个nlogn的的排序算法。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="1.思路"></a>1.思路</h3><p><strong>构建大顶堆 &amp; 调整堆</strong><br>构建大顶堆有两种方式：</p><ul><li>方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求；</li><li>方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求，<strong>更为常用</strong>。</li></ul><h3 id="2-基本实现-2"><a href="#2-基本实现-2" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 构建初始大顶堆</span><br>    buildMaxHeap(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 将最大值交换到数组最后</span><br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">// 调整剩余数组，使其满足大顶堆</span><br>        maxHeapify(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 构建初始大顶堆</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        maxHeapify(arr, i, arr.length);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maxHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>    <span class="hljs-comment">// 左子结点下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右子结点下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-comment">// 与左子树结点比较</span><br>    <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;<br>        largest = l;<br>    &#125;<br>    <span class="hljs-comment">// 与右子树结点比较</span><br>    <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;<br>        largest = r;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-comment">// 将最大值交换为根结点</span><br>        swap(arr, i, largest);<br>        <span class="hljs-comment">// 再次调整交换数字后的大顶堆</span><br>        maxHeapify(arr, largest, heapSize);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>初始化建堆的时间复杂度为 O(n)<br>重建堆的时间复杂度为 O(nlogn)<br>堆排序总的时间复杂度为 O(nlogn)<br><strong>不稳定</strong></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><p>从数组中取出一个数，称之为基数（pivot）。遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。</p><h3 id="2-基本写法-2"><a href="#2-基本写法-2" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 如果区域内的数字少于 2 个，退出递归</span><br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将数组分区，并获得中间值的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> partition(arr, start, end);<br>    <span class="hljs-comment">// 对左边区域快速排序</span><br>    quickSort(arr, start, middle - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 对右边区域快速排序</span><br>    quickSort(arr, middle + <span class="hljs-number">1</span>, end);<br>&#125;<br><span class="hljs-comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 取第一个数为基数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[start];<br>    <span class="hljs-comment">// 从第二个数开始分区</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 找到第一个大于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;<br>        <span class="hljs-comment">// 找到第一个小于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;<br>        <span class="hljs-comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            exchange(arr, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span><br>    <span class="hljs-keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;<br>    <span class="hljs-comment">// 将基数和轴交换</span><br>    exchange(arr, start, right);<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>也可以双指针</p></blockquote><p>平均时间复杂度为 O(nlogn)<br>最坏的时间复杂度为O(n^2)<br>空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为O(logn)~O(n)，平均空间复杂度为 O(logn)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="1.思路"></a>1.思路</h3><p>两个数组合并成有序数组可以使用双指针的方式，那么我们可以从以1为数组长度开始合并，最后合成一个有序数组。</p><h3 id="2-基本实现-3"><a href="#2-基本实现-3" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span>[] result = mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将结果拷贝到 arr 数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对 arr 的 [start, end] 区间归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>    <span class="hljs-comment">// 只剩下一个数字，停止拆分，返回单个数字组成的数组</span><br>    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;arr[start]&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 拆分左边区域</span><br>    <span class="hljs-type">int</span>[] left = mergeSort(arr, start, middle);<br>    <span class="hljs-comment">// 拆分右边区域</span><br>    <span class="hljs-type">int</span>[] right = mergeSort(arr, middle + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-comment">// 合并左右区域</span><br>    <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-3"><a href="#3-优化-3" class="headerlink" title="3.优化"></a>3.优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, result);<br>&#125;<br><br><span class="hljs-comment">// 对 arr 的 [start, end] 区间归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] result)</span> &#123;<br>    <span class="hljs-comment">// 只剩下一个数字，停止拆分</span><br>    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间</span><br>    mergeSort(arr, start, middle, result);<br>    <span class="hljs-comment">// 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间</span><br>    mergeSort(arr, middle + <span class="hljs-number">1</span>, end, result);<br>    <span class="hljs-comment">// 合并左右区域到 result 的 [start, end] 区间</span><br>    merge(arr, start, end, result);<br>&#125;<br><br><span class="hljs-comment">// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] result)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> end1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 用来遍历数组的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> start2;<br>    <span class="hljs-keyword">while</span> (index1 &lt;= end1 &amp;&amp; index2 &lt;= end) &#123;<br>        <span class="hljs-keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;<br>            result[index1 + index2 - start2] = arr[index1++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[index1 + index2 - start2] = arr[index2++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将剩余数字补到结果数组之后</span><br>    <span class="hljs-keyword">while</span> (index1 &lt;= end1) &#123;<br>        result[index1 + index2 - start2] = arr[index1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (index2 &lt;= end) &#123;<br>        result[index1 + index2 - start2] = arr[index2++];<br>    &#125;<br>    <span class="hljs-comment">// 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较</span><br>    <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>        arr[start] = result[start++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 logn 次，每层执行的比较次数都约等于 n 次，所以时间复杂度是&#x3D;&#x3D;O(nlogn)。</p><p>分析归并的过程可知，归并排序是一种稳定的排序算法。</p><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>归并排序的过程必然可以消除逆序对，且不会进行多余的交换，因此可以从其入手，通过求数组某一范围内的逆序对个数，排序后归并，再次求逆序对个数。</p><p><strong>数组中的逆序对</strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> mergeSort(nums);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">return</span> mergeSort(nums, result, <span class="hljs-number">0</span>, length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span>[] result,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == end) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> mergeSort(nums,result,start,middle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightCount</span> <span class="hljs-operator">=</span> mergeSort(nums,result,middle+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mergeCount</span> <span class="hljs-operator">=</span> merge(nums,result,start,end);<br>        <span class="hljs-keyword">return</span> leftCount+mergeCount+rightCount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span>[] result,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> middle+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> start2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(index1&lt;=middle &amp;&amp; index2&lt;=end)&#123;<br>            <span class="hljs-keyword">if</span>(nums[index1]&lt;=nums[index2])&#123;<br>                result[index1+index2-start2] = nums[index1++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[index1+index2-start2] = nums[index2++];<br>                count += middle-index1+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index1&lt;=middle)&#123;<br>            result[index1+index2-start2] = nums[index1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index2&lt;=end)&#123;<br>            result[index1+index2-start2] = nums[index2++];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;i++)&#123;<br>            nums[i] = result[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="1-思路-6"><a href="#1-思路-6" class="headerlink" title="1.思路"></a>1.思路</h3><p>统计每个数的大小和出现的次数，然后按从小到大排列。</p><h3 id="2-基本实现-4"><a href="#2-基本实现-4" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 判空及防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定计数范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[range];<br>    <span class="hljs-comment">// 遍历 arr 中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span><br>        counting[element - min]++;<br>    &#125;<br>    <span class="hljs-comment">// 记录前面比自己小的数字的总数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">preCounts</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; range; i++) &#123;<br>        <span class="hljs-comment">// 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。</span><br>        counting[i] = preCounts;<br>        <span class="hljs-comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span><br>        preCounts += counting[i];<br>    &#125;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// counting[element - min] 表示此元素在结果数组中的下标</span><br>        result[counting[element - min]] = element;<br>        <span class="hljs-comment">// 更新 counting[element - min]，指向此元素的下一个下标</span><br>        counting[element - min]++;<br>    &#125;<br>    <span class="hljs-comment">// 将结果赋值回 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-4"><a href="#3-优化-4" class="headerlink" title="3.优化"></a>3.优化</h3><p>在计算元素在最终结果数组中的下标位置这一步，不是计算初始下标位置，而是计算最后一个下标位置。最后倒序遍历 arr 数组，逐个将 arr 中的元素放到最终位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定计数范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[range];<br>    <span class="hljs-comment">// 遍历 arr 中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span><br>        counting[element - min]++;<br>    &#125;<br><br><span class="hljs-comment">//关键</span><br>    <span class="hljs-comment">// 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可</span><br>    counting[<span class="hljs-number">0</span>]--;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; range; i++) &#123;<br>        <span class="hljs-comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1</span><br>        <span class="hljs-comment">// 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。</span><br>        counting[i] += counting[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-comment">// 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span><br>        result[counting[arr[i] - min]] = arr[i];<br>        <span class="hljs-comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span><br>        counting[arr[i] - min]--;<br>    &#125;<br>    <span class="hljs-comment">// 将结果赋值回 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计数排序的时间复杂度为 O(n + k)，k 表示数据的范围大小。<br>用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 O(n + k)。</p><blockquote><p>计数排序只适用于数据范围不大的场景，否则count数组会很大。如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p></blockquote><blockquote><p>计数排序凭什么能够突破 O(nlogn)的下界呢？<br>如果基于比较来进行排序，无论怎么优化都无法突破 O(nlog n)的下界。计数排序和基于比较的排序算法相比，根本区别就在于：它不是基于比较的排序算法，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。</p></blockquote><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="1-思路-7"><a href="#1-思路-7" class="headerlink" title="1.思路"></a>1.思路</h3><p>类似于计数排序，但是每次只计算数值特定位数（基数）的出现次数和大小，这样，从低位往高位循环排列，最后就可以得到一个有序的数组。</p><h3 id="2-基本实现-5"><a href="#2-基本实现-5" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><ul><li>「最低位优先法」，简称 <code>LSD (Least significant digital)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找出最长的数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-keyword">if</span> (Math.abs(value) &gt; max) &#123;<br>            max = Math.abs(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算最长数字的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigitLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        maxDigitLength++;<br>        max /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">19</span>];<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigitLength; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-comment">// 下标调整</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> value / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            counting[radix]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; counting.length; j++) &#123;<br>            counting[j] += counting[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 使用倒序遍历的方式完成计数排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 下标调整</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[j] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            result[--counting[radix]] = arr[j];<br>        &#125;<br>        <span class="hljs-comment">// 计数排序完成后，将结果拷贝回 arr 数组</span><br>        System.arraycopy(result, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, arr.length);<br>        <span class="hljs-comment">// 将计数数组重置为 0</span><br>        Arrays.fill(counting, <span class="hljs-number">0</span>);<br>        dev *= <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为此处考虑了加入负数的排序，所以基数应该为-9~9，共19位数，所以创建一个19长度的count数组。求出绝对值最大的数的长度后，按照这个长度进行循环的计数排序并重置数组。</p></blockquote><ul><li>「最高位优先法」，简称 <code>MSD (Most significant digital)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(value) &gt; max) &#123;<br>                max = Math.abs(value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算最大长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDigitLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            maxDigitLength++;<br>            max /= <span class="hljs-number">10</span>;<br>        &#125;<br>        radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxDigitLength);<br>    &#125;<br><br>    <span class="hljs-comment">// 对 arr 数组中的 [start, end] 区间进行基数排序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == end || position == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 使用计数排序对基数进行排序</span><br>        <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">19</span>];<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[end - start + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, position - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// MSD, 从最高位开始</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[i] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            counting[radix]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; counting.length; j++) &#123;<br>            counting[j] += counting[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 拷贝 counting，用于待会的递归</span><br>        <span class="hljs-type">int</span>[] countingCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[counting.length];<br>        System.arraycopy(counting, <span class="hljs-number">0</span>, countingCopy, <span class="hljs-number">0</span>, counting.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> end; i &gt;= start; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[i] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            result[--counting[radix]] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">// 计数排序完成后，将结果拷贝回 arr 数组</span><br>        System.arraycopy(result, <span class="hljs-number">0</span>, arr, start, result.length);<br>        <span class="hljs-comment">// 对 [start, end] 区间内的每一位基数进行递归排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; counting.length; i++) &#123;<br>            radixSort(arr, i == <span class="hljs-number">0</span> ? start : start + countingCopy[i - <span class="hljs-number">1</span>], start + countingCopy[i] - <span class="hljs-number">1</span>, position - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 O(n + k)，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。</p><p>所以基数排序的时间复杂度为&#x3D;&#x3D;O(d(n + k))&#x3D;&#x3D;(d 表示最长数字的位数，k 表示每个基数可能的取值范围大小)。<br>使用的空间和计数排序是一样的，空间复杂度为 &#x3D;&#x3D;O(n + k)&#x3D;&#x3D;（k 表示每个基数可能的取值范围大小）。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="1-思路-8"><a href="#1-思路-8" class="headerlink" title="1.思路"></a>1.思路</h3><p>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶;遍历数组，将每个数字装入桶中;对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等;最后按照顺序将所有桶内的数字合并起来。</p><blockquote><p>桶排序在实际工作中的应用较少，不仅因为它需要借助于其他排序算法，还因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。</p></blockquote><h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h3><p>这两个因素会直接影响到桶排序的内存和效率：<br><strong>桶的数量</strong>：桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。具体设置多少个桶需要根据实际情况决定。</p><p><strong>桶的数据结构</strong>：如果将桶的数据结构设置为数组，那么每个桶的长度必须设置为待排序数组的长度，因为我们需要做好最坏的打算，即所有的数字都被装入了同一个桶中，所以这种方案的空间复杂度会很高。</p><ul><li>以数组作为桶：默认以原数组的长度作为桶数组的长度，但这样很可能会造成大量的空间浪费。因此可以对此做优化，声明时所有的数组都为空，当需要添加数字时，不断扩容，并加入新数字。完整代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 判空及防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定取值范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min;<br>    <span class="hljs-comment">// 设置桶的数量，这里我们设置为 100 个，可以根据实际情况修改。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketAmount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 桶和桶之间的间距</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> range * <span class="hljs-number">1.0</span> / (bucketAmount - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 用二维数组来装桶，第一个维度是桶的编号，第二个维度是桶中的数字。初始化长度为 0</span><br>    <span class="hljs-type">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bucketAmount][];<br>    <span class="hljs-comment">// 装桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-comment">// 找到 value 属于哪个桶</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((value - min) / gap);<br>        buckets[index] = add(buckets[index], value);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 对每个桶内的数字进行单独排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketAmount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">null</span> || buckets[i].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 这里需要结合其他排序算法，例如：插入排序</span><br>        insertSort(buckets[i]);<br>        <span class="hljs-comment">// 排序完成后将桶内的结果收集起来</span><br>        System.arraycopy(buckets[i], <span class="hljs-number">0</span>, arr, index, buckets[i].length);<br>        index += buckets[i].length;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 数组扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] add(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> num) &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num&#125;;<br>    <span class="hljs-type">int</span>[] newArr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>    newArr[arr.length] = num;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以链表为桶，则创建一个：<code>HashMap&lt;Integer,Integer&gt;</code>，链表不需要扩容，但排序慢，一般采用插入排序。</li><li>折中的方案:装桶时用链表，桶内排序用数组。</li></ul><h3 id="3-复杂度-1"><a href="#3-复杂度-1" class="headerlink" title="3.复杂度"></a>3.复杂度</h3><ul><li>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 O(n)，空间复杂度 O(1)。</li><li>第二步：装桶的过程需要遍历一轮数组，时间复杂度 O(n)，空间复杂度与桶的数量以及数据结构有关，设桶的数量为 k，如果使用 k 个长度为 n 的数组作为桶，则空间复杂度为 O(kn)，如果采用 ArrayList 或 LinkedList 来装桶，或者采用初始长度为 0 ，装桶时不断扩容的数组，则空间复杂度为 O(n)。</li><li>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 n&#x2F;k，如果采用 O(n^2)级排序算法，则每个桶内排序的时间复杂度为 O((n&#x2F;k)^2)，所有桶完成排序的时间复杂度为 O(k(n&#x2F;k)^2，即 O(n^2 &#x2F; k)。<ul><li>如果采用O(nlogn) 级排序算法，每个桶内排序的时间复杂度 O((n&#x2F;k) log (n&#x2F;k))，所有桶完成排序的时间复杂度为 O(k(n&#x2F;k) log (n&#x2F;k))，即 O(n log (n&#x2F;k))。</li><li>在桶的数量合适的情况下，时间复杂度 O(n^2 &#x2F; k)和 O(nlog(n&#x2F;k)) 都约等于 O(n)。</li><li>桶内排序的空间复杂度也和具体的排序算法有关，O(1)O(1) 或者 O(n)O(n)。</li></ul></li><li>第四步：如果采用 LinkedList 转 <code>int[]</code> 再排序这种方式，由于转换过程需要一轮遍历，所以会增加O(n)的时间复杂度和O(n)的空间复杂度。</li></ul><p><strong>综上可知，桶排序的时间复杂度为 O(n)，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 O(n log n) 级的排序算法快。空间复杂度为 O(n)。</strong></p><div class="note note-primary">            <p>个人理解，这里复杂度为n的方法都是利用了数字本身的性质，即每个待比较的对象都是利用数字进行比较，这个数字是一个绝对且具有传递性（x&gt;y,y&gt;z，则x&gt;z）的属性，所以我们可以直接根据该属性为对象排到其相应的位置。</p>          </div><h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡</td><td>n2</td><td>1</td><td>稳定（取决于实现）</td></tr><tr><td>选择</td><td>n2</td><td>1</td><td>不稳定（另开一个数组时稳定）</td></tr><tr><td>插入</td><td>n2</td><td>1</td><td>稳定</td></tr><tr><td>希尔</td><td>nlogn</td><td>1</td><td>不稳定</td></tr><tr><td>堆</td><td>nlogn</td><td>1</td><td>不稳定</td></tr><tr><td>快排</td><td>nlogn</td><td>logn</td><td>不稳定</td></tr><tr><td>归并</td><td>nlogn</td><td>n</td><td>稳定</td></tr><tr><td>计数</td><td>n+k</td><td>n+k</td><td>稳定</td></tr><tr><td>基数</td><td>d(n+k)</td><td>n+k</td><td>稳定</td></tr><tr><td>桶</td><td>n</td><td>n</td><td>稳定</td></tr></tbody></table><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>swap(int[] arr,int l,int r)</code>其中l和r不能相等，否则相当于与自己异或，等于0。</p><h1 id="三、工业级排序"><a href="#三、工业级排序" class="headerlink" title="三、工业级排序"></a>三、工业级排序</h1><h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><h2 id="1-总体流程"><a href="#1-总体流程" class="headerlink" title="1.总体流程"></a>1.总体流程</h2><p><code>Arrays</code> 类中有很多个 <code>sort</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">long</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">long</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">short</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">short</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">char</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">char</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">byte</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">byte</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">float</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">float</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">double</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">double</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(Object[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(Object[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(T[], Comparator)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(T[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, Comparator)</span><br></code></pre></td></tr></table></figure><blockquote><p>这些 sort 函数可以分为两类：</p><ul><li>对基本类型的排序（int、long、short、char、byte、float、double），对基本类型的排序是通过调用对应的 <code>DualPivotQuicksort.sort()</code> 函数完成的。</li><li>对非基本类型的排序（Object、T），对非基本类型的排序采用的是 TimSort 或者归并排序，在 JDK 1.7 之前，默认采用归并排序，JDK 1.7 及之后，默认采用 TimSort。</li><li>但可以通过设置 JVM 参数 <code>-Djava.util.Arrays.useLegacyMergeSort=true</code> 继续使用归并排序。</li></ul></blockquote><h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2.基本类型"></a>2.基本类型</h2><p><code>dualPivotQuicksort</code>源码很长，是Arrays.sort在处理基本类型的排序时的实现。<br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/Pasted-image-20230313102458.png"></p><h3 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h3><p><code>TimSort</code>的主要思想是：通过遍历数组，将数组拆分成若干个单调递增的子数组。每一块称为一个 run。拆分完成后，再将 run 两两合并起来。<br><code>TimSort</code> 在对<strong>部分有序</strong>的数组进行排序时，速度很快。因为整个数组可以拆分成少量的 run 小块，将其合并即可完成排序。我们称这一类只能被拆分成少量 run 小块的数组是「高度结构化」的 (<strong>highly structured</strong>)。</p><p>在拆分 run 小块的过程中，有两个条件会<strong>停止调用 TimSort</strong>：</p><ul><li>连续相同的数字的数量到达了33个：</li><li>排序时以 k 为索引遍历整个数组，比较相邻数字的大小关系：<ul><li>如果数字在递增，记录下此 run 小块</li><li>如果数字在递减，记录下此 run 小块，并翻转这部分子数组</li><li>如果数字相等，记录下此 run 小块，并判断连续相等的数字是否达到了 MAX_RUN_LENGTH 个，如果达到了 <code>MAX_RUN_LENGTH</code>，则不再使用 TimSort，改为调用 sort(int[] a, int left, int right, boolean leftmost) (leftMost参数)函数进行排序。<br>  在这个被调用的方法中，有对重复数字过多时的排序改进。</li></ul></li><li>run的块数量达到了<code>MAX_RUN_COUNT</code>(67)，如果run块的数量超过了67，说明其并不是高度结构化数据，不适合TimSort。</li></ul><div class="note note-primary">            <p>总结：timsort是对归并算法的优化，通过将归并的分块变成直接使用数组中的递增，递减数组。但若这样的分块过多或重复数字过多，则退化成其他排序方法。</p>          </div><h3 id="插入排序-amp-双插入排序"><a href="#插入排序-amp-双插入排序" class="headerlink" title="插入排序 &amp; 双插入排序"></a>插入排序 &amp; 双插入排序</h3><p>首先仍然是判断数组长度，如果小于 INSERTION_SORT_THRESHOLD（它的值是 47），则采用插入排序算法或双插入排序算法进行排序。如果数据量达到了 47，则采用双轴快排算法进行排序。这是因为<strong>插入排序在数据量小的时候，排序性能比较好</strong>。</p><p><strong>leftMost</strong>表示当前排序的数据范围是否是待排序区间的最左端。如果是最左端，则采用插入排序算法对其排序，否则采用双插入排序的算法进行排序。</p><p>插入排序和双插入排序的区别是（以排升序为例）：</p><ul><li>插入排序时，每次从待排序的数字中取一个数字，将其插入到前方已经有序的数组中。（移动法）</li><li>双插入排序时，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。</li></ul><blockquote><p>当前排序的数据范围如果不是待排序区间最左端，则保证left-1不越界，且left-1的数值一定比left及其右边的小，从而保证插入排序不会越界。</p><p>双轴快排会把数组分为左中右三个区域，分区之后，左边区域的任何一个数字都小于中间区域，中间区域的任何一个数字都小于右边区域，所以每个待排序区间的前一个数字都承担了「哨兵」的职责。</p><p>这也正是 <code>leftMost</code> 参数存在的意义：<strong>因为最左端区间没有「哨兵」，所以只有对非最左端区间排序时，才能采用这种不做边界检查的双插入排序</strong>。</p></blockquote><h3 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h3><p>双轴快排每轮选取两个轴 pivot1、pivot2 (pivot1 &lt; pivot2)，然后以两个轴为分界，将数组分为左中右三个区域。交换三个区域内的数字，使得三个区域分别属于区间 <code>(-∞, pivot1)</code>、<code>[pivot1, pivot2]</code>、<code>(pivot2, +∞)</code>。然后再对左中右区域不断重复此过程，直至排序完成。</p><p>通过从中间位置往前和往后分别走两次数组长度的 1&#x2F;7步长，取到了5个备选轴的下标：e1、e2、e3、e4、e5。</p><p>选择第二、四个数做轴，如果五个备选轴中，出现了相等元素，用单轴进行分区。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote><ol><li><p>当数组长度达到 286 ，并且不存在较多连续相等元素，并且「高度结构化」时，采用类似 TimSort 的算法进行排序。<br>其中用到的 TimSort 思想是：先拆分出单调递增的 run 小块，然后将 run 小块两两合并完成排序，合并时原数组和辅助数组会交替合并。</p></li><li><p>当数组长度小于 INSERTION_SORT_THRESHOLD（即 47）时，采用插入排序或双插入排序。<br>其中，双插入排序的思想是，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。</p></li><li><p>否则，采用双轴快排进行排序。双轴快排的思想是：每轮选取两个轴 <code>pivot1、pivot2,(pivot1 &lt; pivot2)</code>，然后以两个轴为分界，将数组分为左中右三个区域。交换三个区域内的数字，使得三个区域分别属于区间<code> (-∞, pivot1)、[pivot1, pivot2]、(pivot2, +∞)</code>。然后再对左中右区域不断重复此过程，直至排序完成。<br>分区后，如果中间区域过大（大于数组长度的 4&#x2F;7），则将中间区域再次分成三个区域： <code>[pivot1, pivo1]</code>、<code>(pivot1, pivot2)</code>、<code>[pivot2,pivot2]</code>，只让 <code>(pivot1, pivot2)</code> 区间参与下一轮双轴快排。(可能是因为认为边界元素重复多)<br>如果整个数组中存在较多的相等元素，则不再取两个轴，而是只取一个轴，按照 <code>(-∞, pivot)、[pivot, pivot]、(pivot, +∞)</code>，<code>(−∞,pivot)、[pivot,pivot]、(pivot,+∞)</code> 进行分区。然后对左右两个区域不断重复此过程，直至排序完成。</p></li></ol></blockquote><h1 id="三、排序-x2F-二分搜索问题"><a href="#三、排序-x2F-二分搜索问题" class="headerlink" title="三、排序&#x2F;二分搜索问题"></a>三、排序&#x2F;二分搜索问题</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a><br>计数后堆排序解决。</p><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a><br>以任意一点为节点，其左右两侧必然有一侧是单调递增的。考察看目标数在不在这个范围内。</p><p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a><br>元素的右上角相当于一个二叉搜索树的根节点。</p><p><a href="https://leetcode.cn/problems/wiggle-sort/">280. 摆动排序</a><br><a href="https://leetcode.cn/problems/wiggle-sort-ii/">324. 摆动排序 II</a></p><ol><li>先排序，将数组分前后两段（前段长度 &#x3D;&#x3D; 后段 或 ＞ 后段），错位插入。</li><li>对于Ⅱ，注意，如果某个中位数的重复次数等于数组的长度，可能会导致错位插入，如果想要得到排序，此时中位数应该在最终序列的头部或尾部。因此应该将两个数组倒置，这样如果前端有中位数一定在最后序列的头部。</li></ol><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a><br>双堆</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p><ol><li>堆</li><li>快排，并剪枝</li></ol><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><ol><li>利用归并排序，每次归并两个线段时，可以通过索引判断这个数的逆序对。</li><li>离散化树状数组：一个逆序对，即一个数字后面有多少个比该数小的元素，如果采用从后往前填入，则可以很方便的查询逆序对。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, tmp, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-comment">//对原数进行排序，找到每一个值在树状数组中的索引+1。</span><br>        Arrays.sort(tmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            nums[i] = Arrays.binarySearch(tmp, nums[i]) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 建立树状数组</span><br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-comment">//从后开始搜索每一个原值在树状数组中的位置，并添加比该值大的数。</span><br>            ans += bit.query(nums[i] - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//添加该数</span><br>            bit.update(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += tree[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            ++tree[x];<br>            x += lowbit(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a><br>二分搜索，遇到相等的值</p><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素</a><br>对于任意一个数，其左上角部分的元素肯定是比该数小的。</p><ol><li>归并排序，直接对各行进行归并，找到第k个即可返回。</li><li>从右上角开始应用二叉搜索树的性质找分界线。</li></ol><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a><br>相当于寻找第k小的数（k&#x3D;(m+n)&#x2F;2 || k&#x3D;(m+n+1)&#x2F;2）。<br>可以先将两个数组的前k个数都取出来，然后每次淘汰某个数组中k&#x2F;2的人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLength</span> <span class="hljs-operator">=</span> length1 + length2;<br>        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midIndex</span> <span class="hljs-operator">=</span> totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> median;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midIndex1</span> <span class="hljs-operator">=</span> totalLength / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">return</span> median;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKthElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><br><span class="hljs-comment">         * 这里的 &quot;/&quot; 表示整除</span><br><span class="hljs-comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><br><span class="hljs-comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="hljs-comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><br><span class="hljs-comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><br><span class="hljs-comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kthElement</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-keyword">if</span> (index1 == length1) &#123;<br>                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index2 == length2) &#123;<br>                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Math.min(nums1[index1], nums2[index2]);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> k / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newIndex1</span> <span class="hljs-operator">=</span> Math.min(index1 + half, length1) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newIndex2</span> <span class="hljs-operator">=</span> Math.min(index2 + half, length2) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot1</span> <span class="hljs-operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-average-subarray-ii/">644. 子数组最大平均数 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMaxAverage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//求数组的极值</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">max_val</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">min_val</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n: nums) &#123;<br>            max_val = Math.max(max_val, n);<br>            min_val = Math.min(min_val, n);<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">while</span> (error &gt; <span class="hljs-number">0.00001</span>) &#123;<br>            <span class="hljs-comment">//取中值，放入nums中验证</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (max_val + min_val) * <span class="hljs-number">0.5</span>;<br>            <span class="hljs-comment">//如果平均值可能大于等于mid，则令左侧为mid，否则另右侧为mid（不可-1，这是一个浮点数二分）</span><br>            <span class="hljs-keyword">if</span> (check(nums, mid, k))&#123;<br>                min_val = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                max_val = mid;<br>            &#125;<br>            <span class="hljs-comment">//计算目标本轮相对上一轮的调整值</span><br>            error = Math.abs(max_val - min_val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (max_val + min_val) * <span class="hljs-number">0.5</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//验证平均值是否可以大于等于mid，如果能，则返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">double</span> mid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, prev = <span class="hljs-number">0</span>, min_sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++)<br>            sum += nums[i] - mid;<br>        <span class="hljs-keyword">if</span> (sum &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            sum += nums[i] - mid;<br>            prev += nums[i - k] - mid;<br>            min_sum = Math.min(prev, min_sum);<br>            <span class="hljs-keyword">if</span> (sum &gt;= min_sum)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（贪心）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、区间贪心"><a href="#一、区间贪心" class="headerlink" title="一、区间贪心"></a>一、区间贪心</h1><p>优选问题一般体现为：</p><ul><li>相同成本，不同收益（871.加油次数）</li><li>相同收益，不同成本（630.课程表3）</li><li>相同成本和收益，但某种选择对后续的选择更有利。</li><li>有选择限制：如必须在某时间前才能选择&#x2F;必须到达某处才能选择</li></ul><p>贪心的思路也因此分几种：</p><ul><li>先尽可能地不选择，等遇到选择限制时，再选择最优选择。</li><li>先尽可能地选择，等遇到选择限制时，再替换现有地选择。</li></ul><p><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/">871. 最低加油次数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minRefuelStops</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startFuel, <span class="hljs-type">int</span>[][] stations)</span> &#123;<br>        <span class="hljs-comment">//加油站排序</span><br>        Arrays.sort(stations,(a,b) -&gt; a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//当前可以添加的燃料集合（最大堆）</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b-a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sBound</span> <span class="hljs-operator">=</span> stations.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//当前无法到达目的</span><br>        <span class="hljs-keyword">while</span>(startFuel&lt;target)&#123;<br>            <span class="hljs-comment">//将当前可以加到的燃料添加到堆中</span><br>            <span class="hljs-keyword">while</span>(sIndex&lt;sBound &amp;&amp; stations[sIndex][<span class="hljs-number">0</span>]&lt;=startFuel)&#123;<br>                queue.add(stations[sIndex++][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//优先加最大的燃料，没燃料可加时返回-1</span><br>            <span class="hljs-keyword">if</span>(queue.isEmpty())&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//加燃料</span><br>                startFuel += queue.poll();<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/course-schedule-iii/">630. 课程表 III</a><br>贪心思路引导：</p><ul><li>如果每节课需要的时间为0，则从开始不停地<strong>一直学</strong>肯定能在各截止时间前完成。</li><li>时间相同时先后顺序：假如现实中每节课需要的时间相同且不为0，则优先策略肯定是先学截止时间早的。</li><li>先后交叠时时间不同：如果学第x节课时，发现时间不够。如果发现前面的某节课耗时比本节课长，说明放弃前面的那节课必然可以学第x节课，可以放弃前面课程来学学x课程，此时则必然对后面的课程选择更有利。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scheduleCourse</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] courses)</span> &#123;<br>    <span class="hljs-comment">//对截止时间进行顺序排序</span><br>        Arrays.sort(courses, (a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//大顶堆优先队列，表示已经学习的所有课程</span><br>        PriorityQueue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; b - a);<br>        <span class="hljs-comment">// 优先队列中所有课程的总时间，表示目前学习的课程的总时长</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] course : courses) &#123;<br>        <span class="hljs-comment">//本节课的耗时和截止时间</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ti</span> <span class="hljs-operator">=</span> course[<span class="hljs-number">0</span>], di = course[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//如果本节课可以学</span><br>            <span class="hljs-keyword">if</span> (total + ti &lt;= di) &#123;<br>                total += ti;<br>                q.offer(ti);<br>                <span class="hljs-comment">//如果不能学，则查看上一节课与本节课的耗时，调整课程</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!q.isEmpty() &amp;&amp; q.peek() &gt; ti) &#123;<br>                total -= q.poll() - ti;<br>                q.offer(ti);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后</span><br>        <span class="hljs-keyword">return</span> q.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a><br>按照截止时间排序，覆盖时优先保留前面的。<br>按照开始时间排序也可以。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a><br>对气球的末尾排序，每次射箭优先射击尾部边缘，对于刁钻的边界条件需要先将第一个气球打破。</p><p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a><br>每次跳跃时，衡量目的跳跃点可以提供的 “最远距离”来选择目的跳跃点，当可以直接跳到末尾时返回。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/">2086. 从房屋收集雨水需要的最少水桶数</a><br>为一个房屋添加水桶时，显然应该添加在其右侧，这样才能尽可能照顾到后面的房子。但如果其右侧没有空位时，则妥协地添加到其左侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumBuckets</span><span class="hljs-params">(String hamsters)</span> &#123;<br>        <span class="hljs-type">char</span>[] hamster = hamsters.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> hamster.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">filled</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//如果当前位置是房子</span><br>            <span class="hljs-keyword">if</span>(hamster[i] == <span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>                <span class="hljs-comment">//如果房子前面有水桶</span><br>                <span class="hljs-keyword">if</span>(filled == i-<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//如果房子后面有空位</span><br>                    <span class="hljs-keyword">if</span>(i&lt;n-<span class="hljs-number">1</span> &amp;&amp; hamster[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                        filled = i+<span class="hljs-number">1</span>;<br>                        ans++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//如果房子前面有空位</span><br>                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; hamster[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                            filled = i-<span class="hljs-number">1</span>;<br>                            ans++;<br>                            <span class="hljs-comment">//都没有则返回失败</span><br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、过程贪心"><a href="#二、过程贪心" class="headerlink" title="二、过程贪心"></a>二、过程贪心</h1><p><a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/">1605. 给定行和列的和求可行矩阵</a><br>优先将行列中还可以填入的数字填入，具体地：遍历矩阵，每次取当前行，列中较小值，然后将对应行，列的和减去该值。</p><p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></p><ol><li>一次遍历，从左往右发糖果时贪心的思路：<ul><li>遇到递增的分数，每次给孩子比上一个人多一个糖果即可，如果孩子比上一个人分数低，则直接分一个。</li><li>但是如果后面的孩子分数更低，却无法分0个，导致无解。我们可以通过记录递减孩子队列的长度，最后将所有递减队列中的孩子的糖果提高到0以上，此时并不会破坏递增序列中的摆放。</li></ul></li><li>两次遍历，题目的要求本质上是两个条件：<ul><li>如果右边的孩子比左边的孩子分数高，则糖果更多，递增序列。</li><li>如果左边的孩子比右边的孩子分数高，则糖果更多，递减序列。</li><li>分别使用条件处理后，将两侧的分数合并取最高值即可。</li></ul></li></ol><h1 id="三、数值贪心"><a href="#三、数值贪心" class="headerlink" title="三、数值贪心"></a>三、数值贪心</h1><p><a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></p><ol><li>对于相邻两个数字a1,a2，其对结果的长度影响相同，肯定优先保留数字小的。</li><li>对于数组a1,a2,a3：<ol><li>如果a1&lt;a2，则说明a2比a1更应该移除，但a2还需要与a3比较，即如果持续递增会将比较规则递推到最后。</li><li>如果a1&gt;a2，则说明a1比a2更应该移除，此时无论后续的序列如何，以a2开头必然比a1开头更小，所以可以直接移除a1。</li></ol></li><li>确定贪心思路：最后通过维护递增序列的方式实现贪心。</li></ol><p><a href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a><br>对于每一个数：</p><ul><li>如果其右边有比该数大的数，则可以与其交换得到更大的数。</li><li>如果其右边有若干个比该数大的数，则选择其中最大的数与其交换。</li><li>如果其右边有若干个相同的最大数，选择其中最右侧的数。</li></ul><p>对于整体序列：</p><ul><li>如果上面这种交换发生在越左侧的数上则越有利。</li></ul><p>为了维护上面这些规则：</p><ul><li>从右往左遍历，维护最大值，每次就可以判断当前值是否可以与后面的值交换。注意处理，遇到等于最大值的数，我们不更新max索引（取最右侧的最大值）。每次遇到可交换的，则将这次交换作为最终交换（越左侧数与后面的数交换得到的数越大）。</li></ul><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/">2457. 美丽整数的最小增量</a><br>注意处理技巧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">makeIntegerBeautiful</span><span class="hljs-params">(<span class="hljs-type">long</span> n, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">//当前数字</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-comment">//当前可能考虑的进位</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获取当前sum</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> getSum(cur);<br>            <span class="hljs-comment">//若不满足，获取下一个可行的数</span><br>            <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                cur = cur + unit-(cur%unit);<br>                unit *= <span class="hljs-number">10</span>;<br>                <span class="hljs-comment">//若满足，则直接返回</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> cur-n;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//计算各位的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            sum += n%<span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a><br>每个数都是一个32位长的比特串，两个数做异或时，越左边的位出现比特值不同则结果会更大。考虑使用前缀树用于比特位比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            root.add(num);<br>            ans = Math.max(ans,root.max(num));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span>&#123;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (num&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(root.next[temp] == <span class="hljs-literal">null</span>)&#123;<br>                root.next[temp] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            root = root.next[temp];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (num&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(root.next[<span class="hljs-number">1</span>-temp] != <span class="hljs-literal">null</span>)&#123;<br>                ans |= <span class="hljs-number">1</span>&lt;&lt;i;<br>                root = root.next[<span class="hljs-number">1</span>-temp];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.next[temp] != <span class="hljs-literal">null</span>)&#123;<br>                root = root.next[temp];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-product-after-k-increments/">2233. K 次增加后的最大乘积</a></p><ol><li>使用最小堆，每次增加最小的数</li><li>排序，顺序增加(也可批量增加)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-keyword">if</span>(index == n || nums[index] != last)&#123;<br>                index = <span class="hljs-number">0</span>;<br>                last = nums[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[index] == last)&#123;<br>                nums[index++]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            ans = (ans * nums[i])%MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/stone-game-vi/">1686. 石子游戏 VI</a><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/Pasted-image-20230302134806.png"><br>为石头处理价值，排序，两者依次选择价值最大的石头即可。<br>但要注意，最后能否获胜</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stoneGameVI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] aliceValues, <span class="hljs-type">int</span>[] bobValues)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> aliceValues.length;<br>        Integer[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            temp[i] = aliceValues[i]+bobValues[i];<br>        &#125;<br>        Arrays.sort(temp,(a,b) -&gt; b - a);<br>        <span class="hljs-comment">//alice与bob的价值差为alice[i]+bob[i]-sumbob;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                diff += temp[i];<br>            &#125;<br>        &#125;<br>        diff -= Arrays.stream(bobValues).sum();<br>        <span class="hljs-keyword">if</span>(diff &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(diff == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><p><a href="https://leetcode.cn/problems/construct-k-palindrome-strings/">1400. 构造 K 个回文字符串</a><br>每有一个奇数个数的字符，必然有一个对应的回文串，其决定了回文串数量的下线，而字符串总长决定了回文串数量的上线。<br>只需要保证<code>s.length()&lt;k</code>以及<code>奇数字符个数&lt;=k</code></p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></p><ol><li>按身高从小到大摆放：前排的矮子不会影响到高子前面的空位。比当前人矮的人都已经排好了，当前人也知道自己前面还有多少高个子没排好，因此当前人可以方便找到自己的最终位置。<ul><li>一个人的坐标x &#x3D; 其前面比它大的数a（已知） + 其前面比它小的数b，所以只需要从小到达摆放，就可以确定其前面比它小的数的数量b。</li><li>具体的：<ul><li>将人按身高大小从矮到高排列。</li><li>相同身高则按ki从大到小排列，ki小的最终在前面，从而影响b的判断，因此先摆放ki大的较好。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> people.length;<br>        Arrays.sort(people,(a,b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> b[<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] person:people)&#123;<br>            <span class="hljs-comment">//前面比当前人高的人,也就是前面需要留出的空位</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> person[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-comment">//这里主要要判断为空在执行操作，因为就算需要留出的空位数达到了，也要等到下一个空位插入该值</span><br>                <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-literal">null</span>)&#123;<br>                    space--;<br>                    <span class="hljs-keyword">if</span>(space == -<span class="hljs-number">1</span>)&#123;<br>                        ans[i] = person;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>按身高从大到小摆放：后排的矮子不会影响前排的高个子，比当前人高的（或相等）都已经排好了，直接插入到他们中间即可。<ul><li>将人的身高按从大到小，相同身高则先取会摆放在前排的。</li><li>使用list维护一个动态队列，从高到矮放入，每次放入时，根据其ki决定位置</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span>[] b)</span>&#123;<br>                <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>]-a[<span class="hljs-number">0</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;people.length;i++)&#123;<br>            array.add(people[i][<span class="hljs-number">1</span>],people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（链表）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、寻找链表中点"><a href="#一、寻找链表中点" class="headerlink" title="一、寻找链表中点"></a>一、寻找链表中点</h1><p>寻找链表中点，是很多链表题解题的关键，重点则在于终止条件和得到的中点位置以及断开连接等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getMid</span><span class="hljs-params">(ListNode head)</span>&#123;<br><span class="hljs-comment">//两个终止条件，避免fast指针出错。</span><br><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(node.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-comment">//可以想象长度为2的链表和长度和3的链表分别会得到什么结果。</span><br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>slow = slow.next;<br>fast = fast.next.next;<br>&#125;<br><span class="hljs-comment">//slow永远在是“中点/右偏中点”的位置。将slow与后面的节点切割，对于只要求分割链表的题目这样操作已经足够。</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> slow.next;<br>    slow.next = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若希望得到绝对中点，实现断开功能，可以采用哑节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//让slow和fast都慢一步，这样slow则是“中点/左偏中点”。需要在初始化时执行。</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>dummy.next = head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br><br><span class="hljs-comment">//可以只让slow慢一步，这样slow就是&#x27;中点/左偏中点的前一个节点&#x27;，便于断开连接</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>dummy.next = head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br></code></pre></td></tr></table></figure><p>若不需要调整链表的结构，只需要节点中顺序摆放的值，也可以不断开链表，只通过设置终止节点来分割，如<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>的特殊解法。</p><h1 id="二、链表反转-x2F-排序"><a href="#二、链表反转-x2F-排序" class="headerlink" title="二、链表反转&#x2F;排序"></a>二、链表反转&#x2F;排序</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></p><blockquote><p>归并排序对链表很有效，通过寻找中点分割左右两侧。</p></blockquote><p>可以联动该题的常规解法：<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>，自顶向下归并排序。也可以自底向上排序，逐渐扩大合并范围即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自顶向下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sort(head);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(node.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//左侧节点排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">leftsort</span> <span class="hljs-operator">=</span> sort(node);<br>        <span class="hljs-comment">//右侧节点排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightsort</span> <span class="hljs-operator">=</span> sort(temp);<br>        <span class="hljs-comment">//合并节点</span><br>        <span class="hljs-keyword">return</span> merge(leftsort,rightsort);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode node1,ListNode node2)</span>&#123;<br>    <span class="hljs-comment">//创建哑节点方便返回。</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> ans;<br>        <span class="hljs-comment">//这里的外循环是左右都有值</span><br>        <span class="hljs-keyword">while</span>(node1 != <span class="hljs-literal">null</span> &amp;&amp; node2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1.val&lt;node2.val)&#123;<br>                pre.next = node1;<br>                node1 = node1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre.next = node2;<br>                node2 = node2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">//然后接上还有值的节点即可</span><br>        pre.next = node1 == <span class="hljs-literal">null</span>?node2:node1;<br>        <span class="hljs-keyword">return</span> ans.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/">2046. 给按照绝对值排序的链表排序</a><br>多指针完成有序移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortLinkedList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, cur = head.next; <br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// cur为非负数时则两个指针向后移动；</span><br>            <span class="hljs-keyword">if</span> (cur.val &gt;= <span class="hljs-number">0</span>)&#123;<br>                pre = pre.next;<br>                cur = pre.next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.val &lt; <span class="hljs-number">0</span>)&#123;<br>                pre.next = cur.next;<br>                cur.next = head;<br>                head = cur;<br>                cur = pre.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p><ol><li>一次遍历，存数组双指针判断</li><li>递归判断</li><li>双指针</li></ol><blockquote><p>递归是反向遍历链表的好方式！可以通过递归先找到尾部节点，然后与外部的节点指针对比交互。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//函数外的节点，代表待比较的头节点</span><br>    ListNode l1;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        l1 = head;<br>        <span class="hljs-keyword">return</span> func(head);<br>    &#125;<br><span class="hljs-comment">//判断节点是否为回文链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">func</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">func</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//通过func递归，直接找到尾节点，然后与外部头节点逐一比较</span><br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>)&#123;<br>            func = func(node.next);<br>        &#125;<br>        <span class="hljs-comment">//如果最后一个节点与头节点相等，则返回true，并移动头节点，此时尾部节点的func出栈，对比新的头节点和倒数第二个尾节点。</span><br>        <span class="hljs-keyword">if</span> (l1.val == node.val &amp;&amp; func)&#123;<br>            l1 = l1.next;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、循环链表"><a href="#三、循环链表" class="headerlink" title="三、循环链表"></a>三、循环链表</h1><p><a href="https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/">708. 循环有序列表的插入</a><br>主要考察思维严谨性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> insertVal)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>        <span class="hljs-comment">//空节点检测</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            node.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-comment">//单节点检测</span><br>        <span class="hljs-keyword">if</span> (head.next == head) &#123;<br>            head.next = node;<br>            node.next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head, next = head.next;<br>        <span class="hljs-comment">//循环回初始点</span><br>        <span class="hljs-keyword">while</span> (next != head) &#123;<br>            <span class="hljs-comment">//如果大于当前点小于下一个点，可以插入</span><br>            <span class="hljs-keyword">if</span> (insertVal &gt;= curr.val &amp;&amp; insertVal &lt;= next.val) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//判断临近点是否变成降序，如果是，则说明遍历到了首节点</span><br>            <span class="hljs-keyword">if</span> (curr.val &gt; next.val) &#123;<br>                <span class="hljs-comment">//判断当前节点是否可能为首节点，若为，则可以插入</span><br>                <span class="hljs-keyword">if</span> (insertVal &gt; curr.val || insertVal &lt; next.val) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//否则，迭代</span><br>            curr = curr.next;<br>            next = next.next;<br>        &#125;<br>        curr.next = node;<br>        node.next = next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、链表消除"><a href="#四、链表消除" class="headerlink" title="四、链表消除"></a>四、链表消除</h1><p>一般是要在链表中找到一些节点、一些序列取出的问题。<br><a href="https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">1171. 从链表中删去总和值为零的连续节点</a><br>使用hash表+前缀和，实现相同前缀和覆盖，最后的序列肯定不会有相同的前缀和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeZeroSumSublists</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        Map&lt;Integer, ListNode&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dummy; node != <span class="hljs-literal">null</span>; node = node.next) &#123;<br>            prefix += node.val;<br>            seen.put(prefix, node);<br>        &#125;<br>        prefix = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dummy; node != <span class="hljs-literal">null</span>; node = node.next) &#123;<br>            prefix += node.val;<br>            node.next = seen.get(prefix).next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（DFS与BFS）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、DFS与BFS"><a href="#一、DFS与BFS" class="headerlink" title="一、DFS与BFS"></a>一、DFS与BFS</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a><br>简单的搜索，注意终止条件的写法，由于不需要记录路径，所以不需要使用回溯，成功时直接返回即可。</p><p><a href="https://leetcode.cn/problems/battleships-in-a-board/">419. 甲板上的战舰</a><br>DFS，也可以只找左上角块统计。</p><p><a href="https://leetcode.cn/problems/strobogrammatic-number-iii/">248. 中心对称数 III</a><br>思路：</p><ul><li>长度为0的对称数为{null};</li><li>长度为1的对称数为{0,1,8};</li><li>在s的基础上，左右扩充{0+s+0,1+s+1,6+s+9,8+s+8,9+s+6};</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strobogrammaticInRange</span><span class="hljs-params">(String low, String high)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=high.length();<br>        <span class="hljs-type">int</span> n=low.length();<br><span class="hljs-comment">//如果m == n，直接取所有该长度的对称数，然后判断范围。</span><br>        <span class="hljs-keyword">if</span>(m-n==<span class="hljs-number">0</span>)&#123;<br>           List&lt;String&gt; res=helper(n,n);<br>           <span class="hljs-keyword">for</span>(String s :res)&#123;<br>           <span class="hljs-keyword">if</span>(Long.parseLong(s)&gt;=Long.parseLong(low)&amp;&amp;Long.parseLong(s)&lt;=Long.parseLong(high)) sum++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-comment">//遍历长度为n-&gt;m的所有对称数，注意判断范围</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m; i&gt;=n; i--)&#123;<br>                List&lt;String&gt; res=helper(i,i);<br>                <span class="hljs-keyword">for</span>(String s :res)&#123;<br>                <span class="hljs-keyword">if</span>(Long.parseLong(s)&gt;=Long.parseLong(low)&amp;&amp;Long.parseLong(s)&lt;=Long.parseLong(high)) sum++;<br>               &#125;    <br>            &#125;<br>         <br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-comment">// helper(n,m)求长度为n的对称数</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span>&#123;<br>        <span class="hljs-comment">// 第一步：判断输入或者状态是否合法，可省略</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        if(n&lt;0 || m&lt;0 || n&gt;m)&#123;</span><br><span class="hljs-comment">            throw  new IllegalArgumentException(&quot;invalid input&quot;);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        **/</span><br>        <span class="hljs-comment">// 第二步：初始状态</span><br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>));<br>        <span class="hljs-comment">// 第三步：获取子问题答案</span><br>        List&lt;String&gt; list = helper(n-<span class="hljs-number">2</span>, m);<br>        <span class="hljs-comment">// 第四步：在子问题上，添加字符</span><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list)&#123;<br>            <span class="hljs-keyword">if</span> (n!=m) res.add(<span class="hljs-string">&quot;0&quot;</span>+s+<span class="hljs-string">&quot;0&quot;</span>);<br>                <span class="hljs-comment">// n=m时，表示最外层处理。</span><br>                <span class="hljs-comment">// 例如：原始需求n=m=2, &#x27;00&#x27;不合法</span><br>                <span class="hljs-comment">// 若原始需求n=m=4, 内层循环n=2,m=4,&#x27;00&#x27;;最外层循环，n=m=4时，&#x27;1001&#x27;  </span><br>            res.add(<span class="hljs-string">&quot;1&quot;</span>+s+<span class="hljs-string">&quot;1&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;6&quot;</span>+s+<span class="hljs-string">&quot;9&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;8&quot;</span>+s+<span class="hljs-string">&quot;8&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;9&quot;</span>+s+<span class="hljs-string">&quot;6&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-knight-moves/">1197. 进击的骑士</a><br>在一定范围外只允许逼近目标的尝试。</p><p><a href="https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a><br>将穿过障碍物次数视为状态的一个维度，通过BFS实现最短路径搜索。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 四个搜寻方向</span><br>    <span class="hljs-type">int</span>[][] directions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-keyword">if</span> ( k &gt;= m + n - <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> m + n - <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span>[][][] flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n][k + <span class="hljs-number">1</span>]; <span class="hljs-comment">// flag[m][n][k] 表示到达位置 m,n ，且还剩余k个消除障碍物的机会</span><br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,k&#125;);<br>        flag[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][k] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ( ! q.isEmpty() )&#123;<br>            step ++;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-keyword">while</span> ( size -- &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span>[] currentState = q.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curm</span> <span class="hljs-operator">=</span> currentState[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curn</span> <span class="hljs-operator">=</span> currentState[<span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">curk</span> <span class="hljs-operator">=</span> currentState[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] direction : directions)&#123; <span class="hljs-comment">// 下一个搜索位置</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nextm</span> <span class="hljs-operator">=</span> curm + direction[<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> curn + direction[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 搜索位置 未越界</span><br>                    <span class="hljs-keyword">if</span> ( ( nextm &gt;= <span class="hljs-number">0</span> &amp;&amp; nextm &lt; m  ) &amp;&amp; ( nextn &gt;=<span class="hljs-number">0</span> &amp;&amp; nextn &lt; n) )&#123;<br>                        <span class="hljs-comment">// 下一个位置nextm,nextn, 不是障碍物  ,且状态 [nextm][nextn][curk] 没被经历过</span><br>                        <span class="hljs-keyword">if</span> ( grid[nextm][nextn] == <span class="hljs-number">0</span> &amp;&amp; !flag[nextm][nextn][curk] )&#123;<br>                            <span class="hljs-comment">// 找到结果</span><br>                            <span class="hljs-keyword">if</span> ( nextm == m - <span class="hljs-number">1</span> &amp;&amp; nextn == n - <span class="hljs-number">1</span> )&#123;<br>                                <span class="hljs-keyword">return</span> step;<br>                            &#125;<br>                            <span class="hljs-comment">// 没找到结果 ，记录当前状态，继续寻找</span><br>                            <span class="hljs-keyword">else</span>&#123;<br>                                flag[nextm][nextn][curk] = <span class="hljs-literal">true</span>;<br>                                q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextm,nextn,curk&#125;);<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 下一个位置 为障碍物，且当前还有移除障碍物的机会</span><br>                        <span class="hljs-comment">// 且 状态[nextm][nextn][curk - 1]没被经历过</span><br>                        <span class="hljs-comment">// 实际还可以剪枝，即如果存在比curk-1大的flag为true，则略过</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( grid[nextm][nextn] == <span class="hljs-number">1</span> &amp;&amp; curk &gt; <span class="hljs-number">0</span> &amp;&amp; !flag[nextm][nextn][curk-<span class="hljs-number">1</span>])&#123;<br>                            flag[nextm][nextn][curk-<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                            q.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextm,nextn,curk - <span class="hljs-number">1</span>&#125;);<br>                        &#125;<br><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>用于寻找两数的公约数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> x % y;<br><span class="hljs-keyword">while</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>  x = y;<br>  y = remainder;<br>  remainder = x % y;<br>&#125;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过取余操作求公约数。</p><p><em>证明</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs math">令 a = kb + r，即r = a - kb<br>左右同时除a，b的最大公约数d：<br>r/d = a/d - kb/d<br>可知r/d为整数，即d也是r的约数。<br>问题由求a,b的最大公约数变成求b,r的最大公约数。<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/water-and-jug-problem/">365. 水壶问题</a><br><em>1. DFS&#x2F;BFS</em><br>分析情形，每次的操作共6种：装满x水壶、倒空x水壶、x水壶倒入y水壶、装满y水壶、倒空y水壶、y水壶倒入x水壶；递归寻找结果。<br>DFS中减枝：</p><ul><li>不装已经慢了的水壶</li><li>不倒已经空了的水壶</li><li>不到达已经到达了的状态（将两水壶的水量处理成int使用set保存）</li></ul><p><em>2. 贝祖定理</em><br>每次操作只会让水量增加x，增加y，减少x，或减少y，如果装一个不满水桶或倒一个不满水桶呢？</p><ul><li>两个桶不可能同时有水且不满（每个操作后必然有水桶满或空），因此只有以下几种状态：<ol><li>2个空水桶</li><li>2个满水桶</li><li>1个满水桶，1个空水桶</li><li>1个不满水桶，1个空水桶</li><li>1个不满水桶，1个满水桶</li></ol></li><li>对于1、2、3状态，不需要考虑，对于4，5状态，没有必要对一个不满进行装满或倒空，其结果等效于1、2、3状态。</li><li>因此每次有效操作，只会让水量增加x，增加y，减少x，或减少y。</li></ul><p>即问题转化是否有a,b满足：ax+by&#x3D;z<br>根据贝祖定理，只有z是x，y的最大公约数的倍数时，该式子才成立。所以问题转化为求x,y最小公约数，可以使用辗转相除法解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canMeasureWater</span><span class="hljs-params">(<span class="hljs-type">int</span> jug1Capacity, <span class="hljs-type">int</span> jug2Capacity, <span class="hljs-type">int</span> targetCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span>(targetCapacity&gt;jug1Capacity+jug2Capacity) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> gcd(jug1Capacity,jug2Capacity);<br>        <span class="hljs-keyword">return</span> targetCapacity%temp == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> x%y;<br>        <span class="hljs-keyword">while</span>(r != <span class="hljs-number">0</span>)&#123;<br>            x = y;<br>            y = r;<br>            r = x%y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>将树视为一个无向图，则任意两节点之间，都存在距离（两节点直连则距离为1），两节点节点之间的最长距离，就是这棵树的直径。<br>求树直径的方法主要为：2次DFS&#x2F;BFS（1次找直径的一个端点，1次找另一个端点）。<br>证明：<a href="https://blog.csdn.net/AC__dream/article/details/119101320">CSDN</a></p><p><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树</a><br>BFS&#x2F;DFS求直径端点，同时记录路径，便于找直径的中点（1个节点或2个节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">//根据边的信息，创建图结构</span><br>        List&lt;List&lt;Integer&gt;&gt; edgeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            edgeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge:edges)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">1</span>];<br>            edgeList.get(x).add(y);<br>            edgeList.get(y).add(x);<br>        &#125;<br>        <span class="hljs-comment">//parent数组记录了遍历时节点之间路径</span><br>        <span class="hljs-type">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">//直径的第一个端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> mostDeepNode(edgeList,<span class="hljs-number">0</span>,n,parent);<br>        <span class="hljs-comment">//复位parent</span><br>        Arrays.fill(parent,-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//直径的第二个端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> mostDeepNode(edgeList,x,n,parent);<br>        <span class="hljs-comment">//将直径的路径从parent中取出</span><br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(y != -<span class="hljs-number">1</span>)&#123;<br>            path.add(y);<br>            y = parent[y];<br>        &#125;<br>        <span class="hljs-comment">//取路径中点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> path.size();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans.add(path.get(length/<span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">if</span>(length%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            ans.add(path.get((length-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//bfs求直径端点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mostDeepNode</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>[] parent)</span>&#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.add(root);<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        visited[root] =<span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            temp = deque.poll();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:list.get(temp))&#123;<br>                <span class="hljs-keyword">if</span>(!visited[next])&#123;<br>                    visited[next] = <span class="hljs-literal">true</span>;<br>                    parent[next] = temp;<br>                    deque.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a><br>先建立数字与字母<code>Map&lt;Integer,List&lt;Character&gt;&gt;</code>，使用一个<code>StringBuilder</code>，每层做循环，添加和删除末尾，当长度达到要求时返回一个记录并保存。<br><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a><br>记录左右括号的数量作为参数传递，左括号数量-右括号数量&gt;&#x3D;0时才能加右括号。<br><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p><blockquote><p>注意复制list的方法：构造函数<code>new ArrayList&lt;T&gt;(Collection&lt;T&gt;)</code></p></blockquote><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a><br><a href="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索 II</a><br>要一次实现对每个单词的匹配，就不要有方向的寻找路径，而是枚举路径，只要判断出有一个单词之后就不会再核对这个路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯，不要对每个单词单独遍历，太慢超时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[][] board;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] _board, String[] words)</span> &#123;<br>        board = _board;<br>        m = board.length; n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (String w : words) set.add(w);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;<br>                sb.append(board[i][j]);<br>                dfs(i, j, sb);<br>                vis[i][j] = <span class="hljs-literal">false</span>;<br>                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, StringBuilder sb)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (set.contains(sb.toString())) &#123;<br>            ans.add(sb.toString());<br>            set.remove(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> i + d[<span class="hljs-number">0</span>], dy = j + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span> || dx &gt;= m || dy &lt; <span class="hljs-number">0</span> || dy &gt;= n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[dx][dy]) <span class="hljs-keyword">continue</span>;<br>            vis[dx][dy] = <span class="hljs-literal">true</span>;<br>            sb.append(board[dx][dy]);<br>            dfs(dx, dy, sb);<br>            vis[dx][dy] = <span class="hljs-literal">false</span>;<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></p><ul><li>使用列数组，主对角线数组，副对角线数组保存每一列，对角线已经被使用的情况。</li><li>逐行遍历，每行逐一尝试当前可以填入的位置，并对该位置作出限制，递归，实现摆放后，返回一个结果。</li><li>过程中只需要记录各行中摆放的位置<code>List</code>，最后根据这个生成棋盘<code>char[][]</code></li></ul><p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></p><ul><li>通过行数组，列数组，块数组，各使用一个int采用状态压缩的方式对后续填写作出限制。</li><li>将所有空棋放入一个list中，逐个选择，对选择出的棋子位置，遍历所有可能的选择，遇到成功即可返回true。（本质上是暴力尝试，遇到死局会返回）</li></ul><p><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></p><ul><li>遇到数字则直接填入</li><li>遇到字母则先填入，然后回溯尝试字母的大（小）写</li></ul><blockquote><p>Character.isDigit(char c); 判断字符是数字；<br>Character.isLetter(char c); 判断字符是字母；</p><ul><li>小写字母(a-&gt;z)的ASCII，97-&gt;122;</li><li>大写字母(A-&gt;Z)的ASCII，65-&gt;90;</li><li>可见之间隔了32，因此若要进行大小写转换，可以以90为界限，加减32即可。</li><li>若要保存数字+字母，使用<code>int[128]</code>即可</li><li>若只保存字母，使用<code>int[58]</code>即可，索引为<code>c-&#39;A&#39;</code>。</li></ul></blockquote><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a><br>注意题目，同一个元素不能以相同的身份出现在一个组合中。<br>采取先排序，然后剪枝的方法，避免全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//全局记录答案</span><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><span class="hljs-comment">//记录元素是否使用，用于回溯</span><br><span class="hljs-type">boolean</span>[] used;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-comment">//先排序</span><br>Arrays.sort(candidates);<br>used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>dfs(<span class="hljs-number">0</span>,candidates,target,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//当前索引，距离target还差多少</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,List&lt;Integer&gt; list)</span>&#123;<br><span class="hljs-comment">//找到一个结果</span><br><span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果已经超过阈值/索引到达末尾/当前待选 == 上一个待选，且上一个没选，剪枝。</span><br><span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span> || index&gt;=candidates.length || index&gt;<span class="hljs-number">0</span>&amp;&amp;candidates[index]==candidates[index-<span class="hljs-number">1</span>]&amp;&amp;used[index-<span class="hljs-number">1</span>] ==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> candidates[index];<br>list.add(temp);<br>used[index] = <span class="hljs-literal">true</span>;<br>dfs(index+<span class="hljs-number">1</span>,candidates,target-temp,list);<br>list.remove(list.size()-<span class="hljs-number">1</span>);<br>used[index] = <span class="hljs-literal">false</span>;<br>dfs(index+<span class="hljs-number">1</span>,candidates,target,list);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>将本题与火柴题对比：<br>相同点在于，根据题目的要求，判断能否走下去只取决于状态，不取决于选择顺序（实际上，顺序在dp和dfs中就做过枚举处理），只要有一种顺序方案成功，这个状态就是成功的。因此这两题如果要使用dp方法做，都不需要保存某物品作为最后一个选择时的情形，即维度只有状态。</p><p>比较dp和dfs的区别：</p><ul><li>dp时（转移方程是反向思维），对于某个状态s，<strong>枚举</strong>上一个状态s1，即可得知该状态是否可达。最后列举到最后状态<code>dp[(1&lt;&lt;n)-1]</code>即可得知结果。</li><li>dfs+回溯时（转移方程是正向思维），通过初始状态，<strong>枚举</strong>可选择的火柴，寻找后续状态的可行性。</li><li>因为枚举的方向不同，所以dfs判断无法到达结果后，可以直接剪枝，dp则会遍历所有的情况。</li><li>本题显然需要剪枝，使用dfs较好，且在结果中要返回该方案本身，回溯更好处理。</li></ul>          </div><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a><br>排序去重，注意剪枝的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        n = nums.length;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//索引，上一个索引是否使用，当前状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span> lastUsed,List&lt;Integer&gt; cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里注意，要先允许跳过该位置</span><br>        dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>,cur);<br>        <span class="hljs-comment">//然后再判断该位置能否选择，从而剪枝</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] &amp;&amp; !lastUsed) <span class="hljs-keyword">return</span>;<br>        cur.add(nums[i]);<br>        dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>,cur);<br>        cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/letter-tile-possibilities/">1079. 活字印刷</a><br>与子集2对比：</p><ul><li>对于子集而言，元素的顺序是无关紧要的，只要数量上不重复就是唯一子集，而本处的序列需要考虑元素的选择顺序</li></ul><p>先不考虑重复的情况下：</p><ul><li>对于子集的枚举，只需要逐一判断每个元素是否选择，并记录状态即可。是一个单根节点的问题。</li><li>对于子序列的枚举，还要针对下一个元素选择哪一个&#x2F;或不选进行遍历，如下图所示。</li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190007.png"><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190717.png"></p><ol><li>dfs，排序剪枝头，通过排序+顺序遍历保证了每次使用一个字母时，使用的是最左侧的该字母。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilePossibilities</span><span class="hljs-params">(String tiles)</span> &#123;<br>        <span class="hljs-comment">//题目中字母序列不同与子序列，是无序的。</span><br>        <span class="hljs-comment">//为了去重，排序</span><br>        n = tiles.length();<br>        s = tiles.toCharArray();<br>        Arrays.sort(s);<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[j] || (j&gt;<span class="hljs-number">0</span> &amp;&amp; s[j] == s[j-<span class="hljs-number">1</span>] &amp;&amp; !visited[j-<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;<br>            visited[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//每次添加字符后，必然得到一个未见过的序列。</span><br>            res++;<br>            dfs(i+<span class="hljs-number">1</span>);<br>            visited[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>统计各字母个数，每次从26个字母中选择，而不是从剩余元素（可能有重复字母）中选择。</li></ol><p><a href="https://leetcode.cn/problems/number-of-distinct-islands/">694. 不同岛屿的数量</a><br>利用回溯序列固定形状。</p><h1 id="三、图"><a href="#三、图" class="headerlink" title="三、图"></a>三、图</h1><p>图的题目主要为各个节点之间相互连接的问题，常常需要结合dfs，bfs，探索相邻点得到答案。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>拓扑排序中没有环，是一个无环图。</li></ul><h3 id="常见的处理方式"><a href="#常见的处理方式" class="headerlink" title="常见的处理方式"></a>常见的处理方式</h3><h4 id="正向思维-x2F-BFS"><a href="#正向思维-x2F-BFS" class="headerlink" title="正向思维&#x2F;BFS"></a>正向思维&#x2F;BFS</h4><p>节点之间有前后依赖关系，可以先统计每个节点的入度：</p><ul><li>将入度为0的节点放入队列中</li><li>逐一取出队列中节点，取出节点A时消去所有依赖节点A的节点B们的一个入度，如果某节点入度为0，表示其已经可以被消去，入队。</li><li>循环出队的过程</li></ul><h4 id="逆向思维-x2F-DFS"><a href="#逆向思维-x2F-DFS" class="headerlink" title="逆向思维&#x2F;DFS"></a>逆向思维&#x2F;DFS</h4><p>每个节点有三种状态：未搜索，搜索中，搜索完毕。类似JVM回收三色标记，本质上是先将出度为0的节点标记完成：</p><ul><li>对任意一个节点开始进行搜索直接&#x2F;间接依赖该节点的若干节点，并将该节点标记为<strong>搜索中</strong>：</li><li>搜索该节点的临近节点DFS，当某节点和直接&#x2F;间接依赖该节点的若干节点都<strong>搜索完毕</strong>后，该节点才能标至为<strong>搜索完毕</strong>。</li><li>利用拓扑排序中没有环的性质，从任意一点开始搜索，都不会搜索回自己，即在dfs时不可能遇到一个<strong>搜索中</strong>的节点，可以据此判断拓扑排序是否成立。</li></ul><p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a><br>正向&#x2F;逆向思维均可。</p><p><a href="https://leetcode.cn/problems/course-schedule/">210. 课程表 Ⅱ</a><br>为了获取课程学习顺序，使用正向思维。</p><p><a href="https://leetcode.cn/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a><br>出度和入度倒置就可以了。</p><p><a href="https://leetcode.cn/problems/alien-dictionary/">269. 火星词典</a><br>本题的难点：</p><ul><li>如何记录优先级：可以拓扑排序！</li><li>由于题目不允许任何非法排序：<ul><li>不可以有前缀相同但更长的单词（字典规则）</li><li>对于游离的节点，本题允许对其排序，所以直接将其作为入度为0的节点处理即可，如果不允许，还需要额外处理。<ul><li>如果不允许出现游离节点，可以在统计后判断哪些节点，既没有出度也没有入度。</li></ul></li><li>不能有环（非法顺序）。<ul><li>对于环问题，会使拓扑排序提前结束（环上的节点入度永远不可能为0），可以比较<strong>总节点数</strong>和在<strong>排序链上的节点数</strong>。</li></ul></li></ul></li><li>本题有 出度详细统计 和 入度数量统计 作为全局变量，可以灵活判断是否初始化这两个变量来顺便实现统计：<ul><li>如本题利用出度详细统计，统计了全部节点数量。</li><li>如果遇到要处理游离节点的问题：<ul><li>如果想要找到游离节点：可以在完成图建立后，统计入度为0中出度为空的节点。</li><li>如果只想忽视游离节点：可以只对有入度和出度的节点做并集统计，游离节点则不在这两者中，具体而言，选择根节点时，在所有有出度的节点中寻找入度为0或不存在的即可。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//记录出边</span><br>    Map&lt;Character,List&lt;Character&gt;&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//记录入度</span><br>    Map&lt;Character,Integer&gt; in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//是否合法</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-comment">//初始化出边，入度不能初始化（有的字母无法判断任何顺序关系，不能认为其在最前面）</span><br>        <span class="hljs-keyword">for</span>(String word:words)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.length();i++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                edges.putIfAbsent(c,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Character&gt;());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//比较字符串，添加字符顺序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n &amp;&amp; valid;i++)&#123;<br>            compare(words[i-<span class="hljs-number">1</span>],words[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!valid)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//字符队列</span><br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//所有有出边的字符</span><br>        Set&lt;Character&gt; letterSet = edges.keySet();<br>        <span class="hljs-comment">//遍历这些有出边的字符，如果其没有入度，则可以作为根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> u : letterSet) &#123;<br>            <span class="hljs-keyword">if</span> (!in.containsKey(u)) &#123;<br>                deque.offer(u);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            sb.append(c);<br>            List&lt;Character&gt; neigh = edges.get(c);<br>            <span class="hljs-keyword">for</span>(Character c2:neigh)&#123;<br>                in.put(c2,in.get(c2)-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(in.get(c2) == <span class="hljs-number">0</span>)&#123;<br>                    deque.offerLast(c2);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.length() == edges.size() ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>        <br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1,String s2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(s1.length(),s2.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s1.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s2.charAt(i);<br>            <span class="hljs-keyword">if</span>(s1.charAt(i) != s2.charAt(i))&#123;<br>                edges.get(c1).add(c2);<br>                in.put(c2,in.getOrDefault(c2,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == len &amp;&amp; s1.length()&gt;s2.length())&#123;<br>            valid = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/fpTFWP/">LCR 112. 矩阵中的最长递增路径</a></p><h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>参考题目<a href="https://leetcode.cn/problems/cracking-the-safe/">753. 破解保险箱</a><br><em>分析：</em><br>最优解肯定是对于一个初始密码000，每次只在后面添加一个数字就可以得到一个新密码，如<code>0[001]</code>，可见影响下一个密码选项的是当前密码除第一位的数。我们视这样的数为一个节点。我们可以从00节点开始，它可以选择0，1两个后续数，整个密码像一个滑动窗口模型。</p><p><em>欧拉回路：</em><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233121.png"></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li>每个节点都有若干的出度（下一步选项），因此也有若干的入度（对称性）。</li></ul><p><em>推论：</em><br>从某个节点开始遍历，一定可以恰好回到该节点。（因为第一个出度给出去了，最后一个入度会回到这个点。对于本题，我们只需要保证，通过一次遍历能够遍历到所有节点即可。）</p><h3 id="常见处理方式"><a href="#常见处理方式" class="headerlink" title="常见处理方式"></a>常见处理方式</h3><h4 id="Hierholzer-算法（倒序）"><a href="#Hierholzer-算法（倒序）" class="headerlink" title="Hierholzer 算法（倒序）"></a>Hierholzer 算法（倒序）</h4><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233756.png"><br><em>代码实现：</em><br>节点可能会重复，但路径（也就是密码，比节点多一位）永远不会重复，通过记录密码就可以防止走重复的路径，从000开始搜索密码。</p><ul><li>有一个很重要的技巧，就是dfs之后再添加该节点：<ul><li>在某个节点状态Node下，可能有多个下次可成功密码。</li><li>在尝试下一个密码A成功时，并不能保证这个路径可以遍历所有路径，如果沿着这条路走到原点，并顺序添加路径到sb上，则sb的末尾不再是该节点Node，因此无法尝试另一个密码B。</li><li>我们可以倒序添加路径到sb上，先把v-&gt;u的路径以u-&gt;v的方式保存在sb上，此时v即可继续尝试下一个密码。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-type">int</span> highest;<br>    <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//最高位的单位，若n=3，highest=100</span><br>        highest = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-comment">//从00开始搜索</span><br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//ans，填充若干个0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>    <span class="hljs-comment">//下一个可选择的字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; k; ++x) &#123;<br>        <span class="hljs-comment">//下一个尝试密码</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nei</span> <span class="hljs-operator">=</span> node * <span class="hljs-number">10</span> + x;<br>            <span class="hljs-comment">//如果这个密码没有被尝试过</span><br>            <span class="hljs-keyword">if</span> (!seen.contains(nei)) &#123;<br>            <span class="hljs-comment">//则将该节点添加到已见过的密码</span><br>                seen.add(nei);<br>                <span class="hljs-comment">//搜索该节点</span><br>                dfs(nei % highest);<br>                <span class="hljs-comment">//最后将该字符添加到sb末尾，所以sb是倒序的，最后结尾时加00。</span><br>                ans.append(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012352.png"><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012728.png"></p><h4 id="贪心（顺序）"><a href="#贪心（顺序）" class="headerlink" title="贪心（顺序）"></a>贪心（顺序）</h4><p>我们选择”00”作为起始点。但是每次要选择添加的数字时，从大数字开始（即从 k-1遍历到 00）。这样可以尽可能晚地回到起始点。</p><ul><li>很显然，一直添加最小值0，会快速回到起始点。</li><li>事实上，Hierholzer算法中，下一个可选择字符是从小到达遍历的，所以从程序顺序角度看肯定会尽可能早的遍历回起点，因此要做倒序，先把最后这一段添加到sb中，再看其他未走过的路径。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span>&#123;<br>     <span class="hljs-comment">//map记录一个节点当前剩余的最大出边，最大为K-1。</span><br>     Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-comment">//所有节点的所有路径之和</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">kn</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(k,n);<span class="hljs-comment">//路径总数量</span><br>     <span class="hljs-comment">//一个节点有n-1个数字</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">kn_1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(k,n-<span class="hljs-number">1</span>);<span class="hljs-comment">//结点总数量</span><br>     <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>     <span class="hljs-comment">//初始结点为000...</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>         ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>     &#125;<br>     <span class="hljs-comment">//如果密码长度为1，没有出入度，单纯枚举</span><br>     <span class="hljs-keyword">if</span>(ans.length() == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; k; i++)&#123;<br>             ans.append(i);<br>         &#125;<br>         <span class="hljs-keyword">return</span> ans.toString();<br>     &#125;<br>     <span class="hljs-comment">//遍历所有的路</span><br>     <span class="hljs-keyword">while</span> (kn != <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-comment">//获取当前节点</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> ans.substring(ans.length() - n + <span class="hljs-number">1</span>, ans.length());<br>         <span class="hljs-comment">//初始化节点</span><br>         <span class="hljs-keyword">if</span>(!map.containsKey(substring)) map.put(substring,k-<span class="hljs-number">1</span>);<br>         <span class="hljs-comment">//将当前节点的最大边添加到结果中</span><br>         ans.append(map.get(substring));<br>         <span class="hljs-comment">//删除当前节点的最大边</span><br>         map.put(substring,map.get(substring) - <span class="hljs-number">1</span>);<br>         kn--;<br>     &#125;<br>     <span class="hljs-keyword">return</span> ans.toString();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012433.png"></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-type">int</span>[] parent;<br><span class="hljs-type">int</span>[] size;<br><span class="hljs-type">int</span> setCount;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-built_in">this</span>.n = n;<br><span class="hljs-built_in">this</span>.setCount = n;<br><span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-built_in">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>Arrays.fill(size,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>parent[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">return</span> parent[x] == x?x:(parent[x] = root(parent[x]));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>x = root(x);<br>y = root(y);<br><span class="hljs-keyword">if</span>(x == y)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>x = x^y;<br>y = x^y;<br>x = x^y;<br>&#125;<br>parent[y] = x;<br>size[x] += size[y];<br>setCount--;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">return</span> root(x) == root(y);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></p><ol><li>染色，将两个连接的元素标上不同的颜色，如果遇到颜色冲突，则说明无法形成二分图。</li><li>并查集，通过</li></ol><p><a href="https://leetcode.cn/problems/path-with-maximum-minimum-value/">1102. 得分最高的路径</a></p><ol><li>遍历：使用<code>boolean[][]</code>记录已经访问过的路径+dfs回溯，携带路径上的最小值，到达终点时更新答案。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] DIRECTIONS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumMinimumPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//右侧为首尾中最小值，表示想要走通能够遇到的最小值，最大也只能为right。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(grid,m,n,mid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(pass == <span class="hljs-literal">true</span>)&#123;<br>                left = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=n||visited[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(grid[x][y]&lt;mid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(x == m-<span class="hljs-number">1</span> &amp;&amp; y == n-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] direction:DIRECTIONS)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> x + direction[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> y + direction[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dfs(grid,m,n,mid,x1,y1))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>二分：通过限制最小分数min，并判断只能走比min分数大的方块时到达终点的可行性。</li><li>并查集：为每个边赋予分数（两个节点中较大的），然后按照分数从大到小激活点（与已经激活的点相连接），直到首节点和尾节点相连。</li></ol><p><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a><br>并查集逐渐添加边解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> heights.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights[<span class="hljs-number">0</span>].length;<br>List&lt;<span class="hljs-type">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i * n + j;<br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j])&#125;);<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - <span class="hljs-number">1</span>, id, Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>])&#125;);<br>&#125;<br>&#125;<br>&#125;<br>edges.sort((a,b) -&gt; a[<span class="hljs-number">2</span>]-b[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">Collections.sort(edges, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="hljs-comment">public int compare(int[] edge1, int[] edge2) &#123;</span><br><span class="hljs-comment">return edge1[2] - edge2[2];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;);</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(m * n);<br><span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], v = edge[<span class="hljs-number">2</span>];<br>uf.unite(x, y);<br><span class="hljs-keyword">if</span> (uf.connected(<span class="hljs-number">0</span>, m * n - <span class="hljs-number">1</span>)) &#123;<br>ans = v;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-islands-ii/">305. 岛屿数量 II</a></p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul><li>场景：Dijkstra算法主要用于解决带权重的有向图，权重只能为正值，是经典的求<strong>单源最短路径</strong>的一种方法。</li><li>思路：Dijkstra算法采用的是一种贪心的策略：<ul><li>创建数组记录每个点到源点的距离</li><li>创建一个优先队列，放入源点的邻点，按照与源点的距离从小到大排列</li><li>每次取出距离源点最近的点，该点到源点的距离即为最终距离，此时还需要标记该点为已完成，如果优先队列中后续遇到该点则忽略（肯定是距离更远的路径）</li><li>计算该点的邻点在以该点为桥梁时距离源点的距离，将这些点加入优先队列。（点可能在此阶段被重复加入优先队列）</li><li>一直执行直到优先队列为空</li></ul></li><li>复杂度：时间根据遍历最近点的方案（使用遍历时最大为n^2，使用二叉堆时最小为nlogn）；空间（n）；</li></ul><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><ul><li>场景：Floyd算法可以解决带负权重边（不能解决负权回路）的问题，是经典的求<strong>多源最短路径</strong>的一种方法。</li><li>思路：<ul><li>有以下两个对称矩阵：<ul><li>两点之间最短距离矩阵D</li><li>两点之间最短距离所经过的中介点矩阵P</li></ul></li><li>通过遍历各个点为中介点，看是否能其他点之间缩短距离，缩短后更新D、P。</li></ul></li><li>复杂度：时间（n^3），空间（n^2）；</li></ul><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>对于无向有权图，寻找一个所有点连通而路径权重最小的图。</p><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><ul><li>思路：从任一节点开始搜索，每次选择距离当前集合最近的点加入集合，已经搜过的不重复搜，直到所有节点都完成搜索。</li><li>复杂度：O(n^2)</li></ul><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><ul><li>思路：将所有边按照权重从小到大排列，每次取最小权重且两顶点当前不在一个集合的边，直到所有节点连接。</li><li>复杂度：O(n+mlogm)，排序(mlogm)加出栈(n)。</li></ul><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></p><ol><li>dfs配合visited数组秒杀。</li><li>并查集也可以</li></ol><p><a href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a><br>贪心做法容易预先填入，后面因为冲突而无法处理的情况。<br>这里可以先把所有边统计起来，每个花园只影响比其编号大的花园的选择限制（通过位运算标记），这样后面的选择肯定不会干涉已经选择了的花园。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] gardenNoAdj(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] paths) &#123;<br>        <span class="hljs-type">int</span>[] canPicks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        HashMap&lt;Integer,Set&lt;Integer&gt;&gt; connected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] path:paths)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> end;<br>                end = start;<br>                start = temp;<br>            &#125;<br>            connected.putIfAbsent(start,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>            connected.get(start).add(end);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">canPick</span> <span class="hljs-operator">=</span> canPicks[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(((canPick&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                    ans[i-<span class="hljs-number">1</span>] = j+<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(connected.get(i) != <span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:connected.get(i))&#123;<br>                            canPicks[next] |= <span class="hljs-number">1</span>&lt;&lt;j;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/">1059. 从始点到终点的所有路径</a><br>注意代码严谨性！</p><p><a href="https://leetcode.cn/problems/the-maze-ii/">505. 迷宫 II</a><br>使用Dijkstra迭代长度，确定单源最远距离</p><p><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// floyd</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[] ans = &#123;Integer.MAX_VALUE / <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span>[][] mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(mp[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] eg : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> eg[<span class="hljs-number">0</span>], to = eg[<span class="hljs-number">1</span>], weight = eg[<span class="hljs-number">2</span>];<br>            mp[from][to] = mp[to][from] = weight;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            mp[k][k] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                    mp[i][j] = Math.min(mp[i][j], mp[i][k] + mp[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (mp[i][j] &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= ans[<span class="hljs-number">0</span>]) &#123;<br>                ans[<span class="hljs-number">0</span>] = cnt;<br>                ans[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// dijkstra</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheCity</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges, <span class="hljs-type">int</span> distanceThreshold)</span> &#123;<br>        <span class="hljs-type">int</span>[] ans = &#123;Integer.MAX_VALUE / <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span>[][] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-type">int</span>[][] mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(dis[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>            Arrays.fill(mp[i], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] eg : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> eg[<span class="hljs-number">0</span>], to = eg[<span class="hljs-number">1</span>], weight = eg[<span class="hljs-number">2</span>];<br>            mp[from][to] = mp[to][from] = weight;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dis[i][i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 循环n次，寻找最近的点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 寻找距离i最近的节点t</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (!vis[i][k] &amp;&amp; (t == -<span class="hljs-number">1</span> || dis[i][k] &lt; dis[i][t])) &#123;<br>                        t = k;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 使用该节点更新所有与t临近的点k与i的距离</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>                    dis[i][k] = Math.min(dis[i][k], dis[i][t] + mp[t][k]);<br>                &#125;<br>                <span class="hljs-comment">// 将t标记为搜索完成</span><br>                vis[i][t] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (dis[i][j] &lt;= distanceThreshold) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= ans[<span class="hljs-number">0</span>]) &#123;<br>                ans[<span class="hljs-number">0</span>] = cnt;<br>                ans[<span class="hljs-number">1</span>] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、前缀树"><a href="#四、前缀树" class="headerlink" title="四、前缀树"></a>四、前缀树</h1><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-comment">//可以使用数组</span><br>    <span class="hljs-keyword">public</span> Trie[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br><span class="hljs-comment">//也可以使用hash</span><br><span class="hljs-comment">//public Map&lt;?,Trie&gt; children = new HashMap&lt;&gt;();</span><br><br><span class="hljs-comment">//可以记录本节点是一个单词结束点，也可以记录本节点所对应的单词等</span><br>    <span class="hljs-comment">//boolean isEnd = null;</span><br>    <span class="hljs-comment">//public String word = null;</span><br><br><span class="hljs-comment">//获取指定字符的节点</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br><span class="hljs-comment">//插入单词</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>)<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            node = node.children[<span class="hljs-type">char</span>];<br>        &#125;<br>        <span class="hljs-comment">//node.isEnd = true;</span><br>        <span class="hljs-comment">//node.word = word;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/word-squares/">425. 单词方块</a></p><ul><li>先根据题目集合建立字典树（每个节点都记录当前字符串）</li><li>单词方块中的单词数量 &#x3D; 题目中单词的长度</li><li>建立方块数组，枚举第一个单词<ul><li>在前面单词的限制下得到后续单词的前缀，利用前缀树快速判断是否存在该前缀，若不存在直接返回，若存在则继续枚举。</li><li>直到填满方块，返回。</li></ul></li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228202925.jpg"></p><p><a href="https://leetcode.cn/problems/palindrome-pairs/">336. 回文对</a><br>分析：<br>对于两个单词(word1+word2)组成回文对，有三种情况：</p><ul><li>情形1：word1.length&gt;word2.length，此时应该满足，word1的前段与word2成回文，word1剩余长度自成回文。</li><li>情形2：word1.length&lt;word2.length，此时应该满足，word2的后段与word1成回文，word2前面部分自成回文。</li><li>情形3：word1.length &#x3D;&#x3D; word2.length，此时可以考虑为前面情况的特殊情况。</li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228211251.png"><br>思路：</p><ul><li>为了比较回文，先为所有单词<strong>逆序</strong>构建字典树。同时记录每个单词的末尾是否为回文。</li><li>顺序遍历单词，在字典树中寻找<ul><li>为了处理情况1，word1的字符每走一步，判断一次word1后半段是否为回文，若是，则看这时有哪些word2（节点的words列表）。</li><li>为了处理情况2，word1的字符遍历结束时，看该节点是否有后缀的回文串。</li><li>情况3，可包含在情况1或2中解决。(节点的prefix列表)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">palindromePairs</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-comment">// 字典树的插入，注意维护每个节点上的两个列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">//倒序单词</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rev</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(words[i]).reverse().toString();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-comment">//如果本单词本身就是回文串，则将根节点的前缀列表上添加i</span><br>            <span class="hljs-keyword">if</span> (isPalindrome(rev.substring(<span class="hljs-number">0</span>))) cur.suffixs.add(i);<br>            <span class="hljs-comment">//插入单词</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; rev.length(); j++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> rev.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">null</span>) cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>                cur = cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-comment">//如果倒序单词的后缀是回文串，则说明原单词的前缀是回文串</span><br>                <span class="hljs-keyword">if</span> (isPalindrome(rev.substring(j+<span class="hljs-number">1</span>))) cur.suffixs.add(i);<br>            &#125;<br>            <span class="hljs-comment">//最后在该节点的word列表中添加i</span><br>            cur.words.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 用以存放答案的列表</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//枚举单词</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//枚举字符</span><br>            <span class="hljs-keyword">for</span> ( ;j &lt; word.length(); j++) &#123;<br>                <span class="hljs-comment">// 到j位置，后续字符串若是回文对，则在该节点位置上所有单词都可以与words[i]构成回文对 即 word+words[i]是回文对</span><br>                <span class="hljs-keyword">if</span>(isPalindrome(word.substring(j))) <br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : cur.words) <br>                        <span class="hljs-keyword">if</span> (k != i) ans.add(Arrays.asList(i,k));<br>                <span class="hljs-comment">// </span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>                cur = cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br><br>            &#125;<br>            <span class="hljs-comment">// words[i]遍历完了，现在找所有大于words[i]长度且符合要求的单词，suffixs列表就派上用场了:)</span><br>            <span class="hljs-keyword">if</span> (j == word.length()) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : cur.suffixs) <br>                    <span class="hljs-keyword">if</span> (k != i) ans.add(Arrays.asList(i,k));<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>    <span class="hljs-comment">//  判断一个字符串是否是回文字符串</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String w)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = w.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (w.charAt(i) != w.charAt(j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++; j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> Node[] children;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; words;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; suffixs;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-built_in">this</span>.words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.suffixs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>反转String的API：<code>new StringBuilder(string).reverse.toString()</code></p></blockquote><p><a href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 字典树前序遍历</span><br>        <span class="hljs-comment">// 当前节点，也是字典的第一个单词</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        k--;<br>        <span class="hljs-comment">// 找第k个</span><br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 获取当前节点的子节点数量，子节点的值上限为n</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> getSteps(curr, n);<br>            <span class="hljs-keyword">if</span> (steps &lt;= k) &#123;<br>                k -= steps;<br>                curr++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curr = curr * <span class="hljs-number">10</span>;<br>                k--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curr;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> curr, <span class="hljs-type">long</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> curr;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> curr;<br>        <span class="hljs-comment">// 只要最左侧的节点还满足要求，就继续求层次和</span><br>        <span class="hljs-keyword">while</span> (first &lt;= n) &#123;<br>            <span class="hljs-comment">// 本层的节点数量</span><br>            steps += Math.min(last, n) - first + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 下一层的头节点和尾节点数量</span><br>            first = first * <span class="hljs-number">10</span>;<br>            last = last * <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（树）</title>
    <link href="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/"/>
    <url>/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h1><h2 id="二叉树遍历、路径与构造"><a href="#二叉树遍历、路径与构造" class="headerlink" title="二叉树遍历、路径与构造"></a>二叉树遍历、路径与构造</h2><h3 id="顺序遍历"><a href="#顺序遍历" class="headerlink" title="顺序遍历"></a>顺序遍历</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><ol><li>DFS</li><li>迭代，使用队列作为栈，然后让所有左节点入栈，出栈时添加其右节点（及其所有左子节点）到栈中。</li></ol><p><a href="https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树</a></p><blockquote><p>可以将遍历理解成一个回溯的过程！</p></blockquote><p>逐个取出节点，使用链表保存路径上的节点，根据节点的深度判断：</p><ol><li>其是沿着上一个节点的左节点</li><li>之前别的的节点的右节点，此时可不停出列直到找到对应深度的节点。</li></ol><p><a href="https://leetcode.cn/problems/find-leaves-of-binary-tree/">366. 寻找二叉树的叶子节点</a><br>后序遍历，反向求各节点的深度，然后按照深度依次放入结果集即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">//求节点到最近叶子节点的距离，或者叫反深度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//求左节点深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(node.left);<br>        <span class="hljs-comment">//求右节点深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(node.right);<br>        <span class="hljs-comment">//当前节点深度 = 最大深度+1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(l, r) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//如果还没有创建该深度的List，创建一个</span><br>        <span class="hljs-keyword">if</span> (cur &gt;= ret.size()) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-comment">//将该节点添加到对应列表中</span><br>        ret.get(cur).add(node.val);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/boundary-of-binary-tree/">545. 二叉树的边界</a><br>携带信息遍历。</p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/">1123. 最深叶节点的最近公共祖先</a></p><ul><li>dfs检测左右节点高度，左右节点一样高则返回本节点。（这样会有重复的高度计算）</li><li>后序遍历并通过全局ans记录，只有左右高度相同且刷新了高度的才记入结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    TreeNode ans;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lcaDeepestLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        dfs(root,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//传入节点和其深度，返回其最深的子节点的深度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-type">int</span> depth)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> depth-<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left,depth+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right,depth+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(left == right &amp;&amp; left&gt;=height)&#123;<br>                ans = root;<br>                height = left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> Math.max(left,right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p><ol><li>层序遍历</li><li>遍历当前节点时，就建立下一层节点之间的关系：为每层建立一个哑节点作为头节点，即可实现子节点的记录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(now != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> pre;<br>            <span class="hljs-keyword">while</span>(now != <span class="hljs-literal">null</span> &amp;&amp; now.left != <span class="hljs-literal">null</span>)&#123;<br>                pre.next = now.left;<br>                pre = pre.next;<br>                pre.next = now.right;<br>                pre = pre.next;<br>                now = now.next;<br>            &#125;<br>            now = index.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iv/">666. 路径总和 IV</a><br>层数小于5和满二叉树的编号，已经提醒了我们可以使用数组来对树进行存储</p><ul><li>先逐个取出节点，保存到数组中</li><li>然后从根节点开始逐层计算分数，未发现叶子节点则结算当前节点，否则累加后等待子节点结算</li></ul><p><a href="https://leetcode.cn/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a><br>通过中序遍历寻找交换节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;TreeNode&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, y = <span class="hljs-literal">null</span>, pred = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span> &amp;&amp; root.val &lt; pred.val) &#123;<br>                y = root;<br>                <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>                    x = pred;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            pred = root;<br>            root = root.right;<br>        &#125;<br>        swap(x, y);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(TreeNode x, TreeNode y)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> x.val;<br>        x.val = y.val;<br>        y.val = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><blockquote><p>对于树的问题，要善于使用递归，通过递归传递出子节点的信息以供父节点使用。该题则需要传递出</p><ul><li>子节点能提供的最大path（小于0则提供0）</li><li>子节点及以下节点的可能出现的最大分数</li></ul></blockquote><p><a href="https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/">1530. 好叶子节点对的数量</a><br>迭代，同时返回各叶子节点的深度，数量和可以为结果作出的贡献，必要时建立结构体作为返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> dfs(root, distance);<br>        <span class="hljs-keyword">return</span> pair.count;<br>    &#125;<br><br>    <span class="hljs-comment">// 对于 dfs(root,distance)，同时返回：</span><br>    <span class="hljs-comment">// 1）每个叶子节点与 root 之间的距离</span><br>    <span class="hljs-comment">// 2) 以 root 为根节点的子树中好叶子节点对的数量</span><br>    <span class="hljs-keyword">public</span> Pair <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-type">int</span>[] depths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//如果是叶子节点，直接返回。</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeaf</span> <span class="hljs-operator">=</span> root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (isLeaf) &#123;<br>            depths[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(depths, <span class="hljs-number">0</span>);<br>        &#125;<br><span class="hljs-comment">//</span><br>        <span class="hljs-type">int</span>[] leftDepths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] rightDepths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取左右节点信息</span><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">leftPair</span> <span class="hljs-operator">=</span> dfs(root.left, distance);<br>            leftDepths = leftPair.depths;<br>            leftCount = leftPair.count;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">rightPair</span> <span class="hljs-operator">=</span> dfs(root.right, distance);<br>            rightDepths = rightPair.depths;<br>            rightCount = rightPair.count;<br>        &#125;<br><span class="hljs-comment">//将左右叶子节点的深度加1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; distance; i++) &#123;<br>            depths[i + <span class="hljs-number">1</span>] += leftDepths[i];<br>            depths[i + <span class="hljs-number">1</span>] += rightDepths[i];<br>        &#125;<br><span class="hljs-comment">//统计当前节点为路径节点能得到的好子节点数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= distance; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j + i + <span class="hljs-number">2</span> &lt;= distance; j++) &#123;<br>                cnt += leftDepths[i] * rightDepths[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回更新后的叶子节点深度和数量，所有好子节点数量。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(depths, cnt + leftCount + rightCount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-type">int</span>[] depths;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] depths, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.depths = depths;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a><br>记录父子关系后，根节点可以沿着三个方向搜索，DFS时每个节点沿剩余两个方向搜索。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">distanceK</span><span class="hljs-params">(root, target *TreeNode, k <span class="hljs-type">int</span>)</span></span> (ans []<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 从 root 出发 DFS，记录每个结点的父结点</span><br>    parents := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">var</span> findParents <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span><br>    findParents = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            parents[node.Left.Val] = node<br>            findParents(node.Left)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            parents[node.Right.Val] = node<br>            findParents(node.Right)<br>        &#125;<br>    &#125;<br>    findParents(root)<br><br>    <span class="hljs-comment">// 从 target 出发 DFS，寻找所有深度为 k 的结点</span><br>    <span class="hljs-keyword">var</span> findAns <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode, *TreeNode, <span class="hljs-type">int</span>)</span></span><br>    findAns = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node, from *TreeNode, depth <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> depth == k &#123; <span class="hljs-comment">// 将所有深度为 k 的结点的值计入结果</span><br>            ans = <span class="hljs-built_in">append</span>(ans, node.Val)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 只会沿着</span><br>        <span class="hljs-keyword">if</span> node.Left != from &#123;<br>            findAns(node.Left, node, depth+<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Right != from &#123;<br>            findAns(node.Right, node, depth+<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> parents[node.Val] != from &#123;<br>            findAns(parents[node.Val], node, depth+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    findAns(target, <span class="hljs-literal">nil</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a><br>利用二进制，对最</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 1.计算层数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            level++;<br>            node = node.left;<br>        &#125;<br>        <span class="hljs-comment">// 2.二分搜索</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; level, high = (<span class="hljs-number">1</span> &lt;&lt; (level + <span class="hljs-number">1</span>)) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (high - low + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-keyword">if</span> (exists(root, level, mid)) &#123;<br>                low = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br><span class="hljs-comment">// 判断节点存在</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bits</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; (level - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span> &amp;&amp; bits &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((bits &amp; k) == <span class="hljs-number">0</span>) &#123;<br>                node = node.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.right;<br>            &#125;<br>            bits &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、二叉搜索树"><a href="#二、二叉搜索树" class="headerlink" title="二、二叉搜索树"></a>二、二叉搜索树</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a><br>删除二叉搜索树的节点，可以递归解决，可以参考红黑树中的做法，寻找待删除节点的后继节点，使用该后继节点代替原节点！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-comment">//左右递归判断</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>            root.left = deleteNode(root.left, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>            root.right = deleteNode(root.right, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">//需要删除本节点</span><br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>    <span class="hljs-comment">//左右节点存在空节点的情况</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-comment">//左右节点都不为空，则寻找后继节点，即找其右节点的（循环寻找左节点），这与使用迭代来遍历中序遍历二叉树有异曲同工之妙。</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-comment">//删除后继节点</span><br>            root.right = deleteNode(root.right, successor.val);<br>            <span class="hljs-comment">//使用后继节点代替本节点</span><br>            successor.right = root.right;<br>            successor.left = root.left;<br>            <span class="hljs-keyword">return</span> successor;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化写法：使用递归是因为要将子节点操作结果反馈给父节点，若主动记录父节点则可以避免递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, curParent = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.val != key) &#123;<br>            curParent = cur;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; key) &#123;<br>                cur = cur.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>            cur = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.right == <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> cur.right, successorParent = cur;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successorParent = successor;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (successorParent.val == cur.val) &#123;<br>                successorParent.right = successor.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                successorParent.left = successor.right;<br>            &#125;<br>            successor.right = cur.right;<br>            successor.left = cur.left;<br>            cur = successor;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (curParent == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (curParent.left != <span class="hljs-literal">null</span> &amp;&amp; curParent.left.val == key) &#123;<br>                curParent.left = cur;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curParent.right = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/depth-of-bst-given-insertion-order/">1902. 给定二叉搜索树的插入顺序求深度</a><br>使用TreeMap保存值和深度的关系，新值的深度肯定是其左右值深度的较大值+1。</p><p><a href="https://leetcode.cn/problems/split-bst/">776. 拆分二叉搜索树</a><br>注意题目条件，递归解决。</p><p><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></p><ol><li>普通做法是找中点，切断关系然后递归，因为需要根据中点来建立左右节点关系。</li><li>也可以认为有序链表就是二叉搜索树的先序遍历，建立一个假重点建立左节点关系，等左节点建立好之后，就可以获取到中节点的值，最后在建立右节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode globalHead;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        globalHead = head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(index != <span class="hljs-literal">null</span>)&#123;<br>            index = index.next;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> midSearch(<span class="hljs-number">0</span>,end-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">midSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        root.left = midSearch(start,mid-<span class="hljs-number">1</span>);<br>        root.val = globalHead.val;<br>        globalHead = globalHead.next;<br>        root.right = midSearch(mid+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><em>定义</em></p><ol><li>是「二叉排序树」</li><li>任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）</li></ol><p><em>评价指标</em></p><ol><li>平衡因子BF：左子树和右子树高度差</li><li>最小不平衡子树：距离插入节点最近的，并且 BF 的绝对值大于 1 的节点为根节点的子树。</li></ol><p><em>平衡二叉树调整</em><br>左右旋转调整即可，参考<a href="https://blog.csdn.net/jarvan5/article/details/112428036?ops_request_misc=%7B%22request_id%22:%22163126248116780357294578%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163126248116780357294578&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112428036.first_rank_v2_pc_rank_v29&utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1018.2226.3001.4187">平衡二叉树</a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>优先队列的良好实现，使用<strong>完全二叉树</strong>存储。也可数组实现，可参考排序算法中的K排序算法。</p><h1 id="三、赫夫曼树"><a href="#三、赫夫曼树" class="headerlink" title="三、赫夫曼树"></a>三、赫夫曼树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/v2-561bb507a8adcbbed29281abac1d3485_1440w.webp"></p><ul><li>二叉树的各节点有权重</li><li>带权路径长度 &#x3D; 叶子节点到根节点的距离×自身权重</li><li>WPL：所有叶子节点的带权路径长度之和。</li></ul><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>每次将根节点权值最小的树合并即可。<br><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/Pasted-image-20230404233232.jpg"></p><h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h2><p>统计各字符使用次数，将其作为权重然后构造赫夫曼树。</p><h1 id="四、B树和B-树"><a href="#四、B树和B-树" class="headerlink" title="四、B树和B+树"></a>四、B树和B+树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><em>定义</em><br>B树是一类树，包括B-树、B+树、B* 树等，这是一种专门为<strong>外部存储器</strong>设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中，其在结构上允许每个节点有更多的子节点。</p><h2 id="为什么使用B树做存储？"><a href="#为什么使用B树做存储？" class="headerlink" title="为什么使用B树做存储？"></a>为什么使用B树做存储？</h2><p><em>预备知识</em></p><ul><li>存储时总存在一个<strong>存储最小单元</strong>（如InnoDB的页）；</li><li><strong>主存的存取过程</strong>中，通过地址总线传入矩阵后即可从数据总线中得到存储数据，该过程中数据之间的距离对效率<strong>没有影响</strong>；</li><li><strong>磁盘I&#x2F;O的存取过程</strong>中，存在机械运动，每个<strong>扇区是磁盘的最小存储单元</strong>；</li><li><strong>局部性原理</strong>：当一个数据被用到时，其附近的数据也通常会马上被使用。</li></ul><p><em>解释</em></p><ul><li>当数据量较大时，内存不够使用，必然需要<strong>磁盘I&#x2F;O</strong>；</li><li>由于磁盘I&#x2F;O相对主存过慢，为提高效率，需要减少磁盘I&#x2F;O，即进行<strong>预读</strong>；</li><li>预读一般以页为基本单位，B树为磁盘位置检索和预读提供了良好的<strong>数据结构</strong>。</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/Pasted-image-20230423002057.png"><br><em>定义</em></p><ul><li><strong>多路自平衡的搜索树</strong>，B树允许每个节点有多个子节点。</li><li><strong>关键字分布在整颗树中</strong>。</li></ul><p><em>优点</em></p><ul><li>相对二叉树，逻辑上接近的节点物理上也会更近，可以<strong>充分利用磁盘预读</strong>。</li><li>相比二叉树，有效降低了树的高度，且每个节点区确定的范围更精确。</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/Pasted-image-20230423002105.png"><br><em>定义</em></p><ul><li>B树的变体，也是<strong>多路自平衡的搜索树</strong>。</li><li><strong>关键字存储在叶子节点上，且叶子节点之间存在链指针</strong>。</li></ul><p><em>与B树的区别</em></p><ul><li>结构上，由于关键字存储位置不同，B+树的<strong>查询时间复杂度</strong>更稳定，B树则取决于搜索关键字的位置；</li><li><strong>B+树叶子节点两两相连</strong>可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li><li>B+树更适合外部存储，由于<strong>内节点不保存数据</strong>，每个节点占用空间更少，意味着一次可以读出更多的非叶子节点，读出的索引更多，搜索更快。</li></ul><h1 id="五、序列化与反序列化"><a href="#五、序列化与反序列化" class="headerlink" title="五、序列化与反序列化"></a>五、序列化与反序列化</h1><p><em>解释</em><br>树的反序列化，最需要关注和维护的就是节点之间的父子和子子关系，实现隔离一个父的多个子，其维护的难点在于，遍历子节点时，需要维护其父节点以维护父子关系。</p><p><em>方法</em><br>无论使用那种方法，序列化的字符串中每个节点或特殊标记之间需要用<strong>空格</strong>或<strong>逗号</strong>等隔开，反序列化时才方便执行：</p><ul><li>DFS+递归：先序构建字符串，字符串记录节点值后记录子节点值。<ul><li>序列化时：为了区分出子节点结构，对于二叉树，空节点传<code>&quot;Null&quot;</code>，对于N叉树，固定使用一位记录节点数量即可。</li><li>反序列化时：使用一个全局变量代表索引即可；</li></ul></li><li>DFS+递归：中序构建字符串，并特殊处理，如二叉树使用<code>(leftNode)root.val(rightNode)</code>序列化，反序列化时，先建立根节点，然后依次、创建左节点、为根节点赋值、创建右节点，其本质与DFS相同；</li><li>BFS(DFS)+建立映射关系：使用数组记录各节点的值和父节点的索引<code>node.val,parentNode.index;</code>，反序列化时依次实例化并建立关系即可；</li><li>DFS+迭代+栈：使用<code>root.val(childrens)</code>的方式记录，遇到<code>(</code>将上一个节点入栈，遇到<code>)</code>将节点出栈，栈顶维护了当前父节点；</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">return</span> encode(root,sb).toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">encode</span><span class="hljs-params">(TreeNode node,StringBuilder sb)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            sb.append(<span class="hljs-string">&quot;null,&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            sb.append(node.val).append(<span class="hljs-string">&quot;,&quot;</span>);<br>            encode(node.left,sb);<br>            encode(node.right,sb);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>        <br>    &#125;<br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        String[] str = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">int</span>[] index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        index[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> decode(str,index);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">decode</span><span class="hljs-params">(String[] str,<span class="hljs-type">int</span>[] index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index[<span class="hljs-number">0</span>] == str.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[index[<span class="hljs-number">0</span>]].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>            index[<span class="hljs-number">0</span>]++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.valueOf(str[index[<span class="hljs-number">0</span>]++]));<br>            node.left = decode(str,index);<br>            node.right = decode(str,index);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/">428. 序列化和反序列化 N 叉树</a><br>方法：</p><ul><li>标注父节点的索引；</li><li>通过<code>[]</code>框住所有的子节点，使用栈维护；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解法一，使用了全局变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        dfsEnocde(root, builder); <br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br><span class="hljs-comment">//记录子节点的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsEnocde</span><span class="hljs-params">(Node root, StringBuilder builder)</span> &#123;<br>        builder.append(root.val).append(<span class="hljs-string">&quot; &quot;</span>);<br>        builder.append(root.children.size()).append(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; root.children.size(); i++) &#123;<br>            dfsEnocde(root.children.get(i), builder);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//全局变量</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span> || data.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        String[] arr = data.split(<span class="hljs-string">&quot; &quot;</span>);<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> decode(arr);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">decode</span><span class="hljs-params">(String[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == arr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//解码节点，由于可以判断个数，故可以确定循环次数，通过i传递遍历进度</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(arr[i++]), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Integer.valueOf(arr[i++]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123; <span class="hljs-comment">// 如果size == 0，则跳过，直接返回root</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> decode(arr);<br>            root.children.add(child);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解法二“1,-1;2,0;3,0;4,0;5,0;6,2;7,2;8,3;9,4;10,4;11,6;12,7;13,8;14,10&quot;。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Queue&lt;Node&gt; nodeQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Node&gt;();<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; indicesQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        nodeQueue.offer(root);<br>        indicesQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">while</span> (!nodeQueue.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nodeQueue.poll();<br>            <span class="hljs-type">int</span>[] indices = indicesQueue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> indices[<span class="hljs-number">0</span>], parentIndex = indices[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!sb.isEmpty()) &#123;<br>                sb.append(<span class="hljs-string">&#x27;;&#x27;</span>);<br>            &#125;<br>            sb.append(node.val);<br>            sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>            sb.append(parentIndex);<br>            List&lt;Node&gt; children = node.children;<br>            <span class="hljs-keyword">for</span> (Node child : children) &#123;<br>                nodeQueue.offer(child);<br>                indicesQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;index, childIndex&#125;);<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        String[] arr = data.split(<span class="hljs-string">&quot;;&quot;</span>);<br>        String[] rootArr = arr[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.parseInt(rootArr[<span class="hljs-number">0</span>]), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        Node[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[length];<br>        nodes[<span class="hljs-number">0</span>] = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            String[] nodeArr = arr[i].split(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> Integer.parseInt(nodeArr[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> Integer.parseInt(nodeArr[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>            nodes[i] = node;<br>            nodes[parent].children.add(node);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解法三，1 ( 2 3 ( 6 7 ( 11 ( 14 ) ) ) 4 ( 8 ( 12 ) ) 5 ( 9 ( 13 ) 10 ) )</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        sb.append(root.val);<br>        List&lt;Node&gt; children = root.children;<br>        <span class="hljs-keyword">if</span> (!children.isEmpty()) &#123;<br>            <span class="hljs-comment">//注意，在添加一个符号前总是添加一个空格，最后再使用空格把所有符号，数字分开，本质上是因为，数组可能不止一位数，对于值为2位数的数字，不加空格无法区分。</span><br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-keyword">for</span> (Node child : children) &#123;<br>                sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>                sb.append(serialize(child));<br>            &#125;<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        String[] arr = data.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.parseInt(arr[<span class="hljs-number">0</span>]), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>        Deque&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Node&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;(&quot;</span>.equals(str)) &#123;<br>                stack.push(last);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;)&quot;</span>.equals(str)) &#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.parseInt(str), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>                <span class="hljs-comment">//这里默认会先把数组都Push进stack，如果该数的前一个符号不是&#x27;(&#x27;，则把前一个数字pop出去。</span><br>                stack.peek().children.add(node);<br>                last = node;<br>            &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a><br>本题考查二叉树的字符串化：<br><strong>括号表达法：</strong><br><code>node.val + &quot;(&quot; + dfs(node.left) + &quot;)(&quot; + dfs(node.right) + &quot;)&quot;</code><br>或<br><code>&quot;(&quot; + dfs(node.left) + &quot;)&quot; +node.val+ &quot;(&quot; + dfs(node.right) + &quot;)&quot;</code></p><div class="note note-primary">            <p>本题开始尝试了以下表示方法，后来发现行不通：<br><code>dfs(node.left) + &quot;[&quot; + node.val + &quot;]&quot; + dfs(node.right)</code></p><ul><li>如果node.left没有叶子节点，则<code>dfs(node.left) = [node.left.val]</code>，则<code>dfs(node.left)</code>与<code>[node.val]</code>无法分出哪个是根节点。</li><li>所以如果使用括号类标识法，应该保证根节点唯一，左右节点可区分。</li></ul>          </div><p><a href="https://leetcode.cn/problems/encode-n-ary-tree-to-binary-tree/">431. 将 N 叉树编码为二叉树</a><br>N叉树与2叉树的转化，利用左右节点来表示同级节点和子节点。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（设计与应用类）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8%E7%B1%BB%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="设计类"><a href="#设计类" class="headerlink" title="设计类"></a>设计类</h1><h2 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h2><p><a href="https://leetcode.cn/problems/encode-and-decode-strings/">271. 字符串的编码与解码</a><br>使用非ascii码编解码，或使用长度协议。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><a href="https://leetcode.cn/problems/zigzag-iterator/">281. 锯齿迭代器</a><br><a href="https://leetcode.cn/problems/max-stack/">716. 最大栈</a><br><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU 缓存</a><br>法1：平衡二叉树：依赖频率和时间排序，注意要先取出再放入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>    <span class="hljs-comment">// 缓存容量，时间戳</span><br>    <span class="hljs-type">int</span> capacity, time;<br>    Map&lt;Integer, Node&gt; key_table;<br>    TreeSet&lt;Node&gt; S;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LFUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.time = <span class="hljs-number">0</span>;<br>        key_table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Node&gt;();<br>        S = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Node&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果哈希表中没有键 key，返回 -1</span><br>        <span class="hljs-keyword">if</span> (!key_table.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 从哈希表中得到旧的缓存</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> key_table.get(key);<br>        <span class="hljs-comment">// 从平衡二叉树中删除旧的缓存</span><br>        S.remove(cache);<br>        <span class="hljs-comment">// 将旧缓存更新</span><br>        cache.cnt += <span class="hljs-number">1</span>;<br>        cache.time = ++time;<br>        <span class="hljs-comment">// 将新缓存重新放入哈希表和平衡二叉树中</span><br>        S.add(cache);<br>        key_table.put(key, cache);<br>        <span class="hljs-keyword">return</span> cache.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!key_table.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 如果到达缓存容量上限</span><br>            <span class="hljs-keyword">if</span> (key_table.size() == capacity) &#123;<br>                <span class="hljs-comment">// 从哈希表和平衡二叉树中删除最近最少使用的缓存</span><br>                key_table.remove(S.first().key);<br>                S.remove(S.first());<br>            &#125;<br>            <span class="hljs-comment">// 创建新的缓存</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>, ++time, key, value);<br>            <span class="hljs-comment">// 将新缓存放入哈希表和平衡二叉树中</span><br>            key_table.put(key, cache);<br>            S.add(cache);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这里和 get() 函数类似</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> key_table.get(key);<br>            S.remove(cache);<br>            cache.cnt += <span class="hljs-number">1</span>;<br>            cache.time = ++time;<br>            cache.value = value;<br>            S.add(cache);<br>            key_table.put(key, cache);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Node&gt; &#123;<br>    <span class="hljs-type">int</span> cnt, time, key, value;<br>    Node(<span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> time, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-built_in">this</span>.cnt = cnt;<br>        <span class="hljs-built_in">this</span>.time = time;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Node rhs)</span> &#123;<br>        <span class="hljs-keyword">return</span> cnt == rhs.cnt ? time - rhs.time : cnt - rhs.cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>法2：本质上只需要维护相同频率文件之间的时间顺序，使用双hash + 链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>    <span class="hljs-comment">// 最低使用频率</span><br>    <span class="hljs-type">int</span> minfreq, capacity;<br>    <span class="hljs-comment">// 记录key -&gt; Node</span><br>    Map&lt;Integer, Node&gt; keyTable;<br>    <span class="hljs-comment">// 记录 freq -&gt; Link</span><br>    Map&lt;Integer, DoublyLinkedList&gt; freqTable;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LFUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.minfreq = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        keyTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Node&gt;();<br>        freqTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, DoublyLinkedList&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 直接搜索节点</span><br>        <span class="hljs-keyword">if</span> (!keyTable.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 搜索到节点后，根据频率定位节点所在链表，取出</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyTable.get(key);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> node.val, freq = node.freq;<br>        freqTable.get(freq).remove(node);<br>        <span class="hljs-comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span><br>        <span class="hljs-keyword">if</span> (freqTable.get(freq).size == <span class="hljs-number">0</span>) &#123;<br>            freqTable.remove(freq);<br>            <span class="hljs-keyword">if</span> (minfreq == freq) &#123;<br>                minfreq += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 插入到 freq + 1 中</span><br>        <span class="hljs-type">DoublyLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> freqTable.getOrDefault(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>());<br>        list.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, val, freq + <span class="hljs-number">1</span>));<br>        freqTable.put(freq + <span class="hljs-number">1</span>, list);<br>        keyTable.put(key, freqTable.get(freq + <span class="hljs-number">1</span>).getHead());<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!keyTable.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 缓存已满，需要进行删除操作</span><br>            <span class="hljs-keyword">if</span> (keyTable.size() == capacity) &#123;<br>                <span class="hljs-comment">// 通过 minFreq 拿到 freqTable[minFreq] 链表的末尾节点</span><br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> freqTable.get(minfreq).getTail();<br>                keyTable.remove(node.key);<br>                freqTable.get(minfreq).remove(node);<br>                <span class="hljs-keyword">if</span> (freqTable.get(minfreq).size == <span class="hljs-number">0</span>) &#123;<br>                    freqTable.remove(minfreq);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">DoublyLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> freqTable.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>());<br>            list.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value, <span class="hljs-number">1</span>));<br>            freqTable.put(<span class="hljs-number">1</span>, list);<br>            keyTable.put(key, freqTable.get(<span class="hljs-number">1</span>).getHead());<br>            minfreq = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 与 get 操作基本一致，除了需要更新缓存的值</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> keyTable.get(key);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">freq</span> <span class="hljs-operator">=</span> node.freq;<br>            freqTable.get(freq).remove(node);<br>            <span class="hljs-keyword">if</span> (freqTable.get(freq).size == <span class="hljs-number">0</span>) &#123;<br>                freqTable.remove(freq);<br>                <span class="hljs-keyword">if</span> (minfreq == freq) &#123;<br>                    minfreq += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">DoublyLinkedList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> freqTable.getOrDefault(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoublyLinkedList</span>());<br>            list.addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value, freq + <span class="hljs-number">1</span>));<br>            freqTable.put(freq + <span class="hljs-number">1</span>, list);<br>            keyTable.put(key, freqTable.get(freq + <span class="hljs-number">1</span>).getHead());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 双向链表节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, val, freq;<br>    Node prev, next;<br><br>    Node() &#123;<br>        <span class="hljs-built_in">this</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    Node(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> freq) &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.freq = freq;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现了一个有哑头尾节点的双向链表，便于操作</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoublyLinkedList</span> &#123;<br>    Node dummyHead, dummyTail;<br>    <span class="hljs-type">int</span> size;<br><br>    DoublyLinkedList() &#123;<br>        dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        dummyTail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        dummyHead.next = dummyTail;<br>        dummyTail.prev = dummyHead;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prevHead</span> <span class="hljs-operator">=</span> dummyHead.next;<br>        node.prev = dummyHead;<br>        dummyHead.next = node;<br>        node.next = prevHead;<br>        prevHead.prev = node;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> node.prev, next = node.next;<br>        prev.next = next;<br>        next.prev = prev;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getTail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> dummyTail.prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-frequency-stack/">895. 最大频率栈</a><br>巧妙之处在于如果一个数字出现了n次，那么在频率1至频率n的队列中都有该数字，其反应了该数字在某频率下的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FreqStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; freq;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Deque&lt;Integer&gt;&gt; group;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxFreq;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FreqStack</span><span class="hljs-params">()</span> &#123;<br>        freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Deque&lt;Integer&gt;&gt;();<br>        maxFreq = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        freq.put(val, freq.getOrDefault(val, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        group.putIfAbsent(freq.get(val), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;());<br>        group.get(freq.get(val)).push(val);<br>        maxFreq = Math.max(maxFreq, freq.get(val));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> group.get(maxFreq).peek();<br>        freq.put(val, freq.get(val) - <span class="hljs-number">1</span>);<br>        group.get(maxFreq).pop();<br>        <span class="hljs-keyword">if</span> (group.get(maxFreq).isEmpty()) &#123;<br>            maxFreq--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="综合应用类"><a href="#综合应用类" class="headerlink" title="综合应用类"></a>综合应用类</h1><h3 id="对比两个文件-x2F-数组，文件过大时怎么办？"><a href="#对比两个文件-x2F-数组，文件过大时怎么办？" class="headerlink" title="对比两个文件&#x2F;数组，文件过大时怎么办？"></a>对比两个文件&#x2F;数组，文件过大时怎么办？</h3><ul><li>为了解决文件过大，使用分治；</li><li>最后需要将结果合并；</li><li>为了合并结果，可使用hash结构记录每一块的对比结果或对后续的影响；</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（动态规划）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、字符串问题"><a href="#一、字符串问题" class="headerlink" title="一、字符串问题"></a>一、字符串问题</h1><h2 id="通配符问题"><a href="#通配符问题" class="headerlink" title="通配符问题"></a>通配符问题</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/wildcard-matching/">44. 通配符匹配</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//*可以匹配空，所以要找到p的第一个非*的数，其前面的都可以与空匹配。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(p.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//c1 与 c2匹配</span><br>                <span class="hljs-keyword">if</span>(c1 == c2 || c2 == <span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-comment">//c2包含 c1时和 c2不包含c1时</span><br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h2><p>对于寻找字符串的回文子串问题：</p><ul><li>可采用从中心扩展的方式（）</li><li>可使用dp的思想解决</li></ul><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><ol><li>中心扩展，注意剪枝</li><li>dp，处理好索引</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//中心扩展</span><br>String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//边界条件判断</span><br>    <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-comment">//start表示最长回文串开始的位置，</span><br>    <span class="hljs-comment">//maxLen表示最长回文串的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ) &#123;<br>        <span class="hljs-comment">//如果剩余子串长度小于目前查找到的最长回文子串的长度，直接终止循环</span><br>        <span class="hljs-comment">// （因为即使他是回文子串，也不是最长的，所以直接终止循环，不再判断）</span><br>        <span class="hljs-keyword">if</span> (length - i &lt;= maxLen / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i;<br>        <span class="hljs-keyword">while</span> (right &lt; length - <span class="hljs-number">1</span> &amp;&amp; s.charAt(right + <span class="hljs-number">1</span>) == s.charAt(right))<br>            ++right; <span class="hljs-comment">//过滤掉重复的</span><br>        <span class="hljs-comment">//下次在判断的时候从重复的下一个字符开始判断</span><br>        i = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//然后往两边判断，找出回文子串的长度</span><br>        <span class="hljs-keyword">while</span> (right &lt; length - <span class="hljs-number">1</span> &amp;&amp; left &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(right + <span class="hljs-number">1</span>) == s.charAt(left - <span class="hljs-number">1</span>)) &#123;<br>            ++right;<br>            --left;<br>        &#125;<br>        <span class="hljs-comment">//保留最长的</span><br>        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>            start = left;<br>            maxLen = right - left + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//截取回文子串</span><br>    <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a><br>预处理回文串区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-comment">//预处理回文串区间</span><br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(g[i], <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                g[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断各种分法能否构成回文串</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(f, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][i]) &#123;<br>                f[i] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (g[j + <span class="hljs-number">1</span>][i]) &#123;<br>                        f[i] = Math.min(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. 让字符串成为回文串的最少插入次数</a><br>方法一：求最长子序列，然后减去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minInsertions</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//求最大回文子序列，然后减去这个长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">//dp[i][j]表示坐标i到j（包括j）的最大回文子序列</span><br>        <span class="hljs-comment">//if char[i] == char[j] : dp[i][j] = dp[i+1][j-1]+2</span><br>        <span class="hljs-comment">//else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</span><br>        <span class="hljs-comment">//可见这里的循环需要i从大到小，j从小到大遍历，因此有 i=n-1,j=i+1的索引初始化。</span><br>        <span class="hljs-comment">//另外，当j=i+1时，需要dp[i+1][j-1] == 0;dp[i][j-1] == 1，因此有每个i开头时的初始化dp[i][i] = 1。</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n-dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：传统dp，使用长度迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minInsertions</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;length&lt;=n;length++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-length;i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+length-<span class="hljs-number">1</span>;<br>                dp[i][j] = Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                    dp[i][j] = Math.min(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-keyword">if</span>(c1 == c2)&#123;<br>                    dp[i][j] = Math.max(dp[i][j],dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>);<br>                &#125;<br>                dp[i][j] = Math.max(dp[i][j],Math.max(dp[i][j-<span class="hljs-number">1</span>],dp[i+<span class="hljs-number">1</span>][j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-different-palindromic-subsequences/">730. 统计不同回文子序列</a><br>dp时一般会取一个窗口的两端进行判断，这里要避免重复有两个方案（看官方题解）：</p><ol><li><p><code>dp[i][j][k]</code>统计某个窗口<code>[i,j]</code>内以某单词<code>k</code>为两端的回文子序列数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//char[i] == char[j] == k时，所有回文串都可以加上前后的k得到新的回文串</span><br>dp[i][j][k] = <span class="hljs-number">2</span>+sum(m)(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][m]);<br><span class="hljs-comment">//char[j] == k</span><br>dp[i][j][k] = dp[i+<span class="hljs-number">1</span>][j][k];<br><span class="hljs-comment">//char[i] == k</span><br>dp[i][j][k] = dp[i][j-<span class="hljs-number">1</span>][k];<br><span class="hljs-comment">//char[i] != k &amp;&amp; char[j] != k</span><br>dp[i][j][k] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][k];<br></code></pre></td></tr></table></figure></li><li><p><code>dp[i][j]</code>统计某窗口内所有回文子序列数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//char[i] == char[j] =c时</span><br><span class="hljs-comment">//求i的nextC，j的preC:</span><br><span class="hljs-comment">//if nextC&lt;preC，减去重复的部分</span><br>dp[i][j] = <span class="hljs-number">2</span> * dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] - dp[nextC][preC]<br><span class="hljs-comment">//if nextC == preC，多加一个cc补充回文。</span><br>dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br><span class="hljs-comment">//if nextC&gt;preC，多加c和cc两个回文</span><br>dp[i][j] = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> * dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// char[i] != char[j]时：</span><br>dp[i][j] = dp[i+<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>]-dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/">1147. 段式回文</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestDecomposition</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-keyword">return</span> divide(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(String text)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> text.length();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(text.substring(<span class="hljs-number">0</span>,i).equals(text.substring(len-i,len)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>+divide(text.substring(i,len-i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h2><h3 id="拼接问题"><a href="#拼接问题" class="headerlink" title="拼接问题"></a>拼接问题</h3><p><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a><br><a href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a><br>使用set判断片段匹配，为每一个字符索引维护一个<code>List&lt;String&gt;</code>，发现匹配后，直接在原<code>String</code>后拼接即可。<br><a href="https://leetcode.cn/problems/shortest-way-to-form-string/">1055. 形成字符串的最短路径</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestWay</span><span class="hljs-params">(String source, String target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> source.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">while</span>( j &lt; target.length() )&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> j ;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>                <span class="hljs-keyword">if</span>( j &lt; target.length() &amp;&amp; source.charAt(i) == target.charAt(j) )<br>                    j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>( prev == j ) <span class="hljs-comment">//如果j没有移动</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/scramble-string/">87. 扰乱字符串</a><br>3维dp<br>假设：S1&#x3D;A1+B1，S2&#x3D;A2+B2<br>结论：若A1和A2，B1和B2分别是扰乱字符串，则S1和S2也是；若A1和B2，B1和A2分别是扰乱字符串，则S1和S2也是扰乱字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以s1的i索引开头，s2的j索引开头，长度为n的字符串是否是扰乱字符串</span><br>dp[i][j][n] = (dp[i][j][len] &amp;&amp; dp[i+len][j+len][n-len]) || (dp[i][j+n-len][len] &amp;&amp; dp[i+n-len][j][len]);<br><span class="hljs-comment">//可以得知以n为外循环即可，n递增</span><br><br><span class="hljs-comment">//全解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isScramble</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s1.length() != s2.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">char</span>[] c1 = s1.toCharArray();<br>        <span class="hljs-type">char</span>[] c2 = s2.toCharArray();<br>        <span class="hljs-type">boolean</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(c1[i] == c2[j]) dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-len;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n-len;j++)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;len;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(dp[i][j][k] &amp;&amp; dp[i+k][j+k][len-k])&#123;<br>                            dp[i][j][len] = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(dp[i][j+len-k][k] &amp;&amp; dp[i+k][j][len-k])&#123;<br>                            dp[i][j][len] = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><p><a href="https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/">1638. 统计只差一个字符的子串数目</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length(), n = t.length();<br>        <span class="hljs-type">int</span>[][] dpl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[][] dpr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                dpl[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = s.charAt(i) == t.charAt(j) ? (dpl[i][j] + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                dpr[i][j] = s.charAt(i) == t.charAt(j) ? (dpr[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) != t.charAt(j)) &#123;<br>                    ans += (dpl[i][j] + <span class="hljs-number">1</span>) * (dpr[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></p><blockquote><p>题目要求，最小且最左，使用DP解决时，考虑从左到右，每轮后需要对比看是否能得到更小的窗口结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s2.length();<br>        <span class="hljs-comment">//dp表示s1的前i个包含s2的前j个的初始位置.</span><br>        Integer[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//可以初始化dp[i][0]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">window_size</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//求每个i包含s2的前1,2,3,...m个字符的初始值.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//求s1中i下标之前，包含s2[:j]的起始位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                <span class="hljs-comment">//若s1的第i个刚好等于s2的第j个,则s1前i个包含s2的前j个的起始位置为s1前i-1个包含s2前j-1个的位置</span><br>                <span class="hljs-keyword">if</span>(s1.charAt(i-<span class="hljs-number">1</span>)==s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-comment">//否则,s1前i个包含s2的前j个的起始位置为s1前i-1个包含s2前j个的位置</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果当前i包含s2的前m个字符的初始值不为空,即满足条件,计算窗口大小和左右指针,</span><br>            <span class="hljs-keyword">if</span>(dp[i][m]!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur_window_size</span> <span class="hljs-operator">=</span> i-dp[i][m];<br>                <span class="hljs-keyword">if</span>(cur_window_size&lt;window_size)&#123;<br>                    l = dp[i][m];<br>                    r = i-<span class="hljs-number">1</span>;<br>                    window_size = cur_window_size;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> s1.substring(l,r+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a><br>一开始想到用双指针，dfs函数中判断是否分支计算，但超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        dfs(s,t,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s,String t,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(j == n)&#123;<br>            count++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == m)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(s,t,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>            dfs(s,t,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态规划可以更好的利用子问题的结果简化计算，实现剪枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//边界条件，对任意空串都有一个匹配！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-comment">//不使用i匹配，默认有dp[i-1][j]个匹配。</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                <span class="hljs-comment">//i可以匹配，再加上dp[i-1][j-1]。</span><br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a><br>需要先处理i&#x3D;0的所有状态，因为<code>dp[0][?]</code>均可能为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n1+<span class="hljs-number">1</span>][n2+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//注意这里的处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n2 ; j++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;.&#x27;</span> || c1 == c2)&#123;<br>                    dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">2</span>);<br>                    <span class="hljs-keyword">if</span>(c3 == <span class="hljs-string">&#x27;.&#x27;</span> || c3 == c1)&#123;<br>                        dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n1][n2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">940. 不同的子序列 II</a><br>与不同的回文串类似的思路<br>遍历到索引i的字母c时，根据i-1时的不同子序列：<br>索引i子序列数量 &#x3D; A（索引i-1子序列数量，不重复） + B（索引i-1子序列加上c，不重复）-A&amp;B（A中以上一个c结尾的子序列数量）+1（c本身）<br><code>dp[i] = dp[i-1] + dp[i-1] - dp[preC-1] +1</code><br>分类讨论：</p><ul><li>字母c没有出现过，则A&amp;B&#x3D;0，<code>dp[i] = 2*dp[i-1]+1</code></li><li>字母c出现过，则A中肯定有c本身，末尾的1要剪掉：<code>dp[i] = dp[i-1] + dp[i-1] - dp[preC-1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctSubseqII</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//记录某单词出现的索引+1；</span><br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// Arrays.fill(pre,-1);</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preC</span> <span class="hljs-operator">=</span> pre[c];<br>            <span class="hljs-comment">//先默认加上边界c自身和可能重复的值</span><br>            dp[i] = (<span class="hljs-number">2</span>*dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)%MOD;<br>            <span class="hljs-comment">//如果之前有c出现，说明，c本身已经包含在默认的dp[i-1]中了，再将多出来的1个减去。</span><br>            <span class="hljs-keyword">if</span>(preC != <span class="hljs-number">0</span>)&#123;<br>                dp[i] = (dp[i]-dp[preC-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>+MOD)%MOD;<br>            &#125;<br>            pre[c] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、状态转移类"><a href="#二、状态转移类" class="headerlink" title="二、状态转移类"></a>二、状态转移类</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a><br>状态：1.持有股票 2.不持有股票 3.不持有股票且今日卖出<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a><br>状态：1.未买入2.买入一次3.卖出一次4.买入两次5.卖出两次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">5</span>];<br>        <span class="hljs-comment">//不持有，未交易</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//持有，未交易</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//持有，交易过一次</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//不持有，交易过一次；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//不持有，交易过两次；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]-prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]+prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[n][<span class="hljs-number">0</span>],Math.max(dp[n][<span class="hljs-number">3</span>],dp[n][<span class="hljs-number">4</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dp只取决于前一天的状态，因此可以简化dp数组为10个变量（昨日5个，今日5个）<br>但可以假设每天可以进行多次买入卖出（不影响当日结果），只要按照<br><strong>买入一次、卖出一次、买入两次、卖出两次</strong>的顺序计算，就不需要维护两日的信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy1</span> <span class="hljs-operator">=</span>-prices[<span class="hljs-number">0</span>],buy2=-prices[<span class="hljs-number">0</span>],sell1=<span class="hljs-number">0</span>,sell2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            buy1 = Math.max(buy1,-prices[i]);<br>            sell1 = Math.max(buy1+prices[i],sell1);<br>            buy2 = Math.max(buy2,sell1-prices[i]);<br>            sell2 = Math.max(sell2,buy2+prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a><br>注意交易相当于一次买入加卖出，这里将买入作为交易，卖出时不消耗操作次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//严格买入次数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;  <br>    <span class="hljs-comment">//第i天结束时持有/不持有股票且交易次数为k的最大值</span><br>    <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>][k+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//预处理第0天，第0天执行一次买入情形：</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];  <br>    <span class="hljs-comment">//第0天执行1次以上的情况不存在：</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;i++)&#123;  <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i] = Integer.MIN_VALUE/<span class="hljs-number">2</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-comment">//这里不处理j == 0的情况，因为j==0时，dp永远为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;  <br>            dp[i][<span class="hljs-number">1</span>][j] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][j],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]-prices[i]);  <br>            dp[i][<span class="hljs-number">0</span>][j] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][j],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][j]+prices[i]);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> Arrays.stream(dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).max().getAsInt();  <br>&#125;<br><br><span class="hljs-comment">//单纬度解法（可以假设一天进行多次买入和卖出）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br><span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//天数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br><span class="hljs-comment">//进行i次买入最大的收益</span><br><span class="hljs-type">int</span>[] buy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] sell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//第0天，进行i次买入最大的收益为-price[i]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>buy[i] = -prices[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">//从第1天开始算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-comment">//买卖次数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>buy[j] = Math.max(buy[j],sell[j-<span class="hljs-number">1</span>]-prices[i]);<br>sell[j] = Math.max(sell[j],buy[j]+prices[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sell[k];<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意，股票问题在迭代时考虑两个问题：</p><ul><li>可以考虑将卖出和买入作为两个数组（或变量）来维护，结果更显而易见。</li><li>是否可以当成每天可以进行多次交易，若是，则可以节省dp空间</li></ul>          </div><p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></p><ul><li>状态：1.今日偷取 2.今日未偷，每日结束时最大价值取决于前一日是否偷和对应金额，因为环形问题分两种情况考虑即可</li><li>状态：记录每日结束时最大即可，每日结束时最大价值取决于前两日。</li></ul><p><a href="https://leetcode.cn/problems/pizza-with-3n-slices/">1388. 3n 块披萨</a><br>类似打家劫舍，但由于取每块批萨时，不仅取决于前一块，还会影响后一块。由于取走的总数是恒定的，所以根据取走的块数来进行dp。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSizeSlices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] slices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> slices.length;<br>        <span class="hljs-type">int</span>[] slices1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] slices2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-<span class="hljs-number">1</span>];<br>        System.arraycopy(slices,<span class="hljs-number">1</span>,slices1,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        System.arraycopy(slices,<span class="hljs-number">0</span>,slices2,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans1</span> <span class="hljs-operator">=</span> pick(slices1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans2</span> <span class="hljs-operator">=</span> pick(slices2);<br>        <span class="hljs-keyword">return</span> Math.max(ans1,ans2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] slices)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> slices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> (n+<span class="hljs-number">1</span>)/<span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][choose+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxPick</span> <span class="hljs-operator">=</span> Math.min(i,choose);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=maxPick;j++)&#123;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],(i-<span class="hljs-number">2</span>&gt;=<span class="hljs-number">0</span>?dp[i-<span class="hljs-number">2</span>][j-<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>)+slices[i-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][choose];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由打家结舍2和批萨问题可知，状态转移的前驱状态不仅只能是前一天。</p></blockquote><p><a href="https://leetcode.cn/problems/frog-jump/">403. 青蛙过河</a><br>注意记忆化搜索，以当前位置和上一次跳跃距离为状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Boolean[][] can;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCross</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[n][n];<br>        <span class="hljs-keyword">return</span> canCross(stones,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCross</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> step)</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(start == stones.length-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(can[start][step] != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> can[start][step];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start+<span class="hljs-number">1</span>;i&lt;stones.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextStep</span> <span class="hljs-operator">=</span> stones[i]-stones[start];<br>            <span class="hljs-keyword">if</span>(nextStep &lt; step-<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nextStep &gt; step+<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(canCross(stones,i,nextStep))&#123;<br>                <span class="hljs-keyword">return</span> can[start][step] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> can[start][step] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以动态规划，题目有隐含条件，到达索引index时，其上一步绝对不会超过index。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCross</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//可以提前判断不可能到达的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (stones[i] - stones[i - <span class="hljs-number">1</span>] &gt; i) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//固定i,列举i的前一次石头，查看是否可能到达。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> stones[i] - stones[j];<br>                <span class="hljs-keyword">if</span> (k &gt; j + <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                dp[i][k] = dp[j][k - <span class="hljs-number">1</span>] || dp[j][k] || dp[j][k + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> &amp;&amp; dp[i][k]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/dungeon-game/">174. 地下城游戏</a><br>盲目的dfs会弄错题目的意思，本题要求骑士血量永远在0以上，所以先扣血后补血并不是等价的，可以直接假设到达终点后骑士剩余血量为1，然后倒推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] dungeon)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> dungeon.length, m = dungeon[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            Arrays.fill(dp[i], Integer.MAX_VALUE);<br>        &#125;<br>        <span class="hljs-comment">//终点时骑士血量为1</span><br>        dp[n][m - <span class="hljs-number">1</span>] = dp[n - <span class="hljs-number">1</span>][m] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//骑士站在(i,j)往右边或下面走时至少需要minn的血量，因此走到(i,j)则至少需要（minn-dungeon[i][j]）的血量或1血量。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">minn</span> <span class="hljs-operator">=</span> Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i][j + <span class="hljs-number">1</span>]);<br>                dp[i][j] = Math.max(minn - dungeon[i][j], <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/paint-fence/">276. 栅栏涂色</a><br>正常三维dp必然会超时，应该意识到所有颜色都是相同的，可以使用递推公式来解决：</p><ul><li>第i个栏栅与第i-1个栏栅颜色不同，则<code>dp[i] += dp[i-1] * (k-1)</code></li><li>这点的思路与打家劫舍2和3n披萨相似，临近排斥问题可以考虑前若干天&#x2F;若干份的情况。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//可以只考虑某种颜色情况</span><br>        <span class="hljs-comment">//第一天可选方案数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//第二天可选方案数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> k;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> d1*k;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> d2*k;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> d2;<br>            d2 = (k-<span class="hljs-number">1</span>)*(d1+d2);<br>            d1 = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d2*k;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//第1天选择某颜色，且不限制后面选择的方案数为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//第1天选择某颜色，且限制后面选择的可能方案为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从第2天开始求某颜色的方案数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempX</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempY</span> <span class="hljs-operator">=</span> y;<br>            <span class="hljs-comment">//第2天有(k-1)(tempX+tempY)种方案不限制后面选择</span><br>            x = (k-<span class="hljs-number">1</span>)*(tempX+tempY);<br>            <span class="hljs-comment">//第2天有tempX种方案限制后面的选择</span><br>            y = tempX;<br>        &#125;<br>        <span class="hljs-comment">//最后求不限制后面的方案总数</span><br>        <span class="hljs-keyword">return</span> k*(x+y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a><br>本体与其他对状态转义的处理方式不细微的不同：</p><ul><li>对于打家劫舍，其只需要以前一天是否偷取的<strong>行为</strong>作为依据（即行为就是一个维度），判断今天不同行为得到的结果即可。</li><li>对于本题，记录的不是行为，而是行为的结果（迟到次数，缺勤次数），所以根据今天的3种不同行为，需要分别考虑并汇总。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkRecord</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//影响后续dp的只有，之前已经缺勤的次数和连续迟到的次数</span><br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//如果今日到场,缺勤次数不变</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-comment">//过去的所有迟到清零</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                    dp[i][j][<span class="hljs-number">0</span>] = (dp[i][j][<span class="hljs-number">0</span>]+dp[i-<span class="hljs-number">1</span>][j][k])%MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果今日迟到，缺勤次数不变</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                    dp[i][j][k] = (dp[i][j][k] + dp[i-<span class="hljs-number">1</span>][j][k-<span class="hljs-number">1</span>])%MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果今日缺勤，迟到次数归零</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k])%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2</span>;j++)&#123;<br>                ans = (ans+dp[n][i][j])%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>特殊的状态转移方程，原理是矩阵运算。<br><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//转移参数</span><br>        <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] res = pow(a,n);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><span class="hljs-comment">// 矩阵a的n次方</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] pow(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span> n)&#123;<br>    <span class="hljs-comment">//初始状态为单位矩阵</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-comment">//每次循环做一次平方，或在平方上再乘一个矩阵a</span><br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//存在奇数次时，乘一次a</span><br>            <span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                res = multiply(res,a);<br>            &#125;<br>            <span class="hljs-comment">//迭代a</span><br>            a = multiply(a,a);<br>            <span class="hljs-comment">//右移</span><br>            n = n&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//矩阵相乘</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] multiply(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b) &#123;<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                c[i][j] = a[i][<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>][j] + a[i][<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、数值序列规划"><a href="#三、数值序列规划" class="headerlink" title="三、数值序列规划"></a>三、数值序列规划</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a><br>通过处理缩小枚举左指针范围。<br><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a><br>记录各索引元素前递增个数。<br><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a><br>把信封按宽度递增、高度递减排序。实现了每个信封宽度都比前面大或相同，且相同宽度的信封不会装起来。</p><ul><li>直接dp，判断高度，超时！</li><li>直接dp超时的原因在于寻找前一个可以装的信封时是枚举算法，改进：使用一个数组记录 套了i个信封的 的最小信封高度，这是一个递增数组。在判断一个新信封能装多少信封时，搜索刚好低于该高度的最长序列即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分dp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] es)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> es.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-comment">// 由于我们使用了 g 记录高度，因此这里只需将 w 从小到达排序即可</span><br>        Arrays.sort(es, (a, b)-&gt;a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// f(i) 为考虑前 i 个物品，并以第 i 个物品为结尾的最大值</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>        <span class="hljs-comment">// g(i) 记录的是长度为 i 的最长上升子序列的最小「信封高度」</span><br>        <span class="hljs-type">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>        <span class="hljs-comment">// 因为要取 min，用一个足够大（不可能）的高度初始化</span><br>        Arrays.fill(g, Integer.MAX_VALUE); <br>        g[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, len = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 对于 w 相同的数据，不更新 g 数组</span><br>            <span class="hljs-keyword">if</span> (es[i][<span class="hljs-number">0</span>] != es[j][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">// 限制 j 不能越过 i，确保 g 数组中只会出现第 i 个信封前的「历史信封」</span><br>                <span class="hljs-keyword">while</span> (j &lt; i) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> f[j], cur = es[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (prev == len) &#123;<br>                        <span class="hljs-comment">// 与当前长度一致了，说明上升序列多增加一位</span><br>                        g[len++] = cur;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 始终保留最小的「信封高度」，这样可以确保有更多的信封可以与其行程上升序列</span><br>                        <span class="hljs-comment">// 举例：同样是上升长度为 5 的序列，保留最小高度为 5 记录（而不是保留任意的，比如 10），这样之后高度为 7 8 9 的信封都能形成序列；</span><br>                        g[prev] = Math.min(g[prev], cur);<br>                    &#125;<br>                    j++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 二分过程</span><br>            <span class="hljs-comment">// g[i] 代表的是上升子序列长度为 i 的「最小信封高度」</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 令 check 条件为 es[i][1] &lt;= g[mid]（代表 w 和 h 都严格小于当前信封）</span><br>                <span class="hljs-comment">// 这样我们找到的就是满足条件，最靠近数组中心点的数据（也就是满足 check 条件的最大下标）</span><br>                <span class="hljs-comment">// 对应回 g[] 数组的含义，其实就是找到 w 和 h 都满足条件的最大上升长度</span><br>                <span class="hljs-keyword">if</span> (es[i][<span class="hljs-number">1</span>] &lt;= g[mid]) &#123;<br>                    r = mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新 f[i] 与答案</span><br>            f[i] = r;<br>            ans = Math.max(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量</a><br>按攻击力升序，按防御力降序即可判断是否有角色比本角色弱。<br>本题求的是弱角色的数量，而不是求比各个角色弱的角色数量，计算时需要去重。<br>可以使用队列记录防御力，若当前角色防御力高于队尾角色，则应该将尾部不断出队，然后将当前角色入队。每出队一个角色即有一个弱角色。</p><p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度</a><br>本质就是遍历dp，但可以剪枝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Map求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length,ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            map.put(arr[i], i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ivalue</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">//剪枝</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span>*arr[j]&gt;arr[i];j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> map.getOrDefault(arr[i] - arr[j], -<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(k == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[j][i] = Math.max(dp[k][j] + <span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>                ans = Math.max(ans,dp[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//OOM</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length,ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> arr[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxValue+<span class="hljs-number">1</span>][maxValue+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">iValue</span> <span class="hljs-operator">=</span> arr[i];<br>            dp[<span class="hljs-number">0</span>][iValue] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]&gt;iValue/<span class="hljs-number">2</span>;j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">jValue</span> <span class="hljs-operator">=</span> arr[j];<br>                <span class="hljs-keyword">if</span>(dp[<span class="hljs-number">0</span>][iValue-jValue] != <span class="hljs-number">0</span>)&#123;<br>                    dp[jValue][iValue] = Math.max(<span class="hljs-number">3</span>,dp[iValue-jValue][jValue]+<span class="hljs-number">1</span>);<br>                    ans = Math.max(ans,dp[jValue][iValue]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/largest-divisible-subset/">368. 最大整除子集</a><br>排序后，只有后面数是前面数的倍数，就可以连接成子集，因此只需要找到并记录最长子集的长度和最大数。然后倒序推理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestDivisibleSubset</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVal</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]%nums[j] == <span class="hljs-number">0</span>)&#123;<br>                    dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i]&gt;maxSize)&#123;<br>                maxSize = dp[i];<br>                maxVal = nums[i];<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(maxVal%nums[i] == <span class="hljs-number">0</span> &amp;&amp; dp[i] == maxSize)&#123;<br>                list.add(nums[i]);<br>                maxVal = nums[i];<br>                maxSize--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a><br>使用lowbit方法dp</p><p><a href="https://leetcode.cn/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最后的i一定是j的倍数，枚举j，实现状态转移复制可以视为 第一次”粘贴“（原文本）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//f[i]为复制得到i个A需要的操作次数</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//f[1] = 0; 可省略，表示得到1个A需要0次操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            f[i] = Integer.MAX_VALUE;<br>            <span class="hljs-comment">//枚举i的因数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j * j &lt;= i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//如果上次是j复制得到，可能是得到一个j后复制粘贴i/j次：f[j]+i/j</span><br>                    f[i] = Math.min(f[i], f[j] + i / j);<br>                    <span class="hljs-comment">//也可能是i/j复制得到，可能是得到一个i/j后复制粘贴j次：f[i/j]+j</span><br>                    f[i] = Math.min(f[i], f[i / j] + j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a></p><ol><li>使用优先队列，每取出一个最小元素就将其可能新增的三个元素添加到队列中，并利用set去重。</li><li>使用三指针，分别记录<code>*2</code>、<code>*3</code>、<code>*5</code>的数字指针（由于结果是递增的，所以指针总是右移，每次取乘对于倍数最小的数即可，然后移动该指针）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] ugly = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        ugly[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,p2 = <span class="hljs-number">1</span>,p3 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Math.min(ugly[p1]*<span class="hljs-number">2</span>,Math.min(ugly[p2]*<span class="hljs-number">3</span>,ugly[p3]*<span class="hljs-number">5</span>));<br>            ugly[i] = next;<br>            <span class="hljs-keyword">if</span>(next == ugly[p1] *<span class="hljs-number">2</span>)&#123;<br>                p1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(next == ugly[p2] *<span class="hljs-number">3</span>)&#123;<br>                p2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(next == ugly[p3] *<span class="hljs-number">5</span>)&#123;<br>                p3++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ugly[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//dp[i]表示数字i任意拆分再相乘后能得到的最大值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                curMax = Math.max(curMax,Math.max((i-j)*j,j*dp[i-j]));<br>            &#125;<br>            dp[i] = curMax;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a><br>递增序列维护区间最小值信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        Deque&lt;Integer&gt; monoStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!monoStack.isEmpty() &amp;&amp; arr[monoStack.peek()] &gt; arr[i]) &#123;<br>                monoStack.pop();<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> monoStack.isEmpty() ? (i + <span class="hljs-number">1</span>) : (i - monoStack.peek());<br>            dp[i] = k * arr[i] + (monoStack.isEmpty() ? <span class="hljs-number">0</span> : dp[i - k]);<br>            ans = (ans + dp[i]) % MOD;<br>            monoStack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、区间dp"><a href="#四、区间dp" class="headerlink" title="四、区间dp"></a>四、区间dp</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球</a><br><a href="https://leetcode.cn/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a><br>可以分析，我们对数进行k次分组，递推公式为：<br><code>dp[k][i] = dp[k-1][j]+avg[j,i];</code><br>此时可以判断每次只利用上一次循环比i小的索引，所以只要更新索引时从大到小更新，就可以只使用一个数组判断：<br><code>dp[i] = dp[j] + avg[j,i]</code></p><p>临界条件的判断：<br>当k &#x3D;&#x3D; 1时，<code>dp[1][i] = pre[i]/i</code>，所以预先处理dp函数后，循环的次数应该减少一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">double</span>[] P = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[N+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)<br>            P[i+<span class="hljs-number">1</span>] = P[i] + A[i];<br><br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        <span class="hljs-comment">//dp[i]中依然包含i的值，注意P[i]的定义是，小标i前面的前缀和，所以后面的递推中，i和j都要+1。</span><br>            dp[i] = P[i+<span class="hljs-number">1</span>] / (i+<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//因为k == 1时已经处理，这里少一次循环。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; k &lt;= K; ++k)<br>            <span class="hljs-comment">//i表示i坐标及之前的数分成k份（i+1&gt;=k）时，能够得到的最大数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> N-<span class="hljs-number">1</span>; i &gt;= k-<span class="hljs-number">1</span> ; i--)<br>                <span class="hljs-comment">//j表示j坐标及之前的数分成k-1份(j+1&gt;=k-1)，能够得到的最大平均数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i-<span class="hljs-number">1</span>; j &gt;=k-<span class="hljs-number">2</span>; j--)<br>                <span class="hljs-comment">//i和j的终止条件为&gt;=0</span><br>                    dp[i] = Math.max(dp[i], (P[i+<span class="hljs-number">1</span>]-P[j+<span class="hljs-number">1</span>]) / (i-j) + dp[j]);<br>        <span class="hljs-keyword">return</span> dp[N-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            preSum[i] = preSum[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i] = preSum[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;m&lt;=k;m++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=m-<span class="hljs-number">1</span>;i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=m-<span class="hljs-number">2</span>;j--)&#123;<br>                    dp[i] = Math.min(dp[i],Math.max(dp[j],preSum[i+<span class="hljs-number">1</span>]-preSum[j+<span class="hljs-number">1</span>]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以使用贪心二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贪心二分，很巧妙</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            right += nums[i];<br>            <span class="hljs-keyword">if</span> (left &lt; nums[i]) &#123;<br>                left = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-comment">//以mid为每片上限，可以分成m片</span><br>            <span class="hljs-keyword">if</span> (check(nums, mid, m)) &#123;<br>                <span class="hljs-comment">//令right = mid</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//mid为上线无法分成m片，所以每片上限必须增加</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">//检查以x为上限，可以分成m片吗？</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (sum + nums[i] &gt; x) &#123;<br>                cnt++;<br>                sum = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &lt;= m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/">1444. 切披萨的方案数</a><br>看下思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//正向dp，dp[i][j][k]，表示当以i,j为左上角时，已经切了k刀了（相当于分了k+1份）时，剩下的能满足要求的切法数量。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][][] dp;<br>    <span class="hljs-type">char</span>[][] pz;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> need;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways</span><span class="hljs-params">(String[] pizza, <span class="hljs-type">int</span> k)</span> &#123;<br>        m = pizza.length;<br>        n = pizza[<span class="hljs-number">0</span>].length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][k];<br>        pz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m][n];<br>        need = k;<br>        <span class="hljs-comment">//初始化，-1为尚未计算过的dp。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                pz[i][j] = pizza[i].charAt(j);<br>                Arrays.fill(dp[i][j],-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ways(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> cuted)</span>&#123;<br>        <span class="hljs-comment">//超出边界，为0；</span><br>        <span class="hljs-keyword">if</span>(x&gt;=m || y&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//已经计算过，直接返回</span><br>        <span class="hljs-keyword">if</span>(dp[x][y][cuted] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dp[x][y][cuted];<br>        <span class="hljs-comment">//如果已经切了k-1刀，则已经分成了k份，检查最后一份是否合格即可</span><br>        <span class="hljs-keyword">if</span>(cuted == need-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;m;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(pz[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span>  dp[x][y][cuted] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span>  dp[x][y][cuted] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//否则，要考虑怎么切这一块披萨</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[x][y][cuted] = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> row=m-<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> col=n-<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//首先计算有披萨存在的行和列，我们的切法应该在该行、列的下一行、列。</span><br>            a:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;m;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(pz[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                        row = i;<br>                        <span class="hljs-keyword">break</span> a;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            b:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;m;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(pz[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                        col = j;<br>                        <span class="hljs-keyword">break</span> b;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//横着切，注意防止超过范围</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row+<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            dp[x][y][cuted] = (dp[x][y][cuted]+ways(i,col,cuted+<span class="hljs-number">1</span>))%mod;<br>        &#125;<br>            <span class="hljs-comment">//竖着切</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=col+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[x][y][cuted] = (dp[x][y][cuted]+ways(row,j,cuted+<span class="hljs-number">1</span>))%mod;<br>            &#125;<br>            <span class="hljs-comment">//返回值。</span><br>            <span class="hljs-keyword">return</span> dp[x][y][cuted]%mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/allocate-mailboxes/">1478. 安排邮筒</a><br>写出递推公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前i个房子安排k个邮筒 = 前j个房子安排k-1个邮筒 + j个房子到i个房子安排1个邮筒。</span><br>dp[i][k] = min(j=i-<span class="hljs-number">1</span>-&gt;<span class="hljs-number">0</span>)(dp[j][k-<span class="hljs-number">1</span>] + getSum[j][i])<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自己写的，getSum重复计算较多，可以预处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(houses);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> houses.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">//初始化1个邮箱的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i] = getInstance(houses,-<span class="hljs-number">1</span>,i);<br>        &#125;<br>        <span class="hljs-comment">//从2个邮箱开始考虑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">2</span>;m&lt;=k;m++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                    dp[i] = Math.min(dp[i],dp[j]+getSum(houses,j,i));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//不包括start索引邮箱</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start + <span class="hljs-number">1</span> == end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                ans += houses[right--]-houses[left++];<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> houses.length;<br>        Arrays.sort(houses);<br><span class="hljs-comment">//表示从第i个到第j个邮箱的和</span><br>        <span class="hljs-type">int</span>[][] midSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                midSum[i][j] = midSum[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+houses[j]-houses[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][k+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            Arrays.fill(dp[i],Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i][<span class="hljs-number">1</span>] = midSum[<span class="hljs-number">0</span>][i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=k &amp;&amp; j&lt;=i+<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;q&lt;i;q++)&#123;<br>                    dp[i][j] = Math.min(dp[i][j],dp[q][j-<span class="hljs-number">1</span>]+midSum[q+<span class="hljs-number">1</span>][i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></p><ol><li>统计不同奇数个数的前缀子数组个数</li><li>统计不同奇数个数的前缀子数组的开始坐标，两个开始坐标只差即为对应前缀子数组个数。</li></ol><p><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a><br>通过取模，模相等即说明可整除，避免了枚举前缀和。</p><blockquote><p>java的%是取余，向零取整，<strong>结果符号随被除数</strong>。<br>取模为<code>Math.floorMod(a,b)</code>，向下取整，<strong>结果符号随除数</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysDivByK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        record.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : nums) &#123;<br>            sum += elem;<br>            <span class="hljs-comment">// 注意 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">modulus</span> <span class="hljs-operator">=</span> (sum % k + k) % k;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">same</span> <span class="hljs-operator">=</span> record.getOrDefault(modulus, <span class="hljs-number">0</span>);<br>            ans += same;<br>            record.put(modulus, same + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. 找两个和为目标值且不重叠的子数组</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSumOfLengths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">//dp[i]表示索引i前出现的等于target的数组的最小长度。</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(;right&lt;=n;right++)&#123;<br>            sum += arr[right-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span>(sum &gt; target)&#123;<br>                sum -= arr[left++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                dp[right] = Math.min(dp[right-<span class="hljs-number">1</span>],right-left);<br>                ans = Math.min(ans,dp[left]+right-left);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[right] = dp[right-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans == Integer.MAX_VALUE/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a><br>相当于找异或和为0的的片段长度 之和，可以通过维护各异或值的 出现次数 和 出现的索引之和，来快速求每次出现重复异或值时可以贡献的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countTriplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Map&lt;Integer,Integer&gt; bitCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer,Integer&gt; bitPreSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preBit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        bitCount.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        bitPreSum.put(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            preBit ^= arr[i];<br>            <span class="hljs-keyword">if</span>(bitCount.containsKey(preBit))&#123;<br>                ans += bitCount.get(preBit)*i-bitPreSum.get(preBit);<br>            &#125;<br>            bitCount.put(preBit,bitCount.getOrDefault(preBit,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            bitPreSum.put(preBit,bitPreSum.getOrDefault(preBit,<span class="hljs-number">0</span>)+i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-boxes/">546. 移除盒子</a><br>状态为区间<code>[i,j]</code>且j后面有k个与j颜色相同的盒子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][][] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeBoxes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] boxes)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> boxes.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][length][length];<br>        <span class="hljs-keyword">return</span> calculatePoints(boxes, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculatePoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[] boxes, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//越界或已经记忆时直接返回</span><br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[l][r][k] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[l][r][k];<br>        <span class="hljs-comment">//查看相同的右端元素数量，简化计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> r, k1 = k;<br>        <span class="hljs-keyword">while</span> (r1 &gt; l &amp;&amp; boxes[r1 - <span class="hljs-number">1</span>] == boxes[r1]) &#123;<br>            r1--;<br>            k1++;<br>        &#125;<br>        <span class="hljs-comment">//先取最右侧元素</span><br>        dp[l][r][k] = calculatePoints(boxes, l, r1-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + (k1 + <span class="hljs-number">1</span>) * (k1 + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//取中间元素，让最右侧元素和前面相同的元素相遇</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt; r1; i++) &#123;<br>            <span class="hljs-keyword">if</span> (boxes[i] == boxes[r1]) &#123;<br>                dp[l][r][k] = Math.max(dp[l][r][k], calculatePoints(boxes, l, i, k1 + <span class="hljs-number">1</span>) + calculatePoints(boxes, i + <span class="hljs-number">1</span>, r1-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[l][r][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">1000. 合并石头的最低成本</a><br><code>dp[i][j]</code>表示把<code>[i,j]</code>区间尽可能的合并消耗的最低成本。</p><ul><li>j-i&lt;k-1时，成本为0</li><li>j-i&#x3D;k-1时，必须进行一次合并，出现一个唯一成本</li><li>j-i&gt;k-1时，必须尽可能地合并，出现一个最低成本并剩余若干元素（不超过k个）</li></ul><p>递推时：</p><ul><li>j-i&lt;k-1时不需要处理</li><li>j-i&#x3D;k-1时，进行合并</li><li>j-i&gt;k-1时，将区间分成两个部分，为了保证尽可能地合并，需要左侧或右侧至少有一侧发生了合并，即长度&gt;&#x3D;k。所以划分界线时，采取了左侧为一个堆，右侧尽可能合并地的策略。<ul><li>当左侧只有左端一个元素时，右侧必然发生了尽可能地合并，此时对应左侧元素最后才参与合并的情形。</li><li>当左侧有n*(k-1)+1个元素时，表示左侧提前参与了合并的情形。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//取不同分界点，左右分别合并，保证左边为1堆</span><br>dp[i][j] = min(dp[i][p] + dp[p + <span class="hljs-number">1</span>][j])<br><span class="hljs-comment">//如果左右</span><br>dp[i][j] += sum(i, j)<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;两个都多余元素的区间合并时，会自动将多余元素并入到最后一次大区间的分数计算中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeStones</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones, <span class="hljs-type">int</span> k)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;  <br>    <span class="hljs-comment">//每次合并消耗k-1个石头，最后剩1个石头  </span><br>    <span class="hljs-keyword">if</span>((n-<span class="hljs-number">1</span>)% (k-<span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 下面这个条件不行，因为k = 2时不成立：if (n % (k - 1) != 1) return -1;  </span><br>    <span class="hljs-comment">//指针左侧和  </span><br>    <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;  <br>        preSum[i] = preSum[i-<span class="hljs-number">1</span>] + stones[i-<span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-comment">//dp[i][j]表示区间[i,j]内元素尽可能合并的最小成本  </span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];  <br>    <span class="hljs-comment">//从k开始枚举长度，而不是从1  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> k;len&lt;=n;len++)&#123;  <br>        <span class="hljs-comment">//枚举区间起点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-len;i++)&#123;  <br>            <span class="hljs-comment">//区间终点  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+len-<span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">//初始化  </span><br>            dp[i][j] = Integer.MAX_VALUE;  <br>            <span class="hljs-comment">//分界点，步长为k-1，左边合并成1堆，右边尽可能的合并  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=i;p&lt;j;p += k-<span class="hljs-number">1</span>)&#123;  <br>                dp[i][j] = Math.min(dp[i][j],dp[i][p] + dp[p+<span class="hljs-number">1</span>][j]);  <br>            &#125;  <br>            <span class="hljs-comment">//如果左右两侧可以继续合并  </span><br>            <span class="hljs-keyword">if</span>((j-i)%(k-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) dp[i][j] += preSum[j+<span class="hljs-number">1</span>]-preSum[i];  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];  <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/encode-string-with-shortest-length/">471. 编码最短长度的字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[][] dp;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n][n];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; len &lt;= n; len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + len - <span class="hljs-number">1</span>;<br>                dp[i][j] = lc459(s, i, j);<br>                <span class="hljs-comment">//长度大于4时，考虑分割</span><br>                <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">4</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; j; k++)&#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> dp[i][k] + dp[k + <span class="hljs-number">1</span>][j];<br>                        <span class="hljs-keyword">if</span>(dp[i][j].length() &gt; split.length()) dp[i][j] = split;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 另 t = s + s, 从下标 1 的字符开始查找字符串s， 找到下标p，</span><br><span class="hljs-comment">     * 如果p != n, 存在连续重复的子字符串ps = s.substring(0, p), 个数为 n / p</span><br><span class="hljs-comment">     * 否则， 不存在连续重复子字符串， 无法进行编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">lc459</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        s = s.substring(i, j + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//长度不超过4时，不用考虑编码</span><br>        <span class="hljs-keyword">if</span>(s.length() &lt;= <span class="hljs-number">4</span>)  <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (s + s).indexOf(s, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(p != s.length())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> s.length() / p;<br>            <span class="hljs-keyword">return</span> cnt + <span class="hljs-string">&quot;[&quot;</span> + dp[i][i + p - <span class="hljs-number">1</span>] + <span class="hljs-string">&quot;]&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//否则， 无法进行编码</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/stone-game-vii/">1690. 石子游戏 VII</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stoneGameVII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-comment">//由于得分特殊计算方式，预处理前缀和,这里包括不包括对应索引数值，即preSum[1]不包括stone[1]</span><br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            preSum[i+<span class="hljs-number">1</span>] = preSum[i]+stones[i];<br>        &#125;<br>        <span class="hljs-comment">//取区间[i,j]可以得到的最大优势</span><br>        <span class="hljs-comment">//int[][] dp = new int[n][n];</span><br>        <span class="hljs-comment">//dp[i][j] = Math.max(value[i+1,j]-dp[i+1][j],value[i,j-1]-dp[i][j-1]),i-&gt;0,j-&gt;n</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 以下初始化是错误的，其建立在一个人拿一个石头可以得分，实际上一个人拿只能得0分</span><br>        <span class="hljs-comment">// for(int i=0;i&lt;n;i++)&#123;</span><br>        <span class="hljs-comment">//     dp[i] = stones[i];</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[j] = Math.max(preSum[j+<span class="hljs-number">1</span>]-preSum[i+<span class="hljs-number">1</span>]-dp[j],preSum[j]-preSum[i]-dp[j-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a><br>先将字符串处理成离散的元素，然后区间dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ADDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUBTRACTION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MULTIPLICATION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">diffWaysToCompute</span><span class="hljs-params">(String expression)</span> &#123;<br>    <span class="hljs-comment">//先将字符串处理成离散的元素。</span><br>        List&lt;Integer&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expression.length();) &#123;<br>            <span class="hljs-keyword">if</span> (!Character.isDigit(expression.charAt(i))) &#123;<br>                <span class="hljs-keyword">if</span> (expression.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    ops.add(ADDITION);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    ops.add(SUBTRACTION);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ops.add(MULTIPLICATION);<br>                &#125;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//对于数字，考虑其长度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; expression.length() &amp;&amp; Character.isDigit(expression.charAt(i))) &#123;<br>                    t = t * <span class="hljs-number">10</span> + expression.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                ops.add(t);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//初始化dp，dp[i][j]表示某区间下可能得到得所有值（可重复）。</span><br>        List&lt;Integer&gt;[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[ops.size()][ops.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ops.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; ops.size(); j++) &#123;<br>                dp[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//初始化所有区间大小为1得情况，即单独数字，所以这里i的步长为2，略过符号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ops.size(); i += <span class="hljs-number">2</span>) &#123;<br>            dp[i][i].add(ops.get(i));<br>        &#125;<br>        <span class="hljs-comment">//枚举总字符长度，必然为奇数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= ops.size(); i++) &#123;<br>        <span class="hljs-comment">//枚举开头字符的索引，必然为偶数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j + i &lt;= ops.size(); j += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> j + i - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//枚举中间的断开点，即符号点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; r; k += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">//获取符号左右可以得到的值的集合</span><br>                    List&lt;Integer&gt; left = dp[l][k - <span class="hljs-number">1</span>];<br>                    List&lt;Integer&gt; right = dp[k + <span class="hljs-number">1</span>][r];<br>                    <span class="hljs-comment">//批量处理，根据符号判断两数的运算方式</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num1 : left) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num2 : right) &#123;<br>                            <span class="hljs-keyword">if</span> (ops.get(k) == ADDITION) &#123;<br>                                dp[l][r].add(num1 + num2);<br>                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ops.get(k) == SUBTRACTION) &#123;<br>                                dp[l][r].add(num1 - num2);<br>                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ops.get(k) == MULTIPLICATION) &#123;<br>                                dp[l][r].add(num1 * num2);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后返回</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][ops.size() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="五、矩阵区域问题"><a href="#五、矩阵区域问题" class="headerlink" title="五、矩阵区域问题"></a>五、矩阵区域问题</h1><p>一般求矩阵和等情况，需要通过预处理，避免大量计算。<br><em>例题</em><br><a href="https://leetcode.cn/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵</a><br>暴力解：</p><ul><li>固定上边<ul><li>扩大下边，利用上一轮dp情况减少计算量。<ul><li>上下边中间的各列和都计算出来后，转化为求一维数组的最大数值。</li></ul></li></ul></li></ul><p><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值</a><br>与最大子矩阵类似，使用treeset记录前缀和数值，实现计算最大数值不超过K的逻辑。</p><p><a href="https://leetcode.cn/problems/matrix-block-sum/">1314. 矩阵区域和</a><br><code>pre[i][j]</code>表示坐标（i,j）左上角的区域和，这样，每个矩阵区域都可以由4个角的坐标来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixBlockSum(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                pre[i][j] = pre[i-<span class="hljs-number">1</span>][j]+pre[i][j-<span class="hljs-number">1</span>]-pre[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+mat[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point1i</span> <span class="hljs-operator">=</span> i-k&gt;=<span class="hljs-number">0</span>?i-k:<span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point1j</span> <span class="hljs-operator">=</span> j-k&gt;=<span class="hljs-number">0</span>?j-k:<span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point2i</span> <span class="hljs-operator">=</span> i+k+<span class="hljs-number">1</span>&lt;=m?i+k+<span class="hljs-number">1</span>:m;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point2j</span> <span class="hljs-operator">=</span> j+k+<span class="hljs-number">1</span>&lt;=n?j+k+<span class="hljs-number">1</span>:n;<br>                ans[i][j] = pre[point2i][point2j]+pre[point1i][point1j]-pre[point1i][point2j]-pre[point2i][point1j];<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、背包问题"><a href="#六、背包问题" class="headerlink" title="六、背包问题"></a>六、背包问题</h1><p><em>基本场景</em>：有<code>N</code>件物品，背包容量为<code>V</code>，每件物品消耗空间<code>c[i]</code>，价值<code>w[i]</code>。<br><em>基本问题</em>：可以得到的最大价值&#x2F;背包恰好装满时可以得到的最大价值<br><em>基本思路</em>：可以通过初始化的方式解决两种情况：</p><ul><li>最大价值可以将dp全部初始化为0</li><li>恰好装满可以将<code>dp[0]</code>初始化为0，其他初始化为-∞，表示不可达。</li></ul><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">CSDN</a></li><li><a href="https://zhuanlan.zhihu.com/p/139368825">知乎</a></li></ul></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><em>限定条件</em>：每件物品只有一件。<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225231137.png"><br>优化</p><ul><li>空间复杂度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> V; j &gt;= <span class="hljs-number">0</span>; j--)<br>        f[j] = max(f[j], f[j - c[i]] + w[i]);<br></code></pre></td></tr></table></figure></li><li>常数空间：<ul><li>j循环的最小边界可以限定在<code>max(c[i]，V-sum&#123;c[i+1]+c[i+2]+...+c[n]&#125;)</code>：前面是因为只有<code>j&gt;=c[i]</code>时才可以放置物品<code>i</code>;后面是因为如果此时<code>V</code>在放入i后面所有物品后仍能大于<code>c[i]</code>，说明当背包空间为V时，i及后面的物品可以全部放进背包，没有必要再枚举更小的背包空间了查看i物品是否应该放入了。</li></ul></li></ul><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><em>限定条件</em>：每件物品有无数个。<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225232603.png"><br>优化</p><ul><li>逻辑：可以直接忽略费用高但价值低的物品。</li><li>简化：转化为01背包问题，但每次递推时是建立在当前物品可能已经被选择过的情形。</li><li>空间复杂度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> c[i]; j &lt;= V; j++)<br>        f[j] = max(f[j], f[j - c[i]] + w[i]);<br></code></pre></td></tr></table></figure></li></ul><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><em>限定条件</em>：每件物品有若干个。<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225232946.png"><br>优化</p><ul><li>简化：<ul><li>转化为01背包问题。</li><li>拆分，将物品拆分为1，2，4份原物品的数量。</li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//物品</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-comment">//空间</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> V; j &gt;= c[i]; j--)<br><span class="hljs-comment">//数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= p[i] and k * c[i] &lt;= j; k++)<br>f[j] = max(f[j], f[j - c[i] * k] + w[i] * k);<br></code></pre></td></tr></table></figure><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p><em>限定条件</em>：物品数有多种情况<br>结合01背包和完全背包，分别逆序，顺序，指定循环次数</p><h3 id="二维费用"><a href="#二维费用" class="headerlink" title="二维费用"></a>二维费用</h3><p><em>限定条件</em>：每个物品有两个纬度的cost<br>多建立一个费用纬度矩阵即可，其他类似。</p><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><em>限定条件</em>：物品分组，每组只能取一个<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225233434.png"></p><h3 id="依赖背包"><a href="#依赖背包" class="headerlink" title="依赖背包"></a>依赖背包</h3><p><em>限定条件</em>：某个物品依赖于某个主物品<br>等效于将物品按主物品分多个组，每个组内不同的搭配策略为一种物品。</p><h3 id="泛化物品"><a href="#泛化物品" class="headerlink" title="泛化物品"></a>泛化物品</h3><p><em>限定条件</em>：物品的价值取决于消耗</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a><br>分析：完全背包问题，恰好装满背包，求最小花费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//完全背包问题经典解法（完全背包）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-comment">//硬币种类（物品种类）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br><span class="hljs-comment">//选择到第n个物品，容量为amount时最少硬币数。</span><br><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][amount+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//初始化，恰好装满背包的问题</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>Arrays.fill(dp[i],Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//外循环物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//物品cost</span><br><span class="hljs-type">int</span> <span class="hljs-variable">coin</span> <span class="hljs-operator">=</span> coins[i-<span class="hljs-number">1</span>];<br><span class="hljs-comment">//内循环容量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=amount;j++)&#123;<br><span class="hljs-comment">//这里二维数组的定义是，选择完i时（无论有没有选择i物品），背包容量为j时的最小花费。所以即便这里出现j&lt;coin时无法选择i物品的情况，也需要对所有容量j进行赋值，便于下一轮的计算，所以j从1开始遍历</span><br>dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">if</span>(j&gt;=coin)&#123;<br>dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-coin]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> dp[n][amount] == Integer.MAX_VALUE/<span class="hljs-number">2</span>?-<span class="hljs-number">1</span>:dp[n][amount];<br>&#125;<br><br><span class="hljs-comment">//压缩空间，省略物品纬度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-comment">//硬币种类（物品种类）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br><span class="hljs-comment">//容量为amount时最少硬币数。</span><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//初始化，恰好装满背包的问题</span><br>Arrays.fill(dp,Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//开始取物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//物品cost</span><br><span class="hljs-type">int</span> <span class="hljs-variable">coin</span> <span class="hljs-operator">=</span> coins[i-<span class="hljs-number">1</span>];<br><span class="hljs-comment">//枚举背包大小，只更新可能取到coin的情况</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=coin;j&lt;=amount;j++)&#123;<br>dp[j] = Math.min(dp[j],dp[j-coin]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE/<span class="hljs-number">2</span>?-<span class="hljs-number">1</span>:dp[amount];<br>&#125;<br><br><span class="hljs-comment">//切换循环顺序</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//初始化，默认不可达</span><br>Arrays.fill(dp,Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//外循环背包容量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=amount;i++)&#123;<br><span class="hljs-comment">//内循环最后一次添加的硬币</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;coins.length;j++)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">coin</span> <span class="hljs-operator">=</span> coins[j];<br><span class="hljs-keyword">if</span>(i-coin&gt;=<span class="hljs-number">0</span> &amp;&amp; dp[i-coin] != Integer.MAX_VALUE/<span class="hljs-number">2</span>)&#123;<br>dp[i] = Math.min(dp[i],dp[i-coin]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dp[amount] == Integer.MAX_VALUE/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <ol><li>可以发现使用二维数组时，即使容量无法装下当前物品，也要完成状态转移。</li><li>内外循环的先后可以互换：外循环容量（降序），内循环物品（升序）。</li><li><strong>为何往往先循环物品，后循环容量：对于01背包或多重背包，物品的数量是有限的，先循环物品便于后续选择新物品时不需要担心数量问题。</strong></li><li>当化简递推公式为一维时：<ul><li><strong>对于01、多重背包问题，只能外循环物品、内循环容量。因为外循环物品时，选择一个新物品时不会收到旧物品的数量限制。</strong></li><li>对于完全背包问题，可以只考虑在一个容量下背包的最大&#x2F;装满时最小价值。所以外循环容量时，可以放心的使用之前得到的背包在某容量下的状态。即<strong>完全背包问题可以外循环容量。</strong></li></ul></li><li>由于本题是恰好问题，因此也可以使用DFS处理，本质上dp和dfs不过是自底向上和自顶向下的区别。</li></ol>          </div><p><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a><br>一般而言，可以调整背包大小循环和物品循环的顺序，但对于需要对方案去重的情况，使用物品外循环，背包内循环更好解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=coins[i];j&lt;=amount;j++)&#123;<br>                dp[j] += dp[j-coins[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a><br>问题转化：</p><ul><li>两个石头a,b相互抵消，从数字上的体现是a-b&#x3D;c，即得到c石头</li><li>最后剩下的石头 ans &#x3D; Σ(±)a，有一个隐含条件是必须大石头减小石头（可以两个小石头加起来减大石头，因为可以先用一个石头取消耗大石头使其变小），而最后ans必须为正。</li><li>问题变成将原石头分成两份，小的那部分尽可能与大的那部分相等，即尽可能接近sum&#x2F;2：至此，问题转化为了在石头中的01背包问题，背包大小为sum&#x2F;2，要尽可能的装更多块的石头，石头的价值和消耗都为本身大小。</li></ul><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a><br>问题转化：<br>无限背包问题，求恰好达到某利润的方案数：</p><ul><li>外循环容量并压缩维度。</li></ul><p><a href="https://leetcode.cn/problems/profitable-schemes/">879. 盈利计划</a><br>问题转化：<br>01背包问题，求超过某利润的方案数：</p><ul><li>外循环物品，内循环容量（一般可以压缩到只有容量维度，维护最大利润，且容量要倒序遍历）</li><li>与恰好问题不同，这里要求超过利润，且求的是方案数，因此需要各个容量情况下至少达到某利润的方案数，增加了一个维度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>    <span class="hljs-comment">//表示使用了n个容量时，至少达到minProfit的方案数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][minProfit + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> group.length, MOD = (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">members</span> <span class="hljs-operator">=</span> group[i - <span class="hljs-number">1</span>], earn = profit[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= members; j--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> minProfit; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    dp[j][k] = (dp[j][k] + dp[j - members][Math.max(<span class="hljs-number">0</span>, k - earn)]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][minProfit];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shopping-offers/">638. 大礼包</a><br>每件物品&#x2F;套餐的价格和数量都是已知的，剩下的就只需要遍历容量了，这里采用了记忆化+dfs的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    List&lt;Integer&gt; price;<br>    List&lt;List&lt;Integer&gt;&gt; special;<br>    HashMap&lt;List&lt;Integer&gt;,Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shoppingOffers</span><span class="hljs-params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> &#123;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">this</span>.n = price.size();<br>        <span class="hljs-built_in">this</span>.price = price;<br>        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.special = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-comment">//先处理掉不需要的礼包</span><br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; spe:special)&#123;<br>            <span class="hljs-comment">//m = 礼包的物品种类+1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> spe.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">spePrice</span> <span class="hljs-operator">=</span> spe.get(m-<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//计算单价总和</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">singlePrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m-<span class="hljs-number">1</span>;i++)&#123;<br>                singlePrice += spe.get(i)*price.get(i);<br>            &#125;<br>            <span class="hljs-comment">//不需要该礼包</span><br>            <span class="hljs-keyword">if</span>(singlePrice&lt;spePrice)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">this</span>.special.add(spe);<br>        &#125;<br>        <span class="hljs-comment">//无限背包问题，背包容量的维度为物品的种类，need为容量，由于维度较高，故不采用dp数组维护状态，而是通过HashMap做记忆，并使用dfs。</span><br>        <span class="hljs-keyword">return</span> dfs(needs);<br>    &#125;<br>    <span class="hljs-comment">//当前还需要的物品数量，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; needs)</span>&#123;<br>        <span class="hljs-keyword">if</span>(map.get(needs) != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> map.get(needs);<br>        <span class="hljs-keyword">if</span>(needs.stream().mapToInt(Integer::valueOf).sum() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//统计需要的最少价格(单价购买)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            minPrice += needs.get(i)*price.get(i);<br>        &#125;<br>        <span class="hljs-comment">//枚举套餐</span><br>        a:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;special.size();i++)&#123;<br>            List&lt;Integer&gt; spe = special.get(i);<br>            List&lt;Integer&gt; nextNeed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">//枚举套餐内物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//如果无法装下，进入下一轮</span><br>                <span class="hljs-keyword">if</span>(needs.get(j)&lt;spe.get(j)) <span class="hljs-keyword">continue</span> a;<br>                nextNeed.add(needs.get(j)-spe.get(j));<br>            &#125;<br>            minPrice = Math.min(minPrice,dfs(nextNeed)+spe.get(n));<br>        &#125;<br>        map.put(needs,minPrice);<br>        <span class="hljs-keyword">return</span> minPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/closest-dessert-cost/">1774. 最接近目标价格的甜点成本</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[] baseCosts, <span class="hljs-type">int</span>[] toppingCosts, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 快速判断，如果最小的基料都比target大，直接返回该基料即可</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Arrays.stream(baseCosts).min().getAsInt();<br>        <span class="hljs-keyword">if</span> (x &gt;= target) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-comment">// can[index] = true表示辅料可以得到index的价格</span><br>        <span class="hljs-comment">// 这里将辅料的上线定义为target，此处不考虑大于target的情况（大于target的情况单独考虑）</span><br>        <span class="hljs-type">boolean</span>[] can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[target + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 超过target的方案只需要保留最小的方案，其应该小于 target + (target-x)，否则就应该直接选择x。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * target - x;<br>        <span class="hljs-comment">// 使用基料初始化dp数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : baseCosts) &#123;<br>            <span class="hljs-keyword">if</span> (b &lt;= target) &#123;<br>                can[b] = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = Math.min(res, b);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 遍历辅料</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t : toppingCosts) &#123;<br>            <span class="hljs-comment">// 遍历数量，与遍历辅料一起，相当于遍历01背包的所有物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">2</span>; ++count) &#123;<br>                <span class="hljs-comment">// 遍历背包大小</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> target; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>                    <span class="hljs-comment">// 下面两点顺序很重要，先要在没有添加该物品时考察i背包的dp值，然后再判断该物品是否可以更新到i背包的dp值</span><br>                    <span class="hljs-comment">// 1.如果i情况存在且其添加该物品后 大于target</span><br>                    <span class="hljs-comment">// 利用res更新超过target的最小方案情况</span><br>                    <span class="hljs-keyword">if</span> (can[i] &amp;&amp; i + t &gt; target) &#123;<br>                        res = Math.min(res, i + t);<br>                    &#125;<br>                    <span class="hljs-comment">// 2.如果i可以通过添加物品得到，更新该情况</span><br>                    <span class="hljs-keyword">if</span> (i - t &gt; <span class="hljs-number">0</span>) &#123;<br>                        can[i] = can[i] | can[i - t];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= res - target; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (can[target - i]) &#123;<br>                <span class="hljs-keyword">return</span> target - i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七、状态压缩dp"><a href="#七、状态压缩dp" class="headerlink" title="七、状态压缩dp"></a>七、状态压缩dp</h1><p>遇到需要准确维护已选择&#x2F;已经过（待选择&#x2F;待经过）等状态时，使用状态压缩dp。<br>常用技巧：</p><ul><li><p>元素操作</p><ul><li>c 插入 A ：<code>A |= (1 &lt;&lt; c)</code></li><li>A 删除 c ：<code>A &amp;= ~(1 &lt;&lt; c)</code>或<code>A ^= (1&lt;&lt;c)</code></li></ul></li><li><p>集合间操作</p><ul><li>A 置空 ：<code>A = 0</code></li><li>AB并集 ：<code>A | B</code></li><li>AB交集 ：<code>A &amp; B</code></li><li>AB子集?：<code>(A &amp; B) == B</code></li></ul></li><li><p>集合自身操作</p><ul><li>全集 ：<code>(1 &lt;&lt; n) - 1</code></li><li>补集 ：<code>((1 &lt;&lt; n) - 1) ^ A</code></li><li>子集 ：<code>(A &amp; B) == B</code></li></ul></li><li><p>枚举A的子集，假设A为set，每轮循环可以得到一个set的子集（本质是遍历所有情况，但通过<strong>与全集做&amp;运算</strong>跳过非子集的枚举，加速遍历）：<br>  <code>for(int s = set;s != 0;s=(s-1)&amp;set)</code></p></li><li><p>补集，s2为set相对s的补集<br>  <code>s2 = s^set</code></p></li><li><p>其他操作</p><ul><li>是否为2的幂：<code>A&amp;(A-1) == 0</code></li><li>将A最低位1置0：&#96;A &#x3D; A&amp;(A-1)&#96;&#96;</li><li>求A最低位1：&#96;A &#x3D; A&amp;(-A)&#96;&#96;，这种操作也叫做lowbit</li><li>求A最高位1：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> lowbit(A)<br><span class="hljs-keyword">while</span>(p != A)<br>&#123;<br>    A -= p;<br>    p = lowbit(A);<br>&#125;<br><span class="hljs-keyword">return</span> p;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><a href="https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. 每个元音包含偶数次的最长子字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">switch</span>(c)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(status == <span class="hljs-number">0</span>)&#123;<br>                ans = Math.max(ans,i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(dp[status] == <span class="hljs-number">0</span>)&#123;<br>                    dp[status] = i;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans = Math.max(ans,i-dp[status]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/can-i-win/">464. 我能赢吗</a><br>当前已经选择了的数字就是dp的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    Boolean[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> maxChoosableInteger, <span class="hljs-type">int</span> desiredTotal)</span> &#123;<br>        n = maxChoosableInteger;<br>        <span class="hljs-comment">//提前判断无法到达的情况</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span> &lt; desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[<span class="hljs-number">1</span>&lt;&lt;n];<br>        <span class="hljs-keyword">return</span> canWin(<span class="hljs-number">0</span>,desiredTotal);<br>    &#125;<br><span class="hljs-comment">//state情况下，还需要need个数才能赢</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWin</span><span class="hljs-params">(<span class="hljs-type">int</span> state,<span class="hljs-type">int</span> need)</span>&#123;<br>    <span class="hljs-comment">//记忆化返回</span><br>        <span class="hljs-keyword">if</span>(dp[state] != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> dp[state];<br>        <span class="hljs-comment">//从大到小枚举数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//如果某数字还没被选择过</span><br>            <span class="hljs-keyword">if</span>((state &amp; (<span class="hljs-number">1</span>&lt;&lt;i)) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//检查选择该数字后能否直接胜利</span><br>                <span class="hljs-keyword">if</span>(need&lt;=i+<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">//检查选择该数字后能否间接胜利</span><br>                <span class="hljs-keyword">if</span>(!canWin(state|(<span class="hljs-number">1</span>&lt;&lt;i),need-i-<span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//无论选择什么数字都无法胜利时，返回失败</span><br>        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>状态压缩dp本质上就是将状态以bitmap的形式存储的一种手段。<br>这类题常常可以结合记忆化搜索，回溯算法，dfs来解决；</p>          </div><p><a href="https://leetcode.cn/problems/android-unlock-patterns/">351. 安卓系统手势解锁</a><br>需要写一个函数来根据（last,state,next）判断是否是可连接状态。</p><ol><li>使用回溯算法+dfs时，只需要维护一个全局状态<code>boolean[]</code>，dfs的参数为need(即还需要连接多少个元素)，last(上一个连接的元素)，对n-&gt;m都要做一次回溯。</li><li>使用循环做dp时，最后将n-&gt;m的加起来。</li></ol><p><a href="https://leetcode.cn/problems/unique-paths-iii/">980. 不同路径 III</a><br>首先扫描grid，寻找起点和终点，统计需要走的路径数量。</p><ol><li>从起点开始回溯+记忆化搜索+dfs，回溯需要将已经走过的路径标记为3，回溯时标记回0。</li><li>二维状态也可以压缩为一维，此时将所有起点、路径、终点标记为待遍历的点，此时不需要维护全局变量，且可以判断路径是否可走。</li></ol><p><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a><br>状态为当前已经选择的数字，当状态确定时，当前已经得到的组数和当前组已经有的数字数量都可以被确定下来。</p><ol><li>可以先将数组排序，当目前无论选择什么数组都会超出组容量时，快速失败。</li><li>可以使用记忆化，记录state的结果</li><li>不需要维护当前组数，因为可以通过最后所有数字都被获取，即(state &#x3D;&#x3D; (1&lt;&lt;n)-1)来判断到达终点，在这种情况下应该保证每次迭代是合法的，即1中提到的快速失败。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> per, n;<br>    <span class="hljs-type">boolean</span>[] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">all</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (all % k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        per = all / k;<br>        Arrays.sort(nums);<br>        n = nums.length;<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &gt; per) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span> &lt;&lt; n];<br>        Arrays.fill(dp, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> dfs((<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dp[s]) &#123;<br>            <span class="hljs-keyword">return</span> dp[s];<br>        &#125;<br>        dp[s] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + p &gt; per) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(s ^ (<span class="hljs-number">1</span> &lt;&lt; i), (p + nums[i]) % per)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a><br>最短的遍历问题，记得使用广度优先解决，同时使用数组记录防止重复入列带来的消耗，也避免无限循环的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//状态为已经遍历过的节点和当前节点，两个维度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-keyword">if</span>(graph.length == <span class="hljs-number">0</span> || graph[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-comment">//表示某个状态时，达到了某个节点的情况是否被遍历过，避免重复</span><br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>&lt;&lt;n][n];<br>        <span class="hljs-comment">//因为是寻找最短路径，所以使用了队列，发现走的通的路径时直接返回</span><br>        <span class="hljs-comment">//queue中元素维护了节点状态和当前节点</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>&lt;&lt;i,i&#125;);<br>            visited[<span class="hljs-number">1</span>&lt;&lt;i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size();<br>            <span class="hljs-comment">//level表示路径上已经有level个节点，再加一个节点时，路径长度为level</span><br>            level++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-comment">//取出状态</span><br>                <span class="hljs-type">int</span>[] temp = deque.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//遍历节点的临近节点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;graph[last].length;j++)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> graph[last][j];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nextState</span> <span class="hljs-operator">=</span> state|(<span class="hljs-number">1</span>&lt;&lt;next);<br>                    <span class="hljs-keyword">if</span>(nextState == ((<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> level;<br>                    <span class="hljs-comment">//如果临近节点和状态已经被遍历过，则继续；</span><br>                    <span class="hljs-keyword">if</span>(visited[nextState][next] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">//否则，添加该情况</span><br>                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextState,next&#125;);<br>                    visited[nextState][next] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-shortest-superstring/">943. 最短超级串</a><br>分析：</p><ul><li>因为题目保证了不会有一个字符串是另一个字符串的子字符串，所以两个字符串拼接时，长度一定大于原字符串（即两个字符串肯定时交叉关系）。</li><li>可以利用一个函数求出每对字符串s1,s2，拼接后得到的字符串，注意下面API：</li></ul><blockquote><p>API：string1.endWith(string2)，可以看string1是否以string2为结尾。</p></blockquote><ul><li>对于拼接中的字符串，状态只取决于，之前已经选择过了的单词和最后一个选择的单词，这是一个二维数组。</li><li>使用两个二维数组同时维护，某状态下的长度和字符串，因为最后需要返回string。</li></ul><p><a href="https://leetcode.cn/problems/beautiful-arrangement/">526. 优美的排列</a><br>模拟填充过程，从所有数字中选择若干数，一个个放入对应位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countArrangement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>&lt;&lt;n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//枚举状态i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;<br>            <span class="hljs-comment">//枚举最后一个字母j</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-comment">//如果状态i下最后一个字母可以为j</span><br>                <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;(j-<span class="hljs-number">1</span>))) != <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//最后一个字母的索引</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Integer.bitCount(i);<br>                    <span class="hljs-keyword">if</span>(can(index,j))&#123;<br>                        dp[i] += dp[i^(<span class="hljs-number">1</span>&lt;&lt;(j-<span class="hljs-number">1</span>))];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//can函数表示数字j可以放置在坐标i上。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">can</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i%j == <span class="hljs-number">0</span> || j%i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>遇到这种题，多思考状态的转化，随意拿出一个状态，通过枚举其最后一个结尾数即可往前推。</p>          </div><blockquote><p>Integer.bitCount(i); &#x2F;&#x2F;计算i中比特1的数量</p></blockquote><p><a href="https://leetcode.cn/problems/maximum-students-taking-exam/">1349. 参加考试的最大学生数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxStudents</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] seats)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> seats.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> seats[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">//处理禁止坐的地方</span><br>        <span class="hljs-type">int</span>[] bans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ban</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(seats[i-<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                    ban |= (<span class="hljs-number">1</span>&lt;&lt;j);<br>                &#125;<br>            &#125;<br>            bans[i] = ban;<br>        &#125;<br>        <span class="hljs-comment">//第m排，且最后一排状况为n时的情形数量</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>&lt;&lt;n];<br>        <span class="hljs-comment">//从第一排开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-comment">//遍历本排所有的情形</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)&#123;<br>                <span class="hljs-comment">//如果j本身合法</span><br>                <span class="hljs-keyword">if</span>((j&amp;(j&lt;&lt;<span class="hljs-number">1</span>)) ==<span class="hljs-number">0</span> &amp;&amp; (bans[i]&amp;j) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//遍历上一排的情形</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;n);k++)&#123;<br>                        <span class="hljs-comment">//如果k上一排满足</span><br>                        <span class="hljs-keyword">if</span>(((k&amp;(j&lt;&lt;<span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) &amp;&amp; ((k&amp;(j&gt;&gt;<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>))&#123;<br>                            dp[i][j] = Math.max(dp[i][j],dp[i-<span class="hljs-number">1</span>][k]+Integer.bitCount(j));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp[m]).max().getAsInt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/prison-cells-after-n-days/">957. N 天后的牢房</a><br>注意左右移动位运算时，考虑左端和右端牢房始终不会被占用，因此需要使用掩码。<br>本题使用了两个map记录循环中状态和索引的对应关系，也可以只记录状态对应的索引，遇到循环后压缩循环直接到最后一次循环即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] prisonAfterNDays(<span class="hljs-type">int</span>[] cells, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">//掩码,异或相当于减去</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> ((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>)-<span class="hljs-number">1</span>)^<span class="hljs-number">1</span>^(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<br>        <span class="hljs-comment">//记忆，《状态，索引》，《索引，状态》</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer,Integer&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cells.length;<br>        <span class="hljs-comment">//初始化状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(cells[i] == <span class="hljs-number">1</span>)&#123;<br>                state |= <span class="hljs-number">1</span>&lt;&lt;i;<br>            &#125;<br>        &#125;<br>        map.put(state,<span class="hljs-number">0</span>);<br>        map2.put(<span class="hljs-number">0</span>,state);<br>        <span class="hljs-comment">//循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            state = (~((state&lt;&lt;<span class="hljs-number">1</span>) ^ (state&gt;&gt;<span class="hljs-number">1</span>))&amp;mask);<br>            <span class="hljs-keyword">if</span>(map.containsKey(state))&#123;<br>                <span class="hljs-comment">//循环日</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> map.get(state);<br>                <span class="hljs-comment">//循环周期</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> i-j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> (n-i)%circle+j;<br>                state = map2.get(next);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            map.put(state,i);<br>            map2.put(i,state);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>            ans[i] = (state&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Integer.toBinaryString(); 将int打印成二进制</p></blockquote><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a><br>一开始打算贪心并使用二分查找的方法，找到刚好可以分给k个孩子的不公平程度。但是孩子们的饼干分配方案是无法贪心的，无法求解。<br>考虑子问题：<br>所有零食中，已经有i个孩子分到了零食s集合，则第i个孩子一定分到的是s集合的子集s1，则前（i-1）个孩子的状态为s2（s-s1)。定义<code>dp[i][s]</code>为i个孩子拿到状态s的最小不公平程度：<br><code>dp[i][s] = Math.min(dp[i-1][s-s1],sum(s1))</code><br>i这个维度可以省略，此时s应该从大到小遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCookies</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cookies.length;<br>        <span class="hljs-comment">//初始化sum数组，所有选取状态下饼干的数量之和</span><br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[(<span class="hljs-number">1</span>&lt;&lt;n)];<br>        <span class="hljs-comment">//为单一零食包赋值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum[<span class="hljs-number">1</span>&lt;&lt;i] = cookies[i];<br>        &#125;<br>        <span class="hljs-comment">//枚举所有状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;<br>            sum[i] = sum[i&amp;(i-<span class="hljs-number">1</span>)] + sum[i&amp;(-i)];<br>        &#125;<br><br>        <span class="hljs-comment">//初始化，只有一个孩子时的不公平程度</span><br>        <span class="hljs-type">int</span>[] dp = sum.clone();<br>        <span class="hljs-comment">//从2开始枚举孩子数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;i++)&#123;<br>            <span class="hljs-comment">//枚举零食包状态</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>;s&gt;<span class="hljs-number">0</span>;s--)&#123;<br>                <span class="hljs-comment">//枚举第i个孩子获得的零食集合s1，相当于求s所有子集</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> s;s1&gt;<span class="hljs-number">0</span>;s1=(s1-<span class="hljs-number">1</span>)&amp;s)&#123;<br>                    dp[s] = Math.min(dp[s],Math.max(dp[s^s1],sum[s1]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/divide-chocolate/">1231. 分享巧克力</a><br>相比上一题，这题则可以贪心，因为巧克力是连续的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeSweetness</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sweetness, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(sweetness).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left+right+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//如果可以分成K+1块以上</span><br>            <span class="hljs-keyword">if</span>(divide(sweetness,mid,k+<span class="hljs-number">1</span>))&#123;<br>                left = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果无法分成k块，则需要降低临界值</span><br>                right = mid-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sweetness,<span class="hljs-type">int</span> maxSweet,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">piece</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sweetness.length;i++)&#123;<br>            sum += sweetness[i];<br>            <span class="hljs-keyword">if</span>(sum&gt;=maxSweet)&#123;<br>                piece++;<br>                sum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> piece&gt;=k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></p><ol><li>dfs，记录当前状态，枚举下一个可选择的火柴，并携带当前边已经有的长度便于计算。</li><li>dp，从1开始枚举状态，每个状态都可以由上一个状态转移，dp则记录当前行长度，最后监测<code>dp[(1&lt;&lt;n)-1]</code>是否为0。</li></ol><h1 id="八、计数dp"><a href="#八、计数dp" class="headerlink" title="八、计数dp"></a>八、计数dp</h1><p>计数dp一般维度不是很高，外循环到题目条件上限即可，难点在于找到递推方程。</p><p><a href="https://leetcode.cn/problems/handshakes-that-dont-cross/">1259. 不相交的握手</a><br>第一个人枚举与其握手的人，将人群切割成两部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> numPeople)</span> &#123;<br>        <span class="hljs-comment">//canChoose</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> numPeople/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[pair+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//0对时，有1种情况</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//1对时，有1种情况</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//开始枚举2对</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=pair;i++)&#123;<br>            <span class="hljs-comment">//第一个节点与其他节点连线包括了2*j个节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                <span class="hljs-comment">//一侧为2*(j-1)个节点，另一侧为2*(i-j)个节点</span><br>                dp[i] = (dp[i] + (dp[j-<span class="hljs-number">1</span>]*dp[i-j])%MOD)%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[pair];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sentence-screen-fitting/">418. 屏幕可显示句子的数量</a></p><ul><li>技巧1：可以假设每个单词长度延申一个空格，列数也加1来容纳多出来的空格。</li><li>技巧2：每行的开头必然是一个单词，通过统计（预处理）以每个单词开头时，本行可以得到的句子数（可能为0），以及下一行开始的单词的索引。最后统计行为rows时可以得到答案。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wordsTyping</span><span class="hljs-params">(String[] sentence, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> &#123;<br>        <span class="hljs-comment">//单词数量为n</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sentence.length;<br>        <span class="hljs-comment">//每个单词占用len[i]个字符,预处理，每个单词可能占用的字符数(包括了空格键);</span><br>        <span class="hljs-type">int</span>[] len = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            len[i] = sentence[i].length() + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//以next[i]作为状态，同时记录下一个单词的索引和该行的句子数量。</span><br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//枚举单词</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">//index为当前单词,cur为当前列索引，假设每行都有col+1列，cnt为当前行结束的句子数量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i, cur = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//再加一个Index时没有达到末尾：</span><br>            <span class="hljs-keyword">while</span>((cur + len[index])&lt;=cols+<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//可以加上index单词</span><br>                cur += len[index];<br>                <span class="hljs-comment">//如果没有到达句子末尾</span><br>                <span class="hljs-keyword">if</span>(index == n-<span class="hljs-number">1</span>)&#123;<br>                    index = <span class="hljs-number">0</span>;<br>                    cnt++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    index++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//记录该单词开头时该行的状态</span><br>            next[i] = cnt * <span class="hljs-number">100</span> + index;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)&#123;<br>            ans += next[index]/<span class="hljs-number">100</span>;<br>            index = next[index]%<span class="hljs-number">100</span>;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="九、数位dp"><a href="#九、数位dp" class="headerlink" title="九、数位dp"></a>九、数位dp</h1><p>数位dp一般都是求在1~n之间求满足要求的数的个数。<br>我们可以从最高位开始考虑，每位可选择哪些数，以及该选择可能会给后面的选择带来的影响。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><em>灵神模板</em><br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230227154845.png"><br>一般需要记忆化可能会重复使用的情况，而上界情况则不需要记忆，因为只出现一次。因此在判断是否直接利用记忆返回时也需要先判断这一点。<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230227154815.png"></p><div class="note note-primary">            <p>该模只遍历<code>[1,n]</code>，对于0和n的边界条件需要额外考虑，下面是经典例题。</p>          </div><p><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        s = Integer.toString(n).toCharArray();<br>        len = s.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            Arrays.fill(dp[i],-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == len) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] &gt;=<span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> dp[i][mask];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isNum) res += dfs(i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=isNum?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,up=isLimit?s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;j&lt;=up;j++)&#123;<br>            <span class="hljs-keyword">if</span>(((mask&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                res += dfs(i+<span class="hljs-number">1</span>,mask|(<span class="hljs-number">1</span>&lt;&lt;j),isLimit&amp;&amp;(s[i]-<span class="hljs-string">&#x27;0&#x27;</span> == j),<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum)&#123;<br>            dp[i][mask] = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[] s;<br>    String[] digits;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostNGivenDigitSet</span><span class="hljs-params">(String[] digits, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//s为target的字符串</span><br>        s = Integer.toString(n).toCharArray();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length];<br>        <span class="hljs-comment">//dp预填充</span><br>        Arrays.fill(dp,-<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.digits = digits;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == s.length) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//只记忆非limit和以及有数字的情况</span><br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果之前没有填入，本处也可以不填入数字</span><br>        <span class="hljs-keyword">if</span>(!isNum) ans = dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//枚举数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;digits.length;j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> digits[j].charAt(<span class="hljs-number">0</span>)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-comment">//如果受限制且超过上界，直接返回</span><br>            <span class="hljs-keyword">if</span>(isLimit &amp;&amp; (cur&gt;s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-keyword">break</span>;<br>            ans += dfs(i+<span class="hljs-number">1</span>,isLimit&amp;&amp;(cur== s[i]-<span class="hljs-string">&#x27;0&#x27;</span>),<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//只记忆非limit和以及有数字的情况</span><br>        <span class="hljs-keyword">if</span>(isNum &amp;&amp; !isLimit) dp[i] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a><br>可以使用数学的方法写，这里不做介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumbersWithUniqueDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//0,1特殊处理，因为n=1时，10是可以取到数字，但答案不允许数字等于上界。</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            up *= <span class="hljs-number">10</span>;<br>        &#125;<br>        s = Integer.toString(up).toCharArray();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)&#123;<br>            Arrays.fill(dp[i],-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//加上0</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == s.length) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] &gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i][mask];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isNum) res += dfs(i+<span class="hljs-number">1</span>,mask,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=isNum?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,up=isLimit?s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;j&lt;=up;j++)&#123;<br>            <span class="hljs-keyword">if</span>((mask&gt;&gt;j&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                res += dfs(i+<span class="hljs-number">1</span>,(mask|(<span class="hljs-number">1</span>&lt;&lt;j)),isLimit&amp;&amp;(j==s[i]-<span class="hljs-string">&#x27;0&#x27;</span>),<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum) dp[i][mask] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></p><div class="note note-primary">            <p><code>dp[i]</code>定义为前i个二进制位，所能产生的合法数字的个数。不出现连续的“1”就是合法数字。<br>发现有：<code>dp[n] = dp[n-1]+dp[n-2]</code><br>即：f(xxxx) &#x3D; f(0xxx) + f(10xx) &#x3D;&gt; dp(4)&#x3D;dp(3)+dp(2)</p><p>对于小于n的情形，可以拆解n：<br><code>f(10100) = f(0xxxx) + f(100xx) = dp(4) + dp(2)</code><br>对于连续1情形，处理完该批次即可直接返回：<br><code>f(11010) = f(0xxxx) + f(10xxx) = f(11000)</code>，最后面的1在处理第二个1时已经完全考虑。</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-comment">//预处理dp数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">numStr</span> <span class="hljs-operator">=</span> getBinary(num);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历num各个位置，若为0则继续</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numStr.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (numStr.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//为1则统计</span><br>            res += dp[numStr.length() - i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; numStr.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">//最后加0</span><br>        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将非负整数转为二进制字符串</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getBinary</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            sb.insert(<span class="hljs-number">0</span>, num &amp; <span class="hljs-number">1</span>);<br>            num &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/confusing-number-ii/">1088. 易混淆数 II</a><br>本题其实不是数位dp，但这种遍历并逐步添加数字的方式可以学习一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//原始字符</span><br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-comment">//翻转后字符</span><br>    <span class="hljs-type">int</span>[] revs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-comment">//上限n</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">//答案</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">confusingNumberII</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        n = m;<br>        <span class="hljs-comment">//遍历字符</span><br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-comment">//curr表示当前枚举数字和其反转对应的数字，digit表示数字长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> curr, <span class="hljs-type">int</span> rev, <span class="hljs-type">int</span> digit)</span> &#123;<br>        <span class="hljs-comment">// 当前枚举的数字&gt;n结束</span><br>        <span class="hljs-keyword">if</span> (curr &gt; n) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果是易混淆数，答案+1;</span><br>        <span class="hljs-keyword">if</span>(curr != rev) &#123;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-comment">// 枚举下一个要加上的数 比如9 假设当前curr是16</span><br>        <span class="hljs-comment">// curr     16  </span><br>        <span class="hljs-comment">// nextCurr 16*10 + 9         =169</span><br>        <span class="hljs-comment">// nextRev  9*100 + rev(61)   =961</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5</span>; k++) &#123;<br>            <span class="hljs-comment">//如果当前没有数字，则不能将0作为第一个数字，即不会去遍历0xxx这样的数字。</span><br>            <span class="hljs-keyword">if</span> (digit == <span class="hljs-number">0</span> &amp;&amp; k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果当前字符串再添加字符时超出限制，返回</span><br>            <span class="hljs-keyword">if</span> (curr &gt; n/<span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//下一个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextCurr</span> <span class="hljs-operator">=</span> curr * <span class="hljs-number">10</span> + nums[k];<br>            <span class="hljs-comment">//下一个数的反转</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextRev</span> <span class="hljs-operator">=</span>  revs[k]*(<span class="hljs-type">int</span>)(Math.pow(<span class="hljs-number">10</span>, digit)) + rev;<br>            <span class="hljs-comment">//递归</span><br>            dfs(nextCurr, nextRev, digit+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="X、其他"><a href="#X、其他" class="headerlink" title="X、其他"></a>X、其他</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/super-egg-drop/">887. 鸡蛋掉落</a></p><ol><li>第一种方法：在某一层x扔下一枚鸡蛋，破碎和不破碎无法干预，所以取最糟糕情况（max），而在哪一层丢下，则是可以计算的，所以取外层取min。</li></ol><ul><li>**<code>dp[i][n]</code>的定义是：使用i个鸡蛋，在n层楼中，确定刚好不破碎点发生在几楼(也可能全排除，此时说明发生在0层)需要的操作数。</li><li>显然在x层扔一次消耗一次操作，后续需要在<code>n-x</code>层楼中找刚好不破碎点（或全排除，此时发生在x层）或者在<code>x-1</code>层楼中寻找刚好不破碎点（或全排除，此时发生在0层）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][n] = <span class="hljs-number">1</span>+min(x=<span class="hljs-number">0</span>-&gt;n)(max(dp[i-<span class="hljs-number">1</span>][x-<span class="hljs-number">1</span>],dp[i][n-x]))<br></code></pre></td></tr></table></figure><p>通过递推公式，可以遍历x求出结果，但应该加速这个过程：<br><code>dp[i-1][x-1]和dp[i][n-x]</code>，分别是随x变化而递增&#x2F;递减的，要使两者的最大值最小，则要求两者的交点（或交点两侧的整数点，这个过程可以通过二分方法加速）</p><ol start="2"><li>第二种方法：转化问题为已知鸡蛋数量和操作次数，求最高可以求得的楼层。</li></ol><p>初始状态下：已知在0层丢不破碎，未知在1层丢是否破碎。</p><ul><li><code>dp[t][k]</code>的含义是，通过t次操作扔k个鸡蛋，可以确定多少楼层丢鸡蛋是否破碎。</li><li>显然，在x层扔一次消耗一次操作（并确定在x层丢鸡蛋是否破碎），若不破碎，则可以向上搜索，将x层作为已知的楼层（如0）进行处理；若未破碎，则可以向下搜索，将x层作为已知的必然破碎楼层，搜索下面的楼层是否破碎即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设操作t次，使用k个鸡蛋，那么扔下一次鸡蛋后，若没破，我们可以利用k个鸡蛋和t-1次操作继续向上寻找，如果鸡蛋破了，我们可以利用k-1个鸡蛋和t-1次操作在当前楼层下面进行寻找破碎点。</span><br>dp(t,k)=<span class="hljs-number">1</span>+dp(t−<span class="hljs-number">1</span>,k−<span class="hljs-number">1</span>)+dp(t−<span class="hljs-number">1</span>,k);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">superEggDrop</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//如果只有一层，则一次就可以判断（从1楼丢下）</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//操作i次，使用j个鸡蛋</span><br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>        <span class="hljs-comment">//操作1次，使用n个鸡蛋，可以确定的楼层都只有1层</span><br>            f[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//已知递推公式后：</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>                f[i][j] = <span class="hljs-number">1</span> + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[i][k] &gt;= n) &#123;<br>                ans = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><ol><li>考虑每列可以接多少水</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划，整体思维，理出各点积水计算公式为  min(leftMax,rightMax)-curHeight</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[m-<span class="hljs-number">1</span>] = height[m-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            leftMax[i] = Math.max(leftMax[i-<span class="hljs-number">1</span>],height[i]);<br>            rightMax[m-i-<span class="hljs-number">1</span>] = Math.max(rightMax[m-i],height[m-i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m-<span class="hljs-number">1</span>;i++)&#123;<br>            sum += Math.min(leftMax[i],rightMax[i])-height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//可优化，求左右Max的同时求积，使用双指针解决</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> height[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> height[m-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//对于一个位置，该位置水量由其左侧最高点，右侧最高点中的较低值决定的，所以如果能确定这个其中一侧的最高点，肯定低于另一侧的最高点即可。</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(leftMax&lt;rightMax)&#123;<br>                sum += leftMax-height[left];<br>                left++;<br>                leftMax = Math.max(leftMax,height[left]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum += rightMax-height[right];<br>                right--;<br>                rightMax = Math.max(rightMax,height[right]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意只需要加到left&lt;right，left=right时不用再加，因为这个点为最高点</span><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>模拟过程，维护递减序列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单调栈，面向过程，对每个整体水沟一行一行的清除，即填入将高度填入递减栈，当遇到比当前值高的则计算依次积水量并把槽填平。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.length;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i]&gt;height[stack.peek()])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> height[top];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> Math.min(height[i],height[stack.peek()]);<br>                ans += (high-low)*(i-stack.peek()-<span class="hljs-number">1</span>);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-skyline-problem/">218. 天际线问题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">getSkyline</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] buildings)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//保存坐标和高度（上升的使用负数，便于排序：坐标位置相同时，优先处理上升，且处理上升最多的元素）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] a:buildings)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a[<span class="hljs-number">0</span>],-a[<span class="hljs-number">2</span>]&#125;);<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        Collections.sort(list,(a,b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//当前高度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//高度的优先队列，当前的图像肯定是最高高度</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);<br>        queue.add(pre);<br>        <span class="hljs-comment">//逐个增加List</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] a:list)&#123;<br>            <span class="hljs-comment">//发送一次高度变化（可能）</span><br>            <span class="hljs-comment">//如果是负数，变为正数，添加到高度队列中</span><br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>)&#123;<br>                queue.add(-a[<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                queue.remove(a[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//当前高度</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.peek();<br>            <span class="hljs-comment">//与上一个高度不相等，生成新的点</span><br>            <span class="hljs-keyword">if</span>(temp != pre)&#123;<br>                List&lt;Integer&gt; now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                now.add(a[<span class="hljs-number">0</span>]);<br>                now.add(temp);<br>                ans.add(now);<br>                pre = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><ul><li>维护单调递增序列</li><li>遇到更低的序列时，对前面比该值低的高度做一次结算</li><li>记录的是不同高度的坐标，因此对于等高的，可以不加入队列。</li></ul><p><a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a><br>逐行遍历，每行都是一个柱状图中最大的矩形为题，且可以继承前一行的留存结果。</p><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 法一：以某个数为最小数的序列数量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">// left[i]表示i左侧比i小的连续数量</span><br>        <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">// 注意 带等号</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; cur&lt;=arr[deque.peekLast()])&#123;<br>                deque.pollLast();<br>            &#125;<br>            left[i] = deque.isEmpty()?i+<span class="hljs-number">1</span>:i-deque.peekLast();<br>            deque.offerLast(i);<br>        &#125;<br>        deque.clear();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">// 注意 不带等号，从而避免漏算和重复</span><br>            <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; cur&lt;arr[deque.peekLast()])&#123;<br>                deque.pollLast();<br>            &#125;<br>            right[i] = deque.isEmpty()?n-i:deque.peekLast()-i;<br>            deque.offerLast(i);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            ans = (ans + arr[i] * left[i] * right[i])%MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//法二：判断以各数字为结尾的序列数量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        Deque&lt;Integer&gt; monoStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!monoStack.isEmpty() &amp;&amp; arr[monoStack.peek()] &gt; arr[i]) &#123;<br>                monoStack.pop();<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> monoStack.isEmpty() ? (i + <span class="hljs-number">1</span>) : (i - monoStack.peek());<br>            dp[i] = k * arr[i] + (monoStack.isEmpty() ? <span class="hljs-number">0</span> : dp[i - k]);<br>            ans = (ans + dp[i]) % MOD;<br>            monoStack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/4-keys-keyboard/">651. 4键键盘</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxA</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; j + <span class="hljs-number">2</span> &lt; i; j++)&#123;<br>                dp[i] = Math.max(dp[i], dp[j] * (i - (j + <span class="hljs-number">1</span>)));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域算法（分布式算法）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、一致性Hash算法"><a href="#一、一致性Hash算法" class="headerlink" title="一、一致性Hash算法"></a>一、一致性Hash算法</h1><p>todo</p><h1 id="二、Paxos算法"><a href="#二、Paxos算法" class="headerlink" title="二、Paxos算法"></a>二、Paxos算法</h1><p>todo</p><h1 id="三、Raft算法"><a href="#三、Raft算法" class="headerlink" title="三、Raft算法"></a>三、Raft算法</h1><p>Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题: Leader选举(Leader election)、日志同步(Log replication)、安全性(Safety)、日志压缩(Log compaction)、成员变更(Membership change)等。</p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>概念：</p><ul><li>Raft定义了三种角色：<strong>领导者（Leader）</strong>、<strong>跟随者（Follower）</strong> 和 <strong>候选人（Candidate）</strong>。跟随者发现领导者掉线时（收不到leader的心跳）成为候选人。</li><li>节点属性：<ul><li>任期：相当于版本号，过期的任期请求是无用的</li><li>跟随节点ID：即给谁投票或现在跟随谁</li></ul></li><li>超时计时器：<ul><li>选举超时时间：发现leader掉线时随机延迟一段时间选举，防止多节点同时候选</li><li>投票超时时间：收集投票时间的倒计时，结束时统计票数</li><li>竞选等待超时时间：选举失败后且没有其他领导者诞生时，等待一段时间再次选举</li></ul></li></ul><p>实现：</p><ul><li>RPC通讯，只有数据追加请求（心跳）和投票请求（投票）</li><li>任期保证了节点不会使用受到的过期消息，并会跟随最新的任期</li><li>多领导人同时选举时，每个节点只会对一个版本号的投票请求投出一次票。</li></ul><h2 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h2><p>步骤：</p><ul><li>每个node维护一个Log日志（类似于数组，有索引，可以理解为复制进度）。</li><li>leader收到客户端请求后，将消息同步到日志中，并复制给所有follows：<ul><li>当大多数follows接受时，leader会提交该日志。</li><li>leader仍需要保证所有flollows都接受了所有日志保证同步。</li></ul></li><li>该日志会按顺序记录命令与任期，且每条记录会对应一个索引。loader同步日志时，会指定索引，follow通过检查log index可以得知自己是否同步。</li></ul><p><em>新leader同步尚未完成时</em><br>旧leader把某条记录同步给部分follows后掉线，新follows不持有这个记录，则新follows的产生的新记录会覆盖这条丢失的记录。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>拥有最新的已提交的log entry的Follower才有资格成为Leader，为此各节点投票时：</p><ul><li>对于比自己所在任期小的不投票。</li><li>对于比自己复制进度小的不投票。</li></ul><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>日志不能无限增长，各节点可对已经提交的日志进行snapshot（类似做一次RDB代替AOF日志），包括：</p><ul><li>最后一条日子的index和term</li><li>系统当前状态</li></ul><h2 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h2><p>一般指：增加&#x2F;减少副本数、节点替换等。</p><p><em>解决方案</em><br>两阶段变更：旧成员配置Cold -&gt; 共同一致（新旧组合配置） -&gt; 新成员配置Cnew。</p><p><em>步骤</em><br>一阶段：</p><ul><li>Leader收到请求，发起成员变更，<strong>进入共同一致状态</strong>并记录Cold U Cnew log。</li><li>Leader复制Cold U Cnew log到所有共同一致状态的节点（包括新旧节点）。</li><li>如果Cold和Cnew两个多数派确认了这条日志，Leader提交该log。</li></ul><p>二阶段：</p><ul><li>Leader记录Cnew log。</li><li>Leader复制Cnew log到所有共同一致状态的节点（包括新旧节点）。</li><li>Follow收到Cnew log后，若发现自己不在其中则退出，否则进入Cnew状态并返回。</li><li>Leader收到Cnew的多数派确认后，Leader提交该log。</li></ul><p><em>约定</em><br>每次只允许增加或删除一名成员。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>领域算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分布式算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域算法（安全算法）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、摘要算法"><a href="#一、摘要算法" class="headerlink" title="一、摘要算法"></a>一、摘要算法</h1><p><em>摘要算法特点</em></p><ul><li>长度固定</li><li>相同信息求摘要结果相同</li><li>不可逆</li></ul><p><em>摘要算法应用</em></p><ul><li>数字签名和密码加密</li></ul><p><em>常见算法</em></p><ul><li>MD5</li><li>SHA</li></ul><h1 id="二、加密算法"><a href="#二、加密算法" class="headerlink" title="二、加密算法"></a>二、加密算法</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p><em>常见算法</em></p><ul><li>DES，过时。</li><li>IDEA，128位，很少用到。</li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><em>常见算法</em></p><ul><li>RSA，常用。</li><li>ECDHE，ECC族，椭圆加密，HTTPS使用。</li></ul><h1 id="三、国密算法"><a href="#三、国密算法" class="headerlink" title="三、国密算法"></a>三、国密算法</h1><p>国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4，SM7, SM9。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>领域算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>安全算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（数组与字符串）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="数组本身性质"><a href="#数组本身性质" class="headerlink" title="数组本身性质"></a>数组本身性质</h2><p>数组本身的索引的具有信息量，对于很多数组类题目要求时间复杂度O(n)，常量空间复杂度的问题，可以考虑把遍历信息保存在数组内部：</p><ul><li>对数组指定索引做标记：加负号；</li><li>将数组元素与指定索引元素做交换；</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a><br><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></p><ol><li>标记出现了的数的正负号</li><li>将出现了的数交换到对应索引上</li></ol><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>数组中的排序有以下功能：</p><ul><li>相同的数字在一起，实现去重</li><li>连续的数字在一起，可以查看连续序列</li><li>两个排序数组对比可以快速比较重合数（使用双指针）</li><li>利用排序可以快速筛选结果</li></ul><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a><br><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a><br>本质是硬解，但通过排序保证第一个元素永远不重复，还可以通过一些手段减枝。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a><br>建立绝对值和索引的映射，根据绝对值排序，根据索引取真实值。<br><a href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/">2171. 拿出最少数目的魔法豆</a><br>拿出最少的数目 &#x3D; 留下最多的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumRemoval</span><span class="hljs-params">(<span class="hljs-type">int</span>[] beans)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> beans.length;<br>        Arrays.sort(beans);<br>        <span class="hljs-comment">//max表示最多留下的豆子的数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//sum表示所有豆子数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum += beans[i];<br>            max = Math.max(max,(<span class="hljs-type">long</span>)beans[i] * (n-i));<br>        &#125;<br>        <span class="hljs-comment">//最少拿走的豆子 = 总豆子数 - 最多留下的豆子数。</span><br>        <span class="hljs-keyword">return</span> sum-max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-distance-in-arrays/">624. 数组列表中的最大距离</a><br>对于这种<strong>不需要按先后顺序的排他匹配</strong>问题，可以考虑直接顺序遍历，与已遍历部分比较即可。</p><p><a href="https://leetcode.cn/problems/maximum-gap/">164. 最大间距</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumGap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVal</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().getAsInt();<br>        <span class="hljs-keyword">while</span> (maxVal &gt;= exp) &#123;<br>            <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>            <span class="hljs-comment">// 统计exp位上0-9的个数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> (nums[i] / (<span class="hljs-type">int</span>) exp) % <span class="hljs-number">10</span>;<br>                cnt[digit]++;<br>            &#125;<br>            <span class="hljs-comment">// cnt[i]表示第exp位上数值小于i的元素数量，也表示了按照exp排序时，数字为i的数字排序的右边界为cnt[i]（意味着放数字的话可以沿着cnt[i]-1的索引开始放置）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 遍历，在保持数字原顺序的情况下进行放置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> (nums[i] / (<span class="hljs-type">int</span>) exp) % <span class="hljs-number">10</span>;<br>                <span class="hljs-comment">// </span><br>                buf[cnt[digit] - <span class="hljs-number">1</span>] = nums[i];<br>                cnt[digit]--;<br>            &#125;<br>            System.arraycopy(buf, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, n);<br>            exp *= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ret = Math.max(ret, nums[i] - nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="禁止排序"><a href="#禁止排序" class="headerlink" title="禁止排序"></a>禁止排序</h3><p>对于要求n时间复杂度的数组，优先考虑能否利用数组性质保存遍历结果，否则可以通过set等集合保存遍历结果<br><em>例题</em><br><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>对于数组中的滑动窗口首先要注意问题的转化：</p><ul><li>对于<strong>从数组左右两端操作的问题能否转化为对数组中的一个滑动窗口</strong>的问题，如《将x减到0的最小操作数》</li><li>对于窗口内信息的计算能否转化为对窗口两端存储数据的相减，如使用<strong>预处理</strong>方式处理每个元素左边&#x2F;右边的状态，如《爱生气的书店老板》</li><li>差分数组常用于区域<strong>翻转</strong>问题：如将某个数组的一部分翻转（修改正负号或1&#x2F;0变换），判断相邻数的情况。</li></ul><h3 id="静态滑动窗口"><a href="#静态滑动窗口" class="headerlink" title="静态滑动窗口"></a>静态滑动窗口</h3><p>窗口大小不变。<br>每次滑动伴随元素的新增和删除，一般需要维护窗口的性质：</p><ul><li>维护窗口内字符数量等统计信息的：使用如hash，数组等的数据结构维护；</li><li>维护窗口内最大值，最小值的：使用单调队列（LinkedList结构）。</li></ul><blockquote><p>使用数组维护数量时注意：<br>全大&#x2F;小写字符计数：使用<code>int[26]</code>，char-‘a’或-‘A’<br>大小写都有：使用<code>int[58]</code>，char-‘A’<br>全字符：使用<code>int[128]</code></p></blockquote><h4 id="维护窗口统计信息"><a href="#维护窗口统计信息" class="headerlink" title="维护窗口统计信息"></a>维护窗口统计信息</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串</a><br>可以使用一个数维护重复值，一个Hash&#x2F;数组维护字符的数量<br><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a><br>使用预处理数组记录可能获得的顾客<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><ol><li>使用计数法，并且不收缩滑动窗口。</li><li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。<br><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a><br>枚举滑动窗口的起点判断单词数量。</li></ol><h4 id="维护窗口最大值"><a href="#维护窗口最大值" class="headerlink" title="维护窗口最大值"></a>维护窗口最大值</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a><br>双堆，为什么维护一个Map就可以解决延迟删除问题？</p><ul><li>移动元素的有效性：<ul><li>问题：count负责维护了两侧有效元素个数，但在堆之间交换元素时不能保证这个元素是有效元素，导致记录的有效元素与实际的有效元素不相等。</li><li>解决：使每次移动时的队顶元素是绝对有效的，即维护队头的有效性。显然每次计算中间值后、新增元素后队顶都是有效元素，只有移除元素时可能导致某个队头的元素发生变化，通过将另一个队头的元素移过来，即可保证移动的元素是此时的有效元素。</li></ul></li><li>删除元素的合理性：<ul><li>问题：如果延迟删除了队列A的某元素，后续由于某原因该元素在队列B中才被删除（删除时不会调整有效元素个数），导致记录的有效元素与实际的有效元素不相等。</li><li>解决：同上一个问题，如果一个本应该删除的元素被移动到了另一个元素，与移动元素的有效性是相违背的，即该算法能保证一个延迟删除的元素只会被其应该被实时删除的队列中删除。</li></ul></li></ul><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将x减到0的最小操作数</a><br><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a><br>使用有序集合维护窗口的最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Long&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">ceiling</span> <span class="hljs-operator">=</span> set.ceiling((<span class="hljs-type">long</span>) nums[i] - (<span class="hljs-type">long</span>) t);<br>            <span class="hljs-keyword">if</span> (ceiling != <span class="hljs-literal">null</span> &amp;&amp; ceiling &lt;= (<span class="hljs-type">long</span>) nums[i] + (<span class="hljs-type">long</span>) t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            set.add((<span class="hljs-type">long</span>) nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                set.remove((<span class="hljs-type">long</span>) nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>回顾TreeMap的API<br>map.ceilingEntry(key)&#x2F;&#x2F;刚好或大于该key的Entry<br>map.floorEntry(key)&#x2F;&#x2F;刚好或小于该key的Entry<br>map.firstEntry(key)&#x2F;&#x2F;最小的Entry<br>map.lastEntry(key)&#x2F;&#x2F;最大的Entry<br>HashSet同理。</p></blockquote><p><a href="https://leetcode.cn/problems/sliding-window-median/">480. 滑动窗口中位数</a><br>通过大堆+小堆的堆顶实现取中位数，然后维护有效元素的平衡<br>移出元素时：</p><ul><li>直接使用remove(Priority提供了这个方法)</li><li>用HashMap记录过期元素，延迟删除堆顶元素</li></ul><h4 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K连续位的最小翻转次数</a></p><blockquote><p>假设从index&#x3D;0开始判断，每次翻转只翻转index之后长度为k的区域</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minKBitFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-comment">//d[x]记录了A[x]相对A[x-1]翻转了多少次，即d[i] = re[i]-re[i-1]</span><br>    <span class="hljs-comment">//那么第i个数的旋转次数为re[i] = d[0]+d[1]+...+d[i]</span><br>    <span class="hljs-comment">//只需要维护re[i]，即可直到每个位置是否还需要翻转</span><br>        <span class="hljs-type">int</span>[] d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> count= <span class="hljs-number">0</span> ,sumReA= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>        <span class="hljs-comment">//sumReA表示当前i位旋转的次数</span><br>            sumReA +=d[i];<br>            <span class="hljs-comment">//若当前旋转结果为0，则需要以当前索引为窗口头部进行一次旋转</span><br>            <span class="hljs-keyword">if</span>(((sumReA&amp;<span class="hljs-number">1</span>)^A[i]) ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//若后续已经不能旋转了，说明无法实现</span><br>                <span class="hljs-keyword">if</span>(i+K&gt;A.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//当前位旋转。</span><br>                <span class="hljs-comment">//d[i]+=1; 可省略，后续用不到</span><br>                <span class="hljs-comment">//i+K相对i+K-1少旋转一次</span><br>                d[i+K]-=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//由于d[i]+=1，修正sumReA</span><br>                sumReA+=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//结果++</span><br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态滑动窗口"><a href="#动态滑动窗口" class="headerlink" title="动态滑动窗口"></a>动态滑动窗口</h3><p>动态滑动窗口会在合适的时候扩张：</p><ul><li>使用双指针做窗口条件判断，每循环一次右指针向右扩展一单位，然后考虑左边界的情况。</li><li>使用动态规划的方法维护窗口性质，本质就是用数组保存右指针在某处时的窗口状态。</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a><br>不满足要求后，不根据奇偶判断状态，而是根据上一个序列顺序判断，省去一次遍历，不符合要求时，左指针 &#x3D;&#x3D; 右指针<br><a href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a><br>先找到区间，该区间的右扩展全部满足条件，然后收缩左端，每收缩一次计算一次以当前左指针为子数组左端能够得到的子数组数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> answer=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//abc 的计数</span><br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">//窗口左沿</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//窗口右沿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;end&lt;s.length();end++)&#123;<br>            <span class="hljs-type">char</span> charAtEnd=s.charAt(end);<br>            count[charAtEnd-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">while</span>(count[<span class="hljs-number">0</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">2</span>]&gt;=<span class="hljs-number">1</span>)&#123;<br>                answer+=s.length()-end;<br>                <span class="hljs-type">char</span> charAtStart=s.charAt(start);<br>                count[charAtStart-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                start++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a><br>动态滑动窗口+有序集合</p><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a><br>自己做时总想记录特殊字符的位置，实现快速搜索，实际上直接遍历过去速度更快。另外，数组总是比hash更方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-comment">//t中出现字符记录</span><br>    <span class="hljs-type">int</span>[] time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> t.length();<br><br>    <span class="hljs-comment">//结果记录</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length()+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;need;i++)&#123;<br>        mark[t.charAt(i)] = <span class="hljs-literal">true</span>;<br>        time[t.charAt(i)]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>        time[s.charAt(i)]--;<br>        <span class="hljs-keyword">if</span>(mark[s.charAt(i)]&amp;&amp;time[s.charAt(i)]&gt;=<span class="hljs-number">0</span>)&#123;<br>            need--;<br>        &#125;<br>        <span class="hljs-comment">//若满足条件，收缩左侧到刚好不满足条件，并计算值</span><br>        <span class="hljs-keyword">if</span>(need == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(need == <span class="hljs-number">0</span>)&#123;<br>                time[s.charAt(start)]++;<br>                <span class="hljs-keyword">if</span>(mark[s.charAt(start)]&amp;&amp;time[s.charAt(start)]&gt;<span class="hljs-number">0</span>)&#123;<br>                    need++;<br>                &#125;<br>                start++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i-start+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(l&lt;length)&#123;<br>                left = start-<span class="hljs-number">1</span>;<br>                right = i+<span class="hljs-number">1</span>;<br>                length = l;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(length == s.length()+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(left,right);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a><br>动态规划：由于每个状态只依赖前一个状态，所以也可以使用变量代替。<br>同时计算最小、最大和的情况即可，主要排除计算最小和时选择了所有数字的情况。</p><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/">845. 数组中的最长山脉</a><br>类似接雨水题，通过左右指针获取各索引元素左右侧元素状态</p><p><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a><br>该题是一个非二分题，即调整窗口大小时，题目条件的满足性是不确定的，例如，如果原窗口满足条件，将该窗口沿左&#x2F;右扩张时，即可能仍满足要求，也可能不满足要求。<br>因此，为了得到窗口的二分性，可以枚举最大长度所包含的字符类型的数量，当最大程度所包含的字符类型数量是一定的情况下，右端点右移动必然导致字符类型数量增大，左端点右移必然导致字符类型数量减少，得到滑动条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSubstring</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] cs = s.toCharArray();<br>        <span class="hljs-type">int</span>[] cnt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; p &lt;= <span class="hljs-number">26</span>; p++) &#123;<br>            Arrays.fill(cnt, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// tot 代表 [j, i] 区间所有的字符种类数量；sum 代表满足「出现次数不少于 k」的字符种类数量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, tot = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> cs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                cnt[u]++;<br>                <span class="hljs-comment">// 如果添加到 cnt 之后为 1，说明字符总数 +1</span><br>                <span class="hljs-keyword">if</span> (cnt[u] == <span class="hljs-number">1</span>) tot++;<br>                <span class="hljs-comment">// 如果添加到 cnt 之后等于 k，说明该字符从不达标变为达标，达标数量 + 1</span><br>                <span class="hljs-keyword">if</span> (cnt[u] == k) sum++;<br>                <span class="hljs-comment">// 当区间所包含的字符种类数量 tot 超过了当前限定的数量 p，那么我们要删除掉一些字母，即「左指针」右移</span><br>                <span class="hljs-keyword">while</span> (tot &gt; p) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> cs[j++] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                    cnt[t]--;<br>                    <span class="hljs-comment">// 如果添加到 cnt 之后为 0，说明字符总数-1</span><br>                    <span class="hljs-keyword">if</span> (cnt[t] == <span class="hljs-number">0</span>) tot--;<br>                    <span class="hljs-comment">// 如果添加到 cnt 之后等于 k - 1，说明该字符从达标变为不达标，达标数量 - 1</span><br>                    <span class="hljs-keyword">if</span> (cnt[t] == k - <span class="hljs-number">1</span>) sum--;<br>                &#125;<br>                <span class="hljs-comment">// 当所有字符都符合要求，更新答案</span><br>                <span class="hljs-keyword">if</span> (tot == sum) ans = Math.max(ans, i - j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子数组与问题转化"><a href="#子数组与问题转化" class="headerlink" title="子数组与问题转化"></a>子数组与问题转化</h3><p>一般我们有如下定义：<br><strong>子数组</strong>：连续的子数组。<br><strong>子序列</strong>：不连续的子数组。</p><p>求满足要求子数组的问题一般分两类解决方案：</p><ul><li>滑动窗口</li><li>问题转化<ul><li><strong>恰好问题转化为最大-最大</strong></li><li><strong>求最长满足条件的子数组长度问题可以不缩小窗口</strong></li><li><strong>元素抵消</strong></li></ul></li><li>动态规划（见动态规划章节）</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">795. 区间子数组个数</a><br>问题转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">return</span> count(A, R) - count(A, L-<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//计算最大值小于bound的子数组个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> bound)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: A) &#123;<br>            cur = x &lt;= bound ? cur + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            ans += cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a><br>问题转化 + 动态滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//把恰好问题转化为最大-最大</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysWithKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//子数组中存在不同整数数量最大为k的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-comment">//记录窗口中元素数量</span><br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 里不同整数的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>        <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>        <span class="hljs-comment">//添加right元素</span><br>            <span class="hljs-keyword">if</span> (freq[A[right]] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>            freq[A[right]]++;<br>            right++;<br>            <span class="hljs-comment">//若不再满足条件，收缩左端</span><br>            <span class="hljs-keyword">while</span> (count &gt; K) &#123;<br>                freq[A[left]]--;<br>                <span class="hljs-keyword">if</span> (freq[A[left]] == <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献，解释一下，相当于[left,right-1]区间满足count == K，此时以right-1为右节点，向左延申到left，有right-left个数（right-1是因为本轮的right加过1了）</span><br>            res += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a><br>右指针为右界，通过更新右指针字符数量，判断区间内的最大相同字符数量，只需要考虑维护这个最大长度，不用缩短区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> len;<br>        &#125;<br>        <span class="hljs-type">char</span>[] array = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//maxCount表示在满足条件的区间内出现过的最多的相同字符数量，即maxCount+k 一般等于 当前窗口大小。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">while</span>(right&lt;len)&#123;<br>        <span class="hljs-comment">//右端字符数量更新</span><br>            freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            <span class="hljs-comment">//看右端字符数量是否超过了历史最多相同字符数量，</span><br>            maxCount = Math.max(maxCount,freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>            right++;<br>            <span class="hljs-comment">//如果区间内右端字符数量+可修改的字符数量比区间小，说明这个区间无法满足条件，左端需要移动来满足条件，这里没有使用while缩小区间。</span><br>            <span class="hljs-keyword">if</span>(maxCount+k&lt;right-left)&#123;<br>                freq[array[left]-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//确认当前区间的大小</span><br>            res = Math.max(right-left,res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/A1NYOS/">剑指 Offer II 011. 0 和 1 个数相同的子数组</a><br>使用状态量表示1和0数量的差别，通过预处理可以找到匹配的字符串，这里使用HashMap记录相同状态出现的最左索引更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        map.put(counter, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                counter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.containsKey(counter)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> map.get(counter);<br>                maxLength = Math.max(maxLength, i - prevIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(counter, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-all-good-indices/">2420. 找到所有好下标</a><br>双指针左右遍历，使用两个数组分别记录连续递增&#x2F;减数量。</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><ol><li>使用计数法，并且不收缩滑动窗口。</li><li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li></ol><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p>一般为事件在指定时间&#x2F;坐标必然发生&#x2F;结束，需要计算重合情况。<br><em>例题</em><br><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></p><ol><li>可以使用<strong>优先队列</strong>，将所有会议的开始，结束按时间发送顺序排列，然后遍历处理。</li><li>由于题目只要求最多同时需要多少间，因此可以只用<strong>最小堆</strong>记录结束时间，然后采用延迟删除策略。</li><li>创建会议开始，结束时间的有序数组，使用双指针。</li></ol><p><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></p><ul><li>在插入区间的左侧且无交集的区间可以直接添加。</li><li>在插入区间的右侧且无交集的区间也可以直接添加。</li><li>其他情况表示有交集，合并方式是取最左和最右侧。<ul><li>合并可能多次发生，在多次合并后应该确保合并区间被添加。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//表示是否</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">placed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>        <span class="hljs-comment">// 在插入区间的右侧且无交集</span><br>            <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; right) &#123;<br>                <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>                <span class="hljs-keyword">if</span> (!placed) &#123;<br>                    ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>                    placed = <span class="hljs-literal">true</span>;                    <br>                &#125;<br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                <span class="hljs-comment">// 在插入区间的左侧且无交集</span><br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 与插入区间有交集，计算它们的并集</span><br>                left = Math.min(left, interval[<span class="hljs-number">0</span>]);<br>                right = Math.max(right, interval[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>        <span class="hljs-keyword">if</span> (!placed) &#123;<br>            ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ansList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ansList.size(); ++i) &#123;<br>            ans[i] = ansList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">LeetCode讲解</a></p><blockquote><p>线段树出现的目的是为了实现区间更新，常用于<strong>区间统计</strong>和<strong>区间更新</strong>问题，可以实现log复杂度的查询和更新。</p></blockquote><p><img src="/Pasted-image-20230421233108.png"></p><h4 id="普通初始化"><a href="#普通初始化" class="headerlink" title="普通初始化"></a>普通初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span>&#123;  <br>    <span class="hljs-type">int</span>[] tree;  <br>    <span class="hljs-type">int</span> n;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SegmentTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.n = arr.length;  <br>        <span class="hljs-built_in">this</span>.tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>*n];<br>        buildTree(arr,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//将arr[]中的&#123;l,r,index&#125;节点上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> index)</span>&#123;  <br>        <span class="hljs-keyword">if</span>(l == r)&#123;<br>            tree[index] = arr[l];<br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            buildTree(arr,l,mid,leftNode);<br>            buildTree(arr,mid+<span class="hljs-number">1</span>,r,rightNode);  <br>            tree[index] = tree[leftNode]+tree[rightNode];  <br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询arr[]的start-&gt;end区间和，&#123;l,r,index为考察对象&#125;  </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> index)</span>&#123;  <br><span class="hljs-keyword">if</span>(start&gt;r || end&lt;l) &#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(start&lt;=l &amp;&amp; r &lt;= end)&#123;<br><span class="hljs-keyword">return</span> tree[index];  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> query(start,end,l,mid,leftNode);  <br><span class="hljs-type">int</span> <span class="hljs-variable">rightSum</span> <span class="hljs-operator">=</span> query(start,end,mid+<span class="hljs-number">1</span>,end,rightNode);  <br><span class="hljs-keyword">return</span> leftSum+rightSum;  <br>&#125;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;  <br><span class="hljs-keyword">return</span> query(start,end,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更新update_index下的值为val，需要递归更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> update_index,<span class="hljs-type">int</span> val,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> index)</span>&#123;  <br><span class="hljs-keyword">if</span>(l == r)&#123;  <br>tree[index] = val;  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;  <br><span class="hljs-keyword">if</span>(update_index&lt;=mid)&#123;  <br>update(update_index,val,l,mid,leftNode);  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br>update(update_index,val,mid+<span class="hljs-number">1</span>,r,rightNode);  <br>&#125;  <br>tree[index] = tree[leftNode]+tree[rightNode];  <br>&#125;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> update_index,<span class="hljs-type">int</span> val)</span>&#123;  <br>update(update_index,val,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用单点更新初始化"><a href="#利用单点更新初始化" class="headerlink" title="利用单点更新初始化"></a>利用单点更新初始化</h4><p>也可以利用更新逐步初始化线段树，但反复的节点修改会导致效率较低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>update(i,arr[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>例题</em><br><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a><br>思路为线段树，但维护整个数组会导致空间占用过高，因此考虑使用Hashmap维护节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarThree</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; tree;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; lazy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarThree</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//节点所在区间的最大值</span><br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-comment">//节点所在区间被+1的次数，不会递归更新到子节点</span><br>        lazy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">//在start~end区间更新，从（0，1000000000，1）节点，即根节点开始更新</span><br>        update(start, end - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000000000</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//获取根节点数值，即区间内最大值</span><br>        <span class="hljs-keyword">return</span> tree.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">//无需要更新的区间，直接返回</span><br>        <span class="hljs-keyword">if</span> (r &lt; start || end &lt; l) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//该节点代表的区间被更新区间覆盖</span><br>        <span class="hljs-keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;<br>        <span class="hljs-comment">//更新节点代表区间的最大值，即此时tree[idx]肯定为正确的</span><br>            tree.put(idx, tree.getOrDefault(idx, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//更新该区间被+1的次数，注意，这里没有进行递归的更新子节点，所以tree[idx_left]、tree[idx_right]并没有被更新，但题目求得是整体最大值，所以不关心子节点的实时正确性</span><br>            lazy.put(idx, lazy.getOrDefault(idx, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//只更新该区间的部分片段，分别更新左右两子树。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            update(start, end, l, mid, <span class="hljs-number">2</span> * idx);<br>            update(start, end, mid + <span class="hljs-number">1</span>, r, <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//子树更新后，得到的tree[idx_left]和tree[id_right]肯定为正确的，此时需要找到区间最大值，lazy[idx]的值之前没有被更新到子节点，所以在求区间最大值时需要＋回来</span><br>            tree.put(idx, lazy.getOrDefault(idx, <span class="hljs-number">0</span>) + Math.max(tree.getOrDefault(<span class="hljs-number">2</span> * idx, <span class="hljs-number">0</span>), tree.getOrDefault(<span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/">LeetCode讲解</a></p><blockquote><p>树状数组是一种很巧妙的数据结构，通过树状数组可以很方便的解决<strong>前缀和</strong>问题和<strong>单点更新</strong>。</p></blockquote><p><img src="/Pasted-image-20230209172457.png"><br>树状数组的本质是一种通过 树状组织 数组区间和 的数据结构 可以在更新数组节点时依次更新树结构，方便前缀和的查询。</p><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p>得到二进制数x的最低位1的值。相当于计算出了该数在二进制下的粒度&#x2F;最小单位。</p><ul><li>节点依次减去其最小二进制单位即得到求和所需的节点</li><li>节点加上其最小二进制单位即可得到其父节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="前缀和查询"><a href="#前缀和查询" class="headerlink" title="前缀和查询"></a>前缀和查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从右到左查询</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//从节点开始逐一加上前面的节点</span><br>        sum += tree[i];<br>        i -= lowbit(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在要求前6项的和，6的二进制为0110，可分解为0010+0100，对应的是2+4，可以使用C4+C6来表达这个前6项的和。</p><h4 id="单点更新-1"><a href="#单点更新-1" class="headerlink" title="单点更新"></a>单点更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-comment">// 从节点本身开始更新父节点</span><br>    <span class="hljs-keyword">while</span> (i &lt;= len) &#123;<br>    tree[i] += delta;<br>    i += lowbit(i);<br>&#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>树状数组最小索引为1</strong>，所以创建时长度要+1。然后为每个索引初始化数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FenwickTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-built_in">this</span>.len = nums.length + <span class="hljs-number">1</span>;<br>    tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        update(i, nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>例题</em><br><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a><br>本题很容易想到从右到左遍历，但如何维护右边所有数字的值的大小和数量是一个问题。</p><ul><li>先使用有序集合，对所有元素进行排序，得到每个元素大小对应的树状数组索引排名并使用Hash记录。(树状数组的索引是连续的，但索引所代表的值大小不需要连续，只需要保持大小关系即可。)</li><li>从右到左遍历，通过元素大小获取在树状数组下的索引后，获取值，并更新。</li></ul><p><a href="https://leetcode.cn/problems/queries-on-a-permutation-with-key/">1409. 查询带键的排列</a></p><ul><li>扩充数组长度并使用树状数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] processQueries(<span class="hljs-type">int</span>[] queries, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(m + n);<br>        <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            pos[i] = n + i;<br>            bit.update(n + i, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pos[queries[i]];<br>            bit.update(cur, -<span class="hljs-number">1</span>);<br>            ans[i] = bit.query(cur);<br>            cur = n - i;<br>            pos[queries[i]] = cur;<br>            bit.update(cur, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br>  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += a[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            a[x] += dt;<br>            x += lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a><br>以<code>num[i]/2</code>查找翻转对，以<code>nums[i]</code>添加结果。</p><h3 id="线段树和树状数组的区别"><a href="#线段树和树状数组的区别" class="headerlink" title="线段树和树状数组的区别"></a>线段树和树状数组的区别</h3><ul><li>线段树不断进行二分来划分子序列，而树状数组利用索引的二进制表示来划分子序列。</li><li>线段树是一棵二叉树，每个结点可以保存一个区间范围以及对应区间和、最大值、最小值、异或值等等。树状数组易于实现且效率高，但是不支持区间修改和区间询问。</li><li>上一条区别的底层原因是，二叉树的叶子节点仍保留了原始数组的性质，树状数组通过二进制提高了效率，但没有维护原始数组，因此无法实现任意区间的询问和修改，只能针对单点，逐步确认其影响的元素。</li><li>使用上，线段树能实现树状数组实现不了的功能，解决各式区间问题，而树状数组则用于高效的解决前缀和问题。此外，两者都以1为初始索引。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-sum-of-squared-difference/">2333. 最小差值平方和</a><br>使用堆会导致超时，需要巧妙计算</p><p><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/">1664. 生成平衡数组的方案数</a><br>预处理奇数和偶数之和数组，然后枚举删除点。</p><p><a href="https://leetcode.cn/problems/count-good-meals/">1711. 大餐计数</a><br>Hash记录数量，简单遍历即可，每道餐品与前面餐品匹配，不会出现重复情况。</p><blockquote><p>int MOD &#x3D; (int)1e9+7;</p></blockquote><p><a href="https://leetcode.cn/problems/number-of-subarrays-having-even-product/">2495. 乘积为偶数的子数组数</a><br>只要子数组中有偶数，乘积就为偶数，计算以偶数作为结尾的数组即可。</p><p><a href="https://leetcode.cn/problems/candy-crush/">723. 粉碎糖果</a><br>当前场面上所有满足条件的糖果时同时消除的，所以不用考虑粉碎糖果后导致其他糖果从可消除变成不可消除状态。因此每次扫描标记所有可粉碎糖果，然后逐列使用双指针实现迭代。</p><p><a href="https://leetcode.cn/problems/find-permutation/">484. 寻找排列</a><br>无限制下<code>1234...n</code>为最优解，若存在一个递减，则搜索连续递减长度后逆转该片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findPermutation(String s) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            ans[i] = i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(j) == <span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(reverse)&#123;<br>                    reverse(ans,i,j);<br>                    reverse = <span class="hljs-literal">false</span>;<br>                    j++;<br>                    i = j;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    i++;<br>                    j++;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                reverse = <span class="hljs-literal">true</span>;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            reverse(ans,i,j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ans,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ans[l];<br>            ans[l] = ans[r];<br>            ans[r] = temp;<br>            l++;<br>            r--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>总结：</p><ol><li>看排序能不能改善计算！</li><li>看问题能不能转化<ul><li>如最多与最少的转化</li><li>两侧与中间区间的转化</li><li><strong>恰好</strong>与<strong>最大-最大</strong>的转化</li><li>是否能使用预处理数组</li></ul></li><li>对于滑动窗口<ul><li>是否一定要缩小窗口</li><li>统计满足条件的子数组时，以左&#x2F;右端点作为开始&#x2F;结束点。</li></ul></li></ol>          </div><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>字符串的很多题目与数组的处理方式类似，因为字符串本身就是一个字符数组。</p><div class="note note-success">            <p>本篇主要为利用双指针移动判定条件解决问题。<br>对于子序列、回文等问题见动态规划篇。</p>          </div><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a><br>将具有相同元素的单词分类，对各个字符串分别使用字符数组排序，将排序后的单词作为key做对比。</p><h2 id="语义解释"><a href="#语义解释" class="headerlink" title="语义解释"></a>语义解释</h2><p>一般使用双指针，对于计算类需要灵活应用栈，滑动窗口等方法解决。<br><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a><br>类似于操作数栈，但带有正负号，且记录上一次的符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将遇到的数压栈，碰到乘除时出栈计算再压栈，记录每个数前面的符号。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//第一个数前符号为正</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">preSign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">//若是数字，则当前数变化</span><br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>                num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">//若是符号，说明当前数字可以入栈了</span><br>            <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//根据符号选择入栈的真实值</span><br>                <span class="hljs-keyword">switch</span> (preSign) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        stack.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        stack.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        stack.push(stack.pop() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stack.push(stack.pop() / num);<br>                &#125;<br>                preSign = s.charAt(i);<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            ans += stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a><br>可以正向使用栈遍历，然后对比栈；<br>也可以逆向遍历，双指针一次完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> S.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> T.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">skipS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//从右往左移动到第一个有效字符，注意，若没有有效字符了，会变成负数，从而终止。</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipS++;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipS--;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (T.charAt(j) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipT++;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipT--;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//两者都有有效字符，则比较</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            <span class="hljs-comment">//至少有一个已经没有字符了，如果另外一个还有字符，则返回false，当然如果都小于0，可以返回true，但不用写这个逻辑了。</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="比较问题"><a href="#比较问题" class="headerlink" title="比较问题"></a>比较问题</h3><p>一般是双指针，但可以注意循环策略。<br><a href="https://leetcode.cn/problems/long-pressed-name/">925. 长按键入</a><br>判断对比结束是比较难的，这里以i指针作为考察，如果遍历完成后，i指针指向了字符串末尾就算对比成功。<br>此外，return false包含了很多失败情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLongPressedName</span><span class="hljs-params">(String name, String typed)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; typed.length()) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; name.length() &amp;&amp; name.charAt(i) == typed.charAt(j)) &#123;<br>                i++;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; typed.charAt(j) == typed.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == name.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>到这种双指针对比的问题，很容易遇到很多边界条件，如一个结束了另外一个没结束要接着判断边界等情况：<br>1）<code>while(index1&lt;n1 &amp;&amp; index2&lt;n2)</code>，常规思路，还需要额外判断两者是否到达结束点。<br>2）在一个指针的循环体内判断另一个指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1)&#123;<br><span class="hljs-keyword">if</span>(index2&lt;n2)&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）通过if处理都在界内的情况，然后处理有指针不在界内的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1 || index2&lt;n2)&#123;<br><span class="hljs-keyword">if</span>(index1&lt;n1 &amp;&amp; index2&lt;n2)&#123;<br><span class="hljs-comment">//代码，</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="轮转问题"><a href="#轮转问题" class="headerlink" title="轮转问题"></a>轮转问题</h3><p><a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSubstringInWraproundString</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (p.charAt(i) - p.charAt(i - <span class="hljs-number">1</span>) + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 字符之差为 1 或 -25</span><br>                ++k;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k = <span class="hljs-number">1</span>;<br>            &#125;<br>            dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = Math.max(dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>], k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了去重，求以每个字符为结尾的数组长度最大为多少，最后求和。</p><blockquote><p>z-a相连问题，即两字符之间的差为1或-25，可以将其转化为以下式子：<br>（p.charAt(i) - p.charAt(i - 1) + 26) % 26 &#x3D;&#x3D; 1<br>因为25与-1相差26，将符号修正后对26求余时结果肯定一样。</p></blockquote><p><a href="https://leetcode.cn/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></p><blockquote><p>轮转问题一般可以考虑扩充原<strong>数组&#x2F;字符</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFlipedString</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-keyword">if</span>(s2.length() != n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1+s1;<br>        <span class="hljs-keyword">return</span> s3.contains(s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>KMP算法的关键在于构建一个部分匹配表（也称为失败函数或跳转表），这个表的构建过程需要O(m)的时间。然后，KMP算法在主串上进行匹配，它的匹配过程是线性的，每次比较字符后，根据部分匹配表决定如何移动模式串，而不需要回溯主串。<br>KMP（Knuth-Morris-Pratt）算法的时间复杂度为O(n + m)，其中n是主串的长度，m是模式串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(String s1,String s2)</span>&#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> s1.length();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> s2.length();  <br>    <span class="hljs-type">int</span>[] next = getNextArr(s2);  <br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span>(i&lt;n1)&#123;  <br>        <span class="hljs-keyword">if</span>(s1.charAt(i) == s2.charAt(j))&#123;  <br>            i++;  <br>            j++;  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>)&#123;  <br>            j = next[j-<span class="hljs-number">1</span>];  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            i++;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(j == n2)&#123;  <br>            <span class="hljs-keyword">return</span> i-j;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getNextArr(String s) &#123;  <br>    <span class="hljs-type">char</span>[] cs = s.toCharArray();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cs.length;  <br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];  <br>    <span class="hljs-comment">// 当前考察的子串[0,1]  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// j是i-1子串的最长前后缀匹配  </span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span>(i&lt;n)&#123;  <br>        <span class="hljs-keyword">if</span>(cs[i] == cs[j])&#123;  <br>            j++;  <br>            next[i] = j;  <br>            i++;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-keyword">if</span>(j &gt;<span class="hljs-number">0</span>) &#123;  <br>                j = next[j-<span class="hljs-number">1</span>];  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                next[i] = <span class="hljs-number">0</span>;  <br>                i++;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> next;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">最浅显易懂的 KMP 算法讲解</a></p></blockquote><h2 id="字符串替换-x2F-编码"><a href="#字符串替换-x2F-编码" class="headerlink" title="字符串替换&#x2F;编码"></a>字符串替换&#x2F;编码</h2><p>一般题目为允许&#x2F;必须替换字符串中的某些字符，以达到某种条件。<br>滑动窗口类题型可见上文，下面为<strong>规律题</strong>：<br><a href="https://leetcode.cn/problems/1-bit-and-2-bit-characters/">717. 1 比特与 2 比特字符</a></p><ol><li>正向推理：遇到0走一格，遇到1走两格，判断最后一次走的是几格。</li><li>反向推理：<ul><li>如果结尾前为0，则必然为true</li><li>如果结尾前是1，则必然为11<ul><li>这个11的前面只能接着放11或0结尾的字符，所以判断结尾0到倒数第二个0中间1的个数是否为偶数。</li></ul></li></ul></li></ol><p><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a><br>由题可知：<br>L可以与右侧的X交换，R可以与左侧的X交换，但L不可以跨越R。<br>即L可以右移，R可以左移，L和R的顺序不能改变。<br>那么可以忽略X，如果找到对应的L，原始L应该在变化后的L的左侧，原始R应该在变化后的R的右侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (start.charAt(i) != end.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> start.charAt(i);<br>                <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; i &lt; j) || (c == <span class="hljs-string">&#x27;R&#x27;</span> &amp;&amp; i &gt; j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                i++;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (end.charAt(j) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p><a href="https://leetcode.cn/problems/ternary-expression-parser/">439. 三元表达式解析器</a><br>分析：所有<code>?</code>前的一定是’T’或’F’。</p><ul><li>顺序处理，递归、剪枝</li><li>倒序处理，堆栈<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归，每次找到当前层次表达式的?和:，然后递归处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">parseTernary</span><span class="hljs-params">(String expression)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> expression.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">checkLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (expression.charAt(j) == <span class="hljs-string">&#x27;?&#x27;</span>) checkLevel++;<br>            <span class="hljs-keyword">if</span> (expression.charAt(j) == <span class="hljs-string">&#x27;:&#x27;</span>) checkLevel--;<br>            <span class="hljs-keyword">if</span> (checkLevel == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (expression.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;T&#x27;</span>) ? parseTernary(expression.substring(<span class="hljs-number">2</span>, j)) : parseTernary(expression.substring(j+<span class="hljs-number">1</span>, n));<br>        &#125;<br>        <span class="hljs-keyword">return</span> expression;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 栈式处理，倒序处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">parseTernary</span><span class="hljs-params">(String expression)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Character&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> expression.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> expression.charAt(index);<br>            index--;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> expression.charAt(index);<br>                index--;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">if</span> (condition == <span class="hljs-string">&#x27;T&#x27;</span>) &#123;<br>                    stack.push(c1);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stack.push(c2);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(stack.pop());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/basic-calculator-iii/">772. 基本计算器 III</a></p><ul><li>符号优先级：记录符号，乘除当场处理，后续再使用栈处理加减。</li><li>括号问题：记录同层次括号的始末，迭代计算。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">//遇到所有非符号的字符应该视为一个对现有数字的处理</span><br>            <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                num = num*<span class="hljs-number">10</span>+temp-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-comment">//处理括号,记录括号层数</span><br>                <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>                i++;<br>                StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-comment">//不同层次 或 非括号 时继续</span><br>                <span class="hljs-keyword">while</span>(count != <span class="hljs-number">1</span> || s.charAt(i) != <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<span class="hljs-comment">// 处理多重括号</span><br>                    sb.append(s.charAt(i));<br>                    <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;(&#x27;</span>) count++;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;)&#x27;</span>) count--;<br>                    i++;<br>                &#125;<br>                num=calculate(sb.toString());<span class="hljs-comment">//括号中的表达式的值</span><br>            &#125;<br>            <span class="hljs-comment">//遇到符号的字符应该处理该数字，并记录当前符号下次使用</span><br>            <span class="hljs-keyword">if</span>(temp &lt;<span class="hljs-string">&#x27;0&#x27;</span> || i==s.length()-<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">switch</span>(op)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:&#123;<br>                        deque.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:&#123;<br>                        deque.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:&#123;<br>                        deque.push(deque.poll() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:&#123;<br>                        deque.push(deque.poll() / num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                op = temp;<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            res+=deque.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="滚动哈希"><a href="#滚动哈希" class="headerlink" title="滚动哈希"></a>滚动哈希</h2><p>Rabin-Karp<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/Pasted-image-20230903151913.png"><br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/Pasted-image-20230903152047.png"><br>可用于快速比较字符串是否相等。<br><em>例题</em><br><a href="https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/">1147. 段式回文</a><br><a href="https://leetcode.cn/problems/longest-duplicate-substring/">1044. 最长重复子串</a><br>二分判断长度 + set去重，使用滚动hash进行计算，一般mod取大质数即可。<br><a href="https://leetcode.cn/problems/shortest-palindrome/">214. 最短回文串</a></p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode.cn/problems/add-bold-tag-in-string/">616. 给字符串添加加粗标签</a><br>合并区间问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addBoldTag</span><span class="hljs-params">(String S, String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> S.length();<br>        <span class="hljs-type">boolean</span>[] mask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)&#123;<br>            loop:<br>            <span class="hljs-keyword">for</span> (String word:words)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); ++k)&#123;<br>                    <span class="hljs-keyword">if</span> (k+i &gt;= S.length() || S.charAt(k+i) != word.charAt(k)) <span class="hljs-keyword">continue</span> loop;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; i+word.length(); ++j) mask[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">anchor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (mask[i] &amp;&amp; (i == <span class="hljs-number">0</span> || !mask[i-<span class="hljs-number">1</span>]))<br>                ans.append(<span class="hljs-string">&quot;&lt;b&gt;&quot;</span>);<br>            ans.append(S.charAt(i));<br>            <span class="hljs-keyword">if</span> (mask[i] &amp;&amp; (i == N-<span class="hljs-number">1</span> || !mask[i+<span class="hljs-number">1</span>]))<br>                ans.append(<span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-IP</title>
    <link href="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/"/>
    <url>/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、IP概念"><a href="#一、IP概念" class="headerlink" title="一、IP概念"></a>一、IP概念</h1><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong><br><strong>MAC 的作用是实现「直连」的两个设备之间通信，而 IP 负责在「没有直连」的两个网络之间进行通信传输。</strong><br>在网络中数据包传输中：<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><h1 id="二、IP基础概念"><a href="#二、IP基础概念" class="headerlink" title="二、IP基础概念"></a>二、IP基础概念</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/4.webp"><br>IP最大值为：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5.webp"></p><h2 id="分类地址"><a href="#分类地址" class="headerlink" title="分类地址"></a>分类地址</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7.webp"><br><strong>主机号全为 1 表示广播 和 全为 0 表示网络。</strong></p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><div class="note note-primary">            <p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p>          </div><blockquote><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0&#x2F;24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（<strong>由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。</strong>）。</li></ul></blockquote><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><p>而D类和E类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/12.webp"></p><blockquote><p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p></blockquote><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13.webp"></p><p><strong>多播中，后面的28位是多播的组编号。</strong></p><p><em>缺点一</em><br><strong>同一网络下没有地址层次</strong></p><p><em>缺点二</em><br><strong>不能很好的与现实网络匹配</strong>。</p><h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18.webp"></p><h2 id="公有IP地址与私有IP地址"><a href="#公有IP地址与私有IP地址" class="headerlink" title="公有IP地址与私有IP地址"></a>公有IP地址与私有IP地址</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/22.webp"></p><blockquote><p>公有 IP 地址由谁管理呢？<br>公有 IP 地址是由 <code>ICANN</code> 组织管理，中文叫「互联网名称与数字地址分配机构」。</p></blockquote><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/25.webp"></p><blockquote><p><strong>127.0.0.1 作为环回地址</strong>，这是不会流向网络。</p></blockquote><h2 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h2><p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，如FDDI数据链路 MTU 4352、以太网的MTU是1500字节等。<br>那么当IP数据包大小大于MTU时，IP数据包就会被分片。</p><p>在分片传输中，一旦某个分片丢失，则会造成整个IP数据报作废，所以 TCP 引入了<code>MSS</code>也就是在TCP层进行分片不由IP层分片，那么对于UDP我们尽量不要发送一个大于<code>MTU</code>的数据报文。</p><h2 id="IPv6-基本认识"><a href="#IPv6-基本认识" class="headerlink" title="IPv6 基本认识"></a>IPv6 基本认识</h2><p>IPv6 的地址是 <code>128</code> 位的，每 16 位作为一组，每组用冒号 「:」 隔开。</p><blockquote><p>IPv4 和 IPv6 不能相互兼容</p></blockquote><p>IPv6 的地址主要有以下类型地址：</p><ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/29.webp"><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/30.webp"></p><ul><li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4没有此类型。</li><li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于IPv4的私有 IP</li><li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于IPv4的公有IP</li></ul><h3 id="IPv6首部"><a href="#IPv6首部" class="headerlink" title="IPv6首部"></a>IPv6首部</h3><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/31.webp"></p><ul><li><strong>取消了首部校验和字段。</strong>（数据链路和传输层都校验，这里就省略了）</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong>（路由器不再可以分片，只允许源与目标主机分片重组）</li><li><strong>取消选项字段。</strong>（变成了下一个首部）。</li></ul><h1 id="三、IP协议相关技术"><a href="#三、IP协议相关技术" class="headerlink" title="三、IP协议相关技术"></a>三、IP协议相关技术</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>那么实现这一技术的就是 <strong>DNS 域名解析</strong>，DNS 可以将域名网址自动转换为具体的 IP 地址。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/33.webp"><br>DNS的域名解析方式是迭代而不是递归（<strong>只指路不带路</strong>）。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>已知 IP 求 MAC 地址。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/34.webp">两ARP是借助<strong>ARP请求与ARP响应</strong>种类型的包确定 MAC 地址的。</p><ul><li>主机会通过<strong>广播发送ARP请求</strong>，这个包中包含了想要知道的 MAC 地址的主机IP地址。</li><li>当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的 MAC 地址塞入<strong>ARP响应包</strong>返回给主机。</li></ul><h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>与 ARP 协议正好相反，它是<strong>已知 MAC 地址求 IP 地址</strong>。</p><p>通常这需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li><li>然后设备根据该回复设置自己的IP地址。</li></ul><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/36.webp"></p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong>，<strong>UDP广播</strong>。</li><li>服务器<strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应，<strong>UDP广播</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数，<strong>UDP广播</strong>。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数，<strong>UDP广播</strong>。</li></ul><p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li></ul><div class="note note-primary">            <ol><li>DHCP交互都是UDP报文</li><li>首次交互根据事务ID维持沟通独立性</li><li>各DHCP发送自己准备分配的相关信息（提供的地址等），客户端选择后，服务端再确认。</li></ol>          </div><p>如何实现大网段的IP地址分发：</p><blockquote><p><strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p></blockquote><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/37.webp"></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p><strong>网络地址转换 NAT</strong>，对外部通信时，把私有 IP 地址转换成公有 IP 地址，缓解了IP地址不够的问题。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/38.webp"><br>而把 IP 地址 + 端口号一起进行转换的技术叫<strong>网络地址与端口转换 NAPT。</strong><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/39.webp"><br><strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong></p><p>这种转换表在 NAT 路由器上自动生成。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>IPv6</li><li>NAT穿透技术：网络应用程序主动发现自己位于NAT设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目。</li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。<br><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/40.webp"></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><blockquote><p>IGMP与ICMP毫无关系</p></blockquote><p>既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/42.webp"><br><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p><ul><li>主机可以使用IGMP报文向路由器申请加入和退出组播组。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><em>常规查询与响应和离开组播组</em><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/43.webp"></p><ol><li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li><li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）<ul><li>如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li></ul></li><li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li></ol><div class="note note-primary">            <p>简而言之，主机向路由器发送成员关系报告报文后，表示该路由器的直连主机中有某个组播的成员，此后路由器就会转发这个组播。</p>          </div><p><em>离开组播组工作机制</em><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/44.webp"></p><ol><li>主机1要离开组播组，发送给网段内所有路由器</li><li>路由器询问是否还有该组播成员</li><li>若有，则之后会继续转发该组播消息；否则，不再转发。</li></ol><h1 id="四、PING的原理"><a href="#四、PING的原理" class="headerlink" title="四、PING的原理"></a>四、PING的原理</h1><p>ping 是基于 <code>ICMP</code> 协议工作的。<br>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5-1.webp"></p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/6.webp"></li></ul><h2 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h2><p>回送消息 —— 类型 <code>0</code>（回送响应）和 <code>8</code>（回送请求）<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7-1.webp"><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/8.webp"><br>相比原生的 ICMP，这里多了两个字段：</p><ul><li><strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li><strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><h2 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h2><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>目标不可达消息 —— 类型 为 <code>3</code></li><li>原点抑制消息 —— 类型 <code>4</code></li><li>重定向消息 —— 类型 <code>5</code></li><li>超时消息 —— 类型 <code>11</code></li></ul><h3 id="不可达分类"><a href="#不可达分类" class="headerlink" title="不可达分类"></a>不可达分类</h3><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/9.webp"><br><em>网络不可达</em><br>路由表匹配不到</p><p><em>主机不可达</em><br>找得到网络，但找不到主机</p><p><em>协议不可达</em><br>对端主机的防火墙已经禁止TCP协议访问等情况</p><p><em>端口不可达</em><br>通过防火墙，但没有进程监听目标端口</p><p><em>需要进行分片但设置了不分片</em><br>组件路由器由于不分片政策直接丢弃IP分组</p><h4 id="原点抑制"><a href="#原点抑制" class="headerlink" title="原点抑制"></a>原点抑制</h4><p>原点抑制消息（ICMP Source Quench Message）—— 类型 <code>4</code><br>通知主机线路拥堵，需要增大IP包传输间隔</p><blockquote><p>由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p></blockquote><h4 id="重定向消息"><a href="#重定向消息" class="headerlink" title="重定向消息"></a>重定向消息</h4><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code><br>路由器发现不是最优路径，则返回重定向消息给主机。</p><h4 id="超时消息"><a href="#超时消息" class="headerlink" title="超时消息"></a>超时消息</h4><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code><br>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><h2 id="Ping-请求报文的应用"><a href="#Ping-请求报文的应用" class="headerlink" title="Ping-请求报文的应用"></a>Ping-请求报文的应用</h2><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13-1.webp"></p><p>整体流程：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/17.webp"></p><h2 id="traceroute—差错报文类型的使用"><a href="#traceroute—差错报文类型的使用" class="headerlink" title="traceroute—差错报文类型的使用"></a>traceroute—差错报文类型的使用</h2><p><em>1. traceroute 作用一</em><br>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong><br>将TTL从1开始递增，强制接受ICMP超时消息。</p><p><em>2. traceroute 作用二</em><br>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18-1.webp"></p><h1 id="五、ping-127-0-0-1"><a href="#五、ping-127-0-0-1" class="headerlink" title="五、ping 127.0.0.1"></a>五、ping 127.0.0.1</h1><h2 id="ping流程"><a href="#ping流程" class="headerlink" title="ping流程"></a>ping流程</h2><p>ping与TCP的区别（_右边的ping数据应该为TCP数据_）：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/Pasted-image-20230208113935.png"></p><ul><li>ping是应用层协议</li><li>创建socket时的使用的参数不同</li><li>其他与普通TCP发送消息相同，所以可以通过ping测试能否到达访问</li></ul><h2 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/Pasted-image-20230208114527.png"><br>回环地址，<strong>软中断</strong>会直接返回，不走网卡。</p><h2 id="ping回环地址与ping本机IP"><a href="#ping回环地址与ping本机IP" class="headerlink" title="ping回环地址与ping本机IP"></a>ping回环地址与ping本机IP</h2><p><strong>没有区别！</strong><br>即使填写真IP，也会通过本地回环，不走网卡。</p><h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP</title>
    <link href="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/"/>
    <url>/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP基本认识"><a href="#一、TCP基本认识" class="headerlink" title="一、TCP基本认识"></a>一、TCP基本认识</h1><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h2 id="头格式"><a href="#头格式" class="headerlink" title="头格式"></a>头格式</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207114528.png"><br>不常见的：<br>URG：紧急标志位，优先处理紧急数据。<br>PSH：催促标志位，发送方立即发送，接受方立即接受。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文。</li></ul><h2 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h2><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115025.png"><br>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="唯一确定一个-TCP-连接呢？"><a href="#唯一确定一个-TCP-连接呢？" class="headerlink" title="唯一确定一个 TCP 连接呢？"></a>唯一确定一个 TCP 连接呢？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115107.png"></p><ul><li><strong>文件描述符限制</strong>，每个TCP连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看；</li><li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li><li><strong>进程级</strong>：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li></ul></li><li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h3 id="IP层会分片，为什么TCP层还需要MSS？"><a href="#IP层会分片，为什么TCP层还需要MSS？" class="headerlink" title="IP层会分片，为什么TCP层还需要MSS？"></a>IP层会分片，为什么TCP层还需要MSS？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207131104.png"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>如果把TCP报文整个交给IP分层，则一个IP分片丢失就会造成整个IP报文重传，因为IP报文没有分片重传机制，效率很低。</p><p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值。</strong></p><div class="note note-primary">            <p>TCP分片后保证其数据包大小MSS+TCP头部+IP头部&lt;MTU，因此不需要IP分片，这样重发时也是以MSS为单位，效率更高。</p>          </div><div class="note note-success">            <p>注意：MSS不包括TCP头部，但MTU包括IP头部，不包括MAC头部。</p>          </div><h3 id="如何理解TCP基于字节流"><a href="#如何理解TCP基于字节流" class="headerlink" title="如何理解TCP基于字节流"></a>如何理解TCP基于字节流</h3><p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p><p>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。</p><h4 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h4><p>一般交给应用层解决。</p><ul><li>固定长度的消息；</li><li>特殊字符作为边界，如HTTP；</li><li>自定义消息结构；</li></ul><h2 id="UDP-和-TCP-有什么区别呢"><a href="#UDP-和-TCP-有什么区别呢" class="headerlink" title="UDP 和 TCP 有什么区别呢"></a>UDP 和 TCP 有什么区别呢</h2><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115326.png"><br><strong>TCP 和 UDP 区别：</strong><br><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 <strong>MSS</strong> 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 <strong>MTU</strong> 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong><br>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><p><strong>为什么UDP头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115616.png"><br>UDP的头部理论上也可这样省略，保留的原因可能有：</p><ul><li>保持4的整数倍。</li><li>当年UDP协议可能不是基于IP发展的。</li></ul><p><strong>TCP和UDP可以使用同一个端口吗？</strong><br>可以，两者是不同的模块。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.webp"></p><h1 id="二、TCP连接建立"><a href="#二、TCP连接建立" class="headerlink" title="二、TCP连接建立"></a>二、TCP连接建立</h1><h2 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp"></p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120323.png"></p><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120334.png"></p><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120342.png"><br><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</strong></p><blockquote><p>第三次握手如果丢了可以建立连接吗？<br>可以，因为之后的普通数据报文也有ACK标志符和ack号。</p></blockquote><blockquote><p>Linux查看TCP连接状态：<code>netstat -napt</code>查看</p></blockquote><h2 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h2><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p><em>原因一：避免历史连接</em><br><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120725.png"></p><blockquote><p>如果新SYN在RST前到达，则回 <a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。</p><ul><li>客户端第一次握手后收到不正确的ACK会发送RST</li><li>服务端收到新的SYN报文时会要求对方传输正确的SYN，即回复上一次ACK报文。</li></ul></blockquote><p><em>原因二：同步双方初始序列号</em><br><strong>要确保双方的初始序列号能被可靠的同步。</strong> 在两次握手的情况下，只能保证客户端的SYN被接受。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207121527.png"><br>TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以<strong>去除重复</strong>的数据；</li><li>接收方可以根据数据包的序列号<strong>按序</strong>接收；</li><li>可以<strong>标识</strong>发送出去的数据包中，哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p><em>原因三：避免资源浪费</em><br>在两次握手的情况下，服务器无法判断客户端是否接受到了第二次握手，所以服务端每接受到一个SYN都要建立连接，如果SYN阻塞，则会产生很多冗余链接，造成不必要的资源浪费。</p><p><em>小结</em><br>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><div class="note note-primary">            <p>原因一、三有点类似，但角度不同，一个是历史连接建立造成的连接混乱，一个是历史连接建立造成的资源消耗。</p>          </div><h2 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h2><h3 id="初始化序列号为何不同？"><a href="#初始化序列号为何不同？" class="headerlink" title="初始化序列号为何不同？"></a>初始化序列号为何不同？</h3><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收；</li></ul><p>如果每次都是相同的初始化序列号，历史的滞留信息可能被下一次相同四元组的连接接受：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/isn%E7%9B%B8%E5%90%8C.webp"></p><h3 id="如何随机初始化序列号？"><a href="#如何随机初始化序列号？" class="headerlink" title="如何随机初始化序列号？"></a>如何随机初始化序列号？</h3><p>起始<code>ISN</code>是基于时钟的，每4微秒+1，转一圈要4.55个小时。<br>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><div class="note note-primary">            <p>可见不同四元组的ISN几乎不可能相同，同一个四元组中可能产生计时器回绕，因此有时需要时间戳判断历史报文。</p>          </div><h2 id="握手丢失"><a href="#握手丢失" class="headerlink" title="握手丢失"></a>握手丢失</h2><h3 id="第一次握手丢失"><a href="#第一次握手丢失" class="headerlink" title="第一次握手丢失"></a>第一次握手丢失</h3><p>客户端以相同的syn序列号重传。</p><h4 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>第一次超时重传是在<strong>1秒</strong>后。</li><li>默认总共超时<strong>重传5次</strong>（<code>tcp_syn_retries</code>设置）。</li><li><strong>每次超时的时间是上一次的2倍</strong>。</li><li>第五次重传后等待32秒然后断开连接。</li><li>总共耗时63秒，大约1分钟。</li></ul><h3 id="第二次握手丢失"><a href="#第二次握手丢失" class="headerlink" title="第二次握手丢失"></a>第二次握手丢失</h3><ul><li>客户端以相同的序列号<strong>重传</strong>，类似第一次握手丢失。</li><li>服务器也以相同的序列号<strong>重传</strong>SYN-ACK报文。</li></ul><h4 id="超时机制-1"><a href="#超时机制-1" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>默认总共超时<strong>重传5次</strong>（<code>tcp_synack_retries</code>设置）。</li></ul><h3 id="第三次握手丢失"><a href="#第三次握手丢失" class="headerlink" title="第三次握手丢失"></a>第三次握手丢失</h3><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。即服务器超时重传。</p><h3 id="客户端二次握手后超时重传"><a href="#客户端二次握手后超时重传" class="headerlink" title="客户端二次握手后超时重传"></a>客户端二次握手后超时重传</h3><p>TCP 建立连接后的<strong>数据包传输</strong>，最大超时重传次数是由 <code>tcp_retries2</code> 指定，默认值是 15 次。</p><h2 id="TCP快速连接"><a href="#TCP快速连接" class="headerlink" title="TCP快速连接"></a>TCP快速连接</h2><p>Linux 3.7内核版本中，提供了<strong>TCP Fast Open</strong>功能。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/45.webp"></p><ul><li>第一次连接：第二次握手时服务器给客户端传<code>Cookie</code>（加密）</li><li>第二次连接：第一次握手时客户端直接发送<code>Cookie</code>，省去了一次握手。</li></ul><p>net.ipv4.tcp_fastopen 各个值的意义:</p><ul><li>0 关闭</li><li>1 作为客户端使用 Fast Open 功能</li><li>2 作为服务端使用 Fast Open 功能</li><li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能</li></ul><h1 id="三、TCP连接断开"><a href="#三、TCP连接断开" class="headerlink" title="三、TCP连接断开"></a>三、TCP连接断开</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207141651.png"><br><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h2 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h2><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p><strong>在特定情况下，四次挥手是可以变成三次挥手的。</strong></p><h2 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h2><p>关闭的连接的函数有两种函数：</p><ul><li><code>close</code> 函数，同时 socket 关闭发送方向和读取方向。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让socket 引用计数 -1，并不会导致 socket 不可用，同时也<strong>不会发出 FIN 报文</strong>，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li><li><code>shutdown</code> 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。（如果有多进程&#x2F;多线程共享同一个 socket，<strong>shutdown则不管引用计数，直接使得该socket不可用，然后发出 FIN 报文</strong>，如果有别的进程企图使用该 socket，将会受到影响。）</li></ul><div class="note note-primary">            <p>CLOSE只关闭SOCKET对本身的引用，不发FIN；<br>SHUTDOWN关闭写方向时，直接关闭SOCKET，发FIN；</p>          </div><ul><li>如果客户端调用<code>close</code>使Socket引用计数为0时，关闭连接，客户端发送FIN后若再接收到服务器的数据消息，会发送RST给服务端，从而不会经历四次握手。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230208001214.png"></li><li>如果客户端调用shutdown关闭写方向，正常4次挥手，关闭读方向的话，不会发送FIN，因为FIN的语义是我方不再发送信息。</li></ul><h2 id="TCP四次握手变三次"><a href="#TCP四次握手变三次" class="headerlink" title="TCP四次握手变三次"></a>TCP四次握手变三次</h2><p>服务端 <strong>「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul><li>当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方。</li><li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ul><p>延迟等待的时间是在Linux内核中定义。</p><h2 id="挥手丢失"><a href="#挥手丢失" class="headerlink" title="挥手丢失"></a>挥手丢失</h2><h3 id="第一次挥手丢失"><a href="#第一次挥手丢失" class="headerlink" title="第一次挥手丢失"></a>第一次挥手丢失</h3><p>当客户端向服务端重传 FIN 报文。</p><h4 id="超时机制-2"><a href="#超时机制-2" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>默认总共超时<strong>重传8次</strong>（<code>tcp_orphan_retries</code>设置）。</li><li><strong>每次超时的时间是上一次的2倍</strong>。</li><li>超时仍未收到则close。</li></ul><h3 id="第二次挥手丢失"><a href="#第二次挥手丢失" class="headerlink" title="第二次挥手丢失"></a>第二次挥手丢失</h3><ul><li>客户端重传FIN报文，类似第一次挥手丢失。</li><li>服务端不会主动重传ACK，接收到重传的FIN会再次进行二次挥手。</li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.webp"></p><h3 id="第三次挥手丢失"><a href="#第三次挥手丢失" class="headerlink" title="第三次挥手丢失"></a>第三次挥手丢失</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.webp"></p><ul><li>服务端重传，机制类似第一次握手（<code>tcp_orphan_retries</code>）</li><li>客户端超过<code>tcp_fin_timeout</code>（默认60s）后关闭</li></ul><h3 id="第四次挥手丢失"><a href="#第四次挥手丢失" class="headerlink" title="第四次挥手丢失"></a>第四次挥手丢失</h3><ul><li>服务端重传第三次握手，机制类似第一次握手</li><li>客户端进入time_wait状态（2MSL），并会不断回复第四次握手。</li></ul><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>。<br>目的是保证这次连接中所有报文已经死亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p>如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p><strong>为什么是2倍MSL？</strong><br>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>2MSL表示允许第四次挥手报文至少丢失一次。</p><h3 id="TIME-WAIT的目的"><a href="#TIME-WAIT的目的" class="headerlink" title="TIME_WAIT的目的"></a>TIME_WAIT的目的</h3><p><em>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p><ul><li>序列号：为32位，即达到4G数据后会循环回0；</li><li>初始序列号：受时间影响，4.55小时一次循环；</li></ul><p>如果不保证连接中所有报文都死亡，则可能在相同四元组的情况下被下一个连接错误的接受。</p><p><em>原因二：保证「被动关闭连接」的一方，能被正确的关闭</em><br>第四次挥手可能丢失，此时服务端会重传第三次挥手，TW状态可以回复第四次挥手ACK。<br>否则，重传的第三次握手遇到CLOSE状态会收到RST回复来关闭连接，这部是一个优雅的终止方式。</p><h3 id="TIME-WAIT不能过多"><a href="#TIME-WAIT不能过多" class="headerlink" title="TIME_WAIT不能过多"></a>TIME_WAIT不能过多</h3><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><p>对客户端、服务端的影响：</p><ul><li>客户端：对相同IP，PORT的TCP连接是有上线的，即占用端口资源，且占用系统资源。</li><li>服务端：服务器只监听一个端口，理论上不会收到端口资源影响，但仍然占用系统资源。</li></ul><h3 id="优化TIME-WAIT"><a href="#优化TIME-WAIT" class="headerlink" title="优化TIME_WAIT"></a>优化TIME_WAIT</h3><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em><br><strong>tcp_tw_reuse 功能只能用客户端（连接发起方），开启了该功能后，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong><br>前提：打开对 TCP 时间戳的支持，即打开了tcp_timestamps</p><p>结果：时间戳避免了2MSL问题。</p><p><em>方式二：net.ipv4.tcp_max_tw_buckets</em><br>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p><p><em>方式三：程序中使用 SO_LINGER</em><br>设置 socket 选项，来设置调用 close 关闭连接行为。<br>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><h2 id="服务端出现大量TIME-WAIT"><a href="#服务端出现大量TIME-WAIT" class="headerlink" title="服务端出现大量TIME_WAIT"></a>服务端出现大量TIME_WAIT</h2><p><em>第一个场景：HTTP 没有使用长连接</em><br><strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p><p>请求和响应的双方都可以主动关闭 TCP 连接。<strong>但根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接。</strong></p><p><em>第二个场景：HTTP 长连接超时</em><br>web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如nginx提供的keepalive_timeout参数。<br><strong>这种时候也是服务端主动关闭连接。</strong></p><p><em>第三个场景：HTTP 长连接的请求数量达到上限</em><br>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。<br>调大nginx的配置数量即可。</p><h2 id="服务端大量CLOSE-WAIT"><a href="#服务端大量CLOSE-WAIT" class="headerlink" title="服务端大量CLOSE_WAIT"></a>服务端大量CLOSE_WAIT</h2><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>分析一个普通的 TCP 服务端的流程：</p><ol><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll</li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ol><p>导致不会调用close的可能：</p><ol><li>第2步没有注册epoll，代码问题</li><li>第3步没有accept</li><li>第4步没有注册epoll</li><li>第6步没有执行close，代码问题</li></ol><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><div class="note note-primary">            <p>不好记，记下流程和结论就行。</p>          </div><h2 id="客户端突然故障"><a href="#客户端突然故障" class="headerlink" title="客户端突然故障"></a>客户端突然故障</h2><h3 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h3><blockquote><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p></blockquote><p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_keepalive_time</span>=<span class="hljs-number">7200</span><br><span class="hljs-attr">net.ipv4.tcp_keepalive_intvl</span>=<span class="hljs-number">75</span>  <br><span class="hljs-attr">net.ipv4.tcp_keepalive_probes</span>=<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>即一般2小时无信息就开始发送探测报文，9次无响应则断开，共2小时11分15秒。TCP 保活的这个机制检测的时间有点长，我们可以自己在应用层实现一个心跳机制。比如Web应用设置定时器，定时器一到如果没有请求就主动释放连接。</p><p>应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，客户端程序正常工作的。会响应探测信息，重置保活。</li><li>第二种，客户端程序崩溃，不会触发保活，操作系统会回收资源完成挥手。</li><li>第三种，客户端主机宕机并重启。回复RST，直接触发关闭。</li><li>第四种，客户端主机宕机或报文不可达。多次探测后关闭连接。</li></ul><blockquote><p>客户端也有保活机制！</p></blockquote><h2 id="服务端进程突然崩溃"><a href="#服务端进程突然崩溃" class="headerlink" title="服务端进程突然崩溃"></a>服务端进程突然崩溃</h2><p>主机操作系统自动完成挥手释放连接。</p><h1 id="四、Socket编程"><a href="#四、Socket编程" class="headerlink" title="四、Socket编程"></a>四、Socket编程</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207155558.png"><br>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个<strong>已完成连接的 socket</strong>，后续用来传输数据。<br>所以，监听的socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听socket</strong>，一个叫作<strong>已完成连接socket</strong>。</p><p>过程：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207155715.png"></p><ul><li>半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li><li>全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li></ul><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><p><strong>但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 &#x3D; min(backlog, somaxconn)，详情见下面的全连接，半连接章节。</strong></p><h3 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"><br><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><h3 id="close-断开流程"><a href="#close-断开流程" class="headerlink" title="close 断开流程"></a>close 断开流程</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207160043.png"></p><p>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</p><h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以</strong>，accept的作用就是从全连接队列中取出连接，然后对其进行读写，但其不参与连接的建立。</p><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以</strong>：</p><ol><li>客户端可以自连接。</li><li>两个客户端同时发起SYN可以互连。</li></ol><h1 id="五、TCP重传、滑动窗口、流量控制、拥塞控制"><a href="#五、TCP重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="五、TCP重传、滑动窗口、流量控制、拥塞控制"></a>五、TCP重传、滑动窗口、流量控制、拥塞控制</h1><h2 id="重传控制"><a href="#重传控制" class="headerlink" title="重传控制"></a>重传控制</h2><p>常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p><code>RTT</code>（往返时延）：指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong><br><code>RTO</code>（超时重传时间）：<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><ul><li>RTO过小导致不必要的重传</li><li>过大导致传输效率低下</li></ul><p>每次超时重传时将下次超时时间时间设置为先前的2倍。</p><h4 id="RTO计算"><a href="#RTO计算" class="headerlink" title="RTO计算"></a>RTO计算</h4><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/9.webp"><br>在 Linux 下，<strong>α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4</strong>。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>慢</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>客户端回复ACK中携带确认收到的报文，连续3个相同ACK表示通知系统重传。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>无法确定重传一条还是重传一批</p><h3 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h3><p><strong>选择性确认</strong>。<br>它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/11.webp"></p><p>要支持<code>SACK</code>需要双方都开启该功能。</p><h3 id="DSACK方法"><a href="#DSACK方法" class="headerlink" title="DSACK方法"></a>DSACK方法</h3><p>Duplicate SACK 又称 <code>D-SACK</code>。<strong>将接受到的重复消息发送给「发送方」</strong>。</p><p>可以配合超时重传或快传，指出哪些数据重复了：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/12.webp"></p><p><code>D-SACK</code> 有这么几个好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>在滑动窗口模式下，不用逐一等待ACK，实现批量发送、<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>TCP 头里有一个字段叫 <code>Window</code>：这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。</p><h3 id="发送方滑动窗口"><a href="#发送方滑动窗口" class="headerlink" title="发送方滑动窗口"></a>发送方滑动窗口</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/19.webp"><br>通过一个窗口大小，两个绝对指针可以得到可用窗口大小。</p><h3 id="接受方滑动窗口"><a href="#接受方滑动窗口" class="headerlink" title="接受方滑动窗口"></a>接受方滑动窗口</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/20.webp"><br>通过一个窗口大小，一个绝对指针表示窗口。每个小窗口内部记录了是否接受到了数据。</p><div class="note note-primary">            <p>接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>          </div><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>发送方接受到ACK后移动并调整窗口大小</li><li>接受方接受到Seq后移动窗口并调整窗口大小。</li></ul><h3 id="操作系统缓冲区"><a href="#操作系统缓冲区" class="headerlink" title="操作系统缓冲区"></a>操作系统缓冲区</h3><p>发送窗口和接收窗口中所存放的字节数，都放在<strong>操作系统内存缓冲区</strong>中。<br><em>情况一：应用程序读取慢</em><br>当接受方的应用程序没有及时获取已经送达的消息时：<br>接受方滑动窗口的右端不变，左端移动应用程序取走的比特数量，实现窗口缩小。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/22.webp"></p><p><em>情况二：服务器资源紧张</em><br>操作系统可能会直接减少了接收缓冲区大小：<br>这种情况下，可能另发送方调整后的右端比之前的右端还前面。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/23.webp"><br>即发送方发送了接受方不在窗口内的消息，导致数据包丢失。</p><p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p><div class="note note-primary">            <p>即保证右端不会左移动。</p>          </div><h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><h1 id="窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。-lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。-lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/24.webp"></h1><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/24.webp"></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>b4ec10f785adda690225747930324e4cddd2ece6</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h4 id="零窗口探测报文"><a href="#零窗口探测报文" class="headerlink" title="零窗口探测报文"></a>零窗口探测报文</h4><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong><br><strong>窗口探测 (Window probe) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><blockquote><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p></blockquote><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。<br>也就是为了几字节而发送一个TCP包，不值得。</p><p>发生：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据</li></ul><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>解决：</p><ul><li>让接收方不通告小窗口给发送方：<ul><li>当窗口大小小于<code>min(MSS，缓存空间/2）</code>时，通知发送方窗口为0。</li></ul></li><li>让发送方避免发送小数据：<ul><li><strong>Nagle算法</strong>：满足条件之一时才发送<ul><li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li><li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li></ul></li></ul></li></ul><p>Nagle：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/55.webp"></p><p><strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p><h4 id="延迟确认-1"><a href="#延迟确认-1" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul><li>当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方。</li><li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ul><p><strong>与窗口无关但也可以提高效率，避免小报文，同时其可能导致四次挥手变成三次。</strong></p><h4 id="Nagle算法和延迟确认混合使用"><a href="#Nagle算法和延迟确认混合使用" class="headerlink" title="Nagle算法和延迟确认混合使用"></a>Nagle算法和延迟确认混合使用</h4><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/61.webp"></p><ul><li>接受方因为延迟确认算法不回复。</li><li>发送方因为Nagle算法，不发送后续数据。</li><li>导致接收方等到延迟算法达到时间后（延迟算法：只在有新数据发送 或 达到延迟时间 或 接收到新数据后才回复）才回复，整体时延增加。</li></ul><p>解决：</p><ul><li>发送方关闭Nagle算法</li><li>接收方关闭TCP延迟确认</li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制主要考虑避免接受方接受得了。<br>拥塞控制主要考虑网络是否承担得了。</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><blockquote><p>发送窗口 swnd &#x3D; min(拥塞窗口cwnd，接受窗口rwnd)</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p><strong>当发送方每收到一个ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/27.webp"></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。<br><strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/28.webp"></p><h3 id="拥塞发送"><a href="#拥塞发送" class="headerlink" title="拥塞发送"></a>拥塞发送</h3><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><ul><li>超时重传：<ul><li><code>ssthresh</code> &#x3D; <code>cwnd/2</code>，即慢启动门限为当前的一半</li><li><code>cwnd</code> &#x3D; <code>1</code>，重置拥塞窗口。</li></ul></li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/29.webp"></p><ul><li>快速重传：<ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入<strong>快速恢复算法</strong>；</li></ul></li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>一般认为如果快速重传，网络问题应该不大，会进入快速恢复算法：<br>快速恢复算法：</p><ul><li><code>cwnd = ssthresh + 3</code></li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1，当收到新的ACK后，说明丢失数据包已经完成发送，恢复拥塞避免状态。</li><li><code>cwnd = ssthresh</code></li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.webp"></p><div class="note note-primary">            <p>快速恢复的观点是，丢失包是意外情况，想要尽快恢复正常，因此：</p><ol><li>更新门限和窗口（快速重传）。</li><li>紧急加大3个门限希望多发一些数据包。</li><li>当接受到新ACK后说明状态恢复，此时门限再回归拥塞避免状态。</li></ol>          </div><h1 id="六、TCP半连接队列和全连接队列"><a href="#六、TCP半连接队列和全连接队列" class="headerlink" title="六、TCP半连接队列和全连接队列"></a>六、TCP半连接队列和全连接队列</h1><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列，是一个Hash表，便于常数时间取出连接；</li><li>全连接队列，也称 accept 队列，是一个链表，只需取出头节点；</li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230208000041.png"></p><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/3.webp"><br>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，<strong>内核会直接丢弃，或返回 <code>RST</code> 包</strong>。</p><h2 id="TCP全连接溢出"><a href="#TCP全连接溢出" class="headerlink" title="TCP全连接溢出"></a>TCP全连接溢出</h2><p><strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接。</strong><br>丢掉的 TCP 连接的个数会被统计起来。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h4><p>丢弃连接是默认行为，可以通过调整策略修改行为。<br>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：</p><ul><li>0：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；</li><li>1：如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接；</li></ul><div class="note note-primary">            <p>即判断是否要回复RST，设置为0更好，因为一般全连接队列只是短暂的满了，不回复RST便于客户端重连。</p>          </div><h4 id="调大区间"><a href="#调大区间" class="headerlink" title="调大区间"></a>调大区间</h4><p>队列大小为<code>min(somaxconn, backlog)</code>，两者都要调大。</p><h2 id="TCP半连接溢出"><a href="#TCP半连接溢出" class="headerlink" title="TCP半连接溢出"></a>TCP半连接溢出</h2><h3 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h3><p><strong>半连接队列最大值</strong>不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系，即与全连接队列最大值有关。</p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li></ul><p><strong>其长度为max_syn_backlog和全连接队列长度中较小者的两倍</strong>。</p><p>溢出时，看是否开启了tcp_syncookies设置判断是否丢弃。</p><h3 id="舍弃行为"><a href="#舍弃行为" class="headerlink" title="舍弃行为"></a>舍弃行为</h3><p>对消息的舍弃行为行为如下：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/28-1.webp"></p><ol><li>半连接队列满了，没开tcp_syncookies，丢弃</li><li>全连接队列满了，且存在尚未重传第二次握手的连接（说明全连接队列还有有效连接），丢弃</li><li>没开tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)<strong>（即超过了配置数值&lt;不是理论最大值&gt;的3&#x2F;4）</strong>，则丢弃。</li></ol><h3 id="处于SYN-RECV状态的连接数量"><a href="#处于SYN-RECV状态的连接数量" class="headerlink" title="处于SYN_RECV状态的连接数量"></a>处于SYN_RECV状态的连接数量</h3><p>由于丢弃策略的第3点，半连接最大值依然只是一个理论最大值。</p><blockquote><p>Linux5.0后，理论最大值就是全连接最大值。</p></blockquote><h4 id="Syncookies"><a href="#Syncookies" class="headerlink" title="Syncookies"></a>Syncookies</h4><p><strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong><br>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h3 id="SYN攻击方式"><a href="#SYN攻击方式" class="headerlink" title="SYN攻击方式"></a>SYN攻击方式</h3><p>把TCP半连接队列打满。</p><h3 id="SYN攻击避免"><a href="#SYN攻击避免" class="headerlink" title="SYN攻击避免"></a>SYN攻击避免</h3><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li><li>减少 SYN+ACK 重传次数</li></ul><p><em>方式一：调大 netdev_max_backlog</em><br>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。扩大这个队列(默认为1000)。</p><p><em>方式二：增大半连接队列</em><br>同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.<code>tcp_max_syn_backlog</code></li><li>增大 listen() 函数中的 <code>backlog</code></li><li>增大 net.core.<code>somaxconn</code></li></ul><p><em>方式三：开启 net.ipv4.tcp_syncookies</em><br>不再保存半连接，而是给客户端发cookie，收到客户端ACK后再验证cookie。</p><p><em>方式四：减少 SYN+ACK 重传次数</em><br>此时会出现大量的二次握手重传，应该减少重传次数。</p><h1 id="七、TCP优化"><a href="#七、TCP优化" class="headerlink" title="七、TCP优化"></a>七、TCP优化</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/4.webp"></p><h2 id="握手优化"><a href="#握手优化" class="headerlink" title="握手优化"></a>握手优化</h2><h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><p>适当调低重传次数<strong>tcp_syn_retries</strong></p><h3 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h3><h4 id="半连接"><a href="#半连接" class="headerlink" title="半连接"></a>半连接</h4><ul><li>扩大半连接队列大小：<strong>tcp_max_syn_backlog</strong>、<strong>somaxconn</strong>、<strong>backlog</strong></li><li>开启<strong>syncookies</strong>功能</li><li>修改第二次握手的重传次数<strong>tcp_synack_retries</strong></li></ul><h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><ul><li>扩大全连接队列大小：<strong>somaxconn</strong>、<strong>backlog</strong></li></ul><h3 id="如何绕开三次握手"><a href="#如何绕开三次握手" class="headerlink" title="如何绕开三次握手"></a>如何绕开三次握手</h3><p>TCP Fast Open，第一次派发一个cookie（不同于syncookies，那个是用于绕开全连接和半连接队列的）<br>开启方式：<strong>tcp_fastopn</strong></p><h2 id="挥手优化"><a href="#挥手优化" class="headerlink" title="挥手优化"></a>挥手优化</h2><h3 id="主动方"><a href="#主动方" class="headerlink" title="主动方"></a>主动方</h3><p>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。</p><ul><li>close(int sock)：函数意味着完全断开连接。</li><li>shutdown(int sock,int howto)：控制只关闭 读&#x2F;写&#x2F;双向 方向的连接。</li></ul><h4 id="FIN-WAIT1优化"><a href="#FIN-WAIT1优化" class="headerlink" title="FIN_WAIT1优化"></a>FIN_WAIT1优化</h4><ul><li>调低<strong>tcp_orphan_retries参数（默认8次）控制</strong></li><li>调低<strong>tcp_max_orphans 参数，它定义了「孤儿连接」的最大数量</strong>，新的孤儿连接直接发送RST强制关闭。</li><li>设置close关闭行为，即客户端可以强行关闭。</li></ul><h4 id="FIN-WAIT2优化"><a href="#FIN-WAIT2优化" class="headerlink" title="FIN_WAIT2优化"></a>FIN_WAIT2优化</h4><ul><li>shutdown关闭时，可一直维持该状态</li><li>close关闭时，<strong>tcp_fin_timeout</strong>标出了最大持续时长，目的与TIME_WAIT类似。</li></ul><h4 id="TIME-WAIT优化"><a href="#TIME-WAIT优化" class="headerlink" title="TIME_WAIT优化"></a>TIME_WAIT优化</h4><ul><li><strong>tcp_max_tw_buckets参数</strong>限制TIME_WAIT数量。</li><li><strong>tcp_tw_reuse</strong>复用TIME_WAIT连接，同时还要双方开启时间戳。</li></ul><p>时间戳作用：</p><ul><li>防止过期数据</li><li>防止序列号绕回</li></ul><p>PAWS坑：<br>老版本的 Linux 还提供了 <code>tcp_tw_recycle</code> 参数，但是当开启了它，允许处于 TIME_WAIT 状态的连接被快速回收，但是有个<strong>大坑</strong>，现在已经关掉这个参数了。</p><p>开启了 recycle 和 timestamps 选项，就会开启一种叫 per-host 的 PAWS（判断TCP 报文中时间戳是否是历史报文） 机制，<strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>，而非对「IP + 端口」四元组做 PAWS 检查。因此如果客户端通过NAT与服务器建立连接，另一个客户端可能与其复用IP，但两者时间戳可能不一样，导致错误丢弃。</p><div class="note note-primary">            <p>SHUTDOWN比CLOSE优雅，但CLOSE仍然是主流的断开连接方式，并且可以指定CLOSE行为（挥手或直接RST）</p>          </div><h3 id="被动方"><a href="#被动方" class="headerlink" title="被动方"></a>被动方</h3><h4 id="CLOSE-WAIT优化"><a href="#CLOSE-WAIT优化" class="headerlink" title="CLOSE_WAIT优化"></a>CLOSE_WAIT优化</h4><p>调低tcp_orphan_retries 参数</p><blockquote><p>另外，close如果被迅速调用，四次挥手可能变成三次。<br>也可以理解成延时响应。</p></blockquote><p><strong>如果双方同时关闭连接？</strong><br>同时关闭，出现了一个新状态（CLOSING）<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/38.webp"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>滑动窗口大小：TCP可选字段中指明窗口扩大因子。</li><li>最大传输速度：发送缓冲区大小最好与带宽时延积靠近。</li><li>缓冲区：<ul><li>发送缓冲区是自行调节的。</li><li>接受缓冲区可以配置开启，根据系统空闲来接受窗口。</li></ul></li><li>TCP内存范围：<strong>调大 tcp_mem 的上限</strong>扩大TCP内存。</li></ul><h1 id="八、如何确定序列号和确认号"><a href="#八、如何确定序列号和确认号" class="headerlink" title="八、如何确定序列号和确认号"></a>八、如何确定序列号和确认号</h1><ul><li>序列号 &#x3D; <strong>上一次发送</strong>的序列号 + len（数据长度）。<ul><li>特殊情况，如果<strong>上次发送</strong>的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li></ul></li><li>确认号 &#x3D; <strong>上一次收到</strong>的报文中的序列号 + len（数据长度）。<ul><li>特殊情况，如果<strong>上次收到</strong>的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li></ul></li></ul><div class="note note-primary">            <p>总结就是上次序列号+数据长度，但SYN和FIN作为主动发出的控制，都需要占用1个syn。<br>ack表示期待的下一个收到的syn报文。</p>          </div><h1 id="九、QUIC"><a href="#九、QUIC" class="headerlink" title="九、QUIC"></a>九、QUIC</h1><h2 id="TCP协议的缺点"><a href="#TCP协议的缺点" class="headerlink" title="TCP协议的缺点"></a>TCP协议的缺点</h2><ul><li>升级 TCP 的工作很困难：内核实现</li><li>TCP 建立连接的延迟：3次握手</li><li>TCP 存在队头阻塞问题：滑动窗口队头阻塞</li><li>网络迁移需要重新建立 TCP 连接：四元组发生变化</li></ul><h2 id="UDP可靠传输QUIC"><a href="#UDP可靠传输QUIC" class="headerlink" title="UDP可靠传输QUIC"></a>UDP可靠传输QUIC</h2><p>解决了TCP的缺点</p><ul><li>升级容易（随浏览器升级，应用层实现）</li><li>快速连接（配合TLS1.3，1RTT即可实现首次连接，0RTT实现二次连接）</li><li>只存在单个Stream对队头阻塞</li><li>无感迁移（靠连接ID识别）</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/ab3283383013b707d1420b6b4cb8517c.webp"></p><h3 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207231330.jpg"><br>Packet Header 细分这两种：</p><ul><li>Long Packet Header 用于首次建立连接。</li><li>Short Packet Header 用于日常传输数据。</li></ul><p><em>握手次数</em><br><strong>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。</strong></p><p>Short Packet Header 中的 <code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>。</p><blockquote><p>TCP无法区分ACK是对原始报文还是重传报文的响应，因为ack值相同，但SYN重传时Packet Number也不一样，从而便于计算RTT和RTO。</p></blockquote><p>此外，QUIC 使用的Packet Number单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持<strong>乱序确认</strong>，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动。</p><p><em>重传问题</em><br>重传时编号比原始编号大。与乱序确认一起解决了队头阻塞问题。</p><h3 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h3><p>一个 Packet 报文中可以存放多个 QUIC Frame。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207232037.png"></p><h3 id="Fream结构"><a href="#Fream结构" class="headerlink" title="Fream结构"></a>Fream结构</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207232139.jpg"></p><ul><li>Stream ID：区别真正的消息ID，便于组装</li><li>Offset：指出负载数据在消息体中的偏移，保证顺序和可靠性。</li></ul><blockquote><p>如何确定两个Packet相同，即是重传的：<br>通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="如何解决队头阻塞问题？"><a href="#如何解决队头阻塞问题？" class="headerlink" title="如何解决队头阻塞问题？"></a>如何解决队头阻塞问题？</h3><p>HTTP&#x2F;2通过Stream解决了HTTP消息阻塞（不同Stream可以乱序），但无法避免TCP阻塞。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/http2%E9%98%BB%E5%A1%9E.webp"><br><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/quic%E6%97%A0%E9%98%BB%E5%A1%9E.webp"><br>即如果Stream2丢了UDP包，只影响Stream2的处理。</p><h3 id="如何实现流量控制"><a href="#如何实现流量控制" class="headerlink" title="如何实现流量控制"></a>如何实现流量控制</h3><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><h4 id="Stream-级别的流量控制"><a href="#Stream-级别的流量控制" class="headerlink" title="Stream 级别的流量控制"></a>Stream 级别的流量控制</h4><p>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p><p>**接收窗口的流控：接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</p><p><strong>接收窗口的滑动</strong>：当已经上交给应用的数据达到最大接受窗口的一半时进行滑动。</p><h4 id="Connection-流量控制"><a href="#Connection-流量控制" class="headerlink" title="Connection 流量控制"></a>Connection 流量控制</h4><p>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</p><h1 id="X：列举问题"><a href="#X：列举问题" class="headerlink" title="X：列举问题"></a>X：列举问题</h1><h3 id="SYN报文什么时候情况下会被丢弃？"><a href="#SYN报文什么时候情况下会被丢弃？" class="headerlink" title="SYN报文什么时候情况下会被丢弃？"></a>SYN报文什么时候情况下会被丢弃？</h3><ul><li>半连接、全连接队列数量限制且没开syncookies设置。</li><li>为了复用TIME_WAIT开启tcp_tw_recycle，开启了时间戳，在NAT网络下消息过期被丢弃。</li></ul><h3 id="已建立连接的TCP，收到SYN会发生什么？"><a href="#已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="已建立连接的TCP，收到SYN会发生什么？"></a>已建立连接的TCP，收到SYN会发生什么？</h3><ol><li>客户端的SYN报文里的端口号与历史连接不相同：建立新连接。</li><li>客户端的SYN报文里的端口号与历史连接相同：<ul><li>服务端回复ACK（Challenge ACK：包含正确的序列号和确认号）。</li><li>客户端回复RST（即这个ACK处理不了）</li></ul></li></ol><h3 id="收到乱序的FIN包如何处理"><a href="#收到乱序的FIN包如何处理" class="headerlink" title="收到乱序的FIN包如何处理"></a>收到乱序的FIN包如何处理</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207222312.png"><br><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p><p>等收到延迟的数据包后检查乱序队列，若该队列中有可用数据，且数据有FIN标志，则进入TIME_WAIT状态。</p><h3 id="在TIME-WAIT状态的TCP连接，收到-SYN-后会发生什么？"><a href="#在TIME-WAIT状态的TCP连接，收到-SYN-后会发生什么？" class="headerlink" title="在TIME_WAIT状态的TCP连接，收到 SYN 后会发生什么？"></a>在TIME_WAIT状态的TCP连接，收到 SYN 后会发生什么？</h3><p><strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong></p><ul><li>序列号比期望的大</li><li>时间戳要比上次收到的要大</li></ul><p>处理：</p><ul><li>合法则重用四元组连接。</li><li>非法<ul><li>主动端回复第四次ACK</li><li>被动端发现不是自己期待的就发送RST</li><li>主动方接受RST：看<code>net.ipv4.tcp_rfc1337</code> 这个内核参数<ul><li>参数设置为 0，则提前结束TIME_WAIT</li><li>参数设置为 1，则丢掉RST</li></ul></li></ul></li></ul><div class="note note-primary">            <p>接收方发现非法SYN会回复正确（Challenge）的ACK。<br>发送方发现非法ACK会回复RST。</p>          </div><h3 id="TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="TCP 连接，一端断电和进程崩溃有什么区别？"></a>TCP 连接，一端断电和进程崩溃有什么区别？</h3><h4 id="无数据传输"><a href="#无数据传输" class="headerlink" title="无数据传输"></a>无数据传输</h4><p><strong>断电</strong>：过一段时间进入保活，然后关闭<br><strong>进程崩溃</strong>：直接释放，进行挥手</p><h4 id="有数据传输"><a href="#有数据传输" class="headerlink" title="有数据传输"></a>有数据传输</h4><p><strong>客户端主机宕机，又迅速重启</strong>：</p><ol><li>服务端超时重传。</li><li>客户端重启后若无论端口是否被绑定，都会回复RST。</li></ol><p><strong>客户端主机宕机，一直没有重启</strong>：</p><ol><li>服务器超时重传（<code> tcp_retries2</code>，默认15次），然后断开连接。</li></ol><h3 id="拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗？"></a>拔掉网线后， 原本的 TCP 连接还存在吗？</h3><p>本质和数据丢包一样，若有数据则超时重传，没有则等保活。</p><h3 id="tcp-tw-reuse-为什么默认是关闭的？"><a href="#tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="tcp_tw_reuse 为什么默认是关闭的？"></a>tcp_tw_reuse 为什么默认是关闭的？</h3><p>以下两种方式都默认关闭：</p><ul><li>net.ipv4.tcp_tw_reuse，连接时发现<strong>相同四元组</strong>的连接在TIME_WAIT状态则复用。</li><li>net.ipv4.tcp_tw_recycle，由于PWSA机制，NAT网络下不安全。</li></ul><p>tw的2MSL是很重要的：</p><ul><li>RST报文即使时间戳过期也会被处理，关闭正常连接。</li><li>服务端无法正确关闭，不优雅。</li></ul><h3 id="TLS和TCP可以同时握手吗"><a href="#TLS和TCP可以同时握手吗" class="headerlink" title="TLS和TCP可以同时握手吗"></a>TLS和TCP可以同时握手吗</h3><p>只有以下两点同时满足：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><p>利用TCP Fast Open第二次连接时只需要发送cookie，可以同时携带TLS1.3的第二次连接时的会话恢复机制，1RTT即可完成握手。</p><h3 id="TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h3><h4 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h4><p>应用层不主动释放TCP连接，而是复用该TCP连接。</p><h4 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h4><p>在没有数据交互的情况下，探测目标是否存活的保活机制。</p><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p>可以，两套独立模块<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97-1.webp"></p><h3 id="多个TCP服务进程可以bind同一个端口吗？"><a href="#多个TCP服务进程可以bind同一个端口吗？" class="headerlink" title="多个TCP服务进程可以bind同一个端口吗？"></a>多个TCP服务进程可以bind同一个端口吗？</h3><p>不行，绑定相同IP和Port时不行。</p><h4 id="同一个TCP服务进程如何复用TCP连接"><a href="#同一个TCP服务进程如何复用TCP连接" class="headerlink" title="同一个TCP服务进程如何复用TCP连接"></a>同一个TCP服务进程如何复用TCP连接</h4><blockquote><p>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？<br>因为有TIME_WAIT状态，服务器进程可以bind前开启<strong>SO_REUSEADDR</strong>，即仅针对自己这个进程的TW复用。</p></blockquote><h4 id="绑定不同IP相同Port可行吗"><a href="#绑定不同IP相同Port可行吗" class="headerlink" title="绑定不同IP相同Port可行吗"></a>绑定不同IP相同Port可行吗</h4><p>一般可行，但有特例：</p><blockquote><p>注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p><p>这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。</p></blockquote><p>开启<strong>SO_REUSEADDR</strong>后，只要求IP和端口不完全一样即可，所以这个特例也变成可行的。</p><h3 id="多个客户端可以bind同一个端口吗"><a href="#多个客户端可以bind同一个端口吗" class="headerlink" title="多个客户端可以bind同一个端口吗"></a>多个客户端可以bind同一个端口吗</h3><blockquote><p>客户端是在调用 connect 函数的时候，由内核随机选取一个端口作为连接的端口。<br>而如果我们想自己指定连接的端口，就可以用 bind 函数来实现：客户端先通过 bind 函数绑定一个端口，然后调用 connect 函数就会跳过端口选择的过程了，转而使用 bind 时确定的端口。</p></blockquote><p>其他同上一个问题。</p><h3 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h3><p>TCP由四元组做区分，在所有IP相同情况下：</p><ul><li>访问不同的服务器（目标IP和目标端口不同），总是可以复用。</li><li>访问同一个服务器，则端口有冲突，但很少不够用导致重复。</li></ul><blockquote><p>客户端TCP连接TIME_WAIT状态过多，会导致端口资源耗尽而无法建立新的连接吗？<br>与上个问题类似。</p></blockquote><blockquote><p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？<br>开启tw_reuse，若TIME_WAIT超过1s，则可以复用。</p></blockquote><p>客户端端口选择：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.webp"></p><h3 id="服务端没有listen，可以建立连接吗"><a href="#服务端没有listen，可以建立连接吗" class="headerlink" title="服务端没有listen，可以建立连接吗"></a>服务端没有listen，可以建立连接吗</h3><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><div class="note note-primary">            <p>bind只是表示进程会占用该端口发送消息，只有listen后才会创建全连接队列，半连接队列。</p>          </div><p><strong>不使用listen，可以建立连接吗？</strong><br>与服务端必须开启listen不同，主机内核有个全局 hash 表，可以用于存放 sock 连接的信息。<br>当<strong>客户端</strong>调用connect函数时，会将该sock信息放入表中，因此可以实现连接一般有两种情况：</p><ul><li>客户端自连接</li><li>两个客户端互相连接</li></ul><div class="note note-primary">            <p>服务端listen后，创建队列接受处理连接。<br>客户端connect后，自己的连接信息放入内核hash处理连接。</p>          </div><h3 id="没有-accept，能建立-TCP-连接吗？-1"><a href="#没有-accept，能建立-TCP-连接吗？-1" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>执行accept()只是为了从全连接队列里取出一条连接。</strong><br>不干涉TCP握手的建立。</p><h3 id="队列满了的行为"><a href="#队列满了的行为" class="headerlink" title="队列满了的行为"></a>队列满了的行为</h3><ul><li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li><li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li></ul><h3 id="四次挥手可以变成三次吗"><a href="#四次挥手可以变成三次吗" class="headerlink" title="四次挥手可以变成三次吗"></a>四次挥手可以变成三次吗</h3><p>可以，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><h3 id="TCP一定可靠吗？"><a href="#TCP一定可靠吗？" class="headerlink" title="TCP一定可靠吗？"></a>TCP一定可靠吗？</h3><p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong><br>如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTP</title>
    <link href="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    <url>/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>超文本传输协议，<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><ul><li>协议：HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</li><li>传输：HTTP 协议是一个<strong>双向协议</strong>。</li><li>超文本：<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li></ul><p>总结：<br><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.webp"><br><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。<br><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 </li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h2><ul><li>Accept: 可接受的数据格式</li><li>Host 字段：服务器域名</li><li>Connection 字段：使用长连接<br>  即复用同一个TCP连接，HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li><li>Content-Length 字段：数据长度，为了解决粘包</li><li>Content-Type：本次数据格式</li><li>Content-Encoding：数据的压缩方法</li></ul><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>get：语义是获取资源（可放入body也可放入url）<br>post：语义是操作资源（请求参数放入body）</p><h3 id="GET和POST方法都是安全和幂等的吗？"><a href="#GET和POST方法都是安全和幂等的吗？" class="headerlink" title="GET和POST方法都是安全和幂等的吗？"></a>GET和POST方法都是安全和幂等的吗？</h3><p>安全：不破坏服务器资源<br>幂等：多次执行结果不变</p><ul><li><strong>GET 方法就是安全且幂等的</strong>（可做缓存）。</li><li><strong>POST</strong> <strong>方法不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。（<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>）。</li></ul><blockquote><p>实际上开发者也可以不遵守这个规定。</p></blockquote><h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><p>本地缓存的方式有：<strong>强制缓存和协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>HTTP响应头可以表示资源的缓存时间：</p><ul><li><code>Cache-Control</code>，是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>其中，<strong>Cache-Control 的优先级高于 Expires</strong>。<br>强制缓存：只要不过期，肯定直接返回。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%BC%93%E5%AD%98etag.webp"><br>协商缓存：<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>实现方法：<br>方法一：时间戳</p><ul><li>响应头中的<code>Last-Modified</code>：资源最后的修改时间</li><li>请求头中的<code>If-Modified-Since</code>：告诉服务器上次接受资源的时间</li></ul><p>即客户端接受到第一次访问的数据中发现有<code>Last-Modified</code>字段，再次请求时会携带<code>If-Modified-Since</code>字段（值为<code>Last-Modified</code>），服务器通过判断<code>Last-Modified</code>是否过期判断回复最新结果200还是无修改304。</p><p>方法二：E-tag</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：告诉服务器上次接受资源的ID。</li></ul><p>原理相同。<br>由于方法一的时间戳可能背篡改导致不可靠，主要使用方法二，且<strong>Etag的优先级更高</strong>。</p><p><strong>Etag的优点</strong>：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><div class="note note-primary">            <p>这些Last-Modified的缺点与TCP连接的TW-REUSE开启之后使用时间戳的缺点类似。</p>          </div><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><h1 id="二、HTTP特性"><a href="#二、HTTP特性" class="headerlink" title="二、HTTP特性"></a>二、HTTP特性</h1><p>到目前为止，HTTP 常见到版本有 <code>HTTP/1.1</code>，<code>HTTP/2.0</code>，<code>HTTP/3.0</code>，不同版本的 HTTP 特性是不一样的。</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>HTTP 最突出的优点是「简单(格式简单)、灵活和易于扩展（在应用层请求头和响应头可扩展）、应用广泛和跨平台」。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>长连接</li><li>管道网络传输，解决了请求的队头阻塞。</li></ul><h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><h5 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h5><p>在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.webp"></p><p><strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。<br>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。<br><strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="传输上"><a href="#传输上" class="headerlink" title="传输上"></a>传输上</h4><ul><li>数据量大</li><li>响应阻塞</li></ul><h4 id="安全性上"><a href="#安全性上" class="headerlink" title="安全性上"></a>安全性上</h4><ul><li>无状态：无状态使服务器不用记忆http状态，但关联性操作会比较麻烦。可使用cookie技术解决。</li><li>明文传输：信息容易被爬</li><li>不安全：<ul><li>明文导致密码泄露</li><li>假网站</li><li>无法证明报文完整性</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="与HTTP的区别"><a href="#与HTTP的区别" class="headerlink" title="与HTTP的区别"></a>与HTTP的区别</h3><ul><li>HTTPS 则解决 <strong>HTTP 不安全</strong>的缺陷，在TCP和HTTP网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h3><p>窃听、篡改、冒充</p><h3 id="HTTPS解决的方法"><a href="#HTTPS解决的方法" class="headerlink" title="HTTPS解决的方法"></a>HTTPS解决的方法</h3><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li></ul><div class="note note-primary">            <p>对称加密：就是一个密钥加密，并使用同一个密钥解密。<br>非对称加密：一个密钥加密，必须由另一个密钥解密。</p><p>其中非对称加密一般分公钥和私钥，这两个钥匙可以双向加解密。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；（防窃听）</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。（防冒充）</li></ul>          </div><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p><strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>。（防修改）</p><p><strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><div class="note note-primary">            <p>摘要只保证正文未被修改，不保证正文真伪。</p>          </div><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>数字签名算法</strong>，使用<strong>非对称加密算法</strong>加密哈希值（摘要）。</p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.webp"></p><p>由于中间人无法将数据使用私钥加密，其伪造的hash无法被公钥解密，所以可以得知数据被人替换过了。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>摘要和签名算法已经保证了数据不会被篡改和不被冒充。<br>但实现过程中存在漏洞：公钥的获取，客户端需要根据公钥来识别数字签名。</p><p><strong>数字证书认证机构</strong>CA：</p><ul><li>服务器可以将自己的公钥注册到CA机构，CA使用私钥将其加密后颁发数字证书。</li><li>客户端根据服务器发送的证书和公钥，将其使用CA公钥解开对比即可得知其是否得到了CA的信任。</li></ul><p>验证流程：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp"></p><h3 id="TLS握手阶段"><a href="#TLS握手阶段" class="headerlink" title="TLS握手阶段"></a>TLS握手阶段</h3><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp"></p><p>TLS 协议建立的详细流程：<br><em>1. ClientHello</em><br>客户端向服务器发送以下信息（明文）：<br>（1）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。<br>（2）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em><br>服务器回应的内容有如下内容（明文）：<br>（1）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。<br>（2）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</p><p><em>3.客户端回应</em><br>验证CA证书，取出公钥，并使用公钥加密（服务器公钥加密）：<br>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><blockquote><p>由于使用服务器公钥加密，所以只有服务器可以解密得知pre-master-key，即第三个随机数中间人无法获取。</p></blockquote><p><em>4. 服务器的最后回应</em><br>计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><blockquote><p>第三、四次握手只有第三次握手传了第三个随机数，剩下的两个内容类似TCP握手协议中的FIN，ACK确认。</p></blockquote><h3 id="TLS握手算法"><a href="#TLS握手算法" class="headerlink" title="TLS握手算法"></a>TLS握手算法</h3><p>不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的。<br>过程：与上面的过程相同。<br><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。一旦服务端的私钥泄漏了，过去被第三方截获的所有TLS通讯密文都会被破解。</p><h4 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h4><p>ECDHE 密钥协商算法是 DH 算法演进过来的。</p><h5 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h5><p>DH算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.webp"></p><ul><li>底数a和模数p是离散对数的公共参数，也就说是公开的。</li><li>b是真数（私钥），i是对数（公钥）。</li><li>知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</li></ul><h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>通讯双方各自根据自己的私钥，使用固定算法得到自己的公钥并交换。<br>根据得到的对方公钥，和自己的私钥计算，双方此时得到相同的密钥。<br>（这个算法具有交换律）</p><h5 id="DHE"><a href="#DHE" class="headerlink" title="DHE"></a>DHE</h5><p>根据私钥生成的方式，DH 算法分为两种实现：</p><ul><li>static DH 算法，这个是已经被废弃了；</li><li>DHE 算法，现在常用的；</li></ul><p>static DH不具有前向安全性，后者表示每次动态生成密钥。</p><h5 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h5><p>为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。利用了ECC 椭圆曲线特性。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p><strong>在TLS第四次握手前，客户端就已经发送了加密的 HTTP 数据，即ECDHE相比RSA握手过程省去了一个消息往返的时间</strong>。</p><ul><li>第一次握手与RSA类似</li><li>第二次握手新增了选择椭圆曲线和基点，动态生成了私钥和公钥，同时使用<strong>RSA签名算法</strong>给公钥签名并发送。</li><li>第三次握手验证CA后根据椭圆信息也生成私钥和公钥，并回复公钥。</li><li>第四次握手类似，回复确认过程没问题即可。</li></ul><div class="note note-primary">            <ul><li>ECDHE每次动态生成密钥和公钥，支持前向保密。</li><li>客户端可以在三次握手后就开始传输数据</li><li>在 TLS 第2次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li><li>依然使用了RSA算法，服务端使用了static私钥签名曲线公钥，用于保证发送的公钥不被篡改。</li></ul>          </div><h4 id="证书校核"><a href="#证书校核" class="headerlink" title="证书校核"></a>证书校核</h4><p>颁发和校核流程：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp"><br>信任链：<br>我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.webp"><br>验证链：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E9%93%BE.webp"></p><p>为何不直接由Root CA验证：<br><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p><h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p><em>SSL&#x2F;TLS</em>：SSL 是 “_Secure Sockets Layer_” 的缩写，中文叫做「安全套接层」。其标准化之后的名称改为 TLS（ “_Transport Layer Security_” ），即「传输层安全协议」。</p><p>_TLS1.3_：TLS1.3相对TLS1.2做了优化，其只需要<strong>3次</strong>握手：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/tls1.2and1.3-1.webp"></p><ul><li><strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</li><li>由于省去算法协商，直接互相交换使用相同算法计算过的公钥即完成了交换和计算，从而只需要3次握手（1RTT）。</li><li>重连时，使用Ticket技术优化的话可以在0RTT内完成重连(<strong>会话恢复机制</strong>)。</li></ul><h3 id="HTTPS的应用数据是如何保证完整性的？"><a href="#HTTPS的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS的应用数据是如何保证完整性的？"></a>HTTPS的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp"></p><p>具体过程如下：</p><ul><li>切割消息并压缩。</li><li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>通过对称密码进行加密。</li><li>加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><h3 id="HTTPS一定可靠吗？"><a href="#HTTPS一定可靠吗？" class="headerlink" title="HTTPS一定可靠吗？"></a>HTTPS一定可靠吗？</h3><p>如前面说的，HTTPS中CA部分是为了防止冒充，但这里中间人自己有证书，从而实现了服务代理。但这种证书其实是非法的，只要用户不主动接受非法证书，否则是不会出现问题的。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.webp"></p><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h3 id="如何避免被抓包"><a href="#如何避免被抓包" class="headerlink" title="如何避免被抓包"></a>如何避免被抓包</h3><ol><li>不点击允许非法证书（中间人攻击）</li><li>HTTPS双向认证，即服务端也要验证客户端信息。</li></ol><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><strong>HTTP&#x2F;2协议是基于HTTPS的。</strong><br>其兼容了老版本的HTTP&#x2F;1.1，即其仍使用http表示明文，https表示加密，而浏览器和服务器可以在背后实现协议升级。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/25-HTTP2.webp"></p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>主动推送</li></ul><div class="note note-primary">            <p>2个特点压缩信息，2个特点加强传输。</p>          </div><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>使用<code>HPACK</code>算法，维护一张头信息表，为每个头信息生成一个id号，以后就可以只传id。</p><h4 id="HPACK算法"><a href="#HPACK算法" class="headerlink" title="HPACK算法"></a>HPACK算法</h4><ul><li>静态字典：有61种固定id和对应含义；</li><li>动态字典：自行构建动态表，发送一次后，双方都会更新自己的动态表（一个id保存本次所有Header字段），下次可以只发id；<ul><li>动态表生效前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。因此会造成内存占用过大，服务器一般会配置参数限制动态表大小，达到数量后关闭HTTP&#x2F;2连接来释放内存。</li></ul></li><li>Huffman 编码（压缩算法）；</li></ul><p>另外由于使用二进制表达，也不需要冒号空格和末尾的<code>\r\n</code>作为分隔符了，改用表示字符串长度（Value Length）来分割 Index 和 Value，一个Header字段：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224430.png"></p><h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>头信息和数据体都直接为二进制格式，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp"><br>这样解析数据时，可以直接解析二进制文件。</p><h4 id="二进制帧结构"><a href="#二进制帧结构" class="headerlink" title="二进制帧结构"></a>二进制帧结构</h4><h1 id="帧长度后面的一个字节是表示帧的类型，HTTP-x2F-2-总共定义了-10-种类型的帧，一般分为数据帧和控制帧两类。-帧类型后面的一个字节是标志位，可以保存-8-个标志位，用于携带简单的控制信息。-lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#帧长度后面的一个字节是表示帧的类型，HTTP-x2F-2-总共定义了-10-种类型的帧，一般分为数据帧和控制帧两类。-帧类型后面的一个字节是标志位，可以保存-8-个标志位，用于携带简单的控制信息。-lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="- 帧长度后面的一个字节是表示帧的类型，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为数据帧和控制帧两类。- 帧类型后面的一个字节是标志位，可以保存 8 个标志位，用于携带简单的控制信息。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224926.png"><br>- 帧长度后面的一个字节是表示<strong>帧的类型</strong>，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类。<br>- 帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息。<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>b4ec10f785adda690225747930324e4cddd2ece6</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h3 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h3><p>HTTP&#x2F;1.1使用<strong>请求-响应</strong>模型，因此会产生对头阻塞。<br>HTTP&#x2F;2引入了Stream概念，使多个stream复用一个TCP连接：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/stream.webp"></p><blockquote><p>1 个 TCP 连接包含多个 Stream。<br>1 个 Stream 里可以包含多个 Message。<br>1 个 Message 对应 HTTP&#x2F;1 中的1个请求或响应，可以包含多个Frame</p></blockquote><p>每个HTTP请求（Message）都有独一无二的<strong>SteamID</strong>，这样接受端可以通过StreamID将多个Frame有序组装成一个HTTP消息。</p><ul><li>不同StreamID是可以乱序发送的。</li><li>相同Stream的frame必须有序发送。</li></ul><p>HTTP&#x2F;2 还可以对每个 Stream 设置不同<strong>优先级</strong>，在枕头中的标志位展示。</p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.webp"></p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID也是有区别的：</p><ul><li>客户端建立的Stream必须是奇数号。</li><li>服务器建立的Stream必须是偶数号。</li></ul><p>如下：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206191054.png"><br>应用有：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/push.webp"><br>主动推送css文件。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>还是存在队头阻塞问题，问题出在TCP层面。</li></ul><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><ul><li><strong>使用UDP，解决了TCP的阻塞问题。</strong></li><li>然后使用<strong>QUIC协议</strong>实现UDP可靠传输。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>特点：</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><p><em>1、无队头阻塞</em><br>多路复用，类似HTTP&#x2F;2的stream，但不受限于TCP了。<br><strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。<br>这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响（TCP）。</p><p><em>2、更快的连接建立</em><br>HTTP&#x2F;3 在传输数据前需要 QUIC 协议3次握手，需要 1 RTT。握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，其内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 <strong>TLS&#x2F;1.3</strong>，因此仅需 <strong>1 个 RTT</strong> 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.webp"><br>对于第二次连接，应用数据包+QUIC(TLS+连接信息)，可以实现0-RTT。</p><p>以下是TCP+TLS1.2，TCL+TLS1.3，QUIC三种情况在首次和再次需要的RTT时间：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206210341.png"></p><div class="note note-primary">            <p><strong>RTT是针对客户端建立连接耗时。</strong><br>TCP+TLS1.2：</p><ul><li>首次：TCP三次握手+TLS四次握手（TCP第三次握手合并TLS第一次握手，最后合并为6个）：3RTT</li><li>再次：TCP三次握手+TLS两次握手（TCP第三次握手合并TLS第一次握手，TLS使用Session技术，合并为4个）：2RTT<br>TCP+TLS1.3:</li><li>首次：TCP三次握手+TLS三次握手（TCP第三次握手合并TLS第一次握手，合并为5个）：2RTT</li><li>再次：TCP三次握手+TLS零次握手（TCP第三次握手合并TLS第一次握手，TLS使用Ticket技术，合并为3个）：1RTT<br>QUIC+TLC1.3：</li><li>首次：QUIC三次握手+TLS三次握手（全程合并，为3个）：1RTT</li><li>再次：QUIC一次握手+TLS零次握手（QUIC连接迁移，TLS使用Ticket技术，合并为1个）：0RTT</li></ul><p>RTT记忆：32,21,10。</p>          </div><p><em>3、连接迁移</em><br>四元组确定一个独立的<strong>TCP</strong>连接。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206211242.png"><br><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。</p><p>QUIC 协议没通过<strong>连接 ID</strong> 来标记通信的两个端点。只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，达到了<strong>连接迁移</strong>的功能。</p><blockquote><p>QUIC 比较新，而又是基于 UDP 实现的，如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p></blockquote><h4 id="帧格式对比"><a href="#帧格式对比" class="headerlink" title="帧格式对比"></a>帧格式对比</h4><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206225705.png"></p><ul><li>类型：大体上分为数据帧和控制帧两大类，Headers 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</li><li>压缩：头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。</li><li>相比HTTP&#x2F;2，HTTP&#x2F;3的静态扩大了，动态表的解码方式不同，QPACK解决了该问题：使用两个特殊的单向流，实现字典的请求同步和响应。</li></ul><blockquote><p>动态表具有时序性，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。</p></blockquote><h1 id="三、HTTP1-1优化"><a href="#三、HTTP1-1优化" class="headerlink" title="三、HTTP1.1优化"></a>三、HTTP1.1优化</h1><p>我们可以从下面这三种优化思路来优化 HTTP&#x2F;1.1 协议：</p><ul><li>_尽量避免发送 HTTP 请求_；</li><li>_在需要发送 HTTP 请求时，考虑如何减少请求次数_；</li><li>_减少服务器的 HTTP 响应的数据大小_；</li></ul><h2 id="避免发送HTTP请求"><a href="#避免发送HTTP请求" class="headerlink" title="避免发送HTTP请求"></a>避免发送HTTP请求</h2><p>本地缓存：将请求url作为key，响应作为value保存到本地磁盘上。</p><ul><li>根据<code>Cache-Control</code>或<code>Expires</code>请求头实现强制缓存。</li><li>根据<code>Last_Modified</code>或<code>Ttag</code>请求头实现协商缓存。</li></ul><h2 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h2><ul><li>减少重定向请求次数；</li><li>合并请求；</li><li>延迟发送请求；</li></ul><h3 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h3><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.webp"><br><strong>重定向的工作交由代理服务器完成，就能减少HTTP请求次数了</strong><br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.webp"><br>代理服务器已知重定向规则后，直接实现代理访问：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.webp"></p><h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>多个小请求合并成大请求，body一样但避免了header重复。</p><p>另外，HTTP&#x2F;1.1的管道模式默认不开启，即存在请求队头阻塞问题，浏览器的处理方式是多开几个TCP连接一起访问，所以合并请求也可以减少TCP连接的数量。</p><h3 id="延迟发送请求"><a href="#延迟发送请求" class="headerlink" title="延迟发送请求"></a>延迟发送请求</h3><p>即懒加载。</p><h2 id="减少HTTP响应的数据大小"><a href="#减少HTTP响应的数据大小" class="headerlink" title="减少HTTP响应的数据大小"></a>减少HTTP响应的数据大小</h2><p><strong>压缩</strong>的方式一般分为 2 种，分别是：</p><ul><li>_无损压缩_；</li><li>_有损压缩_；</li></ul><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Encoding: gzip, deflate, br<br></code></pre></td></tr></table></figure><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>q表示质量引子。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: audio/*; q=<span class="hljs-number">0</span>.<span class="hljs-number">2</span>, audio/basic<br></code></pre></td></tr></table></figure><h3 id="增量数据"><a href="#增量数据" class="headerlink" title="增量数据"></a>增量数据</h3><p>对于视频和声音等，可以使用增量数据的方式表示后续帧。<br>对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p><div class="note note-primary">            <p>记忆总结：</p><ul><li>数量上不发</li><li>数量上少发</li><li>大小上减少</li></ul>          </div><h1 id="四、HTTPS优化"><a href="#四、HTTPS优化" class="headerlink" title="四、HTTPS优化"></a>四、HTTPS优化</h1><h2 id="性能消耗"><a href="#性能消耗" class="headerlink" title="性能消耗"></a>性能消耗</h2><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p><strong>HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</strong>，可以选择对应指令优化的CPU。</p><h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><ul><li>软件升级：Linux系统内核升级</li><li>协议优化：<ul><li>ECDHE密钥交换，客户端不用等第四次握手就可以发送消息。</li><li>TLS升级1.3，1RTT即完成握手。</li></ul></li></ul><h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><h4 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h4><p>相同强度下，椭圆曲线（ECDSA）证书比RSA证书密钥长度更短</p><h4 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h4><p>减少验证链的过程。</p><p>CRL：证书吊销列表（_Certificate Revocation List_）<br>即快速失败策略，会越来越大，也不好维护，已经不再使用。<br>OCSP：在线证书状态协议（_Online Certificate Status Protocol_），<strong>向CA发送请求查询，返回有效状态</strong>。</p><h5 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h5><p>服务器向CA周期性查询证书状态，并缓存经过<strong>签名</strong>结果。<br>客户端发起连接请求时，服务器把响应结果回复给客户端。<br>由于<strong>签名</strong>的存在，服务器无法篡改。</p><div class="note note-primary">            <p>即把客户端CA验证变成了服务端统一验证。</p>          </div><h2 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h2><ul><li>第一种叫 Session ID，1RTT；</li><li>第二种叫 Session Ticket，1RTT；</li><li>第三种叫 Pre-shared Key，0RTT；</li></ul><h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p><strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>。</p><p>缺点是占用内存（空间换时间），且不一定会命中上次访问过地服务器。</p><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p><strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。<br>客户端缓存Ticket，下次连接时发送，服务器直接解密校验。</p><p>缺点是要确保每台服务器的加解密方式一样，且不具有前向安全性。</p><h3 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h3><p>对于<strong>重连 TLS1.3</strong>只需要 0 RTT，原理与Ticket类似，但其重连时会直接把Ticket和HTTP一起发送给服务端。</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>中间人获取Session ID&#x2F;Ticket后模拟客户端不断请求。因此，要对<strong>对会话密钥设定一个合理的过期时间</strong>，并只对安全请求使用会话重用。</p><h1 id="五、RPC协议"><a href="#五、RPC协议" class="headerlink" title="五、RPC协议"></a>五、RPC协议</h1><h2 id="TCP存在的问题"><a href="#TCP存在的问题" class="headerlink" title="TCP存在的问题"></a>TCP存在的问题</h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。<br>由于TCP是<strong>基于字节流</strong>的，字节之间没有边界，会造成<strong>粘包问题</strong>。因此，一般使用TCP时，还需要自定义一些信息，如消息头中标记长度，从而取出正确的数据。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。<br>主要思想是像调用本地方法一样调用远程方法。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230207112106.png"><br>有非常多款式的 RPC 思想的实现，比如比较有名的<code>gRPC</code>，<code>thrift</code>。虽然大部分 RPC 协议底层使用 TCP，但实际上<strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><h3 id="存在"><a href="#存在" class="headerlink" title="存在"></a>存在</h3><ul><li>为什么有了HTTP还要RPC：RPC在HTTP前诞生</li><li>为什么有了RPC还要HTTP：B&#x2F;S架构的诞生，需要统一协议。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul><li>HTTP访问需要<strong>IP</strong>和<strong>端口</strong>。</li><li>RPC访问时，可以找中间服务获取IP等信息。</li></ul><p>本质上区别不大。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><ul><li>RPC和HTTP1.1一样，有长连接</li><li>RPC和HTTP一样，可以存在连接池</li></ul><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>RPC定制化程度更高，序列化协议的体积更小，因此<strong>性能</strong>也更好。</p><blockquote><p>当然上面说的 HTTP，其实<strong>特指的是现在主流使用的 HTTP&#x2F;1.1</strong>，<code>HTTP/2</code> 在前者的基础上做了很多改进，所以<strong>性能可能比很多 RPC 协议还要好</strong>，甚至连 <code>gRPC</code> 底层都直接用的 <code>HTTP/2</code>。</p></blockquote><h1 id="六、WebSocket"><a href="#六、WebSocket" class="headerlink" title="六、WebSocket"></a>六、WebSocket</h1><h2 id="服务器主动推送消息的方式"><a href="#服务器主动推送消息的方式" class="headerlink" title="服务器主动推送消息的方式"></a>服务器主动推送消息的方式</h2><ul><li>HTTP不断轮询：轮询存在间隔，有卡顿，浪费资源。</li><li>长轮询:即将超时时间设置的很长，出现响应后才回复（扫码）</li><li>WebSocket</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>HTTP&#x2F;1.1，使用了半双工的方式（请求-响应）。</p><h3 id="建立WebSocket连接"><a href="#建立WebSocket连接" class="headerlink" title="建立WebSocket连接"></a>建立WebSocket连接</h3><p>1）浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p><ul><li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是继续用普通 HTTP 协议进行交互。</li><li>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：即浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<br><span class="hljs-symbol">Upgrade:</span> WebSocket<br><span class="hljs-keyword">Sec</span>-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n<br></code></pre></td></tr></table></figure></li></ul><p>2）服务器接受到消息后，如果也想升级成WebSocket协议，则走WebSocket 握手流程，同时根据客户端生成的base64码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols\r\n<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>WebSocket\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade\r\n<br></code></pre></td></tr></table></figure><p>3）浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p><h3 id="WebSocket消息格式"><a href="#WebSocket消息格式" class="headerlink" title="WebSocket消息格式"></a>WebSocket消息格式</h3><p>数据包在WebSocket中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230207113622.png"><br><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p><ul><li>等于 1 ，是指text类型（<code>string</code>）的数据包</li><li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li><li>等于 8 ，是关闭连接的信号</li></ul><p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p><ul><li>既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit 或 7+64bit。</code></li><li>根据最前面7bit的数值绝对，若为126则实际上为<code>16bit</code>，127则实际上为<code>64bit</code>。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p><p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第5章（线程池）</title>
    <link href="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/"/>
    <url>/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程池工作原理"><a href="#一、线程池工作原理" class="headerlink" title="一、线程池工作原理"></a>一、线程池工作原理</h1><h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：系统的资源是有限的，所以线程作为一个消耗系统资源的东西，就不可能无限制的创建。这样，我们通过引入线程池，对线程进行进行统一地分配和监控，降低手动管理每个线程的复杂度。</li></ul><blockquote><p>阿里巴巴的《Java 开发手册》中也强制规定了：<strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong>。</p></blockquote><h2 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h2><p>线程池的组成：</p><ul><li>核心线程池（存储线程）</li><li>工作队列（存储任务）</li></ul><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203232839.png"><br>当提交一个新任务到线程池时，线程池的处理流程分如下三步走：</p><ol><li>判断核心线程池里的线程是否都在执行任务（<strong>核心线程池是否已满</strong>）：<ul><li>如果不是，则创建一个新的工作线程来执行任务。</li><li>如果核心线程池里的线程都在执行任务，则进入下一步。</li></ul></li><li>判断<strong>工作队列是否已满</strong>：<ul><li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li><li>如果工作队列满了，则进入下一步。</li></ul></li><li>判断线程池中的所有线程是否都处于工作状态（<strong>线程池是否已满</strong>）：<ul><li>如果没有，则创建一个新的工作线程来执行任务。</li><li>如果已经满了，则交给<strong>饱和策略</strong>来处理这个任务。</li></ul></li><li>饱和策略有以下几种：<ul><li>AbortPolicy（默认）：无法处理新任务时直接抛出异常</li><li>CallerRunsPolicy：使用调用者所在的线程来运行新任务（这个很好理解，一般我们都是主线程提交任务，然后扔进线程池执行，对吧。当线程池满了后，如果使用这个策略，就会调用主线程来执行新任务）</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并将新任务加入队列</li><li>DiscardPolicy：不做任何处理，直接将新任务丢弃掉，粗暴！</li></ul></li></ol><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203233411.png"></p><div class="note note-primary">            <p>总的思路是<strong>尽量使用核心线程池的线程执行任务</strong>，实在不行再请求新线程，还不行就走饱和策略。</p>          </div><p><strong>工作队列何时出列？</strong><br>线程在执行完任务后，就会主动从工作队列中获取任务来执行。</p><p><strong>为什么这样设计？</strong><br>创建新线程永远不是最优先的选择，而是尽可能地复用已存在的线程。</p><h1 id="二、创建线程池"><a href="#二、创建线程池" class="headerlink" title="二、创建线程池"></a>二、创建线程池</h1><p>线程池的创建方法总体来说可分为 2 大类：</p><ul><li>一种是通过 <code>Executors</code> 创建的线程池</li><li>另一种是通过 <code>ThreadPoolExecutor</code> 创建的线程池</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 封装了6种方法，对应创建6种不同的线程池：</p><ul><li>FixedThreadPool</li><li>CachedThreadPool</li><li>SingleThreadExecutor</li><li>WorkStealingPool</li><li>ScheduledThreadPool</li><li>SingleThreadScheduledExecutor</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234231.png"><br>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建包含 2 个线程的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 创建任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>    &#125;<br>&#125;;<br>fixedThreadPool.submit(runnable);<br>fixedThreadPool.execute(runnable);<br></code></pre></td></tr></table></figure><p>execute和submit </p><ul><li>execute用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li><li>submit用于提交需要返回值的任务，线程池会返回一个 Future 类型的对象。</li></ul><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>创建一个可缓存的线程池，若线程数超过处理任务所需（供 &gt; 求），多出来的线程缓存一段时间后会被回收掉；而如果线程数不够（供 &lt; 求），则线程池会新建一些线程出来。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234225.png"></p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>创建只包含一个线程的线程池，它可以保证任务先进先出的执行顺序。也就说，先被扔进线程池的任务，就会被先执行<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234321.png"></p><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234401.png"><br>和 SingleThreadExecutor相反，WorkStealingPool创建的是一个抢占式执行的线程池，也即任务执行顺序不确定。</p><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>创建一个可以执行延迟&#x2F;定时任务的线程池。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234413.png"><br>这时就不再使用<code>execute/submit</code>了，而是<code>schedule</code>。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234500.png"></p><h3 id="SingleThreadScheduledExecutor"><a href="#SingleThreadScheduledExecutor" class="headerlink" title="SingleThreadScheduledExecutor"></a>SingleThreadScheduledExecutor</h3><p>这个方法创建的是仅包含 1 个线程线程池，并且它可以执行延迟任务。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>上述Executors的6种方法，其底层最终调用的都是ThreadPoolExecutor的构造函数，只不过参数不同。可以简单理解为，<code>ThreadPoolExecutor</code>是最基本的创建线程池的方式，<code>Executors</code>对其做了一定的封装。</p><blockquote><p>在阿里巴巴的《Java 开发手册》上，明确规定了：<br>【强制要求】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234656.png"></p><ol><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</li><li>unit：即keepAliveTime的单位</li><li>workQueue：阻塞队列</li><li>threadFactory：线程工厂，主要用来创建线程，默认为<strong>正常优先级、非守护线程</strong>。</li><li>handler：拒绝策略，即饱和策略<ul><li>AbortPolicy (默认策略)：拒绝执行并抛出异常</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy：抛弃阻塞队列头部（最旧）的一个任务，并执行当前任务</li><li>DiscardPolicy：忽略并抛弃当前任务</li></ul></li></ol><div class="note note-primary">            <p><strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>阻塞队列</strong>是限制大小的。<br><strong>存活时间</strong>和<strong>单位</strong>是管理非核心线程的。<br><strong>工厂</strong>管理生成线程策略。<br><strong>处理器</strong>决定饱和策略。</p>          </div><p>后两个参数一般默认，常用的是5参数版本：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203235208.png"></p><h3 id="为什么不要使用Executors创建线程池"><a href="#为什么不要使用Executors创建线程池" class="headerlink" title="为什么不要使用Executors创建线程池"></a>为什么不要使用Executors创建线程池</h3><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</li><li>CachedThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li></ul><h1 id="三、Executor"><a href="#三、Executor" class="headerlink" title="三、Executor"></a>三、Executor</h1><p>Executor是一个接口，也是一个框架！<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203235700.png"></p><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204002439.png"></p><ul><li>任务：包括被执行任务需要实现的接口：<code>Runnable/Callable</code>接口</li><li>任务的执行：包括任务执行机制的核心接口<code>Executor</code>，以及继承自 <code>Executor</code>的<code>ExecutorService</code>接口。<ul><li><code>Executor</code>框架有两个关键类实现了<code>ExecutorService</code>接口，分别为<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code></li></ul></li><li>任务执行的结果：包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204002726.png"></p><ol><li>创建Runnable&#x2F;Callable</li><li>提交给ExecutorService，ExecutorService根据具体实现来处理任务。</li><li>返回Future&#x2F;FutureTask(FutureTask是Future的实现类)</li></ol><h2 id="Executors、Executor、ExecutorService"><a href="#Executors、Executor、ExecutorService" class="headerlink" title="Executors、Executor、ExecutorService"></a>Executors、Executor、ExecutorService</h2><p>区别：</p><ul><li><code>ExecutorService</code>接口继承了<code>Executor</code>接口<ul><li><code>execute()</code>方法在<code>Executor</code>中定义，而<code>submit()</code>在<code>ExecutorService</code>中定义。</li><li><code>ExecutorService</code>提供了很多控制线程池的方法，如<code>shutdown</code>。</li></ul></li><li><code>Executors</code>只是一个工具类，快速生成<code>ExecutorService</code>的子类，如<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>。</li></ul><h1 id="四、线程池生命周期"><a href="#四、线程池生命周期" class="headerlink" title="四、线程池生命周期"></a>四、线程池生命周期</h1><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>; <span class="hljs-comment">// =29</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>; <span class="hljs-comment">// =000 11111...</span><br><br><span class="hljs-comment">// runState is stored in the high-order bits</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 111 00000...</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 000 00000...</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 001 00000...</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 010 00000...</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">// 011 00000...</span><br><br><span class="hljs-comment">// 线程池的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br><span class="hljs-comment">// 线程池中工作线程的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;<br><span class="hljs-comment">// 计算ctl的值，等于运行状态“加上”线程数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><p><em>线程池状态</em><br>2. 线程池的状态和工作线程的数量共同保存在控制变量ctl中，类似于AQS中的state变量，不过这里是直接使用的<code>AtomicInteger</code>，这里换成unsafe+volatile也是可以的；<br>3. ctl的高三位保存运行状态，低29位保存工作线程的数量，也就是说线程的数量最多只能有(2^29-1)个，也就是上面的CAPACITY；<br>4. 线程池的状态一共有五种，分别是RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED；<br>    - <code>RUNNING</code>，表示可接受新任务，且可执行队列中的任务；<br>    - <code>SHUTDOWN</code>，表示不接受新任务，但可执行队列中的任务；<br>    - <code>STOP</code>，表示不接受新任务，且不再执行队列中的任务，且中断正在执行的任务；<br>    - <code>TIDYING</code>，所有任务已经中止，且工作线程数量为0，最后变迁到这个状态的线程将要执行terminated()钩子方法，只会有一个线程执行这个方法；<br>    - <code>TERMINATED</code>，中止状态，已经执行完terminated()钩子方法；</p><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230922155528.png"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="状态变迁"><a href="#状态变迁" class="headerlink" title="状态变迁"></a>状态变迁</h3><p><em>RUNNING状态</em><br>创建线程池的时候就会初始化ctl，而ctl初始化为<code>RUNNING</code>状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始状态为RUNNING</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p><em>SHUTDOWN状态</em><br>执行<code>SHUTDOWN</code>方法时，将线程状态修改为<code>SHUTDOWN</code>状态，<code>advanceRunState（）</code>通过自旋保证成功，同时标记空闲线程为中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        <span class="hljs-comment">// 修改状态为SHUTDOWN</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">// 标记空闲线程为中断状态</span><br>        interruptIdleWorkers();<br>        onShutdown();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">advanceRunState</span><span class="hljs-params">(<span class="hljs-type">int</span> targetState)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 如果状态大于SHUTDOWN，或者修改为SHUTDOWN成功了，才会break跳出自旋</span><br>        <span class="hljs-keyword">if</span> (runStateAtLeast(c, targetState) ||<br>            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>STOP状态</em><br>执行<code>shutdownNow()</code>方法时，把线程池状态修改为<code>STOP</code>状态，同时标记所有线程为中断状态。</p><p><em>TIDYING状态</em><br>当执行<code>shutdown()</code>或<code>shutdownNow()</code>之后，如果所有任务已中止，且工作线程数量为0，会调用<code>tryTerminate()</code>进入这个状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 下面几种情况不会执行后续代码</span><br>        <span class="hljs-comment">// 1. 运行中</span><br>        <span class="hljs-comment">// 2. 状态的值比TIDYING还大，也就是TERMINATED</span><br>        <span class="hljs-comment">// 3. SHUTDOWN状态且任务队列不为空</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 工作线程数量不为0，也不会执行后续代码</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 尝试中断空闲的线程</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// CAS修改状态为TIDYING状态</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 更新成功，执行terminated钩子方法</span><br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 强制更新状态为TERMINATED，这里不需要CAS了</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>更新状态为<code>TIDYING</code>和<code>TERMINATED</code>状态的代码都在tryTerminate()方法中</li><li>tryTerminated()方法在shutdown()、shutdownNow()、线程退出时都会被调用，即每个线程最后消亡的时候都会调用tryTerminate()方法，但最后只会有一个线程真正执行到修改状态为TIDYING的地方。</li></ul><p><em>TERMINATED状态</em><br>见<code>TIDYING</code>状态</p><h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker()"></a>addWorker()</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230925182050.png"></p><ol><li>判断线程池状态是否允许创建新线程：<code>RUNNING状态</code>或<code>SHUTDOWN状态下处理旧任务时</code>才允许创建。</li><li>自旋判断线程数量是否允许添加新线程：<ol><li>如果工作线程数量≥线程池最大限制(1&lt;&lt;27-1)，禁止添加;</li><li>当前待添加线程是核心线程：如果工作线程数量≥核心线程池数量，禁止添加。</li><li>当前待添加线程是非核心线程：如果工作线程数量≥最大线程池数量，禁止添加。</li></ol></li><li>将工作线程CAS++：<ol><li>失败时，判断当前线程池的状态，如果现在获取到的状态与进入自旋的状态不一致的话，那么则通过continue重新进行状态<code>步骤1</code>的判断。</li><li>成功时，进入<code>步骤4</code>。</li></ol></li><li>创建新的Worker对象</li><li>获取线程池的重入锁后，判断当前线程池的状态：<ol><li>如果线程池状态为<code>RUNNING状态</code>或<code>SHUTDOWN状态下处理旧任务时</code>，那么将worker加入到线程池的workers列表中，调度执行方法。</li><li>否则，将<code>workerCount</code>减一，然后调用<code>tryTerminate</code>停止线程池，并且返回false。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>retry:<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br><span class="hljs-comment">// Check if queue empty only if necessary.</span><br><span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>! (rs == SHUTDOWN &amp;&amp;<br>   firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>   ! workQueue.isEmpty()))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>wc &gt;= (core ? corePoolSize : maximumPoolSize))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br><span class="hljs-keyword">break</span> retry;<br>c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br><span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br><span class="hljs-keyword">continue</span> retry;<br><span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>&#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br><span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>mainLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// Recheck while holding lock.</span><br><span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br><span class="hljs-comment">// shut down before lock acquired.</span><br><span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br><span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>(rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br><span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>workers.add(w);<br><span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br><span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>largestPoolSize = s;<br>workerAdded = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>mainLock.unlock();<br>&#125;<br><span class="hljs-keyword">if</span> (workerAdded) &#123;<br>t.start();<br>workerStarted = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (! workerStarted)<br>addWorkerFailed(w);<br>&#125;<br><span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)  <br>            workers.remove(w);  <br>        decrementWorkerCount();  <br>        tryTerminate();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker中Thread的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>runWorker(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>w.firstTask = <span class="hljs-literal">null</span>;<br>w.unlock(); <span class="hljs-comment">// allow interrupts</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 关键点：利用while循环和不断地getTask来从队列中获取任务</span><br><span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>w.lock();<br><span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br><span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br><span class="hljs-comment">// requires a recheck in second case to deal with</span><br><span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br><span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br> (Thread.interrupted() &amp;&amp;<br>  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>!wt.isInterrupted())<br>wt.interrupt();<br><span class="hljs-keyword">try</span> &#123;<br>beforeExecute(wt, task);<br><span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 关键点</span><br>task.run();<br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>thrown = x; <span class="hljs-keyword">throw</span> x;<br>&#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>thrown = x; <span class="hljs-keyword">throw</span> x;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>afterExecute(task, thrown);<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>task = <span class="hljs-literal">null</span>;<br>w.completedTasks++;<br>w.unlock();<br>&#125;<br>&#125;<br>completedAbruptly = <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>processWorkerExit(w, completedAbruptly);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 关键方法</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><span class="hljs-comment">// Check if queue empty only if necessary.</span><br><span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>decrementWorkerCount();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><span class="hljs-comment">// Are workers subject to culling?</span><br><span class="hljs-comment">// 关键点</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>&amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br><span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 关键点</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>workQueue.take();<br><span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">return</span> r;<br>timedOut = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>timedOut = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shutdown-与shutdownNow"><a href="#shutdown-与shutdownNow" class="headerlink" title="shutdown()与shutdownNow()"></a>shutdown()与shutdownNow()</h3><h4 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h4><p><em>shutdown方法</em></p><ol><li>修改线程池状态为SHUTDOWN（不再接受新任务）</li><li>将<strong>所有空闲线程标记为中断状态</strong></li></ol><p><em>shutdownNow方法</em></p><ol><li>修改线程池状态为STOP（不再接受新任务、不再执行队列中的任务）</li><li>将<strong>所有线程标记为中断状态</strong></li><li>返回执行队列中的任务</li></ol><h4 id="线程中断本质"><a href="#线程中断本质" class="headerlink" title="线程中断本质"></a>线程中断本质</h4><p>本质上调用了<code>Thread#interrupt()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptWorkers</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;  <br>    mainLock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Worker w : workers)  <br>            w.interruptIfStarted();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        mainLock.unlock();  <br>    &#125;  <br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;  <br>    Thread t;  <br>    <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            t.interrupt();  <br>        &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><em>Thread.interrupt()工作机制</em><br>一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，<code>Thread.stop</code>, <code>Thread.suspend</code>, <code>Thread.resume</code> 都已经被废弃了。<br><code>Thread.interrupt()</code>方法所提供的线程中断，实际就是从线程外界，修改线程内部的一个 boolean类型 标志变量，或者让线程中的一些阻塞方法，抛出InterruptedException。以此“通知”线程去做一些事情， 至于做什么，做不做，实际完全是由线程内的<strong>业务代码</strong>决定的。</p><p><em>Thread.interrupt()使用</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br><span class="hljs-comment">// 中断线程t，将线程t标记为中断状态</span><br>t.interrupt();<br><span class="hljs-comment">// 判断线程t是否为中断状态，返回boolean</span><br>t.isInterrupted();<br><span class="hljs-comment">// 线程判断自身（是静态方法，其他线程无法调用对线程t方法）是否为中断状态，返回boolean，并消除该中断状态</span><br>Thread.interrupted();<br></code></pre></td></tr></table></figure><p>阻塞状态下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程t在sleep、阻塞时，其他线程调用了中断，会将线程标记为中断状态</span><br><span class="hljs-comment">// 此时会打破线程t的阻塞状态并抛出InterruptException异常：</span><br><span class="hljs-comment">// 1. 如果该异常被捕获，则消除该中断状态</span><br><span class="hljs-comment">// 2. 如果该异常没有被捕获，则该线程仍为中断状态（没有被捕获的异常会导致线程终止）</span><br><span class="hljs-keyword">try</span>&#123;<br>Thread.sleep()<br>&#125;<span class="hljs-keyword">catch</span>(InterruptException ie)&#123;<br>t.isInterrupted(); <span class="hljs-comment">// false，异常被捕获后不是异常状态</span><br>Thread.interrpted(); <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>优雅处理</em></p><ol><li>处理中断的时机：被中断线程只需在合适的时候处理即可，一般在每次迭代的时候，进入一个可能阻塞且无法中断的方法之前等。</li><li>处理中断的方式：如果是可中断的阻塞方法抛出<code>InterruptedException</code><ol><li>若可以在该方法中抛出异常，可以继续向方法调用栈的上层抛出该异常（即将该方法也变成一个可中断的方法）</li><li>若无法在该方法中抛出异常（如因为继承原因无法在方法签名上标注），可以捕获该异常并通过Thread.currentThread.interrupt()来重新设置中断状态。</li></ol></li><li>中断的响应：视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务。</li></ol><h4 id="线程池处理shutdown"><a href="#线程池处理shutdown" class="headerlink" title="线程池处理shutdown"></a>线程池处理shutdown</h4><ol><li>当前任务：同线程中断本质中描述的，线程池的shutdownNow()不会强行中断当前的任务，需要任务的业务中自行处理中断。</li><li>队列任务：线程对中断的响应其实是在任务队列的<code>take()</code>或<code>poll()</code>方法中进行的，即任务队列的Lock的<code>AQS</code>中，其检测到线程中断后会抛出一个<code>InterruptedException</code>异常，<code>getTask()</code>捕获这个异常后，会在下一次的自旋时退出并减少工作线程的数量。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <span class="hljs-comment">// 如果状态为STOP了，这里会直接退出循环，且减少工作线程数量</span><br>        <span class="hljs-comment">// 退出循环了也就相当于这个线程的生命周期结束了</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>        <span class="hljs-comment">// Are workers subject to culling?</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 真正响应中断是在poll()方法或者take()方法中</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            <span class="hljs-comment">// 这里捕获中断异常</span><br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination()"></a>awaitTermination()</h3><p><code>awaitTermination(long timeOut, TimeUnit unit)</code><br>一个阻塞方法，用于等待线程池结束，在以下情况停止阻塞：</p><ul><li>目标线程池所有已提交的任务（包括正在跑的和队列中等待的）执行完；</li><li>或者 等超时时间到了（timeout 和 TimeUnit设定的时间）；</li><li>或者 本线程被中断，抛出InterruptedException。</li></ul><h1 id="五、配置线程池"><a href="#五、配置线程池" class="headerlink" title="五、配置线程池"></a>五、配置线程池</h1><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204003341.png"><br>三个参数：<code>corePoolSize</code>核心线程数、<code>maximumPoolSize</code>最大线程数和 <code>workQueue</code>阻塞队列，就是我们在创建线程池时应该关注的重点。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="线上与线下"><a href="#线上与线下" class="headerlink" title="线上与线下"></a>线上与线下</h3><p><strong>线上 - 响应速度优先</strong>：需要快速响应用户的请求，应该不设置阻塞队列去缓冲并发任务，调高 <code>corePoolSize</code> 和 <code>maxPoolSize</code> 去创造尽可能多的线程快速执行任务。<br><strong>线下 - 吞吐量优先</strong>：需要尽可能快地批量处理任务，应该设置阻塞队列去缓冲并发任务，调整合适的<code>corePoolSize</code>去设置处理任务的核心线程数。</p><h3 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h3><p><strong>CPU密集型任务</strong>：充分利用CPU，设置corePoolSize为CPU数+1（备用，防止其他线程暂停不工作）。<br><strong>IO密集型任务</strong>：尽可能多配置核心线程，IO等待时让其他线程占用CPU。<br>主要还是看实际生产情况灵活调整。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第4章（并发集合与工具类）</title>
    <link href="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/"/>
    <url>/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、并发集合"><a href="#一、并发集合" class="headerlink" title="一、并发集合"></a>一、并发集合</h1><p>J.U.C 为每一类集合都提供了线程安全的实现，且大多都是以 <code>Concurrent</code> 或者 <code>CopyOnWrite</code> 开头的。</p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>1)List</p><ul><li><code>Vector</code>（这个没啥好说的，它就是把 ArrayList 中所有的方法统统加上 <code>synchronized</code> ）</li><li><code>CopyOnWriteArrayList</code></li></ul><p>2)Set</p><ul><li><code>CopyOnWriteArraySet</code></li><li><code>ConcurrentSkipListSet</code></li></ul><p>3)Queue</p><ul><li>BlockingQueue 接口<ul><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>ConcurrentLinkedQueue</li></ul></li><li>TransferQueue 接口<ul><li>LinkedTransferQueue</li></ul></li><li>BlockingDeque 接口<ul><li>LinkedBlockingDeque</li><li>ConcurrentLinkedDeque</li></ul></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li>HashTable（就是把 HashMap 中所有的方法统统加上 synchronized ）</li><li>ConcurrentMap 接口<ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul><li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</li><li>Segment 继承自 ReentrantLock，是一种可重入锁；HashEntry 是用于真正存储数据的地方</li><li>一个 ConcurrentHashMap 包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，当对某个 HashEntry 数组中的元素进行修改时，必须首先获得该元素所属 HashEntry 数组对应的 Segment 锁</li></ul><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203174438.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 真正存放数据的地方</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<br>    <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 阈值</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><br>    Segment(<span class="hljs-type">float</span> lf, <span class="hljs-type">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">this</span>.loadFactor = lf;<br>        <span class="hljs-built_in">this</span>.threshold = threshold;<br>        <span class="hljs-built_in">this</span>.table = tab;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简而言之，将HashCode分片，每片持有一个锁（ReentrantLock），多个桶（HashEntry数组）</p><p><strong>每个 <code>HashEntry</code> 是一个链表结构的元素</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V value;<br>    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><p>HashEntry维护了一个next指针，并注意value被<code>volatile</code>修饰，保证了可见性。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-comment">// 1. 通过 key 定位到具体的 Segment</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject<br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>)<br>        s = ensureSegment(j);<br>    <span class="hljs-comment">// 在对应的 Segment 中进行真正的 put</span><br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对key做hash处理（1次hash）</li><li>对key做掩码等处理（2次hash）</li><li>获取对应segment，如果为空则创建。</li><li>在对应segment上执行put操作（使用1次hash的值）</li><li>获取segment的锁，失败则自旋直到成功</li><li>成功后判断是否需要扩容HashEntry数组，然定位、插入。</li></ol><p>注意这里获取segment时，对key做了两次hash处理，目的是尽可能将将数据打散到各个segment。</p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ol><li>通过二次hash定位到具体segment</li><li>通过一次hash定位到具体元素</li></ol><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>不同于 JDK 1.7 版本的 Segment 数组 + HashEntry 链表。</p><ul><li>JDK 1.8 版本中的 ConcurrentHashMap 直接抛弃了 Segment 锁，一个 ConcurrentHashMap 包含一个 Node 数组（和 HashEntry 实现差不多）</li><li>每个 Node 是一个链表结构，并且在链表长度大于一定值（大于8且node数组长度大于64）时会转换为红黑树结构（TreeBin）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br><br>    Node(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p>TreeBin继承了Node，当Node链表长度过长时，会升级为TreeBin。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203175817.png"><br>结构图：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203175855.png"></p><p>使用<strong>synchronized+CAS</strong>保证并发安全性。</p><p>Node 数组其实就是一个哈希桶数组，每个 Node 头节点及其所有的 next 节点组成的链表就是一个桶，只要锁住这个桶的<strong>头结点</strong>，就不会影响其他哈希桶数组元素的读写。</p><blockquote><p>JDK 1.8 没有使用 ReentrantLock 而是改用 synchronized，足以说明新版 JDK 对 synchronized 的优化确有成效。</p></blockquote><h4 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h4><ol><li>根据key计算hash</li><li>根据hash定位Node<ul><li>若Node为空，则CAS写入（失败则自旋，重新判断Node是否为空）；</li><li>若不为空但hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1，需要扩容</li><li>若不为空且不需要扩容，则利用synchronized写入数据。</li></ul></li></ol><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p><a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">扩容细节</a></p><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><ol><li>根据key计算hash</li><li>根据hash定位Node</li><li>判断节点类型并搜索</li></ol><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列含义：</p><ul><li><strong>当队列满时，队列会阻塞向其中插入元素的线程，直到队列不满</strong></li><li><strong>当队列为空时，获取队列中元素的线程会一直等待，直到队列变为非空</strong><br>应用场景：生产者-消费者<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181313.png"><br>模式：<strong>当队列满时，生产者阻塞，当队列空时，消费者阻塞</strong>。</li></ul><h3 id="Java中的BlockingQueue"><a href="#Java中的BlockingQueue" class="headerlink" title="Java中的BlockingQueue"></a>Java中的BlockingQueue</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181429.png"><br>Java 中提供了一个阻塞队列的接口 BlockingQueue 以及 7 个具体的实现（6 个单向队列和 1 个双端队列）：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue：一个使用 PriorityBlockingQueue 实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储任何元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><h4 id="有界队列与无界队列"><a href="#有界队列与无界队列" class="headerlink" title="有界队列与无界队列"></a>有界队列与无界队列</h4><p>以LinkedBlockingQueue为例：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181546.png"></p><ul><li>带参构造函数需要指定队列的长度，并且当<strong>队列满了之后也不会对其进行扩容</strong>，这就是有界队列</li><li>而<strong>无参构造函数赋给队列的长度是 Integer.MAX_VALUE</strong>，显然现实几乎不会有这么大的容量超过 Integer.MAX_VALUE，所以从使用者的体验上，可以无限入队，相当于无界队列</li></ul><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>主要方法：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181646.png"><br>方法区别：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181641.png"></p><p>主要研究：”阻塞进” <code>put()</code> 和 “阻塞出” <code>take()</code></p><p>阻塞队列利用<code>Lock</code>中的<code>Condition</code>使用<strong>通知模式</strong>，实现对生产者，消费者的通知。</p><p>以<code>ArrayBlockingQueue</code>为例，其拥有两个condition成员变量：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181939.png"></p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 获取可中断锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果当前元素个数等于队列的最大长度，则调用 notFull.await() 进行等待</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br>        <span class="hljs-comment">// 向队列中插入元素</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 入队成功，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取可中断锁</li><li>判断队列空间<ul><li>如果队列空间不足，则在notFull队列中等待，被唤醒后继续尝试入列（<code>enqueue</code>，该方法中调用了notEmpty.signal()，提醒消费者）。</li><li>如果队列空间足够，入列（<code>enqueue</code>）</li></ul></li><li>释放锁</li></ol><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 获取可中断锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果队列中没有元素，则调用 notEmpty.await() 进行等待</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-comment">// 从队列中取出元素</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 出队成功，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取可中断锁</li><li>判断队列是否为空<ul><li>若为空，则在在notEmpty队列中等待，被唤醒后再尝试获取</li><li>若不为空，则获取元素(<code>dequeue</code>，notFull.signal()，提醒生产者)</li></ul></li><li>释放锁</li></ol><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203182814.png"></p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>ConcurrentLinkedQueue，使用CAS保证线程安全。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203182841.png"></p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>Vector</code> 其实是非常粗暴的给ArrayList所有方法都加上了锁，导致并发度不高。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>ArrayList迭代时，不允许集合被修改。因此需要避免多线程下ArrayList线程不安全的问题。<br>可以通过读写锁避免读时写，但如果我们希望无论合适都可以读取到数据，则需要COW的思想。</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>COW放弃了这种数据实时性，通过满足数据的最终一致性从而提升并发度。顾名思义，写时复制，Redis的主从复制就是使用的这种思想。<br>写操作时，先创建目标对象的拷贝，对拷贝对象写完成后替换原对象。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>CopyOnWriteArrayList维护一个底层数组，其可以被替换。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203183841.png"></p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203183612.png"></p><ol><li>加重入锁</li><li>复制数组</li><li>改写数组元素并替换原数组对象</li><li>释放锁</li></ol><h3 id="延时感知"><a href="#延时感知" class="headerlink" title="延时感知"></a>延时感知</h3><p>读线程读取数组元素时，可能读到的是旧数组。</p><h3 id="COW缺点"><a href="#COW缺点" class="headerlink" title="COW缺点"></a>COW缺点</h3><ul><li>复制严重消耗<strong>性能</strong>。</li><li>会产生大量数组垃圾，容易造成GC（<strong>内存</strong>）。</li><li>对实时性要求高的化也不建议使用。</li></ul><h1 id="二、并发工具类"><a href="#二、并发工具类" class="headerlink" title="二、并发工具类"></a>二、并发工具类</h1><p>J.U.C 为我们封装了一些有用的控制并发流程的工具，CountDownLatch、CyclicBarrier、Semaphore 以及 Exchanger。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒计时器，一个线程执行一定的时间后另一个线程才可以开始（继续）执行。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>join方法也可以提供类似的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>System.out.println(<span class="hljs-string">&quot;first thing finish&quot;</span>);   <br>    &#125;        <br>&#125;);          <br><br>threadA.start();     <br>threadA.join();   <br>System.out.println(<span class="hljs-string">&quot;FINISH&quot;</span>);    <br></code></pre></td></tr></table></figure><p>主线程会等待A线程完成后再执行FINISH打印。<br>join()方法还提供了<code>join(long millis)</code> 和 <code>join(long millis,int nanos)</code>，可以设置超时时间和时间单位。</p><p>join的底层原理：<strong>wait&#x2F;notify</strong> 等待通知机制。</p><h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203184730.png"><br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203184732.png"></p><ul><li>CountDownLatch 的构造函数接收一个 int 类型的参数（count）作为计数器。</li><li>每调用一次 countDown 方法，这个 count 就会减 1。</li><li>当 count 不为 0 的时候，我们可以调用 CountDownLatch 的 await 方法阻塞当前线程，直到 count 变为 0，当前线程才可以继续往下执行。</li></ul><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;first thing finish&quot;</span>);   <br>        countDownLatch.countDown(); <span class="hljs-comment">// count --</span><br>        System.out.println(<span class="hljs-string">&quot;second thing finish&quot;</span>);        <br>        countDownLatch.countDown(); <span class="hljs-comment">// count --</span><br>    &#125;        <br>&#125;).start();<br>countDownLatch.await(); <span class="hljs-comment">// 主线程被阻塞住，直到 count = 0</span><br>System.out.println(<span class="hljs-string">&quot;FINISH&quot;</span>);    <br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>join是必须等待其他线程执行完或超时才继续执行，这里则通过信号量的方式实现对主线程的通知。</p>          </div><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>        cyclicBarrier.await(); <span class="hljs-comment">// 子线程已达到屏障</span><br>        System.out.println(<span class="hljs-string">&quot;child Thread&quot;</span>);   <br>    &#125;        <br>&#125;).start();<br><br>cyclicBarrier.await(); <span class="hljs-comment">// 主线程已到达屏障</span><br>System.out.println(<span class="hljs-string">&quot;main Thread&quot;</span>);  <br></code></pre></td></tr></table></figure><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203185034.png"></p><p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties，Runnable barrier-Action)</code>，就是说，当抵达屏障的线程数量满足parties后，在所有被阻塞的线程继续执行之前（即屏障打开之前），率先执行<code>barrier-Action</code>方法。</p><div class="note note-primary">            <p>都是通过调用工具类对象的<code>await</code>方法实现线程阻塞，然后工具类在合适的时候会唤醒线程。</p>          </div><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用许可证来理解更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">20</span>);<br><span class="hljs-comment">//申请许可证</span><br>s.acquire();<br><span class="hljs-comment">//释放许可证</span><br>s.release();<br></code></pre></td></tr></table></figure><p>就像餐厅的座位有限一样，需要排队恰饭一样。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203185405.png"><br>其最大的作用就是限流，和阻塞队列的原理有些相似，只不过阻塞队列限制的是排队的长度，这里限制的是恰饭的人数。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>两个线程想要互相阻塞式地交换信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;aaa&quot;</span>);  <br>                System.out.println(<span class="hljs-string">&quot;B发生的消息：&quot;</span>+A);  <br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123; <br>            &#125;   <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;bbb&quot;</span>);  <br>            System.out.println(<span class="hljs-string">&quot;A发生的消息：&quot;</span>+B);  <br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123; <br>        &#125;<br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure><p>交换到信息后，两个线程各自继续执行。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal称不上是一个工具类，但其能起到隔离线程之间数据的效果。<br>线程在ThreadLocal中设置的值是线程私有的。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();  <br>threadLocal.set(<span class="hljs-string">&quot;aa&quot;</span>);  <br>threadLocal.get();  <br>System.out.println(threadLocal.get());  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191027.png"></p><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191043.png"></p><ol><li>通过线程t获取ThreadLocalMap</li><li>通过ThreadLocalMap设置（this，value）</li></ol><p>解释：<br>1）ThreadLocalMap<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191419.png"><br>ThreadLocalMap是ThreadLocal的内部类，其中，Entry是map中的节点，从来存储真正的k-v数据。所以当向ThreadLocal中set值时，实际上是在给ThreadLocalMap赋值，即，在ThreadLocalMap中创建新的Entry节点。<br>2）<code>map.set(this,value)</code><br>ThreadLocal是一个公共对象，且可以有多个ThreadLocal存在。</p><ul><li>同一个ThreadLocal在不同的线程下代表不同的值。</li><li>使用一个线程查看不同的ThreadLocal也具有不同的意义。</li></ul><p>因此，实际上只有<code>ThreadLocalMap</code>是线程私有的，<code>ThreadLocalMap</code>中的Entry存储着真正的值，通过这个map，以不同的<code>ThreadLocal</code>为键，即可存储本线程中不同<code>ThreadLocal</code>的值。</p><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191609.png"></p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191704.png"><br>可以看出来，一个 ThreadLocal 只能保存一个 “key : value” 键值对，并且各个线程的数据互不干扰。</p><h3 id="ThreadLocal经典之内存泄漏"><a href="#ThreadLocal经典之内存泄漏" class="headerlink" title="ThreadLocal经典之内存泄漏"></a>ThreadLocal经典之内存泄漏</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203192458.png"></p><p><strong>Entry结构</strong><br>ThreadLocalMap，底层保存了Entry数组，作为存储的桶。</p><p>Entry结构持有：</p><ul><li>虚引用ThreadLocal</li><li>实引用Value</li></ul><p>在构造Entry（继承了<code>WeakReference&lt;ThreadLocal&gt;</code>，因此其可以虚引用一个<code>ThreadLocal</code>字段）的时候，会顺便把对应的<code>ThreadLocal</code>设置它的一个弱引用，空间不足且满足条件时可以将其释放。</p><p><strong>如何判断Entry的Index</strong><br>使用<code>(threadLocal.threadLocalHashCode &amp; capacity-1)</code>作为entry在数组中存放的地址。<br>这种设计是基于不会发生hash冲突的预期而实现的，数组中一个桶只放一个entry。</p><p><strong>为什么要使用弱引用保存key？</strong><br><code>ThreadLocalMap</code>的生命与<code>Thread</code>一样长，若使用了<code>ThreadLocal</code>作为键保存值而不进行回收，则会造成内存泄漏。</p><p><strong>存在的问题</strong><br>虽然key被设计成弱应用了，可以从某种程度上避免内存泄漏，但是，value仍然是强引用！需要<strong>显式地调用<code>remove</code>方法</strong>。</p><p><strong>为什么value不设置成弱引用</strong><br>因为不清楚这个value是否存在其他引用，如果value是弱引用对象，但存在其他引用，则GC时可能直接将value回收了。但ThreadLocal还在使用期间，导致get获取到null。</p><p><strong>要保证value的生命周期比key的生命周期长。</strong></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第3章（Lock接口）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、CAS"><a href="#一、CAS" class="headerlink" title="一、CAS"></a>一、CAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>乐观锁的目的就是在不使用锁（悲观锁）的情况下保证线程安全</strong>。<br>乐观锁在 Java 中是采用 CAS 算法实现的，J.U.C 包中的原子类就是通过 CAS 算法来实现了乐观锁。<br>使用这种 CAS 算法的代码也常被称为 <strong>无锁</strong> 编程（Lock-Free）。<br>**现代处理器基本都已经内置了实现 CAS 的指令，比如 x86 指令集上的 <code>CAMPXCHG</code>。<br>当多个线程尝试使用 CAS 同时更新主内存中的同一个变量时，只有一个线程可以成功更新变量的值，其他的线程都会失败，失败的线程并不会挂起，而是会自旋重试。</p><p><strong>CAS</strong>（Compare And Set）的步骤为：</p><ul><li>读取主内存值</li><li>将读取到的值再与主内存值比较</li><li>将新值交换到该变量</li></ul><h2 id="CAS三大问题"><a href="#CAS三大问题" class="headerlink" title="CAS三大问题"></a>CAS三大问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203125031.png"></p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><strong>在变量值前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A</strong>。<br>从 Java 1.5 开始，JDK 的 Atomic 包里提供了一个类 <code>AtomicStampedReference</code> 来解决 ABA 问题，把变量放在 <code>AtomicStampedReference</code> 类中即可。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>x86 指令集上使用 CAMPCHG 来实现 CAS 操作，我们在一些源码里看到的 CAS 操作其实都是对这条底层指令的封装罢了，而<strong>这条指令的功能就是一次只原子地修改一个变量</strong>。</p><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ol><li>使用锁</li><li>将变量合并，操作后再拆解</li></ol><p>从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，这样我们就可以把多个变量封装在一个对象里来进行 CAS 操作。</p><h3 id="循环时间开销"><a href="#循环时间开销" class="headerlink" title="循环时间开销"></a>循环时间开销</h3><p>失败时一直重试，开销过大，CPU空转</p><h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>使 JVM 支持底层指令 pause，这个指令的功能就是当自旋失败时让 CPU 睡眠一小段时间再继续自旋，其有两个作用：<br>1）降低读操作的频率；<br>2）避免在退出循环的时候因 内存顺序冲突（Memory OrderViolation） 而引起 CPU 流水线被清空（CPU PipelineFlush）。</p><blockquote><p>内存顺序就是CPU访问内存的顺序，持锁线程store后，其他线程load才可以获取锁，但如果重排序，会导致load到的数据无效，此时会清空流水线再重排序，而pause可以减少重排序所耗费的时间。</p></blockquote><h1 id="二、Unsafe与原子类"><a href="#二、Unsafe与原子类" class="headerlink" title="二、Unsafe与原子类"></a>二、Unsafe与原子类</h1><h2 id="Unsafe-类浅析"><a href="#Unsafe-类浅析" class="headerlink" title="Unsafe 类浅析"></a>Unsafe 类浅析</h2><p>Unsafe 类存在于 sun.misc 包中，单从名称看来就可以知道该类是非安全的，因为其内部方法操作可以像 C 的指针一样直接操作内存（全是本地方法）。</p><p>所以事实上 Java 官方也不建议我们直接去使用 Unsafe 类。J.U.C 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p><p>CAS相关方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203125836.png"><br>将参数重命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapXxx</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object expected, Object update)</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数 o 为给定对象，即包含要修改字段的对象</li><li>第二个参数 offset 为对象内存的偏移量，通过这个偏移量可以迅速定位字段并设置或获取该字段的值</li><li>第三个参数 expected 表示期望值</li><li>第四个参数 update 表示要设置的值</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>在 Atomic 包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新属性（字段）</li></ul><h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><ul><li><code>AtomicBoolean</code>：原子更新布尔类型</li><li><code>AtomicInteger</code>：原子更新整型</li><li><code>AtomicLong</code>：原子更新长整型</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203134452.png"><br>常用方法：</p><ul><li><code>addAndGet</code></li><li><code>compareAndSet</code></li><li><code>getAndIncrement</code>、<code>getAndDecrement</code></li><li><code>getAndSet</code></li></ul><p>这些方法底层都是调用Unsafe类的方法进行CAS操作。<br>对于其他基本类型如char，float，double等，会先把其他类信息转换成int&#x2F;long类型再进行操作。</p><h3 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h3><ul><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203134948.png"><br>常用方法略，就是多一个数组索引。</p><h3 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h3><ul><li><code>AtomicReference</code>：原子更新引用类型</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li><li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203135105.png"><br>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReference&lt;User&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">16</span>);                <br>reference.set(user1);            <br><br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user2&quot;</span>, <span class="hljs-number">18</span>);<br>reference.compareAndSet(user1, user2);<br><br>System.out.println(reference.get().getName()); <span class="hljs-comment">// &quot;user2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原子更新字段"><a href="#原子更新字段" class="headerlink" title="原子更新字段"></a>原子更新字段</h3><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段</li><li>AtomicLongFieldUpdater：原子更新长整型字段</li><li>AtomicStampedReference：原子更新带有版本号的引用类型</li></ul><p>这三个方法不同于前面的简单封装，而是被称为原子更新器，构造函数如下：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203135443.png"><br>即都是通过抽象类的静态方法获取更新器实例，基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 原子更新 User 类的 age 字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 旧值是 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> updater.getAndAdd(user, <span class="hljs-number">5</span>); <span class="hljs-comment">// 原子更新为 5</span><br>        System.out.println(oldValue); <span class="hljs-comment">// 1</span><br>        System.out.println(updater.get(user)); <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="三、Lock接口"><a href="#三、Lock接口" class="headerlink" title="三、Lock接口"></a>三、Lock接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>为什么需要Lock？</strong></p><ul><li>synchronized锁隐式的限定了锁的获取和释放位置，导致某线程获取锁的顺序总是先获取先释放（栈式），满足不了更多的需要，而lock手动获取释放。</li><li>synchronized只实现了互斥锁，且无法被中断（而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。）</li><li>lock可以选择是否公平</li></ul><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>         <span class="hljs-comment">// 加锁</span><br>reentrantLock.lock();<br>        <br><span class="hljs-comment">// do something ....</span><br>        <br>         <span class="hljs-comment">// 解锁</span><br>        reentrantLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>lock()：尝试获取锁，获取锁成功后返回</li><li>lockInterruptibly()：可中断的获取锁。所谓可中断的意思就是，在锁的获取过程中可以中断当前线程</li><li>tryLock()：尝试非阻塞的获取锁。不同于 lock() 方法在锁获取成功后再返回，该方法被调用后就会立即返回。如果最终获取锁成功返回 true，否则返回 false</li><li>tryLock(long time, TimeUnit unit)：超时的获取锁。如果在指定时间内未获取到锁，则返回 false</li><li>unlock()：释放锁</li><li>newCondition()：当前线程只有获得了锁，才能调用 Condition 接口的 await 方法。Condition 接口本文就先不做详细赘述了</li></ul><p>Lock是一个<strong>接口</strong>，它规定所有的锁要实现这6个方法(调用层)从而实现锁的功能。</p><h2 id="Lock底层：AQS"><a href="#Lock底层：AQS" class="headerlink" title="Lock底层：AQS"></a>Lock底层：AQS</h2><p>Lock 接口的实现基本都是通过聚合了一个队列同步器（AbstractQueuedSynchronizer，AQS）的<strong>子类</strong>来完成线程访问控制的。<br>比如 ReentrantLock：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203140146.png"><br>而AbstractQueuedSynchronizer：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203140222.png"><br>总结：</p><ul><li><code>Lock</code>的实现类（如<code>ReentrantLock</code>）基本都是通过使用它的一个<code>内部队列</code>（sync）来实现线程的控制访问的。</li><li><code>ReentrantLock</code>有一个内部抽象类<code>Sync</code>，该类继承另一个抽象类<code>AbstractQueuedSynchronizer</code>，并完成部分方法重写。</li><li><code>ReentrantLock</code>还有一些非抽象类，继承<code>Sync</code>，并对其部分方法进行重写，实现不同的队列控制，所谓的内部队列，就是某个非抽象类的实例。</li><li><code>AbstractQueuedSynchronizer</code>被称作同步器，其将一些方法开放给子类写，实现了不同需求的锁控制。</li></ul><h3 id="AQS方法"><a href="#AQS方法" class="headerlink" title="AQS方法"></a>AQS方法</h3><blockquote><p>理解 模板方法设计模式 是理解 AQS 的关键，所谓模板方法可以简单理解为不可被子类重写的方法，模板方法相当于一个骨架，也就是说整体骨架不能被改变，里面具体实现细节可以开放给子类进行重写。</p></blockquote><ul><li>AQS 中的模板方法 <code>acquire()</code>，可以看到被 <code>final</code> 关键字标识了，不可被继承重写。</li><li>但是这个模板方法中调用的 <code>tryAcquire</code> 就是开放给子类进行重写的。</li></ul><blockquote><p>谈谈对AQS的理解：<br>AQS 是一个抽象类，是用来构建锁或者其他同步组件的<strong>基础框架</strong>，它使用了一个 <strong>volaitle 修饰的 int 成员变量 state 表示同步状态</strong>，通过内置的 FIFO 双向队列（源码注释上写的 CLH（Craig，Landin，and Hagersten） 队列（三个人名的简称），其实就是一个先进先出的双向队列）来完成线程们获取资源的时候的排队工作。<br>具体来说，如果某个线程请求锁（共享资源）失败，则该线程就会被加入到 CLH 队列的末端。当持有锁的线程释放锁之后，会唤醒其后继节点，这个后继节点就可以开始尝试获取锁。</p></blockquote><h3 id="成员变量state"><a href="#成员变量state" class="headerlink" title="成员变量state"></a>成员变量state</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>    state = newState;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加锁时，通过CAS，state+1</li><li>释放时，通过CAS，state-1</li></ul><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><h4 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h4><p><code>addWaiter</code>，通过CAS创建一个node并添加到队列尾部。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203143108.png"><br>这里注意有一个添加Waiter时还需要指定一个Node对象<code>mode</code>，这是Node类的静态字段，主要其标记作用，用来指定是共享锁还是排他锁（可以看后面的Node节点中源码和AQS两套模式）。</p><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142026.png"><br>首节点的线程 A 在释放同步资源时，将会唤醒器其后继节点 B，而后继节点 B 被唤醒后，就会重新尝试加锁，同样还是 CAS 操作给 state 变量加 1，如果成功，就<strong>将自己CAS设置为首节点</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142115.png"></p><p>设置首节点是不需要CAS的，因为当线程能否设置首节点时，说明已经获取到了同步资源，只有一个线程能做到（只有一个线程可以将state状态从0 CAS到 1）。</p><h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><p>addWaiter方法中调用了enq方法，这个方法通过死循环的方式使用CAS将节点设置成尾节点，即enq方法将<strong>并发添加节点的请求变成“串行化”了</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142655.png"></p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <br><span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><br>    <span class="hljs-keyword">volatile</span> Node prev; <span class="hljs-comment">// 前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node next; <span class="hljs-comment">// 后继节点</span><br><br>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 当前线程的引用</span><br><br>    Node nextWaiter; <span class="hljs-comment">//标记节点是共享锁还是排他锁</span><br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 最后一个节点</span><br></code></pre></td></tr></table></figure><p>每个Node拥有其<strong>线程的引用</strong>和一个<strong>状态</strong>，主要关注下面两个状态：</p><ul><li><code>CANCELLED</code>：表示取消状态，就是说我不要这个锁了，请你把我从队列中移出去。</li><li><code>SINGAL</code>：表示<strong>当前节点的后继节点</strong>正在等待，注意是后继节点，不是当前节点。</li></ul><h3 id="AQS两套模式"><a href="#AQS两套模式" class="headerlink" title="AQS两套模式"></a>AQS两套模式</h3><p>AQS的模板方法有：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203143651.png"><br>主要分三类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>独占Exclusive（排它锁模式）和共享 Share（共享锁模式）就是 AQS 提供的两种模式。事实上，在 AQS 的所有子类中，只会使用这两种模式的其中之一，要么实现并使用了独占锁的 API，要么使用了共享锁的 API，<strong>不会一个子类同时使用两套不同的模式。</strong><br>独占锁与共享锁在创建自己的节点时（<code>addWaiter</code> 方法）会通过 <code>nextWaiter</code> 变量来表明身份。</p><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="锁获取"><a href="#锁获取" class="headerlink" title="锁获取"></a>锁获取</h5><p>独占锁就是在同一时刻只能有一个线程获取到锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 此方法会尝试去获取锁</span><br>        <span class="hljs-comment">// 将当前线程加入 CLH 队列中，这里可见添加了独占节点</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>tryAcquire是开放给子类重写的，所以子类可以自定义这个方法是否实现公平竞争。即共享&#x2F;排他是AQS内部实现的，公平&#x2F;非公平是子类实现的。</p>          </div><p>acquireQueued方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 当前节点的前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果当前节点的前驱节点是头节点并且成功获取锁，则当前线程获取到独占锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 获取独占锁失败，则当前线程进入等待态</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意三点：<br>1)<code>if (p == head &amp;&amp; tryAcquire(arg))</code><br>如果当前节点的前驱节点是<strong>头节点</strong>并且成功获取锁，则当前线程获取到独占锁。<br>此时当前节点被称为<strong>首节点</strong>（与头节点做区分）。</p><p>2）<code>for(;;)</code><br>会通过死循环（<strong>自旋</strong>）获取锁，如果失败了就阻塞该线程，直到被唤醒。</p><p>3）<code>setHead(node)</code><br>将当前节点作为头节点</p><div class="note note-danger">            <p>重点解释一下，如果某个线程节点是<strong>头节点</strong>，意味着该线程可能<br>1.持有锁<br>2.之前持有锁，但已经释放了（该节点此时是空节点）</p><p>释放节点的时候，并不会像链表一样由头节点线程操作链表将自己弹出，而是释放锁（state &#x3D; 0），然后唤醒后继节点，后继节点发现自己已经是头节点的后继节点，且成功的获取同步（state &#x3D; 1），则将之前的头节点弹出，自己做新的头节点。</p>          </div><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203144926.png"></p><div class="note note-primary">            <ol><li>先看能否直接获取同步状态，有则直接获取return</li><li>若不能，则说明其他线程持有锁</li><li>在通过CAS添加节点的时候，再对前驱节点做一次判断，因为此时锁可能已经被释放，若前驱节点为头节点，则尝试获取同步状态，成功则return</li><li>若前驱节点不是头节点，或前驱节点是头节点，但同步状态获取失败，则线程进入等待状态park(waitStatus变成)。</li></ol>          </div><h5 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unparkSuccessor</code>用于CAS操作唤醒头节点的后继节点：</p><ul><li>改变头节点的waitStatus</li><li>校验后续节点的waitStatus查看是否已经放弃</li><li>若通过了则唤醒后继节点</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>在获取同步状态（锁）时，AQS 维护一个 CLH 双向队列，获取锁失败的线程都会通过 CAS 操作被加入到队列尾端，并且在队列中<strong>尝试获取锁，失败则中断，等待唤醒再循环获取过程</strong>；</li><li>停止自旋（或者说被移除 CLH 队列）的条件是其<strong>前驱节点为头节点并且成功获取了独占锁</strong>；</li><li>当前节点（线程）成功释放掉独占锁后，AQS 就会紧接着<strong>唤醒该节点的后继节点</strong>，这样，这个后继节点又会开始去尝试获取锁。循此往复。</li></ul><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="锁获取-1"><a href="#锁获取-1" class="headerlink" title="锁获取"></a>锁获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取失败则执行<code>doAcquireShared</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样会无限自旋直到获取锁：</p><ul><li>头节点的后继节点</li><li>成功获取锁，即拿到需要的资源量arg</li></ul><p><code>setHeadAndPropagate</code>：自己拿到资源后，如果条件满足还会唤醒后继节点，因为这里是共享模式。</p><h5 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doReleaseShared</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>独占锁的释放直接就调用了 unparkSuccessor 方法唤醒后继节点，而共享锁这里，在 unparkSuccessor 之前还加了一个循环和 CAS 的操作来确保共享锁成功释放，因为可能同时存在多个线程释放锁（共享）。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>共享锁与排他锁方法的区别：<br>这里的共享模式不同于读写锁，而是一种资源限制策略，一次只允许若干线程获取锁资源，前面的线程在释放锁之后，后面的线程就可以使用该线程释放的资源。</p><blockquote><ul><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul></blockquote><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>重入锁</strong>，是Lock接口的实现，聚合了AQS。</p><h3 id="重入锁原理"><a href="#重入锁原理" class="headerlink" title="重入锁原理"></a>重入锁原理</h3><h4 id="锁获取-2"><a href="#锁获取-2" class="headerlink" title="锁获取"></a>锁获取</h4><p>对于公平锁和非公平锁来说，它们获取锁的方式是不同的。</p><blockquote><p>ReentrantLock 的 tryLock 方法调用的也就是非公平锁的方法，也就是说，即使该锁是公平锁，使用 tryLock() 方法的话也会使用非公平的方式去获取锁。</p></blockquote><p>这里以获取非公平锁为例：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203163610.png"><br>该方法只定义如何获取锁，失败后策略在AQS中已经实现：</p><ul><li>若锁不被占有则获取return true</li><li>若被占有则检查持有者是否为本线程，是则获取+1，return true</li><li>否则return false</li></ul><h4 id="锁释放-2"><a href="#锁释放-2" class="headerlink" title="锁释放"></a>锁释放</h4><p>通过CAS令state–，如果state &#x3D; 0，则释放锁。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>红线表示内部类，蓝线表示继承，绿色虚线表示实现接口：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164710.png"><br>ReentrantLock 的无参构造使用的就是非公平锁：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164756.png"><br>当然也可以传入一个 boolean 值，true 时为公平锁，false 时为非公平锁：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164805.png"><br>重写方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164823.png"><br>都只重写了加锁方法，公平锁和非公平锁的释放方法相同。</p><p>调用链：<br>ReentrantLock.lock -&gt; Sync.lock -&gt; NonfairSync&#x2F;FairSync.lock -&gt; AQS.acquire -&gt; NonfairSync&#x2F;FairSync.tryAcquire()</p><ul><li>lock是根据具体实现决定执行方式</li><li>tryLock永远通过非公平方式，所以其实现放在了Sync中</li></ul><h4 id="底层区别"><a href="#底层区别" class="headerlink" title="底层区别"></a>底层区别</h4><p>公平锁的 <code>tryAcquire</code> 方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203165544.png"><br>公平锁多了<code>hasQueuedPredecessors</code>，快速判断当前节点是否有前驱节点。</p><ul><li>公平锁：先判断队列，再尝试CAS操作state</li><li>非公平锁：先CAS，失败再看队列，对于非公平锁，可能存在一个线程刚被唤醒与另一个外部线程同时尝试CAS。</li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>非公平锁的效率最高，所以<code>tryLock</code>的默认实现是非公平的。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>读写锁中的读锁和写锁也都是<strong>可重入</strong>的。通过分离读锁和写锁，使得读写锁的并发性能相比一般的排他锁有了很大提升。</p><h3 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170043.png"><br>这个接口只有两个方法，<code>readLock</code> 用来获取读锁，<code>writeLock</code> 用来获取写锁。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>ReentrantReadWriteLock</li><li>StampedLock，是对前者的增强</li></ul><h3 id="ReentrantReadWriteLock-1"><a href="#ReentrantReadWriteLock-1" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170223.png"><br>读写锁拥有读锁和写锁两个实体。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <br>    <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();  <br>    <span class="hljs-comment">// 读写锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();    <br>    <span class="hljs-comment">// 读锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> rwl.readLock();    <br>    <span class="hljs-comment">// 写锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> rwl.writeLock();    <br>    <span class="hljs-comment">// 获取一个 key 对应的 value    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123; <br>        <span class="hljs-comment">// 加读锁</span><br>        readLock.lock();            <br>        <span class="hljs-keyword">try</span> &#123;                    <br>            <span class="hljs-keyword">return</span> map.get(key);            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放读锁</span><br>            readLock.unlock();            <br>        &#125;    <br>    &#125;    <br>    <span class="hljs-comment">// 设置 key 对应的 value，并返回旧的 value    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;    <br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();            <br>        <span class="hljs-keyword">try</span> &#123;                    <br>            <span class="hljs-keyword">return</span> map.put(key, value);            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放写锁</span><br>            writeLock.unlock();            <br>        &#125;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果不使用读写锁，就需要使用java的等待通知机制（wait,notify）。使用读写锁比等待通知方式简单的多。</p></blockquote><h4 id="ReentrantWriteLock"><a href="#ReentrantWriteLock" class="headerlink" title="ReentrantWriteLock"></a>ReentrantWriteLock</h4><p>使用一个state同时维护读、写状态，将 32 位的整型变量 state 切分成两个部分，高 16 位表示读，低 16 位表示写：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170539.png"><br>通过位运算即可获取、修改状态。</p><h5 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h5><ul><li>如果当前有锁（state !&#x3D; 0）<ul><li>如果读锁（高16位）已经被获取过，则无法获取写锁。</li><li>如果没有读锁（高16位），且写锁持有者是自己，则可以重入。</li></ul></li><li>如果没锁<ul><li>尝试CAS获取</li></ul></li></ul><h5 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h5><ul><li>如果当前线程持有写锁，可重入</li><li>如果当前线程没有写锁<ul><li>如果其他线程有写锁，失败</li><li>如果其他线程没有写锁，查看本线程是否有读锁<ul><li>有则state++</li><li>没有则CAS获取</li></ul></li></ul></li></ul><p><strong>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在 <code>ThreadLocal</code> 中，由每个线程自己来维护</strong>，这使获取读锁的实现变得复杂。</p><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>读写锁中的锁降级指的是，<strong>写锁降级成为读锁</strong>。<br>把持住当前线程所拥有的写锁，然后获取到读锁，随后释放先前拥有的写锁。</p><p>主要应用在于：<br>某线程的加锁写操作对其后续的读操作必然是<strong>可见</strong>的，中间不会被其他线程修改。</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Lock中，通过Condition中实现等待通知功能。<br>lock有一个方法是<code>newCondition()</code>，其可以生成一个Condition对象并返回。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>Condition</code>接口的实现类为<code>ConditionObject</code>，其存在于AQS内部。</p><p>Condition也是通过队列的方式实现阻塞和唤醒的，与AQS中的CLH不同在于，Condition队列叫做<strong>等待队列</strong>，CLH队列叫做<strong>同步队列</strong>。</p><p>Condition等待队列是一个FIFO的<strong>单向队列</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203172742.png"></p><p><strong>一个 Lock 对象可以拥有一个同步队列和多个等待队列</strong>：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203172822.png"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>当前线程调用<code>Condition.await()</code> 方法，<strong>将会以当前线程构造节点，并将节点从尾部加入等待队列。</strong></p><p>不同于 CLH 同步队列在尾部添加节点时需要使用 CAS 操作，<strong>Condition 等待队列不需要 CAS 的保证</strong>，因为调用 <code>await</code> 方法的线程必定是获取了 Lock的线程，不会有其他线程来争夺这个添加尾部节点的操作。<br>从逻辑上看，这与设置头节点不需要CAS相同。<br>从语义上看，这与<code>wait()</code>方法只在<code>synchronized</code>块中调用相同。</p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p><strong>将 Condition 等待队列的首节点移动到 CLH 同步队列的尾部</strong><br>同样，<code>signal</code> 这个方法，一定是当前占据锁的线程调用的。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203173352.png"></p><h4 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h4><p>将等待队列中所有节点全部移动到同步队列中。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第2章（三大关键字）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1）根据线程要不要锁住共享资源，可以分为：</p><ul><li>悲观锁：锁住共享资源</li><li>乐观锁：不锁住共享资源</li></ul><p>2）如果试图锁住共享资源失败，那么线程要不要阻塞？如果不想要阻塞线程，可以通过以下两种锁实现：</p><ul><li>自旋锁</li><li>适应性自旋锁</li></ul><p>3）根据多个线程竞争锁时是否需要排队，可以分为：</p><ul><li>公平锁：需要排队</li><li>非公平锁：先尝试插队，插队失败再排队</li></ul><p>4）根据一个线程是否能够重复获取同一把锁，可以分为：</p><ul><li>可重入锁：能被同一个线程重复获取</li><li>不可重入锁：不能被同一个线程重复获取</li></ul><p>5）根据锁只能被单个线程持有还是能被多个线程共同持有，可以分为：</p><ul><li>排他锁：锁只能被单个线程持有</li><li>共享锁：锁能被多个线程共同持有</li></ul><p>6）以下这 4 种锁都是专门针对 synchronized 关键字的，是上面介绍的锁的组合实现：</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h2 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁 | 乐观锁"></a>悲观锁 | 乐观锁</h2><blockquote><p><strong>悲观锁是一种悲观思想</strong>，认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>乐观锁是一种乐观思想</strong>，认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在提交修改的时候去判断一下，在此之前有没有其他的线程也修改了这个数据：</p><ul><li>如果其他的线程还没有提交修改，那么当前线程就将自己修改的数据成功写入；</li><li>如果其他的线程已经提交了修改，则当前线程会根据不同的实现方式执行不同的操作（例如报错或者自动重试）</li></ul></blockquote><p>乐观锁的算法是CAS算法实现的，这种算法一般也被称为无锁编程（Lock-Free），这是一种算法思想。</p><p><strong>两者判断是否能拥有锁的时点不一样（先判断；先操作然后在提交时判断），判断的方式不一样（直接判断是否能获取；CAS算法）。</strong></p><div class="note note-primary">            <p>实用区别：</p><ul><li>悲观锁一般性能差，但修改量太大的话性能会好。</li><li>乐观锁一般性能好，但一直失败的话不如悲观，防止空转。<br>实现：</li><li><code>synchronized</code>和<code>Lock接口</code>的实现类都是悲观锁</li><li><code>JUC</code>的原子类是乐观锁。</li></ul>          </div><h2 id="自旋锁-自旋适应锁"><a href="#自旋锁-自旋适应锁" class="headerlink" title="自旋锁 | 自旋适应锁"></a>自旋锁 | 自旋适应锁</h2><blockquote><p><strong>自旋锁</strong>就是“稍等一下”，其实就是个 do-while 循环。更底层来说自旋操作就是<strong>空转 CPU</strong>，执行一些无意义的指令，目的就是不让出 CPU 等待锁的释放。如果这个线程自旋完成后，前面锁定共享资源的线程已经释放了锁，那么这个线程就可以不必被阻塞而是直接获取共享资源，从而<strong>避免切换操作系统状态的开销</strong>。</p><p><strong>自旋适应锁</strong>：如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源，空转，死等，还不如被阻塞住。自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。默认是 10 次，可以使用参数<code>-XX:PreBlockSpin</code>来更改。而在 JDK 1.6 中，对于自选等待的次数这个问题，做出了一次优化，即引入了<strong>适应性自旋锁</strong>（自适应的自旋锁）。</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么 JVM 就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；</li><li>如果对于某个锁，很少有线程通过自旋等待成功获得过，那么当以后有线程尝试获取这个锁时， JVM 可能省略掉自旋过程，直接阻塞住线程，避免空转浪费处理器资源。</li></ul></blockquote><p><strong>两者是判断当获取锁失败时策略，是直接阻塞还是稍作等待（实现是CAS算法）,并规定稍作等待的时长。</strong></p><div class="note note-primary">            <p>实用性：</p><ul><li>避免阻塞，阻塞后唤醒需要切换到内核态，对系统性能消耗大。<br>实现：</li><li>JUC的原子类是自旋锁，这也是一种乐观锁，可以说自旋锁的原理就是CAS算法。<br>乐观锁与自旋锁，CAS算法的关系：</li><li>CAS是一种实现自旋的算法</li><li>乐观锁和自旋锁都是期待可以获取同步资源并执行，因此在实现上总是同时出现，一个定义如何获取，一个定义失败行为。</li></ul>          </div><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 | 非公平锁"></a>公平锁 | 非公平锁</h2><blockquote><p><strong>公平锁</strong>：多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果该锁的等待队列为空，则直接占有锁；如果该锁的等待队列不为空，则该线程加入到等待队列的末尾，按照 FIFO 的原则从队列中取出线程，然后占有锁。</p><p><strong>非公平锁</strong>：线程会先尝试获取锁，如果获取不到，则再采用公平锁的方式也就是进入等待队列。也就是说，多个线程获取锁的顺序，不是按照 FIFO 的顺序，有可能后申请锁的线程比先申请的线程优先获取到锁。</p></blockquote><p>从源码上看，唯一区别就是公平锁在获取锁前多一个判断条件：<code>hasQueuedPredecessors</code>判断当前线程是否是等待队列中的第一个。</p><p><strong>两者决定多线程争夺时锁的归属策略</strong></p><div class="note note-primary">            <p>实用性：</p><ul><li>根据不同场景需要使用不同策略。</li><li>公平锁效率低，频繁阻塞造成进入内核态的开销。</li><li>非公平锁效率高，但可能饿死线程。</li></ul><p>实现：</p><ul><li>synchronized是非公平的</li><li>Lock接口的实现类ReentrantLock可以指定是否公平（默认非公平）。</li></ul>          </div><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 | 不可重入锁"></a>可重入锁 | 不可重入锁</h2><blockquote><p><strong>可重入锁</strong>：也称为递归锁，同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。</p><p><strong>不可重入锁</strong>：同一个线程不能获得同一个对象的锁两次。</p></blockquote><p>原理：如ReentrantLock，通过判断state字段，若为0则直接占用锁，不为0则判断主人是不是自己，若是，则锁上加一个记号。</p><p><strong>决定其在被一个线程重复获取时是否成功</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>防止同一个线程获取同一个锁失败<br>实现：</li><li>synchronized，ReentrantLock都是可重入锁。</li></ul>          </div><h2 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁 | 排他锁"></a>共享锁 | 排他锁</h2><blockquote><p><strong>共享锁</strong>：该锁可被多个线程所持有。如果线程 A 对数据 B 加上共享锁后，则其他线程只能对 B 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p><strong>排他锁</strong>：也称互斥锁、独享锁，该锁一次只能被一个线程所持有。如果线程 A 对数据 B 加上排它锁后，则其他线程不能再对 B 加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</p></blockquote><p>排他锁是一种悲观锁，共享锁是一种乐观锁。</p><p><strong>决定锁是否私有</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>根据场景，保证性能、准确性。<br>实现：</li><li>排他锁：synchronized 和 ReentrantLock、ReentrantReadWriteLock中的写锁。</li><li>共享锁：ReentrantReadWriteLock中的读锁。</li></ul>          </div><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 | 偏向锁 | 轻量级锁 | 重量级锁"></a>无锁 | 偏向锁 | 轻量级锁 | 重量级锁</h2><blockquote><p><strong>无锁（Lock-Free）</strong>,具体指的是没有使用悲观锁，如使用CAS算法的JUC原子类。</p><p><strong>偏向锁</strong>，锁会偏向于第一个获得它的<strong>线程</strong>，接下来如果没有其他线程竞争该锁，则该线程不需要进行CAS操作。偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制。</p><p><strong>轻量级锁</strong>，偏向锁时出现两个线程交替竞争则变成轻量级锁。（不会自旋）</p><p><strong>重量级锁</strong>，升级成重量级锁之后，线程如果没有争抢到锁，会进行一段自旋等待锁的释放。那么上文说过，自旋等待是需要有一定限度的，如果自旋等待超过了一定的次数（时间），那么这个线程就要被阻塞住了。因为涉及到操作系统所以重量。</p></blockquote><p>抛开无锁这个状态不谈，Java 中的<code>synchronized</code>有偏向锁、轻量级锁、重量级锁，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁就会按照顺序进行升级。</p><p>一般认为，<strong>锁只能升级不能降级</strong>，但实际上是有降级的，不过条件苛刻，可以忽略。</p><p><strong>定义了synchronized的状态，决定其在被一个或多个线程争夺时的线程的获取锁策略</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>无锁，写操作比较少时使用，使用CAS算法实现，效率高。</li><li>偏向锁，只有一个线程获取该锁时的策略，不会频繁的释放锁。</li><li>轻量级锁，两个线程交替拥有锁，但无实际竞争避免阻塞（<strong>信号量</strong>），像一个过渡状态，一旦竞争就变成重量级。</li><li>重量级锁，短暂自旋后会阻塞，安全性能好。<br>实现：</li><li><code>synchronized</code></li></ul>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>悲|乐观锁决定线程获取锁的行为时点和方式（先获取|先操作再校验）</li><li>自旋锁决定获取锁失败后的行为（阻塞|等待）</li><li>公平锁|非公平锁决定多线程竞争时的优先级（顺序|插队）</li><li>可重入锁|不可重入锁决定单线程能否重复获取锁</li><li>共享锁|排他锁决定锁能否被多个线程共有（读锁|写锁）</li></ol><p>无锁|偏向锁|轻量级锁|重量级锁是锁的状态，其是针对synchronized具体实现的分类，其他锁指的是思想。</p><div class="note note-primary">            <ul><li>synchronized 关键词是悲观锁、排他锁、可重入锁、(某些状态下可自旋)、非公平锁。</li><li>Lock接口的实现是悲观锁、可重入锁<ul><li>ReentrantLock是排他锁、有公平和非公平两种实现。</li><li>ReentrantReadWriteLock读锁是共享的，写锁是排他的。</li></ul></li><li>JUC原子类是乐观锁，自旋锁（可以认为，自旋操作的实现就是CAS，但乐观锁的实现不只CAS）。</li></ul>          </div><h1 id="二、synchronized关键字"><a href="#二、synchronized关键字" class="headerlink" title="二、synchronized关键字"></a>二、synchronized关键字</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1）对于普通同步方法（synchronized 修饰的普通方法），锁是<strong>当前实例对象</strong>。<br>2）对于静态同步方法（synchronized 修饰的静态方法），锁是<strong>当前类的 Class 对象</strong>。<br>3）对于同步方法块（synchronized 修饰的块），锁是<strong>Synchonized括号里配置的对象</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>monitorenter 和 monitorexit 来隐式地使用这两个操作。</p><h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>所有 Lock 实现都必须强制执行与内置监视器锁 synchronization 提供的相同的内存同步语义。<br>1）锁释放的内存语义：<strong>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong><br>2）锁获取的内存语义：<strong>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被锁保护的临界区代码必须从主内存中读取共享变量。</strong></p><blockquote><p>线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了消息，比如说告知对方我对某个共享变量做了修改；<br>线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的消息，比如说接收了线程 A 在释放这个锁之前对共享变量所做的修改；</p></blockquote><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><ol><li>普通同步方法：加上<code>ACC_SYNCHRONIZED</code>标识</li><li>静态同步方法：加上<code>ACC_SYNCHRONIZED</code>标识</li><li>同步方法块：方法的code属性中，多了<code>monitorenter</code>和<code>monitorexit</code>字节码。</li></ol><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="Monitor介绍"><a href="#Monitor介绍" class="headerlink" title="Monitor介绍"></a>Monitor介绍</h4><p>任何一个对象都与一个监视器（monitor）对象相关联。当一个监视器有拥有者（owner）的时候，这个监视器就会被锁定（locked）。</p><p>每个监视器都维护着一个自己被持有次数（或者说被锁住 locked）的计数器（count），具体如下：</p><ul><li>如果与对象关联的监视器的计数器为零，则线程进入监视器成为该监视器的拥有者，并将计数器设置为 1。</li><li>当同一个线程再次进入该对象的监视器的时候，计数器会再次自增</li><li>当其他线程想获得该对象关联的监视器的时候，就会被阻塞住，直到该监视器的计数器为 0 才会再次尝试获得其所有权。</li><li>因为计数器和owner的存在，被 <code>synchronized</code> 修饰的同步方法块对同一条线程来说是<strong>可重入</strong>的。所谓可重入就是说即使同一个线程反复进入一个同步方法块也不会出现自己把自己锁死的情况。</li></ul><div class="note note-primary">            <p>可见synchronized也是通过<strong>计数器信号量</strong>快速判断能否获取和重入次数的。</p>          </div><h4 id="ACC-SYNCHRONIZED"><a href="#ACC-SYNCHRONIZED" class="headerlink" title="ACC_SYNCHRONIZED"></a>ACC_SYNCHRONIZED</h4><p>方法级别的同步是隐式执行的，调用方法时，线程会进入对应对象的监视器，然后执行方法。<strong>在执行线程拥有监视器期间，没有其他线程可以进入这个方法</strong>。<br>另外，如果在调用同步方法过程中抛出异常并且同步方法没有处理该异常，则在异常重新抛出同步方法之前，该方法的监视器会自动退出。</p><h4 id="monitorenter、monitorexit"><a href="#monitorenter、monitorexit" class="headerlink" title="monitorenter、monitorexit"></a>monitorenter、monitorexit</h4><p>同步代码块是显示执行的。</p><h4 id="Monitor详解"><a href="#Monitor详解" class="headerlink" title="Monitor详解"></a>Monitor详解</h4><p>常见的进程同步与互斥机制是<strong>信号量</strong>和<strong>管程</strong>。</p><p>相比起信号量，管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。也就是说管程天生支持进程互斥。（排他锁）</p><p>Java中<strong>管程</strong>（monitor）的具体实现是<code>ObjectMonitor</code> 类。这是一个C++实现的类。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202192413.png"><br>补充：</p><ul><li>monitor还持有计数器count</li><li>WAITING列表中保存着：<strong>获得过锁但使用wait()方法等方式放弃锁的线程</strong>，它们等待被唤醒后进入RUNNABLE状态，此时无法获取锁则BLOCKED。</li></ul><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。<br>针对普通对象和数组对象：</p><ul><li>如果对象是数组类型，则虚拟机用3个字宽（Word，在32位系统中，一个word占4字节，32bit）存储对象头（Mard Word、类型指针、数组长度）</li><li>如果对象是非数组类型，则用2字宽存储对象头（Mard Word、类型指针）。</li></ul><p>在32位虚拟机中，1字宽等于4字节，即32bit，如表所示：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64 bit</td><td>Mark Word</td><td>存储对象的 hashCode 和锁信息等</td></tr><tr><td>32&#x2F;64 bit</td><td>Class Metadata（类型指针）</td><td>对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例</td></tr><tr><td>32&#x2F;64 bit</td><td>Array Length（数组长度）</td><td>数组的长度</td></tr></tbody></table><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202231421.png"><br>其中MarkWord部分是对象与monitor关联的重点，其有多种状态：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232949.png"><br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232952.png"></p><p>在64位下，MarkWord是64bit大小的，hashCode变成了31bit，原先的25bit则空了出来，且新增了1bit字段cms_free（CMS回收器GC时使用）<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232955.png"></p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>JDK1.6前，<strong>synchronized在1.6之前是一个重量级锁</strong>。</li><li>JDK1.6后，出现了各种锁优化技术，如自旋转，轻量级锁，锁消除和锁粗化等。</li></ul><h3 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h3><p><strong>自旋锁可以使线程免于阻塞但并不能代替阻塞</strong>，等待的时间必须有一定的限度，默认自旋等待次数是 10 次，用户也可以使用参数 <code>-XX：PreBlockSpin</code> 来自行更改，而在 JDK 1.6 中，对于自旋等待的次数这个问题，做出了一次优化，即引入了<strong>适应性自旋</strong>（也称为自旋适应锁）：</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么 JVM 就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；</li><li>如果对于某个锁，很少有线程通过自旋等待成功获得过，那么当以后有线程尝试获取这个锁时， JVM 可能省略掉自旋过程，直接阻塞住线程，避免空转浪费处理器资源。</li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能再降级回偏向锁（其实可以，要求很严格）</strong>。<br>Mark Word内容：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202233831.png"><br>初始状态和偏向锁下锁的标志位是<code>01</code>，轻量锁为<code>00</code>，重量锁为<code>10</code>，GC标记为<code>11</code>。<strong>01 -&gt; 00 -&gt; 10 -&gt; 11</strong></p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>1）<strong>检查Mark Word初始状态</strong>：需要保证对象无锁，即锁标志位为<code>01</code>，偏向锁标志位为<code>0</code>。<br>2）<strong>在当前线程的栈帧上建立锁记录</strong>：java虚拟机会将当前线程的<strong>栈帧</strong>中建立一个名为<strong>锁记录</strong>（Lock Record）的空间，Lock Record 中有一个字段 displaced_header，用于后续存储锁对象的 Mark Word 的拷贝。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202234727.png"><br>3）<strong>复制锁对象的 Mark Word 到锁记录中</strong>：把锁对象的 Mark Word 复制到锁记录中，更具体来讲，是将 Mark Word 放到锁记录的 <code>displaced_header</code>属性中。官方给这个复制过来的记录起名 <code>Displaced Mark Word</code>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202234855.png"><br>4）使用 <strong>CAS 操作更新锁对象的 Mark Word</strong>。Java 虚拟机使用 CAS 操作尝试把锁对象的 Mark Word 更新为指向锁记录的指针，并将锁记录里的 owner 指针指向对象的 Mark Word。</p><ul><li>如果这个更新操作成功了，就表明获取轻量级锁成功，也就是说该线程拥有了这个对象的锁！并且该对象 Mark Word 的锁标志位会被改为 00，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，那有两种可能性：<ul><li>当前线程已经拥有了这个对象锁（直接进入同步块继续执行）</li><li>存在其他的线程竞争获取这个对象锁（膨胀成重量级锁，锁标志的状态值变为 10，Mark Word 中存储的就是指向重量级锁（互斥量）的指针）</li></ul></li></ul><h5 id="当前线程已经拥有该锁"><a href="#当前线程已经拥有该锁" class="headerlink" title="当前线程已经拥有该锁"></a>当前线程已经拥有该锁</h5><p>虚拟机首先会检查该对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行（synchronized 是可重入锁）。</p><p>假设锁的状态是轻量级锁，下图反应了对象的 Mark word 和线程栈中锁记录的状态，可以看到左边线程栈中包含3个指向当前锁对象的 Lock Record。其中栈中最高位的锁记录为第一次获取轻量级锁时分配的，其 Displaced Mark word 的值为锁对象 obj 加锁之前的 Mark word，之后的每次锁重入都会在线程栈中分配一个 Displaced Mark word 为 <code>null</code>的锁记录。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202235425.png"></p><blockquote><p>为什么 synchronized 重入的时候 Java 虚拟机要在线程栈中添加 Displaced Mark word 为 null 的锁记录呢？</p><ul><li>首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，只有解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁的重入次数。</li><li>最简单的记录锁重入次数的方案就是将其记录在对象头的 Mark word 中，但 Mark word 大小有限，没有多出来的地方存放该信息了。</li><li>另一个方案就是在锁纪录中记录重入次数，但这样做的话，每次重入获得锁的时候都需要遍历该线程的栈找到对应的锁纪录，然后去修改重入次数的值，显然这样效率不是很高。</li></ul><p>所以最终 Hotspot 选择了每次重入获得锁都添加一个锁记录来表示锁的重入，这样有几个 Displaced Mark word 为 null 的锁记录就表示发生了几次锁重入，非常简单。</p></blockquote><h5 id="存在其他线程竞争该锁"><a href="#存在其他线程竞争该锁" class="headerlink" title="存在其他线程竞争该锁"></a>存在其他线程竞争该锁</h5><p><strong>轻量级锁 CAS 失败并不会自旋而是直接膨胀成重量级锁</strong>。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁的时候 Java 虚拟机会用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来：</p><ul><li>如果替换成功，那整个同步过程就顺利完成了</li><li>如果替换失败，则说明有其他线程尝试过获取该锁，轻量级锁会先膨胀成重量级锁然后再解锁（调用重量级锁的 exit 方法）</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>synchronized关键字会尝试加锁：将<strong>锁对象的对象头</strong>中的<strong>mark word</strong>(包括hashCode,age,lock信息)复制到<strong>当前线程的栈帧</strong>当中，叫做<strong>displaced mark word</strong>。然后尝试通过<strong>CAS</strong>算法替换<strong>对象头的markword</strong>为指向栈帧中<strong>displaced mark word</strong>的指针，并将栈帧中的<strong>owner</strong>指向对象。</p><ul><li>若当前对象的mark word没有被替换过，替换成功，获得锁。</li><li>若当前对象的mark word被替换过，考虑：<ul><li>之前是被本线程替换的，经过检查后，会再到本线程的栈帧中插入新的lock record(displaced header和owner的集合)，其中header为空，owner与之前的一样</li><li>若是其他线程的竞争，则膨胀成重量级锁。获取该重量级锁时会进行失败自旋。</li></ul></li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢</strong>。但大多数情况下无竞争，为了避免CAS的开销，引入了偏向锁。</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>1）查看对象头的 Mark Word 中偏向锁的标识以及锁标志位，若<strong>偏向锁</strong>标识为1 且 <strong>锁标志位</strong> 为 01，则该锁为<strong>可偏向状态</strong>；<br>2）若为可偏向状态，则测试 Mark Word 中的线程 ID 是否与当前线程相同，若相同，则不用执行 CAS 操作，直接进入同步块执行，否则进入下一步。<br>3）当前线程通过 CAS 操作竞争锁，若竞争成功，则使用 CAS 操作将 Mark Word 中线程 ID 设置为当前线程 ID（重新偏向），然后执行同步块；若竞争失败，则进入偏向锁撤销的流程。</p><p>轻量级锁重入：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000535.png"><br>偏向锁重入：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000550.png"></p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>偏向锁的撤销采用了 <strong>一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争</strong>。</p><p>如果当前线程通过 CAS 竞争偏向锁失败，说明存在锁竞争，则进入偏向锁撤销的流程，偏向锁的撤销需要等待 全局安全点 safe point（这个时间点上没有正在执行的代码），其具体步骤如下：<br>1）JVM 会先暂停拥有偏向锁的线程，判断持有偏向锁的线程是否还存活；<br>2）根据判断结果执行</p><ul><li>如果持有偏向锁的线程存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁竞争的逻辑里。</li><li>如果持有偏向锁的线程已经不存活或者不在同步块中，则将对象头的 Mark Word 改为无锁状态（01），以允许其他线程竞争锁，之后再升级为轻量级锁；<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000458.png"></li></ul><h4 id="批量重偏向和批量撤销"><a href="#批量重偏向和批量撤销" class="headerlink" title="批量重偏向和批量撤销"></a>批量重偏向和批量撤销</h4><p>批量指的是某个类的大量对象，是<strong>针对类的优化</strong>。<br><strong>批量重偏向</strong>（bulk rebias）：当某个类的对象的偏向锁的<strong>撤销次数</strong>超过重偏向阈值（默认 20 次）后，JVM 会这样觉得，我是不是偏向错了呢，于是在给这些对象加锁时会重新偏向至试图加锁的线程。</p><p><strong>批量撤销</strong>（bulk revoke）：当某个类的对象的偏向锁的<strong>撤销次数</strong>超过批量撤销阈值（默认40 次）后，JVM 会这样觉得，自己确实偏向错了，根本就不该偏向，于是整个类的所有对象 都会变为<strong>不可偏向</strong>的，新建的对象也是不可偏向的。通俗来说，JVM 会认为这个类的所有对象的使用场景都存在多线程竞争，会标记该类为不可偏向，之后，对于该类的对象的锁，都会直接走轻量级锁的逻辑。</p><h4 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h4><p>JDK 15废弃了偏向锁，其带来的作用已经不大。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>偏向锁其实就是为了避免一直获取，释放锁带来的消耗（CAS）,采用确认mark word中的线程id来判断是否属于自己，若不属于则升级为轻锁（尝试CAS），再不行就变成重锁（先自旋再堵塞）</p><p>一个对象有<strong>可偏向</strong>和<strong>不可偏向</strong>两种状态（取决于偏向锁标志位是否为1），且初始时是可偏向的。若是对象可偏向,则会尝试加偏向锁，否则直接走轻量级锁逻辑。</p><p><strong>撤销</strong>是等Save Point时，判断持有线程是否仍在同步块中：</p><ul><li>若在，则升级锁为轻量级锁（发生竞争）。</li><li>若不在，则将其变成无锁状态（此时<strong>不可偏向</strong>，此后该线程获取该对象锁时会直接获取轻量级锁）。<br>但是，若大量同类对象偏向锁的被撤销，则给与该类的对象重新偏向其他线程的机会（标记为<strong>可偏向</strong>），但是若再被撤销太多次，则变成<strong>不可偏向</strong>。</li></ul><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>Lock Elimination:锁消除的概念比较容易理解，就是<strong>如果编译器认定一个锁只会被单个线程访问，那么这个锁就可以被消除</strong>。</p><p>锁消除需要进行逃逸分析：</p><ul><li>方法逃逸</li><li><strong>线程逃逸</strong></li></ul><p>针对是否逃逸，JVM的优化有：</p><ul><li><strong>同步省略</strong></li><li>标量替换</li><li>栈上分配</li></ul><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>Lock Coarsening:如果虚拟机检查到有这样一串连续的操作都是对同一个对象进行加锁，就会把加锁同步的范围粗化（扩大）到整个操作序列的外部。<br>简单来说，锁粗化就是把多次加锁请求合并成一次。如<code>sb.append()</code>连续调用。</p><h2 id="wait和synchronized"><a href="#wait和synchronized" class="headerlink" title="wait和synchronized"></a>wait和synchronized</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>wait方法必须在 synchronized 同步块中调用</li><li>wait方法是Object实现的native方法</li></ul><p>某线程A调用对象a的<code>wait</code>方法，会让线程处于WAITING状态，直到另一个线程调用对象a的<code>notify</code>（随机）或<code>notifyAll</code>（所有）方法。可以看出，对象a基本上是信号的传递者的角色。</p><p><strong>调用 <code>wait</code> 方法的线程必须拥有此对象的监视器</strong>，否则报异常。该方法将当前线程（称为 T）置于此对象的 WaitSet 中，然后放弃该对对象的锁。直到被唤醒或中断、超时。</p><p>总结：调用 wait 方法就是对象通知持有自己锁的线程释放该锁并等待；而 notify 和 notifyAll 方法就是对象通知在等待的线程又可以来竞争我的锁了。</p><h3 id="无效唤醒-Lost-Wakeup"><a href="#无效唤醒-Lost-Wakeup" class="headerlink" title="无效唤醒 Lost Wakeup"></a>无效唤醒 Lost Wakeup</h3><p>为什么必须在同步块中调用wait？<br>wait要在notify前发生，即编程时希望先让某线程wait，再由其他线程唤醒它，但是多线程下不能保证wait发生在notify后，所以需要用锁来保证只有wait成功之后，其他线程才能notify这个对象。</p><h3 id="虚假唤醒-Spurious-Wakeup"><a href="#虚假唤醒-Spurious-Wakeup" class="headerlink" title="虚假唤醒 Spurious Wakeup"></a>虚假唤醒 Spurious Wakeup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(某条件)&#123;<br><span class="hljs-comment">//等待</span><br><span class="hljs-built_in">this</span>.wait();<br>&#125;<br><span class="hljs-comment">//执行某事件</span><br><span class="hljs-keyword">do</span>();<br><span class="hljs-comment">//通知其他线程</span><br><span class="hljs-built_in">this</span>.notifyAll();<br></code></pre></td></tr></table></figure><p>在if条件语句不满足条件时，线程进入wait，被唤醒时其if条件仍不满足，因此需要把if改成while。</p><h1 id="三、Volatile"><a href="#三、Volatile" class="headerlink" title="三、Volatile"></a>三、Volatile</h1><p>当一个变量被定义成 volatile 之后，它将具备两项特性：</p><ol><li>保证此变量对所有线程的<strong>可见性</strong>。所谓 “可见性” 就是指当一条线程修改了这个变量的值，其他线程可以立即得知这个修改。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</li><li><strong>禁止指令重排序</strong>。事实上，普通的变量是无法保证变量赋值操作的顺序与程序代码的执行顺序是一致的，在某些情况下，可能会出现意想不到的结果。</li></ol><h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><ol><li><strong>volatile 写的内存语义</strong>：当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li><strong>volatile 读的内存语义</strong>：当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ol><p>事实上，更底层来讲，有 volatile 变量修饰的共享变量进行写操作的时候会多出一条Lock前缀的指令，根据 IA-32 架构软件开发者手册，这条指令会引发两件事情：<br>1）将当前处理器缓存行的数据写回到系统内存<br>2）这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效<br>即<strong>无效其他线程本地内存的操作实际上是在写时就发生了</strong>。</p><h2 id="volatile禁止指令重排"><a href="#volatile禁止指令重排" class="headerlink" title="volatile禁止指令重排"></a>volatile禁止指令重排</h2><p>绿色表示可以重排序，红色则不能：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203010905.png"><br>简而言之：</p><ul><li>volatile写之前的不许被排序在其后（写之后不被修改）</li><li>volatile读之后的不许排序在其前（读之前不被修改）</li><li>volatile写和读不可以重排序</li></ul><p>更底层的，禁止指令重排的底层原理是插入内存屏障：编译器在生成字节码的时候，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序：</p><p>1）在每个 volatile 写操作的前面插入一个 StoreStore 屏障；在每个 volatile 写操作的后面插入一个 StoreLoad 屏障<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011123.png"></p><p>2）在每个 volatile 读操作的后面插入一个 LoadLoad 屏障和一个 LoadStore 屏障（图中volatile读前有一个Load屏障）<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011141.png"></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>内存屏障是一种指令，无论是在JAVA内存模型还是CPU层次，都是有具体的指令对应的，是一种特殊的指令，作用为禁止指令</strong><br>重排序的内存屏障有四种，分别叫做**LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</p><p>例子：LoadLoad屏障<br>序列：load1指令 <strong>LoadLoad屏障</strong> load2指令<br>作用：在load1指令和load2指令之间加上 LoadLoad屏障，<strong>强制先执行load1指令再执行load2指令</strong>；load1指令和load2指令不能进行重排序。</p><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011315.png"></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>volatile读需要保证，其后面的写操作不会重排序到其前面影响读结果（loadstore），同时保证其后的读的结果和本次读的结果一致（loadload）。</li><li>volatile写需要保证，其前面的写操作不会重排序到其后面（storestore），同时要保证可见性（storeload）。</li></ul><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p><strong>双重校验锁（Double Checked Locking，DCL）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span> &#123;<br><span class="hljs-comment">// 私有化构造方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span>&#123;&#125;; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">// 第一次校验</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;     <br>            <span class="hljs-keyword">synchronized</span> (SingleTon.class) &#123;<br>                <span class="hljs-comment">// 第二次校验</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;     <br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>                &#125;<br>        &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么 <code>instance</code> 一定要用 <code>volatile</code> 这个关键字来修饰？</p><h3 id="可见性应用"><a href="#可见性应用" class="headerlink" title="可见性应用"></a>可见性应用</h3><ul><li>第一次校验：直接返回已经创建的实例，且不通过同步方法，速度快。</li><li>第二次校验：防止两线程同时getIntance并通过第一次校验，导致创建两个对象。</li></ul><p>即只同步新建对象的过程，不影响直接返回对象的过程，且创建后对另一个线程<strong>可见</strong>。</p><h3 id="禁止指令重排序的应用"><a href="#禁止指令重排序的应用" class="headerlink" title="禁止指令重排序的应用"></a>禁止指令重排序的应用</h3><p>在 Java 语言层面上，创建对象仅仅是一个 new 关键字而已，而在 JVM 中，对象的创建其实并不是一蹴而就的，忽略掉一些 JVM 底层的细节比如设置对象头啥的，对象的创建可以大致分三个步骤：</p><ol><li>在堆中为对象分配内存空间</li><li>调用构造函数，初始化实例</li><li>将栈中的对象引用指向刚分配的内存空间</li></ol><p>为了防止2-&gt;3步发生重排序，使用volatile保证先创建完对象再给出引用。</p><h1 id="四、Final"><a href="#四、Final" class="headerlink" title="四、Final"></a>四、Final</h1><blockquote><p>引言：在旧的 Java 内存模型（JDK 1.5 以前）中，一个最严重的缺陷就是线程可能看到 final 域的值会改变。比如一个线程看到一个 int 类型 final 值为 0，此时该值是未初始化前的零值，一段时间后该值被某线程初始化，再去读这个 final 值会发现值变为 1。</p><p>为了修补这个漏洞，新的 Java 内存模型并增强了 final 的语义，通过为 final 域增加写和读重排序规则，为 Java 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（lock、volatile）就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p></blockquote><p>简单来说：只要一个不可变对象被正确地构建出来（即没有发生 this 引用逃逸的情况，这是一种例外），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。</p><p>甚至我们可以下结论：<strong>不可变对象永远是线程安全的。</strong></p><h2 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h2><p>构造对象时会初始化final域，此时：</p><ol><li>JMM <strong>禁止编译器</strong>把对 final 域的写指令重排序到构造函数之外。</li><li>编译器会在对 final 域的写指令之后，构造函数 return 之前，插入一个 StoreStore 屏障（这个屏障的作用就是<strong>禁止处理器</strong>把对 final 域的写指令重排序到构造函数之外）</li></ol><p>解释：<strong>编译器</strong>不做重排序，并通过storestore防止<strong>处理器</strong>重排序。<br>目的：保证先赋值对象的final属性，后完成初始化给出该对象引用。</p><h2 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h2><ol><li><strong>编译器不会</strong>把对final域的读重排序到对对象的读之前</li><li>但部分处理器可能会这么做，所以编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障<strong>禁止处理器</strong>重排序。</li></ol><blockquote><p>对于编译器和大部分处理器来说，肯定是不会对初次读对象引用与初次读该对象包含的 final 域这两个操作进行重排序的，因为这两个操作之间存在间接依赖关系。<br>但有少数处理器是允许对存在间接依赖关系的操作做重排序的，所以这个规则就是专门用来针对这种处理器的。</p></blockquote><p>解释：<strong>编译器</strong>一般不会重排序final读，同时通过loadload保证<strong>处理器不会</strong>把读final域的操作放在读其所属对象前。<br>目的：保证先获取到对象本身，然后再读final值。</p><h2 id="this引用逃逸"><a href="#this引用逃逸" class="headerlink" title="this引用逃逸"></a>this引用逃逸</h2><p>final保证了final属性在对象构造完成return前赋值，但若return前将this引用给到外部，此时对象尚未初始化完成，这就是一种线程逃逸。</p><p>避免：为了避免这种逃逸现象，最好不要这样编写代码，保证”只要一个不可变对象被正确地构建出来（即没有发生 this 引用逃逸的情况），那其外部的可见状态永远都不会改变”。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第1章（基础知识）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h1><h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>在操作系统中，内存通常会被分成用户空间（User space）与内核空间（Kernel space）这两个部分。当进程&#x2F;线程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态：</p><ul><li>运行在内核态的程序可以访问用户空间和内核空间，或者说它可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等。</li><li>而应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问用户空间。</li></ul><p>区分的目的：<br>用户态的程序不能随意操作内核地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。</p><p>那如果处于用户态的程序想要访问内核空间的话怎么办呢？<strong>就需要进行系统调用从用户态切换到内核态。</strong></p><h2 id="操作系统线程"><a href="#操作系统线程" class="headerlink" title="操作系统线程"></a>操作系统线程</h2><h3 id="用户空间实现线程"><a href="#用户空间实现线程" class="headerlink" title="用户空间实现线程"></a>用户空间实现线程</h3><p><strong>早期</strong>的操作系统<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202153716.png"><br>优点：</p><ul><li>第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；</li><li>第二点，线程的调度只发生在用户态，<strong>避免</strong>了操作系统从内核态到用户态的<strong>转换开销</strong>。</li></ul><p>缺点：</p><ul><li>CPU 的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于<strong>用户空间中没有时钟中断机制</strong>，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；</li><li>另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。</li></ul><h3 id="内核空间实现线程"><a href="#内核空间实现线程" class="headerlink" title="内核空间实现线程"></a>内核空间实现线程</h3><p><strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS X 和 Solaris 等，都支持内核线程。<strong>支持多线程的内核就叫做多线程内核</strong>（Multi-Threads Kernel）。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202154001.png"><br>我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，不需要像用户级线程那样自己设计线程调度等。</p><p>这种方式又分一对多、一对一、多对多三种，<a href="https://leetcode.cn/leetbook/read/concurrency/atqmpr/">参考</a></p><ul><li>一对多，特点同用户空间实现多线程</li><li>一对一，管理线程开销大，<strong>Windows (从 Win95 开始) 和 Linux 都实现了线程的一对一模型</strong>。</li><li>多对多，复用线程（线程池）</li></ul><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p><strong>线程库就是为开发人员提供创建和管理线程的一套 API</strong>。</p><p>下面简单介绍下三个主要的线程库：<br>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展<br>2）Win32 线程：用于 Window 操作系统的内核级线程库<br>3）Java 线程：<strong>Java 线程 API 通常采用宿主系统的线程库来实现</strong>，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p><p><strong>现今 Java 中线程的本质，其实就是操作系统中的线程。</strong></p><p>其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Win32 线程库来管理线程，且 Windows 采用的是一对一的线程模型。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有一个虚拟机栈空间。</p><p>当然，使用多线程就不可避免的会遇到一个问题，那就是线程的上下文切换（Thread Context Switch），就是说因为某些原因导致 CPU 不再执行当前的线程，转而执行另一个线程。</p><p>导致线程上下文切换的原因大概有以下几种：<br>1）线程的 CPU 时间片用完<br>2）发生了垃圾回收<br>3）有更高优先级的线程需要运行<br>4）线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p><p>当线程的上下文切换发生时，也就是从一个线程 A 转而执行另一个线程 B 时，需要由操作系统保存当前线程 A 的状态（为了以后还能顺利回来接着执行），并恢复另一个线程 B 的状态。</p><p>这个状态就包括每个线程私有的程序计数器和虚拟机栈中每个栈帧的信息等，显然，每次操作系统都需要存储这么多的信息，频繁的线程上下文切换势必会影响程序的性能。</p><h1 id="二、JAVA内存模型与原子性、可见性、有序性"><a href="#二、JAVA内存模型与原子性、可见性、有序性" class="headerlink" title="二、JAVA内存模型与原子性、可见性、有序性"></a>二、JAVA内存模型与原子性、可见性、有序性</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202154822.png"></p><blockquote><p>JMM(Java Memory Model) 规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory）。</p><p>线程的工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。</p></blockquote><p><strong>这就是并发时内存不一致的元凶！</strong></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>JMM 中定义了以下 8 种操作规范来完成一个变量从主内存拷贝到工作内存、以及从工作内存同步回主内存这一类的实现细节。Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li></ul><div class="note note-primary">            <ul><li>lock，unlock执行锁，操作主内存</li><li>read，write操作主内存</li><li>load，store操作工作内存</li><li>assign，use操作执行引擎<br>java的实现，保证以上8种类型的操作一定是原子操作。</li></ul>          </div><p><strong>如何保证原子性？</strong><br>处理器提供了总线锁和缓存锁，<strong>Java提供了锁和循环CAS的方式</strong></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>何为可见性</strong>？就是指当一个线程修改了共享变量的值时，其他线程能够<strong>立即</strong>得知这个修改。<br>所谓可见性就是要把工作内存内容立即写入主内存。</p><h3 id="如何保证可见性？"><a href="#如何保证可见性？" class="headerlink" title="如何保证可见性？"></a>如何保证可见性？</h3><ul><li><strong>volatile</strong>：volatile修饰的变量。</li><li><strong>synchronized</strong>：对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）</li><li><strong>final</strong>：被 <code>final</code> 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看见 <code>final</code> 字段的值。</li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>Java的编译器也有这样的一种优化手段：<strong>指令重排序</strong>（Instruction Reorder）。<br>但都需要遵守一个规定：<br><strong>as-if-serial 语义</strong>：不管怎么重排序，<strong>单线程</strong>环境下程序的执行结果不能被改变。即CPU和编译器不会对存在<strong>数据依赖关系</strong>（1.读后写2.写后读3.写后写）的操作做重排序。</p><p><strong>不同 CPU 之间和不同线程之间的数据依赖性是不被 CPU 和编译器考虑的</strong>。所以as-if-serial的约束在多线程下是无效的。</p><p>结论：<strong>CPU 和 Java 编译器为了优化程序性能，会自发地对指令序列进行重新排序。在多线程的环境下，由于重排序的存在，就可能导致程序运行结果出现错误</strong>。</p><h3 id="如何保证有序性？"><a href="#如何保证有序性？" class="headerlink" title="如何保证有序性？"></a>如何保证有序性？</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>as-if-serial规定</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li><code>volatile</code> 本身除了保证可见性的语义外，还包含了禁止指令重排序的语义，所以天生就具有保证有序性的功能。</li><li><code>synchronized</code>保证有序性的理论支撑，仍然是 JMM 规定在执行 8 种基本原子操作时必须满足的一系列规则中的某一个提供的：<strong>一个变量在同一个时刻只允许一条线程对其进行 lock 操作</strong></li><li><code>Happens-before</code> 原则</li></ul><div class="note note-primary">            <p>volatile和synchronized都可以保证可见性和有序性。<br>final可以保证可见性。<br>as-if-serial原则保证单线程有序性。<br>happens-before原则保证多线程有序性。</p>          </div><h2 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>可见性和有序性是矛盾的：我们希望内容足够可见，但又希望提高性能（重排序）。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>如果一个操作 Happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作<strong>可见</strong>，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 Happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 Happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 Happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）</li></ol><div class="note note-primary">            <p>如果A happens before B</p><ul><li>一般来说，A需要在<strong>先于</strong>B执行并保证结果<strong>可见</strong>。</li><li>但如果<strong>重排序</strong>不影响执行结果，也可以改变执行顺序。</li></ul>          </div><p>JMM 其实是在遵循一个基本原则：<strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行</strong>。</p><h3 id="8条Happens-before规则"><a href="#8条Happens-before规则" class="headerlink" title="8条Happens-before规则"></a>8条Happens-before规则</h3><p>1）程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生（Happens-before）于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// A  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// B  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;  <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure><p>有A happens-before B，B happens-before C</p><div class="note note-primary">            <p>类似于单线程下的as-if-serial</p>          </div><p>2）管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是 “同一个锁”，而 “后面” 是指时间上的先后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 此处自动加锁</span><br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span>) &#123;<br>        x = <span class="hljs-number">1</span>;<br>    &#125;      <br>&#125; <span class="hljs-comment">// 此处自动解锁</span><br></code></pre></td></tr></table></figure><p>3）volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的 “后面” 同样是指时间上的先后。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202164431.png"></p><blockquote><p>以下将happens before简写为hb<br>程序次序规则：1hb2，3hb4<br> volatile规则：2hb3<br>此时线程A执行writer()，线程B执行reader()<br>如果flag &#x3D;&#x3D; true，则i &#x3D; a &#x3D; 42；</p></blockquote><div class="note note-primary">            <p>因为变量flag被violate修饰，所以它不会发生重排序，写变量a一定在写变量flag前执行。同时，因为flag被violate修饰，所以它在写后会强制同步到主内存，即，该操作完成时即同步（<strong>可见性</strong>），在其后执行读变量的话读到的一定是最新值。</p>          </div><p>4）线程启动原则（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</p><p>5）线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread 对象的 join() 方法是否结束、Thread 对象的 isAlive() 的返回值等手段检测线程是否已经终止执行。</p><p>6）线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread 对象的 interrupted() 方法检测到是否有中断发生。</p><p>7）对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p>8）传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</p><div class="note note-primary">            <p>程管V启中终对传</p>          </div><h3 id="“时间上先后发生”和“先行发生”"><a href="#“时间上先后发生”和“先行发生”" class="headerlink" title="“时间上先后发生”和“先行发生”"></a>“时间上先后发生”和“先行发生”</h3><p><strong>两者并无必然关系</strong><br>时间上先后发生：指事件A在事件B之前执行<br>先行发生：指事件A的执行结果对事件B可见</p><ul><li>符合先行发生关系如果对结果没影响也可能被重排序，导致两者矛盾。</li><li>时间上先后发生的不一定先行发生，如两个线程，先后调用set，get方法，这样set在get前调用，但不一定先行发生，无法保证set的结果对get可见。</li></ul><h3 id="Happens-before-与-as-if-serial"><a href="#Happens-before-与-as-if-serial" class="headerlink" title="Happens-before 与 as-if-serial"></a>Happens-before 与 as-if-serial</h3><ul><li>as-if-serial 语义保证单线程内程序的执行结果不被改变，Happens-before 关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。Happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 Happens-before 指定的顺序来执行的。</li></ul><h1 id="三、Java线程"><a href="#三、Java线程" class="headerlink" title="三、Java线程"></a>三、Java线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Thread实现了Runnable接口。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202170026.png"></p><h3 id="1-线程与任务合并"><a href="#1-线程与任务合并" class="headerlink" title="1.线程与任务合并"></a>1.线程与任务合并</h3><p>直接继承Thread+重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义线程对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 线程需要执行的任务</span><br>......<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>();<br><br><span class="hljs-comment">// 一般使用匿名内部类</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-comment">// run 方法内实现了要执行的任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 线程需要执行的任务</span><br>    ......<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-线程与任务分离-Runnable"><a href="#2-线程与任务分离-Runnable" class="headerlink" title="2.线程与任务分离(Runnable)"></a>2.线程与任务分离(Runnable)</h3><p>Thread + 实现 Runnable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程需要执行的任务</span><br>    ......<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建任务类对象</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br><br><span class="hljs-comment">// 匿名内部类</span><br><span class="hljs-comment">// 创建任务类对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        ......<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br></code></pre></td></tr></table></figure><h3 id="3-线程与任务分离-Callable"><a href="#3-线程与任务分离-Callable" class="headerlink" title="3.线程与任务分离(Callable)"></a>3.线程与任务分离(Callable)</h3><p>Thread + 实现 Callable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        ......<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 将 Callable 包装成 FutureTask，FutureTask也是一种Runnable</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>Thread只实现了runnable，所以需要将callable包装成一个runnable，通常使用FutureTask进行包装，其是一个Runnable。</p>          </div><div class="note note-success">            <p>start会异步执行，run会同步执行（<strong>使用当前线程执行，没有真正创建新线程</strong>）。</p>          </div><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h3 id="操作系统线程五态模型"><a href="#操作系统线程五态模型" class="headerlink" title="操作系统线程五态模型"></a>操作系统线程五态模型</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202170624.png"></p><h3 id="Java线程六态模型"><a href="#Java线程六态模型" class="headerlink" title="Java线程六态模型"></a>Java线程六态模型</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202173309.png"></p><ul><li>Java线程模型将操作系统中就绪态（READY）和运行态（RUNNING）两种状态统称为 “RUNNABLE”。</li><li>Java线程新增了WAITING状态和TIMED_WAITING状态，是为了实现线程的手动唤醒。</li></ul><blockquote><p>LockSupport提供类似sleep的作用，其与锁无关：</p><ul><li>线程睡眠：</li><li>LockSupport.park();</li><li>LockSupport.parkNano(long time);</li><li>唤醒线程：</li><li>LockSupport.unpark(Thread t);</li></ul></blockquote><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><p>刚创建，还没start</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><p>调用start后</p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h4><p>阻塞于锁，即同步资源获取失败，指<code>synchronized</code>。</p><blockquote><p>LOCK接口中，线程会进入<strong>WAITING状态</strong></p></blockquote><h5 id="何时进入BLOCKED状态"><a href="#何时进入BLOCKED状态" class="headerlink" title="何时进入BLOCKED状态"></a>何时进入BLOCKED状态</h5><ol><li>首次竞争锁失败 RUNNABLE -&gt; BLOCKED</li><li>目标锁被其他线程释放，本线程被唤醒后再次竞争 BLOCKED -&gt; BLOCKED</li><li>处于等待状态的线程被唤醒然后竞争进入<code>synchronized</code>块 WAITING -&gt; RUNNABLE -&gt; BLOCKED</li></ol><div class="note note-primary">            <p>即WAITING状态的线程被唤醒后会先进入RUNNABLE状态，等待系统分配运行资源再竞争锁。</p>          </div><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><h5 id="RUNNABLE到WAITING"><a href="#RUNNABLE到WAITING" class="headerlink" title="RUNNABLE到WAITING"></a>RUNNABLE到WAITING</h5><ol><li>调用<code>Object.wait</code></li><li>调用<code>Thread.join</code>：当前线程调用t.join()，则当前线程需要等t执行完毕后才继续执行</li><li>调用<code>LockSupport.park</code></li></ol><h5 id="WAITING到RUNNABLE"><a href="#WAITING到RUNNABLE" class="headerlink" title="WAITING到RUNNABLE"></a>WAITING到RUNNABLE</h5><ol><li>调用了 <code>Object.notify</code></li><li>调用了 <code>Object.notifyAll</code></li><li>调用了 <code>LockSupport.unpark</code> 恢复某个线程的运行</li></ol><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>不同于WAITING，指定时间后返回到Runnable状态。</p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>终止状态，表示当前线程已经执行完毕。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM下篇:性能监控与调优</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8B%E7%AF%87-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8B%E7%AF%87-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p><strong>生产环境中的问题</strong></p><ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境CPU负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加log，如何确定请求是否执行了某一行代码？</li><li>不加log，如何实时查看某个方法的入参与返回值？</li></ul><p><strong>为什么要调优</strong></p><ul><li>防止出现OOM</li><li>解决OOM</li><li>减少Full GC出现的频率</li></ul><p><strong>不同阶段的考虑</strong></p><ul><li>上线前</li><li>项目运行阶段</li><li>线上出现OOM<div class="note note-primary">            <p>上面这些浏览一下，看个大概就行。</p>          </div></li></ul><h2 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h2><p><strong>监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>调优的大方向</strong></p><ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行JVM调优</li></ul><p><strong>性能优化的步骤</strong><br><strong>第1步：性能监控</strong></p><ul><li>GC频繁</li><li>cpu load过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul><p><strong>第2步：性能分析</strong></p><ul><li>打印GC日志来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo等</li><li>dump出堆文件，使用内存分析工具分析文件</li><li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li><li>jstack查看堆栈信息</li></ul><p><strong>第3步：性能调优</strong></p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li></ul><p><strong>吞吐量</strong></p><ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li>吞吐量为1-1&#x2F;(1+n)，其中-XX::GCTimeRatio&#x3D;n</li></ul><p><strong>并发数</strong></p><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul><p><strong>内存占用</strong></p><ul><li>Java堆区所占的内存大小</li></ul><h1 id="二、监控-命令行"><a href="#二、监控-命令行" class="headerlink" title="二、监控-命令行"></a>二、监控-命令行</h1><ul><li>jps：查看正在运行的Java进程</li><li>jstat：查看JVM统计信息<ul><li>跟随 -class查看类加载情况</li><li>跟随 -compiler查看编译情况</li><li>跟随 -gc查看垃圾回收情况</li></ul></li><li>jinfo：实时查看和修改JVM配置参数</li><li>jmap：导出内存映像文件&amp;内存使用情况（<strong>dump文件</strong>）</li><li>jhat：JDK自带堆分析工具（已经删除）</li><li>jstack：打印JVM中线程快照</li><li>jcmd：多功能命令行（执行上面的命令）</li><li>jstatd：远程主机信息收集</li></ul><h1 id="三、监控-GUI"><a href="#三、监控-GUI" class="headerlink" title="三、监控-GUI"></a>三、监控-GUI</h1><ul><li>JConsole，java自带</li><li>Visual VM，java自带</li><li>Eclipse MAT，堆分析器，分析dump文件</li><li>JProfiler，好用全面，但收费</li><li>Arthas，阿里开源，远程监控</li><li>Java Misssion Control，Oracle JDK中提供，官方出品，使用采样技术，开销很小<ul><li>Java Flight Record，JMC的组件</li></ul></li></ul><h1 id="四、JVM运行时参数"><a href="#四、JVM运行时参数" class="headerlink" title="四、JVM运行时参数"></a>四、JVM运行时参数</h1><h2 id="JVM参数选项"><a href="#JVM参数选项" class="headerlink" title="JVM参数选项"></a>JVM参数选项</h2><h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><p>java -help出的内容，一般为常规参数</p><h4 id="Server模式与Client模式"><a href="#Server模式与Client模式" class="headerlink" title="Server模式与Client模式"></a>Server模式与Client模式</h4><p>Hotspot JVM有两种模式，分别是server和client，分别通过-server和-client模式设置。</p><ul><li><strong>32位系统</strong>上，默认使用Client类型的JVM。要想使用Server模式，机器配置至少有2个以上的CPU和2G以上的物理内存。<strong>client模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</strong>。</li><li><strong>64位系统</strong>上，<strong>只支持server模式的JVM</strong>，适用于需要大内存的应用程序，<strong>默认使用并行垃圾收集器</strong>。</li></ul><h3 id="类型二：-X参数选项"><a href="#类型二：-X参数选项" class="headerlink" title="类型二：-X参数选项"></a>类型二：-X参数选项</h3><p>java -X 出的内容，相当于一些高级选项<br>熟悉的有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xms&lt;size&gt;        设置初始 Java 堆大小<br>-Xmx&lt;size&gt;        设置最大 Java 堆大小<br>-Xss&lt;size&gt;        设置 Java 线程堆栈大小<br></code></pre></td></tr></table></figure><h3 id="类型三：-XX参数选项"><a href="#类型三：-XX参数选项" class="headerlink" title="类型三：-XX参数选项"></a>类型三：-XX参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+&lt;option&gt;  启用option属性<br>-XX:-&lt;option&gt;  禁用option属性<br><br>-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G<br>-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值<br></code></pre></td></tr></table></figure><p>一些开关类，设置类</p><h2 id="常用的JVM选项"><a href="#常用的JVM选项" class="headerlink" title="常用的JVM选项"></a>常用的JVM选项</h2><h3 id="打印XX选项"><a href="#打印XX选项" class="headerlink" title="打印XX选项"></a>打印XX选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项<br>-XX:+PrintFlagsInitial 打印所有XX选项的默认值<br>-XX:+PrintFlagsFinal 打印所有XX选项的实际值<br>-XX:+PrintVMOptions 打印JVM的参数<br></code></pre></td></tr></table></figure><h3 id="内存大小设置"><a href="#内存大小设置" class="headerlink" title="内存大小设置"></a>内存大小设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">栈</span><br>-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">堆</span><br>-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M<br>-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M<br>-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8<br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br>-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启<br>-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效<br>-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15<br>-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法区</span><br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M<br>-XX:+UseCompressedOops 使用压缩对象<br>-XX:+UseCompressedClassPointers 使用压缩类指针<br>-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接内存</span><br>-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>可见对内存使用的配置基本都是使用<code>-XX：</code>形式，其中设置堆、栈大小给出了<code>-X</code>的形式。</p>          </div><h3 id="OutOfMemory相关的选项"><a href="#OutOfMemory相关的选项" class="headerlink" title="OutOfMemory相关的选项"></a>OutOfMemory相关的选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥<br>-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录<br>-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本<br></code></pre></td></tr></table></figure><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Serial回收器</span><br>-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ParNew回收器</span><br>-XX:+UseParNewGC  年轻代使用ParNew GC<br>-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Parallel回收器</span><br>-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活<br>-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活<br>-XX:ParallelGCThreads<br>-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。<br>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。<br>所以服务器端适合Parallel，进行控制。该参数使用需谨慎。<br>-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小<br>取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。<br>与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。<br>-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。<br>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CMS回收器</span><br>-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。<br>开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合<br>-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。<br>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。<br>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<br>因此通过该选项便可以有效降低Fu1l GC的执行次数。<br>-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动<br>-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理<br>以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。<br>-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。<br>-XX:ParallelCMSThreads  设置CMS的线程数量。<br>CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。<br>当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。<br>-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的<br>-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度<br>-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）<br>-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记<br>用于提高标记速度，在Java8开始已经默认开启<br>-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启<br>-XX:+ExplicitGCInvokesConcurrent<br>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses<br>这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期<br>-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">G1回收器</span><br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。<br>-XX:G1HeapRegionSize 设置每个Region的大小。<br>值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。<br>-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms<br>-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8<br>-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。<br>-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。<br>-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）<br>-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）<br>-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出<br></code></pre></td></tr></table></figure><h4 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h4><ul><li>优先让JVM自适应，调整堆的大小</li><li><strong>串行</strong>收集器：内存小于100M；<strong>单核、单机程序</strong>，并且没有停顿时间的要求</li><li><strong>并行</strong>收集器：<strong>多CPU、高吞吐量</strong>、允许停顿时间超过1秒</li><li><strong>并发</strong>收集器：多CPU、追求低停顿时间、<strong>快速响应</strong>（比如延迟不能超过1秒，如互联网应用）</li><li><strong>官方推荐G1</strong>，性能高。现在互联网的项目，基本都是使用G1。</li></ul><h1 id="五、GC相关日志"><a href="#五、GC相关日志" class="headerlink" title="五、GC相关日志"></a>五、GC相关日志</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息<br>-XX:+PrintGCDetails            打印详细日志信息<br>-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图<br>-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中<br><br>-XX:+TraceClassLoading  监控类的加载<br>-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间<br>-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间<br>-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用<br>-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布<br>-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储<br>-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目<br>-XX:GCLogFileSize=1M  设置GC日志文件的大小<br></code></pre></td></tr></table></figure><h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用<br>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小<br>-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况<br>-XX:+DoEscapeAnalysis  开启逃逸分析<br>-XX:+UseBiasedLocking  开启偏向锁<br>-XX:+UseLargePages  开启使用大页面<br>-XX:+PrintTLAB  打印TLAB的使用情况<br>-XX:TLABSize  设置TLAB大小<br></code></pre></td></tr></table></figure><h2 id="Java获取运行参数"><a href="#Java获取运行参数" class="headerlink" title="Java获取运行参数"></a>Java获取运行参数</h2><p>Java提供了<code>java.lang.management</code>包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地或远程监控和管理运行的Java虚拟机。<br>其中<strong>ManagementFactory</strong>类较为常用，另外<strong>Runtime</strong>类可获取内存、CPU核数等相关的数据。通过使用这些api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryMonitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MemoryMXBean</span> <span class="hljs-variable">memorymbean</span> <span class="hljs-operator">=</span> ManagementFactory.getMemoryMXBean();<br>        <span class="hljs-type">MemoryUsage</span> <span class="hljs-variable">usage</span> <span class="hljs-operator">=</span> memorymbean.getHeapMemoryUsage();<br>        System.out.println(<span class="hljs-string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;\nFull Information:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());<br>        System.out.println(<span class="hljs-string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());<br><br>        System.out.println(<span class="hljs-string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 当前堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 空闲堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 最大可用总堆内存大小</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden &#x2F; S0, S1）的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br></code></pre></td></tr></table></figure><p><strong>GC原因</strong></p><ul><li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace区不够用了</li><li>FErgonomics：JVM自适应调整导致的GC</li><li>System：调用了System.gc()方法</li></ul><p><strong>垃圾收集器</strong></p><ul><li>Serial收集器：新生代显示 <code>&quot;[DefNew&quot;</code>，即 Default New Generation</li><li>ParNew收集器：新生代显示 <code>&quot;[ParNew&quot;</code>，即 Parallel New Generation</li><li>Parallel Scavenge收集器：新生代显示<code>&quot;[PSYoungGen&quot;</code>，JDK1.7使用的即PSYoungGen</li><li>Parallel Old收集器：老年代显示<code>&quot;[ParoldGen&quot;</code></li><li>G1收集器：显示<code>&quot;garbage-first heap&quot;</code></li></ul><p><strong>GC前后</strong><br>形式：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p><ul><li>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul><p><strong>GC时间</strong></p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核，一般而言：real time &lt; sys time＋user time<br>如果real＞sys＋user的话，则可能存在下列问题：IO负载非常重或CPU不够用。</p><h1 id="六、浅堆深堆与内存泄漏"><a href="#六、浅堆深堆与内存泄漏" class="headerlink" title="六、浅堆深堆与内存泄漏"></a>六、浅堆深堆与内存泄漏</h1><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><h3 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h3><p><strong>浅堆是指一个对象所消耗的内存</strong>。<br>在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。</p><h3 id="保留集（Retained-Set）"><a href="#保留集（Retained-Set）" class="headerlink" title="保留集（Retained Set）"></a>保留集（Retained Set）</h3><p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。<br>通俗地说，就是指<strong>仅被对象A所持有的对象的集合，包括A自身</strong>。</p><h3 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h3><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p><p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p><h3 id="对象的实际大小"><a href="#对象的实际大小" class="headerlink" title="对象的实际大小"></a>对象的实际大小</h3><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，<strong>但实际上，这个概念和垃圾回收无关</strong>。</p><div class="note note-primary">            <p>浅堆：对象本身的大小<br>深堆：对象及其<strong>独有</strong>所有直接，间接引用的大小<br>对象大小：对象及其所有直接，间接引用的大小</p>          </div><h3 id="支配树（Dominator-Tree）"><a href="#支配树（Dominator-Tree）" class="headerlink" title="支配树（Dominator Tree）"></a>支配树（Dominator Tree）</h3><p>支配树的概念源自图论。体现对象实例之间的支配关系：</p><ul><li>如果指向B的所有路径都经过A，则认为A是B的<strong>支配者</strong>。</li><li>如果A是离B最近的支配者，则A是B的<strong>直接支配者</strong>。</li></ul><h3 id="内存泄漏（memory-leak）"><a href="#内存泄漏（memory-leak）" class="headerlink" title="内存泄漏（memory leak）"></a>内存泄漏（memory leak）</h3><p>严格上说：对象不会再被程序用到了，但是GC又不能回收他们的情况（永生），才叫内存泄漏。<br>宽泛的说：由于对象的生命周期过长（存活过久，如某对象不再使用，但其支配者仍需要存活一段时间的情况）。</p><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>内存泄漏的增多，最终会导致内存溢出。</p><h2 id="Java中内存泄漏的8种情况"><a href="#Java中内存泄漏的8种情况" class="headerlink" title="Java中内存泄漏的8种情况"></a>Java中内存泄漏的8种情况</h2><ul><li>静态集合类（方法区）</li><li>单例模式（方法区）</li><li>内部类持有外部类（一个内部类总是保存着外部类的引用）</li><li>数据库，IO连接等（没有关闭连接，无法回收）</li><li>不合理的作用域（变量作用范围大于其使用范围）</li><li>改变哈希值<ul><li>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则再也无法检索到该对象</li></ul></li><li>缓存泄漏（可以使用WeakHashMap）</li><li>监听器和其他回调<ul><li>回调函数：一个通过<strong>函数指针</strong>调用的函数。如果你把函数的<strong>指针地址</strong>作为<strong>参数传递</strong>给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</li><li>如果客户端向应用注册了一个回调函数，使用后没有取消，则会造成内存泄漏，解决办法是使用WeakHashMap。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM中篇:字节码与类加载</title>
    <link href="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Class文件结构"><a href="#一、Class文件结构" class="headerlink" title="一、Class文件结构"></a>一、Class文件结构</h1><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td></tr></tbody></table><blockquote><p>其中un表示有n个字节。</p></blockquote><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>u4<br><code>0xCAFEBABE</code></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>u2+u2<br>主版本号和副版本号一起构成版本号：M.m<br>不同编译器的class文件不同，目前JVM可以向下兼容。</p><h2 id="常量池集合"><a href="#常量池集合" class="headerlink" title="常量池集合"></a>常量池集合</h2><p>u2(常量数量)+ cp_info（常量表大小）</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>u2，从1开始计数，所以constant_pool_count&#x3D;1时说明有0个常量。</p><div class="note note-primary">            <p>因为0索引被空出来作为“空常量”</p>          </div><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool"></a>constant_pool</h3><p>1 ~ constant_pool_count - 1为索引<br>主要存放<strong>字面量Literal</strong>和<strong>符号引用Symbolic References</strong>，其包含该class文件中如下内容：</p><ul><li>字面量<ul><li>字符串</li><li>final常量</li></ul></li><li>符号引用<ul><li>类，接口名</li><li>方法名</li><li>字段名</li></ul></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>使用1byte表示该常量的类型：如字符串、符号引用等，即下表中的tag，剩余的部分根据类型不同而不同。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201163645.png"><br>其中：只有CONSTANT_utf8_info的长度是不固定的，其本身也代表字符串，其他常量项的属性可以指向CONSTANT_utf8_info。</p><h2 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的，即bitmap，这样只使用<strong>2byte</strong>即可表达所有访问标志。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。</li><li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。JDK8后，默认每个class文件都设置了ACC_SUPER标志，目的是向后兼容。</li></ul><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><h3 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h3><p>2byte，指向常量池</p><h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>2byte，指向常量池</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>指向常量池索引集合。</p><h4 id="interfaces-count（接口计数器）"><a href="#interfaces-count（接口计数器）" class="headerlink" title="interfaces_count（接口计数器）"></a>interfaces_count（接口计数器）</h4><p>2byte，interfaces_count项的值表示当前类或接口的直接超接口数量。</p><h4 id="interfaces（接口索引集合）"><a href="#interfaces（接口索引集合）" class="headerlink" title="interfaces（接口索引集合）"></a>interfaces（接口索引集合）</h4><p><code>interfaces_count*2byte</code><br>每个成员的值必须是对常量池表中某项的有效索引值，长度为interfaces_count</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><h3 id="fields-table"><a href="#fields-table" class="headerlink" title="fields_table"></a>fields_table</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识符"><a href="#访问标识符" class="headerlink" title="访问标识符"></a>访问标识符</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h4 id="描述符索引"><a href="#描述符索引" class="headerlink" title="描述符索引"></a>描述符索引</h4><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object</code>;</td></tr><tr><td><code>[</code></td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D </code></td></tr></tbody></table><h4 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h4><p>每个字段还可以拥有不同的属性，如初始值，注释信息。这些属性的数量放在属性计数器attribute_count中，内容放在属性集合attributes中。</p><p>比如某常量字段拥有下面三个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>methods表中的每个成员都必须是一个method_info结构：</p><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识-1"><a href="#访问标识-1" class="headerlink" title="访问标识"></a>访问标识</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>这里与字段&#x2F;方法表中的属性集合要分开，字段&#x2F;方法中属性集合是描述字段&#x2F;方法属性的，本处的属性表集合用来描述class文件的附加信息。</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>attributes_count的值表示当前class文件属性表的成员个数。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>属性表中每一项都是一个attribute_info结构。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><p>各种属性的含义见官网，具体问题具体分析。</p><h1 id="二、字节码指令集"><a href="#二、字节码指令集" class="headerlink" title="二、字节码指令集"></a>二、字节码指令集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p><ul><li>i代表对int类型的数据操作，</li><li>l代表long</li><li>s代表short</li><li>b代表byte</li><li>c代表char</li><li>f代表float</li><li>d代表double</li></ul><div class="note note-primary">            <p>注意，编译器会将boolean,byte,char,short作为int使用i开头的指令处理。</p>          </div><h2 id="加载与存储"><a href="#加载与存储" class="headerlink" title="加载与存储"></a>加载与存储</h2><ul><li>xload，将<strong>局部变量</strong>加载到操作数栈。</li><li>iconst、bipush等，<strong>常量入操作数栈</strong></li><li>xstore，<strong>出栈装入局部变量表</strong></li></ul><div class="note note-primary">            <ul><li>x为a表示对象操作，如aload，即加载一个对象到操作数栈。</li><li>在x后加a表示从数组中操作，如iaload，即从<code>int[]</code>数组中取数。</li></ul>          </div><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><h3 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201172429.png"></p><h3 id="运算模式"><a href="#运算模式" class="headerlink" title="运算模式"></a>运算模式</h3><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；<br><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p><h3 id="NaN值使用"><a href="#NaN值使用" class="headerlink" title="NaN值使用"></a>NaN值使用</h3><p>对于浮点数，有特殊的表达式：<br>1&#x2F;0.0 &#x3D; Infinity<br>0.0&#x2F;0.0 &#x3D; NaN</p><h3 id="算数指令-1"><a href="#算数指令-1" class="headerlink" title="算数指令"></a>算数指令</h3><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位与指令</td><td>iand</td><td>land</td><td></td></tr><tr><td></td><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td></tr><tr><td>比较指令</td><td></td><td>lcmp</td><td>fcmpg &#x2F; fcmpl</td><td>dcmpg &#x2F; dcmpl</td></tr></tbody></table><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table><thead><tr><th>转化</th><th>byte</th><th>char</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>int</td><td>i2b</td><td>i2c</td><td>i2s</td><td>○</td><td>i2l</td><td>i2f</td><td>i2d</td></tr><tr><td>long</td><td>l2i i2b</td><td>l2i i2c</td><td>l2i i2s</td><td>l2i</td><td>○</td><td>l2f</td><td>l2d</td></tr><tr><td>float</td><td>f2i i2b</td><td>f2i i2c</td><td>f2i i2s</td><td>f2i</td><td>f2l</td><td>○</td><td>f2d</td></tr><tr><td>double</td><td>d2i i2b</td><td>d2i i2c</td><td>d2i i2s</td><td>d2i</td><td>d2l</td><td>d2f</td><td>○</td></tr></tbody></table><p><strong>宽化类型转换</strong>，可能有精度损失，如long-&gt;double，但结果不会偏离太远。<br><strong>窄化类型转换</strong>，可能造成数据溢出导致结果不正确，并有下面的规律：</p><ul><li>浮点-&gt;整数<ul><li>NaN -&gt; 0</li><li>其他 -&gt; 向0取整 或 转换为整数能表示的最大值</li></ul></li><li>浮点-&gt;浮点(d2f)<ul><li>过小 -&gt; 0</li><li>过大 -&gt; 正负无穷大</li><li>NaN -&gt; NaN</li></ul></li></ul><h2 id="对象创建与访问"><a href="#对象创建与访问" class="headerlink" title="对象创建与访问"></a>对象创建与访问</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><table><thead><tr><th>创建指令</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>创建类实例</td></tr><tr><td>newarray</td><td>创建基本类型数组</td></tr><tr><td>anewarray</td><td>创建引用类型数组</td></tr><tr><td>multilanewarra</td><td>创建多维数组</td></tr></tbody></table><h3 id="字段访问"><a href="#字段访问" class="headerlink" title="字段访问"></a>字段访问</h3><table><thead><tr><th>字段访问指令</th><th>含义</th></tr></thead><tbody><tr><td>getstatic、putstatic</td><td>访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td>getfield、 putfield</td><td>访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th></tr></thead><tbody><tr><td>xaload</td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td></tr><tr><td>xastore</td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td></tr></tbody></table><h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>判断给定对象是否是某一个类的实例</td></tr><tr><td>checkcast</td><td>检查类型强制转换是否可以进行</td></tr></tbody></table><ul><li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li><li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li></ul><h2 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h2><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><ul><li>invokevirtual，调用对象的实例方法，<strong>支持多态</strong>。</li><li>invokespecial，调用特殊方法，静态绑定。</li><li>invokestatic，静态绑定。</li><li>invokedynamic，动态解析方法，并执行。该指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。</li></ul><div class="note note-primary">            <p>invokedynamic是lambda表达式的具体底层实现，使用较少，类似于通过方法句柄调用方法，与反射不同，有点难理解，不要过度关注。</p>          </div><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td>xreturn</td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p><h3 id="操作数栈管理"><a href="#操作数栈管理" class="headerlink" title="操作数栈管理"></a>操作数栈管理</h3><ul><li>pop，出栈</li><li>dup，复制栈顶<ul><li>dupm表示复制m个slot并压入栈顶</li><li>dupm_xn表示复制m个slot，并插入到栈顶下的（m+n）slot的位置。</li></ul></li><li>swap，交换栈顶两个slot数值，long,double不可用（占用两个slot）</li><li>nop，占位</li></ul><h2 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h2><ol><li>比较指令</li><li>条件跳转指令</li><li>比较条件跳转指令</li><li>多条件分支跳转指令。</li><li>无条件跳转指令等。</li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>athrow 抛出异常或错误。将栈顶异常抛出<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>ret 从子例程返回</p><h3 id="athrow"><a href="#athrow" class="headerlink" title="athrow"></a>athrow</h3><p>即throw语句<br>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>异常表保存了每个异常处理信息。比如：</p><ul><li>起始位置</li><li>结束位置</li><li>程序计数器记录的代码处理的偏移地址</li><li>被捕获的异常类在常量池中的索引</li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。<br>如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p><p>如果有finally块，则finally块必然执行，finally块在return前执行，但不影响return的结果，因此最好不要在非finally块中使用return。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；不需要显式的用字节码表示。</p><h4 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h4><ul><li>如果设置了同步，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li><li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li><li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个<strong>同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</strong></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>jvm的指令集有monitorenter和monitorexit 两条指令来支持synchronized关键字的语义。</p><h4 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h4><p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><h1 id="三、类的加载过程"><a href="#三、类的加载过程" class="headerlink" title="三、类的加载过程"></a>三、类的加载过程</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201180946.png"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182105.png"></p><ol><li>通过类的全名，获取类的二进制数据流，来源有：<ul><li>本地文件</li><li>压缩包</li><li>网络</li><li>数据库</li><li>实时生成</li></ul></li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型）：<ul><li>JDK8前：永久代</li><li>JDK8后：元空间</li></ul></li><li>创建java.lang.Class类的实例（堆中），表示该类型。作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>此时Class类中的成员还没有初始化。</p>          </div><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p><strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的。</p><ul><li>因此，若数组元素是引用类型，则先加载引用类型，然后JVM自动创建其数组类型。</li><li>数组的访问权限由其元素类型的访问权限决定。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182705.png"></p><h4 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h4><ul><li><strong>加载过程中，只进行格式检查</strong></li><li>把class文件加载到方法区后，再进行后续的检查</li></ul><h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><ol><li>格式验证：是否以魔数0XCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li><li>语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的。如父类不存在，接口未实现等。</li><li>字节码验证：主要检查是否有不合理的跳转，赋值，调用。（检查手段是有限的，即使通过了这阶段检查也不代表没问题。）</li><li>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的，并有访问权限</strong>。</li></ol><div class="note note-primary">            <p>验证行为贯穿整个类的加载过程</p><ul><li>在加载阶段进行格式检查。</li><li>在链接阶段的验证环节进行语义和字节码验证。</li><li>在链接阶段的解析环节继续拿符号引用验证。</li></ul>          </div><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类分配内存空间，并设置初始值0值。</p><div class="note note-primary">            <p>不包含<strong>基本数据类型的字段</strong>用<strong>static final</strong>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。<br>此外，类变量(static)存放在<strong>堆</strong>中class对象中。</p>          </div><div class="note note-success">            <p><strong>static与static final</strong><br>根据虚拟机规范定义，类变量（static）应该被放入方法区，而java中方法区的具体实践是：</p><ul><li>类元信息放入元空间</li><li>字符串常量池和静态变量放入堆中，其中静态变量是伴随着Class对象分配空间的。<ul><li>如果静态变量是final且是基本数据类型（包括字符串），那么其值会在类加载过程中的<strong>链接环节的准备过程</strong>中初始化赋值，否则在这里赋0值。</li><li>如果静态变量不是final且是基本数据类型（包括字符串），那么其在类加载过程中的<strong>初始化环节</strong>中会初始化赋值。</li><li>所以，无论是否final，基本类型的static成员变量都在堆中（伴随Class对象）</li></ul></li></ul>          </div><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。<br>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h3><ul><li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值</li><li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行，即<code>String a = &quot;12&quot;</code>形式。</li><li>在初始化阶段<code>&lt;clinit&gt;()</code>中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</li></ul><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h3><p>该方法是带锁，线程安全的。只会被执行一次。</p><h3 id="类的初始化情况"><a href="#类的初始化情况" class="headerlink" title="类的初始化情况"></a>类的初始化情况</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p>总之是需要使用到类的字段或方法的情况。</p><ul><li>实例化</li><li>调用静态方法</li><li>获取静态字段</li><li>使用反射（包括<strong>forName</strong>）</li><li>继承该类</li><li>default方法</li><li>包含main方法</li><li>被指定调用MethodHandler</li></ul><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了以上情况都是被动使用，比如：</p><ul><li>通过子类引用父类的静态变量，子类不会初始化。</li><li>数组定义，定义某种类型的数组</li><li>引用某个的常量static final（常量在链接的准备阶段就已经完成赋值）</li><li><code>loadClass()</code>也不会主动初始化。</li></ul><blockquote><p><a href="https://www.jianshu.com/p/d432a94be182">JVM：类加载的五个过程：加载、验证、准备、解析、初始化</a></p></blockquote><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>类加载器</strong>与<strong>被该加载器加载的类</strong>的内部实现中，存在着双向引用。因此根据GC的原理，当某一个类的Class对象不再被引用时，即可回收，因此回收类的前提是回收其加载器。</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li><strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载的。</strong></li><li><strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>。</li><li>被开发者<strong>自定义的类加载器</strong>实例加载的类型<strong>只有在很简单的上下文环境中才能被卸载</strong>，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。</li></ul><h3 id="卸载前提"><a href="#卸载前提" class="headerlink" title="卸载前提"></a>卸载前提</h3><ul><li>所有类实例被回收</li><li>所有对该类的引用被回收</li><li>该类的加载器被回收</li></ul><h1 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。</p><p>ClassLoader在整个装载阶段，<strong>只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为</strong>。至于它是否可以运行，则由Execution Engine决定。</p><div class="note note-primary">            <p>ClassLoader只定义类加载中的<strong>加载环节的细节</strong>。</p>          </div><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="加载方式分类"><a href="#加载方式分类" class="headerlink" title="加载方式分类"></a>加载方式分类</h3><ul><li>显式加载：反射</li><li>隐式加载：JVM加载</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p><strong>类的唯一性：由加载器和该类共同决定其唯一性。</strong></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>可见性，子加载器可以看见父加载器加载的类型，反之则不行。</li><li>单一性，由于可见性，父加载器加载的类不会被子加载器重复加载。</li></ul><h2 id="加载器分类"><a href="#加载器分类" class="headerlink" title="加载器分类"></a>加载器分类</h2><ul><li>引导类加载器（Bootstrap ClassLoader）</li><li>自定义类加载器（User-Defined ClassLoader）</li></ul><p>加载器之间不是继承关系，而是<strong>包含关系</strong>，子加载器包含父加载器的引用，因此其可以看见父加载器加载的内容（可见性），以及调用父加载器（实现双亲委派机制）。</p><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><h4 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h4><ul><li>C&#x2F;C++实现，在JVM内部实现</li><li>加载核心库</li><li>没有父加载器</li></ul><h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>加载ext.dirs目录下的类库</li><li>父类加载器为启动类加载器</li><li>直接继承于URLClassLoader，其继承于ClassLoader类（一个抽象类）</li></ul><h4 id="系统类加载器（AppClassLoader）"><a href="#系统类加载器（AppClassLoader）" class="headerlink" title="系统类加载器（AppClassLoader）"></a>系统类加载器（AppClassLoader）</h4><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li>父类加载器为扩展类加载器</li><li>直接继承于URLClassLoader，其继承于ClassLoader类（一个抽象类）</li></ul><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><p>可以通过自定义实现插件机制，此外加载器可以实现应用隔离。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="ClassLoader主要方法"><a href="#ClassLoader主要方法" class="headerlink" title="ClassLoader主要方法"></a>ClassLoader主要方法</h3><p>ClassLoader是一个抽象类，基本java实现的加载器都继承自它。<br>其有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span><br><span class="hljs-comment">//加载</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-comment">//链接</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span><br></code></pre></td></tr></table></figure><ul><li>其中，<code>loadClass()</code>会调用<code>findClass()</code>，而loadClass中实现了双亲委派机制，因此自定义加载器时，尽量只重写findClass()及其调用的方法。</li><li><code>findClass()</code>会调用<code>defineClass()</code>，其指明如何将byte流解析成Class对象。</li></ul><h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><ul><li>SecureClassLoader继承并扩展了ClassLoader功能，添加了权限认证。</li><li>URLClassLoader继承并扩展了SecureClassLoader，其对ClassLoader中的许多抽象方法做了具体的实现。</li><li>一般自定义加载类直接继承URLClassLoader非常方便。</li></ul><h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><ul><li>JDK8中，这两个类都继承自URLClassLoader</li><li>JDK9中，这两个类都继承自BuiltinClassLoader</li></ul><h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><ul><li>前者会初始化，后者不会。</li><li>后者需要指定一个具体的加载器加载。</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先交给父类加载器加载，加载失败再由子类加载。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202001557.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>搜索类，有则返回</li><li>有父类则委托加载</li><li>无父类则使用引导类加载器加载（必须委托一次引导类，实现保护的核心API的功能）</li><li>都失败则主动加载</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>避免重复加载</li><li>保护核心类库</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>顶层无法访问底层加载器，系统类无法访问应用类，无法在系统类的方法中调用应用类。</li></ul><div class="note note-primary">            <p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</p>          </div><h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><h4 id="第一次：覆盖loadClass"><a href="#第一次：覆盖loadClass" class="headerlink" title="第一次：覆盖loadClass"></a>第一次：覆盖loadClass</h4><p>双亲委派机制推出前就有ClassLoader存在，loadClass方法已经被用户使用自定义加载器覆盖（没有双亲委派），后来才推荐用户改写findClass。</p><h4 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h4><p>解决系统类无法调用用户类的缺点，如JNDI服务就需要调用，管理用户类。</p><h5 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h5><p>JNDI是 Java 命名与目录接口（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一。</p><ul><li>JDBC：JDBC模式下，连接数据库需要对JDBC相关Driver进行编码，获取数据库连接，其存在以下问题：<ul><li>数据库服务器名称MyDBServer 、用户名和口令都可能需要改变，由此引发JDBC URL需要修改；</li><li>数据库可能改用别的产品，如改用DB2或者Oracle，引发JDBC驱动程序包和类名需要修改；</li></ul></li><li>解决思路：不应该关心具体的数据库后台，驱动程序，URL格式等问题，而是将这些交给J2EE容器来配置和管理</li><li>JNDI：JNDI模式下，在J2EE容器中配置JNDI参数，定义一个数据源，也就是JDBC引用参数，给这个数据源设置一个名称；然后，在程序中，通过数据源名称引用数据源从而访问后台数据库。（本质上就是由J2EE容器实现服务发现，用户程序直接获取服务即可）</li></ul><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202002835.png"><br>父类加载器可以通过线程上下文类加载器委托给子类加载器完成类的加载。这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h4 id="第三次：用户的要求"><a href="#第三次：用户的要求" class="headerlink" title="第三次：用户的要求"></a>第三次：用户的要求</h4><p>第三次破坏源于用户需求：代码热替换(Hot Swap)、模块热部署(Hot Deployment)等。</p><ul><li>**热部署(Hot Deploy)**：热部署针对的是容器或者是整个应用，包括运行需要使用到的各种文件（jar包、JS、CSS、html、配置文件），新的资源或者修改了一些代码，需要在不停机的情况下的重新加载整个应用；</li><li>**热加载(Hot Swap)**：热加载针对的是单个字节码文件，指的是重新编译后， 不需要停机 ，应用程序就可以加载使用新的class文件。</li></ul><p>背景：IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>搜索顺序：</p><ol><li>java.开头，委托父类（双亲）</li><li>若在委派列表名单中，委托父类（双亲）</li><li>在各种列表中寻找类加载器进行加载（平行）</li></ol><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003613.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱。即将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源（CPU、内存、文件系统、网络）访问。</p><h3 id="JDK1-0"><a href="#JDK1-0" class="headerlink" title="JDK1.0"></a>JDK1.0</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003843.png"></p><h3 id="JDK1-1"><a href="#JDK1-1" class="headerlink" title="JDK1.1"></a>JDK1.1</h3><p>增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003849.png"></p><h3 id="JDK1-2"><a href="#JDK1-2" class="headerlink" title="JDK1.2"></a>JDK1.2</h3><p>改进了安全机制，增加了<strong>代码签名</strong>。由<strong>类加载器</strong>加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003938.png"></p><h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><p>虚拟机会把所有代码加载到不同的系统域和应用域。</p><p>系统域专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。</p><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003950.png"></p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>隔离加载类（容器隔离）</li><li>修改类的加载方式（动态加载）</li><li>扩展加载源（数据库，网络）</li><li>防止源码泄漏（加密）</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>方式</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法，推荐<br>说明</li><li>其父类加载器是系统类加载器</li></ul><h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</li><li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/323cfcda53f98034ed15372c0ea43685.png"></p><ol start="3"><li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li><li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li><li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ol><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202004846.png"></p><div class="note note-primary">            <p>总结就是：</p><ol><li>ext改名plat</li><li>新增getName()方法</li><li>plat和app不再继承url，而是builtin</li><li>引导类由java实现</li><li>双亲委托前可直接判断所属系统并交付</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM上篇:内存与垃圾回收</title>
    <link href="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JVM与Java体系"><a href="#一、JVM与Java体系" class="headerlink" title="一、JVM与Java体系"></a>一、JVM与Java体系</h1><ul><li>JVM只关心字节码文件</li><li>虚拟机是对物理计算机的模仿</li><li>JVM是运行在操作系统之上的，不直接与硬件交互<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140012.png"></li></ul><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140104.png"></p><h2 id="Java代码执行顺序"><a href="#Java代码执行顺序" class="headerlink" title="Java代码执行顺序"></a>Java代码执行顺序</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140118.png"></p><h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><ul><li>栈式架构<br>实现更简单，不需要硬件支持，指令集更小，跨平台</li><li>寄存器架构<br>指令集架构则完全依赖硬件，可移植性差</li></ul><h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></p><h3 id="虚拟机退出的情况"><a href="#虚拟机退出的情况" class="headerlink" title="虚拟机退出的情况"></a>虚拟机退出的情况</h3><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。<br>总结：一个正常执行完毕，两个错误终止，两个手动终止。</li></ul><h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="类加载器与类加载过程"><a href="#类加载器与类加载过程" class="headerlink" title="类加载器与类加载过程"></a>类加载器与类加载过程</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140856.png"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li><strong>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</strong></li><li>加载的类信息存放于一块称为<strong>方法区</strong>的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ol><li>通过类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>这里注意，加载阶段就完成了方法区数据结构的装载和Class对象的生成，但此时还没有进行类初始化，即此时类中的字段还没有初始化。</p>          </div><h4 id="补充：class文件来源"><a href="#补充：class文件来源" class="headerlink" title="补充：class文件来源"></a>补充：class文件来源</h4><ul><li>本地</li><li>网络</li><li>动态代理，动态生成</li><li>压缩包</li><li>JSP</li><li>数据库</li><li>加密文件</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<strong>文件格式验证(文件格式、魔数、长度等)，元数据验证（继承关系是否合法等），字节码验证（方法体是否合法等），符号引用验证（引用类型是否存在等）</strong>。</li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li><strong>这里不包含用final修饰的static，因为final static在编译的时候就会分配了，准备阶段会显式初始化；</strong></li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<strong>符号引用转换为直接引用</strong>的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。符号引用就是一组符号来描述所引用的目标。</li><li>符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><strong>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。</strong></li><li>该阶段是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和<strong>静态代码</strong>块中的语句合并而来。</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</li></ul><div class="note note-primary">            <ul><li>加载阶段负责把字节码的二进制文件加载到方法区，并根据字节码在堆中生成class对象</li><li>链接阶段负责检验class文件的正确性、为类的变量分配内存并设置默认值（0值）、解析时将符号应用转换为直接引用。</li><li>初始化负责对类变量、static块执行赋值。</li></ul>          </div><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul><li>分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li><li>Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144137.png"></li></ul><h3 id="自带的加载器"><a href="#自带的加载器" class="headerlink" title="自带的加载器"></a>自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li><strong>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</strong></li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li><strong>并不继承自ava.lang.ClassLoader，没有父加载器。</strong></li><li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</strong></li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><div class="note note-primary">            <ul><li>引导类加载器不继承ClassLoader；其他类都继承该抽象类，被称为自定义类加载器。</li></ul>          </div><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>启动类加载器</strong></li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>扩展类加载器</strong></li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><div class="note note-primary">            <p>具体到类加载过程中的步骤，其可以加密（防止源码泄漏），可以扩展加载的源（如网络），可以修改类的加载方式并隔离加载类（热部署）。</p>          </div><p>实现步骤：</p><ul><li>JDK1.2之前，继承ClassLoader，覆盖loadClass方法。</li><li>JDK1.2之后，继承ClassLoader，覆盖findClass方法（其被loadClass方法调用）。</li><li>没有复杂需求时，直接继承URLClassLoader，避免自己编写findClass。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144950.png"></li></ul><h3 id="获取ClassLoader方法"><a href="#获取ClassLoader方法" class="headerlink" title="获取ClassLoader方法"></a>获取ClassLoader方法</h3><ul><li>clazz.getClassLoader()</li><li>Thread.currentThread().getContextClassLoader() &#x2F;&#x2F;上下文线程的加载器</li><li>ClassLoader.getSystemClassLoader() &#x2F;&#x2F;系统类加载器</li><li>DriverManager.getCallerClassLoader() &#x2F;&#x2F;调用者的加载器</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul><li>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式</li><li>加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</li></ul><p><strong>原理</strong><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145155.png"><br>具体实现在loadClass()方法中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>如何判断两个class对象是否相同</strong><br>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p><strong>对类加载器的引用</strong></p><ul><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</li><li>如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li></ul><div class="note note-primary">            <p>不同类加载器加载的对象解析需要其在同一个域。</p>          </div><p><strong>主动使用与被动使用</strong><br>对类的成员的调用：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>初始化一个类的子类</li></ul><p>规范：</p><ul><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>Java虚拟机启动时被标明为<strong>启动类</strong>的类</li><li>JDK 7 开始提供的动态语言支持：<br>  java.lang.invoke.MethodHandle实例的解析结果<br>  REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都不会导致<strong>类的初始化</strong>。</p><h1 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h1><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145718.png"></p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>PS：JVM允许一个应用有多个线程并行的执行。在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><h2 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h2><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><div class="note note-primary">            <p>可以理解为JVM后台运行的线程，其中虚拟机线程是管理其他线程的线程，其令JVM达到安全点才调用执行一些操作，如Stop-the-world，线程栈收集，线程挂起，偏向锁撤销。</p>          </div><h2 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h2><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123150208.png"><br>作用：<br>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li><li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</strong></li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；<strong>或者，如果是在执行native方法，则是未指定值（undefined）</strong>。</li></ul><div class="note note-primary">            <p>每个线程都拥有一个PC计数器，相互隔离（私有），标识当前线程的执行点，这样执行引擎就会执行该地址代码。</p>          </div><p><strong>为什么使用PC寄存器记录当前线程的执行地址呢？</strong><br>CPU可能会分片执行，切换线程后需要知道从哪里开始执行。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。</p><ul><li><strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。</li><li>生命周期和线程一致</li><li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li><li>JVM对栈的操作仅有，出栈，入栈。</li></ul><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><code>StackOverflowError</code>，超过设定的栈容量</li><li><code>OutOfMemoryError</code>，整体内存空间不足。</li></ul><p>**设置大小方法:</p><ul><li>**<code>-Xss</code></li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><ul><li>栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong>。</li><li>栈帧<strong>先进后出</strong>，一个线程只有一个活动栈帧，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</li></ul><p>Java方法有两种返回函数的方式：</p><ul><li>一种是正常的函数返回，使用return指令；</li><li>另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h3 id="栈帧中的内容"><a href="#栈帧中的内容" class="headerlink" title="栈帧中的内容"></a>栈帧中的内容</h3><ul><li><strong>局部变量表（Local Variables）</strong></li><li><strong>操作数栈（operand Stack）（或表达式栈）</strong></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul><li>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><h5 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h5><ul><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li><li><strong>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</strong></li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或doub1e类型变量）</li><li>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123151728.png"><br>另外，Slot空间可以被复用，如某些局部变量超出作用域后，新的局部变量可以复用该位置。</p><h5 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h5><p>Static：类变量表有两次初始化的机会：</p><ul><li>第一次是在“链接阶段中的准备阶段”，执行系统初始化，对类变量设置零值。</li><li>另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li></ul><p>局部变量表：不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</p><div class="note note-primary">            <p>虚拟机栈指的就是整个线程栈，线程栈分若干个栈帧，栈帧中又有操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p>          </div><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123152330.png"></p><p>PS：每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</p><h5 id="栈顶缓存-Top-Of-Stack-Caching-技术"><a href="#栈顶缓存-Top-Of-Stack-Caching-技术" class="headerlink" title="栈顶缓存(Top Of Stack Caching)技术"></a>栈顶缓存(Top Of Stack Caching)技术</h5><p>操作数是存储在内存中的，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接、方法返回地址、附加信息有时被一起称为帧数据区。</p><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。通过这个引用，可以实现动态链接。</p><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123154403.png"></p><div class="note note-primary">            <p>现有动态链接，再有栈帧！<br>比如，现在某对象A在方法A0中调用对象B的一个方法B0，字节码文件如下：<br>invokeVirtual B0</p><p>此时虚拟机会根据操作数栈顶的对象类型，根据<strong>字符串</strong>查找其方法中类元信息中的<strong>方法入口</strong>。<br>但是每次调用方法都扫描查找一次类信息是很繁琐的，在方法区的运行时常量池中，直接保存了字符串与方法入口地址的对应关系（直接引用），这个对应关系也叫类B的Vtable。</p>          </div><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，<strong>动态链接的作用就是为了将这些符号引用转换位调用方法的直接引用</strong>。</p><div class="note note-primary">            <p>个人理解：某个方法A可能会调用其他方法B，在执行引擎遇到调用其方法的语句如invokeVirtual时，需要找到方法B的入口。<br>而栈帧中保存了一个指针，指向了方法B符号在运行时常量池中的位置，再通过运行时常量池，实现将符号引用转化为直接引用。</p>          </div><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。</p><ul><li>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li><li>通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>目标方法在编译期可知，且运行期保持不变时。对应<strong>早期绑定</strong>，调用非虚方法。</p><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用。对应<strong>晚期绑定</strong>，调用虚方法。</p><h4 id="方法绑定"><a href="#方法绑定" class="headerlink" title="方法绑定"></a>方法绑定</h4><p>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><ul><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通方法调用</span><br>invokestatic：调用静态方法，解析阶段确定唯一方法版本<br>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本<br>invokevirtual：调用所有虚方法<br>invokeinterface：调用接口方法<br><br><span class="hljs-comment">//动态方法调用</span><br>invokedynamic：动态解析出需要调用的方法，然后执行<br></code></pre></td></tr></table></figure><p><strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><p><code>invokedynamic</code>在JAVA7中才出现，但没有直接生成该指令，在JAVA8中的Lambda表达式可以生成<code>invokedynamic</code></p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>也就是前面动态链接中提到的Vtable，每个类都有一个这样的虚方法表存在于方法区，便于查找方法的真实入口。</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>根据操作数栈顶元素的实际对象类型寻找方法</li><li>找到后使用权限校验，通过则调用，不通过则报异常</li><li>找不到则根据继承关系循环进行1，2步</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>方法中定义的局部变量是否线程安全？<br>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><h2 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>native修饰的方法<br>主要用于与外部环境、操作系统交互，调用C语言实现的方法等。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>实现本地方法的管理调用，也是每个线程持有一个。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129213758.png"></p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>这个图有点问题</p><ul><li>本地方法入栈后，执行引擎会调用本地方法库执行本地方法。</li><li><strong>本地方法接口</strong>则是<strong>本地方法访问虚拟机内部数据</strong>的接口。</li></ul><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。</p><p>并不是所有JVM都支持本地方法。<br><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆空间结构"><a href="#堆空间结构" class="headerlink" title="堆空间结构"></a>堆空间结构</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214614.png"><br>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214618.png"></p><p><strong>堆空间大小设置</strong></p><ul><li>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code><br>默认Xms:电脑内存&#x2F;64<br>默认Xmx:电脑内存&#x2F;4</li></ul><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129215125.png"></p><ul><li>可以设置新生代&#x2F;老年代占比：默认<code>-XX:NewRatio=2</code></li><li>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，可以使用<code>-XX:SurvivorRatio</code></li><li>可以使用<code>-Xmn</code>设置新生代最大内存大小。</li></ul><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p><img src="/Pasted%20image%2020230917225656.png"></p><h4 id="小对象分配原则"><a href="#小对象分配原则" class="headerlink" title="小对象分配原则"></a>小对象分配原则</h4><ul><li><code>Eden</code>出生，一次MinorGC后进入<code>Survivor</code></li><li>15次（使用-XX:MaxTenuringThreshold&#x3D;N调整）Survivor移动后进入<code>Old</code>。</li><li><code>Old</code>若被MajorGC可能会清理，若无法保存则报OOM。</li></ul><h4 id="其他分配原则"><a href="#其他分配原则" class="headerlink" title="其他分配原则"></a>其他分配原则</h4><ul><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>动态对象年龄判断：如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保（-XX:HandlerPromotionFailure），开启时：<ul><li>MinorGC前检查老年代是否有连续空间容纳新生代的对象空间。<ul><li>若有，则可以执行MinorGC</li><li>若无，检查是否开启空间分配担保<code>-XX:HandlePromotionFailure</code><ul><li>若开启，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。<ul><li>若大于，则进行一次MinorGC（有风险）</li><li>若小于，FullGC</li></ul></li><li>否则，FullGC</li></ul></li></ul></li></ul></li></ul><div class="note note-primary">            <p>为什么需要空间担保：<br>minorGC时可能直接将大量Survivor区对象直接放入Old区，此时需要Old区保证能接受这些对象，若老年代剩余空间&gt;新生代所有对象大小，则肯定可以接受。若空间&lt;对象大小，则可以根据之前的回收情况预估实际进入老年代的对象大小，判断是否需要据此进行冒险的MinorGC，以避免盲目的FullGC。<br><strong>JDK7及以后已经弃用。此后，默认会进行冒险行为，否则FullGC。</strong></p>          </div><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>Thread Local Allocation Buffer，堆是所有线程共享的，因此也是线程不安全的。TLAB表示JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。<br>可以通过<code>-XX:UseTLAB</code>决定是否开启TLAB，通过<code>-XX:TLABWasteTargetPercent</code>决定TLAB占用Eden空间的大小。</p><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><p>GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h4><p>Eden满，需要清理Eden，STW。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129220927.png"></p><h4 id="MajorGC-x2F-FullGC"><a href="#MajorGC-x2F-FullGC" class="headerlink" title="MajorGC&#x2F;FullGC"></a>MajorGC&#x2F;FullGC</h4><p>Old区不够用时发生，Major发生总是伴随着MinorGC，但不绝对，STW。</p><h4 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h4><ol><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li></ol><p>要尽量避免FullGC，其耗时太长。</p><h3 id="堆是分配对象的唯一选择吗？"><a href="#堆是分配对象的唯一选择吗？" class="headerlink" title="堆是分配对象的唯一选择吗？"></a>堆是分配对象的唯一选择吗？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。</p><p>JDK6u23后默认开启逃逸分析，此前需要：</p><ul><li>选项”<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li><li>通过选项”<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>栈上分配：对象不发生方法逃逸。</li><li>同步省略：对象不发生线程逃逸（其他线程不访问该对象），也叫<strong>锁消除</strong>。</li><li>标量替换：将对象结构体（聚合量）替换为一个个属性（标量，基本类型）。使用<code>-XX:EliminateAllocations</code>开启。</li></ul><p>逃逸分析不成熟，因为分析性能不一定优于优化性能。<br><strong>Hotspot中的所有对象都建立在堆上。</strong></p><div class="note note-primary">            <p>JDK7前，字符串常量池在永久代上，后来永久代被元空间取代，而字符串常量池迁移到堆中，符合了所有对象都建立在堆上的结论。</p>          </div><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>方法区是一个独立于java堆的内存空间。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131114507.png"><br>前面的概念中有提到，方法区只是一个逻辑上的概念。在JDK8之前，方法区由永久代实现，JDK8之后，方法区由元空间实现，其独立于java堆空间，直接使用本地内存（但是也可能报OOM，本地内存的大小也是有限的）。</p><h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3><h4 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h4><ul><li>初始：<code>-XX:Permsize</code></li><li>最大：<code>-XX:MaxPermsize</code></li></ul><h4 id="jdk8之后"><a href="#jdk8之后" class="headerlink" title="jdk8之后"></a>jdk8之后</h4><ul><li>初始：<code>-XX:MetaspaceSize</code></li><li>最大：<code>-XX:MaxMetaspaceSize</code>(设置为-1则不受限制)</li></ul><h3 id="存储什么"><a href="#存储什么" class="headerlink" title="存储什么"></a>存储什么</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><ol><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型直接接口的一个有序列表</li></ol><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ol><li>域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li><li>域类型</li><li>域名称</li></ol><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ol><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的返回类型（或void）</li><li>方法名称</li><li>方法参数的数量和类型（按顺序）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><div class="note note-primary">            <p>简而言之，我们java文件中写的内容基本都会保存到方法区中。</p>          </div><h4 id="对于static-x2F-final"><a href="#对于static-x2F-final" class="headerlink" title="对于static&#x2F;final"></a>对于static&#x2F;final</h4><ul><li>若符号由static修饰，说明是类变量，在类的加载过程中生成。</li><li>若符号由static final修饰，说明是常量，在编译时即完成分配。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131120156.png"></p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池也称静态常量池，每个类的字节码文件（.class）中都具有一个常量池表，其描述了各种<strong>字面量</strong>与<strong>类、域、方法</strong>的<strong>符号引用</strong>。<br>而常量池中一般存储有：</p><ul><li>字段复用<ul><li>数量值</li><li>字符串值</li></ul></li><li>类及成员<ul><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li></ul><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用。<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>，<strong>一个类加载到 JVM 中后对应一个运行时常量池</strong>。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</li></ul><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池是全局</strong>的，里面存储的是字符串对象，而不是字面量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li>常量池存在于Class文件中，表现为 序号（”#1”） 到 字面量（”java&#x2F;lang&#x2F;Object”）的映射</li><li>运行时常量池存在于方法区，表现为 序号（”#1”）到 字面量（基本类型） 或 真实地址的映射。</li><li>常量池在类的加载过程的<strong>链接阶段</strong>的<strong>解析阶段</strong>，会将常量池中的字面量解析为真实地址。</li></ul>          </div><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><table><thead><tr><th>JDK1.6及之前</th><th>有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><div class="note note-primary">            <ul><li>方法区是一个逻辑概念，其定义了该区域应该存储的内容，而方法区的实现则由永久代&#x2F;元空间+部分堆空间实现。</li><li>字符串常量池移动到了堆中，但运行时常量池依然在元空间。</li><li>元空间中可能持有字符串的引用。</li></ul>          </div><h4 id="为什么要使用元空间"><a href="#为什么要使用元空间" class="headerlink" title="为什么要使用元空间"></a>为什么要使用元空间</h4><ul><li>永久代大小不应限制，使用元空间使用本地内存</li><li>永久代很难调优，GC起来很困难，类的卸载条件很苛刻。</li></ul><h4 id="StringTable为何换位置"><a href="#StringTable为何换位置" class="headerlink" title="StringTable为何换位置"></a>StringTable为何换位置</h4><p>字符串的创建和回收是很频繁的，放在永久代不宜回收（只有FullGC），而放在堆中可以及时回收。</p><h4 id="静态变量存放在哪"><a href="#静态变量存放在哪" class="headerlink" title="静态变量存放在哪"></a>静态变量存放在哪</h4><p>虚拟机规范要求将class相关信息放置于方法区中，但没有限制方法区的实现，所以HotSpot选择将静态变量随着class对象一起放在堆中。</p><h4 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h4><p>方法区主要回收常量池中废弃的常量和不再使用的类型。</p><ul><li>常量：不再被使用即可回收。</li><li>类型：<ul><li>所有对象已经回收</li><li>所有对该类的引用已经被回收</li><li>对于的类加载器已经被回收</li></ul></li></ul><p>满足类型的回收条件也只是允许回收，并不是必然的。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>元空间使用直接内存，NIO（Native IO）时也可以使用直接内存</p><h4 id="非直接内存"><a href="#非直接内存" class="headerlink" title="非直接内存"></a>非直接内存</h4><p>使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><h4 id="直接内存-1"><a href="#直接内存-1" class="headerlink" title="直接内存"></a>直接内存</h4><p>使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。<br>直接内存可以通过<code>MaxDirectMemorySize</code>设置，不指定时与-Xmx参数一致。</p><h1 id="四、对象的实例化过程"><a href="#四、对象的实例化过程" class="headerlink" title="四、对象的实例化过程"></a>四、对象的实例化过程</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ul><li>new：最常见的方式、Xxx的静态方法，XxxBuilder&#x2F;XxxFactory的静态方法</li><li>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis</li></ul><div class="note note-primary">            <ul><li>new，类，构造器的构造方法是一般的生成新对象方法。</li><li>clone和序列化是复制对象的方法。</li><li>第三方库</li></ul>          </div><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol><li>判断对象对应的类是否加载、链接、初始化<ul><li>元空间查找</li><li>失败，双亲委派加载（classloader+包名+类名）</li><li>失败，抛出异常</li></ul></li><li>为对象分配内存（具体如何分配取决于java堆的GC功能）<ul><li>有规整的内存（使用指针碰撞法时）</li><li>内存不规整（需要维护一个空闲列表）</li></ul></li><li>处理并发问题：保证更新的原子性</li><li>初始化分配到的内存（所有对象赋默认值，0值）</li><li>设置对象的对象头</li><li>init方法初始化（显示、代码块，构造器）</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130349.png"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度。</p><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><p>详情见JUC</p><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>有以下两种模式</p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130511.png"><br>优点在于，若对象被移动只需要修改句柄池</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130542.png"><br>HotSpot采用这种方式，访问快速。</p><h1 id="五、执行引擎"><a href="#五、执行引擎" class="headerlink" title="五、执行引擎"></a>五、执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎属于JVM的下层，里面包括<strong>解释器、及时编译器、垃圾回收器</strong><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130915.png"><br>执行引擎的任务就是将字节码指令解释&#x2F;编译成本地平台上的本地机器指令。</p><p>工作流程：执行引擎执行PC寄存器指向的指令，PC寄存器指向下一条指令。</p><h2 id="编译与执行过程"><a href="#编译与执行过程" class="headerlink" title="编译与执行过程"></a>编译与执行过程</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131115.png"></p><ol><li>Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131132.png"></li><li>Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131139.png"></li></ol><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器：对字节码逐行解释成机器码并执行。<br>编译器：</p><ul><li>前端编译器：将java代码编译成class字节码文件</li><li>后端编译器（JIT编译器）：将源代码直接编译成机器语言。</li></ul><p>java是一门半解释半编译的语言。</p><h2 id="指令基本概念"><a href="#指令基本概念" class="headerlink" title="指令基本概念"></a>指令基本概念</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>二进制指令，与CPU相关</p><h3 id="指令与指令集"><a href="#指令与指令集" class="headerlink" title="指令与指令集"></a>指令与指令集</h3><p>将二进制指令使用mov,inc等人类可读的方式表示。不同机器上指令对应的机器码可能不同。每个平台所支持的所有指令，称之为对应平台的指令集。即指令的集合。如-86，ARM</p><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>用助记符代替机器指令的操作码，使用汇编语言编写的程序需要翻译成机器指令码才能被识别、执行。</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍然<strong>需要把程序解释和编译成机器的指令码</strong>。<br>一般都是高级指令翻译成汇编语言，然后翻译成机器指令才能被执行。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>为了实现跨平台，没有采用静态编译生成机器指令，而是生成class文件，由解释器实现跨平台。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><ol><li>字节码解释器：纯软件代码模拟字节码执行。</li><li>模板解释器：每一条字节码和一个模板函数相关联。</li></ol><p>HotSpotVM中，解释器由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能，将字节码翻译为机器码</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>基于解释器执行已经沦落为低效的代名词<br>为了解决该问题，JVM平台支持一种叫作即时编译的技术（JIT），将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>JIT编译器属于后端编译器，将字节码翻译为机器码，是一种即时编译器。<br>HopSpot VM使用了<strong>解释器和即时编译器并存的架构</strong>。</p><p>有了JIT，为什么还要解释器？</p><ul><li>快启动</li><li>编译器无法优化程序时，解释器是逃生门</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2。<br>开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li><li><code>-server</code>：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。</li><li><strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>Java7后，就算开启-server模式也会默认使用分层编译。</li></ul><h4 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h4><p>C1编译器上主要有方法内联、去虚拟化、冗余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2的优化主要是在全局层面，做逃逸分析</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h2 id="HopSpotJVM执行方式"><a href="#HopSpotJVM执行方式" class="headerlink" title="HopSpotJVM执行方式"></a>HopSpotJVM执行方式</h2><p>解释器先发生作用，即时编译器根据热点探测将有价值的字节码编译为本地机器指令。</p><ul><li>JIT编译器是<strong>后端运行时编译器</strong>（Just In Time Compiler）,将字节码编译成本地机器指令。</li><li>AOT编译器是<strong>静态提前编译器</strong>（Ahead Of Time），将java文件编译成本地机器指令。</li></ul><h3 id="热点代码及探测"><a href="#热点代码及探测" class="headerlink" title="热点代码及探测"></a>热点代码及探测</h3><h4 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h4><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”。因而可以通过JIT编译器编译为本地机器指令，这种方式叫做栈上替换，或称为OSR（On Stack Replacement）编译。</p><h4 id="热点探测功能"><a href="#热点探测功能" class="headerlink" title="热点探测功能"></a>热点探测功能</h4><p>HotSpot使用的热点探测方式是<strong>基于计数器</strong>的热点探测。</p><p>HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数。</li><li>回边计数器则用于统计方法内循环体执行的循环次数。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>Client模式下默认1500次，Server模式下默认10000次。<br>可以通过<code>-XX:CompileThreshold</code>来人为设定阈值。</p><p>如果发现<strong>方法调用计数器和回边计数器之和</strong>超过了阈值，则会提交JIT即时编译请求。</p><h4 id="热点衰退"><a href="#热点衰退" class="headerlink" title="热点衰退"></a>热点衰退</h4><p>方法调用计数器统计的并<strong>不是方法被调用的绝对次数</strong>，而是一个相对的执行频率，即一段时间之内方法被调用的次数。<br>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减（Counter Decay）</strong>，而这段时间就称为此方法统计的<strong>半衰周期（Counter Half Life Time）</strong><br>热点衰退在GC时顺便进行，可以使用<code>-XX:-UseCounterDecay</code>设置关闭热点衰减，使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li><code>-Xint</code>：完全采用解释器模式执行程序；</li><li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h1 id="六、StringTable"><a href="#六、StringTable" class="headerlink" title="六、StringTable"></a>六、StringTable</h1><h2 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h2><ul><li>字符串</li><li>final，不可继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。</li><li>String实现了Comparable接口：表示string可以比较大小</li><li>String在jdk8及以前内部定义了<code>final char[] value</code>用于存储字符串数据。JDK9时改为<code>byte[]</code>。</li></ul><h2 id="为什么修改String底层"><a href="#为什么修改String底层" class="headerlink" title="为什么修改String底层"></a>为什么修改String底层</h2><p>原因：<code>char[]</code>数组中大多数char属于Latin-1字符，使用1byte即可表示，但char需要2byte，空间浪费。</p><p>改进：为String提供两种字符集使用（Latin-1或UTF-16）。</p><h2 id="StringPool"><a href="#StringPool" class="headerlink" title="StringPool"></a>StringPool</h2><p>String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</p><p>使用<code>-XX:StringTablesize</code>可设置StringTable的长度</p><ul><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，设置StringTable长度的话，1009是可以设置的最小值</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul><li>直接使用双引号声明出来的String对象会直接存储在<strong>常量池</strong>中。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</li><li>使用new，生成的对象在堆中，不入池。</li></ul><h3 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>Java 6及以前，字符串常量池存放在永久代<br>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<br>Java 8元空间，字符串常量池在堆内。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><code>String str =&quot;ab&quot; + &quot;cd&quot;</code>创建了1个对象，因为”ab”+”cd”会被编译器优化，只在常量池创建一个”abcd”并返回。</li><li><code>String str = new String(&quot;123&quot;)</code>创建了2个对象，一个”123”在字符串常量池，一个new String在堆中，返回堆中对象。</li></ul><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><ul><li><strong>常量(final)与常量(final)</strong> 的拼接结果在常量池，原理是编译期优化</li><li><strong>只要其中有一个是变量</strong>，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li></ul><h4 id="优化拼接"><a href="#优化拼接" class="headerlink" title="优化拼接"></a>优化拼接</h4><ul><li>尽量使用<strong>StringBuilder.append()</strong></li><li>可以在初始化时，指定StringBuilder的capacity，减少扩容次数。</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>语义是：返回常量池中的相同字符串。</p><ul><li>如果池中本身存在该String对象，则直接返回池中对象。</li><li>否则，将该对象添加到池中，并返回该String对象。</li></ul><h4 id="JDK6-gt-JDK7-x2F-8"><a href="#JDK6-gt-JDK7-x2F-8" class="headerlink" title="JDK6-&gt;JDK7&#x2F;8"></a>JDK6-&gt;JDK7&#x2F;8</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br><span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-built_in">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br><span class="hljs-built_in">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224322.png"><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224329.png"></p><p>JDK1.6中，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象<strong>复制一份</strong>，放入池中，返回池中对象。</li></ul><p>JDK1.7后，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象的<strong>引用地址复制一份</strong>，放入池中，返回引用地址对象。</li></ul><p>简单讲，JDK7后的方式，省去了复制对象的开销。</p><h2 id="G1垃圾处理器去重String"><a href="#G1垃圾处理器去重String" class="headerlink" title="G1垃圾处理器去重String"></a>G1垃圾处理器去重String</h2><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。然后对队列中的元素进行去重处理。</li><li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ol><h1 id="七、垃圾回收"><a href="#七、垃圾回收" class="headerlink" title="七、垃圾回收"></a>七、垃圾回收</h1><h2 id="垃圾回收概念"><a href="#垃圾回收概念" class="headerlink" title="垃圾回收概念"></a>垃圾回收概念</h2><h3 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h3><p><strong>垃圾</strong>：垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>早期C&#x2F;C++，需要开发人员手动释放内存，若存在疏忽则会永久产生内存泄漏。</p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p>Java堆是垃圾收集器的工作重点</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h3 id="对象finalization机制"><a href="#对象finalization机制" class="headerlink" title="对象finalization机制"></a>对象finalization机制</h3><ul><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。</li><li>不要手动调用，应该由垃圾处理器调用<ul><li>调用可能使对象复活</li><li>执行时间无保证，取决于GC线程</li></ul></li><li>finalize()只能被调用一次，也就是说一个对象最多复活一次。</li></ul><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br>优点：</p><ul><li>实现简单，判断效率高。<br>缺点：</li><li>增加了对象的字段</li><li>加减法时间开销</li><li><strong>无法处理循环引用</strong><br>Python使用引用计数算法，通过弱引用解决循环引用的问题。</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>可达性分析算法是以<strong>根对象集合</strong>（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li></ul><h5 id="GCRoot"><a href="#GCRoot" class="headerlink" title="GCRoot"></a>GCRoot</h5><p>栈上引用</p><ul><li>虚拟机栈上引用对象</li><li>本地方法栈上引用对象</li></ul><p>方法区引用</p><ul><li>类静态属性</li><li>常量引用（String Table等）</li></ul><p>其他引用</p><ul><li>同步锁对象</li><li>虚拟机内部对象（class对象）</li><li>本地代码缓存等</li></ul><p>当然还要考虑GC的作用空间：对于young空间的某对象A，存在着被old空间的对象B引用的情况，因此old空间的对象也需要考虑到GCRoots集合中。</p><h4 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h4><p>由于finalize的存在，对象有三种状态。</p><ul><li>可触及</li><li>可复活</li><li>不可触及</li></ul><p>标记过程：</p><ol><li>若无引用，进行一次标记</li><li>若无finalize或finalize已经被执行过，进行二次标记，为不可触及。</li><li>若有finalize，加入F-Queue队列等待Finalizer线程执行finalize方法。</li><li>随后GC对F-Queue进行标记，看是否可触及，可触及则移出队列，否则移出并标记为不可触及。</li></ol><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231730.png"></p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p>缺点</p><ul><li>效率不高</li><li>STW</li><li>碎片</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231822.png"><br>优点</p><ul><li>不需要标记清除，直接复制可达对象，高效</li><li>无碎片<br>缺点</li><li>空间消耗大</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>Survivor区</li></ul><h4 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131232037.png"><br>优化了复制算法，使用原本的内存进行移动。</p><p><strong>指针碰撞</strong><br>指这种通过指针记录空闲空间的起始点，为新对象分配内存时可以直接分配。</p><p>优点</p><ul><li>相对标记清除，使用了指针碰撞</li><li>相对复制算法，不耗多余内存</li></ul><p>缺点</p><ul><li>效率比复制低（时间换空间）</li><li>移动对象时，若对象被其他对象引用，需要调整引用地址（与复制算法相同）</li><li>STW</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>对不同生命周期的对象采取不同的收集方式，以便提高回收效率。即，实际上的GC采用的是分代收集，其根据收集区域使用不同的收集方式。</p><ul><li>年轻代（Young Gen），空间不大，复制算法效率最高。</li><li>老年代（Tenured Gen），不同GC的处理方式不同。</li></ul><h3 id="增量收集算法与分区算法"><a href="#增量收集算法与分区算法" class="headerlink" title="增量收集算法与分区算法"></a>增量收集算法与分区算法</h3><h4 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h4><p>为了避免STW，GC线程与用户线程交替进行，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><p>缺点：线程上下文切换造成总吞吐量下降。</p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131233426.png"></p><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>提醒JVM进行FullGC,不保证立刻生效。</p><h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><ul><li>内存溢出：内存超了<ul><li>超出设置，可以调整</li><li>超出机器内存上限</li></ul></li><li>内存泄漏：存在不再使用的对象无法被回收<ul><li>例子：单例模式，资源未close<br>可以说内存泄漏是内存溢出的元凶之一。</li></ul></li></ul><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>标记过程（枚举GC Roots）需要STW，因为分析工作必须在一个快照中进行，否则准确性无法保证。</p><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上同时发生了，只在多核CPU存在。</li></ul><h4 id="对于垃圾回收"><a href="#对于垃圾回收" class="headerlink" title="对于垃圾回收"></a>对于垃圾回收</h4><p>并行（<em>Parallel</em>）：<strong>多条GC线程</strong>同时执行GC。<br>串行（<em>Serial</em>）：<strong>单GC线程</strong>执行GC。<br>并发（<em>Concurrent</em>）：<strong>用户线程与GC线程</strong>交替执行。</p><p>一次GC可能同时具有并行、并发的特性。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>只有在特定的位置才能STW，这些位置称为安全点。</p><p>放置的安全点不能太多，当然也不能太少。放置安全点的位置一般是以“是否具有让程序长时间执行特征”为标准进行选定，当线程运行到安全点时，其状态是确定的。不同虚拟机对于自己safe point的实现不一定一样，对于HotSpot：</p><ul><li>解释器：每一段字节码的边界都可以作为一个safe point，因为对于解释器来说找到完整的执行状态实在是一件非常容易的事。</li><li>JIT：对于来说则是以每个方法临返回前，以及所有的非 counted loop（可数循环） 循环回跳之前，放置一个safe point。并且在每个safepoint生成一些“调试符号信息”，方便VM找到需要的运行状态。</li></ul><p>中断方式：</p><ul><li>抢先式中断（已经不再使用），让所有线程在安全点中断。</li><li>主动式中断，线程运行到安全点后主动询问是否需要中断。</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点具有盲区，如果线程无法走到安全点（如Sleep或Block），也应该有中断的机会。<br>安全区域：<strong>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。</strong><br>因此，也可以把Safe Region看做是被扩展了的Safepoint。</p><p>执行时，若线程处于SaveRegion，则可以忽略该线程。当线程走出SaveRegion时，需要判断GC是否结束，若未结束则需要等待。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。<br>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们<br>分类：</p><ul><li>强引用（StrongReference）：引用赋值，不回收。</li><li>软引用（SoftReference）：内存不够（将要溢出前）时进行回收</li><li>弱引用（WeakReference）：GC时后回收</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>不回收，内存泄漏的主要原因之一。</li><li>可以直接访问目标对象。</li></ul><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><ul><li>内存不足即回收。</li><li>主要用于高速缓存。<br>软引用回收时，GC会选择性的将软引用放进一个<strong>引用队列</strong>。</li></ul><h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><ul><li>发现即回收。</li><li>GC时发现弱引用即回收。</li><li>也可用于缓存<br>比软引用回收更容易，更快。</li></ul><p><strong>会被回收的是WeakReference对象持有的对象，WeakReference本身并不会被回收。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value&quot;</span>);<br>WeakReference&lt;String&gt; WeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(hello);<br><span class="hljs-comment">//此时不会回收，因为该String被hello强引用持有。</span><br>System.gc();<br>hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value2&quot;</span>);<br><span class="hljs-comment">//此时，new String(&quot;value&quot;)被回收。</span><br>System.gc();<br></code></pre></td></tr></table></figure><h4 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h4><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。<br>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><div class="note note-primary">            <p>简而言之，将对象放入虚引用后得到的引用sf没有任何作用。<br>但当Object被回收时，phantomQueue会被添加一个虚引用，表示对象已被回收。</p>          </div><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象。</p><div class="note note-primary">            <p>由此可见，引用总是伴随着引用队列，JVM根据队列依次对引用进行处理。</p>          </div><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。<br>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。<br>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。<br>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p><h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><ul><li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li>内存占用：Java堆区所占的内存大小。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul><p>主要抓住两点：<strong>吞吐量（总效率）、暂停时间（用户体验）</strong><br>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h3 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143734.png"><br>按线程和工作模式分：</p><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1<br>按内存区分：</li><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143826.png"></p><ul><li>红色虚线是JDK8已经被移除的GC</li><li>绿色虚线是JDK14中弃用的组合</li><li>蓝色框CMS GC已被删除</li></ul><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>我们选择的只是对具体应用最合适的收集器。<br><code>-XX:+PrintCommandLineFlags</code>可以查看默认参数。</p><h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><strong>Serial GC</strong>：STW，单线程，复制算法<br><strong>Serial Old GC</strong>：STW，单线程，标记-压缩算法。</p><div class="note note-primary">            <p>根据新老年代需求给出的最土味的算法。</p>          </div><h5 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h5><p>Serial Old是Client模式下的默认回收器。<br>简单高效，但单线程不太行，对于web应用不可接受，已经不用了。</p><h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>只回收新生代<br><strong>ParNew</strong>：STW，多线程，复制算法</p><div class="note note-primary">            <p>相对Serial回收器的多线程版本</p>          </div><h5 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h5><p>单CPU下不如串行，可以设置线程数。</p><h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p><strong>Parallel Scavenge</strong>：STW，多线程，复制算法<br><strong>Parallel Old</strong>：STW，多线程，标记压缩</p><div class="note note-primary">            <p>Parallel Scavenge相比于ParNew，回收的目标是<strong>最大的吞吐量</strong>，因此其可控制吞吐量，自适应调节。比较适合<strong>批处理</strong>。</p>          </div><h5 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h5><p>JDK8的Server模式下的默认回收器，可以设置线程数和垃圾收集器最大停顿时间，吞吐量，以及设置自适应调节策略。</p><h4 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201145934.png"><br>只回收老年代，是第一款并发收集器，用户线程与GC线程同时工作。<br><strong>CMS（Concurrent Mark Sweep）</strong>：STW，单&#x2F;多线程，标记-清除算法</p><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><ul><li>初始标记：STW，标记GCRoots以及其直接关联到的对象。</li><li>并发标记：根据GCRoots直接关联对象遍历对象图。</li><li>重新标记：STW，修正由于并发标记期间用户线程造成的变化。</li><li>并发清理：清除标记删除的对象，释放内存。<br>由于并发标记和并发清理最耗费时间，采用并发的方式，整体回收停顿很低。</li></ul><p>另外，由于并发标记，清理中用户线程仍在跑，需要提前进行CMS回收才能防止OOM，一般是当堆内存使用率达到某一阈值时，便开始进行回收。<br>由于标记清除，会产生内存碎片，只能通过<strong>空闲列表</strong>分配内存。</p><h5 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h5><ul><li>并发收集，低延迟</li><li>会产生内存碎片，低延迟但吞吐量不行。</li><li>无法处理浮动垃圾（并发标记期间产生的新垃圾）</li></ul><blockquote><p><strong>重新标记</strong>（三色标记法<a href="https://baijiahao.baidu.com/sid=1719715247743913571&wfr=spider&for=pc%EF%BC%89">https://baijiahao.baidu.com/sid=1719715247743913571&amp;wfr=spider&amp;for=pc）</a><br>由于标记阶段是从GC Roots开始标记可达对象，那么在并发标记阶段可能产生两种变动:<br>1．本来可达的对象，变得不可达了<br>2．本来不可达的内存，变得可达了<br> 第一种变动会产生所谓的浮动垃圾，第二种变动怎么回事呢?重点在于miss。如果并发标记阶段用户线程里new了一个对象，而它在初始标记和并发标记中是不会能够从GC Roots 可达的，也就是were missed。如果没有重新标记阶段来将这个对象标记为可达，那么它会在清理阶段被回收，这是严重的错误，是必须要在重新标记阶段来处理的，所以这就是重新标记阶段实际上的任务。<br> 相比之下，浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢?也许是由可达变为不可达这样的变化需要重新从GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。<br> CMS通过增量更新：扫描已经完成的对象A指向新对象B，将A标灰。<br> G1通过原始快照STAB：某个新对象B被取消引用时，将其标记为灰。</p></blockquote><p>可以设置触发阈值，JDK9中标记过时，JDK14中已经删除。</p><h4 id="G1（Garbage-First）回收器"><a href="#G1（Garbage-First）回收器" class="headerlink" title="G1（Garbage First）回收器"></a>G1（Garbage First）回收器</h4><p>官方给G1设定的目标是在<strong>延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“全功能收集器”的重任与期望。只所以叫G1回收器是因为其优先回收垃圾最多的空间。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151459.png"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>并行性：STW，多线程回收</li><li>并发性：部分工作可以与应用程序交替进行</li><li>分代：依然保持分代，但不要求连续空间，同时回收年轻代和老年代。</li><li>空间整合：Region之间复制算法，整体使用标记压缩，都避免内存碎片。</li><li>延迟：可以只回收一个Region，优先回收价值最大的Region。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不能碾压CMS，运行负担更大，小内存应用上CMS更好，大内存引用上G1更好。（6-8G左右）</li></ul><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li><li>当然也可以设置并发标记线程数和触发阈值。<br>提供三种垃圾回收模式：Young GC，Mixed GC，Full GC。</li></ul><h5 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151944.png"></p><ul><li>Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了找连续H区有时必须FullGC。</li><li>对每个Region内部使用指针碰撞方式分配空间（标记压缩）</li></ul><h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152200.png"></p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC） </li><li>全局GC（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p>一个对象可能被不同区域引用，<strong>Remembered Set是所有分代收集器避免全局扫描的关键</strong>。</p><p>G1的实现细节：<br>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作，然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象），如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152820.png"></p><blockquote><ul><li>RememberSet是一种思想，其记录了待收集region中的对象被哪些其他非待收集region所引用，那么在回收该region时还需要将其他region加入到root中。</li><li>只向其他区域时有不同的粒度：</li><li>字长</li><li>对象</li><li>卡</li><li>Card Table则是一种rset的具体实现，其实现是基于卡精度，其将内存以512Byte作为一个单元分成很多entry，以entry为单位记录卡的状态，如：region1和region3中的两个entry就被region2的rset标记为脏卡。然后把Card存入Dirty Card Queue，这是因为RSet存在多线程竞争写入问题。</li></ul></blockquote><div class="note note-primary">            <p>即，将对象赋予给一个引用时，检查引用与对象是否在同一个region，若不在，则在对象所在region的remember set上记录对象被引用信息，最后在回收该区域时，将remember set上的对象也加入GCRoots。</p>          </div><h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201153244.png"><br>触发：当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。<br>回收范围：Eden区和Survivor区。<br>执行原理：STW，多线程，复制算法<br>过程：</p><ol><li>扫描root</li><li>更新rset（将Dirty Card Queue中的Card全部处理）</li><li>处理rset</li><li>复制对象</li><li>处理引用（存活对象的地址发送变化）</li></ol><h5 id="Conconrrent-Mark"><a href="#Conconrrent-Mark" class="headerlink" title="Conconrrent Mark"></a>Conconrrent Mark</h5><p>触发：堆内存达到45%时触发。<br>回收范围：Eden和Survivor区（触发一次Young GC）<br>过程：</p><ol><li>初始标记阶段：STW，扫描GCRoots，并触发一次Young GC（不一定立即执行）。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。<strong>这一过程必须在YoungGC之前完成。</strong></li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：STW，修正并发标记的问题。</li><li>独占清理（cleanup）：STW，计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h5 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h5><p>触发：并发标记结束后<br>回收范围：整个Young Region（Eden，Survivor），部分的Old Region(默认为1&#x2F;8，但分段执行8次)。<br>过程：<br>并发标记结束后，全垃圾的region已经被回收，部分垃圾的region已经被计算。使用和年轻代一样的方法GC即可。<br>备注：</p><ul><li>可以设置垃圾阈值，默认一个region只有垃圾占65%时才回收。</li><li>可以设置允许的垃圾阈值，当整堆中垃圾小于其时，不进行MixedGC。</li></ul><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>触发：以上方式无法正常工作（并发处理过程完成前空间耗尽）。<br>回收范围：整堆<br>特点：STW</p><h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</li><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。<br>回收器选择：官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><div class="note note-primary">            <p>G1回收器，三种清理模式：</p><ul><li>YoungGC：全程STW，根据GCRoots直接处理Young Region，注意rset的处理，region间复制算法。</li><li>MixedGC：<ul><li>STW扫描全局GCRoots，进行根区域扫描，根据Survivor区找Old区的对象，也压入扫描栈。</li><li>YoungGC</li><li>并发标记，STW，可能被YGC打断，根据扫描栈扫描对象。</li><li>STW修正标记，处理没处理的write barrier，即新出现的引用变化，但与CMS不同，这里的扫描范围只扫描SATB（snapshot-at-the-beginning），比CMS快。</li><li>STW计算区域属性</li><li>并发清理完全为空的区域</li><li>分段（默认8段）清理各区域。</li></ul></li><li>FullGC</li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第5章（集合）</title>
    <link href="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <url>/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="集合知识体系"><a href="#集合知识体系" class="headerlink" title="集合知识体系"></a>集合知识体系</h1><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109204736.png"><br>集合主要分Map和Collection两个体系:</p><ul><li>Map<ul><li>SortedMap<ul><li>NavigableMap</li></ul></li></ul></li><li>Collection<ul><li>List</li><li>Queue<ul><li>Deque</li></ul></li><li>Set<ul><li>SortedSet<ul><li>NavigableSet</li></ul></li></ul></li></ul></li></ul><div class="note note-primary">            <p>以上都是接口，从功能角度上对集合进行了分类。</p><ul><li>Map作为字典，重要的是其搜索能力，所以其有sorted-&gt;navigable的继承接口。</li><li>Collection中<ul><li>List体现的是对数组的封装，可以随机获取。</li><li>Queue体现单端的进出（堆）<ul><li>Deque实现双端的任意出入</li></ul></li><li>Set需要去重，重要的同样是其搜索能力，所以与map类似，有sorted-&gt;navigable的继承。</li></ul></li></ul>          </div><div class="note note-success">            <p>从基本的实现来看:</p><ul><li>Map<ul><li>map的朴素实现是HashMap<ul><li>HashMap有时需要保留先后顺序，LinkedHashMap继承自HashMap</li></ul></li><li>map搜索增强的实现是TreeMap</li><li>还有一些功能性Map(不做重点)，直接继承Map<ul><li>WeakHashMap，软引用，处于缓存角度，键值可以被回收</li><li>IdentifyHashMap，判断两值相等，只看其引用地址的16位hash（强相等）</li><li>EnumMap，只允许key为指定枚举值，底层其实是array实现。</li></ul></li></ul></li><li>Collection<ul><li>list的朴素实现是ArrayList<ul><li>vector还继承了list，是线程安全的，但已不推荐使用。<ul><li>stack继承了vector，先入先出</li></ul></li></ul></li><li>queue的实现是PriorityQueue(堆)<ul><li>deque的朴素实现是<strong>LinkedList</strong>，这个类也继承了List和Queue，三姓家奴</li><li>deque的另一个实现是ArrayDeque</li></ul></li><li>set与map类似，有HashSet-&gt;LinkedHashSet,TreeSet等实现。</li></ul></li></ul>          </div><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>继承：ArrayList实现了List接口<br>null：允许放入null<br>底层实现：array<br>同步：同步类为vector</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当数组capacity &#x3D;&#x3D; size时添加新元素</li><li>数组扩容通过一个公开的方法<code>ensureCapacity(int minCapacity)</code>来实现。</li><li>每次大约扩容1.5倍。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109213925.png"></li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li>每次add前通过<code>ensureCapacity()</code>确保容量足够</li><li><code>add(int index,E e)</code>，需要先对元素进行移动<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109214209.png"></li><li><code>addAll()</code>，注意addAll不会调用add，其需要保证modCount只+1次。</li></ul><h3 id="set-x2F-get"><a href="#set-x2F-get" class="headerlink" title="set()&#x2F;get()"></a>set()&#x2F;get()</h3><p>直接操作数组即可，不过要检查参数索引是否越界。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><ul><li><code>remove(int index)</code>移除指定坐标，原地copy数组完成</li><li><code>remove(Object o)</code>移除指定对象，底层通过equals判断</li></ul><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>将底层数组的容量调整为当前列表保存的实际元素的大小。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index，也通过equals判断。</p><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>快速失败，modCount标记操作数，避免并发带来的不确定风险。</p><div class="note note-primary">            <p>注意，除了扩容，其他的remove操作只会在原数组上进行copy，通过size维护有效数组大小即可。</p>          </div><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>注意不存在哑节点。</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>LinkedList同时实现了List接口和Deque接口。<br>不过现在的首选是ArrayDeque，其底层通过数组实现，性能更好。</p><h2 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h2><h3 id="底层-1"><a href="#底层-1" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><ul><li><code>getFirst()</code>, <code>getLast()</code>直接获取即可。</li><li><code>get(int index)</code>，通过<code>node(index)</code>获取节点并修改。</li></ul><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h3><p>底层调用unlink方法释放节点。</p><ul><li><code>removeFirst()</code>, <code>removeLast()</code>直接删除，调整指针即可。</li><li><code>remove(e)</code>需要迭代equals判断</li><li><code>remove(index)</code>同理（调用<code>node(index)</code>）<br>ps:</li><li>注意，以上方法都会先对操作的可行性进行判断。</li><li>查找指定索引节点的方法为<code>node(index)</code>，其会根据index判断从前开始找还是从后开始找速度快。</li></ul><h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><ul><li><code>add(E e)</code>直接加到尾部</li><li><code>add(int index,E e)</code>需要线性查找(也会先找<code>node(index)</code>)</li></ul><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>同arraylist，不会调用add()。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>会迭代将node之间引用清空，加快清理速度。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>通过equals迭代判断。</p><h3 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h3><p>上面都是一些list方法的实现，linkedlist还实现了queue和deque，以下是对这些类的实现。<br>peek(),element(),poll(),remove(),offer()</p><ul><li>peek,element,poll,remove都是操作头元素，offer操作尾元素</li><li>element调用<code>getFirst()</code>会抛出空异常，peek()返回null。</li></ul><h3 id="Deque方法"><a href="#Deque方法" class="headerlink" title="Deque方法"></a>Deque方法</h3><p>offerFirst,offerLast,peekFirst,peekLast,pollFirst,pollLast,push,pop</p><ul><li>push，pop都操作头元素。</li></ul><div class="note note-primary">            <p>记忆，</p><ul><li><code>peek,push,pop</code>属于栈方法，操作头元素</li><li><code>peek,offer,poll</code>属于队列方法，默认操作头元素，不会异常，且有双端方法可以使用</li><li><code>add,remove</code>属于list方法，操作尾部元素</li></ul>          </div><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack是一个具体的实现类，而Queue却没有，这是一个反常理的事情，不过现在Java已经不推荐使用Stack了，<code>ArrayDeque</code>往往更高效。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是一个接口，实现了Collection接口，其队列特殊方法不会抛出异常。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>deque是一个接口，实现了Queue接口，表示双向队列，支持双向的队列操作。<br>deque常见的实现是LinkedList和ArrayDeque</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>底层通过数组实现，且数组为循环数组，即任一点都可以是起点或终点，如下图。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109232400.png"></p><h3 id="机制-2"><a href="#机制-2" class="headerlink" title="机制"></a>机制</h3><p>ArrayDeque不允许放入null</p><h4 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h4><p><code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code><br>会对head-1取模，如果<code>head-1==-1</code>,则得到的head&#x3D;<code>elements.length - 1</code>，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><div class="note note-primary">            <p>elements.length总为偶数，-1后为全1。<br><code>(head - 1) &amp; (elements.length - 1)</code>相当于对<code>head-1</code>对<code>elements.length-1</code>做取模处理。</p><ul><li>head值若超过length-1，则相当于取余</li><li>head-1若为负数，相当于取对element.length的补码。</li><li>实际上head-1最小为-1，取补码后等于element.length-1。</li></ul>          </div><h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><p>容量满了就需要扩容，方法是<code>doubleCapacity()</code>。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109233801.png"></p><ul><li>第一次复制<code>head</code>右边的元素。</li><li>第二次复制<code>head</code>左边的元素。</li></ul><h4 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h4><p><code>(tail = (tail + 1) &amp; (elements.length - 1)) == head</code><br>tail+1取模，若<code>tail+1==elements.length-1</code>，则得到的tail &#x3D; 0，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><h3 id="pollFirst-pollFirst-peekLast-，pollLast"><a href="#pollFirst-pollFirst-peekLast-，pollLast" class="headerlink" title="pollFirst(),pollFirst(),peekLast()，pollLast()"></a>pollFirst(),pollFirst(),peekLast()，pollLast()</h3><p>返回对应值，为空则返回Null。</p><div class="note note-primary">            <p>注意，ArrayList扩容是1.5倍，ArrayDeque扩容是2倍。</p>          </div><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><ul><li>优先队列不允许放入<code>null</code>元素。</li><li>其通过完全二叉树的小顶堆实现。</li></ul><h3 id="机制-3"><a href="#机制-3" class="headerlink" title="机制"></a>机制</h3><h4 id="底层-2"><a href="#底层-2" class="headerlink" title="底层"></a>底层</h4><p>PriorityQueue底层通过数组维护堆结构<br><code>leftNode = parentNode*2+1</code><br><code>rightNo = parentNo*2+2</code><br><code>parentNo = (nodeNo-1)/2</code></p><h4 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h4><p>使用<code>grow()</code>函数，会复制原数组元素到新数组</p><h4 id="element-peek"><a href="#element-peek" class="headerlink" title="element(),peek()"></a>element(),peek()</h4><p>一个会抛异常，一个不会。都返回下标为0的元素。</p><h4 id="add-offer"><a href="#add-offer" class="headerlink" title="add(),offer()"></a>add(),offer()</h4><p>add、offer，添加在数组末尾，然后逐步向上调节。<br>会调用<code>siftUp(int k, E x)</code>，用于在指定位置插入节点并进行调整。</p><h4 id="remove-poll"><a href="#remove-poll" class="headerlink" title="remove(),poll()"></a>remove(),poll()</h4><p>一个会抛异常，一个不会，都移除下标为0的元素，然后进行堆调整。<br>会调用<code>siftDown(int k, E x)</code>，用于在指定位置删除节点并进行调整。</p><div class="note note-primary">            <p>siftUp，siftDown会根据指定元素x，不断对该位置及其上&#x2F;下的节点进行比较并移动，直到满足找到x小于&#x2F;大于目标节点的时候截至。</p>          </div><h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p>遍历数组删除第一个equals的元素。</p><h1 id="HashSet-amp-HashMap"><a href="#HashSet-amp-HashMap" class="headerlink" title="HashSet&amp;HashMap"></a>HashSet&amp;HashMap</h1><p>二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，即默认value &#x3D;&#x3D; null。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashTable是同步的HashMap。该map不保证元素顺序。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。</p><h3 id="Java7"><a href="#Java7" class="headerlink" title="Java7"></a>Java7</h3><p>HashMap采用的是冲突链表方式。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110203318.png"></p><p>可见put，get方法可以在常数时间完成，但若table过大，对map进行遍历就会很耗时。</p><p>有<strong>两个参数</strong>可以影响HashMap的性能: 初始容量(<em>inital capacity</em>)和负载系数(<em>load factor</em>)。</p><ul><li>初始容量指定了初始<code>table</code>的大小，默认为16。</li><li>负载系数用来指定自动扩容的临界值，默认为0.75<br>当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容（2倍）并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</li></ul><p>将对象放入到HashMap或HashSet中时，有<strong>两个方法</strong>需要特别关心：<code>hashCode()</code>和<code>equals()</code>。</p><ul><li><strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。</li><li>所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><p>先<code>getEntry</code>，然后<code>getValue</code><br>其中getEntry先通过hashCode判断bucket，然后通过equals遍历判断。</p><p>求bucket的过程：<br><code>hash(k)&amp;(table.length-1)</code>，与list扩容类似，取模。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>先<code>getEntry</code>，如果没有则<code>addEntry</code>。在链表中使用<strong>头插法</strong>。</p><h4 id="remove-2"><a href="#remove-2" class="headerlink" title="remove()"></a>remove()</h4><p>先<code>getEntry</code>，然后remove。</p><h3 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h3><p>由 <strong>数组+链表+红黑树</strong> 组成。<br>当链表中的元素达到了<strong>8</strong>个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110204320.png"><br>链表的元素为<code>Node</code>，红黑树的元素为<code>TreeNode</code>，通过头节点的类型判断是链表还是红黑树。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize()方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 <strong>2倍</strong>，并进行数据迁移。</p><div class="note note-primary">            <p>hash的长度始终为2的幂的原因：</p><ul><li>效率上：元素在数组中的位置取决于<code>hashCode%length</code>，但求余效率不如位移运算，源码中做了优化<code>hash&amp;(length-1)</code>，而<code>hash%length==hash&amp;(length-1)</code>的前提是length是2的n次方；</li><li>避免碰撞：2的n次方-1 实际就是n个1，因为每一位都参与运算，这样做散列更均匀。</li><li>简化实现：扩容时，每个桶中的元素只有两种结果：1.保留在原桶 2.迁移到确定的新桶。<ul><li>隔离性：每个桶中只有部分元素会迁移到新桶，且该新桶中元素只来源于一个原桶。</li><li>稳定性：在JDK8中，尾插法保证了原桶和新桶中元素顺序与扩容前一致。</li><li>简化判断：在实现时，不需要反复判断某桶中每个元素的目标桶，只需要判断其是否需要迁移即可，是否迁移取决于：<code>hashCode&amp;(newLength-1) =? hashCode&amp;(oldLength-1))</code>，上式等效于<code>hashCode&amp;oldLength == 0</code>，因此只需要将hashCode与原容量进行与运算即可得知该元素是否迁移。</li></ul></li></ul>          </div><h4 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h4><p>java8使用了尾插法，从而避免在并发情况下出现环形链表。</p><div class="note note-primary">            <p>成环原因：</p>          </div><blockquote><p><a href="https://zhuanlan.zhihu.com/p/200997545">环形链表原因</a></p></blockquote><div class="note note-primary">            <p>java7是先扩容再插值，java8是先插值再扩容，猜测的原因为：</p><ul><li>java7基于头插法，先扩容后可以直接计算目标值hash，插入扩容后的集合。</li><li>java8基于尾插法，且使用了红黑树结构，先将元素插入后在改变结构更方便。</li></ul>          </div><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p>判断是红黑树还是链表，采用不同方法取值。<br>具体红黑树讲解见TreeMap</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>就是对HashMap的一层包装。</p><h1 id="LinkedHashMap-amp-LinkedHashSet"><a href="#LinkedHashMap-amp-LinkedHashSet" class="headerlink" title="LinkedHashMap&amp;LinkedHashSet"></a>LinkedHashMap&amp;LinkedHashSet</h1><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>实现了map接口，<strong>允许放入key或value为null的元素</strong>，也是HashMap的子类。其使用双向链表将所有entry相连接。并多了header和tail指向<code>头部</code>和<code>尾部</code>。</p><p>优点：遍历时不用遍历所有bucket，只用遍历entrylist即可。</p><p>有<strong>两个参数</strong>可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。<br>将对象放入到LinkedHashMap或LinkedHashSet中时，有<strong>两个方法</strong>需要特别关心: <code>hashCode()</code>和<code>equals()</code>。</p><p>这点与HashMap相同。<br>其没有同步化实现，若需要同步，可使用：<br><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p><h3 id="get-3"><a href="#get-3" class="headerlink" title="get()"></a>get()</h3><p>同HashMap</p><h3 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h3><p>也是先getEntry，然后再addEntry<br>add时，既要使用头插法插入bucket链表头部，也要将其插入linkedlist的尾部。</p><h3 id="remove-3"><a href="#remove-3" class="headerlink" title="remove()"></a>remove()</h3><p>同样先get，然后remove，同时维护两个链表。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>是LinkedHashMap的简单包装。</p><h1 id="TreeSet-amp-TreeMap"><a href="#TreeSet-amp-TreeMap" class="headerlink" title="TreeSet&amp;TreeMap"></a>TreeSet&amp;TreeMap</h1><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeSet是对TreeMap的一层包装。</p><p>底层通过红黑树实现。意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。</p><p>TreeSet是非同步的，若需要同步，可以使用：<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1d64y1z7Uk?p=20&vd_source=7324e975d0c1b4b4719d1194e3649ff8">bilibili</a><br>参考blog：<a href="https://www.bilibili.com/read/cv17486236">bilibili</a><br><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。</p><p>性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。<br>树结构改变时，任意破坏3，4，因此需要调整。</li></ol><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="234树"><a href="#234树" class="headerlink" title="234树"></a>234树</h4><p>一种特殊的搜索树。</p><ul><li>2节点表示1个key组成的一个节点</li><li>3节点表示2个key组成的一个节点</li><li>4节点表示3个key组成的一个节点</li></ul><p>当给234树添加节点时</p><ul><li>通过搜索找到应该插入的节点。</li><li>如果该节点位置已经有不超过3个节点，则可以进行合并。</li><li>如果已经为4节点，则需要拆解出节点并向上移动。</li></ul><p>因为这样自底向上的插入性质，其所有根节点的高度总是相等的。</p><h4 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是可以和234树等价的。</p><ul><li>2节点表示一个黑节点</li><li>3节点表示一个红节点和其一个黑子节点</li><li>4节点表示一个红节点和其两个黑子节点</li></ul><p>另外红黑树每个叶子节点都是黑节点（一般是隐藏的，其不会影响红黑树的3，4性质）</p><h4 id="左旋-x2F-右旋"><a href="#左旋-x2F-右旋" class="headerlink" title="左旋&#x2F;右旋"></a>左旋&#x2F;右旋</h4><p>以x节点为中心左旋，其右子节点r会成为x节点的父节点。右子节点r的左节点rl会称为x的右节点。<br>右旋同理，左右旋主要是为了调整树的节点构造，在不影响整体高度的情况下达到我们想要构造。</p><h4 id="节点后继"><a href="#节点后继" class="headerlink" title="节点后继"></a>节点后继</h4><p>搜索树中某节点x有前继pre（比x小的最大节点）和后继post（比x大的最小节点）节点。这两个节点可以完美替换节点x。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="get-4"><a href="#get-4" class="headerlink" title="get()"></a>get()</h4><p>按照常规二叉搜索树寻找即可。<br>底层根据compareTo()的返回值判断进行迭代。</p><h4 id="put-3"><a href="#put-3" class="headerlink" title="put()"></a>put()</h4><p>先查找，若没有，则add。<br>其可能破坏红黑树约束条件，因此需要调整。<br>1.默认插入RED节点。<br>2.1.若其父节点也为BLACK节点，不影响高度（return）。<br>2.2.若其父节点也为RED，需要调整父节点及其叔叔节点为BLACK(+1)，并让爷爷节点为RED(-1)。<br>3.迭代至根节点。</p><h4 id="remove-4"><a href="#remove-4" class="headerlink" title="remove()"></a>remove()</h4><p>先查找，若有，则remove。<br>其可能破坏红黑树约束条件，因此需要调整。</p><p>1.可能移除树中任意位置的节点，可以通过<strong>值替换</strong>的方式转化为移除其前继或<strong>后继</strong>节点，最终只会删除叶子节点或有单侧叶子节点的节点</p><p>2.1.若移除的是RED节点，不影响高度(return)。<br>2.1.1如果该节点是叶子节点，直接(return)<br>2.1.2如果该节点有单侧叶子节点，由叶子节点替代该节点（return）。</p><p>2.2.若移除的是BALCK节点L，需要调整。<br>2.2.1如果该节点是叶子节点，需要先调整，再移除<br>2.2.2如果该节点有单侧子节点，由子节点替代该节点后，再调整。</p><div class="note note-primary">            <p>所谓调整，本质上是一个方法 f(Node node)，其能让node节点这一侧补充一个黑色节点高度。核心思想是，由于移除了黑色节点L，该侧高度（-1），需要找一个节点（且为黑色）补充回来。</p><ul><li>如果L有红色子节点，将其提升后染黑即可。</li><li>如果L没有红色子节点，需要将其父节点P的左&#x2F;右旋，将P移到该侧填补黑色节点。然后由其兄弟节点提升多余节点（兄弟节点有红色子节点）代替父节点并进行调整。</li><li>如果兄弟节点R没有多余红色节点，则将兄弟节点一起染红，然后迭代其父节点P作为L。</li></ul>          </div><p>2.3.1.如果替代上来的节点是红色节点，将其染黑即可(return)<br>2.3.2.如果原节点(2.2.1)或替代上来的节点是黑色节点(2.2.2)，需要进行旋转调整。<br>2.3.3.事实上这不会容易，父节点P左旋时，其右节点R会成为新的父节点，这会导致右侧减去一个节点R，因此，右旋时要保证右侧的高度也不变，需要满足以下几种条件之一：<br>2.4.1.如果兄弟节点为红色，说明其不是真正的兄弟节点（因为234树中3节点和4节点都应该是黑色节点为根），此时应该<strong>调整兄弟节点成黑色节点为根的形态</strong>(通过左&#x2F;右旋并调整颜色实现，达到2.4.2)。<br>2.4.2.如果兄弟节点为黑色，考虑其子节点是否有红色节点可以借用。<br>2.4.2.1.兄弟节点有红色子节点：</p><ul><li>将父节点左旋，并染黑，补充L侧的黑节点个数</li><li>原兄弟节点成为新的父节点，将其调整为原父节点P的颜色</li><li>原兄弟节点的子节点成为新父节点的右节点，将其染黑补充R侧的黑节点个数</li><li>return</li></ul><p>2.4.2.2.兄弟节点没有红色子节点:</p><ul><li>将兄弟节点染红，则导致父节点到叶子的路径总体-1，以父节点为新的L迭代2.2.1步，可以将其视为一个整体。</li></ul><p>2.5最终达到root时，return。</p><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>具体实现类似HashMap，弱引用可以访问对象，但这不是有效引用，即被引用的对象可以被GC回收。<br>WeakHashMap内部通过弱引用管理entry。<br>想要获取HashSet，需要使用：<br><code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>，其可以将任意map转化为set。</p><h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><ul><li>基于泛型原理，<strong>绝大多数集合都是可以添加Null值</strong>的。</li><li><strong>PriorityQueue，TreeSet，TreeMap只允许添加一次Null值</strong>，第二次添加Null值会报错，因为其需要实现<code>compare</code>方法做比较。</li><li><strong>ArrayDeque不能传入null值</strong>，而LinkedList可以，这是因为ArrayDeque在实现时添加元素前会对元素做非空判断。</li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><table><thead><tr><th>不安全</th><th>安全实现</th><th>ConCurrent</th></tr></thead><tbody><tr><td>ArrayList</td><td>Vector&#x2F;Stack</td><td>暂无</td></tr><tr><td>LinkedList</td><td>Collections.synchronizedList(List)</td><td>暂无</td></tr><tr><td>PriorityQueue</td><td>无</td><td>暂无</td></tr><tr><td>HashMap</td><td>Hashtable</td><td>暂无</td></tr><tr><td>LinkedHashMap</td><td>Collections.synchronizedMap(Map)</td><td>暂无</td></tr><tr><td>TreeMap</td><td>Collections.synchronizedSortedMap(SortedMap);</td><td>暂无</td></tr><tr><td>NavigableMap</td><td>Collections.synchronizedNavigableMap(NavigableMap)</td><td>暂无</td></tr></tbody></table><p>Set的Collections包装方法类似map。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第4章（注解、异常、反射）</title>
    <link href="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/"/>
    <url>/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li><strong>生成文档</strong>，通过代码里标识的元数据生成javadoc文档。</li><li><strong>编译检查</strong>，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li><strong>编译时动态处理</strong>，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li><strong>运行时动态处理</strong>，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是注解的注解，一般用于标识注解的属性</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>描述注解的使用范围，即可以在哪些对象上使用注解（常见的有TYPE,FILED,METHOD）等等。</p><h3 id="Retention-amp-RetentionTarget"><a href="#Retention-amp-RetentionTarget" class="headerlink" title="@Retention &amp; @RetentionTarget"></a>@Retention &amp; @RetentionTarget</h3><p>描述注解的保留时间（注意这里是指被保留到什么时候）有（SOURCE,CLASS,RUNTIME）三种策略。</p><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p>被其修饰的注解在标记在 其他对象上后，使用 javadoc 工具为类生成帮助文档时<strong>会保留其注解信息</strong>。</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>被其修饰的注解是否有继承性，如某类使用注解A，其子类也会继承注解A</p><h3 id="Reaptable"><a href="#Reaptable" class="headerlink" title="@Reaptable"></a>@Reaptable</h3><p>描述注解是否可以重复使用，即在一个对象上多次标注（但使用不同的参数）</p><h3 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h3><p>被其修饰的<strong>成员变量</strong>可以被本地方法引用，使用较少。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：<strong>编译检查</strong>，会检查是否按规范重写了父类方法。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：表示这个对象已经过时。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;<br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭编译器警告,可传入<code>String[]</code>著名需要抑制的警告类型。</p><div class="note note-primary">            <p>元注解与内置注解：<br>目持文继重原，重过抑。</p>          </div><h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><p>如何获取注解信息？<br>通过反射即可获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; T <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span><br><br>Annotation[] getAnnotations()<br></code></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyMethodAnnotation &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">title</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><h3 id="JDK8新注解"><a href="#JDK8新注解" class="headerlink" title="JDK8新注解"></a>JDK8新注解</h3><ul><li>@Repeatable</li><li>新的Target参数<code>ElementType.TYPE_PARAMETER</code>，包括type和parameter。</li></ul><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p><strong>注解之间无法继承</strong>，但编译后统一继承<code>java.lang.annotation.Annotation</code></p><h3 id="注解实现原理"><a href="#注解实现原理" class="headerlink" title="注解实现原理"></a>注解实现原理</h3><ul><li>注解是一个继承自Annotation的接口，里面每一个属性其实是一个接口的抽象方法。</li><li>使用注解时，会创建一个注解实例对象，该对象是通过jdk动态代理生成的（在<code>AnnotationInvocationHandler()</code>方法中就封装了代理的逻辑）</li></ul><h3 id="注解应用场景"><a href="#注解应用场景" class="headerlink" title="注解应用场景"></a>注解应用场景</h3><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架从配置化 -&gt; 注解化</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP实现统一日志管理，实现模块的解偶。<br>具体就是以@Log为切点，然后对方法进行增强。</p><h1 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h1><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109184839.png"></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error是JVM无法处理的错误。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Exception是可以被捕获，处理的异常。分为两类：运行时异常和编译时异常。</p><ul><li>运行时异常（不会检查的）：NullPointerException,IndexOutOfBoundsException。</li><li>非运行时异常（必须处理的）：IOException、SQLException。</li></ul><h3 id="可检查异常和不可检查异常"><a href="#可检查异常和不可检查异常" class="headerlink" title="可检查异常和不可检查异常"></a>可检查异常和不可检查异常</h3><p>除了Error，RuntimeException及其子类，其他都是可检查异常，需要在编写程序时对其进行解决。</p><h3 id="异常使用"><a href="#异常使用" class="headerlink" title="异常使用"></a>异常使用</h3><ul><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。如果try,catch中有return或throw，会先执行完finally再回去执行返回行为（return&#x2F;throw），如果finally中有返回行为，则不会再回去执行。finally可以脱离catch使用。</li><li><strong>throw</strong> – 用于<strong>抛出</strong>异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法<strong>可能抛出</strong>的异常。</li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>必须声明方法可抛出的任何可查异常（checked exception）。</p><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时会在catch中抛出另一个异常，主要是为了封闭异常细节。</p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>继承Exception即可，习惯上要定义无参和具有描述信息的构造函数。</p><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>JAVA7中引入，会自动关闭资源。需要该资源实现了AutoCloseable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br><span class="hljs-comment">// code</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br><span class="hljs-comment">// handle exception</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>JVM处理异常的机制涉及Exception Table，以下称为异常表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatch</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: goto          <span class="hljs-number">11</span><br>       <span class="hljs-number">6</span>: astore_0<br>       <span class="hljs-number">7</span>: aload_0<br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><p>异常表按<strong>catch顺序</strong>记录的异常捕获信息，包括：</p><ul><li><strong>from</strong> 可能发生异常的起始点</li><li><strong>to</strong> 可能发生异常的结束点</li><li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li><li><strong>type</strong> 异常处理者处理的异常的类信息</li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatchFinally</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">11</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">14</span>: astore_0<br>      <span class="hljs-number">15</span>: aload_0<br>      <span class="hljs-number">16</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">19</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">22</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">27</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">30</span>: astore_1<br>      <span class="hljs-number">31</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">34</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">36</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">39</span>: aload_1<br>      <span class="hljs-number">40</span>: athrow<br>      <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">14</span>   Class java/lang/Exception<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">30</span>   any<br>          <span class="hljs-number">14</span>    <span class="hljs-number">19</span>    <span class="hljs-number">30</span>   any<br></code></pre></td></tr></table></figure><p>一个finally会产生两个捕获表条目，表示try或catch中发送任何异常其都可以捕获并跳转到30执行。<br>如果方法有返回值，为了保证finally执行，会在编译时将finally中内容编译在return语句前。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Class类也是一个类，不同的类都有一个Class类的实体存在于堆中。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191903.png"><br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191923.png"></p><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><h4 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h4><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li><li>类加载器：xxxClassLoader.loadClass(全限定类名)</li></ul><div class="note note-primary">            <p>其中，通过类名.class，类加载器.loadClass获取class对象，不会进行类加载的初始化，此时静态代码块和静态对象不会执行。</p>          </div><h4 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h4><p>可以通过class对象获取该类的构造器。</p><ul><li>getConstructors() 获取所有public构造器</li><li>getDeclaredConstructors() 获取所有声明的构造器<br>以上两个方法不构成覆盖关系，getDeclaredConstructors能获取私有构造器，却无法获取继承到的public构造器。</li></ul><div class="note note-primary">            <p>Field&#x2F;Method的获取中的declared也类似。</p>          </div><h4 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h4><p><code>method.invoke(Object obj, Object... args)</code><br>可以使用arg作为参数，执行obj的method方法</p><h2 id="深入反射"><a href="#深入反射" class="headerlink" title="深入反射"></a>深入反射</h2><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109192732.png"></p><div class="note note-primary">            <p>获取类对象时，只会对类进行加载、链接。<br>只有通过<strong>forName获取类对象</strong>或<strong>创建该类的对象</strong>或<strong>使用该类的静态变量</strong>时才会进行初始化，详情见JVM。</p>          </div><blockquote><p>这里做一下区分，有具体实现的是java程序，没有具体实现的我们认为是交给JVM的(native)。</p></blockquote><ul><li>类加载<ul><li>forName会加载类，其会调用本地方法加载类（交给JVM）</li><li>JVM回调类加载其对类进行加载</li></ul></li><li>实例生成<ul><li>查找构造器，若没有则从JVM获取，有则直接从缓存中取出。缓存的结构名为ReflectionData，Class对象对该缓存使用了软引用，通过reflection()方法获取缓存。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>反射也是考虑了线程安全的，放心使用；</li><li><strong>反射使用软引用relectionData缓存class信息</strong>，避免每次重新从jvm获取带来的开销；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证<strong>数据隔离；</strong></li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ul><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>SPI（Service Provider Interface）服务发现机制，主要用于框架开发。核心思想就是解偶。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109194225.png"><br>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。<br>当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><p>例子：<br>java定义了java.sql.Driver接口。<br>mysql提供了mysql-connector-java-6.0.6.jar，其META-INF&#x2F;services下有文件<code>java.sql.Driver</code>，其内容为<code>com.mysql.cj.jdbc.Driver</code>，表示使用<code>com.mysql.cj.jdbc.Driver</code>实现<code>java.sql.Driver</code>。</p><h3 id="SPI和API区别"><a href="#SPI和API区别" class="headerlink" title="SPI和API区别"></a>SPI和API区别</h3><ul><li>SPI - “接口”位于“调用方”所在的“包”中，由外部实现该接口。</li><li>API - “接口”位于“实现方”所在的“包”中，服务自身实现该接口。</li></ul><h3 id="SPI缺点"><a href="#SPI缺点" class="headerlink" title="SPI缺点"></a>SPI缺点</h3><ul><li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第3章（泛型）</title>
    <link href="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/"/>
    <url>/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><h2 id="泛型的功能"><a href="#泛型的功能" class="headerlink" title="泛型的功能"></a>泛型的功能</h2><p>代码复用，使用一个代码流程适配多个类型。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class="hljs-keyword">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h2><p>使用泛型时，我们可以具体制定此时需要适配的类型，然后<strong>编译器</strong>会根据此进行类型检查，约束编码。</p><h1 id="二、泛型的基本使用"><a href="#二、泛型的基本使用" class="headerlink" title="二、泛型的基本使用"></a>二、泛型的基本使用</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>创建该类的对象的时候可以制定泛型的具体类型，其方法也会适配。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&lt;T&gt;&#123;         <span class="hljs-comment">// 此处可以随便写标识符号，T是type的简称  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;     <span class="hljs-comment">// var的类型由T指定，即：由外部指定  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 返回值的类型由外部决定  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <span class="hljs-comment">// 设置的类型也由外部决定  </span><br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsDemo01</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;  <br>        Point&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>&lt;String&gt;() ;     <span class="hljs-comment">// 里面的var类型为String类型  </span><br>        p.setVar(<span class="hljs-string">&quot;it&quot;</span>) ;                            <span class="hljs-comment">// 设置字符串  </span><br>        System.out.println(p.getVar().length()) ;   <span class="hljs-comment">// 取得字符串的长度  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用多元泛型&lt;A,B&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.value = value ;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>不要惧怕<code>&lt;&gt;</code>，其就是一个用来传参的窗口，类似与方法中在<code>()</code>写入多个参数，泛型则是在<strong>类&#x2F;接口的创建</strong>或<strong>方法的使用</strong>时，传入类型的参数<code>&lt;type1,type2&gt;</code>，从而令类型、方法等具体化。</p>          </div><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>可见定义接口和定义类类似，在实现该接口时，也应该使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;        <span class="hljs-comment">// 在接口上定义泛型  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> ; <span class="hljs-comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;   <span class="hljs-comment">// 定义泛型接口的子类  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;             <span class="hljs-comment">// 定义属性  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InfoImpl</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;     <span class="hljs-comment">// 通过构造方法设置属性内容  </span><br>        <span class="hljs-built_in">this</span>.setVar(<span class="hljs-keyword">var</span>) ;    <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个非泛型类里面也可以有泛型方法，泛型方法的目的也是可以对一个泛型方法传入多种类型的参数，而不需要new很多泛型类来实现。<br>同时，泛型方法就是为了适配不同类型的参数，所以一般在声明方法时，型参的类型也是一个泛型类，如下面的<code>Class&lt;T&gt;</code>。</p><p>此时泛型的类别应该在调用该方法时，通过参数？或其他方式，指明类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getObject</span><span class="hljs-params">(Class&lt;T&gt; c)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> c.newInstance();<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-type">Clazz</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clazz</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz1.getObject(Class.forName(<span class="hljs-string">&quot;com.cnblogs.test.User&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>泛型方法需要在修饰符后面加上<code>&lt;T&gt;</code>来标识这是一个泛型方法。</li><li>泛型方法需要使用泛型类型的型参来，使用时传入具体的泛型类型来适配。</li></ul><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>普通方法使用泛型，该方法不属于泛型方法，参数是泛型类，且已经制定了具体的泛型类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;Integer&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h2><p>泛型有一个问题，即</p><ul><li>Even <code>A extends B</code> but <code>List&lt;A&gt;  not extends List&lt;B&gt;</code><br>假如，现在有一个普通方法，参数是一个泛型类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;B&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>如果传入一个<code>List&lt;A&gt;</code>则会出现报错。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用上下边界机制解决,如：</p><h4 id="泛型方法-1"><a href="#泛型方法-1" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;? extends B&gt; list)</span>&#123;&#125;;<br><span class="hljs-comment">//下限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Info&lt;? <span class="hljs-built_in">super</span> String&gt; temp)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="泛型类-1"><a href="#泛型类-1" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;&#123;    <span class="hljs-comment">// 此处泛型只能是数字类型</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;        <span class="hljs-comment">// 定义泛型变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 直接打印</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span>.toString() ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>泛型上下限使用上下限 限制了 泛型的<strong>具体类型</strong>，此时注意<code>？</code>才是真正的泛型类型。<br>具体使用时，</p><ul><li>如果该 类&#x2F;方法 是对 界限类型T的生产者，则使用<code>&lt;? extends T&gt;</code>，即在类&#x2F;方法中有类似T t &#x3D; new B(实际传入的类型)，这类<strong>生产T</strong>的操作。即可以创造一个<code>List&lt;? extends Fruit&gt;</code>，然后我们可以通过getNode()，来确保我们能获取一个Fruit。</li><li>如果该 类&#x2F;方法 是对 界限类型T的消费者，则使用<code>&lt;? super T&gt;</code>，即在类&#x2F;方法中有类似 addNode(T t)，这类<strong>消费T</strong>的操作。一般用于泛型类当中，即可以创造一个<code>List&lt;? super Apple&gt;</code>，这样就知道往这个集合里add Apple或其子类肯定是可行的，因为Apple及其子类肯定也是<code>？</code>具体类型的子类。</li></ul><p>所以，上限确保我们可以得到一个具体类型<strong>T</strong>的引用（生产，将其作为返回值获取），下限确保我们可以往类型&#x2F;方法中消耗<strong>T</strong>(消费，将其作为参数传入)。</p>          </div><div class="note note-primary">            <ul><li>在具体的泛型类&#x2F;泛型方法的<strong>声明</strong>中，一般使用<code>T</code>或<code>T extends Clazz</code>声明泛型，然后使用<strong>T</strong>进行操作。</li><li>在具体的普通引用&#x2F;普通方法的参数<strong>声明</strong>中，一般使用<code>List&lt;?&gt;</code>或<code>List&lt;? extends Clazz&gt;</code>，对传入的泛型对象的具体类型的限制。</li></ul>          </div><h4 id="多限制"><a href="#多限制" class="headerlink" title="多限制"></a>多限制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Staff</span> &amp; Passenger&gt;<br></code></pre></td></tr></table></figure><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;<span class="hljs-keyword">String</span>&gt;[] list13 = (List&lt;<span class="hljs-keyword">String</span>&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告 </span><br>List&lt;?&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;?&gt;[] list15 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK</span><br></code></pre></td></tr></table></figure><p>泛型的语义包含类型检查的功能，如果创建<strong>具体泛型类</strong>的数组，会导致无法实现对泛型类的检查。</p><h1 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h1><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure）。</p><div class="note note-primary">            <p>回到本质，java泛型本质是为了复用代码，泛型则用于在编码时限制，编译时会对其进行擦除。</p>          </div><p>具体操作：</p><ul><li>T和？和? super Clazz都替换为Object<br><img src="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011238.png"></li><li>T extends Clazz&#x2F;? extends Clazz替换为Clazz<br><img src="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011241.png"></li></ul><h3 id="泛型方法-2"><a href="#泛型方法-2" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span><br></code></pre></td></tr></table></figure><ul><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float </span><br></code></pre></td></tr></table></figure><h3 id="编译期检查"><a href="#编译期检查" class="headerlink" title="编译期检查"></a>编译期检查</h3><p>Java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，再进行编译。</p><p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过</span><br></code></pre></td></tr></table></figure><h3 id="泛型多态"><a href="#泛型多态" class="headerlink" title="泛型多态"></a>泛型多态</h3><p>类型擦除会导致多态冲突，如继承一个具体泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Date&gt; &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>        <span class="hljs-built_in">super</span>.setValue(value);  <br>    &#125;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如我们希望通过继承<strong>具体泛型</strong>来重写具有<strong>具体参数</strong>和<strong>具体返回值</strong>的方法，但父类由于类型擦除，参数会变成Object。导致与重写发生定义冲突。</p><p>此时，JVM会使用桥方法解决问题，以下为字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.tao.test.DateInter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  <br>  com.tao.test.DateInter();  <br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.util.Date)</span>;  <span class="hljs-comment">//我们重写的setValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: invokespecial #<span class="hljs-number">16</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br>       <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> java.util.Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//我们重写的getValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">23</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br>       <span class="hljs-number">4</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">7</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> java.lang.Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;     <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokevirtual #<span class="hljs-number">28</span>                 <span class="hljs-comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br>       <span class="hljs-number">4</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.lang.Object)</span>;   <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">30</span>                 <span class="hljs-comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>编译器通过生成桥方法（Object作为参数和返回值等），实现对父类方法的重写，然后在其中调用我们真正重写的方法。<br>另外，桥方法getValue()看似和我们重写的getValue()冲突，但实际上JVM允许自己通过参数类型和返回类型共同确定一个方法。</p><h3 id="基本类型不能作为泛型类型"><a href="#基本类型不能作为泛型类型" class="headerlink" title="基本类型不能作为泛型类型"></a>基本类型不能作为泛型类型</h3><p>ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><h3 id="泛型类型不能实例化"><a href="#泛型类型不能实例化" class="headerlink" title="泛型类型不能实例化"></a>泛型类型不能实例化</h3><p>编译期找不到对应的类字节码文件，无法确认具体泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(); <span class="hljs-comment">// ERROR</span><br><br><span class="hljs-comment">//解决，利用反射</span><br><span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">newTclass</span> <span class="hljs-params">(Class &lt; T &gt; clazz)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型数组不能初始化"><a href="#泛型数组不能初始化" class="headerlink" title="泛型数组不能初始化"></a>泛型数组不能初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// Error，Class</span><br><br><span class="hljs-comment">//如果对lsa进行强转Object[]，就可以对其添加其他list，导致Class错误，因此要避免这样的情况发生：</span><br><br>List&lt;?&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// OK, array of unbounded wildcard type.</span><br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (Integer) lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">//因为使用？来创建类型，所以array本身的定位就是可以放入不同的list，最后取出时强转，符合逻辑</span><br></code></pre></td></tr></table></figure><h3 id="PS数组类型"><a href="#PS数组类型" class="headerlink" title="PS数组类型"></a>PS数组类型</h3><p><strong>数组类可以分类可以分成两类：</strong></p><ul><li>基本类型的数组类；</li><li>引用类型的数组类；</li></ul><p>基本类型的数组类的父类是Object，即<code>int[]</code>可以强转<code>Object</code><br>引用类型的数组类的父类有<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>，即如果A extends B，A可以强转<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>。</p><h3 id="泛型数组如何正确初始化"><a href="#泛型数组如何正确初始化" class="headerlink" title="泛型数组如何正确初始化"></a>泛型数组如何正确初始化</h3><p>最好使用列表集合对其替换。或者通过反射建立，因为反射时，类型已经被确认。</p><h3 id="如何理解泛型类中的静态方法和静态变量"><a href="#如何理解泛型类中的静态方法和静态变量" class="headerlink" title="如何理解泛型类中的静态方法和静态变量"></a>如何理解泛型类中的静态方法和静态变量</h3><p>泛型类中的静态方法和静态变量<strong>不可以</strong>使用泛型类所声明的泛型类型参数，显然当静态变量建立时，具体类型还未确认。</p><h3 id="如何理解异常中使用泛型"><a href="#如何理解异常中使用泛型" class="headerlink" title="如何理解异常中使用泛型"></a>如何理解异常中使用泛型</h3><ul><li>不能<strong>捕获</strong>泛型类型的异常。（编译器禁止）<ul><li>由于类型抹去，捕获泛型类型会失效，也可能导致多个catch句子中的父子类顺序混淆</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(Class&lt;T&gt; t)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(T e) &#123; <span class="hljs-comment">//编译错误</span><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123; <span class="hljs-comment">//Integer会抹去，无法捕获</span><br>    ...<br>    &#125; <span class="hljs-keyword">catch</span>(IndexOutOfBounds e) &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但可以在方法声明中使用泛型并抛出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> T &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Throwable realCause) &#123;<br>        t.initCause(realCause);<br>        <span class="hljs-keyword">throw</span> t; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>由于泛型本质上是为了简化类型转换问题和约束编程，在编译时会进行类型抹去。而catch操作是一个运行时发生的事件，<strong>需要catch具体的类型</strong>，其抹去类型后，与catch的捕获异常的<strong>范围和先后顺序</strong>产生矛盾。<br>但通过限制泛型异常上界，并<strong>捕获其上界</strong>，对其进行抛出是可行的。</p>          </div><h3 id="如何获取泛型参数"><a href="#如何获取泛型参数" class="headerlink" title="如何获取泛型参数"></a>如何获取泛型参数</h3><p><strong>Type</strong>是Java所有类型实现的<strong>公共接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericType&lt;String&gt; genericType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;<br><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> genericType.getClass().getGenericSuperclass();<br><span class="hljs-comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> ((ParameterizedType)superclass).getActualTypeArguments()[<span class="hljs-number">0</span>]; <br>System.out.println(type);<span class="hljs-comment">//class java.lang.String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第2章（知识点）</title>
    <link href="/2023/01/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/"/>
    <url>/2023/01/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型有<br>boolean(1),byte(8),char(16),short(16);<br>int(32),long(64),float(32),double(64);</p><p>括号表示类型占的bit数，其中，char,byte,short不会互相转换，其计算时首先转换为int。</p><div class="note note-primary">            <p>java分内码和外码，内码指运行时内存中编码方式。除了内码的都是外码（如class文件，序列化等）。</p><ul><li>boolean：实际上JVM规范将boolean当作int来处理，也就是都占用4个字节。true为1，false为0。</li><li>char：内码中使用UTF16编码，一个字符占2个或4个字节(相当于用两个char表示一个字符)。外码中char使用UTF8编码，一个字符占1-6个字节。</li></ul>          </div><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="String-x2F-Integer-x2F-int"><a href="#String-x2F-Integer-x2F-int" class="headerlink" title="String&#x2F;Integer&#x2F;int"></a>String&#x2F;Integer&#x2F;int</h3><p>基本类型之间，char,byte,short可以转化为int,int-&gt;long-&gt;float-&gt;double可以链式转换，反向转换需要强制类型转换，可能造成数据精度损失。</p><p>String与Integer互相转化：</p><ul><li>String.valueOf(Integer)</li><li>Integer.valueOf(String)</li></ul><p>String与int互相转化：</p><ul><li>String.valueOf(int) &#x2F; int + “”</li><li>Integer.parseInt(“int”)</li></ul><p>Integer与int互相转化：</p><ul><li>Integer.valueOf()</li><li>integer.intValue()</li></ul><div class="note note-primary">            <p>可见，对于具体类（String,Integer）,valueOf是一个将其他类型转化为本类型的通用方法。涉及到其他类型转化为基本类型时，需要使用<code>Integer.parseInt(string)</code>和<code>integer.intValue()</code>这种特殊方法。</p>          </div><h3 id="隐式类型"><a href="#隐式类型" class="headerlink" title="隐式类型"></a>隐式类型</h3><h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>1.1字面量是double类型的。<br><code>float f = 1.1f</code></p><h4 id="short"><a href="#short" class="headerlink" title="short"></a>short</h4><p>1字面量是int类型的<br><code>short s1 = 1</code>不可行，而<code>+=</code>可以实现隐式转换<br><code>s1 += 1</code>;<br>相当于s1 &#x3D; (short)(s1 + 1)</p><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li><li>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</li></ul><p><strong>自动装箱</strong>的过程，默认调用的是<strong>valueOf</strong>,因此会先判断对象是否在缓存池。</p><blockquote><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul></blockquote><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 被声明为 final，因此它不可被继承。其内部使用一个final的char数组存储字符。</p><blockquote><p>JDK9时改为<code>byte[]</code>，因为一个char为2或4字节（UTF16），但大多数情况下char只需要1字节标识，所以使用Latin-1字符集表示即可。当遇到无法表示的字符时，String在转化字符集。</p></blockquote><h3 id="不可变的原因"><a href="#不可变的原因" class="headerlink" title="不可变的原因"></a>不可变的原因</h3><ul><li>String常作为hashKey，不可变时，每个String对象只需要计算一次hash；</li><li>StringPool，不可变才可重复利用；</li><li>安全性，其常作为网络连接参数，不可变保证其正常运行。</li><li>String天生线程安全。</li></ul><h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><ul><li>String不可变，StringBuffer和StringBuilder可变</li><li>String线程安全，StringBuilder线程不安全，<strong>StringBuffer线程安全</strong>，内部synchronized进行同步。</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><ul><li>String s1 &#x3D; new String(“aaa”)不会将对象放入线程池</li><li>String s2 &#x3D; “bbb”会自动将对象放入线程池</li><li>String s3 &#x3D; s1.intern()会将s1放入线程池<br>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>HotSpot字符串常量池放在哪里？</p><ul><li>JVM虚拟机规范中：规定<strong>运行时常量池</strong>在方法区（<strong>方法区只是一个逻辑概念</strong>）内。</li><li>方法区在不同的虚拟机中有不同的实现，HotSpot才有永久代的概念。但随着时间发展，HotSpot也放弃了永久代的概念。</li></ul><table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table><div class="note note-primary">            <ul><li>1.6前，方法区由永久代（ALL）实现。</li><li>1.7时，方法区由永久代（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量）共同实现。</li><li>1.8时，方法区由元空间（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量static）共同实现。</li></ul>          </div><h1 id="二、运算"><a href="#二、运算" class="headerlink" title="二、运算"></a>二、运算</h1><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>减去一个正数 &#x3D; 加上一个负数 &#x3D; 加上一个进位值再减去该数的绝对值 &#x3D; 对原正数求补码并加一（这与我们对负数的补码的定义是相同的）</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="Mod与"><a href="#Mod与" class="headerlink" title="Mod与%"></a>Mod与%</h3><h4 id="求余"><a href="#求余" class="headerlink" title="%求余"></a>%求余</h4><p>a % b &#x3D; c…<code>d</code><br>余数的正负取决于被除数，顾名思义，求余，是指被除数 除以 除数 之后<strong>剩下</strong>的值（求余时，得到的c是<strong>向0取整</strong>的），因此肯定余被除数的符号相同。<br>eg:<br>9%4 &#x3D; 2…<code>1</code><br>9%-4 &#x3D; -2…<code>1</code><br>-9%4 &#x3D; -2…<code>-1</code><br>-9%-4 &#x3D; -2…<code>-1</code></p><h4 id="mod取模"><a href="#mod取模" class="headerlink" title="mod取模"></a>mod取模</h4><p>a mod b &#x3D; c…<code>d</code><br>mod时，结果与除数相同，（得到的c是<strong>向下取整</strong>的）<br>eg:<br>9mod4 &#x3D; 2…<code>1</code><br>9mod-4 &#x3D; -3…<code>-3</code><br>-9mod4 &#x3D; -3…<code>3</code><br>-9mod-4 &#x3D; 2…<code>-1</code></p><div class="note note-primary">            <p>java中%表示求余，但python中%表示求模。且java中的取模操作为<code>Math.floorMod(a,b)</code></p>          </div><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><div class="note note-primary">            <p>所有位运算都是针对补码而言的</p>          </div><h4 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h4><p>相当于 <code>*2</code></p><h4 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移&gt;&gt;"></a>右移&gt;&gt;</h4><p>相当于 <code>/2</code>,向下取整eg:<code>5&gt;&gt;1 = 2</code>,<code>-5&gt;&gt;1 = -3</code><br>(负数的高位补1)</p><h4 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h4><ul><li>对于正数相当于<code>/2</code>，向下取整。</li><li>对于负数，结果需要具体计算(负数的高位补0)</li></ul><h4 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h4><p>~n &#x3D; -(n+1)<br>eg:</p><ul><li>正数：<br>~ 3 &#x3D; -(3+1) &#x3D; -4<br>~0011 &#x3D; -(0011+0001) &#x3D; -0100 &#x3D; 1100</li><li>负数：<br>~ (-3) &#x3D; -(-3+1) &#x3D; 2<br>~1101 &#x3D; -(1101+0001) &#x3D; -1110 &#x3D; 0010</li></ul><div class="note note-primary">            <p>由上可见，在二进制上，取反相当于把1置0，把0置1。<br>在具体值上，我们是对原值的补码进行求反，得到的是答案的补码。<br>如果是正数，符号变负，且绝对值+1。<br>如果是负数，符号变正，且绝对值-1。<br>注意到这个过程是可以相互抵消的，即<del>(</del>n) &#x3D; n，从二进制角度来看，也很符合常理。</p><p>如何求-n的补码：<br>~n+1 &#x3D; -(n+1)+1 &#x3D; -n</p>          </div><div class="note note-success">            <p>取反可以理解成以-0.5为轴旋转！</p>          </div><h4 id="自增"><a href="#自增" class="headerlink" title="自增++"></a>自增++</h4><p>自增++线程不安全<br>i++：先将变量从局部变量表拷贝到操作数栈顶，再对局部变量表中变量执行自增。<br>++i：先对局部变量表中变量执行自增，再将变量从局部变量表拷贝到操作数栈顶。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>java只有值传递，对于对象，传递的是对象的引用指针。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch条件判断语句中可以使用<br>byte,short,char,int,枚举(jdk5.0)，String对象(jdk7.0)，但不能使用long类。<br><strong>PS</strong>：</p><ul><li>实际上能string对象也只是一个语法糖，底层通过string对象的hash值处理。</li><li>对枚举类使用switch，case后面枚举类必须使用非限定名，即不用再带上枚举类名。</li></ul><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>若满足了某一个case，且该case中没有使用break，则后续的所有case内语句都会被执行，直到遇到break或return</p><div class="note note-primary">            <p>本质就是指能处理int相关的类型和枚举，对String提供了额外支持。</p>          </div><h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h3 id="Java-中的编译期常量是什么-使用它有什么风险"><a href="#Java-中的编译期常量是什么-使用它有什么风险" class="headerlink" title="Java 中的编译期常量是什么? 使用它有什么风险?"></a>Java 中的编译期常量是什么? 使用它有什么风险?</h3><p>这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。<br>这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h3 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别?"></a>Java 中，Serializable 与 Externalizable 的区别?</h3><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。<br>Externalizable 接口要求重写 writeExternal 和 readExternal 方法，允许手动控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>声明为static和transient类型的数据不能被序列化，反序列化需要一个无参构造函数。<br>transient的内存语义就是其只存在于内存而不会被写入磁盘，可以将一些不希望被序列化的字段加上该关键字。</p><blockquote><p>当使用Externalizable手动实现序列化时不受该限制。</p></blockquote><h3 id="Object有哪些公用方法"><a href="#Object有哪些公用方法" class="headerlink" title="Object有哪些公用方法?"></a>Object有哪些公用方法?</h3><p>clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。</p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>继承角度：</p><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li></ul><p>构造角度：</p><ul><li>抽象类可以有构造方法, 接口没有构造方法</li></ul><p>成员变量角度：</p><ul><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能<strong>public static final</strong>(默认)</li></ul><p>成员方法角度：</p><ul><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default和static方法，在JDK9中允许有private方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li></ul><div class="note note-primary">            <p>注意，接口不能拥有成员变量，但可以拥有静态变量。<br>抽象类可以有具体方法（代码复用），但具体类不能有抽象方法。<br>抽象类可以有静态方法，接口在JDK8之前没有，JDK8之后有。<br>接口：JDK8前只有public abstract，JDK8允许default和static，JDK9允许private。</p>          </div><h3 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h3><ul><li>finally不管有没有异常都要处理</li><li><strong>当try和catch中有return时，finally仍然会执行，finally比return先执行</strong>，finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以<strong>函数返回值是在finally执行前确定</strong>的</li><li><strong>finally中最好不要包含return</strong>，这样返回值不是try或catch中保存的返回值，而是finally中的return值。</li></ul><p>finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电。</p><h3 id="局部变量为什么要手动初始化赋值"><a href="#局部变量为什么要手动初始化赋值" class="headerlink" title="局部变量为什么要手动初始化赋值"></a>局部变量为什么要手动初始化赋值</h3><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，<strong>如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销</strong>，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，<strong>解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第1章（面向对象）</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>属性和操作分离，即通过get,set方法操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，子类可以获得父类非 private的属性和方法。</p><div class="note note-primary">            <p>继承应该遵循<strong>里氏替换</strong>原则，子类对象必须能够替换掉所有父类对象。</p>          </div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>:</p><ul><li>编译时多态主要指方法的<strong>重载</strong></li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><blockquote><p>即子类要继承父类，覆盖父类的方法，并使用了父类的指针。</p></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191817.png"><br>即继承父类</p><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191831.png"><br>即实现接口</p><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191859.png"><br>弱依赖，整体不存在了部分也还是存在。</p><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191919.png"><br>强依赖，整体不存在了部分也不存在了。</p><h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192246.png"><br>1对1，1对n，n对1。</p><h3 id="依赖关系（Dependency）"><a href="#依赖关系（Dependency）" class="headerlink" title="依赖关系（Dependency）"></a>依赖关系（Dependency）</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192243.png"><br>A是B类的局部变量、参数，或A向B发送信息。</p><h2 id="面向对象的规则"><a href="#面向对象的规则" class="headerlink" title="面向对象的规则"></a>面向对象的规则</h2><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>Java 中有三个访问权限修饰符（四个访问权限等级）: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>对<strong>类</strong>或类中的成员(<strong>字段</strong>以及<strong>方法</strong>)加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>对于<strong>类</strong>：只有public和defualt修饰符<br>对于<strong>成员</strong>：4种访问等级都有，protected表示<strong>本包和子类</strong>可见</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>1.修饰数据<br>表示数据为不可改变，其只针对编译期检查，运行时会抹去。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变。</li></ul><div class="note note-primary">            <p>final可以修饰局部变量，但在编译时会抹去。</p><ul><li>从虚拟机层面来说，局部变量声明final是没有意义的，生成的字节码根本不会记录。</li><li>从java语言层面来说是有意义的，如我们通过内部类访问外部对象需要通过final修饰，另外在做代码重构时，将对象临时修饰为final来判断对象的作用域以及是否变化等情况也是有意义的。</li><li>对于匿名内部类，若需要使用到局部变量，需要把局部变量标注为final，JVM会将所有的局部内部类对象要访问的final型局部变量，都拷贝成为该内部类对象中的一个数据成员。（JDK8后不用可以标注了，是一种语法糖）。</li></ul>          </div><p>2.修饰类<br>表示类不可继承</p><p>3.修饰方法<br>表示不可重写</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>1.静态变量<br>静态变量就是类变量<br>2.静态方法<br>类加载时就存在，必须实现，不可为抽象方法，也只能访问所属类的静态变量和静态方法<br>3.静态代码块<br>见代码块，类初始化时运行<br>4.静态内部类<br>不依赖外部实例的静态类（内部类本质上是一个单独的class文件）</p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>一个类至少有一个构造器，如果显式定义了构造器，系统默认的无参构造器会失效。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块分：</p><ul><li>普通代码块：类的方法体</li><li>构造代码块：即类中的{}</li><li>静态代码块：即类中的static {}</li></ul><div class="note note-primary">            <p>静态代码块是类加载时执行的，只会在第一次new时执行一次，是类的初始化<br>构造代码块是每新建一个实例都会执行一次，是对象的初始化</p>          </div><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>新建对象调用顺序：<br>静态代码块（只会调用一次）-&gt; 构造代码块 -&gt; 构造器</p><p>因此属性的赋值：</p><ul><li>静态初始化（静态赋值和静态代码块按照执行顺序）</li><li>默认初始化（0,false）</li><li>构造初始化（普通赋值和构造代码块按执行顺序）</li><li>构造函数</li></ul><div class="note note-primary">            <p>注意，构造初始化在构造函数前执行！</p>          </div><p>存在继承时：</p><ol><li>父类静态、子类静态</li><li>父类构造初始化、父类构造函数</li><li>子类构造初始化、子类构造函数</li></ol><div class="note note-primary">            <p>静态变量是可以不赋初值的，当其被声明时，会先赋予默认值，可以后续再赋予初值。</p>          </div><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类和抽象方法一定使用 abstract 关键字进行声明。<br>很容易理解：</p><ul><li>抽象类不能被实例化</li><li>抽象方法不能出现在非抽象类中</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口在Java 8之前是纯抽象类，在JAVA8之后其允许默认的方法实现。</p><ul><li>接口的成员，字段都默认（且必须）是Public的</li><li>接口的字段默认是static final的</li></ul><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p>抽象类是IS-A关系，接口是LIKE-A关系</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>接口：多重继承，主要用于表示实现类拥有具体方法。<br>抽象类：主要用于在相关类中共享代码。<br>优先使用接口</p><h4 id="super字段"><a href="#super字段" class="headerlink" title="super字段"></a>super字段</h4><ul><li>super()<br>父类的构造函数，如果子类使用必须放在子类构造函数的第一排</li></ul><h4 id="this字段"><a href="#this字段" class="headerlink" title="this字段"></a>this字段</h4><p>在方法中，this指方法所属对象（static方法里不能有this）<br>在构造函数中，this指正在初始化的对象</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写限制（里氏原则）：</p><ul><li>子类方法访问权限大于父类</li><li>子类方法返回值为父类返回值或其子类</li></ul><p>@Override会对以上限制进行检查。</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>同一个方法的参数：个数，类型，顺序至少一个不同</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类也都是独立的类，均有单独的class文件，但前面会有外部类的类名和$符<br>分类：</p><ul><li>成员内部类<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>局部内部类、匿名内部类</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>作为成员：</p><ul><li>成员内部类可以声明为private或protected，可以调用外部内的结构</li><li>如果是static的成员内部类，可以脱离父类实例存在，因此也只能使用父类静态成员。</li></ul><p>作为类：<br>可以声明为abstract被其他内部类继承，也可以声明为final禁止继承</p><div class="note note-primary">            <p>不存在静态的外部类，因为这没有意义，外部类的成员只要标注为static就能任意使用。<br>而内部类可以标注为静态，表示其可以脱离父实例而存在，因此若内部类需要再使用static成员，其类本身也必须为static，才可以任意使用。</p>          </div><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>即在方法中声明一个内部类，声明后在只能在方法体内使用。<br>（但可以在方法最后返回这个内部类实例，不过返回值应该设置为该内部类的父类或父接口，毕竟外部不认识该局部内部类）</p><p>其可以使用外部类的成员（包括私有的）、外部方法的局部变量，但必须是final修饰的</p><p>因为是一个局部的，短暂的类，所以其与局部变量类似，不存在修饰符，也不能为静态类或拥有静态成员。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类必须继承父类或实现接口，其只有一个对象，只能多态引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentClass</span>|ParentInterface()&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>局部内部类是主要用于在一个方法中，我们短暂的需要一个结构体来处理问题时使用；而如果我们明确只需要一个具体的函数，但不想为此创造一个新类，且这个函数已经有明确的父类或接口，我们则可以让局部内部类退化为匿名内部类实现这个方法即可。<br>同样，匿名内部类的方法也可以使用外部的变量，但外部的变量必须是final修饰的：<br>匿名内部类，之所以能够使用外部变量，是因为其底层将外部变量作为构造参数传入了匿名内部类，问题的核心在于，如果不声明外部变量为final，当外部变量变化时，匿名内部类无法感知这个变化，可能会导致数据的不一致问题。实际上，JDK8中我们不再需要显示的将外部变量声明为final，其实底层还是为我们加上了final（语法糖）。<br>不过回到final的知识点，读写final字段对于JVM而言，主要是在编译期起限制重排序的作用，详情见JUC。</p>          </div><div class="note note-primary">            <p>匿名内部类是lambda表达式的原型，因此也很好理解为声明lambda表达式只能使用final变量</p>          </div><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p><em>equals()</em><br>默认为比较对象是否等价，需要满足对称等性质。<br><code>==</code>则判断值（基本类型或指针）是否相等。 </p><p><em>hashCode()</em><br>默认：是一个native方法，返回int，使用的是对象的地址（引用地址）进行计算。<br>其可以被覆盖（String,Integer等都覆盖了这个方法）。对于两个对象，如果equals返回true,其hashCode()必须相等，因此覆盖equals时总是应该覆盖hashCode方法。</p><p><em>toString()</em><br>默认返回对象类型+@+16进制的hashCode()</p><p><em>clone()</em><br>clone()是一个native,protected方法</p><blockquote><p>因为clone修饰符为protected，其只对本包和其子类可见，对于自定义类1，2<br>在类1中调用类2的clone()，Object的默认clone只对类2可见，对类1不可见，所以要重写，一般重写为 return (T)super.clone()</p></blockquote><p>另外，一个类要使用clone()方法，必须先继承Cloneable接口，并重写clone()，且要抛出CloneNotSupportedException异常。</p><p>另外，克隆也有浅拷贝和深拷贝，native的clone()只能获得一个对象的<strong>浅拷贝</strong>，对象的属性（引用类型）仍相同。想要获得<strong>深拷贝</strong>，需要在重写中实现。</p><p>替代方案，clone()既复杂又危险，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> &#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[original.arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;<br>            arr[i] = original.arr[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>类的对象有限且确定时可以使用枚举。</p><ul><li>enum定义的枚举类默认继承了java.lang.Enum类。</li><li>枚举类的构造器只能使用 private 权限修饰符。</li><li>必须在枚举类的第一行声明枚举类对象</li></ul><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> <br>&#123; <br>    RED, GREEN, BLUE; <br>&#125;<br><span class="hljs-comment">//实际使用中，有一种获取静态变量的感觉</span><br>Color.RED<br><br><span class="hljs-comment">//通用方法和字段</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">1</span>), GREEN(<span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">2</span>), BLANK(<span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-number">3</span>), YELLO(<span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">4</span>);  <br>    <span class="hljs-comment">// 成员变量  </span><br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.index = index;  <br>    &#125;  <br>    <span class="hljs-comment">// 普通方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;  <br>            <span class="hljs-keyword">if</span> (c.getIndex() == index) &#123;  <br>                <span class="hljs-keyword">return</span> c.name;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;<br>get,set...<br>&#125;<br><br><span class="hljs-comment">//也可以声明抽象方法并在所有枚举中实现</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;红色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    GREEN&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;绿色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    BLUE&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;蓝色&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>枚举更像是在创建父类后，在父类中直接构造子类。</p></blockquote><p><em>枚举类swicth语句</em><br>使用<code>switch</code>语句时必须使用非限定名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Color</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Color.RED;<br><span class="hljs-keyword">switch</span>(c)&#123;<br><span class="hljs-comment">// case Color.RED 是错误的，必须直接使用RED</span><br><span class="hljs-keyword">case</span> RED:<br>System.out.println(<span class="hljs-string">&quot;RED&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>System.out.println(<span class="hljs-string">&quot;OTHER COLOR&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>指一个公共的，有无参公共构造器，有对应的set，get方法的，即一个标准的实体类。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>私有化构造器</strong>（外部不能new）</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>类自己持有自己的实例</strong>，通过static方法取得该实例，饿汉式表示会预加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>只有调用时才加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton single;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(single == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-type">return</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里省略了线程安全的部分。</p></blockquote><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>顾名思义，一个类A为另一个类做B代理，通过操作A来操作B<br>作用：</p><ul><li>屏蔽真实角色</li><li>增强功能，如添加权限，访问控制和申计</li><li>延迟加载</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>定义一个接口和实现类</li><li>定义一个代理类，实现该接口</li><li>将实现类注入代理类，实现代理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理类AdminServiceProxy与真实类AdminService继承相同的接口，即实现相同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdminService</span> &#123;<br><span class="hljs-comment">//以字段的形式持有真实对象</span><br>    <span class="hljs-keyword">private</span> AdminService adminService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceProxy</span><span class="hljs-params">(AdminService adminService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adminService = adminService;<br>    &#125;<br><span class="hljs-comment">//代理方法，可以在前后进行增强</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre&quot;</span>);<br>        adminService.update();<br>        System.out.println(<span class="hljs-string">&quot;post&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre1&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;pre2&quot;</span>);<br>        <span class="hljs-keyword">return</span> adminService.find();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态代理有<strong>适配器模式</strong>中对象适配器（聚合原类，继承接口）的影子，区别在于这里的原类也继承了该接口。静态代理编写代码时就明确了被代理类和方法。</p></blockquote><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>又名JDK动态代理，使用反射实现动态代理<br>优点：<strong>Proxy对象不需要实现接口，即不用实现接口所有的方法。</strong></p><ul><li>定义一个接口和一个实现类</li><li>定义一个服务类实现<code>InvocationHandler</code>接口，并重写invoke方法。</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>创建代理对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//reflect包中的静态方法，使用类加载器（不管）、接口列表（即生成的代理对象要实现哪些方法）、和事件处理器（代理对象在原目标上要做哪些加强）生成一个新的代理对象</span><br><span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler )</span>;<br><br><span class="hljs-comment">//事件处理器，主要用来写增强的内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceInvocation</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceInvocation</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理类，通过传入 增强器 和 代理目标，生成代理对象,后续可根据这个该代理类实体获取代理对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceDynamicProxy</span> extends &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-keyword">private</span> InvocationHandler invocationHandler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceDynamicProxy</span><span class="hljs-params">(Object target,InvocationHandler invocationHandler)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.invocationHandler = invocationHandler;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getPersonProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), invocationHandler);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>即通过反射的invoke方法，执行目标对象的目标方法。增强器会聚合被代理对象，但不需实现所有接口，invoke最终只会增强指定接口对应的方法。<br>被代理的对象类型没有被限定，因此可以复用增强器。</p></blockquote><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>优点：<strong>代理目标对象没有实现接口时可使用</strong>，其会实现一个子类，实现对target对象的代理，因此target类不能为final。</p><blockquote><p>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。（Cglib代理可能是为了弥补无接口的方法的代理问题而出现的。）</p></blockquote><ul><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object object, Method method, Object[] arg2, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-type">AliSmsService</span> <span class="hljs-variable">aliSmsService</span> <span class="hljs-operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br></code></pre></td></tr></table></figure><blockquote><p>这里的增强器没有聚合被代理类，只将其作为拦截方法参数。然后通过代理类工厂将增强器和被代理类聚合在一起生成新类。</p></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h4><ul><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ul><li><strong>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD建模语言圣经</title>
    <link href="/2023/01/06/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/DDD%E5%BB%BA%E6%A8%A1/DDD%E5%BB%BA%E6%A8%A1/"/>
    <url>/2023/01/06/%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0/DDD%E5%BB%BA%E6%A8%A1/DDD%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="DDD入门"><a href="#DDD入门" class="headerlink" title="DDD入门"></a>DDD入门</h1><h2 id="DDD介绍"><a href="#DDD介绍" class="headerlink" title="DDD介绍"></a>DDD介绍</h2><p><em>微服务拆分的困境</em><br>不知道业务或者微服务的<strong>边界</strong>在哪里？</p><p><em>DDD的核心思想</em><br>DDD核心思想是通过领域驱动设计方法定义领域模型，从而<strong>确定业务和应用边界</strong>，<strong>保证业务模型与代码模型的一致性</strong>。</p><p><em>DDD实现</em><br>DDD是一种<strong>架构设计方法</strong>，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易的实现架构演进。</p><p><em>DDD战略设计（设计阶段，关注系统划分与术语定义）</em><br><img src="/Pasted%20image%2020231031194055.png"></p><ol><li>在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素<strong>梳理出领域实体等领域对象</strong>。</li><li>根据领域实体之间的业务关联性，<strong>将业务紧密相关的实体进行组合形成聚合</strong>，确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。</li><li>根据业务及语义边界等因素，<strong>将一个或者多个聚合划定在一个限界上下文内，形成领域模型</strong>。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。</li></ol><p><em>DDD的战术设计（实施阶段，关注子系统的代码实现）</em><br>将领域模型中的领域对象与代码模型中的代码对象建立映射关系，将业务架构和系统架构进行绑定。当我们去响应业务变化调整业务架构和领域模型时，系统架构也会同时发生调整并同步建立新的映射关系。</p><p><em>DDD与微服务的关系</em><br>DDD 是一种<strong>架构设计方法</strong>，微服务是一种<strong>架构风格</strong>，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的<strong>演进式架构</strong>。</p><ul><li>DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。</li><li>微服务主要关注：运行时的进程间通信、容错和故障隔离实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。</li><li>DDD可以用于微服务设计，解决微服务设计过程中边界难以划定的难题。</li></ul><p><em>DDD大图</em><br><img src="/Pasted%20image%2020231031193011.png"></p><h2 id="DDD基础概念"><a href="#DDD基础概念" class="headerlink" title="DDD基础概念"></a>DDD基础概念</h2><p><img src="/Pasted%20image%2020231031193049.png"></p><h3 id="领域与子域"><a href="#领域与子域" class="headerlink" title="领域与子域"></a>领域与子域</h3><p><em>领域</em><br>DDD 的<strong>领域</strong>就是这个边界内要解决的业务问题域。<br><em>子域</em><br>领域可以进一步划分为子领域。我们把划分出来的多个子领域称为<strong>子域</strong>，每个子域对应一个<br>更小的问题域或更小的业务范围。</p><h3 id="核心域、通用域与支撑域"><a href="#核心域、通用域与支撑域" class="headerlink" title="核心域、通用域与支撑域"></a>核心域、通用域与支撑域</h3><p>在领域不断划分的过程中，领域会细划分为三类子域，它们分别是: 核心域、通用域和支撑域。<br>为不同的子域，子域可以根据自身重要性和功能属性。<br><em>核心域</em><br>决定产品和公司核心竞争力的子域，它是业务成功的主要因素和公司的核心竞争力。<br><em>通用域</em><br>同时被多个子域使用的通用功能子域。（如权限、认证系统）<br><em>支撑域</em><br>必需的子域，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能。（如数据字典等系统）</p><h3 id="通用语言与限界上下文"><a href="#通用语言与限界上下文" class="headerlink" title="通用语言与限界上下文"></a>通用语言与限界上下文</h3><p><em>通用语言与限界上下文的解释</em><br>通用语言定义上下文含义，限界上下文则定义领域边界，以确保每个上下文含义在它特定的边界内都具有唯一的含义，领域模型则存在于这个边界之内。<br><em>通用语言</em><br>在事件风暴过程中，通过团队交流达成共识的，<strong>能够简单、清晰、准确描述业务涵义和规则的语言</strong>就是通用语言。<br>通用语言包括术语和用例场景：</p><ul><li>通用语言中的名词可以给领域对象命名，对应实体对象</li><li>通用语言中的动词表示一个动作或事件，对应领域事件或命令</li></ul><p><img src="/Pasted%20image%2020231031193227.png"></p><blockquote><p>设计过程中我们可以用一些表格,来记录事件风暴和微服务设计过程中产生的领域对象及其属性。DDD 分析和设计过程中的每一个环节都需要保证限界上下文内术语的统一，在代码模型设计的时侯就要建立领域对象和代码对象的一一映射，从而保证业务模型和代码模型的一致，实现业务语言与代码语言的统一。</p></blockquote><p><em>限界上下文</em><br>通用语言也有它的上下文环境。为了避免同样的概念或语义在不同的上下文环境中产生歧义，DDD 在战略设计上提出了“限界上下文”这个概念，用来<strong>确定语义所在的领域边界</strong>（可以理解为业务的上下文环境）。<br><strong>领域边界就是通过限界上下文来定义的</strong>。</p><p><em>限界上下文与微服务</em><br>子域可能会包含多个限界上下文，也有可能子域本身的边界就是限界上下文边界，但每个领域模型都有它对应的限界上下文。理论上限界上下文就是微服务的边界，将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。</p><h3 id="实体与值对象"><a href="#实体与值对象" class="headerlink" title="实体与值对象"></a>实体与值对象</h3><p><em>实体</em><br>实体拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。</p><ul><li>业务形态：实体和值对象是组成领域模型的基础单元</li><li>代码形态：实体的表现为实体类，在 DDD 里，这些实体类通常采用充血模型，与这个实体相关的所有业务逻辑都在实体类的方法中实现，跨多个实体的领域逻辑则在领域服务中实现。</li><li>运行形态：实体以领域对象的形式存在，每个实体对象都有唯一的ID。</li><li>数据库形态：多数情况下实体与持久化对象是一对一，但复杂场景下可能出现一对多或多对一的场景。</li></ul><p><em>值对象</em><br>通过对象属性值来识别的对象，它<strong>将多个相关属性组合为一个概念整体</strong>。在 DDD 中用来描述领域的特定方面，并且是个没有标识符的对象，叫作值对象（如人员的地址，包括省市区街道等多个属性）。</p><ul><li>业务形态：值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。</li><li>代码形态：单一属性直接定义为实体类的属性，属性集合一般设计为Class类。</li><li>运行形态：值对象运行时嵌入到实体，主要有<strong>属性嵌入</strong>和<strong>序列化大对象</strong>嵌入两种方式：<ul><li>属性嵌入：提升数据库性能，但若值对象过多，会导致实体堆积一堆缺乏完整性的属性。</li><li>序列化大对象：简化数据库设计，但无法满足基于值对象的快速查询。</li></ul></li><li>数据库形态：根据值对象与实体对象的属性值是否保存在同一个数据库实体表分为两者方案。在同一个表中时破坏了业务涵义和概念完整性；不在同一个表则增加了不必要的实体和表，增加了数据库设计的复杂性。</li></ul><p><em>总结</em><br>DDD 提倡从领域模型设计出发，而不是先设计数据模型。<br>在领域建模时，我们可以将部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。</p><h3 id="聚合和聚合根"><a href="#聚合和聚合根" class="headerlink" title="聚合和聚合根"></a>聚合和聚合根</h3><p><em>聚合</em><br>领域模型内的实体和值对象就好比个体，而能<strong>让实体和值对象协同工作的组织就是聚合</strong>，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</p><blockquote><p>可以认为聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化</p></blockquote><p>聚合有一个聚合根和上下文边界，这个边界根据业务<strong>单一职责和高内聚原则</strong>，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。</p><p><em>聚合根</em><br>如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是<strong>实体</strong>，还是<strong>聚合的管理者</strong>，以及<strong>聚合对外的接口人</strong>。其以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。</p><p><em>聚合设计过程</em></p><ol><li>事件风暴，梳理实体和值对象</li><li>选择聚合根实体</li><li>根据单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值对象。</li><li>根据聚合根、实体、值对象的依赖关系，画出对象的引用和依赖模型。</li><li>多个聚合根据业务语义和上下文划分到一个限界上下文</li></ol><p><em>聚合设计原则</em></p><ol><li>在一致性边界内建模真正的不变条件</li><li>设计小聚合</li><li>通过唯一标识引用其他聚合</li><li>在边界之外使用最终一致性（聚合内数据强一致性）</li><li>通过应用层实现跨聚合的服务调用（便于未来以聚合为单位的微服务组合和拆分）</li><li>根据实际情况和要求可以适当突破原则</li></ol><p><em>总结</em></p><ul><li>聚合的特点: 高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位，但我不建议你对微服务过度拆分。但在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。一个微服务可以包合多个聚合，聚合之间的边界是微服务内天然的逻辑边界。有了这个逻辑边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就不再是一件难事了</li><li>聚合根的特点: 聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。</li><li>实体的特点: 有ID标识，通过D 判断相等性，ID 在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是对一的关系。实体可以引用聚合内的聚合根、实体和值对象</li><li>值对象的特点：无ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征值对象尽量只引用值对象</li></ul><h3 id="领域事件"><a href="#领域事件" class="headerlink" title="领域事件"></a>领域事件</h3><p><em>定义</em><br>领域事件用来表示领域中发生的事件。一个领域事件将导致进一步的业务操作。<br><strong>领域事件驱动设计</strong>可以切断领域模型之间的强依赖关系，事件发布完成后，发布方不必关心后续订阅方事件处理是否成功，这样可以实现领域模型的解耦，维护领域模型的独立性和数据的一致性。在领域模型映射到微服务系统架构时，领域事件可以解耦微服务，微服务之间的数据不必要求强一致性，而是基于事件的<strong>最终一致性</strong>。</p><p><em>微服务内的领域事件</em><br>微服务内应用服务不一定需要引入消息中间件，但一个事件若涉及到多个聚合，需要考虑引入事件总线，但也需要考虑其开发成本。<br>微服务内应用服务，可以通过跨聚合的服务编排和组合，以服务调用的方式完成跨聚合的访问，这种方式通常应用于实时性和数据一致性要求高的场景。这个过程会用到分布式事务以保证发布方和订阅方的数据同时更新成功。</p><p><em>微服务之间的领域事件</em><br>跨微服务的领域事件会在不同的限界上下文或领域模型之间实现业务协作，其主要目的是实现微服务解耦，减轻微服务之间实时服务访问的压力。<br>跨微服务的事件机制要总体考虑事件构建、发布和订阅、事件数据持久化、消息中间件，甚至事件数据持久化时还可能需要考虑引入分布式事务机制（确保数据一致性）等。</p><p><em>领域事件总体架构</em><br>领域事件处理包括：<strong>事件构建和发布、事件数据持久化、事件总线、消息中间件、事件接受和处理</strong>等。</p><ol><li>事件构建与发布：<ol><li>事件基本属性：事件唯一标识、发生时间、类型、来源。为保证事件结构统一，一般会创建事件基类，子类可扩充属性和方法。</li><li>事件发布前需要构建事务实体并持久化，发布的方式可以为事务总线或消息中间件等。</li></ol></li><li>事件数据持久化：用于系统之间数据对账，持久化有两种方案：<ol><li>持久化到本地业务数据库的事件表中，利用本地事务保证业务和事件数据的一致性。</li><li>持久化到共享事件数据库中，为了保证业务数据与事件数据的一致性，可能需要使用分布式事务来保证强一致性。</li></ol></li><li>事件总线：提供事件分发和接受等服务。<ol><li>微服务内的消费者：直接分发</li><li>微服务外的消费者：持久化后异步发送到消息中间件</li><li>混合消费者：先分发内部订阅者，后持久化后异步发送到微服务外。</li></ol></li><li>消息中间件：跨微服务的领域事件大多会用到消息中间件</li><li>事件接受与处理：订阅方次啊用监听机制，完成事件数据的持久化后即可进行下一步业务处理。</li></ol><h2 id="DDD分层架构"><a href="#DDD分层架构" class="headerlink" title="DDD分层架构"></a>DDD分层架构</h2><p><em>依赖倒置</em><br><img src="/Pasted%20image%2020231031194150.png"><br>领域层为软件的核心，实现了各层对基础层的解耦。</p><p><em>DDD分层</em><br><img src="/Pasted%20image%2020231028201816.png"></p><ol><li>用户接口层：负责向用户显示信息和解释用户指令。</li><li>应用层：主要面向用例和流程相关的操作，可协调多个聚合服务和领域对象。</li><li>领域层：实现核心业务逻辑，包括聚合根，实体，值对象，领域服务等领域模型。</li><li>基础层：贯穿所有层，为其他各层提供通用的技术和基础服务，如数据库访问实现。基础层采用了依赖倒置的设计，应用层通过解耦保持了独立的核心业务逻辑。</li></ol><p><em>DDD分层的原则</em><br>架构根据耦合的紧密程度分为：严格分层架构和松散分层架构，优化后的DDD分层属于严格分层架构，每层只能与位于其下的层发送耦合。</p><p><em>三层架构到DDD分层</em><br><img src="/Pasted%20image%2020231031194238.png"><br>DDD分层架构的基础资源访问都采用了仓储设计模式，即通过依赖倒置实现各层对基础资源的解耦，仓库接口放在领域层，仓库实现放在基础层。</p><h2 id="微服务架构模型"><a href="#微服务架构模型" class="headerlink" title="微服务架构模型"></a>微服务架构模型</h2><p><em>整洁架构</em><br>又称洋葱架构，体现了分层的设计思想。越往里依赖越低，代码级别越高，越是核心能力。内圆不需要知道外圆的任何情况。<br><img src="/Pasted%20image%2020231028201843.png"></p><p><em>六边形架构</em><br>核心理念：应用是通过端口与外部进行交互的。即核心业务逻辑与外部资源完全隔离，仅通过适配器进行交互，其解决了业务逻辑与用户界面的代码交错问题，实现了前后端分离，其他各层依赖关系与整洁架构类似。<br><img src="/Pasted%20image%2020231028201903.png"><br>六边形架构的一个端口可能对应多个外部系统，不同外部系统也可能会使用不同的适配器。</p><p><em>模型对比分析</em><br><img src="/Pasted%20image%2020231028201926.png"><br>都是以领域模型为中心的设计思想，都考虑了前端需求的变与领域模型的不变。</p><p><em>中台</em><br>中台：本质上是领域的子域，通常认为阿里的中台对应DDD的通用域。</p><p><em>中台与微服务设计</em></p><ol><li>中台建设要站在企业高度考虑能力的共享和复用。</li><li>微服务要有合理的架构分层。</li><li>应用资源的解耦和适配：通过仓储模式，采用依赖倒置的设计方法，屏蔽资源变更对业务代码的影响。</li></ol><p><em>项目级微服务</em><br><img src="/Pasted%20image%2020231028202046.png"><br>服务的组合和编排在应用层实现。</p><p><em>企业级微服务</em><br><img src="/Pasted%20image%2020231028202123.png"><br>使用BFF微服务（服务于前端的微服务，没有领域模型）完成各个中台微服务的服务组合和编排。</p><p><em>整洁架构和六边形架构的区别？</em><br>整洁架构规定了层之间的依赖关系规则：内层（高层）不依赖外层（低层），六边形架构层之间的依赖关系也遵从此规则。<strong>可以认为整洁架构是一种架构设计的指导思想，六边形架构是整洁架构的一种具体的架构设计。</strong><br>采用依赖倒置原则后的分层架构和<strong>六边形架构</strong>，实际上都符合整洁架构设计理念。但是六边形架构中使用端口与适配器，让应用程序能够以一致的方式被用户、程序、自动化测试、批处理脚本所驱动，同时能够让应用程序边界更加清晰，从而能更好地防止领域层和应用层逻辑泄露到外层。</p><blockquote><p><a href="https://juejin.cn/post/7256795117675216952?from=search-suggest">DDD架构为什么应该首选六边形架构？ | 京东云技术团队</a></p></blockquote><h1 id="DDD与中台建模"><a href="#DDD与中台建模" class="headerlink" title="DDD与中台建模"></a>DDD与中台建模</h1><h2 id="中台介绍"><a href="#中台介绍" class="headerlink" title="中台介绍"></a>中台介绍</h2><p><em>平台与中台区别</em></p><ul><li>背景：阿里<strong>业务中台</strong>的前身是<strong>共享平台</strong>，而原来的共享平台更多的被当作资源团队，他们承接各业务方的需求，并为业务方在基础服务上做定制开发。</li><li>目标：将核心的服务链路整体当作一个平台产品来做，为前端业务提供业务解决方案。</li><li>区别：平台只是将通用的公共能力独立为共享平台，其并没有与企业内其他平台或应用等实现全面融合，也没有将核心业务服务链路作为一个整体方案考虑，各平台之间是分离且独立的。</li></ul><p><em>中台的定义</em><br>中台是<strong>企业级能力</strong>复用平台。其相比平台，有以下特点：</p><ol><li>对前台业务的快速响应能力；</li><li>企业级复用能力；</li><li>从前台、中台到后台的设计、研发、页面等的无缝联通、融合能力。</li></ol><p><em>中台应该共享什么？</em><br>业务中台：解决核心业务链路的<strong>联通</strong>和不同渠道服务<strong>共享</strong>的问题。<br>数据中台：解决系统微服务拆分后的<strong>数据孤岛</strong>、数据融合和业务创新等问题。</p><h2 id="前中后台协同"><a href="#前中后台协同" class="headerlink" title="前中后台协同"></a>前中后台协同</h2><p><em>前、中、后台的定义</em><br>阿里对前、中、后台的定义：前台主要面向客户以及终端销售者，实现营销推广以及交易转化，中台主要面向运营人员完成运营支撑，后台主要面向后台管理人员，实现流程审核、内部管理以及后勤支撑，比如采购、人力、财务和 OA 等系统。</p><p><em>前台</em></p><ul><li>传统企业的早期系统，<strong>每个系统都有自己的前端</strong>，相互独立，用户需要登录多个系统才能完成完整业务流程。</li><li>中台后的前台需要有一套综合考虑业务边界、流程和平台的整体解决方案，以达到不管后端有多少中台，前端用户感受到的就是<strong>只有一个前台</strong>。</li></ul><p><em>业务中台</em></p><ul><li>传统企业核心业务基于集中式架构开发，没有扩展性和弹性伸缩能力，难以快速响应前端一线业务。</li><li><strong>业务中台</strong>的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。</li></ul><p><em>数据中台</em><br>数据中台的主要目标是打通数据孤岛，实现业务融合和创新，包括三大主要职能：</p><ul><li>完成企业全域数据的采集与存储，实现各不同业务类别<strong>中台数据的汇总和集中管理</strong>；</li><li>按照标准的数据规范或数据模型，<strong>将数据</strong>按照不同主题域或场景进行加工和<strong>处理形成面向不同主题和场景的数据应用</strong>，比如客户视图、代理人视图、渠道视图、机构视图等不同数据体系；</li><li>建立业务需求驱动的数据体系，基于各个维度的数据，<strong>深度萃取数据价值，支持业务和商业模式的创新</strong>；</li></ul><p><em>后台</em><br>主要为实现内部的管理需求，一般可以考虑按角色或岗位进行功能聚合，将复杂的管理需求从业务领域中剥离开。</p><p><em>总结</em><br>前台通过页面和流程共享实现不同渠道应用之间的前台融合，中台通过 API 实现服务共享。而前台、业务中台和数据中台的融合可以实现传统应用与互联网应用的融合，从而解决“后端双核心、前端两张皮”的问题。能力复用了，前台流程和数据融合了，才能更好地支持业务的融合和商业模式的创新。</p><h2 id="DDD、中台和微服务协作"><a href="#DDD、中台和微服务协作" class="headerlink" title="DDD、中台和微服务协作"></a>DDD、中台和微服务协作</h2><p>中台是抽象出来的业务模型，微服务是业务模型的系统实现，DDD作为方法论可以同时指导中台业务建模和微服务建设，三者相辅相成。<br><img src="/Pasted%20image%2020231029013115.png"></p><p><em>中台的本质</em><br>中台的本质其实就是提炼各个业务板块的共同需求，进行业务和系统抽象，形成通用的可复用的业务模型，打造成组件化产品，供前台部门使用。<strong>前台要做什么业务，需要什么资源可以直接找中台，不需要每次都去改动自己的底层。</strong></p><p><em>DDD、中台和微服务的协作</em><br><img src="/Pasted%20image%2020231029013045.png"></p><p><em>中台如何建模</em></p><ol><li>将业务域细分为多个中台，根据功能属性和重要性归类到核心中台或通用中台。</li><li>选择具体中台，事件风暴后找出实体、聚合和限界上下文，进行领域分解、建立领域模型。</li><li>以主领域模型为基础，扫描其他中台领域模型，检查是否有重复或需要重组的领域对象。</li><li>选择其他主领域模型重复第3步，直到所有主领域模型完成比对和重构。</li><li>完成微服务设计，完成系统落地。</li></ol><h2 id="DDD重构中台业务模型"><a href="#DDD重构中台业务模型" class="headerlink" title="DDD重构中台业务模型"></a>DDD重构中台业务模型</h2><p><em>重构策略</em></p><ol><li>自顶向下策略：先做顶层设计、从最高领域逐级分解为中台，分别建立领域模型。自顶向下的策略适用于<strong>全新的应用系统建设，或旧系统推倒重建的情况</strong>。</li><li>自底向上策略：基于业务和系统现状完成领域建模。自底向上策略<strong>适用于遗留系统业务模型的演进式重构</strong>。步骤一般有以下三步：<ol><li>锁定系统所在业务域，构建领域模型：找到各领域业务能力重复或分散的部分。</li><li>对齐业务域，构建中台业务模型：以互联网电商领域模型作为<strong>辅助模型</strong>构建中台业务模型。</li><li>中台归类，根据领域模型设计微服务：根据中台业务模型设计微服务。</li></ol></li></ol><blockquote><p>构建多业务域的中台业务模型的过程，就是找出同一业务域内所有同类业务的领域模型，对比分析域内领域模型和聚合的差异和共同点，打破原有的模型，完成新的中台业务模型重组或归并的过程。</p></blockquote><h1 id="DDD实战"><a href="#DDD实战" class="headerlink" title="DDD实战"></a>DDD实战</h1><h2 id="事件风暴"><a href="#事件风暴" class="headerlink" title="事件风暴"></a>事件风暴</h2><p><em>要点</em></p><ul><li>参与者：项目团队、领域专家</li><li>内容：枚举实体、目录、领域事件、其他信息，关注业务语言和行为。</li><li>步骤：<ol><li>产品愿景：确定产品方向</li><li>业务场景：将产生很多命令和领域事件</li><li>领域建模：分析依赖关系，组成聚合、划定限界上下文。</li><li>微服务拆分与设计：以领域模型作为拆分微服务的依据，而不是唯一标准。</li></ol></li></ul><h2 id="代码模型设计"><a href="#代码模型设计" class="headerlink" title="代码模型设计"></a>代码模型设计</h2><blockquote><p>DDD没有给出标准的代码模型，下面的设计只是一个参考。</p></blockquote><p><em>设计案例</em><br><img src="/Pasted%20image%2020231031183128.png"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs perl">- com.$&#123;company&#125;.$&#123;system&#125;.$&#123;appname&#125;<br>|- interfaces(用户接口层)<br>  |- assembler(实现DTO与领域对象的转换)<br>  |- dto(数据传输载体)<br>  |- facade(调用接口)<br>|- application(应用层)<br>  |- service(服务)<br>    |- impl<br>  |- event(事件，领域层和应用层都可以存放，但为了事件管理的统一性，建议放在应用层)<br>    |- publish<br>|- subscribe<br>|- domain(领域层)<br>  |- domain1(领域<span class="hljs-number">01</span>)<br>|- service(领域服务)<br>|- entity(领域实体)<br>|- event(领域事件)<br>|- repository(仓库接口)<br>|- infrastructure(基础设施层)<br>  |- dal(数据访问层)<br>    |-dao<br>  |- mapper<br>  |- factory<br>  |- utils<br></code></pre></td></tr></table></figure><p><em>异常处理</em><br>Interface层的HTTP和RPC接口，返回值为Result，捕捉所有异常。<br>Application层的所有接口返回值为DTO，不负责处理异常。</p><p><em>Facade层</em><br>为远程客户端提供粗粒度的调用接口，他的作用就是将一个用户请求委派给一个或多个service进行处理。</p><p><em>防腐层</em><br>Anti-Corruption Layer（防腐层或ACL）。很多时候我们的系统会去依赖其他的系统，通过在系统间加入一个防腐层，能够有效的隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能的保持不变。<br>ACL防腐层的实现方式：</p><ul><li>对于依赖的外部对象，我们抽取出所需要的字段，生成一个内部所需的VO或DTO类。</li><li>构建一个新的Facade，在Facade中封装调用链路，将外部类转化为内部类。</li><li>针对外部系统调用，同样的用Facade方法封装外部调用链路。</li></ul><blockquote><p>在一些理论框架里ACL Facade也被叫做Gateway，含义是一样的。</p></blockquote><p><em>各种O</em></p><ul><li>DAO （Data Access Object）数据访问对象</li><li>DTO（Data Transfer Object）数据传输对象</li><li>DO （Domain Object）领域对象</li><li>VO（View Object）视图模型</li><li>AO（Application Object）应用对象</li><li>BO（ Business Object）业务对象</li><li>POJO（Plain Ordinary Java Object）纯普通Java对象</li><li>PO（Persistent Object）持久化对象</li><li>Entity（应用程序域中的一个概念）实体</li><li>Model （概念实体模型）实体类和模型</li><li>View （概念视图模型）视图模型</li></ul><p><em>总结</em></p><ol><li>聚合之间的代码边界要清晰</li><li>要有代码分层的概念</li></ol><p><em>保证领域模型与代码模型的一致性</em></p><ol><li>整理事件风暴的内容为一个表格，包含领域模型、聚合、领域对象、领域对象类型</li><li>微服务化：<ol><li>设计实体：设计Entity对象</li><li>找出聚合根：同一个聚合的实体放在同一个领域的Entity目录</li><li>设计值对象：设计值对象放在对应领域的Entity目录</li><li>设计领域事件：设计实践并将Event类和Handler类放在服务层的Event目录</li><li>设计领域服务：设计服务并放在领域层的Service目录</li><li>设计仓储：设计仓储接口放在领域层的Repository目录</li></ol></li><li>服务的封装与调用<ol><li>实体方法的封装，用DomainService和AppService区分<strong>领域服务</strong>或<strong>应用服务</strong></li><li>领域服务对同一领域的多个实体方法进行组合编排</li><li>应用服务对多个领域的服务进行组合编排，暴露给用户接口层</li></ol></li><li>建立领域对象与微服务代码对象的映射</li></ol><blockquote><p>对于一些业务场景可能无法设计出典型的领域模型，如找不到聚合根，此时可以借鉴聚合的思想，用聚合来定义这部分功能。</p></blockquote><h2 id="微服务边界"><a href="#微服务边界" class="headerlink" title="微服务边界"></a>微服务边界</h2><p><em>演进式架构</em><br>演进式架构就是以支持增量的、非破坏的变更作为第一原则，同时支持在应用程序结构层面的多维度变化。微服务设计的重点，就是看微服务设计是否能够支持架构长期、轻松的演进。</p><p><em>边界</em></p><ul><li>逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚。<strong>可根据需要变成物理边界，也就是说聚合也可以独立为微服务。</strong></li><li>物理边界:微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。</li><li>代码边界: 不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离方便架构演进时代码的重组。</li></ul><h2 id="微服务视图"><a href="#微服务视图" class="headerlink" title="微服务视图"></a>微服务视图</h2><p><em>服务依赖关系</em></p><ul><li>松散分层架构：领域层服务和实体方法直接暴露给应用层和用户接口层，无需逐级封装。（开发效率更高）</li><li>严格分层架构：每一层服务只向紧邻的上一层提供服务，实体方法值暴露给领域服务，由领域服务暴露给应用层。（可管理性更好）</li></ul><p><em>数据对象视图</em><br><img src="/Pasted%20image%2020231031185337.png"></p><h2 id="微服务前端设计"><a href="#微服务前端设计" class="headerlink" title="微服务前端设计"></a>微服务前端设计</h2><p><em>微前端</em><br>为了解决单体前端的问题，我们可以借鉴微服务的设计思想，引入<strong>微前端</strong>概念：在前端设计时我们需要遵循单一职责和复用原则，按照领域模型和微服务边界，将前端页面进行拆分。同时构建多个可以<strong>独立部署、完全自治、松耦合的页面组合</strong>，其中每个组合只负责特定业务单元的 UI 元素和功能，这些页面组合就是<strong>微前端</strong>。</p><p><em>业务单元组合</em></p><ol><li>单一业务单元：一个微前端对应一个微服务</li><li>组合业务单元：一个微前端对应多个微服务</li><li>通用共享业务单元：一个微前端与若干微服务组成通用业务单元，以共享页面的方式与其他微前端页面协作</li></ol><p><em>微前端集成</em><br>微服务位于前端和微服务之间，因此其需要完成与这两方的集成：</p><ol><li>微前端与前端主页面集成：通过页面路由、微前端注册等方式实现</li><li>微前端与微服务集成：类似传统前后端集成</li></ol><p><em>职责边界</em></p><ul><li>前端项目团队：只需要完成企业级前端主页面与业务单元的融合，前端只关注前端主页面与微前端页面之间的集成。</li><li>中台项目团队：关注业务单元功能的完整性和自包含能力，完成业务单元内微服务和微前端开发、集成和部署，提供业务单元组件。</li></ul><h2 id="微服务设计原则"><a href="#微服务设计原则" class="headerlink" title="微服务设计原则"></a>微服务设计原则</h2><p><em>微服务演进策略</em></p><ul><li>绞杀者策略：整体重构，用微服务逐步替换原单体系统</li><li>修缮者策略：部分重构，在现有系统的基础上<strong>剥离影响整体业务的功能</strong>独立为微服务</li></ul><p><em>不同场景建模策略</em></p><ul><li>新建系统<ul><li>简单领域系统：直接事件风暴即可</li><li>复杂领域系统：拆分子域建立领域模型、领域模型微调、微服务设计</li></ul></li><li>遗留系统：修缮者策略，取性能瓶颈的模块拆分为微服务</li></ul><p><em>微服务设计原则</em></p><ul><li>领域驱动设计，拒绝数据驱动或界面驱动</li><li>清晰微服务的边界</li><li>清晰微服务分层的职能</li><li>不做过度拆分</li></ul>]]></content>
    
    
    <categories>
      
      <category>架构学习</category>
      
      <category>DDD建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DDD</tag>
      
      <tag>架构学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言圣经</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><em>目录介绍</em></p><ol><li>Go的主要项目文件在其安装目录下，我们称之为<code>GOROOT</code>。</li><li>Go的其他库文件在<code>GOPATH</code>中，该文件的作用类似Maven的全局仓库。（在<code>GOPATH</code>时代，其无法作为全局仓库，所以我们的项目也只能放在GOPATH下的src文件夹下。）</li></ol><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/fb0b9eb90e638a7f0a7754691a22349.jpg"></p><ul><li>pkg 其中pkg下面以下三个文件夹。<ul><li>XX_amd64: 其中 XX 是目标操作系统，比如 mac 系统对应的是darwin_amd64, linux 系统对应的是 linux_amd64，存放的是.a结尾的文件。</li><li>&#x3D;&#x3D;mod: 当开启go Modules 模式下，go get命令缓存下依赖包存放的位置&#x3D;&#x3D;</li><li>sumdb: go get命令缓存下载的checksum数据存放的位置，主要起小版本管理的作用</li></ul></li></ul><p><em>GOPATH与GOMOD</em></p><ul><li>过去（GOPATH）：项目都在GOPATH下src中，外部引入的库（第三方）也在src包路径下才可以使用。</li><li>现在（GOMOD）：项目可以在任意地方，项目下的mod起依赖版本管理作用，GOPATH中 pkg&#x2F;mod放第三方库</li></ul><p><em>语法特性</em><br>不需要分号结尾：Go会自动在符合条件的语句结尾加分号，因此其也有以下使用限制</p><ul><li>函数的左括号必须跟着函数名，不能单起一行</li><li><code>x + y</code>等运算符场景，只能在 + 后换行而不能在 + 前换行。</li></ul><h1 id="二、程序结构"><a href="#二、程序结构" class="headerlink" title="二、程序结构"></a>二、程序结构</h1><p><em>命名规则</em><br>一个名字必须以一个字母（Unicode字母）或下划线开头。<br>Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。<br>一个函数的声明由一个<code>func</code>、<code>函数名字</code>、<code>参数列表</code>、<code>可选的返回值列表</code>和包含函数定义的<code>函数体</code>组成。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p><em>变量关键字</em><br>变量声明使用<code>const</code>或<code>var</code>，函数体外的变量是<strong>包可见</strong>的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 变量声明方式(“类型”或“=表达式”两个部分可以省略其中的一个,如果初始化表达式被省略，那么将用零值（或nil）初始化该变量。)</span><br><span class="hljs-keyword">var</span> 变量名字 类型 = 表达式<br><span class="hljs-comment">// 多变量类型多值初始化</span><br><span class="hljs-keyword">var</span> i, j, k <span class="hljs-type">int</span>                 <span class="hljs-comment">// int, int, int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;four&quot;</span> <span class="hljs-comment">// bool, float64, string</span><br></code></pre></td></tr></table></figure><p><em>简短变量</em><br>在<strong>函数内部</strong>，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 :&#x3D; 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 简短变量声明</span><br>t := <span class="hljs-number">0.0</span><br><span class="hljs-comment">// 变量交换</span><br>i,j = j,i<br></code></pre></td></tr></table></figure><blockquote><p>请记住“:&#x3D;”是一个变量声明语句，而“&#x3D;”是一个变量赋值操作。</p></blockquote><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>一个指针的值是另一个<strong>变量的地址</strong>。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">1</span>  <br>p := &amp;x         <span class="hljs-comment">// p, of type *int, points to x  </span><br>*p = <span class="hljs-number">2</span>          <span class="hljs-comment">// equivalent to x = 2</span><br></code></pre></td></tr></table></figure><p>使用<code>&amp;</code>获取<strong>变量的指针</strong>，使用<code>*</code>获取<strong>指针所指的变量的值</strong>。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231026212947.png"></p><p>另一个创建变量的方法是调用内建的<code>new</code>函数。表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后<strong>返回变量地址</strong>，即返回的指针类型为<code>*T</code>。</p><blockquote><p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p></blockquote><h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p><em>生命周期</em></p><ul><li>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。</li><li>局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</li></ul><p><em>可达性算法</em><br>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p><p><em>内存分配</em><br>编译器会<strong>自动选择在栈上还是在堆上分配局部变量的存储空间</strong>，其取决于变量是否发生了<strong>方法逃逸</strong>。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><ul><li>自增和自减：是一种语句，而不是表达式，因此<code>x = i++</code>之类的表达式是错误的</li><li>元组赋值：另一种形式的赋值语句，它允许同时更新多个变量的值：<code>x, y = y, x</code></li><li>错误返回：部分函数会用额外的返回值来表达某种错误类型，例如os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok：<code>f, err = os.Open(&quot;foo.txt&quot;)</code></li><li>隐式赋值：<code>medals := []string&#123;&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;&#125;</code></li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span>    <span class="hljs-comment">// 摄氏温度</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span> <span class="hljs-comment">// 华氏温度</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123; <span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>) &#125;<br></code></pre></td></tr></table></figure><ul><li>类型声明语句一般出现在包一级，因此<strong>如果新创建的类型名字的首字符大写</strong>，则在包外部也可以使用。</li><li>即使两种类型有着相同的底层类型，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。</li><li>对于每一个类型T，都有一个对应的类型转换操作<code>T(x)</code>，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如<code>(*int)(0)</code>）。</li></ul><h2 id="包与文件"><a href="#包与文件" class="headerlink" title="包与文件"></a>包与文件</h2><p>在Go语言中，每个源文件都是以包的声明语句开始，用来指明包的名字，一个简单的规则是：<strong>如果一个名字是大写字母开头的，那么该名字是包导出的</strong>（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p><p><em>可见性</em></p><ul><li>包间：导入包后，包内的大写成员将通过类似<code>包名.成员名</code>的形式访问。</li><li>包内：在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。</li></ul><p><em>注释</em><br>在package语句前应该标注包的注释，若有多个注释则会自动合并，若注释太复杂则需要单独使用<code>doc.go</code>文件来表达。</p><p><em>包的初始化</em></p><ul><li>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</li><li>对于在包级别声明的变量：<ul><li>简单的赋值：用表达式初始化</li><li>复杂的赋值：用特殊的<code>init</code>初始化函数来简化初始化工作。<strong>每个文件都可以包含多个<code>init</code>初始化函数</strong></li></ul></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><em>作用域</em><br>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p><p><em>变量作用域</em><br><strong>声明语句</strong>对应的词法域决定了<strong>作用域范围</strong>的大小。如果变量名在内部和外部的块分别声明过，则内部块的声明首先被找到。</p><p><em>声明顺序</em><br>在<strong>包级别</strong>，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p><p><em>初始化</em><br><code>:=</code>总是会创建新的变量而忽略外部变量，因此若想在函数中对函数外的变量赋值，最好使用 <code>=</code>。</p><h1 id="三、基础数据类型"><a href="#三、基础数据类型" class="headerlink" title="三、基础数据类型"></a>三、基础数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p><em>类型特点</em></p><ul><li>Unicode字符rune类型是和int32等价的类型</li><li>同样byte也是uint8类型的等价类型</li><li>无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳<strong>指针</strong>。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</li></ul><p><em>运算符</em><br><code>&amp;^</code> 位清空（AND NOT）</p><p><em>运算规则</em><br>一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，且<strong>算术和逻辑运算的二元操作中必须是相同的类型</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> apples <span class="hljs-type">int32</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> oranges <span class="hljs-type">int16</span> = <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> compote <span class="hljs-type">int</span> = apples + oranges <span class="hljs-comment">// compile error</span><br><br><span class="hljs-keyword">var</span> compote = <span class="hljs-type">int</span>(apples) + <span class="hljs-type">int</span>(oranges)<br></code></pre></td></tr></table></figure><p><em>进制表达</em><br>任何大小的整数字面值都<strong>可以用以0开始的八进制格式书写</strong>，例如0666；或<strong>用以0x或0X开头的十六进制格式书写</strong>，例如0xdeadbeef。十六进制数字可以用大写或小写字母。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">o := <span class="hljs-number">0666</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o) <span class="hljs-comment">// &quot;438 666 0666&quot;</span><br>x := <span class="hljs-type">int64</span>(<span class="hljs-number">0xdeadbeef</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]x %#[1]x %#[1]X\n&quot;</span>, x)<br></code></pre></td></tr></table></figure><blockquote><p>请注意fmt的两个使用技巧：<br>通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的<code>[1]</code>副词告诉Printf函数再次使用第一个操作数。第二，%后的<code>#</code>副词告诉Printf在用<code>%o、%x、%X</code>输出时生成0、0x或0X前缀。</p></blockquote><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><em>注意点</em><br>通常应该优先使用<code>float64</code>类型，因为<code>float32</code>类型的累计计算误差很容易扩散，并且<code>float32</code>能精确表示的正整数并不是很大。</p><p><em>打印</em><br>用<code>Printf</code>函数的<code>%g</code>参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用<code>%e</code>（带指数）或<code>%f</code>的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 打印精度是小数点后3个小数精度和8个字符宽度</span><br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">8</span>; x++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;x = %d e^x = %8.3f \n&quot;</span>, x, math.Exp(<span class="hljs-type">float64</span>(x)))<br>&#125;<br></code></pre></td></tr></table></figure><p><em>其他特别数</em><br>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> z <span class="hljs-type">float64</span><br>fmt.Println(z, -z, <span class="hljs-number">1</span>/z, <span class="hljs-number">-1</span>/z, z/z) <span class="hljs-comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span><br></code></pre></td></tr></table></figure><p>函数<code>math.IsNaN</code>用于测试一个数是否是非数<code>NaN</code>，<code>math.NaN</code>则返回非数对应的值。虽然可以用<code>math.NaN</code>来表示一个非法的结果，但是测试一个结果是否是非数<code>NaN</code>则是充满风险的，因为<code>NaN</code>和任何数都是不相等的（类似MySQL的IS NULL）</p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go语言提供了两种精度的复数类型：<code>complex64</code>和<code>complex128</code>，分别对应<code>float32</code>和<code>float64</code>两种浮点数精度。内置的complex函数用于构建复数，内建的<code>real</code>和<code>imag</code>函数分别返回复数的实部和虚部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1+2i</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 3+4i</span><br>fmt.Println(<span class="hljs-built_in">real</span>(x*y))           <span class="hljs-comment">// &quot;-5&quot;</span><br>fmt.Println(<span class="hljs-built_in">imag</span>(x*y))           <span class="hljs-comment">// &quot;10&quot;</span><br><span class="hljs-comment">// 也可以用自然方式书写</span><br>x := <span class="hljs-number">1</span> + <span class="hljs-number">2i</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><em>赋值</em><br>一个字符串是一个<strong>不可改变</strong>的字节序列，默认UTF8，相关操作如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello, world&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s))     <span class="hljs-comment">// 返回字符串的 字节数量</span><br>fmt.Println(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">7</span>]) <span class="hljs-comment">// 返回对应所有下的字节</span><br>fmt.Println(s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]) <span class="hljs-comment">// 基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串（与原字符串共享底层内存，且不可变）。</span><br></code></pre></td></tr></table></figure><p>多行字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">`line1</span><br><span class="hljs-string">line2</span><br><span class="hljs-string">line3</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><em>Unicode</em><br>Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。由于Go语言字符串使用UTF8表示，因此不能根据字符串长度判断字符的数量。<br>Go提供了utf8包来实现Unicode的解析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;你好，世界&quot;</span>  <br>fmt.Println(utf8.RuneCountInString(s)) <span class="hljs-comment">// &quot;5&quot; s的字符数量  </span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); &#123;  <br>    r, size := utf8.DecodeRuneInString(s[i:]) <span class="hljs-comment">// 从索引i开始解析一个字符，r为字符对应的utf8值，size为字符对应的字节数  </span><br>    fmt.Printf(<span class="hljs-string">&quot;%d\t%c\n&quot;</span>, i, r)              <span class="hljs-comment">// %d表示整数索引i的值，%c将字符utf8解析为字符表达  </span><br>    i += size  <br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便的遍历字符，可以使用range，其隐式的处理了字符解析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;Hello, 世界&quot;</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Java中，JDK8的String的底层为<code>char[]</code>数组，采用了UTF16编码，JDK9的String底层为<code>buye[]</code>数组，默认采用UTF8编码。<br>由于一个char无法表达<code>non-BMP</code>字符（需要32位），因此一个char并不一定能表达一个字符。</p></blockquote><p><em>rune</em><br>UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune数组可能更方便，因为rune大小一致，支持数组索引和方便切割。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;你好，世界&quot;</span>  <br>runes := []<span class="hljs-type">rune</span>(s)  <span class="hljs-comment">// string -&gt; []rune</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> runes &#123;  <br>    <span class="hljs-built_in">println</span>(<span class="hljs-type">string</span>(r)) <span class="hljs-comment">// rune 转 string打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果对应码点的字符是无效的，则用<code>\uFFFD</code>无效字符作为替换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">1234567</span>)) <span class="hljs-comment">// &quot;?&quot;</span><br></code></pre></td></tr></table></figure><p><em>字符串和Byte切片</em><br>bytes、strings、strconv和unicode包提供了很多基础的API：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// strings</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(a []<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// bytes</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(b, subslice []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> [][]<span class="hljs-type">byte</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(s [][]<span class="hljs-type">byte</span>, sep []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span><br></code></pre></td></tr></table></figure><p>bytes包还提供了Buffer类型（类似StringBuffer）用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intsToString</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> buf bytes.Buffer<br>    buf.WriteByte(<span class="hljs-string">&#x27;[&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>            buf.WriteString(<span class="hljs-string">&quot;, &quot;</span>)<br>        &#125;<br>        fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, v)<br>    &#125;<br>    buf.WriteByte(<span class="hljs-string">&#x27;]&#x27;</span>)<br>    <span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(intsToString([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)) <span class="hljs-comment">// &quot;[1, 2, 3]&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><em>定义</em><br>常量表达式的值在编译期计算，而不是在运行期。常量间的所有算术运算、逻辑运算和比较运算的结果也是常量。</p><p>每种常量的潜在类型都是基础类型：boolean、string或数字。一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。</p><p><em>声明</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 普通声明</span><br><span class="hljs-keyword">const</span> PI=<span class="hljs-number">3.14</span><br><span class="hljs-comment">// 批量声明</span><br><span class="hljs-keyword">const</span> (<br>    e  = <span class="hljs-number">2.71828182845904523536028747135266249775724709369995957496696763</span><br>    pi = <span class="hljs-number">3.14159265358979323846264338327950288419716939937510582097494459</span><br>)<br><span class="hljs-comment">// 类型常量 time.Duration类型的常量</span><br><span class="hljs-keyword">const</span> noDelay time.Duration = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><em>初始化省略</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-number">1</span><br>    b<br>    c = <span class="hljs-number">2</span><br>    d<br>)<br>fmt.Println(a, b, c, d) <span class="hljs-comment">// &quot;1 1 2 2&quot;</span><br></code></pre></td></tr></table></figure><p><em>iota 常量生成器</em><br>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，<strong>在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一</strong>，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>    Sunday Weekday = <span class="hljs-literal">iota</span><br>    Monday<br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br></code></pre></td></tr></table></figure><p><em>无类型常量</em><br>go中有部分常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型<strong>更高精度的算术运算</strong>；你可以认为至少有256bit的运算精度。有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p><ul><li>通过<strong>延迟明确常量的具体类型</strong>，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如Pi常量可以被赋予各类型变量</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">float32</span> = math.Pi<br><span class="hljs-keyword">var</span> y <span class="hljs-type">float64</span> = math.Pi<br><span class="hljs-keyword">var</span> z <span class="hljs-type">complex128</span> = math.Pi<br></code></pre></td></tr></table></figure><ul><li>除法运算符&#x2F;会<strong>根据操作数的类型生成对应类型的结果</strong>。因此，不同写法的常量除法表达式可能对应不同的结果：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">212</span><br>fmt.Println((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)     <span class="hljs-comment">// &quot;100&quot;; (f - 32) * 5 is a float64</span><br>fmt.Println(<span class="hljs-number">5</span> / <span class="hljs-number">9</span> * (f - <span class="hljs-number">32</span>))     <span class="hljs-comment">// &quot;0&quot;;   5/9 is an untyped integer, 0</span><br></code></pre></td></tr></table></figure><ul><li>只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被<strong>隐式转换</strong>为对应的类型，如果转换合法的话：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">3</span> + <span class="hljs-number">0i</span> <span class="hljs-comment">// untyped complex -&gt; float64</span><br>f = <span class="hljs-number">2</span>                  <span class="hljs-comment">// untyped integer -&gt; float64</span><br>f = <span class="hljs-number">1e123</span>              <span class="hljs-comment">// untyped floating-point -&gt; float64</span><br>f = <span class="hljs-string">&#x27;a&#x27;</span>                <span class="hljs-comment">// untyped rune -&gt; float64</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。</p></blockquote><h1 id="四、复合数据类型"><a href="#四、复合数据类型" class="headerlink" title="四、复合数据类型"></a>四、复合数据类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><em>介绍</em><br>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。<br><strong>因为数组的长度是固定的，因此在Go语言中很少直接使用数组</strong>。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活。</p><p><em>基本操作</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> <span class="hljs-comment">//声明数组</span><br><span class="hljs-built_in">len</span> := <span class="hljs-built_in">len</span>(a) <span class="hljs-comment">//获取数组长度</span><br><br><span class="hljs-comment">// 初始化数组</span><br><span class="hljs-keyword">var</span> q [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// r[2] = 0</span><br><span class="hljs-comment">//省略长度，长度根据初始化的值来计算</span><br>q := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// “...”处值会根据初始化值数量自动填充</span><br><br><span class="hljs-comment">// 指定索引的初始化</span><br>symbol := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;€&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;￡&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;￥&quot;</span>&#125; <span class="hljs-comment">// 初始化顺序不受限制</span><br>fmt.Println(RMB, symbol[RMB]) <span class="hljs-comment">// &quot;3 ￥&quot;</span><br><br><span class="hljs-comment">// 遍历数组</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, v)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em>数组声明注意事项</em><br>在 Go 语言中，数组的长度必须是一个常量。这意味着，在定义数组时，必须明确指定数组的长度，且长度必须是在编译时就能确定的常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 合法</span><br><span class="hljs-keyword">const</span> size = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> a [size]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 非法</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> a [n]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 如果需要动态指定数组长度，需要使用make函数，这里生产的是一个切片</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br></code></pre></td></tr></table></figure><p><em>数组作为函数参数</em><br>当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以<strong>函数参数变量接收的是一个复制的副本</strong>，并不是原始调用的变量。因为函数参数传递的机制导致<strong>传递大的数组类型将是低效</strong>的，并且<strong>对数组参数的任何的修改都是发生在复制的数组</strong>上，并不能直接修改调用时原始的数组变量。<br>为了解决这个问题，可以使用指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(ptr *[32]<span class="hljs-type">byte</span>)</span></span> &#123;<br>    *ptr = [<span class="hljs-number">32</span>]<span class="hljs-type">byte</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p><em>切片概念</em></p><ul><li>一个slice由三个部分构成：指针（底层数组）、长度和容量。</li><li>切片是长度没有限制的数组，类似Java中的ArrayList。</li><li>切片的声明与数组类似，<strong>区别在于不会声明长度，也不会使用省略号代替</strong>。</li><li>切片之间可以共享底层数组<ul><li>可以基于数组创建切片<code>s=a[1:2]</code>，切片的左右指针应该在原数组的范围内。</li><li>可以基于切片创建切片<code>s2=s1[1:100]</code>，新切片的范围可以比原切片大，但是新切片的左右指针仍应该在底层数组的范围内。</li></ul></li></ul><blockquote><p><code>字符串</code>和<code>[]byte</code>类型也可以做切面</p></blockquote><p><em>切片特性</em></p><ul><li>切片不可以使用<code>==</code>判断所有元素是否全等（只有<code>[]byte</code>可以通过<code>bytes.Equal()</code>函数判断）</li><li>切片变量可以与 <code>nil</code>比较：<code>summer == nil</code></li></ul><p><em>切片零值</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建nil切片</span><br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span>    <span class="hljs-comment">// len(s) == 0, s == nil，零值切片</span><br>s = <span class="hljs-literal">nil</span>        <span class="hljs-comment">// len(s) == 0, s == nil，零值切片</span><br>s = []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// len(s) == 0, s == nil，零值切片</span><br><br><span class="hljs-comment">// 0值切片</span><br>s = []<span class="hljs-type">int</span>&#123;&#125;    <span class="hljs-comment">// len(s) == 0, s != nil，长度为0的切片</span><br></code></pre></td></tr></table></figure><p>除了文档已经明确说明的地方，<strong>所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice</strong>。</p><p><em>make函数</em><br>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>)<br><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>) <span class="hljs-comment">// same as make([]T, cap)[:len]</span><br></code></pre></td></tr></table></figure><p><em>append函数</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// append可以修改slice[len]的值，如果len == cap，则会创建一个新的切片</span><br>stack = <span class="hljs-built_in">append</span>(stack, v) <span class="hljs-comment">// push v</span><br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span><br><span class="hljs-comment">// 删除slice中间元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-built_in">copy</span>(slice[i:], slice[i+<span class="hljs-number">1</span>:])<br>    <span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-comment">// 如果不需要保持原顺序，可以用最后一个元素替换原元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    slice[i] = slice[<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><em>切片作为函数参数</em><br>函数参数的复制机制是值拷贝，而如<strong>切片&#x2F;哈希</strong>这样的高级数据结构所持有的是底层数据结构的指针，拷贝时也拷贝的是指针，即底层数据结构的地址，因此<strong>使用这些数据类型作为函数参数时不需要使用指针即可实现内存共享</strong>。<br>结构体也是如此，如果结构体的某字段类型是某个数据类型的指针，再函数传递过程中发生复制时，复制的也是该字段的地址，从而实现对原结构体变量的修改。</p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><em>map创建</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个map</span><br>age := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>) <span class="hljs-comment">// mapping from strings to ints</span><br><span class="hljs-comment">// 创建一个</span><br>age := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;alice&quot;</span>:   <span class="hljs-number">31</span>,<br>    <span class="hljs-string">&quot;charlie&quot;</span>: <span class="hljs-number">34</span>,<br>&#125;<br><span class="hljs-comment">// 创建空的map的表达式是</span><br>age := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><em>map使用</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// put</span><br>ages[<span class="hljs-string">&quot;alice&quot;</span>] = <span class="hljs-number">32</span><br><span class="hljs-comment">// remove，安全操作，即使ages中不存在alice也不会报错</span><br><span class="hljs-built_in">delete</span>(ages, <span class="hljs-string">&quot;alice&quot;</span>) <span class="hljs-comment">// remove element ages[&quot;alice&quot;]</span><br><span class="hljs-comment">// get，安全操作，ages中不包含bob时默认返回零值</span><br>ages[<span class="hljs-string">&quot;bob&quot;</span>] = ages[<span class="hljs-string">&quot;bob&quot;</span>]+<span class="hljs-number">1</span><br><span class="hljs-comment">// += 和 ++ 也可以用于map</span><br>ages[<span class="hljs-string">&quot;bob&quot;</span>]++<br><br><span class="hljs-comment">// 遍历，安全操作，map为nil时不遍历</span><br><span class="hljs-keyword">for</span> name, age := <span class="hljs-keyword">range</span> ages &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%s\t%d\n&quot;</span>, name, age)<br>&#125;<br><br><span class="hljs-comment">// 判断是否存在key</span><br>age,ok := ages[<span class="hljs-string">&quot;bob&quot;</span>] <span class="hljs-comment">// 返回的ok是一个布尔值，返回元素是否真正存在</span><br></code></pre></td></tr></table></figure><p><em>map注意点</em></p><ul><li><strong>禁止对map元素取址</strong>，因为map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</li><li>查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是<strong>向一个nil值的map存入元素将导致一个panic异常</strong>（但可以向一个nil值的slice存入元素）</li></ul><p><em>set数据结构</em><br>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能：<code>map[string]bool</code>。</p><p><em>key值的要求</em><br>由于Go不像Java使用HashCode判断元素所属桶，也不存在equals的对象通用方法，一般需要手动为对象实现一个ID函数<code>k</code>作为key，确保只有<code>x</code>和<code>y</code>相等时<code>k(x) == k(y)</code>才成立。</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><em>结构体操作</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明结构体</span><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    ID        <span class="hljs-type">int</span><br>    Name      <span class="hljs-type">string</span><br>    Address   <span class="hljs-type">string</span><br>    DoB       time.Time<br>    Position  <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 声明结构体变量</span><br><span class="hljs-keyword">var</span> employee Eployee<br><span class="hljs-comment">// 操作属性</span><br>employee.Salary = <span class="hljs-number">5000</span><br><span class="hljs-comment">// 通过指针操作属性，也可以简化（语法糖）</span><br><span class="hljs-keyword">var</span> prt = &amp;employee<br>*prt.Salary = <span class="hljs-number">6000</span> &lt;==&gt; prt.Salary = <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>如果要在函数内部修改结构体成员的话，用<strong>指针传入</strong>是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</li><li>函数往往<strong>返回结构体变量的指针</strong>而不是结构体变量，因为返回结构体变量时会对原变量进行复制并返回，导致性能开销。</li></ul></blockquote><p><em>结构体特点</em></p><ul><li>结构体成员中，以大写字母开头的就是导出的</li><li>命名为<code>S</code>的结构体不可以拥有类型为<code>S</code>的成员（聚合的值不能包含它自身），但可以拥有类型为<code>*S</code>的成员。</li><li>结构体的零值是每个成员都是零值</li></ul><p><em>结构体创建</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">int</span> &#125;<br><span class="hljs-comment">// 按照顺序填入成员的初始值</span><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-comment">// 指定成员值</span><br>p := Point&#123;X:<span class="hljs-number">1</span>,Y:<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>无论是顺序还是指定初始化成员，都不可能初始化非导出的成员</p></blockquote><p><em>结构体比较</em><br>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用<code>==</code>或<code>!=</code>运算符进行比较。相等比较运算符&#x3D;&#x3D;将比较两个结构体的每个成员。</p><p><em>结构体嵌入和匿名成员</em></p><ul><li>匿名成员：只声明一个成员对应的数据类型而不指名成员的名字，匿名成员的数据类型必须是<strong>命名的类型</strong>或<strong>指向一个命名的类型的指针</strong>。</li><li>结构体嵌入：对于匿名成员，可以认为其嵌入了结构体，可以<strong>直接访问叶子属性</strong>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>    Point <span class="hljs-comment">// 匿名成员</span><br>    Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>    Circle <span class="hljs-comment">// 匿名成员</span><br>    Spokes <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> w Wheel<br>w.X = <span class="hljs-number">8</span>            <span class="hljs-comment">// equivalent to w.Circle.Point.X = 8</span><br></code></pre></td></tr></table></figure><p>但是，结构体创建过程无法使用匿名成员的语法，只能使用以下语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">w = Wheel&#123;Circle&#123;Point&#123;<span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">20</span>&#125;<br><br>w = Wheel&#123;<br>    Circle: Circle&#123;<br>        Point:  Point&#123;X: <span class="hljs-number">8</span>, Y: <span class="hljs-number">8</span>&#125;,<br>        Radius: <span class="hljs-number">5</span>,<br>    &#125;,<br>    Spokes: <span class="hljs-number">20</span>, <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> trailing comma necessary here (and at Radius)</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>匿名成员拥有隐式的名字（就是<strong>类型名</strong>），两个相同类型的匿名成员也会导致歧义和成员冲突。且匿名成员的可见性与该成员类的可见性一致（因为匿名成员的名字与成员类的名字完全一样，大小写也一样）</p>          </div><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p><em>json包基本使用</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// other =&gt; json，返回一个[]byte，没有缩进</span><br>data, err := json.Marshal(movies)<br><span class="hljs-comment">// other =&gt; json，返回一个[]byte，有缩进，两个参数分别代表每个json的前缀和每层的缩进</span><br>data, err := json.MarshalIndent(movies, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;    &quot;</span>)<br><span class="hljs-comment">// 结构体中配置json后的属性名</span><br>Year  <span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;released&quot;`</span><br>Color <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;color,omitempty&quot;`</span><br><br><span class="hljs-comment">// json =&gt; other</span><br><span class="hljs-keyword">type</span> titles []<span class="hljs-keyword">struct</span>&#123; Title <span class="hljs-type">string</span> &#125; <span class="hljs-comment">// 声明了一个结构体切片，且声明了该结构体的成员</span><br><span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;titles); <span class="hljs-comment">// 将data反序列化到titles数组地址中</span><br></code></pre></td></tr></table></figure><p><em>流式解码器</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 从resp.Body流解码JSON数据到result地址中</span><br>json.NewDecoder(resp.Body).Decode(&amp;result);<br></code></pre></td></tr></table></figure><h2 id="文本和HTML模板"><a href="#文本和HTML模板" class="headerlink" title="文本和HTML模板"></a>文本和HTML模板</h2><p><em>text&#x2F;template</em><br>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。action会触发一些其他行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义模板</span><br><span class="hljs-keyword">const</span> templ = <span class="hljs-string">`&#123;&#123;.TotalCount&#125;&#125; issues:</span><br><span class="hljs-string">&#123;&#123;range .Items&#125;&#125;----------------------------------------</span><br><span class="hljs-string">Number: &#123;&#123;.Number&#125;&#125;</span><br><span class="hljs-string">User:   &#123;&#123;.User.Login&#125;&#125;</span><br><span class="hljs-string">Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;</span><br><span class="hljs-string">Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days</span><br><span class="hljs-string">&#123;&#123;end&#125;&#125;`</span><br><br><span class="hljs-comment">// 生成模板对象</span><br>report, err := template.New(<span class="hljs-string">&quot;report&quot;</span>). <span class="hljs-comment">// 创建并返回一个模板report  </span><br>                Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;). <span class="hljs-comment">// 为模板注入函数</span><br>                Parse(templ)                                 <span class="hljs-comment">// 分析目标模板</span><br><span class="hljs-comment">// 执行模板</span><br>report.Execute(os.Stdout, result) <span class="hljs-comment">//指定输出，和输入</span><br></code></pre></td></tr></table></figure><p><em>html&#x2F;template</em><br><code>html/template</code>模板包使用和<code>text/template</code>包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以<strong>避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题</strong>。这个特性还可以避免一些长期存在的安全问题，比如通过生成<strong>HTML注入攻击</strong>，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><em>new函数</em><br>在 golang 中 new 是另外一种创建变量的方式。通过 new(T) 可以创建 T 类型的变量(这里 T 表示类型)，初始值为 T 类型的零值，返回值为其地址(地址类型是 <code>*T</code>)。使用 new 创建一个变量和先通过 var 初始化一个变量，然后对这个变量取地址没什么不同，唯一的区别是，<strong>通过 new 函数不需要引入变量名称，所以使用上更加简洁、便利</strong>。</p><p><a href="https://books.studygolang.com/gopl-zh/ch5/ch5-01.html">https://books.studygolang.com/gopl-zh/ch5/ch5-01.html</a></p><h1 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p><em>声明</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(parameter-list)</span></span> (result-list) &#123;<br>    body<br>&#125;<br><span class="hljs-comment">// 相同类型的形参可以一起声明，如x,y</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hypot</span><span class="hljs-params">(x,y <span class="hljs-type">float64</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(x*x + y*y)<br>&#125;<br></code></pre></td></tr></table></figure><p><em>函数的签名</em><br>函数的类型被称为函数的签名。如果两个函数<strong>形式参数列表</strong>和<strong>返回值列表</strong>中的<strong>变量类型一一对应</strong>，那么这两个函数被认为有相同的类型或签名。<br>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此<strong>形参和返回值的变量名对于函数调用者而言没有意义</strong>。<br><strong>注意：Go语言不支持函数的重载，即不允许同时声明具有相同名称但参数不同的函数，即使他们的签名并不同，其目的是为了让Go保持足够的简单。</strong></p><div class="note note-primary">            <p>实参通过<strong>值的方式传递</strong>，因此<strong>函数的形参是实参的拷贝</strong>。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如<strong>指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改</strong>。</p>          </div><blockquote><p>个人理解：变量名是地址的别名，用于值类型；指针是地址的直接引用，属于引用类型。</p></blockquote><p><em>多返回值</em><br>在Go中，一个函数可以返回多个值，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 指定多个返回值的类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiReturn</span><span class="hljs-params">()</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;error message!&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 也可以连续声明，并赋予返回值变量名。且可以在函数中使用返回值变量（默认0值）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Size</span><span class="hljs-params">(rect image.Rectangle)</span></span> (width, height <span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">multiReturn</span><span class="hljs-params">()</span></span> (i, j <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">1</span> <span class="hljs-comment">// 可以直接为返回值变量赋值</span><br>j = <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> <span class="hljs-comment">// equals return i,j</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>准确的变量名可以传达函数返回值的含义，但也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息。</p></blockquote><h2 id="函数错误"><a href="#函数错误" class="headerlink" title="函数错误"></a>函数错误</h2><p><em>错误定义</em></p><ul><li>大部分函数无法确保成功执行，因为错误的原因超出了程序员的控制（如IO错误）。</li><li>对于将运行失败看作预期结果的函数，会返回一个额外的返回值来传递错误（bool 或 error）</li><li>error是一个接口，该类型可以为nil 和 non-nil，当其为nil时代表有错误发生。</li></ul><blockquote><p>Go语言认为错误不同于异常，<strong>错误是预期内的而异常是预期外的</strong>。该设计原因是对于某个应该被处理的错误，将错误以异常的形式抛出会混乱对错误的描述，导致大量的无用信息。</p></blockquote><p><em>错误处理策略</em></p><ol><li>直接返回原错误或封装一次后返回</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url,err) <span class="hljs-comment">// fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>重试策略</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// eg:</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WaitForServer</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">const</span> timeout = <span class="hljs-number">1</span> * time.Minute<br>    deadline := time.Now().Add(timeout)<br>    <span class="hljs-keyword">for</span> tries := <span class="hljs-number">0</span>; time.Now().Before(deadline); tries++ &#123;<br>        _, err := http.Head(url)<br>        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// success</span><br>        &#125;<br>        log.Printf(<span class="hljs-string">&quot;server not responding (%s);retrying…&quot;</span>, err)<br>        time.Sleep(time.Second &lt;&lt; <span class="hljs-type">uint</span>(tries)) <span class="hljs-comment">// exponential back-off</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;server %s failed to respond after %s&quot;</span>, url, timeout)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>输出错误信息并结束程序</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// eg：</span><br><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err)<br>    os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 等效于</span><br><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatalf(<span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err) <span class="hljs-comment">// 打印后退出</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p></blockquote><ol start="4"><li>只记录错误信息，程序继续执行</li><li>直接忽略掉错误</li></ol><h2 id="函数值与匿名函数"><a href="#函数值与匿名函数" class="headerlink" title="函数值与匿名函数"></a>函数值与匿名函数</h2><p><em>函数值定义</em></p><ul><li>可以使用类似变量的方式声明、使用函数；</li><li>函数值属于引用变量，零值为nil；</li><li>函数值之间不能比较，也不能作为map的key。<strong>因为函数是有状态</strong>的，参见匿名函数的例子，其涉及到闭包技术。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义一个函数值</span><br>f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> n * n&#125;<br></code></pre></td></tr></table></figure></li></ul><p><em>匿名函数</em><br>函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。函数字面量允许我们在使用函数时，再定义它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squares</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        x++<br>        <span class="hljs-keyword">return</span> x * x<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := squares() <span class="hljs-comment">// f为一个匿名函数</span><br>    fmt.Println(f()) <span class="hljs-comment">// &quot;1&quot;</span><br>    fmt.Println(f()) <span class="hljs-comment">// &quot;4&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 匿名函数递归使用前必须声明为一个变量，否则无法递归使用（因为生成函数值时变量还不存在）</span><br>visitAll := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span> &#123;<br>    visitAll(m[item]) <span class="hljs-comment">// compile error: undefined: visitAll</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>迭代变量陷阱</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 代码要求先创建若干文件，并将删除该文件的函数存储，随后统一执行</span><br><span class="hljs-comment">// 下面代码是正确的，其正确的使用临时变量代替循环变量传入函数值</span><br><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> tempDirs() &#123;<br>    dir := dir <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> necessary!</span><br>    os.MkdirAll(dir, <span class="hljs-number">0755</span>) <span class="hljs-comment">// creates parent directories too</span><br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dir)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">for</span> _, rmdir := <span class="hljs-keyword">range</span> rmdirs &#123;<br>    rmdir() <span class="hljs-comment">// clean up</span><br>&#125;<br><br><span class="hljs-comment">// 下面代码是错误的，因为循环变量i也会被传入函数值</span><br><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>dirs := tempDirs()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dirs); i++ &#123;<br>    os.MkdirAll(dirs[i], <span class="hljs-number">0755</span>) <span class="hljs-comment">// OK</span><br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dirs[i]) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中<code>dir := dir</code>是必要的，因为：</p><ul><li>匿名函数的函数值记录的是循环变量的内存地址，而不是其创建时刻的值。</li><li>循环中循环变量共享相同的循环内存地址。</li></ul><h2 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h2><p><em>可变参数函数</em><br>参数数量可变的函数称为可变参数函数。在声明可变参数函数时，需要在参数列表的<strong>最后一个参数类型</strong>之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>        total += val<br>    &#125;<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数体中，vals被看作是类型为<code>[] int</code>的切片，但可变参数函数和以切片作为参数的函数不同：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">([]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// &quot;func(...int)&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, g) <span class="hljs-comment">// &quot;func([]int)&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Deferred函数"><a href="#Deferred函数" class="headerlink" title="Deferred函数"></a>Deferred函数</h2><p><em>deferred定义</em><br>在调用普通函数或方法前加上<strong>关键字defer</strong>，就完成了defer所需要的语法，相当于<code>finally</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">title</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    resp, err := http.Get(url)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> resp.Body.Close()<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。<strong>通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放</strong>。释放资源的defer应该直接跟在请求资源的语句后。</p><p><em>其他特点</em></p><ul><li>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。</li><li>不要忘记defer语句后的<code>()</code>，其保证指定的函数在方法退出时执行，并且其可以使用返回值，并<strong>修改返回值</strong>（无论是基本类型还是引用类型）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">double</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Printf(<span class="hljs-string">&quot;double(%d) = %d\n&quot;</span>, x,result) &#125;()<br>    <span class="hljs-keyword">return</span> x + x<br>&#125;<br>_ = double(<span class="hljs-number">4</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> (a <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">// return 2</span><br>    a = <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">// last execute</span><br>       a = <span class="hljs-number">2</span>  <br>    &#125;()  <br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;  <br>       a = <span class="hljs-number">3</span>  <br>    &#125;()  <br>    <span class="hljs-keyword">return</span> a  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>同一函数中的多个defer语句的函数会<strong>由下至上</strong>的执行。</li><li>循环体中的defer语句只会在所有循环执行完毕后执行，如果需要在循环内执行，需要将循环的语句提取成一个单独的函数。</li></ul><h2 id="Panic与Recover"><a href="#Panic与Recover" class="headerlink" title="Panic与Recover"></a>Panic与Recover</h2><p><em>Panic异常</em><br>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。此外，直接调用内置的panic函数也会引发panic异常；<br><em>Panic异常后</em><br>一般而言，当panic异常发生时，程序会<strong>中断运行</strong>，并立即执行在该goroutine中被延迟的函数（<strong>defer 机制</strong>）。随后，程序崩溃并输出日志信息。日志信息包括panic value（错误信息）和函数调用的堆栈跟踪信息。</p><p><em>Panic的使用场景</em><br>由于panic会引起程序的崩溃，因此panic一般用于<strong>严重错误</strong>，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。<br>在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I&#x2F;O操作都应该被优雅的处理，<strong>最好的处理方式，就是使用Go的错误机制</strong>。</p><p><em>JAVA与GO的异常对比</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231102224111.png"></p><p><em>Recovery捕获Panic</em><br>如果在<code>deferred函数</code>中调用了<code>内置函数recover</code>，并且<code>定义该defer语句的函数</code>发生了panic异常，recover会使程序从panic中恢复，并返回<code>panic value</code>，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> (s *Syntax, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 从recover()获取异常信息</span><br>            err = fmt.Errorf(<span class="hljs-string">&quot;internal error: %v&quot;</span>, p) <span class="hljs-comment">// 这里将其以error的方式返回，实现了panic捕获</span><br>        &#125;<br>    &#125;()<br>    <span class="hljs-comment">// ...parser...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不应该试图去恢复其他包引起的panic，也不应该恢复所有的panic，安全的做法是有选择性的recover，即只恢复应该被恢复的panic异常，</p><blockquote><p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。</p></blockquote><h1 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h1><h2 id="方法基础"><a href="#方法基础" class="headerlink" title="方法基础"></a>方法基础</h2><p><em>方法定义</em><br>在函数声明时，在其<strong>函数名之前放上一个变量</strong>，即是一个方法，当于<strong>为这种类型定义了一个独占的函数</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><span class="hljs-comment">// traditional function</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span></span> <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><span class="hljs-comment">// same thing, but as a method of the Point type</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(Distance(p, q)) <span class="hljs-comment">// &quot;5&quot;, function call，调用的是包级别函数</span><br>fmt.Println(p.Distance(q))  <span class="hljs-comment">// &quot;5&quot;, method call，调用的是结构体的方法</span><br></code></pre></td></tr></table></figure><p><em>使用规则</em></p><ul><li>Go语言中，能够给任意类型定义方法，包括切面、基础数据类型等；</li><li>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名。</li></ul><h2 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h2><p><em>基于指针对象的方法</em><br>如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>    p.X *= factor<br>    p.Y *= factor<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的名字是：<code>(*Point).ScaleBy</code>，因为如果没有括号的话可能被理解为<code>*(Point.ScaleBy)</code>。</p><p><em>使用规则</em></p><ul><li>在现实的程序里，一般会<strong>约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器</strong>，即使是那些并不需要这个指针接收器的函数。</li><li>在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> P *<span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(P)</span></span> f() &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// compile error: invalid receiver type</span><br></code></pre></td></tr></table></figure><ul><li>Go语法糖可以避免我们每次调用指针对象方法时先将对象转指针，但这只是方法调用时的语法糖，仍需要注意声明方法时接收器是指针类型与非指针类型两者的区别（涉及接收器是否拷贝以及一些封装调用）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">r := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><span class="hljs-comment">// 天然写法与等效写法</span><br>(&amp;r).ScaleBy(<span class="hljs-number">2</span>)  &lt;==&gt; r.ScaleBy(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 但对于其他封装好的调用，无法通过原类型使用指针类型方法：</span><br>fmt.Println(x) <span class="hljs-comment">// 调用x方法的String而不是*x方法的String</span><br></code></pre></td></tr></table></figure><ul><li>Nil 也可以作为指针类型被合法接受。</li></ul><h2 id="内嵌结构体方法"><a href="#内嵌结构体方法" class="headerlink" title="内嵌结构体方法"></a>内嵌结构体方法</h2><p><em>内嵌结构体方法</em><br>类似于内嵌结构体中外部结构体可以直接访问内部结构体的成员，外部结构体也可以直接调用内部结构体的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 内部结构体</span><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><span class="hljs-comment">// 内部结构体方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> xaddY() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> p.X + p.Y<br>&#125;<br><span class="hljs-comment">// 外部结构体</span><br><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br>Point<br>Color color.RGBA<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;<br>cp := ColoredPoint&#123;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, red&#125;<br><span class="hljs-comment">// !!可以直接调用内部结构体函数</span><br>cp.xaddY()<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从实现的角度来看，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法。</p><blockquote><p>内嵌结构体方法的调用很像JAVA中子类调用父类方法一样，但这是错误的理解。通过为子结构体定义方法能更好的解耦一个结构体的各部分，而内嵌结构体方法则是一种为了方便调用子结构体方法的语法糖。</p></blockquote><p><em>内嵌结构体方法注意事项</em></p><ul><li>子结构体的方法访问不到父结构体的字段。</li><li>当编译器解析一个选择器到方法时，它会首先去找直接定义在这个类型里的方法，然后再找的内嵌字段们引入的方法，调用的优先级是层序迭代遍历，如果同一层中有两个同名方法，即存在二义性，此时编译器会报错，即：<ul><li>如果类型和内嵌字段都引入了相同的方法，会优先调用类型自身的方法</li><li>如果同级的若干个内嵌字段都引入了相同的方法，并试图使用匿名方式调用，则编译器会报错。</li></ul></li></ul><p><em>方法值</em><br>方法可以被从对象中取出调用，即<strong>方法值</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义p,q结构体变量</span><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-comment">// 从p变量中获取函数调用</span><br>distanceFromP := p.Distance        <span class="hljs-comment">// method value</span><br>fmt.Println(distanceFromP(q))      <span class="hljs-comment">// &quot;5&quot;</span><br></code></pre></td></tr></table></figure><p>该<strong>方法值</strong>绑定了原对象。</p><p><em>表达式</em><br>如果希望方法值不绑定对象，而是可以选择对象进行调用，则需要使用<strong>表达式</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>distance := Point.Distance   <span class="hljs-comment">// method expression</span><br>fmt.Println(distance(p, q))  <span class="hljs-comment">// &quot;5&quot;</span><br></code></pre></td></tr></table></figure><p>表达式的参数会比原方法多一个，其第一个参数用于指定接收器（与JAVA中的反射Method有点类似）</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><em>封装定义</em><br>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。</p><p><em>方法可见性</em><br>大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而<strong>如果我们想要封装一个对象，我们必须将其定义为一个struct</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>    words []<span class="hljs-type">uint64</span> <span class="hljs-comment">// 禁止其他包操作底层数组</span><br>&#125;<br><br><span class="hljs-keyword">type</span> IntSet []<span class="hljs-type">uint64</span> <span class="hljs-comment">// 允许其他包操作底层数组</span><br></code></pre></td></tr></table></figure><p><em>Go的set与get</em><br>只用来访问或修改内部变量的函数被称为setter或者getter，在命名一个getter方法时，我们通常会省略掉前面的Get前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> log<br><span class="hljs-keyword">type</span> Logger <span class="hljs-keyword">struct</span> &#123;<br>    flags  <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">// 省略get前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span></span> Flags() <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span></span> SetFlags(flag <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h1 id="七、接口"><a href="#七、接口" class="headerlink" title="七、接口"></a>七、接口</h1><h2 id="接口基础"><a href="#接口基础" class="headerlink" title="接口基础"></a>接口基础</h2><p><em>接口定义</em><br>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接口也可以组合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader <span class="hljs-comment">// Reader接口</span><br>    Writer <span class="hljs-comment">// Writer接口</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>接口的实现</em><br>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。（不需要定义一个具体类型和它实现的接口之间的关系。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br><span class="hljs-comment">// 只要是实现了接口方法，都可以被赋值</span><br>w = os.Stdout           <span class="hljs-comment">// OK: *os.File has Write method</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)   <span class="hljs-comment">// OK: *bytes.Buffer has Write method</span><br><br><span class="hljs-comment">// 同上</span><br><span class="hljs-keyword">var</span> rwc io.ReadWriteCloser<br>rwc = os.Stdout         <span class="hljs-comment">// OK: *os.File has Read, Write, Close methods</span><br><br><span class="hljs-comment">// 因为ReadWriteCloser聚合了Writer，可以将rwc赋值给w</span><br>w = rwc <span class="hljs-comment">// OK: io.ReadWriteCloser has Write method</span><br><span class="hljs-comment">// 但w不能赋值给rwc</span><br>rwc = w <span class="hljs-comment">// compile error: io.Writer lacks Close method</span><br></code></pre></td></tr></table></figure><p><em>指针类型对接口的实现</em><br>类型是否实现了接口取决于该类型是否实现了对应方法，但应当注意到指针类型所定义的方法不属于该类型，即<strong>如果只是指针类型实现了接口，该类型本身并没有实现该接口</strong>。（能通过类型变量调用指针接口只是语法糖）</p><p><em>空接口</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-comment">// 可以将任意一个值赋给空接口类型。</span><br>any = <span class="hljs-literal">true</span><br>any = <span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure><h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p><em>接口类型的结构</em><br>接口类型零值：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231112234228.png"></p><p><em>接口类型</em><br>一个接口值<strong>基于它的动态类型</strong>被描述为空或非空，随着为其赋值，其type和value会随之改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创造一个空值接口</span><br><span class="hljs-keyword">var</span> w io.Writer <span class="hljs-comment">// 此处，io.Writer的默认type为nil，而不是io.Writer</span><br>w == <span class="hljs-literal">nil</span> <span class="hljs-comment">// true</span><br>w = os.Stdout <span class="hljs-comment">// 修改w的Type为*os.File，修改w的value为一个os.File的指针</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// 修改w的Type为*byte.Buffer，修改w的value为bytes.Buffer的指针</span><br>w = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 重置type和value为nil</span><br></code></pre></td></tr></table></figure><p><em>接口值比较</em><br>接口值可以使用<code>==</code>和<code>!＝</code>来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的<code>==</code>操作相等。<br>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic。</p><p><em>包含nil指针的接口不是nil接口</em><br><strong>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buf *bytes.Buffer <span class="hljs-comment">// 对于这个接口值的声明，其value为nil，但动态类型type是*bytes.Buffer的（因为选择了具体接口的指针为类型）</span><br>buf == <span class="hljs-literal">nil</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231112235416.png"></p><h2 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a>sort.Interface接口</h2><p><em>sort.Interface</em><br>sort包内置的提供了根据一些排序函数来对任何序列排序的功能。Go语言的<code>sort.Sort</code>函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型<code>sort.Interface</code>来指定通用的排序算法和可能被排序到的序列类型之间的约定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<br><br><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>    Len() <span class="hljs-type">int</span><br>    Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> <span class="hljs-comment">// i, j are indices of sequence elements</span><br>    Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><em>reverse</em><br>如果需要倒序排列，我们不需要重新对接口进行实现。sort包提供了<code>sort.Reverse</code>函数值，通过将一个实现了<code>sort.Interface</code>的结构体传入该函数，会构造一个<code>sort.reverse</code>结构体的对象。<br>该结构体通过内嵌隐式的实现了<code>Len</code>和<code>Swap</code>方法，并重写了<code>Less</code>函数，因此其也是一个<code>sort.Interface</code>，可以对其调用<code>sort.Sort</code>实现逆序排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用</span><br>sort.Sort(sort.Reverse(byArtist(tracks)))<br><br><span class="hljs-comment">// 源码</span><br><span class="hljs-keyword">package</span> sort<br><span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span>&#123; Interface &#125; <span class="hljs-comment">// that is, sort.Interface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> r.Interface.Less(j, i) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span></span> Interface &#123; <span class="hljs-keyword">return</span> reverse&#123;data&#125; &#125;<br></code></pre></td></tr></table></figure><p><em>Int切片排序</em><br><code>[]int</code>并没有实现<code>sort.Interface</code>接口，sort包为其提供了特殊的排序版本，以及对其的包装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">// 整数排序</span><br>sort.Ints(values)<br><span class="hljs-comment">// 包装后倒序排序</span><br>sort.Sort(sort.Reverse(sort.IntSlice(values)))<br></code></pre></td></tr></table></figure><h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a>http.Handler接口</h2><p><em>handler接口</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><span class="hljs-comment">// handler接口，可以将该接口的实现传入ListenAndServe函数</span><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><span class="hljs-comment">// ListenAndServe主函数，绑定server地址和handler</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-type">string</span>, h Handler)</span></span> <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 某个实现该接口的类：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-comment">// 根据url判断如何返回值</span><br>    <span class="hljs-keyword">switch</span> req.URL.Path &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/list&quot;</span>:<br>    <span class="hljs-comment">// 返回匹配的handler结果</span><br>        fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, <span class="hljs-string">&quot;toy&quot;</span>, <span class="hljs-number">50</span>)<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/price&quot;</span>:<br>        fmt.Fprintf(w, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-number">30</span>)<br>    <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 匹配失败，返回404</span><br>        w.WriteHeader(http.StatusNotFound) <span class="hljs-comment">// 404</span><br>        <span class="hljs-comment">// 等效于</span><br>        <span class="hljs-comment">// http.Error(w, msg, http.StatusNotFound) // 404</span><br>        fmt.Fprintf(w, <span class="hljs-string">&quot;no such page: %s\n&quot;</span>, req.URL)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>ServeMux</em><br>可以使用<code>ServerMux</code>实现了<code>http.Handler</code>接口，且其自身可以做路径和处理器的匹配：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;<br>    mux := http.NewServeMux()<br>    mux.Handle(<span class="hljs-string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))<br>    mux.Handle(<span class="hljs-string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, mux))<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>http.HandlerFunc</code>是一个转换器，传入一个函数值，其会对函数进行转换，使其实现统一的方法<code>ServeHTTP</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;<br>    f(w, r)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了简化转化的步骤，也可以直接调用<code>mux.HandleFunc</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;<br>    http.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)<br>    http.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)<br>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h2><p><em>error接口</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>errors包</em><br>errors包提供了New函数用于快速的创建一个error——<code>*errorString</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125; &#125;<br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123; text <span class="hljs-type">string</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.text &#125;<br></code></pre></td></tr></table></figure><p><em>fmt.Errorf</em><br>fmt提供了更方便的Errors.New函数，来返回一个<code>*errorString</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> errors.New(Sprintf(format, args...))<br>&#125;<br></code></pre></td></tr></table></figure><p><em>Errno</em><br>Errno是一个实现error的数字类型，会从字符串表中返回一个标准的Unix平台错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> syscall<br><span class="hljs-keyword">type</span> Errno <span class="hljs-type">uintptr</span> <span class="hljs-comment">// operating system error code</span><br><span class="hljs-keyword">var</span> errors = [...]<span class="hljs-type">string</span>&#123;<br>    <span class="hljs-number">1</span>:   <span class="hljs-string">&quot;operation not permitted&quot;</span>,   <span class="hljs-comment">// EPERM</span><br>    <span class="hljs-number">2</span>:   <span class="hljs-string">&quot;no such file or directory&quot;</span>, <span class="hljs-comment">// ENOENT</span><br>    <span class="hljs-number">3</span>:   <span class="hljs-string">&quot;no such process&quot;</span>,           <span class="hljs-comment">// ESRCH</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-type">int</span>(e) &amp;&amp; <span class="hljs-type">int</span>(e) &lt; <span class="hljs-built_in">len</span>(errors) &#123;<br>        <span class="hljs-keyword">return</span> errors[e]<br>    &#125;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;errno %d&quot;</span>, e)<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span> = syscall.Errno(<span class="hljs-number">2</span>)<br>fmt.Println(err.Error()) <span class="hljs-comment">// &quot;no such file or directory&quot;</span><br>fmt.Println(err)         <span class="hljs-comment">// &quot;no such file or directory&quot;</span><br></code></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><em>类型断言</em><br>通过<code>变量.(类型)</code>可以判断其是否为对应类型：如果是，则将其以该类型的形式返回；如果不是，则抛出panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>f := w.(*os.File)      <span class="hljs-comment">// success: f == os.Stdout</span><br></code></pre></td></tr></table></figure><p>如果<strong>类型断言使用的是一个接口而不是实际类型</strong>，则会判断该变量是否实现了该接口：如果是，则将其以该接口的形式返回；如果不是，则抛出panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>rw := w.(io.ReadWriter) <span class="hljs-comment">// success: *os.File has both Read and Write</span><br>w = <span class="hljs-built_in">new</span>(ByteCounter)<br>rw = w.(io.ReadWriter) <span class="hljs-comment">// panic: *ByteCounter has no Read method</span><br></code></pre></td></tr></table></figure><p>如果变量为nil，则其始终会失败并抛出panic。</p><blockquote><p>类型断言相当于java的类型强转：a &#x3D; (A)b</p></blockquote><p><em>多返回值类型断言</em><br>如果类型断言出现在一个预期有两个结果的赋值操作中，这个操作<strong>不会在失败的时候发生panic</strong>，而是返回额外的一个结果，该结果是一个标识成功与否的布尔值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer = os.Stdout<br>f, ok := w.(*os.File)      <span class="hljs-comment">// success:  ok, f == os.Stdout</span><br>b, ok := w.(*bytes.Buffer) <span class="hljs-comment">// failure: !ok, b == nil</span><br></code></pre></td></tr></table></figure><p><em>if语句连用</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> w, ok := w.(*os.File); ok &#123;<br>    <span class="hljs-comment">//原来的变量名重用，其实是声明了一个同名的新的本地变量，外层原来的w不会被改变</span><br>&#125;<br></code></pre></td></tr></table></figure><p><em>基于类型断言区别错误类型</em><br>以文件IO异常为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> os<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPermission</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// PathError是一个Error，其封装了一个底层Error，并提供了相关的信息，其有点类似Java的子类</span><br><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>    Op   <span class="hljs-type">string</span><br>    Path <span class="hljs-type">string</span><br>    Err  <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error()<br>&#125;<br></code></pre></td></tr></table></figure><p>利用类型断言：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> pe, ok := err.(*PathError); ok &#123;<br>        err = pe.Err<br>    &#125;<br>    <span class="hljs-keyword">return</span> err == syscall.ENOENT || err == ErrNotExist<br>&#125;<br></code></pre></td></tr></table></figure><p><em>基于类型断言查看接口</em><br>对于一个类型，希望其调用一个函数时根据是否做了更详细的实现而做出不同的行为，可以使用类型断言，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关键方法（可以认为是手动实现的多态函数调用）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeString</span><span class="hljs-params">(w io.Writer, s <span class="hljs-type">string</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">type</span> stringWriter <span class="hljs-keyword">interface</span> &#123;<br>        WriteString(<span class="hljs-type">string</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果w还实现了WriteString方法，则优先调用该方法</span><br>    <span class="hljs-keyword">if</span> sw, ok := w.(stringWriter); ok &#123;<br>        <span class="hljs-keyword">return</span> sw.WriteString(s) <span class="hljs-comment">// avoid a copy</span><br>    &#125;<br>    <span class="hljs-comment">// 否则，调用io.Writer的默认方法</span><br>    <span class="hljs-keyword">return</span> w.Write([]<span class="hljs-type">byte</span>(s)) <span class="hljs-comment">// allocate temporary copy</span><br>&#125;<br><br><span class="hljs-comment">// 使用，w是一个io.Writer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w io.Writer, contentType <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">if</span> _, err := writeString(w, <span class="hljs-string">&quot;Content-Type: &quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型分支"><a href="#类型分支" class="headerlink" title="类型分支"></a>类型分支</h2><p><em>接口被以两种不同的方式使用</em></p><ul><li>表达实现该接口的具体类型之间的相似性（有共同的方法名），重点在于方法。</li><li>利用接口值可以持有各种具体类型值得能力，将其视作一些类型的联合，类似子类型多态。</li></ul><p><em>利用接口值进行类型分支</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqlQuote</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">int</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">uint</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b, ok := x.(<span class="hljs-type">bool</span>); ok &#123;<br>        <span class="hljs-keyword">if</span> b &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TRUE&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FALSE&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s, ok := x.(<span class="hljs-type">string</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> sqlQuoteString(s) <span class="hljs-comment">// (not shown)</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected type %T: %v&quot;</span>, x, x))<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 也可以使用switch，只有接口值才能使用.(type)关键词获取其实现类型。</span><br><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:       <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>, <span class="hljs-type">uint</span>: <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:      <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不同于JAVA，这里如果只想执行匹配成功的case时不需要在每个case内加break。</p></blockquote><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>一般情况下，不要为了仅有一个实现的类型创建接口，这种接口是不必要的抽象。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</li><li>例外情况下，例如接口和接口的具体实现存在于两个包中，则可以使用一个只被一个单一具体类型实现的接口。接口是解耦包的好方式。</li></ul><h1 id="八、Goroutines和Channels"><a href="#八、Goroutines和Channels" class="headerlink" title="八、Goroutines和Channels"></a>八、Goroutines和Channels</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p><em>goroutines</em><br>在Go语言中，每一个并发的执行单元叫作一个goroutine。新的goroutine会用go语言来创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> f()<br></code></pre></td></tr></table></figure><p><em>main goroutine</em><br>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。</p><p><em>注意匿名函数</em><br>注意匿名函数中的迭代陷阱：匿名函数的函数值记录的是循环变量的<strong>内存地址</strong>，而<strong>不是其创建时刻的值</strong>。且循环中循环变量共享相同的循环内存地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 正确的方式</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br>thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> correct!</span><br>&#125;(f) <span class="hljs-comment">// 这里将f显示的传递给了函数，这样函数值中本身就记录了当下的f</span><br>&#125;<br><br><span class="hljs-comment">// 错误的方式</span><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 试图使用匿名函数隐式调用外部变量，但外部变量因为迭代可能已经发生了变化</span><br>        thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p><em>channels</em><br>channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。<br>每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为<code>chan int</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// ch has type &#x27;chan int&#x27;</span><br><span class="hljs-comment">// 使用channel发送</span><br>ch &lt;- x<br><span class="hljs-comment">// 使用channel接受</span><br>x = &lt;-ch<br><span class="hljs-comment">// 空接受，忽略返回值</span><br>&lt;-ch<br></code></pre></td></tr></table></figure><p><em>channel的关闭</em><br>channel支持关闭操作，关闭后关于channel的所有<strong>发送操作都会导致panic异常</strong>，但<strong>已经发送成功的数据依然可以被接受</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure><p>当一个被关闭的channel中已经发送的数据都被成功接收后，<strong>后续的接收操作将不再阻塞</strong>，它们会立即返回一个零值。但如果本身业务的返回值就可能为0，则可能导致无法判断管道是否关闭，因此接受操作也存在变体形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x, ok := &lt;-ch<br></code></pre></td></tr></table></figure><p><em>不带缓存的channels</em><br>基于无缓存的channels对于发送者和接收者都是阻塞的，前者需要满足 <strong>消息被接受</strong> 后才能继续执行，后者需要满足 <strong>接受到消息</strong> 才能继续执行。因此，缓存Channels有时候也被称为<strong>同步Channels</strong>。<br>有时候通讯的事实和发生的时刻十分重要，当我们更希望强调通讯发生的时刻时，我们将它称为<strong>消息事件</strong>，这些消息事件可能并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，此时可以使用<code>ch &lt;- 1</code>这种简单的表达来发送信号。</p><p><em>串联的channels</em><br>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（<strong>pipeline</strong>）。<br><strong>可使用for循环持续获取管道数据，其会在管道关闭时退出</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> in &#123;<br>out &lt;- x * x<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br></code></pre></td></tr></table></figure><p><em>单方向的channels</em><br>一般我们会将channel作为参数传入goroutine的函数，而当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。<br>为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别<strong>用于只发送或只接收的channel</strong>。类型<code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。相反，类型<code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// chan&lt;- int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123;<br>        out &lt;- x<br>    &#125;<br>    <span class="hljs-built_in">close</span>(out)<br>&#125;<br></code></pre></td></tr></table></figure><p><em>带缓存的channels</em><br>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>对于基于缓存的channel，<strong>发送&#x2F;接受操作</strong>只会在<strong>缓存已满&#x2F;缓存已空</strong>的情况下阻塞。</p><p><em>goroutines泄漏</em><br>如果由于无阻塞条件始终无法达成（例如在无缓存情况下goroutines的数据没有线程接受）导致其永远卡住，这种情况被称为goroutines泄漏。和垃圾变量不同，<strong>泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的</strong>。</p><h2 id="并发的循环"><a href="#并发的循环" class="headerlink" title="并发的循环"></a>并发的循环</h2><p><em>sync.WaitGroup</em><br>waitgroup是一个计数器，可以认为其是一个<code>CountDownLatch</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个计数器</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-comment">// 添加n个计数，本质类似于初始化</span><br>wg.Add(n)<br><span class="hljs-comment">// 减少一个计数，可以认为是wg.Add(-1)</span><br>wg.Done()<br><span class="hljs-comment">// 阻塞，当wg计数为0时释放</span><br>wg.Wait()<br></code></pre></td></tr></table></figure><p>一般Add必须在其他goroutine开启前调用，如果放在goroutine中，则无法判断是Add后Done，还是goroutine还没有开始执行。</p><p><em>案例：感知并发的结束</em><br>主线程通过信号量感知所有goroutine执行完毕</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1.为了使程序感知到所有goroutine执行完毕，可以使用wg</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails6</span><span class="hljs-params">(filenames &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    sizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>)<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> f := <span class="hljs-keyword">range</span> filenames &#123;<br>    <span class="hljs-comment">// 1.每一个worker routine开启前，新增一个wg信号</span><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// worker</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            thumb, _ := thumbnail.ImageFile(f)<br>            info, _ := os.Stat(thumb)<br>            sizes &lt;- info.Size()<br>        &#125;(f)<br>    &#125;<br>    <br><span class="hljs-comment">// 执行到此处时，Add肯定执行完毕了，但worker并没有全部执行完成</span><br>    <span class="hljs-comment">// closer 线程，等待所有worker执行完成后关闭channel</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        wg.Wait()<br>        <span class="hljs-comment">// 3.关闭管道</span><br>        <span class="hljs-built_in">close</span>(sizes)<br>    &#125;()<br><br><span class="hljs-comment">// 2.循环获取channel内的数据</span><br>    <span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br>    <span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> sizes &#123;<br>        total += size<br>    &#125;<br>    <span class="hljs-comment">// 4.结束主线程循环，返回结果</span><br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><p><em>案例：BFS扫描并发</em><br>实现BFS的并发，每出现一个新的待扫描节点则向主线程新增一个信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 以下实现了一个并发的 BFS</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int</span> <span class="hljs-comment">// number of pending sends to worklist</span><br>    <span class="hljs-comment">// 信号初始化为1</span><br>    n++<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<br>    <span class="hljs-comment">// 首次调用接受 启动参数 n-- 到0</span><br>    <span class="hljs-comment">// 后续每处理一个需要迭代的过程则将n--</span><br>    <span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>    <span class="hljs-comment">// 处理一个迭代信息</span><br>        list := &lt;-worklist<br>        <span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<br>        <span class="hljs-comment">// 每有一个下一个迭代信息，令n++，要求主函数为其增加一次迭代调用</span><br>n++<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-type">string</span>)</span></span> &#123;<br>worklist &lt;- crawl(link)<br>&#125;(link)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 迭代结束</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p><em>基于select语句的多路复用</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> x := &lt;-ch2:<br>    <span class="hljs-comment">// ...use x...</span><br><span class="hljs-keyword">case</span> ch3 &lt;- y:<br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用一次select只会响应就绪的case：</p><ul><li>如果都不满足且没有default，则会阻塞，直到有事件触发。（一个没有任何case的select语句写作select{}，会永远地等待下去。）</li><li>如果存在多个case同时就绪时，则随机选择一个执行。</li></ul><p><em>time.Tick函数</em></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">// 生成一个<span class="hljs-built_in">tick</span> 的channel，同时生成一个goroutine定时向<span class="hljs-built_in">tick</span>中发信号（不会停止）<br><span class="hljs-built_in">tick</span> := <span class="hljs-built_in">time</span>.Tick(<span class="hljs-number">1</span> * <span class="hljs-built_in">time</span>.Second)<br><span class="hljs-comment"></span><br><span class="hljs-comment">// 生成一个ticker，其是对tick的封装，可以通过ticker.C接受定时信号，也可以手动停止</span><br>ticker := <span class="hljs-built_in">time</span>.NewTicker(<span class="hljs-number">1</span> * <span class="hljs-built_in">time</span>.Second)<br>&lt;-ticker.C<br>ticker.Stop()<br></code></pre></td></tr></table></figure><p><em>处理零值channel</em><br>channel的零值是nil，对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。<br>因此，我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。</p><h2 id="并发的退出"><a href="#并发的退出" class="headerlink" title="并发的退出"></a>并发的退出</h2><p><em>并发的退出</em><br>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，这样会导致goroutine之间的共享变量落在未定义的状态上。<br>因此，令goroutine退出方法有：</p><ul><li>单goroutine：向chan发送一个信号通知goroutine停止运行；</li><li>多goroutine：利用select的机制和chan的关闭机制实现广播通知。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goroutine循环 select</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-comment">// 1.正常工作时，done中无数据，不走该case</span><br>    <span class="hljs-comment">// 2.当done被关闭后，可以从done中取到0值，因此select会触发该case</span><br>    <span class="hljs-keyword">case</span> &lt;-done:<br>        <span class="hljs-comment">// 清除资源占用后退出</span><br>        <span class="hljs-comment">// do sth</span><br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// 正常执行</span><br>        <span class="hljs-comment">// do sth</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>案例：令多个goroutine退出</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printString</span><span class="hljs-params">(string1 <span class="hljs-type">string</span>, done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>times := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-comment">// 返回退出</span><br><span class="hljs-comment">// do sth，释放资源，在当前代码下可能无法被完全执行</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">println</span>(string1 + <span class="hljs-string">&quot;:第&quot;</span> + strconv.Itoa(times) + <span class="hljs-string">&quot;次&quot;</span>)<br>&#125;<br>times++<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> printString(<span class="hljs-string">&quot;hello1&quot;</span>, done)<br><span class="hljs-keyword">go</span> printString(<span class="hljs-string">&quot;hello2&quot;</span>, done)<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-comment">// 关闭goroutines</span><br><span class="hljs-built_in">close</span>(done)<br><span class="hljs-comment">// 需要注意，这里close后主线程直接结束，无法保证goroutine的完成了资源的释放</span><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在Go中，<code>main</code>函数的退出是程序结束的标志。一旦<code>main</code>函数完成执行（包括通过<code>return</code>、<code>panic</code>或正常的函数结束），整个程序就会退出，而不会等待其他未完成的goroutine。<br>因此想要让goroutine正确的关闭，必须保证主函数的关闭时机在其他goroutine正确结束后，一般的方法有：使用sync.WaitGroup感知子函数正确退出后再退出。</p><h2 id="Goroutines与线程"><a href="#Goroutines与线程" class="headerlink" title="Goroutines与线程"></a>Goroutines与线程</h2><p><em>动态栈</em><br>一个goroutine的栈和OS线程不太一样的是，其大小并不是固定的，而是根据需要动态地伸缩。其最大值有1GB，比传统的固定大小的线程栈要大得多。</p><p><em>Goroutine调度</em><br>Go的运行时包含了其自己的调度器，其使用了一些技术，如m:n调度等。<br>Go调度器并不是一个硬件定时器，而是而是被Go语言“建筑”本身进行调度的，由于这种调度方式不需要进入内核的上下文，所以调度一个goroutine比调度一个OS线程代价要低得多</p><p><em>GOMAXPROCS</em><br>Go的调度器使用了一个叫GOMAXPROCS的变量决定有多少个操作系统的线程同时执行Go代码，其默认值为运行机器上的CPU的核心数。</p><p><em>Goroutine没有ID号</em><br>goroutine没有可以被程序员获取到的身份（id）的概念。因为thread-local总是被不合理的滥用。而Go的设计认为一个函数的行为应该仅由自己的参数所决定，而不是由其所运行在的线程所决定。</p><h1 id="九、基于共享变量的并发"><a href="#九、基于共享变量的并发" class="headerlink" title="九、基于共享变量的并发"></a>九、基于共享变量的并发</h1><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p><em>竞争条件</em><br>竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。<br><em>数据竞争</em><br>这个程序包含了一个特定的竞争条件，叫作数据竞争。无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。<br><em>避免数据竞争</em></p><ol><li>不要写变量</li><li>避免从多个goroutine访问变量</li><li>允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“<strong>互斥</strong>”</li></ol><h2 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a>sync.Mutex互斥锁</h2><p><em>sync.Mutex</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// 互斥锁</span><br>    mu sync.Mutex<br>    balance <span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure><p>在Lock和Unlock之间的代码段叫做临界区。</p><p><em>Mutex的不可重入性</em><br>Mutex<strong>不可重入</strong>，其理念是确保共享变量在程序执行时的关键点上能够保证不变性：当一个goroutine获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（即没有其他代码块正在读写共享变量）<br>通用的解决方案是将函数分离，内部存在一个不使用锁的函数，对外暴露一个使用锁的函数，由其调用内部函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对外暴露</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    deposit(amount)<br>&#125;<br><span class="hljs-comment">// 内部使用（不需要重入）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123; balance += amount &#125;<br></code></pre></td></tr></table></figure><h2 id="sync-RWMutex读写锁"><a href="#sync-RWMutex读写锁" class="headerlink" title="sync.RWMutex读写锁"></a>sync.RWMutex读写锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.RWMutex<br><span class="hljs-keyword">var</span> balance <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 读锁的加锁</span><br>    mu.RLock()<br>    <span class="hljs-comment">// 读锁的解锁</span><br>    <span class="hljs-keyword">defer</span> mu.RUnlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p>channel、mutex除了功能性的语义，还有<strong>内存同步</strong>的语义：</p><ul><li>通道（<code>channel</code>）的操作在内部包含了适当的内存屏障，以确保在发送和接收操作之间的正确同步，保证数据的可见性。</li><li>锁（<code>sync.Mutex</code>）不仅提供了互斥，也提供了内存屏障的作用。当一个 goroutine 通过 <code>mu.Lock()</code> 获取锁，并通过 <code>mu.Unlock()</code> 释放锁时，这确保了在锁内执行的所有操作对其他goroutine是可见的。</li></ul><h2 id="sync-Once惰性初始化"><a href="#sync-Once惰性初始化" class="headerlink" title="sync.Once惰性初始化"></a>sync.Once惰性初始化</h2><p><em>并发初始化问题</em><br>类似JAVA单例模式中的初始化，Go语言中的惰性初始化也会遇到并发问题。<br>在JAVA中，一般通过synchronize关键词即可实现方法的串行访问，考虑到锁的消耗，可以考虑双重校验锁的实现方式，避免后续每次访问都加锁。<br>在Go语言中，没有提供synchronize关键词，因此可以利用锁来手动实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 双重校验锁</span><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> instance *SingletonObject<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *SingletonObject &#123;<br><span class="hljs-keyword">if</span> instance == <span class="hljs-literal">nil</span> &#123;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">if</span> instance == <span class="hljs-literal">nil</span> &#123;<br>instance = &amp;SingletonObject&#123;&#125;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p><em>sync.Once</em><br>在 Go 语言中，<code>sync.Once</code> 是一个提供了一个简单的方法来确保某个函数在程序运行期间只被执行一次，其通过内部机制保证了<strong>线程安全</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> once sync.Once<br><span class="hljs-keyword">var</span> instance *SingletonObject<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span> *SingletonObject &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        instance = &amp;SingletonObject&#123;&#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><p>与JAVA的双重校验锁相比，其无需用户手动处理锁，无需用户使用volatile关键词保证属性的可见性，其隐藏了更多的细节。</p><h2 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h2><p><em>竞争检查器</em><br>go提供了竞争检查器（the race detector），只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。<br>另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对<code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code>等等的调用。<br>这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。</p><p><em>使用注意点</em></p><ul><li>竞争检查器只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。</li><li>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存。</li></ul><h2 id="并发的非阻塞缓存"><a href="#并发的非阻塞缓存" class="headerlink" title="并发的非阻塞缓存"></a>并发的非阻塞缓存</h2><p><em>基于锁的缓存</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>    res   result<br>    ready <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// closed when res is ready</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br>    <span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>    f     Func<br>    mu    sync.Mutex <span class="hljs-comment">// guards cache</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (value <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br>    memo.mu.Lock()<br>    e := memo.cache[key]<br>    <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// This is the first request for this key.</span><br>        <span class="hljs-comment">// This goroutine becomes responsible for computing</span><br>        <span class="hljs-comment">// the value and broadcasting the ready condition.</span><br>        e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>        memo.cache[key] = e<br>        memo.mu.Unlock()<br><br>        e.res.value, e.res.err = memo.f(key)<br><br>        <span class="hljs-built_in">close</span>(e.ready) <span class="hljs-comment">// broadcast ready condition</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// This is a repeat request for this key.</span><br>        memo.mu.Unlock()<br><br>        &lt;-e.ready <span class="hljs-comment">// wait for ready condition</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> e.res.value, e.res.err<br>&#125;<br></code></pre></td></tr></table></figure><p><em>基于通道</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A request is a message requesting that the Func be applied to key.</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>    key      <span class="hljs-type">string</span><br>    response <span class="hljs-keyword">chan</span>&lt;- result <span class="hljs-comment">// the client wants a single result</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span>&#123; requests <span class="hljs-keyword">chan</span> request &#125;<br><span class="hljs-comment">// New returns a memoization of f.  Clients must subsequently call Close.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br>    memo := &amp;Memo&#123;requests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> request)&#125;<br>    <span class="hljs-keyword">go</span> memo.server(f)<br>    <span class="hljs-keyword">return</span> memo<br>&#125;<br><br><span class="hljs-comment">// 客户请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    response := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)<br>    memo.requests &lt;- request&#123;key, response&#125;<br>    res := &lt;-response<br>    <span class="hljs-keyword">return</span> res.value, res.err<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Close() &#123; <span class="hljs-built_in">close</span>(memo.requests) &#125;<br><br><br><span class="hljs-comment">// 服务端</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> server(f Func) &#123;<br>    cache := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)<br>    <span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> memo.requests &#123;<br>        e := cache[req.key]<br>        <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// This is the first request for this key.</span><br>            e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>            cache[req.key] = e<br>            <span class="hljs-keyword">go</span> e.call(f, req.key) <span class="hljs-comment">// call f(key)</span><br>        &#125;<br>        <span class="hljs-keyword">go</span> e.deliver(req.response)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> call(f Func, key <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-comment">// Evaluate the function.</span><br>    e.res.value, e.res.err = f(key)<br>    <span class="hljs-comment">// Broadcast the ready condition.</span><br>    <span class="hljs-built_in">close</span>(e.ready)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> deliver(response <span class="hljs-keyword">chan</span>&lt;- result) &#123;<br>    <span class="hljs-comment">// Wait for the ready condition.</span><br>    &lt;-e.ready<br>    <span class="hljs-comment">// Send the result to the client.</span><br>    response &lt;- e.res<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十、包"><a href="#十、包" class="headerlink" title="十、包"></a>十、包</h1><p><em>包导入</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br>    <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。</p><p><em>包声明</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 包声明</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>通常来说，默认的包名就是包导入路径名的最后一段，因此<strong>即使两个包的导入路径不同，它们依然可能有一个相同的包名</strong>。但也有例外场景：</p><ol><li>main包的导入路径是无关紧要的，名字为main的包的目的是给go build构建一个命令信息。</li><li><code>_test.go</code>为后缀的Go源文件（译注：前面必须有其它的字符，因为以<code>_</code>或<code>.</code>开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以<code>_test</code>为后缀名的。所有以<code>_test</code>为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。</li><li>一些依赖版本号的管理工具会在<strong>导入路径后追加版本号</strong>信息，例如“gopkg.in&#x2F;yaml.<strong>v2</strong>”。这种情况下包的名字并不包含版本号后缀，而是yaml。</li></ol><p><em>包导入</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;crypto/rand&quot;</span><br>    mrand <span class="hljs-string">&quot;math/rand&quot;</span> <span class="hljs-comment">// 取别名以避免冲突</span><br>)<br></code></pre></td></tr></table></figure><p>选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。</p><p><em>匿名导入</em><br>允许包的匿名导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;image/png&quot;</span><br></code></pre></td></tr></table></figure><p>这样导入的包无法被显示使用，但会计算包级变量的初始化表达式和执行导入包的init初始化函数。</p><p><em>包命名</em><br>包名要简短、易懂、一般采用单数形式（除非要与具体类型区分）</p><p><em>包工具</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 下载包<br>go get ...<br><br><span class="hljs-regexp">//</span> 构建包<br>go build target_package<br><br><span class="hljs-regexp">//</span> 查看包文档<br>go doc time<br>godoc -http :<span class="hljs-number">8000</span> <span class="hljs-regexp">//</span> 查看包文档并显示到<span class="hljs-number">8000</span>端口<br><br><span class="hljs-regexp">//</span> 查询可用包的信息<br>go list ...<br><span class="hljs-regexp">//</span> 通过-json可以展示更完整的元数据<br>go list package -json<br></code></pre></td></tr></table></figure><p><em>内部包</em><br>Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。<br>这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。</p><h1 id="十一、测试"><a href="#十一、测试" class="headerlink" title="十一、测试"></a>十一、测试</h1><p><em>go_test</em><br>所有以<code>_test.go</code>为后缀名的源文件在执行go build时不会被构建成包的一部分。</p><p><em>测试函数</em><br>每个测试函数必须导入testing包。测试函数有如下的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过外部测试包，可以防止包的循环依赖：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F/Pasted-image-20231221162213.png"></p><p><em>测试覆盖率</em></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 测试包覆盖率（通过为函数生成切面实现），并输出到控制台</span><br>go <span class="hljs-keyword">test</span> -<span class="hljs-keyword">run</span>=Coverage -coverprofile=c.<span class="hljs-keyword">out</span> target_package<br></code></pre></td></tr></table></figure><p><em>基准测试</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 测试对应的函数，.代表所有<br>go test -bench=.<br></code></pre></td></tr></table></figure><p><em>剖析</em></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">go <span class="hljs-keyword">test</span> -cpuprofile=<span class="hljs-meta">cpu</span><span class="hljs-number">.</span><span class="hljs-keyword">out</span><br>go <span class="hljs-keyword">test</span> -blockprofile=block<span class="hljs-number">.</span><span class="hljs-keyword">out</span><br>go <span class="hljs-keyword">test</span> -memprofile=mem<span class="hljs-number">.</span><span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><ul><li>CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。</li><li>堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。</li><li>阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</li></ul><p><em>示例函数</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleIsPalindrome</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(IsPalindrome(<span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>))<br>    fmt.Println(IsPalindrome(<span class="hljs-string">&quot;palindrome&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>示例函数没有函数参数和返回值。</p><ol><li>根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身。</li><li>在<code>go test</code>执行测试的时候也会运行示例函数测试。</li></ol><h1 id="十二、反射"><a href="#十二、反射" class="headerlink" title="十二、反射"></a>十二、反射</h1><h2 id="reflect-Type-和-reflect-Value"><a href="#reflect-Type-和-reflect-Value" class="headerlink" title="reflect.Type 和 reflect.Value"></a>reflect.Type 和 reflect.Value</h2><p><em>reflect.Type</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取一个对象的反射类型（具体类型）</span><br>t := reflect.TypeOf(<span class="hljs-number">3</span>)  <span class="hljs-comment">// a reflect.Type</span><br>fmt.Println(t.String()) <span class="hljs-comment">// &quot;int&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// %T可以代表类型</span><br></code></pre></td></tr></table></figure><p><em>reflect.Value</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取一个对象的值反射</span><br>v := reflect.ValueOf(<span class="hljs-number">3</span>) <span class="hljs-comment">// a reflect.Value</span><br>fmt.Println(v)          <span class="hljs-comment">// &quot;3&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, v)   <span class="hljs-comment">// &quot;3&quot;</span><br>fmt.Println(v.String()) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> &quot;&lt;int Value&gt;&quot;,String方法只返回值类型</span><br><span class="hljs-comment">// 对值调用Type获取对应的reflect.Type</span><br>t := v.Type()           <span class="hljs-comment">// a reflect.Type</span><br><br><span class="hljs-comment">// 将值反射重新包装成对象interface&#123;&#125;</span><br>v := reflect.ValueOf(<span class="hljs-number">3</span>) <span class="hljs-comment">// a reflect.Value</span><br>x := v.Interface()      <span class="hljs-comment">// an interface&#123;&#125;</span><br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formatAtom</span><span class="hljs-params">(v reflect.Value)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">switch</span> v.Kind() &#123;<br>    <span class="hljs-keyword">case</span> reflect.Invalid:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;invalid&quot;</span><br>    <span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,<br>        reflect.Int32, reflect.Int64:<br>        <span class="hljs-keyword">return</span> strconv.FormatInt(v.Int(), <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,<br>        reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br>        <span class="hljs-keyword">return</span> strconv.FormatUint(v.Uint(), <span class="hljs-number">10</span>)<br>    <span class="hljs-comment">// ...floating-point and complex cases omitted for brevity...</span><br>    <span class="hljs-keyword">case</span> reflect.Bool:<br>        <span class="hljs-keyword">return</span> strconv.FormatBool(v.Bool())<br>    <span class="hljs-keyword">case</span> reflect.String:<br>        <span class="hljs-keyword">return</span> strconv.Quote(v.String())<br>    <span class="hljs-keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:<br>        <span class="hljs-keyword">return</span> v.Type().String() + <span class="hljs-string">&quot; 0x&quot;</span> +<br>            strconv.FormatUint(<span class="hljs-type">uint64</span>(v.Pointer()), <span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">// reflect.Array, reflect.Struct, reflect.Interface</span><br>        <span class="hljs-keyword">return</span> v.Type().String() + <span class="hljs-string">&quot; value&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过reflect-Value修改值"><a href="#通过reflect-Value修改值" class="headerlink" title="通过reflect.Value修改值"></a>通过reflect.Value修改值</h2><p><em>reflect.Value地址</em><br>有一些reflect.Values是可取地址的；其它一些则不可以。考虑以下的声明语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">2</span>                   <span class="hljs-comment">// value   type    variable?</span><br>a := reflect.ValueOf(<span class="hljs-number">2</span>)  <span class="hljs-comment">// 2       int     no</span><br>b := reflect.ValueOf(x)  <span class="hljs-comment">// 2       int     no</span><br>c := reflect.ValueOf(&amp;x) <span class="hljs-comment">// &amp;x      *int    no</span><br>d := c.Elem()            <span class="hljs-comment">// 2       int     yes (x)</span><br></code></pre></td></tr></table></figure><p>其中,a、b只是2的拷贝副本，c是x的指针的拷贝副本，但由于其值指向的是一个地址，我们通过对c解引用，可以得到一个可取地址的<code>reflect.Value</code>。</p><div class="note note-primary">            <p>个人理解：</p><ul><li><code>a</code> 和 <code>b</code> 是提供值的内容信息，它们没有提供实际对象的位置信息，所以你不能获取它们的地址。</li><li><code>c</code> 是x的位置信息的拷贝，通过对c使用解引用，可以得到其位置，即目标实体d。</li></ul><ol><li>**<code>reflect.ValueOf(x)</code>**：当你直接对 <code>x</code> 使用 <code>reflect.ValueOf(x)</code>，你得到的是 <code>x</code> 的一个副本的反射值。这个副本是不可寻址的，意味着你不能通过这个反射值修改原始变量 <code>x</code> 的值。这是因为反射机制在这种情况下仅提供了 <code>x</code> 值的一个快照。</li><li>**<code>reflect.ValueOf(&amp;x).Elem()</code>**：当你先对 <code>x</code> 的地址 <code>&amp;x</code> 使用 <code>reflect.ValueOf(&amp;x)</code>，然后调用 <code>Elem()</code> 方法，你实际上是获取了 <code>x</code> 的地址的反射值，然后通过 <code>Elem()</code> 方法访问这个地址所指向的实际值。在这种情况下，你得到的反射值 <code>d</code> 是可寻址的，意味着你可以通过 <code>d</code> 来修改 <code>x</code> 的值。这是因为 <code>d</code> 直接引用了 <code>x</code>，而不是它的一个副本。</li></ol>          </div><p><strong>所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的。</strong><br>我们可以通过调用reflect.Value的CanAddr方法来判断其是否可以被取地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(c.CanAddr()) <span class="hljs-comment">// &quot;false&quot;</span><br>fmt.Println(d.CanAddr()) <span class="hljs-comment">// &quot;true&quot;</span><br></code></pre></td></tr></table></figure><p><strong>每当我们通过指针间接地获取的reflect.Value都是可取地址的，即使开始的是一个不可取地址的Value。</strong><br>例如，slice的索引表达式<code>e[i]</code>将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。以此类推，<code>reflect.ValueOf(e).Index(i)</code>对应的值也是可取地址的，即使原始的<code>reflect.ValueOf(e)</code>不支持也没有关系。</p><p><em>reflect.Value访问变量</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">2</span><br>d := reflect.ValueOf(&amp;x).Elem()   <span class="hljs-comment">// d refers to the variable x</span><br>px := d.Addr().Interface().(*<span class="hljs-type">int</span>) <span class="hljs-comment">// px := &amp;x</span><br>*px = <span class="hljs-number">3</span>                           <span class="hljs-comment">// x = 3</span><br>fmt.Println(x)                    <span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p>或者，不使用指针，而是通过调用可取地址的reflect.Value的reflect.Value.Set方法来更新对应的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">d.Set(reflect.ValueOf(<span class="hljs-number">4</span>))<br>fmt.Println(x) <span class="hljs-comment">// &quot;4&quot;</span><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>个人理解：</p><ol><li><strong>获取保险箱的钥匙</strong>：<code>reflect.ValueOf(&amp;x).Elem()</code> 相当于你拿到了一个可以打开保险箱的特殊钥匙（<code>d</code>）。这个钥匙让你能够接触并改变保险箱里的内容。</li><li><strong>准备要放进去的新内容</strong>：<code>reflect.ValueOf(4)</code> 就像你准备了新的物品（这里是数字 <code>4</code>），并把它放在一个特殊的容器里，这个容器能够和保险箱的钥匙（<code>d</code>）兼容。</li><li><strong>使用钥匙和特殊容器来更新保险箱的内容</strong>：<code>d.Set()</code> 方法就像是你使用钥匙打开保险箱，然后用准备好的特殊容器中的新物品（数字 <code>4</code>）来替换保险箱里原来的内容。</li></ol>          </div><p>相当于为一个reflect.Value设置一个reflect.Value，实现底层数据的替换。</p><p><em>Set方法</em><br>Set方法将在运行时执行和编译时进行类似的可赋值性约束的检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 编译检查</span><br>d.Set(reflect.ValueOf(<span class="hljs-type">int64</span>(<span class="hljs-number">5</span>))) <span class="hljs-comment">// panic: int64 is not assignable to int</span><br><br>x := <span class="hljs-number">2</span><br>b := reflect.ValueOf(x)<br>b.Set(reflect.ValueOf(<span class="hljs-number">3</span>)) <span class="hljs-comment">// panic: Set using unaddressable value</span><br><br><span class="hljs-comment">// 其他设置方法</span><br>d := reflect.ValueOf(&amp;x).Elem()<br>d.SetInt(<span class="hljs-number">3</span>)<br>fmt.Println(x) <span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p>Set方法总是尽可能地完成任务。以SetInt为例，只要变量是某种类型的有符号整数就可以工作，即使是一些命名的类型、甚至只要底层数据类型是有符号整数就可以，而且如果对于变量类型值太大的话会被自动截断。<br>但需要谨慎的是：对于一个引用interface{}类型的reflect.Value调用SetInt会导致panic异常，即使那个interface{}变量对于整数类型也不行。</p><p><em>CanSet</em><br>CanAddr方法并不能正确反映一个变量是否是可以被修改的。方法CanSet是用于检查对应的reflect.Value是否是可取地址并可被修改的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(fd.CanAddr(), fd.CanSet()) <span class="hljs-comment">// &quot;true false&quot;</span><br></code></pre></td></tr></table></figure><h2 id="获取结构体标签"><a href="#获取结构体标签" class="headerlink" title="获取结构体标签"></a>获取结构体标签</h2><p><em>根据请求解析结构体</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 属性值的string和reflectValue的映射</span><br>fields := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]reflect.Value)<br>v := reflect.ValueOf(ptr).Elem() <span class="hljs-comment">// the struct variable </span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<br>fieldInfo := v.Type().Field(i) <span class="hljs-comment">// a reflect.StructField</span><br>tag := fieldInfo.Tag           <span class="hljs-comment">// a reflect.StructTag</span><br>name := tag.Get(<span class="hljs-string">&quot;http&quot;</span>)<br><span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;<br>name = strings.ToLower(fieldInfo.Name)<br>&#125;<br>fields[name] = v.Field(i)<br>&#125;<br><br><span class="hljs-comment">// 从req.Form中提取值，并赋值给fileds的value</span><br><span class="hljs-keyword">for</span> name, values := <span class="hljs-keyword">range</span> req.Form &#123;<br>f := fields[name]<br><span class="hljs-keyword">if</span> !f.IsValid() &#123;<br><span class="hljs-keyword">continue</span> <span class="hljs-comment">// ignore unrecognized HTTP parameters</span><br>&#125;<br><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">if</span> f.Kind() == reflect.Slice &#123;<br>elem := reflect.New(f.Type().Elem()).Elem()<br><span class="hljs-keyword">if</span> err := populate(elem, value); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, name, err)<br>&#125;<br>f.Set(reflect.Append(f, elem))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> err := populate(f, value); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, name, err)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="显示类型的方法"><a href="#显示类型的方法" class="headerlink" title="显示类型的方法"></a>显示类型的方法</h2><p><em>Method方法</em><br>reflect.Type和reflect.Value都提供了一个Method方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">t := v.Type() <span class="hljs-comment">// reflect.Type</span><br>v := reflect.ValueOf(x) <span class="hljs-comment">// reflect.Value</span><br>t.Method(i) <span class="hljs-comment">// 返回一个reflect.Method结构体，该结构体描述t的第i个方法的名称和类型</span><br>v.Method(i) <span class="hljs-comment">// 返回一个reflect.Value表示对于的值</span><br></code></pre></td></tr></table></figure><h1 id="底层编程"><a href="#底层编程" class="headerlink" title="底层编程"></a>底层编程</h1><h2 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h2><p><em>unsafe.Sizeof</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br>fmt.Println(unsafe.Sizeof(<span class="hljs-type">float64</span>(<span class="hljs-number">0</span>))) <span class="hljs-comment">// &quot;8&quot;</span><br></code></pre></td></tr></table></figure><p><code>unsafe.Sizeof</code>函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式。<br>注意：</p><ul><li>Sizeof不会对表达式进行求值。</li><li>Sizeof函数返回的大小只包括数据结构中固定的部分</li></ul><blockquote><p>Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编译器可以随意地重新排列每个字段的内存位置。</p></blockquote><p><em>unsafe.Alignof</em><br><code>unsafe.Alignof</code> 函数返回对应参数的类型需要对齐的倍数。和 Sizeof 类似， Alignof 也是返回一个常量表达式，对应一个常量。</p><p><em>unsafe.offsetof</em><br><code>unsafe.Offsetof</code> 函数的参数必须是一个字段 <code>x.f</code>，然后返回 <code>f</code> 字段相对于 <code>x</code> 起始地址的偏移量，包括可能的空洞。</p><p><em>unsafe.Pointer</em><br><code>unsafe.Pointer</code>是特别定义的一种指针类型,，它可以包含任意类型变量的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">f <span class="hljs-type">float64</span><br>temp := unsafe.Pointer(&amp;f) <span class="hljs-comment">//将&amp;f转化为unsafe.Pointer</span><br>temp2 := (*<span class="hljs-type">uint64</span>)temp <span class="hljs-comment">// 将unsafe.Pointer转化为*T指针</span><br></code></pre></td></tr></table></figure><p><strong>注意区别</strong></p><ul><li>不可以直接通过<code>*p</code>来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。</li><li><code>unsafe.Pointer</code>指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。</li><li>一个<code>unsafe.Pointer</code>指针也可以被转化为<code>uintptr</code>类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。</li><li>将<code>unsafe.Pointer</code>指针转为原生数字，然后再转回为<code>unsafe.Pointer</code>类型指针的操作是不安全，因为GC会对内存进行整理，导致对象的地址发送变化，此时<code>unsafe.Pointer</code>会被更新，但<code>uintptr</code>不会。</li></ul><h2 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#cgo CFLAGS: -I/usr/include</span><br><span class="hljs-comment">#cgo LDFLAGS: -L/usr/lib -lbz2</span><br><span class="hljs-comment">#include &lt;bzlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">bz_stream* bz2alloc() &#123; return calloc(1, sizeof(bz_stream)); &#125;</span><br><span class="hljs-comment">int bz2compress(bz_stream *s, int action,</span><br><span class="hljs-comment">                char *in, unsigned *inlen, char *out, unsigned *outlen);</span><br><span class="hljs-comment">void bz2free(bz_stream* s) &#123; free(s); &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> writer <span class="hljs-keyword">struct</span> &#123;<br>    w      io.Writer <span class="hljs-comment">// underlying output stream</span><br>    stream *C.bz_stream<br>    outbuf [<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>]<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-comment">// NewWriter returns a writer for bzip2-compressed streams.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWriter</span><span class="hljs-params">(out io.Writer)</span></span> io.WriteCloser &#123;<br>    <span class="hljs-keyword">const</span> blockSize = <span class="hljs-number">9</span><br>    <span class="hljs-keyword">const</span> verbosity = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> workFactor = <span class="hljs-number">30</span><br>    w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;<br>    C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)<br>    <span class="hljs-keyword">return</span> w<br>&#125;<br></code></pre></td></tr></table></figure><p>其实并没有一个叫C的包，但是<code>import &quot;C&quot;</code>语句会让Go编译程序在编译之前先运行cgo工具，该工具会生成一个临时包，该包将包含所有需要在Go语言中访问的C语言的函数或类型。<br>cgo工具通过以某种特殊的方式调用本地的C编译器来发现在Go源文件导入声明前的注释中包含的C头文件中的内容。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-API</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go-API/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Golang/Go-API/</url>
    
    <content type="html"><![CDATA[<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 最大整数</span><br>math.MaxInt32<br>math.MaxInt64<br><br><span class="hljs-comment">// 取模，需要转化为int，否则会被认为是浮点数</span><br>mod := (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span> <br></code></pre></td></tr></table></figure><h1 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h1><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><p><em>动态数组创建</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 错误示例</span><br>n := <span class="hljs-number">1</span><br>b := [n]<span class="hljs-type">int</span>&#123;&#125; <span class="hljs-comment">// error,数组长度必须为常量</span><br><br><span class="hljs-comment">// 正确示例1</span><br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n)<br><br><span class="hljs-comment">// 正确示例2</span><br><span class="hljs-keyword">const</span> n = <span class="hljs-number">10</span><br>a := [n]<span class="hljs-type">int</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><em>二维数组创建</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">slice1 := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, len1)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> slice1 &#123;<br>slice1[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, len2)<br>&#125;<br><span class="hljs-keyword">return</span> slice1<br><br></code></pre></td></tr></table></figure><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p><em>append实现切片拷贝</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//函数签名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []Type, elems ...Type)</span></span> []Type<br><br><span class="hljs-comment">//使用</span><br>a := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment">// 在a后使用...，指明调用的时可变参数函数，可以通过这种方式直接接受切片，表示传入切片的所有元素</span><br><span class="hljs-comment">// 在空切片上添加a，由于切片长度不够，会新建一个切片，复制原切片内容并返回</span><br>b := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>),a...)<br></code></pre></td></tr></table></figure><p><em>copy实现切片拷贝</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//函数签名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">(dst, src []Type)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 使用</span><br>a :=[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-built_in">copy</span>(b,a)<br></code></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">t:=strings.Fields(s) <span class="hljs-comment">//使用该函数可切割单个/多个空格，提取出单词数组</span><br>strings.Join(t,<span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">//使用空格连接单词数组中的单词</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Go</category>
      
      <category>Go-API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis复习</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据类型与结构"><a href="#一、数据类型与结构" class="headerlink" title="一、数据类型与结构"></a>一、数据类型与结构</h1><p>基本数据结构：String、List、Set、Zset、Hash<br>高级数据结构：Bitmap、Geo、HyberLogLog、Stream</p><h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><p>type和encoding共同实现了redis对象的多态处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230103190014.png"></p><p><em>对象共享</em><br>redis也有常量池，存了命令返回值（”OK”）和10000以内整数，但不是所有对象都共享，否则复杂度较高，用其换取内存不划算。</p><p><em>引用计数</em><br>refCount引用计数归零后可被回收</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><em>编码</em><br>有三种编码类型：int、embstr、raw，其中字符串内容的字节超过一定阈值（不同版本阈值不一样）时使用raw。<br>int：long对象，与RedisObject一起分配内存。<br>embstr：SDS对象，与RedisObject一起分配内存，不可变（<strong>只读</strong>）。<br>raw：SDS对象，与RedisObject分开分配内存，可变。</p><p><em>限制</em><br>value最多容纳512M。</p><p><em>应用</em><br>缓存对象，计数，<strong>分布式锁</strong>（SETNX实现「key不存在才插入」，同时设置过期时间PX），Session（分布式环境下去同一个Redis）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET lock_key unique_value NX PX 10000<br></code></pre></td></tr></table></figure><p>优点：高性能，实现方便，避免单点故障<br>缺点：超时时间不好设置（解决：使用守护线程续约枷锁）、异步复制可能导致不可靠。</p><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>简单动态字符串（simple dynamic string,SDS）</p><p><em>组成</em><br><code>len</code>(字符串长度)+<code>alloc</code>(分配的字节数)+<code>flags</code>(类型标志)+<code>buf[]</code>(数据)<br><code>alloc-len</code>可以得到剩余空间的大小，作为是否需要扩容的依据。</p><p><em>优点</em></p><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。<ul><li>小于1MB时，翻倍扩容</li><li>大于1MB时，多给1MB空间</li></ul></li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li><li><strong>动态分配内存</strong>：节省空间，还会禁止编译器做优化对齐。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>按插入顺序排序。</p><p><em>编码</em><br>List 类型的底层数据结构是由<strong>双向链表</strong>或<strong>压缩列表</strong>实现的（元素个数小于512个且都小于64字节时使用压缩链表，否则使用双向链表。）<br>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 <strong>Quicklist</strong> 实现了。</p><p><em>应用</em><br>消息队列（不支持消费组）</p><ul><li>为避免消费者循环读取，提供了阻塞式读取。</li><li>若要处理重复信息：需要为每个消息打上全局ID。</li><li>消费者读取时将其存在另一个待完成list（备份）中。</li></ul><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cadf797496816eb343a19c2451437f1e.webp"><br>dup、free、match是可以自定义实现的函数。</p><p><em>优点</em><br>在于访问&#x2F;添加头节点尾节点快<br><em>缺点</em><br>在内存碎片多且浪费大</p><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/a3b1f6235cf0587115b21312fe60289c.webp"><br><em>组成</em></p><ul><li>zlbytes，记录整个压缩列表占用内存字节数（整个内存）；</li><li>zltail，记录压缩列表「尾部」节点距离起始地址由多少字节（entryN起始位置，便于查找），也就是列表尾的偏移量；</li><li>zllen，记录压缩列表包含的节点数量；</li><li>zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p><em>Entry组成</em></p><ul><li>prevlen，上一个节点的长度（占用1字节或5字节：以254字节为分界）</li><li>encoding，指定类型为字符串或整数以及其长度（整数占1字节，字符串占1&#x2F;2&#x2F;5字节）。</li><li>data，实际数据</li></ul><p><em>特点</em></p><ul><li>每个entry保存了本entry长度和前一个entry的长度，便于逆向搜索</li><li>每个entry的类型根据实际长度灵活变化</li></ul><p><em>优点</em><br>省空间</p><p><em>缺点</em></p><ul><li>entry内容变化时会改变prelen，prelen因此也变化长度，可能需要<strong>连锁更新</strong>；</li><li>节点数量过多时，搜索缓慢</li></ul><h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/f46cbe347f65ded522f1cc3fd8dba549.webp"><br>双向链表 + 压缩列表（控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题）。</p><h4 id="ListPack"><a href="#ListPack" class="headerlink" title="ListPack"></a>ListPack</h4><p>Redis7.0中取代了压缩列表<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/c5fb0a602d4caaca37ff0357f05b0abf.webp"><br>整体结构：相比压缩列表，少了尾部指针。<br>Entry结构：相比压缩列表，len放在末尾标识本entry长度，同样可以倒序。<br>暂未使用。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><em>编码</em><br><strong>压缩列表</strong>（元素个数小于512个，所有值小于64字节）或<strong>哈希表</strong></p><p><em>应用</em><br>缓存对象</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><code>dict</code> -&gt; <code>dictht</code> -&gt; <code>dictEntry[]</code><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2fedbc9cd4cb7236c302d695686dd478.webp"></p><p><em>rehash</em><br>触发条件：</p><ol><li>负载因子大于1且没有bgsave或bgrewriteaof任务。</li><li>负载因子大于5时。<br>过程：</li><li>正常过程写入<code>ht1</code>中。</li><li>扩容时，为<code>ht2</code>赋予一个长度为2倍<code>ht1</code>的哈希表。</li><li>逐步迁移数据。</li><li>释放「ht1」，并使用「ht2」替换「ht1」。</li></ol><p><em>渐进式rehash</em></p><ul><li>给「ht2」分配空间</li><li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作（查找时先找old再找new，新增时直接添加在new上）之外，还会<strong>顺序地</strong>（从第一个桶开始）将「ht1」中索引位置上的所有 key-value 迁移到「ht2」上；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「ht1」的所有 key-value 迁移到「ht2」，从而完成 rehash 操作。</li></ul><div class="note note-primary">            <p><em>扩展：rehash与ConcurrentHashMap的扩容方式相比，有什么区别？</em></p><ol><li>rehash单线程扩容，ConcurrentHashMap多线程扩容，一般而言后者更快</li><li>对于读操作，两者响应速度差不多</li><li>对于写操作，rehash更快，因为ConcurrentHashMap中线程需要帮助完成扩容，扩容完成后才进行真正的写操作。</li><li>对于删除操作，同写操作。</li></ol>          </div><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>无序集合，成员唯一。</p><p><em>编码</em><br>整数集合（元素数量不超过512）或哈希表</p><h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p><em>组成</em></p><ul><li><code>encoding</code>：标识整数的类型（int16、int32、int64）；</li><li><code>length</code>：记录压缩列表「尾部」节点距离起始地址由多少字节（entryN起始位置，便于查找），也就是列表尾的偏移量；</li><li><code>contents[]</code>：记录压缩列表包含的节点。</li></ul><p><em>升级</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/e84b052381e240eeb8cc97d6b729968b.webp"><br><strong>节省内存资源</strong>。且不支持降级。</p><p><em>应用</em><br>点赞、共同关注</p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>权重排序</p><p><em>编码</em><br><strong>压缩列表（小于128个元素，且元素小于64B）</strong> 或 <strong>跳表（加哈希表）</strong></p><p><em>应用</em><br>排行榜</p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>注意跳表是结合了dict结构使用的，但dict主要起常数时间获取权重的作用。<br><em>结构</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323223354.png"><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323215824.png"><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.webp"></p><ol><li>zskiplistNode：其包含ele（数据），score（权重），backward（前一个节点指针，便于后序遍历），zskiplistLevel数组；</li><li>zskipLevel：记录了指向节点的指针和距离；</li><li>zskipList：记录头尾指针、链表长度、最大层数。</li></ol><p><em>设计细节</em><br>查询</p><ul><li>为了实现快速跳跃，从<strong>头节点的最高层</strong>开始搜索：发现目标节点在该节点之后（目标权重更高或权重相同但键更大），继续同层搜索，否则降层搜索。<br>层次</li><li>相邻两层的节点数量的比例会影响跳表的查询性能，理想的比例是1:2，但会带来调整开销，所以选择随机生成每层的节点数：循环生成一个<code>[0,1]</code>的随机数，其小于0.25则加一层，直到大于0.25。最高为64层。</li><li>头节点不保存数据，64层。</li></ul><p><em>为什么使用跳表而不是红黑树？</em></p><ol><li>范围查找跳表更方便，找到端点后遍历即可，红黑树还要想办法中序遍历。</li><li>内存占比上，每个节点的指针更少。</li><li>算法实现更简单，不需要调整。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20231001212816.png"></p><ul><li>String：int&#x2F;SDS(embstr，raw)</li><li>List：ziplist&#x2F;linkedlist -&gt; quicklist(3.2) -&gt; ListPack</li><li>Hash：ziplist&#x2F;dict</li><li>Set：intset&#x2F;dict</li><li>Zset：ziplist&#x2F;skip</li></ul><p>list，hash，set，Zset都试图使用<strong>压缩列表</strong>（排序的压缩列表或整数集合）来处理数量小于512&#x2F;512&#x2F;512&#x2F;128个且大小都小于64字节的元素集合，否则使用高级数据结构。</p><h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>统计01<br><em>原理</em><br>string，二进制字节数组</p><p><em>应用</em><br>签到统计</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>不精确的去重计数，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数。</p><p><em>应用</em><br>日活</p><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>保存经纬度</p><p><em>编码</em><br>Zset</p><p><em>应用</em><br>打车</p><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>消息队列（基于内存的不可靠版）</p><p><em>特点</em></p><ul><li>可自动生成不重复、<strong>递增</strong>的id（eg：时间戳-序号）。</li><li>有消费组，组内消费者为竞争关系。</li><li>每个消费组维护一个pending_ids，保证可靠性。只有消费者回复ACK后才将其标记为完成，消费者宕机重启后可查看未处理完的消息。</li><li>其他消费组也可以将目标消费者<strong>超时未处理</strong>的消息转移到自己的pending列表</li><li>死信，转发一定次数后都无法被消费者处理的消息，可输出XDEL。</li></ul><p><em>与专业消息队列的差别</em></p><ul><li>redis基于内存，宕机时磁盘中不是最新数据，主从切换时同理。专业消息队列基于集群，有多个副本。</li><li>redis基于内存，可能OOM，而Kafka和RabbitMQ基于磁盘</li></ul><p><em>Stream会丢消息吗？</em></p><ul><li>生产者处理好与队列的ACK确认就，不会发生丢失。</li><li>消费者将消息处理完成后再XACK，不会发送丢失。</li><li>中间件会丢消息吗？会，AOF时没完成写盘，或主从复制切换。</li></ul><p><em>Stream能处理消息挤压吗？</em><br>Stream能指定最大长度，超出后旧消息会被删除。而传统MQ则会存在内存中。</p><h3 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h3><p>发布订阅是redis开放的一个通讯功能，消息队列stream是对其可靠性的补充。<br><em>两种发布&#x2F;订阅模式</em></p><ul><li>基于频道(Channel)的发布&#x2F;订阅：频道以哈希表结构保存，订阅同一频道的消费者以链表保存，发布的消息只发布给对于频道的消费者。</li><li>基于模式(pattern)的发布&#x2F;订阅：模式以链表结构保存，发布消息时，对每个模式进行表达式对比，然后选择发送。</li></ul><p><em>发布订阅方式（只适合即时通讯场景）为什么不能做消息队列</em></p><ul><li>不具有数据持久化</li><li>不保存历史信息</li><li>消息挤压时，消费者可能被强制断开</li></ul><h1 id="二、持久化"><a href="#二、持久化" class="headerlink" title="二、持久化"></a>二、持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><em>流程</em><br>主线程阻塞进行或子线程后台进行，使用COW技术应对主线程的修改。</p><p><em>执行策略</em></p><ul><li>主动执行：<ul><li>save&#x2F;bgsave</li></ul></li><li>自动执行：<ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul></li></ul><p><em>特点</em></p><ul><li>文件小，且加载速度快。</li><li>全量快照，执行缓慢，实时性差。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><em>流程</em><br>主线程先执行命令，成功后写入aof_buf<strong>内核</strong>缓冲区，aof_buf根据策略刷新到磁盘。</p><p><em>写回策略</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/98987d9417b2bab43087f45fc959d32a.webp"><br>底层：在不同的时间点调用<code>fsync()</code>函数。（请求将内核缓冲区内容立刻刷盘）</p><p><em>重写机制</em><br>会使用<em>bgrewriteaof</em>后台重写：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/t_70-20230309231944807.webp"></p><ul><li>fork子进程（复制虚拟页表，<strong>第一次阻塞</strong>）</li><li>主线程同时需要完成写内存，写aof缓存（仍正常刷盘在原文件上），写aof重写缓存（方便后续追加在重写文件上）</li><li>使用CopyOnWrite技术（复制物理内存，<strong>第二次阻塞</strong>，如果修改的是bigkey，则阻塞更久）和解决一致性；</li><li>子线程完成rewrite，发送<strong>信号</strong>（<strong>第三次阻塞</strong>），通知主线程追加aof命令和改名<strong>原子覆盖</strong>。</li></ul><blockquote><p>写时复制后，主进程使用原地址，子进程使用复制出来的地址。</p></blockquote><p><em>重写触发</em></p><ul><li>当前文件大小超过上次重写后的百分之多少。</li><li>当前文件大小超过设置大小。</li></ul><h2 id="RDB和AOF混合持久化"><a href="#RDB和AOF混合持久化" class="headerlink" title="RDB和AOF混合持久化"></a>RDB和AOF混合持久化</h2><p><em>开启</em></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">aof-<span class="hljs-keyword">use</span>-rdb-preamble yes<br></code></pre></td></tr></table></figure><p><em>流程</em><br>AOF文件：前半部分记录RDB内容，后半部分记录AOF部分。本质是通过 <strong>AOF 后台重写</strong>触发完成的，会重新生成RDB内容，并将期间产生的AOF部分添加在AOF文件后面。</p><p><em>加载流程</em><br>优先加载AOF，不存在再加载RDB。</p><h2 id="big-key"><a href="#big-key" class="headerlink" title="big key"></a>big key</h2><p><em>Big Key的影响</em></p><ul><li>客户端超时</li><li>网络阻塞</li><li>DEL阻塞</li><li>内存分布不均匀</li><li>AOF日志：刷盘阻塞耗时</li><li>AOF重写：快速触发重写，拷贝大虚拟页表阻塞耗时，如果对big key写，COW的物理内存复制也阻塞耗时。</li></ul><p><em>寻找Big Key</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --bigkeys<br></code></pre></td></tr></table></figure><p><em>避免Big Key</em><br>拆分big key，即将一个键值拆分为多个键值。</p><p><em>删除Big Key</em></p><ul><li>对其的删除使用unlink，异步延迟释放内存。</li><li>分批次删除：针对集合类型分多次删除</li></ul><p><em>Linux开启内存大页</em><br>会允许以2MB为单位分配内存，会导致小数据修改也要在COW中拷贝大页。</p><h1 id="三、事件机制"><a href="#三、事件机制" class="headerlink" title="三、事件机制"></a>三、事件机制</h1><p><em>Redis的线程</em><br>Redis的单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的。<br>Redis程序并不是单线程的，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，有2个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了1个后台线程，用来异步释放 Redis 内存，即lazyfree 线程。</li></ul><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20231001213203.png"></p><p><em>Redis事件机制</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.webp"><br><em>Redis事件处理模型</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235505.png"></p><p><code>aeEventLoop</code>是事件驱动的核心，同时管理<strong>文件事件</strong>和<strong>时间时间</strong>。</p><p><em>Redis与IO多路复用</em><br>redis支持select、epoll、kqueue等技术，适配操作系统实现。</p><p><em>Redis文件事件</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235714.png"><br>使用<strong>Redis文件事件处理器</strong>实现<strong>连接应答</strong>、<strong>请求处理</strong>、<strong>响应处理</strong>等事件的分发。</p><p><em>Redis时间事件</em><br>时间事件执行器运行时，遍历整个时间事件<strong>无序链表</strong>，查找已经到达的时间事件并调用相应事件处理器。</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><blockquote><p>Redis一般只使用<code>serverCron</code>时间事件，用于<strong>统计，删除过期键，RDB，AOF，同步，心跳等，周期执行</strong></p></blockquote><p><em>实现</em><br>初始化函数<code>initServer</code>创建了aeEventLoop对象，初始化文件、时间事件表，创建epoll实例。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000231.png"></p><h1 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h1><p><em>语句</em><br><code>MULTI</code>开启事务，<code>EXEC</code>执行事务，<code>DISCARD</code>取消事务。</p><p><em>回滚</em><br>Redis不支持回滚：</p><ul><li>若出现语法错误，整个事务不执行。</li><li>若出现类型错误，错误语句执行失败，其他语句依然执行。</li></ul><p><em>ACID</em><br>A：<strong>官方认为支持</strong>原子性，要么全执行要么全不执行（不保证每个语句都执行成功）。<br>C：<strong>支持</strong>，WATCH锁<br>I：<strong>支持</strong>，单线程<br>D：<strong>不支持</strong>，AOF刷盘时机 ，RDB间隔都可能丢数据。</p><p><em>乐观锁</em></p><ul><li><code>WATCH KEY</code>：在<code>MULTI</code>前执行，在<code>EXEC</code>时若发现KEY被修改，则不会执行事务。</li><li><code>UNWATCH</code>：取消对所有key的监视。</li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000718.png"></p><h1 id="五、删除策略和淘汰策略"><a href="#五、删除策略和淘汰策略" class="headerlink" title="五、删除策略和淘汰策略"></a>五、删除策略和淘汰策略</h1><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p><em>设置过期时间</em><br><code> expire key 100</code></p><p><em>过期判断</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323234744.png"><br>redis会将会过期的键放在过期字典（key:expire）中，get key时，先在字典中搜索，看是否存在以及是否过期。</p><p><em>删除策略</em></p><ul><li>定时删除</li><li>定期删除（定期删除行为会在ServerCron函数中执行）</li><li>惰性删除</li></ul><p>Redis 选择「<strong>惰性删除+定期删除</strong>」这两种策略配和使用<br>    对于RDB，其不会记录已经删除的键<br>     对于AOF文件，键过期后会在文件后面加上DEL key的命令，重写时则不会记录该key。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p><em>内存淘汰策略</em></p><ol><li>noeviction：写满了就停止服务。</li><li>volatile-ttl：对即将过期的时间进行排序，删除</li><li>volatile-random：对会过期的键随机删除</li><li>volatile-lru(last-recently-used)：对最后使用时间进行排序，删除最后一次使用较早的数据</li><li>volatile-lfu（4.0后新增）：对使用次数进行排序，删除最少使用的数据</li><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ol><p><em>redis实现lru&#x2F;lfu淘汰</em><br>lru模式：最近最少使用，用redisObject的lru字段（24位记录时间戳）记录，会造成<strong>缓存污染</strong><br>lfu模式：最近最不常用，用redisObject的lru字段（16位记录时间戳，8位记录访问次数，会衰减）。<br>随机选一批数据，排序。</p><p><em>原理</em><br>新数据进入redis时，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，则执行淘汰算法。</p><h1 id="六、高可用"><a href="#六、高可用" class="headerlink" title="六、高可用"></a>六、高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><em>作用</em></p><ul><li>数据冗余 -&gt; 故障恢复</li><li>负载均衡</li><li>读写分离</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><em>初次建立连接（全量复制）</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/ea4f7e86baf2435af3999e5cd38b6a26.webp"><br>注意点：</p><ul><li><strong>psync</strong>请求可以和aof刷盘的fsync联合记忆</li><li><strong>runID</strong>和复制进度<strong>offset</strong>。</li><li>最后发送<strong>replcation buffer</strong>。</li></ul><p><em>命令传播</em><br>长连接！<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/03eacec67cc58ff8d5819d0872ddd41e.webp"></p><p><em>再次连接（增量复制）</em><br>注意：</p><ul><li><strong>repl_backlog_buffer</strong>，「环形」缓冲区。</li><li><strong>replication offset</strong>，标记缓冲区的同步进度。<ul><li>主服务器使用 <code>master_repl_offset</code> 来记录自己「_写_」到的位置。</li><li>从服务器使用 <code>slave_repl_offset</code> 来记录自己「_读_」到的位置。</li></ul></li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2db4831516b9a8b79f833cf0593c1f12.webp"><br>若<code>slave_repl_offset</code>在<code>repl_backlog_buffer</code>中，则会将增量数据写入<code>replication buffer</code>，继续传播。否则，全量复制。</p><blockquote><p>可适当调节repl_backlog_buffer避免频繁全量复制。</p></blockquote><p><em>心跳机制</em><br>主节点：10秒ping一次从节点。<br>从节点：1秒发送一次replconf ack{offset}上报存活和当前复制进度。</p><p><em>过期key</em><br>主节点发送DEL KEY指令给从节点。<br>Redis3.2版本后，从节点也会判断过期数据。</p><p><em>replication buffer 、repl backlog buffer</em></p><ul><li>一个主节点只分配一个 repl backlog buffer，满了之后覆盖。</li><li>每个从节点分配一个replication buffer，满了之后断开连接并删除该buffer，等待从节点重连后全量复制。</li></ul><h3 id="主从复制优化"><a href="#主从复制优化" class="headerlink" title="主从复制优化"></a>主从复制优化</h3><p><em>数据不一致</em><br>优化网络环境，集群扩展负载能力，检测并断开网络过于差的节点。</p><p><em>减少切换的数据丢失</em></p><ul><li>异步复制，主节点宕机后恢复：<ul><li><code>min-slaves-max-lag x</code>参数，主节点要求至少要有一个从节点与主节点的同步进度小于x秒，否则禁止写数据。</li></ul></li><li>异步复制，主节点宕机后成为从节点 <strong>（脑裂）</strong>：<ul><li><code>min-slaves-to-write x</code>参数，主节点至少要有x个从节点，否则禁止写数据。</li><li><code>min-slaves-max-lag x</code>参数，主节点要求至少要有一个从节点与主节点的同步进度小于x秒，否则禁止写数据。</li></ul></li></ul><blockquote><p>都是在宕机是禁止对原节点的写入，通过队列缓存等待恢复或直接写入新节点。</p></blockquote><p><em>故障自动切换</em><br>哨兵可以完成故障发现、转移、停止。</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p><em>哨兵的作用</em></p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p><em>哨兵集群构建</em></p><ul><li>哨兵一般至少为3个，应该为奇数个，<code>quorum</code>一般设置成<code>哨兵数量/2+1</code>。</li><li>通过主节点的<code>__sentinel__:hello</code>频道完成哨兵直接的互相发现与连接。</li><li>通过每10s一次的消息头部请求，获取主节点和从节点的基本信息，实现对从节点的连接。</li></ul><p><em>监控</em></p><ol><li>首个发现哨兵A将其标记为<strong>主观下线</strong>，并询问其他哨兵是否下线。</li><li>当哨兵A收集到达到<code>quorum</code>数量的赞成票时，将其标记为<strong>客观下线</strong>。</li><li>做出<strong>客观下线判定的哨兵</strong>就是执行故障转移的Leader候选人，Leader候选人需要拿到达到<code>quorum</code>数量且达到<code>哨兵数量/2+1</code>数量的赞成票才能当选（<strong>Raft选举算法</strong>）。</li></ol><p><em>Raft选举算法</em><br><a href="https://juejin.cn/post/6998470783831900197">Raft选举算法</a><br>概念：</p><ul><li>Raft定义了三种角色：<strong>领导者（Leader）</strong>、<strong>跟随者（Follower）</strong> 和 <strong>候选人（Candidate）</strong>。跟随者发现领导者掉线时（收不到leader的心跳）成为候选人。</li><li>节点属性：<ul><li>任期：相当于版本号，过期的任期请求是无用的</li><li>跟随节点ID：即给谁投票或现在跟随谁</li></ul></li><li>超时计时器：<ul><li>选举超时时间：发现leader掉线时随机延迟一段时间选举，防止多节点同时候选</li><li>投票超时时间：收集投票时间的倒计时，结束时统计票数</li><li>竞选等待超时时间：选举失败后且没有其他领导者诞生时，等待一段时间再次选举</li></ul></li></ul><p>实现：</p><ul><li>RPC通讯，只有数据追加请求（心跳）和投票请求（投票）</li><li>任期保证了节点不会使用受到的过期消息，并会跟随最新的任期</li><li>多领导人同时选举时，每个节点只会对一个版本号的投票请求投出一次票。</li></ul><blockquote><p>更详细内容见分布式算法专题。</p></blockquote><p><em>故障转移与通知</em></p><ol><li>挑选新主节点，优先级如下：<ul><li>其中，网络状况不好指：与主节点的断连超过10次以上的从节点</li></ul></li></ol><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B.webp"><br>2. 对新主发送<code>SLAVEOF no one</code>，对其他节点发送<code>SLAVEOF 新主节点</code>命令<br>3. 通知客户故障转移，通过哨兵的<code>+switch-master</code>频道订阅<br>4. 若后续旧主节点上线，也对其发送<code>SLAVEOF 新主节点</code>命令</p><h2 id="集群机制"><a href="#集群机制" class="headerlink" title="集群机制"></a>集群机制</h2><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165951.png"></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><em>hash slot</em><br>redis cluster有16384（2的14次方，bitmap压缩，2kB大小既可以描述）个槽，每个节点管理部分槽。</p><p><em>hash tags</em><br>只使用<code>&#123;&#125;</code>的部分计算hash，实现key的定向存放。</p><p><em>分配方案</em></p><ul><li><code>cluster create</code>创建时平均分配</li><li><code>cluster meet</code>扩容后手动分配</li></ul><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p><em>cluster nodes</em><br>每个节点维护必要的信息：</p><ul><li>该节点的node id，slots，版本号，连接状态</li><li>其他节点的node id，ip，port，slots，master id，版本号，连接状态（最后一次ping，pong的响应时间）</li></ul><p><em>cluster bus</em><br>node通过<code>10000+port</code>端口与其他节点建立连接。</p><p><em>集群拓扑</em><br>redis集群是一个全网拓扑，节点之间两两相连。</p><p><em>cluster handshake</em><br>node通过cluster bus监听消息：</p><ul><li>ping messgae：心跳消息，收到该消息后肯定回复pong消息。<ul><li>若是集群成员，则处理ping消息中携带的gossip信息，识别可能的新节点。</li><li>若不是集群成员，则丢弃该消息。</li></ul></li><li>meet message：发现消息，收到该消息后将消息源视为集群的一部分</li><li>ping message：交换消息，收到集群内其他节点的gossip消息后，将消息中的新节点视为集群的一部分。</li></ul><p><em>Key迁移过程</em><br>key 迁移过程中，涉及到一下两个命令：</p><ul><li>CLUSTER SETSLOT slot8 MIGRATING node 命令</li><li>CLUSTER SETSLOT slot8 IMPORTING node 命令</li></ul><p>前者用于将给定节点 node 中的槽 slot8 迁移出节点，而后者用于将给定槽 slot8 导入到节点 node ：</p><ol><li>如果一个槽被设置为 MIGRATING 状态时，<strong>原本持有该槽的节点会继续接受关于这个槽的命令请求</strong>，但只有当键存在于该节点时，节点才会处理这个请求。如果命令所使用的键不存在于该节点，那么节点将向客户端返回一个 ASK 转向（redirection）错误，告知客户端，要将命令请求发送到槽的迁移目标节点。</li><li>如果一个槽被设置为 IMPORTING 状态时，<strong>节点仅在接收到 ASKING 命令之后，才会接受关于这个槽的命令请求。</strong> 如果客户端向节点发送该槽的数据请求，命令为非 ASKING 时，那么节点会使用 MOVED 转向错误将命令请求转向至真正负责处理这个槽的节点。</li></ol><p><em>请求重定向</em></p><ul><li>MOVED重定向：槽不命中时返回MOVED重定向</li><li>ASK重定向：槽命中但找不到key，且槽在迁移中，则返回ASK重定向</li></ul><p><em>SMART客户端</em><br>通过<code>cluster slots</code>命令获取集群的slots信息，自主计算key所在节点并访问，失败时随机访问节点，并更新slots缓存。</p><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p><strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。</strong></p><p><em>为什么不使用发布订阅</em><br>消息量太大，消耗带宽。（可以使用bloom过滤器优化）</p><p><em>节点结构</em><br>epoch表示版本</p><p><em>gossip消息类型</em><br>ping、pong、meet、failover四种基本类型。另外有<strong>广播通知</strong>，不同于gossip，会发送，使用于标记客观下线，故障恢复请求和故障恢复完成。</p><p><em>心跳发送</em></p><ul><li>每次Cron向所有未建立链接的节点发送ping或meet。</li><li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li><li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li><li>收到ping或meet，立即回复pong</li></ul><p><em>心跳处理</em><br>1.新节点加入：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324172724.png"></p><p>2.slots、master slave、fail等信息的更新与传播。</p><p><em>故障检测</em><br>节点状态：<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p><ol><li><strong>主节点A</strong>检测到<strong>主节点B</strong>下线，将<strong>疑似下线</strong>该消息保存到其维护的字典中<code>节点B的clusterNode</code>结构的<code>fail_reports</code>链表中，通过gossip协议传播。</li><li><strong>主节点C</strong>收到<strong>主节点A</strong>的gossip消息，也对其进行检查，标记和传播。</li><li>传播到某<strong>主节点D</strong>时，主节点D判断其已经下线，且发现已经有半数以上<strong>主节点</strong>认为节点B疑似下线，则<strong>主节点D</strong>将其标记为<strong>已下线状态</strong>，并发送<strong>广播通知</strong>。</li></ol><p><em>故障恢复</em></p><ol><li>各从节点接受到其主节点客观下线的<strong>广播通知</strong></li><li>各从节点将epoch+1并发送failover requsest<strong>广播通知</strong></li><li>其他主节点响应并投票，对相同epoch只投一次票</li><li>获得超过半数投票后，某从节点当选，并发送failover complete<strong>广播通知</strong></li></ol><blockquote><p>可见集群中，各个主节点充当了哨兵的作用，完成下线判断和投票。</p></blockquote><h3 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h3><p><em>节点加入集群</em><br>加入集群后节点默认为主节点，但无slot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster meet ip:port<br>redis-cli --cluster add-node ip:port<br></code></pre></td></tr></table></figure><p><em>将节点设置为从节点</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster replicate 4b339ad25b4884c2ff6de8a8ec2bc8766f8faf0b<br></code></pre></td></tr></table></figure><p><em>手动迁移</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster reshard 192.168.100.100:8001<br></code></pre></td></tr></table></figure><p><em>缩容</em><br>判断下线节点类型，若是主节点，则先将其迁移后将其标记为待下线，最后将下线主节点的从节点指向其他主节点。</p><h1 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h1><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。<strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>大量缓存数据同时过期</strong>，或<strong>Redis宕机</strong>，导致对数据库的大量请求并引起一连串的连锁反应。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h4><p>首先过期的主要目的是为了实现数据的更新。</p><ul><li>大量：<strong>接口限流或熔断</strong> 或 <strong>互斥锁</strong>（一次只允许一个请求构建缓存，防止对数据库的大量请求，记得设置超时时间）。</li><li>同时：<strong>设置均匀的过期时间</strong>。</li><li>过期：<ul><li><strong>后台更新缓存</strong>：不设置过期时间，数据发送变化时后台主动更新缓存，但可能出现内存紧张发生淘汰，解决方法有：<ul><li>后台定时检测key是否被淘汰。</li><li>淘汰时以消息队列通知后台更新，并暂时返回空。</li></ul></li><li><strong>双key</strong>：使用两个key，主key会过期方便更新，备key则临时应付主键过期时的请求。应用程序发现主key过期则访问备key，并触发主备key的更新（也要配合互斥锁实现更新）。</li></ul></li></ul><h4 id="Redis故障宕机"><a href="#Redis故障宕机" class="headerlink" title="Redis故障宕机"></a>Redis故障宕机</h4><ul><li><strong>服务熔断</strong>或<strong>请求限流</strong></li><li>构建Redis高可用集群（主从）</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>某个热点数据过期</strong>，导致对数据库的大量请求并引起一连串的连锁反应。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>大量：<strong>接口限流或熔断</strong>、互斥锁方案</li><li>不设置过期时间，后台异步更新缓存及其过期时间</li></ul><blockquote><p>接口限流和熔断和互斥锁几乎是万金油机制</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致对数据库大量请求。</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>限制非法请求，检查请求参数</li><li>缓存空值或默认值</li><li>布隆过滤器快速判定是否命中缓存</li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><em>组成</em><br>位图数组 + N个哈希函数</p><p><em>标记步骤</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/86b0046c2622b2c4bda697f9bc0f5b28.webp"></p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p><em>查询步骤</em><br>计算N个hash值并取模，判断这些位是否都为1：</p><ul><li>全1不代表一定存在</li><li>存在0代表一定不存在</li></ul><p><em>哈希冲突</em><br><strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，redis中一定就不存在这个数据</strong>。</p><blockquote><p>更详细内容见大数据处理算法专题。</p></blockquote><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>并发问题和行为不执行都可能导致缓存的不一致性。</p><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>主动更新在<strong>并发写</strong>时存在不一致问题，如下：</p><ul><li>先更新数据库，再更新缓存</li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/8febac10b14bed16cb96d1d944cd08da.webp"><br><strong>无法保证一致性。</strong></p><ul><li>先更新缓存，再更新数据库</li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/454a8228a6549176ad7e0484fba3c92b.webp"><br><strong>无法保证一致性。</strong></p><h3 id="更新删除策略"><a href="#更新删除策略" class="headerlink" title="更新删除策略"></a>更新删除策略</h3><p>更新数据库并删除缓存在<strong>并发读、写</strong>时存在不一致问题，如下：</p><h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/6e3db3ba2f829ddc14237f5c7c00e7ce.webp"></p><ul><li>先删除缓存，再更新数据库</li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cc208c2931b4e889d1a58cb655537767.webp"><br><strong>无法保证一致性。</strong></p><ul><li>先更新数据库，再删除缓存</li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/1cc7401143e79383ead96582ac11b615.webp"><br><strong>无法保证一致性。</strong><br>虽然仍可能存在不一致性，但发生的概率较低：</p><ul><li>请求A更新缓存只发送在缓存未命中的情况（可能键恰好失效）。</li><li>缓存的写速度远快于数据库写入，请求A的写缓存行为几乎不会发生在请求B完成删除缓存之后。</li></ul><div class="note note-primary">            <p><strong>先更新数据库，后删除缓存</strong>是可行的，虽然不能完全保证一致性，但可以接受。</p>          </div><h3 id="缓存代理模式（使用较少）"><a href="#缓存代理模式（使用较少）" class="headerlink" title="缓存代理模式（使用较少）"></a>缓存代理模式（使用较少）</h3><h4 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165034.png"></p><h4 id="Write-Behind-Caching-Pattern（异步缓存写入）"><a href="#Write-Behind-Caching-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Caching Pattern（异步缓存写入）"></a>Write Behind Caching Pattern（异步缓存写入）</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165054.png"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><em>主动更新策略</em><br>主动更新策略能更好的保证实时性和命中率，但存在并发问题，解决方案：</p><ul><li>使用<strong>分布式锁</strong>，只允许一个请求更新缓存</li><li>使用<strong>较短的过期时间</strong>，即使存在过期数据也快速刷新</li></ul><p><em>更新删除策略</em><br>延迟双删：更新数据库前<strong>删除缓存</strong>，更新数据库后<strong>睡眠</strong>一小段时间，再执行一次<strong>删除缓存</strong>。</p><p><em>执行失败</em><br>「先更新数据库， 再删除缓存」行为中，删除缓存可能未得到执行。</p><h3 id="解决强一致性问题"><a href="#解决强一致性问题" class="headerlink" title="解决强一致性问题"></a>解决强一致性问题</h3><p>由于更新删除策略中删除缓存可能得不到执行，需要优化流程：<br><em>方案1：队列+重试</em><br>将删除缓存行为加入到消息队列保证其得到执行。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164739.png"></p><p><em>方案2：队列+重试+非业务代码异步更新</em><br>使用数据库更新日志binlog，中间件（Canal 中间件，阿里巴巴开源）提取key并执行缓存删除，这中间也需要使用消息队列保证执行成功，但可以使用非业务代码完成这个操作。</p><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164801.png"></p><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2ee2280e9f59b6b4879ebdec6eb0cf52.webp"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis常见问题</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis概念"><a href="#Redis概念" class="headerlink" title="Redis概念"></a>Redis概念</h1><p><em>什么是Redis?</em><br>Redis 是一个使用 C 语言写成的，基于内存的高性能key-value非关系缓存数据库。<br>特点：支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p><p><em>Redis 和 Memcached 有什么区别？</em><br>Redis 与 Memcached <strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p>Redis 与 Memcached <strong>区别</strong>：</p><ol><li>Redis 支持的<strong>数据类型</strong>更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持数据的<strong>持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生支持<strong>集群模式</strong>，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li></ol><p><em>为什么Redis可以做缓存？</em><br>其有高性能（基于内存响应速度块）、高并发（单机的 QPS 能轻松破 10w）的特性。</p><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><p><em>Redis有哪些常见类型？</em><br>常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）<br>后面又支持了四种数据类型：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</p><p><em>Redis各数据类型使用场景？</em></p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><p><em>各数据类型底层实现？</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231001212816.png"><br><code>list</code>，<code>hash</code>，<code>set</code>，<code>zset</code>都试图使用<strong>压缩的数据结构</strong>（压缩列表&#x2F;排序的压缩列表&#x2F;整数集合）来处理数量小于512&#x2F;512&#x2F;512&#x2F;128个且大小都小于64字节的元素集合，否则使用高级数据结构。</p><p><em>为什么SDS的设计不同于C语言？</em></p><ul><li>SDS 不仅可以保存文本数据，还可以保存<strong>二进制数据</strong>，因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束。</li><li>SDS **获取字符串长度的时间复杂度是 O(1)**，C 语言的字符串并不记录自身长度。</li><li>Redis 的 <strong>SDS API 是安全的</strong>，拼接字符串不会造成缓冲区溢出，SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><p><em>一个字符串类型的值能存储最大容量是多少？</em><br>512M</p><p><em>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</em><br>理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5千万的 keys。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说， Redis 的存储极限是系统中的可用内存值。</p><h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><p><em>Redis是单线程吗？</em></p><ul><li>处理文件事件是主线程单线程完成。</li><li>关闭文件、AOF 刷盘、lazyfree等操作都由子线程异步完成。</li><li>之前使用单线程，因为CPU不是性能瓶颈；6.0后使用了多线程，因为网络上开始出现瓶颈（<strong>对于命令的执行，Redis 仍然使用单线程来处理，只是对于网络 I&#x2F;O 采用多线程处理</strong>）。</li></ul><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231001213203.png"></p><p><em>为什么单线程模型如此快？</em></p><ul><li>基于内存</li><li>无锁</li><li>I&#x2F;O多路复用</li></ul><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p><em>RDB与AOF的优缺点？</em><br>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。<br>AOF 优点是丢失数据少，但是数据恢复不快。</p><p><em>为什么AOF先写数据后写日志？</em></p><ul><li>优点：可以避免额外的检查开销、不会阻塞当前写操作命令的执行。</li><li>缺点：数据可能会丢失、可能阻塞其他操作（AOF 日志也是在主线程中执行，会阻塞后续命令）</li></ul><p><em>AOF写回策略</em><br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231001213939.png"></p><p><em>RDB写时复制</em><br>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231003135431.png"></p><p><em>混合持久化的优点与缺点？</em></p><ul><li>触发：<strong>混合持久化</strong>工作在 <strong>AOF 日志重写过程</strong>，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，期间主线程处理的操作命令会被记录在重写缓冲区里，随后重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</li><li>优点：混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li><li>缺点：AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h1 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h1><p><em>Redis 如何实现服务高可用？</em><br>主从复制 -&gt; 哨兵模式 -&gt; 集群模式</p><p><em>主从模式</em><br>主从复制是 Redis <strong>高可用</strong>服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。<br>主从服务器之间的命令复制是<strong>异步</strong>进行的，无法保证强一致性，且节点出现故障后，需要手动容灾。</p><p><em>哨兵模式</em><br>哨兵模式是主从模式的优化，通过哨兵集群监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p><p><em>集群模式</em><br>集群模式为Redis提供了水平扩展的能力，其使用哈希槽（Hash Slot）来处理数据和节点之间的映射关系。</p><p><em>哈希槽</em></p><ul><li>哈希槽计算：在 Redis Cluster 方案中，一个切片集群共有 16384 （2的14次方）个哈希槽。根据键值对的 key，按照 CRC16 算法计算一个 <strong>16 bit</strong> 的值。再用 16bit 值对 <strong>16384</strong> 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li><li>哈希槽分配：<ul><li><strong>平均分配</strong>：在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384&#x2F;9 个。</li><li><strong>手动分配</strong>：可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li></ul></li></ul><p><em>一致性哈希与哈希槽的区别</em></p><ul><li>节点取余：hash % 节点数量 -&gt; 实际节点，增减节点会导致大量节点迁移</li><li><strong>一致性哈希</strong>：hash -&gt; 顺时针寻找 -&gt; 实际节点，增减节点的影响控制在相邻节点之间，但节点数量较少时，数据会严重不平衡</li><li><strong>哈希槽</strong>：hash -&gt; 槽 -&gt; 实际节点，<strong>槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小</strong>。</li></ul><p><em>集群高可用</em><br>集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。由于异步复制的特性，也无法实现强一致。</p><p><em>集群选举的参与者</em><br>由所有master参与节点的上下线判断，超过半数主节点与当前节点通信超时时，集群认为当前master节点挂掉。</p><p><em>集群什么时候不可用？</em></p><ol><li>某个没有slave的master宕机了，整个集群会因为缺少该主节点管理的哈希槽而不可用。</li><li>当集群 Master 节点个数小于 3 个的时候，或者集群可用节点个数为偶数的时候，基于 fail 的这种选举机制的自动主从切换过程可能会不能正常工作，一个是标记 fail 的过程，一个是选举新的 master 的过程，都有可能异常。</li></ol><p><em>集群是如何做到 key 迁移不阻塞集群服务的呢？</em></p><ul><li>原节点将槽设置为<code>MIGRATING</code>状态，继续接受该槽的请求，若不存在则返回ASK转向</li><li>新节点将槽设置为<code>IMPORTING</code>状态，仅接受ASK转向请求，接受到非ASK请求时会回复MOVED转向错误命令。</li></ul><p><em>集群之间是如何复制的？</em><br>异步复制</p><p><em>集群如何选择数据库？</em><br>Redis 集群目前无法做数据库选择， 默认在 0 数据库。</p><p><em>集群脑裂</em></p><ul><li>问题：集群判断主节点下线后换主，但主节点还在对外提供服务，即新旧主节点数据不一致，此时集群判断旧主节点上下，将其设置为新主节点的从节点，导致数据丢失。</li><li>解决：通过以下两个参数，让旧主节点停止对外服务：<ul><li><code>min-slaves-to-write x</code>：主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li><li><code>min-slaves-max-lag x</code>：主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li></ul></li></ul><h1 id="Redis过期删除与内存淘汰"><a href="#Redis过期删除与内存淘汰" class="headerlink" title="Redis过期删除与内存淘汰"></a>Redis过期删除与内存淘汰</h1><p><em>Redis key 的过期时间和永久有效分别怎么设置？</em><br>EXPIRE 和 PERSIST 命令。</p><p><em>Redis过期删除策略</em><br>惰性删除+定期删除</p><p><em>如何判定 key 已过期了？</em><br>当对一个 key 设置过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，即「过期字典」保存了数据库中所有 key 的过期时间。<br>过期字典的数据结构如下图所示：<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231002164228.png"><br>当我们查询一个 key 时，Redis <strong>首先检查该 key 是否存在于过期字典</strong>中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ul><p><em>惰性删除的优缺点</em></p><ul><li>优点：惰性删除策略对 CPU 时间最友好。</li><li>缺点：惰性删除策略对内存不友好。</li></ul><p><em>定期删除的方式</em><br>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Pasted-image-20231002163810.png"><br><em>Redis大量键同时过期会造成什么影响？</em><br>可能出现循环过度，造成Redis卡顿，因此需要设置循环的执行时间上限。</p><p><em>定期删除的优缺点</em></p><ul><li>优点：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li><li>缺点：难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><p><em>Redis 持久化时，对过期键会如何处理的？</em></p><ul><li>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。<ul><li><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，过期的键「不会」被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li><li><strong>RDB 加载阶段</strong>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul><li>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，<strong>过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li><li>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，<strong>不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul></li></ul></li><li>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。<ul><li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，<strong>Redis 会向 AOF 文件追加一条 DEL 命令</strong>来显式地删除该键值。</li><li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li></ul></li></ul><p><em>Redis 主从模式中，对过期键会如何处理？</em><br>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p><p><em>Redis内存淘汰时机？</em><br>对Redis发送新命令时，Redis 检查内存使用情况， 如果大于 maxmemory的限制, 则根据设定好的策略进行回收。</p><p><em>Redis内存淘汰</em></p><ul><li><strong>noeviction</strong>（Redis3.0 之后，默认的内存淘汰策略）：不进行内存淘汰</li><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li><li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li></ul><p><em>内存淘汰策略选择</em></p><ul><li>根据是否允许淘汰非过期键值判断使用volatile还是allkeys；</li><li>根据数据访问频率的分布判断使用random还是lru&#x2F;lfu。</li></ul><p><em>LRU 算法和 LFU 算法有什么区别？</em></p><ul><li><strong>LRU</strong>全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</li><li><strong>LFU</strong>全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据数据访问次数来淘汰数据的。</li></ul><p><em>LRU算法实现</em><br><strong>LRU</strong>没有使用传统的LRU链表形式实现LRU算法，其实现了一种<strong>近似的LRU</strong>算法，其在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的<strong>最后一次访问时间</strong>（24bit）。进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><ul><li>优点：不用为所有的数据维护一个大链表，节省了空间占用；不用在每次数据访问时都移动链表项，提升了缓存的性能；</li><li>缺点：<strong>无法解决缓存污染问题</strong>，即如果某数据只读取一次，其也会留存在 Redis 缓存中很长一段时间，造成缓存污染（因此需要LFU）。</li></ul><p><em>LFU算法实现</em><br><strong>LFU</strong> 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息：高 16bit 存储 ldt（Last Decrement Time），低 8bit 存储 logc（Logistic Counter），<strong>logc 会随时间推移而衰减的</strong>：先按照上次访问距离当前的时长，来对 logc 进行衰减；然后，再按照一定概率增加 logc 的值（越大越难再增加）</p><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><p><em>如何避免缓存雪崩？</em></p><ul><li>将缓存失效时间随机打散</li><li>设置缓存不过期</li></ul><p><em>如何避免缓存击穿？</em></p><ul><li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存。</li></ul><p><em>缓存穿透？</em></p><ul><li>非法请求的限制：入参检查</li><li>设置空值或者默认值：线上问题止血</li><li>布隆过滤器：快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</li></ul><p><em>如何设计更新策略实现动态更新热点数据？</em></p><ul><li>背景：redis根据内存限制实现的lfu内存淘汰策略具有不稳定性，且无法准确限制热点的数量，因此可以手动实现热点识别功能。</li><li>思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。</li><li>实现：通过缓存系统做一个排序队列，根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前，并定期淘汰排名在最后的若干数据。</li></ul><p><em>常见的缓存更新策略？</em></p><ul><li>Cache Aside（旁路缓存）<ul><li>原理：先更新数据库后无效缓存，其他方式可能会导致读写并发时的不一致现象：<ul><li>写数据库 + 写缓存：写并发时，可能导致最后写入的缓存不是数据库最新值。</li><li>写缓存 + 写数据库：写并发时，可能导致最后写入数据库的不是最新缓存值。</li><li>无效缓存 + 写数据库：读写并发时，读操作可能先更新旧的值到缓存。</li><li>写数据库 + 无效缓存：读写并发时，若本身无缓存，读缓存先未命中并查旧值，可能最后更新旧的值到缓存。（但是，读时更新缓存比写数据库快得多，所以该情况发生的概率较小）。</li></ul></li><li>场景：适用于<strong>读多写少</strong>的场景，若写太多可能会导致频繁的无效缓存，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：<ul><li>更新数据时更新缓存，在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li><li>更新数据时更新缓存，给并给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li></ul></li></ul></li><li>Read&#x2F;Write Through（读穿 &#x2F; 写穿）<ul><li>原理：应用程序只和缓存交互，由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</li><li>场景：Redis不支持与数据库交互，使用较少。可用于本地缓存。</li></ul></li><li>Write Back（写回）<ul><li>原理：更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</li><li>场景：<strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。缺点是<strong>数据不是强一致性的，而且会有数据丢失的风险</strong>。</li></ul></li></ul><p><em>主动更新策略优化</em><br>业务主动更新缓存，而不是删除。该方案能更好的保证实时性和命中率，但存在<strong>并发问题</strong>，解决方案：</p><ul><li>使用<strong>分布式锁</strong>，只允许一个请求更新缓存</li><li>使用<strong>较短的过期时间</strong>，即使存在过期数据也快速刷新</li></ul><p><em>更新删除策略优化</em><br>更新删除策略也存在<strong>小概率的并发问题</strong>，解决：</p><ul><li><strong>延迟双删</strong>：更新数据库前<strong>删除缓存</strong>，更新数据库后<strong>睡眠</strong>一小段时间，再执行一次<strong>删除缓存</strong>。</li></ul><p><em>强一致性优化方案</em><br>由于更新删除策略中<strong>删除缓存可能得不到执行</strong>，需要优化流程：</p><ul><li>队列+重试：删除缓存失败时，将删除缓存作为消息投递到消息队列中，然后进行重试。</li><li>队列+重试+非业务代码异步更新：使用数据库更新日志binlog，中间件（Canal 中间件，阿里巴巴开源）提取key并执行缓存删除，这中间也需要使用消息队列保证执行成功，但可以使用非业务代码完成这个操作。</li></ul><h1 id="Redis扩展能力"><a href="#Redis扩展能力" class="headerlink" title="Redis扩展能力"></a>Redis扩展能力</h1><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p><em>队列实现对比</em></p><ul><li><code>list</code>做队列，根据需求使用非阻塞<code>lpop</code>或阻塞的<code>blpop</code>，但无法实现重复消费，也不支持重试。</li><li><code>pub/sub</code>订阅者模式，可以实现1:N的消息队列，解决了消费者重试，但消费者下线时消息会丢失（不具有堆积能力）。</li><li><code>stream</code>趋于成熟的消息队列，支持阻塞式拉取、订阅发布（通过消费组实现）、消息重试（利用消息id）、持久化（RDB&#x2F;AOF）。其处理消息堆积的方式是指定队列长度，丢弃旧消息。</li></ul><blockquote><p>List 其实是属于「拉」模型，而 Pub&#x2F;Sub 其实属于「推」模型。</p></blockquote><p><em>Redis队列的缺陷</em></p><ol><li>Redis 本身可能会丢数据</li><li>面对消息积压，Redis 内存资源紧张</li></ol><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>Zset，利用score存储预计延迟时间：</p><ul><li>zadd score1 value1 命令生产消息</li><li>zrangebysocre 查询符合条件的所有待处理的任务</li></ul><h2 id="大Key问题"><a href="#大Key问题" class="headerlink" title="大Key问题"></a>大Key问题</h2><p><em>定义</em><br>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。（如String 类型的值大于 10 KB，Hash、List、Set、ZSet 类型的元素的个数超过 5000个）</p><p><em>影响</em></p><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><p><em>排查</em><br><code>redis-cli --bigkeys</code> 查找大key</p><ul><li>注意：要在从节点或业务压力低峰阶段进行扫描，以免阻塞影响实例的正常运行，有以下缺点：</li><li>缺点：<ul><li>这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；</li><li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量（即可能只是元素多，并没有占用大内存）。</li></ul></li></ul><p><code>SCAN</code> 命令查找大 key</p><ul><li>原理：使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型，针对不同类型有不同的计算大小的方式：<ul><li>对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。</li><li>对于集合类型来说，有两种方法可以获得它占用的内存大小：1.平均大小 × 集合元素数量；2.<code>MEMORY USAGE</code>（需要Redis4.0），查询一个键值对占用的内存空间。</li></ul></li></ul><p><code>RdbTools</code> 工具查找大 key：</p><ul><li>原理：解析 Redis 快照（RDB）文件，找到其中的大 key。</li></ul><p><em>删除</em><br>在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。<br>删除方案有以下两种：</p><ul><li>分批次删除：对于集合元素，每次只删除少量元素。</li><li>异步删除（Redis 4.0版本以上）：<strong>用 unlink 命令代替 del 来删除</strong>，还可以通过配置参数，使Redis在达到某些条件的时候自动进行异步删除，如：<ul><li>lazyfree-lazy-eviction：表示当 Redis 运行<strong>内存超过 maxmeory</strong> 时，是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-expire：表示设置了<strong>过期时间的键值</strong>，当过期之后是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个<strong>隐式的 del 键的操作</strong>，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li><li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 <strong>flushall 来清理自己的数据</strong>，它表示此时是否开启 lazy free 机制删除。</li></ul></li></ul><p><em>避免</em><br>拆Value（大Key问题）：某Key的Value很大，每次使用需要整取整存，可以将该键值拆成多个键值。</p><h2 id="热Key问题"><a href="#热Key问题" class="headerlink" title="热Key问题"></a>热Key问题</h2><p><em>定义</em><br>QPS较高的key</p><p><em>影响</em><br>大量请求访问某个特定的key，导致流量过于集中，达到物理网卡的上限，导致Redis服务器宕机。</p><p><em>发现</em></p><ul><li>凭借业务经验，预估热Key</li><li>客户端收集访问频率</li><li>在Proxy层收集访问频率</li><li>Redis自带的命令：<code>monitor</code>、<code>redis-cli hotkeys</code>（可能造成卡顿）</li><li>抓包评估</li></ul><p><em>解决</em></p><ul><li>拆Key：即备份热Key，让key在每个Redis实例上都存一份，分散流量。具体地，每次访问hotkey时为该key拼接0~2N的随机数，若redis中没有则将该hotkey添加到缓存。</li><li>本地缓存：使用本地缓存，避免对中间件中热key的频繁访问</li></ul><p><em>业内解决方案</em></p><ol><li>热点发现：通过客户端&#x2F;Proxy进行热点探测，实现热点发现</li><li>通知系统：通知系统进行本地缓存</li></ol><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。<br><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.webp"><br><strong>管道技术可以解决多个命令执行时的网络等待</strong>，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端。</p><p><em>管道与批量命令的对比</em></p><ol><li>原生批量命令是原子的，Pipeline 是非原子的。</li><li>原生批量命令是一个命令对应多个 key，Pipeline 支持多个命令。</li><li>原生批量命令是 Redis 服务端支持实现的，而 Pipeline 需要服务端和客户端的共同实现</li></ol><p><em>适用场景</em><br><code>Pipeline</code>是 Redis 的一个提高吞吐量的机制，适用于<strong>多 key 读写场景</strong>，比如同时读取多个<code>key</code> 的<code>value</code>，或者更新多个<code>key</code>的<code>value</code>，并且允许一定比例的<strong>写入失败</strong>、<strong>实时性</strong>也没那么高。</p><p><em>注意事项</em></p><ul><li><code>Pipeline</code>是非原子的，即Redis 实际上还是一条一条的执行的，而执行命令是需要排队执行的，所以就会出现原子性问题，因此Pipeline执行的指令之间也不能有因果关系。</li><li><code>Pipeline</code>中包含的命令不要包含过多：<ul><li>发送的命令数量不会被限制，但输入缓存区也就是命令的最大存储体积为 1GB，当发送的命令超过此限制时，命令不会被执行，并且会被 Redis 服务器端断开此链接；</li><li>如果管道的数据过多可能会导致客户端的等待时间过长，导致网络阻塞；</li><li>部分客户端自己本身也有缓存区大小的设置，如果管道命令没有没执行或者是执行不完整，可以排查此情况或较少管道内的命令重新尝试执行。</li></ul></li><li><code>Pipeline</code>每次只能作用在一个 Redis 节点上。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><em>Redis的ACID</em></p><ul><li>A原子性：事务中有语句执行时报错并不会回滚，而是继续执行，<strong>不满足原子性</strong>（事务中的命令要不全部成功，要不全部失败）</li><li>C一致性：由于原子性和持久性无法满足，作为其目的的<strong>一致性自然无法满足</strong>。</li><li>I隔离性：Redis使用单线程处理请求，<strong>满足隔离性</strong>。</li><li>D持久性：Redis基于内存，RDB和AOF都有存储间隔，无法保证事务更新的数据持久化，<strong>不满足持久性</strong>。</li></ul><p><em>Redis 事务相关的命令</em><br>MULTI、EXEC、DISCARD、WATCH</p><p><em>回滚</em><br>Redis中事务没有提供回滚机制：</p><ul><li>WATCH命令本质是一种乐观锁实现，监控的键发生变化时会主动放弃执行。</li><li>DISCARD命令也不是ROLLBACK，该语句只会主动放弃事务的执行，其并没有实现回滚。</li></ul><p><em>为什么Redis不支持回滚</em></p><ul><li>Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现；</li><li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><em>分布式锁定义</em><br>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。</p><p><em>分布式锁的要求</em><br>为了实现分布式锁，需要实现以下能力：</p><ol><li>对锁的读取、检查、更改必须是一个原子操作</li><li>分布式锁需要有过期时间</li><li>需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作</li></ol><p><em>Redis实现加分布式锁</em><br>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，通过将值设置成客户端的唯一id，即可实现分布式锁的基本要求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET lock_key unique_value NX PX 10000 <br></code></pre></td></tr></table></figure><p><em>Redis实现解分布式锁</em><br>解锁时，需要要先判断锁的 unique_value 是否为加锁的客户端，若是才将 lock_key 键删除。为了保证该读锁和判锁的原子性，需要使用lua脚本实现Redis执行的原子性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><em>Redis分布式锁的优缺点</em></p><ul><li>优点：<ol><li>性能高效（这是选择缓存实现分布式锁最核心的出发点）。</li><li>实现方便。很多研发工程师选择使用 Redis 来实现分布式锁，很大成分上是因为 Redis 提供了 setnx 方法，实现分布式锁很方便。</li><li>避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）。</li></ol></li><li>缺点：<ol><li><strong>超时时间不好设置</strong>。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。</li><li><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</li></ol></li></ul><p><em>如何合理的设置超时时间？</em><br>可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。</p><p><em>集群模式下的分布式锁</em></p><ul><li>官方提供了RedLock算法：<ol><li>客户端记录开始时间t1。</li><li>客户端为所有redis节点加锁，加锁超时（几十毫秒）则判定失败。</li><li>当客户端成功加了N&#x2F;2+1的锁时，获取时间t2，判断总耗时<code>加锁耗时&lt; 锁过期时间</code>，若通过检测，说明上锁成功。</li><li>计算剩余有效时间，若<code>锁过期时间-加锁耗时&lt;业务需要的时间</code>则释放锁。</li></ol></li><li>简述：<strong>如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功，此时判断这个锁是否还有足够的时间完成业务员，不可用则直接释放。</strong></li><li>释放：释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</li></ul><h2 id="Session共享存储"><a href="#Session共享存储" class="headerlink" title="Session共享存储"></a>Session共享存储</h2><p><em>问题</em><br>在集群环境下，同一用户请求可能打到不同的服务器上，这些服务器需要分别为其创建Session，即用户有一定机率需要登录多次，这是不可容忍的。</p><p><em>解决方案</em></p><ol><li>粘性Session：Nginx每次将同一用户的所有请求转发到同一台服务器上。</li><li>服务器Session复制：每次Session发生变化时，广播到集群中所有服务器。</li><li>Session共享：通过共享缓存Redis、MemCache实现</li></ol><h1 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h1><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p><em>主从架构</em></p><ol><li>Master最好不要做RDB，一般由从节点做AOF（1秒1次）即可。</li><li>尽量避免在压力很大的Master上添加从节点。</li><li>主从复制可以采用链表结构而不是树桩结构。<ul><li>优点：可以更好发现单点故障，减少各节点同步压力，且主节点故障后可直接由其后继节点替换，避免选主。</li><li>缺点：则是多数节点同步延迟变高，从节点故障会影响所有后续链路。</li></ul></li></ol><p><em>内存优化</em></p><ol><li>尽可能使用Hash存储结构化数据，而不是使用多个String，海量的Key在集群模式分片模式中内存消耗较大。</li><li>好好利用 Hash,list,sorted set,set 等集合类型数据，通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。</li></ol><p><em>如何提高多核CPU利用率</em><br>单服务器部署多个Redis实例（但Redis的瓶颈是IO，而不是CPU）</p><h2 id="客户端选择"><a href="#客户端选择" class="headerlink" title="客户端选择"></a>客户端选择</h2><p><em>Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</em><br>Redisson、Jedis、lettuce 等等， 官方推荐使用 Redisson。</p><p><em>Jedis 与 Redisson 对比有什么优缺点？</em></p><ul><li>Jedis 是 Redis 的 Java 实现的客户端， 其 API 提供了比较全面的 Redis 命令的支持；</li><li>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单， 不支持字符串操作， 不支持排序、事务、管道、分区等 Redis 特性。</li><li>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h2 id="命令操作"><a href="#命令操作" class="headerlink" title="命令操作"></a>命令操作</h2><p><em>Redis的共同前缀</em></p><ul><li><code>keys</code>指令<ul><li>作用：获取所有key列表</li><li>缺点：由于Redis是单线程的，该操作会造成线程阻塞一段时间，线上服务停顿。</li></ul></li><li><code>scan</code>指令<ul><li>作用：<code>scan</code>命令是一个基于游标的迭代器，每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 <code>scan</code>命令的游标参数， 以此来延续之前的迭代过程。<code>scan</code>返回一个包含两个元素的数组， 第一个元素是用于进行下一次迭代的新游标， 而第二个元素则是一个数组， 这个数组中包含了所有被迭代的元素。如果新游标返回 <code>0</code> 表示迭代已结束。</li><li>集合遍历命令：<code>zscan</code>、<code>sscan</code>、<code>hscan</code></li><li>使用方式：<code>SCAN cursor [MATCH pattern] [COUNT count]</code>，获取到返回<code>cursor</code>后继续执行直到<code>cursor</code>为0。</li><li>缺点：遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的；有重复遍历的概率，需要客户端实现去重，整体花费时间比keys长。</li></ul></li></ul><p><em>Redis状况查看</em><br><code>info</code></p><p><em>Redis key 的过期时间和永久有效分别怎么设置？</em><br>EXPIRE 和 PERSIST 命令。</p><p><em>修改配置不重启 Redis 会实时生效吗？</em><br>很多配置可以在运行时通过<code>config set</code>命令进行修改，如RDB切换到AOF模式，但偶尔的重启是必须的，因为还有一些配置不支持在线修改。</p><h2 id="压测工具"><a href="#压测工具" class="headerlink" title="压测工具"></a>压测工具</h2><p>Redis 自带了一个叫 <strong>redis-benchmark</strong> 的工具来模拟 N 个客户端同时发出 M 个请求。 （类似于 Apache ab 程序）。可以使用 redis-benchmark -h 来查看基准参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">100000个请求、50个并发，只测试<span class="hljs-built_in">set</span>命令，使用管道传输（一次16个请求）</span><br>redis-benchmark -h 127.0.0.1 -p 6379 -n 100000 -c 50 -t set -P 16<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis常见问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第7章（性能监控）</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="状态命令"><a href="#状态命令" class="headerlink" title="状态命令"></a>状态命令</h1><ul><li>状态信息 - <code>info</code><br>通过<code>info</code>命令查看实时吞吐量（ops&#x2F;sec）。</li><li>监控执行命令 - <code>monitor</code><br>监控接受到的命令</li><li>监控延迟 - <code>latency</code><br>测量响应延迟<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --latency -h 127.0.0.1<br></code></pre></td></tr></table></figure></li><li>内部机制监控<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CONFIG SET latency-monitor-threshold 100 <span class="hljs-comment">#100是阈值，只有慢于100ms的才记录</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">latency latest <span class="hljs-comment">#查看最后一条消息的延迟</span></span><br><br></code></pre></td></tr></table></figure></li></ul><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="避免使用过于复杂的命令"><a href="#避免使用过于复杂的命令" class="headerlink" title="避免使用过于复杂的命令"></a>避免使用过于复杂的命令</h2><p>可以查看slowlog，查看执行慢的命令。</p><h2 id="操作BigKey"><a href="#操作BigKey" class="headerlink" title="操作BigKey"></a>操作BigKey</h2><p>如果value过大，分配内存会比较耗时。<br>可以通过<code>--bigkeys</code>命令扫描</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>避免使用bigkey</li><li>4.0版本以下，使用unlink代替del</li><li>6.0版本以上，开启lazy-free机制<div class="note note-primary">            <p>unlink和lazy-free都可以把释放内存放在后台线程中执行。</p>          </div></li></ul><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>随机过期时间</li><li>lazy-free</li></ul><h2 id="内存达到上限（max-memory）"><a href="#内存达到上限（max-memory）" class="headerlink" title="内存达到上限（max-memory）"></a>内存达到上限（max-memory）</h2><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>改成allkeys随机淘汰</li><li>拆分实例</li></ul><h2 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h2><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><ul><li>控制内存大小（fork与实例大小有关）</li><li>合理配置持久化策略</li></ul><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><p>我们都知道，应用程序向操作系统申请内存时，是按内存页进行申请的，而常规的内存页大小是 4KB。<br>Linux 内核从 2.6.38 开始，支持了内存大页机制，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。<br>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>关闭内存大页机制</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li>写磁盘的瓶颈</li><li>子线程将aof刷入盘中的过程如果阻塞也会影响主线程写aof</li></ul><p>一般下面一种情况发生在：</p><ul><li>正在重写aof</li><li>其他应用程序大量占用磁盘IO</li></ul><h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>配置中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>禁止了重写时的同步磁盘</p><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><p>避免了上下文切换，但Redis有子进程，子进程若大量占用被绑定的CPU，会导致主进程受阻。</p><h3 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h3><p>若一定要绑定，可绑定到多个CPU上，Redis6.0已经支持各线程分别绑定CPU</p><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><p>如果你对操作系统有些了解，就会知道操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。</p><h3 id="解决-7"><a href="#解决-7" class="headerlink" title="解决"></a>解决</h3><ul><li>增加内存</li><li>整理内存</li></ul><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>碎片内存会降低使用效率</p><h3 id="解决-8"><a href="#解决-8" class="headerlink" title="解决"></a>解决</h3><p>整理内存也CPU资源，需要谨慎</p><h2 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h2><h3 id="解决-9"><a href="#解决-9" class="headerlink" title="解决"></a>解决</h3><p>网络IO瓶颈，需要及时扩容。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第6章（缓存问题）</title>
    <link href="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <url>/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><ul><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩</li><li>缓存污染（或者满了）</li><li>缓存和数据库一致性</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>。<br>缓存不命中则会一直请求数据库，数据库查不到，又无法写入缓存。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>禁止非法请求，如校验参数合法性</li><li>数据库取不到的数据，在redis中置为key-null，防止大量数据库请求</li><li>bloomfilter，判断key是否在容器中</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（单一过期）<br>缓存过期导致大量针对该过期数据的请求段时间发生。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>设置数据永不过期</li><li>接口限流、熔断</li><li>互斥锁</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大</strong>（大量同时过期）</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。</p><h3 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h3><p><strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p><h3 id="新数据进入redis"><a href="#新数据进入redis" class="headerlink" title="新数据进入redis"></a>新数据进入redis</h3><p>当新数据进入redis时，如果内存不足怎么办？</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>通过<code>max-memory</code>配置设置淘汰策略<br>Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。</p><p><strong>怎么理解呢</strong>？主要看分三类看：</p><ul><li>不淘汰<ul><li>noeviction （v4.0后默认的）</li></ul></li><li>对设置了过期时间的数据中进行淘汰<ul><li>随机：volatile-random</li><li>ttl：volatile-ttl</li><li>lru：volatile-lru</li><li>lfu：volatile-lfu</li></ul></li><li>全部数据进行淘汰<ul><li>随机：allkeys-random</li><li>lru：allkeys-lru</li><li>lfu：allkeys-lfu</li></ul></li></ul><p>具体而言：</p><ol><li>noeviction<br>写满了就停止服务。</li><li>volatile-random<br>对会过期的键随机删除</li><li>volatile-ttl<br>对即将过期的时间进行排序，删除</li><li>volatile-lru(last-recently-used)<br>对最后使用时间进行排序，删除最后一次使用较早的数据</li><li>volatile-lfu（4.0后新增）<br>对使用次数进行排序，删除最少使用的数据</li><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ol><div class="note note-primary">            <p>淘汰策略 不是 过期清理策略，其不太关心键是否已经过期，只将是否设置了过期、过期时间作为筛选的范围。<br>volatile的挑选范围是<code>所有可能过期的数据</code>。<br>allkeys的挑选范围是<code>所有数据</code>。</p>          </div><h4 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h4><ul><li>redis每个数据都会记录最后访问的时间戳（redisObject的lru字段，24位时间戳）和最近使用次数（只有开启LFU时才记录，字段变成lfu，16位时间戳+8位访问次数）。</li><li>LRU淘汰时：<ul><li>随机选N个数据（可以通过maxmemory-samples设置）</li><li>排序lru字段</li><li>淘汰lru最小的数据</li></ul></li><li>LFU淘汰时：<ul><li>根据访问次数筛选（lru字段后8bit）</li><li>淘汰访问次数最低的数据（次数相同则比较最后使用时间，前16bit）</li></ul></li></ul><blockquote><p>8bit只能记录255次使用，到达后LFU会退化为LRU，因此有策略控制lfu的增长。</p></blockquote><p><code>lfu-log-factor</code>，有新访问时，只有满足一定算法条件时才count++<br><code>lfu-decay-time</code>，有新访问时，会按照算法对count进行衰减。</p><h2 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h2><p>一般流程：<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105015406.jpg"></p><p>修改数据库数据时，缓存与数据库必然存在不一致情况：<br>1.先写数据库，再删除redis，后者的删除可能未执行<br>2.先删除redis，再写数据库，后者还未执行redis可能就又刷新了。</p><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p><strong>写后失效缓存</strong><br>读时：</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。<br>写时：</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><h4 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br>相比Cache Aside模式：<br>读时：</p><ul><li><strong>失效</strong>：都会查找数据库然后同步到缓存，但Read Pattern会先缓存再返回。<br>写时：</li><li><strong>更新</strong>：Write Pattern会先<strong>更新</strong>缓存再写数据库，最后返回。<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105020042.png"></li></ul><h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105023335.png"><br>性能高，但数据一致性弱，实现较复杂，要判断哪些需要持久化。</p><h3 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h3><h4 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h4><p>以Cache Aside Pattern为例：<br>读操作（失效时）：1.查找数据库 2.更新缓存<br>写操作：1.修改数据库 2.失效缓存</p><p>同步进行读、写时，若读写先后完成了对数据库的查询、修改，此时写操作先失效缓存导致读操作将旧信息更新到了缓存。<br>即 读1-&gt;写1-&gt;写2-&gt;读2</p><p>该事件这个概率较低，其只发生在读时失效且刚好有并发写操作，且写操作较慢且需要锁表，读操作一般肯定已经完成，所以这个概率会很低。当然最好还是为缓存设置过期时间。</p><h4 id="缓存更新失效"><a href="#缓存更新失效" class="headerlink" title="缓存更新失效"></a>缓存更新失效</h4><p>解决写操作第二步：失效缓存因为异常导致没有执行的问题</p><h5 id="方案1：队列-重试"><a href="#方案1：队列-重试" class="headerlink" title="方案1：队列+重试"></a>方案1：队列+重试</h5><p><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105024206.png"><br>优点：队列解决了缓存更新失败的问题<br>缺点：对代码的侵入量大，影响服务速度</p><h5 id="方案2：队列-重试-非业务代码做异步更新缓存"><a href="#方案2：队列-重试-非业务代码做异步更新缓存" class="headerlink" title="方案2：队列+重试+非业务代码做异步更新缓存"></a>方案2：队列+重试+非业务代码做异步更新缓存</h5><p><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105181554.png"><br>由非业务代码读取mysql的操作，然后更新缓存。<br>优点：不侵入业务<br>缺点：同步速度慢<br>例子：canal</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第5章（高可用）</title>
    <link href="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <url>/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p></blockquote><p><strong>主从复制的作用</strong>主要包括：<br>性能上：</p><ul><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>读写分离</strong>：<ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li></ul></li></ul><p>稳定性上：</p><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>1.从节点 发送指令replicaof ip port，主节点接受并响应<br>2.从节点 连接master的socket<br>3.从节点 发送指令auth password<br>4.主节点 验证授权<br>5.从节点 发送自身信息，主节点保存slave</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>全量复制</li><li>增量复制</li></ul><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104040638.jpg"><br><strong>第一阶段</strong>：主从库间建立连接、协商同步的过程。</p><ul><li>从节点发送psync命令，其应该包含主库的runId和offset，但这是初次复制，所以发送的runId&#x3D;?,offset&#x3D;-1。</li><li>主节点回复FULLRESYNC，并携带runId和offset，告诉从节点自身信息。</li></ul><p><strong>第二阶段</strong>：主库将所有数据同步给从库。</p><ul><li>主库执行bgsave，将其发送给从库。</li><li>从库接受到RDB时，先清空数据库，再加载RDB。</li><li>主库在这一阶段会把新的写命令记录在repl buffer中。</li></ul><p><strong>第三阶段</strong>：主库发送期间同步期间产生的新的写命令。</p><div class="note note-primary">            <p>注意这里的repl buffer，前面讲AOF持久化时，也有一个aof_buffer，用于记录<strong>重写</strong>时的新写入命令。</p>          </div><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><blockquote><p>每次都全量复制的开销过大。</p></blockquote><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104041537.jpg"></p><p><code>repl_backlog_buffer</code>：环形缓冲区，用于记录写命令（会覆盖）。repl_baklog文件记录了命令偏移，<strong>主节点的offset</strong>和<strong>从节点的offset</strong>（但还是会以从节点ask发来的offset为准）。</p><p><code>replication buffer</code>：每个client连上Redis后，<strong>Redis都会分配一个client buffer</strong>，所有数据交互都是通过这个buffer进行的。Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。repl buffer的默认大小为1M。</p><h4 id="全量复制还是增量复制？"><a href="#全量复制还是增量复制？" class="headerlink" title="全量复制还是增量复制？"></a>全量复制还是增量复制？</h4><p>从库会记录自己的<code>slave_repl_offset</code>，恢复连接时，从库会通过<code>psync</code>发送自己的offset，主库根据这个offset判断进行增量还是全量复制。（如果<code>repl_backlog_buffer</code>的<code>slave_repl_offset</code>已经被覆盖，进全量复制）。</p><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741726.png"></p><div class="note note-primary">            <p>run id是属于主机的唯一的id。</p>          </div><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741728.png"></p><div class="note note-primary">            <p>主从节点都会发心跳，目的都有判断对方是否在线，此外从节点还会汇报自己的复制进度。</p>          </div><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741729.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741730.png"></p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="主服务器持久化与安全性"><a href="#主服务器持久化与安全性" class="headerlink" title="主服务器持久化与安全性"></a>主服务器持久化与安全性</h3><ul><li>主从复制时，主服务器强烈建议开启持久化。</li><li>若主节点没有开启持久化，又开启了自动重启，重启后主节点数据库为空，而从节点对其进行全量复制，会导致从节点数据也被删除。</li><li>所以，若主节点没有开启持久化，应该禁止自动重启。</li></ul><h3 id="为什么主从全量复制使用RDB而不使用AOF"><a href="#为什么主从全量复制使用RDB而不使用AOF" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF"></a>为什么主从全量复制使用RDB而不使用AOF</h3><ul><li>RDB文件很小，适合传输</li><li>RDB加载很快，适合恢复</li><li>AOF使用不当，会严重影响Redis性能</li></ul><h3 id="无磁盘复制模式"><a href="#无磁盘复制模式" class="headerlink" title="无磁盘复制模式"></a>无磁盘复制模式</h3><p>主服务器磁盘速度较低时，RDB会带来一些负担，<strong>无磁盘复制模式</strong>是指：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。<br>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><h3 id="从库的从库"><a href="#从库的从库" class="headerlink" title="从库的从库"></a>从库的从库</h3><p>对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。<br>通过“主 - 从 - 从”模式可以<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104045116.jpg"><br>后续的写同步也可以级联传播。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="延迟与不一致问题"><a href="#延迟与不一致问题" class="headerlink" title="延迟与不一致问题"></a>延迟与不一致问题</h4><p><strong>优化</strong>：优化网络环境、舍弃大延迟从节点，使用集群扩展读负载能力。</p><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><p>单机redis的删除策略</p><ul><li><strong>惰性删除</strong>：客户端查询数据时才判断是否过期，过期则删除</li><li><strong>定期删除</strong>：服务器定时任务删除过期数据</li></ul><p>主从复制时，从节点不主动删除，而是由主节点控制从节点删除（保证数据一致性），但由于主节点不会立即删除过期数据，客户端在从节点上容易读到过期数据。<br><strong>解决</strong>：Redis3.2中，从节点也会判断数据过期。</p><h4 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h4><p>主&#x2F;从节点发生故障时，要及时切换客户端的Redis连接。</p><ul><li>手动：响应慢，容易出错</li><li>监控程序：实现复杂</li></ul><div class="note note-primary">            <p>使用哨兵即可解决这个问题。</p>          </div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><blockquote><p>哨兵Redis Sentinel的核心功能是协助完成自动故障转移。</p></blockquote><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>监控：监听主从节点运作</li><li>自动故障转移：更改主节点</li><li>配置提供：向客户端提供节点信息</li><li>通知：通知客户端故障转移的结果</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="集群组建"><a href="#集群组建" class="headerlink" title="集群组建"></a>集群组建</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223227.jpg"></p><ul><li>主节点上有一个<code>_sentinel_:hello</code>频道，哨兵们通过该频道实现互相发现。</li><li>互相发现后哨兵之间建立连接。</li></ul><h3 id="监控Redis库"><a href="#监控Redis库" class="headerlink" title="监控Redis库"></a>监控Redis库</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223410.jpg"></p><ul><li>哨兵向主节点发送<code>INFO</code>命令，根据接受到的Slave列表与各从库建立连接</li></ul><h3 id="主库下线判断"><a href="#主库下线判断" class="headerlink" title="主库下线判断"></a>主库下线判断</h3><p>下线概念：</p><ul><li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223530.jpg"></li><li>哨兵判断主库下线后，向其他哨兵发送<code>is-master-down-by-addr</code>命令，其他哨兵作出Y或N响应。</li><li>如果赞成票大于配置项<code>quorum</code>，判定主库客观下线。</li></ul><h3 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h3><p>客观下线后，需要选举一个主哨兵执行最终调整命令</p><ul><li>选举算法：<ul><li>Raft选举算法： 选举的票数大于等于num(sentinels)&#x2F;2+1时，将成为领导者，如果没有超过，继续选举。</li></ul></li><li>成为Leader的前提：<ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <code>quorum</code> 值。</li></ul></li></ul><div class="note note-primary">            <p>这里注意，判断客观下线需要得到大于<code>quorum</code>的赞成票，选举leader需要半数以上<strong>且</strong>大于<code>quorum</code>值的赞成票。<br>即，若有哨兵掉线导致无法超过半数，也无法实现Leader选举</p>          </div><h3 id="新主库选择"><a href="#新主库选择" class="headerlink" title="新主库选择"></a>新主库选择</h3><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><div class="note note-primary">            <p>先选活的，再选关系户，最后选有实力的，都没法就选runID小的。</p>          </div><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104224208.png"></p><ul><li>让新主库脱离原主库（replicaof no one）</li><li>让其他从库成为新主库的从节点</li><li>通知应用程序新redis主节点</li><li>原主库上线后变成新主节点的从节点</li></ul><h1 id="分片技术"><a href="#分片技术" class="headerlink" title="分片技术"></a>分片技术</h1><blockquote><p>主从复制解决了主节点崩溃的备份问题，并通过读写分离提高了性能。<br>哨兵机制解决了主节点崩溃时的崩溃转移问题。<br>但这都没有扩展Redis的写能力和存储能力，因此Redis引入了集群的功能。</p></blockquote><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="哈希槽-Hash-Slot"><a href="#哈希槽-Hash-Slot" class="headerlink" title="哈希槽(Hash Slot)"></a>哈希槽(Hash Slot)</h3><p>Redis-cluster没有使用一致性hash，而是引入了<strong>哈希槽</strong>的概念。Redis-cluster中有<strong>16384(即2的14次方)个哈希槽</strong>，每个key通过CRC16校验后对16383取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。</p><h3 id="Keys-hash-tags"><a href="#Keys-hash-tags" class="headerlink" title="Keys hash tags"></a>Keys hash tags</h3><p>Hash tags提供了一种途径，<strong>用来将多个(相关的)key分配到相同的hash slot中</strong>。这时Redis Cluster中实现multi-key操作的基础。<br>hash tag规则如下，如果满足如下规则，<code>&#123;</code>和<code>&#125;</code>之间的字符将用来计算HASH_SLOT，以保证这样的key保存在同一个slot中。</p><p>例如：hash(“{user1}.name”) &#x3D;&#x3D; hash(“{user1}.age”)</p><h3 id="Cluster-nodes属性"><a href="#Cluster-nodes属性" class="headerlink" title="Cluster nodes属性"></a>Cluster nodes属性</h3><p>每个<strong>节点在cluster中有一个唯一的名字</strong>。<br>这个名字由160bit随机十六进制数字表示，并在节点启动时第一次获得(通常通过&#x2F;dev&#x2F;urandom)。节点在配置文件中保留它的ID，并永远地使用这个ID，直到被管理员使用CLUSTER RESET HARD命令hard reset这个节点。<br>这样节点可以实现IP的变化而不影响其在集群中的定位。</p><p>每个节点维护集群内其他节点的以下信息：</p><ul><li><code>node id</code>，<code>节点的IP和port</code>，<code>节点标签</code>，<code>master node id</code>（如果这是一个slave节点）</li><li><code>最后被挂起的ping的发送时间</code>(如果没有挂起的ping则为0)，<code>最后一次收到pong的时间</code></li><li><code>当前的节点configuration epoch</code>（配置版本号） ，<code>链接状态</code>，以及该节点服务的<code>hash slots</code>。</li></ul><div class="note note-primary">            <p>即维护基本身份（node id,ip port,从属）,存活信息（ping pong），服务信息（版本号、连接、slots）</p>          </div><h3 id="Cluster总线"><a href="#Cluster总线" class="headerlink" title="Cluster总线"></a>Cluster总线</h3><p>每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接。</p><p>这个端口与用来接收client命令的普通TCP端口有一个固定的offset。如该端口等于普通命令端口加上10000.例如，一个Redis街道口在端口6379坚挺客户端连接，那么它的集群总线端口16379也会被打开。</p><blockquote><p>节点到节点的通讯只使用集群总线，同时使用集群总线协议：有不同的类型和大小的帧组成的二进制协议。</p></blockquote><h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点总是接受集群总线端口的链接，并且总是会回复ping请求，即使ping来自一个不可信节点。然而，如果发送节点被认为不是当前集群的一部分，所有其他包将被抛弃。</p><p>节点认定其他节点是当前集群的一部分有两种方式（阶段）：</p><ul><li>节点接受到一条meet消息，其会将meet消息的发送节点视为集群内节点。</li><li>节点接受到其信任的节点的gossip信息，其会将gossip信息中提到的新节点标记为集群内节点。</li></ul><h3 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h3><p>Redis Cluster是一张全网拓扑，节点与其他每个节点之间都保持着TCP连接。<br>节点之间使用gossip协议更新避免过多的消息交换。</p><div class="note note-danger">            <p>上面主要是cluster的主要模块，涉及到以下几个方面：</p><ul><li>分片：使用了<strong>哈希槽</strong>的方法对键进行分片，同时使用<strong>keys hash tags</strong>技术实现了定向的分片。</li><li>通讯：节点会开启<strong>cluster总线</strong>监听、返回消息，其会记录各个<strong>cluster nodes</strong>的基本信息。</li><li><strong>握手</strong>：节点监听到meet消息或信任节点的gossip消息会将目标节点加入到集群内。</li></ul>          </div><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><ul><li>检查当前key是否存在当前NODE？<ul><li>通过crc16（key）&#x2F;16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果<ul><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？<ul><li>若slot正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若slot未迁出，检查Slot是否导入中？<ul><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul></li></ul></li></ul></li></ul><h4 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233215.png"></p><h4 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233422.png"></p><h4 id="SMART客户端"><a href="#SMART客户端" class="headerlink" title="SMART客户端"></a>SMART客户端</h4><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来<strong>减低复杂性，追求更好的性能</strong>。<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233615.png"></p><p>客户端通过cluster slots命令获取集群信息，依据其自主计算目标key所在的节点，直接对目标节点进行访问。</p><blockquote><p>失败时，进行随机访问节点、更新自身映射表并重新访问，若失败过多则放弃。</p></blockquote><div class="note note-warning">            <p>简而言之，客户端请求后，节点判断是否由自己处理，不由自己处理则MOVED，由自己处理但发现slot已经迁移则ASK。<br>SMART客户端则自身计算slots的工作，映射失效时则随机访问节点刷新映射。</p>          </div><h3 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h3><p>Cluster中的每个节点都维护一份在自己看来当前整个集群的状态，主要包括：</p><ul><li>当前集群状态</li><li>集群中各节点所负责的slots信息，及其migrate状态</li><li>集群中各节点的master-slave状态</li><li>集群中各节点的存活状态及不可达投票</li></ul><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>gossip 协议（gossip protocol）又称 epidemic 协议（epidemic protocol）是一种P2P2协议，Gossip协议的最大的好处是，<strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许Consul管理的集群规模能横向扩展到数千个节点</strong>。</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><code>Meet</code> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><code>Ping</code> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><code>Pong</code> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><code>Fail</code> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><div class="note note-primary">            <p>meet用于新增节点，ping&#x2F;pong维护，fail用于下线节点</p>          </div><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>在某节点看来，其他节点的状态有<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p><ul><li>节点A发现某节点B下线时，将其标记为PFAIL，并通知附近节点C。</li><li>节点C接受到消息后，确认真假，将该状态记录并继续传播PFAIL消息。</li><li>最后节点判断其是否客观下线（<strong>自己认为</strong> 且 <strong>发现过半节点认为其疑似下线PFIAL</strong>），若客观下线，其会发送FAIL消息让所有节点接受节点A客观下线。</li></ul><h3 id="通讯维护"><a href="#通讯维护" class="headerlink" title="通讯维护"></a>通讯维护</h3><h4 id="什么时候进行心跳？"><a href="#什么时候进行心跳？" class="headerlink" title="什么时候进行心跳？"></a>什么时候进行心跳？</h4><p>Redis节点会记录其向每一个节点上一次发出ping和收到pong的时间，心跳发送时机与这两个值有关。通过下面的方式既能保证及时更新集群状态，又不至于使心跳数过多：</p><ul><li>每次Cron向所有未建立链接的节点发送ping或meet</li><li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li><li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li><li>收到ping或meet，立即回复pong</li></ul><h4 id="发送哪些心跳数据？"><a href="#发送哪些心跳数据？" class="headerlink" title="发送哪些心跳数据？"></a>发送哪些心跳数据？</h4><ul><li>Header，发送者自己的信息<ul><li>所负责slots的信息</li><li>主从信息</li><li>ip port信息</li><li>状态信息</li></ul></li><li>Gossip，发送者所了解的部分其他节点的信息<ul><li>ping_sent, pong_received</li><li>ip, port信息</li><li>状态信息，比如发送者认为该节点已经不可达，会在状态信息中标记其为PFAIL或FAIL</li></ul></li></ul><h4 id="如何处理心跳？"><a href="#如何处理心跳？" class="headerlink" title="如何处理心跳？"></a>如何处理心跳？</h4><h5 id="新节点加入"><a href="#新节点加入" class="headerlink" title="新节点加入"></a>新节点加入</h5><ul><li>发送meet包加入集群</li><li>从pong包中的gossip得到未知的其他节点</li><li>循环上述过程，直到最终加入集群<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104235107.png"></li></ul><h5 id="Slots消息"><a href="#Slots消息" class="headerlink" title="Slots消息"></a>Slots消息</h5><ul><li>判断发送者声明的slots信息，跟本地记录的是否有不同</li><li>如果不同，且发送者epoch较大，更新本地记录</li><li>如果不同，且发送者epoch小，发送Update信息通知发送者</li></ul><h5 id="Master-slave信息"><a href="#Master-slave信息" class="headerlink" title="Master slave信息"></a>Master slave信息</h5><p>发现发送者的master、slave信息变化，更新本地状态</p><h5 id="节点Fail探测-故障发现"><a href="#节点Fail探测-故障发现" class="headerlink" title="节点Fail探测(故障发现)"></a>节点Fail探测(故障发现)</h5><p>超时没有收到某节点pong包，标记其PFAIL，并在pong时传播这个标记。</p><blockquote><p>注：Gossip的存在使得集群状态的改变可以更快的达到整个集群。每个心跳包中会包含多个Gossip包，那么多少个才是合适的呢，redis的选择是N&#x2F;10，其中N是节点数，这样可以保证在PFAIL投票的过期时间内，节点可以收到80%机器关于失败节点的gossip，从而使其顺利进入FAIL状态。</p></blockquote><h3 id="故障恢复（Failover）"><a href="#故障恢复（Failover）" class="headerlink" title="故障恢复（Failover）"></a>故障恢复（Failover）</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>通过某个slave执行cluster failover命令，手动让某个master宕机，并将本slave作为master节点。<br>此时命令还包括一些流程处理，如校验offset，查看master状态和询问其他master意见等。</p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave。Failover的过程需要经过类Raft协议的过程在整个集群内达到一致，其过程如下：</p><ul><li>slave发现自己的master变为FAIL</li><li>将自己记录的集群currentEpoch加1，并广播Failover Request信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新Master</li><li>广播Pong通知其他集群节点<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230105001028.png"></li></ul><h3 id="扩容-amp-缩容"><a href="#扩容-amp-缩容" class="headerlink" title="扩容&amp;缩容"></a>扩容&amp;缩容</h3><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ol><li>首先将新节点加入到集群中，可以通过在集群中任何一个客户端执行cluster meet 新节点ip:端口，或者通过redis-trib add node添加，新添加的节点默认在集群中都是主节点。</li><li>迁移数据 迁移数据的大致流程是，首先需要确定哪些槽需要被迁移到目标节点，然后获取槽中key，将槽中的key全部迁移到目标节点，然后向集群所有主节点广播槽（数据）全部迁移到了目标节点。</li></ol><h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>缩容的大致过程与扩容一致，需要判断下线的节点是否是主节点，以及主节点上是否有槽，若主节点上有槽，需要将槽迁移到集群中其他主节点，槽迁移完成之后，需要向其他节点广播该节点准备下线（cluster forget nodeId）。最后需要将该下线主节点的从节点指向其他主节点，当然最好是先将从节点下线。</p><h2 id="更深入理解"><a href="#更深入理解" class="headerlink" title="更深入理解"></a>更深入理解</h2><h3 id="为什么Redis-Cluster的Hash-Slot是16384？"><a href="#为什么Redis-Cluster的Hash-Slot是16384？" class="headerlink" title="为什么Redis Cluster的Hash Slot是16384？"></a>为什么Redis Cluster的Hash Slot是16384？</h3><p>我们知道一致性hash算法是2的16次方（65535），为什么hash slot是2的14次方（16384）呢？</p><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，使用bitmap压缩，16384bit &#x3D; 16kb &#x3D; 2kB，也就是说使用2kB的空间创建了16k的槽数。如果使用CRC16分配65535个槽位，需要使用8kB才行，作者认为没有必要。</p><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢？"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢？" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢？"></a>为什么Redis Cluster中不建议使用发布订阅呢？</h3><p>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会<strong>严重消耗带宽</strong>，不建议使用。（虽然官网上讲有时候可以使用Bloom过滤器或其他算法进行优化的。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第4章（事件与事物）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><p>Redis的单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的。<br>Redis程序并不是单线程的，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，有2个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了1个后台线程，用来异步释放 Redis 内存，即lazyfree 线程。</li></ul><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20231001213203.png"></p><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>所谓事件机制，指的是Redis 接受客户端的请求并响应（文件事件） 和 执行定时任务（时间事件） 的机制。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><div class="note note-primary">            <p>文件事件指交互性事件，时间事件指定时类执行事件。</p>          </div><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104015729.png"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p><p>Redis 是单线程主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>。采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。</p><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020000.png"></p><div class="note note-primary">            <p>这里还没学，暂时理解为netty、ae_event(Redis使用的)等是异步处理IO复用的应用框架，底层的实现库是与操作系统的具体实现有关。</p>          </div><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020123.png"><br>I&#x2F;O多路复用程序监听多个套接字（客户端），当需要套接字IO时，产生一个文件事件，Redis将这些就绪的文件事件放在一个队列中（fired就绪事件表），然后文件事件处理器会有序、同步、单个的执行一个个文件事件。</p><p>某客户端请求流程如下：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020550.png"></p><h3 id="Redis-IO多路复用模型"><a href="#Redis-IO多路复用模型" class="headerlink" title="Redis IO多路复用模型"></a>Redis IO多路复用模型</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020629.jpg"></p><div class="note note-primary">            <p>这里理解为epoll是一个操作系统内核机制，其监听了3个FD（套接字），当发生事件时，事件入列，然后逐个出列调用函数。</p>          </div><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis 的时间事件分为以下两类：</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：也就是说时间处理器处理某个事件后，判断其需不需要过一段时间再次执行。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104022102.png"><br>所有事件时间放在一个无序链表中，时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件并调用相应事件处理器。</p><blockquote><p>一般Redis服务器只使用serverCron一个时间事件，这个事件用于更新服务器各类统计数据，清理键值，整理客户端连接，尝试AOF或RDB，同步数据，心跳检测等。总之，Redis会周期性的执行这个函数。</p></blockquote><h2 id="aeEventLoop实现"><a href="#aeEventLoop实现" class="headerlink" title="aeEventLoop实现"></a>aeEventLoop实现</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。具体过程是其会调用aeCreateEventLoop函数：</p><ul><li>创建该aeEventLoop对象。</li><li>初始化文件事件表内容</li><li>初始化时间事件表</li><li>调用aeApiCreate函数创建epoll实例，初始化apidata<br>具体实现不细看了，逻辑图如下<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104024156.png"></li></ul><h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li><code>MULTI</code> ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li><code>EXEC</code>：执行事务中的所有操作命令。</li><li><code>DISCARD</code>：取消事务，放弃执行事务块中的所有命令。</li><li><code>WATCH</code>：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li><code>UNWATCH</code>：取消WATCH对所有key的监视。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>语法错误：若存在语法错误，整个事务不会被执行。</li><li>类型错误：若在执行时发送Redis类型错误，该条命令失败，但其他命令正常执行。</li></ul><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p>WATCH命令为Redis事务提供了CAS的行为：<br>当执行了WATCH命令监视某键后，在执行时发现与WATCH时相比，键值发生了变化，则回滚事务。最后会取消监控。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025042.png"></p><h3 id="事物执行步骤"><a href="#事物执行步骤" class="headerlink" title="事物执行步骤"></a>事物执行步骤</h3><ul><li>MULTI开始</li><li>入队</li><li>执行<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025058.png"></li></ul><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>redis悲观锁又称为分布式锁，主要是为了防止数据被其他客户改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>通过以上命令可以设置分布式锁(key&#x3D;lock-key)：</p><ul><li>若设置成功，会返回值，拥有控制权。</li><li>若设置失败，无返回值，需要排队等待。<br>期间其他客户无法操作lock-key。<br>操作完毕后通过<strong>del操作释放锁</strong>。</li></ul><h3 id="分布式锁改良"><a href="#分布式锁改良" class="headerlink" title="分布式锁改良"></a>分布式锁改良</h3><p>使用expire为lock-key设置过期时间，防止忘记或程序中断导致忘记释放锁</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="Redis不支持回滚？"><a href="#Redis不支持回滚？" class="headerlink" title="Redis不支持回滚？"></a>Redis不支持回滚？</h3><p>redis只会因命令编写错误（主要指类型错误这种无法提前检测的命令）而失败，这个错误是在编程时应该避免的。</p><h3 id="ACID？"><a href="#ACID？" class="headerlink" title="ACID？"></a>ACID？</h3><ul><li>原子性<em>atomicity</em><br>有观点认为Redis没有原子性，因为其不支持运行期回滚，但Redis官方的理解如下：<br><strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。</strong>这个过程并不保证执行成功。</li><li>一致性<em>consistency</em><br>Redis能保证命令失败的情况下不执行（普通语法错误、WATCH锁），能保证一致性。**<code>WATCH</code>监视并不是在事务中某一条使用了被监视键的命令执行前检查，而是在整个事务开始前就检查所有被监视的键是否被修改**。</li><li>隔离性<em>Isolation</em><br><strong>单线程</strong>的本质保证了隔离性（不会被其他客户端打断）</li><li>持久性<em>Durability</em><br><strong>redis事务是不保证持久性的</strong>，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</li></ul><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><ul><li><strong>基于Lua脚本</strong>，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li><strong>基于中间标记变量</strong>，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h1 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h1><blockquote><p>删除作为一个redis事件，也放在本章一起阐述。</p></blockquote><p>使用<code>TTL</code>可以查看键的生命状态：</p><ul><li>xx为时效数据</li><li>1为永久有效数据</li><li>2为已经过期或不存在的数据</li></ul><h2 id="常见的删除策略"><a href="#常见的删除策略" class="headerlink" title="常见的删除策略"></a>常见的删除策略</h2><ol><li>定时删除：定时任务，到时即删除</li><li>定期删除：定期清理，serverCron()中会执行删除。</li><li>惰性删除：访问时删除，调用expireIfNeeded函数</li></ol><div class="note note-success">            <p>redis使用的是<strong>惰性删除</strong>和<strong>定期删除</strong></p>          </div><div class="note note-primary">            <p>对于RDB，其不会记录已经删除的键<br>对于AOF，键过期后会在文件后面加上DEL key的命令。</p>          </div><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105004950.png"></p><p>这个格式不是redisObject的格式，而是redis数据库的一个格式。<br>redisDB结构中expires保存了所有的键过期信息。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105010244.png"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第3章（持久化）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="持久化：RDB和AOF机制详解"><a href="#持久化：RDB和AOF机制详解" class="headerlink" title="持久化：RDB和AOF机制详解"></a>持久化：RDB和AOF机制详解</h2><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(<em>Redis DataBase</em>)持久化</h3><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><blockquote><p><strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><code>save</code>命令：由主线程执行，会造成长时间阻塞。</li><li><code>bgsave</code>命令：fork子线程执行，阻塞只发生在fork阶段。</li></ul><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103211303.png"></p><p>具体流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，<strong>那么主进程直接返回</strong>；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子<strong>替换</strong>旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_相关选项）。</li></ul><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>由以下4种触发情况</p><ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul><p><strong>相关配置</strong><br><code>stop-writes-on-bgsave-error</code>：bgsave错误时暂停主线程，主要目的是让运维人员排查问题<br><code>rdbcompression</code>：启用LZF压缩算法<br><code>rdbchecksum</code>：64位CRC冗余校验编码，可以验证RDB的完整性。</p><h4 id="深入RDB"><a href="#深入RDB" class="headerlink" title="深入RDB"></a>深入RDB</h4><ul><li><p><strong>并发问题？</strong><br><a href="https://zhuanlan.zhihu.com/p/339437815#:~:text=%20Redis%E4%B8%AD%E6%89%A7%E8%A1%8CBGSAVE%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90RDB%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E8%B0%83%E7%94%A8Linux%E4%B8%AD%E7%9A%84fork%20%28%29%E5%91%BD%E4%BB%A4%EF%BC%8CLinux%E4%B8%8B%E7%9A%84fork,%28%29%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%BA%86copy-on-write%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9B%20fork%20%28%29%E4%B9%8B%E5%90%8E%EF%BC%8Ckernel%E6%8A%8A%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E6%9D%83%E9%99%90%E9%83%BD%E8%AE%BE%E4%B8%BAread-only%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%8C%87%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%82%20%E5%BD%93%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%83%BD%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E3%80%82">Copy-on-Write</a><br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103215527.jpg"><br>如果主线程需要进行写操作，则将写操作部分的数据块复制，对新的副本进行修改，这样保证了bgsave子进程可见的数据的一致性（即bgsave开始时的快照）</p></li><li><p><strong>若服务崩溃怎么办？</strong><br>bgsave的temp文件在生成之前不会覆盖旧的dump。</p></li><li><p><strong>能否尽可能快的RDB</strong>?<br>快照过快会导致fork大量阻塞主线程，且磁盘空间是有限的。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li><strong>LZF压缩算法，文件体积远小于内存</strong></li><li>加载速度比AOF快</li></ul></li><li>缺点<ul><li><strong>实时性不够</strong></li><li><strong>开销大</strong></li><li>版本兼容</li><li>RDB文件无法手动修改</li></ul></li></ul><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append only file)持久化"></a>AOF(<em>append only file</em>)持久化</h3><p>执行写命令时，<strong>先写内存，后写日志</strong>。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220350.jpg"></p><blockquote><p>目的：</p><ol><li>避免额外检查，执行成功才写日志</li><li>不阻塞当前写操作</li></ol><p>风险：</p><ol><li>完成写内存后中断，日志缺失</li><li>主线程写磁盘压力过大</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220620.jpg"></li><li><strong>AOF重写</strong> Redis通过创建一个新的AOF文件来替换现有的AOF。</li></ul><div class="note note-primary">            <p>aof_buf缓存写命令，触发写回时将aof_buf中命令一次写入磁盘</p>          </div><p><strong>相关配置</strong><br><code>appendfsync</code>：主要用于设置“真正执行”操作命令向AOF文件中同步的策略，支持always、everysec、no，默认为everysec。<br><code>no-appendfsync-on-rewrite</code>：<strong>重写</strong>时不再记录新命令<br><code>auto-aof-rewrite-percentage</code>：当前AOF文件超过上次重写AOF文件大小的百分之多少后开始重写。<br><code>auto-aof-rewrite-min-size</code>：当前AOF文件超过设置大小时开始重写</p><h4 id="深入AOF重写"><a href="#深入AOF重写" class="headerlink" title="深入AOF重写"></a>深入AOF重写</h4><ul><li><strong>AOF重写会阻塞吗</strong>？</li></ul><p>重写时会fork主线程，由后台进程bgrewriteaof完成，fork时会阻塞主线程。</p><ul><li><strong>何时重写</strong>？</li></ul><p>auto-aof-rewrite-percentage和auto-aof-rewrite-min-size</p><ul><li><strong>并发问题</strong>？</li></ul><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103221653.jpg"></p><p>重写时:<br>    - redis原始数据会通过copy on write机制拷贝<br>    - 服务器写入新数据时，会将新数据同时写入两个aof_buf缓存区（当持久化策略为always时，则是写入磁盘和一个aof_buf缓冲），<strong>子线程</strong>完成重写后通知主线程，<strong>主线程</strong>会把aof重写缓冲区的命令追加到aof文件中。最后文件改名，保证原子性。</p><blockquote><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会<strong>拷贝父进程的页表</strong>，即<strong>虚实映射关系</strong>（虚拟内存和物理内存的映射索引表），而<strong>不会拷贝物理内存</strong>。这个拷贝会消耗大量cpu资源，并且<strong>拷贝完成前会阻塞主线程</strong>，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p></blockquote><ul><li><p><strong>重写时有哪些阻塞</strong>？</p><ul><li>fork</li><li>主线程bigkey写入，操作系统需要创建页面副本并拷贝原有数据。</li><li>主线程追加写入aof</li></ul></li><li><p><strong>为什么AOF不复用原AOF文件</strong>？</p><ul><li>父子同时写一个文件产生竞争，影响父进程性能</li><li>若重写失败会造成污染</li></ul></li></ul><h3 id="RDB和AOF混合方式"><a href="#RDB和AOF混合方式" class="headerlink" title="RDB和AOF混合方式"></a>RDB和AOF混合方式</h3><p>在Redis4.0提出，简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志<strong>记录这期间</strong>的所有命令操作。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222843.jpg"></p><ul><li>RDB不用过快执行，同时AOF也不会过大</li></ul><h3 id="持久化恢复"><a href="#持久化恢复" class="headerlink" title="持久化恢复"></a>持久化恢复</h3><p>重启redis即可恢复<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222858.png"><br>AOF优先级更高，因为其数据更完整。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第2章（对象机制）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><blockquote><p>前面介绍了Redis的基本数据类型，针对这些数据类型有着不同的底层实现。</p></blockquote><p>对象模型：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190013.png"></p><blockquote><p>Redis对象有不同的数据类型，而一个数据类型可能有多种实现方式（编码类型），根据value的情况灵活变化。<br>编码类型作为一种类型标识，告诉了Redis应该如何解析这个对象，不同编码类型也有不同的底层数据结构实现。</p></blockquote><p>Redis对象机制作用：<br><strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.<br><strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><h1 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190705.png"></p><ul><li>type标识了数据所属的基本类型</li><li>encoding标识了数据类型对于的编码</li><li>LRU记录了数据的最后访问时间（LFU还记录访问次数）</li><li>refcount记录了对象被引计数</li><li>ptr指向真实的底层数据结构</li></ul><div class="note note-primary">            <p>redisObject保存了Redis服务器需要维护的对象信息，包括数据结构类型和编码（用于多态解析），LRU（LFU）和refcount（淘汰机制），ptr指向底层数据结构。</p>          </div><h2 id="命令检查与多态"><a href="#命令检查与多态" class="headerlink" title="命令检查与多态"></a>命令检查与多态</h2><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103191229.png"></p><div class="note note-success">            <p>type判断命令是否正确，encoding判断如何执行命令</p>          </div><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>redis一般会把一些常见值放入共享对象中：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192218.png"></li></ul><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。<br>像整数集合和压缩列表这些将数据保存在数据结构内的则无法使用。</p></blockquote><blockquote><p>为什么不共享其他数据结构：<br>复杂度较高，消耗CPU，用其换取内存不划算。</p></blockquote><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h1 id="底层数据对象"><a href="#底层数据对象" class="headerlink" title="底层数据对象"></a>底层数据对象</h1><h2 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h2><p><strong>简单动态字符串（simple dynamic string,SDS</strong>）的存在是为了尽可能的节省存储可见，只为对象分配其需要的空间大小。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192512.png"></p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的<strong>头部</strong>, 分别如下:<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192821.png"><br>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的<code>\0</code>, 剩余的字节数。</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><div class="note note-primary">            <p>实际SDS的长度为 头部+alloc+尾部。<br>len为<code>buf[]</code>中的有效长度，即有效字符串长度。</p>          </div><h3 id="为何使用SDS"><a href="#为何使用SDS" class="headerlink" title="为何使用SDS"></a>为何使用SDS</h3><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li></ul><blockquote><p>在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p></blockquote><h2 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h2><p>ziplist是一个特殊编码的双向列表，其可以存储字符串或整数，操作的时间复杂度为O(1)，每次操作都需要重新分配ziplist的内存。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103194043.png"></p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p>一般</p><ul><li><code>prevlen</code>：前一个entry的大小</li><li><code>encoding</code>：表示当前entry类型和长度</li><li><code>entry-data</code>:存储entry标识的数据<br>特殊<br>类型为int时，<code>encoding</code>和<code>entry-data</code>合并在一起表示，没有<code>entry-data</code>。</li></ul><p><strong>prevlen</strong><br>前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度。<br>如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><p><strong>encoding编码</strong><br>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；<br>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><h3 id="为什么ZipList省内存"><a href="#为什么ZipList省内存" class="headerlink" title="为什么ZipList省内存"></a>为什么ZipList省内存</h3><p>根据数据类型灵活变化编码规则，使用encoding标识entry类型和大小，是。<br>因为是双端列表，为了解决遍历问题，使用prevlen字段方便倒序遍历。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不预留空间，每次写操作都需要重新分配内存。<br>节点扩容可能导致后续所有prevlen字段扩容。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>是一个以ziplist为节点的双端链表结构。</p><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例。</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下</li></ul><h3 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103200220.png"></p><ul><li><p><code>quicklist.fill</code>影响ziplist的长度，数值为负数时限制ziplist最大长度，为正数时限制ziplist的entry数量。</p></li><li><p><code>quicklist.compress</code>影响zl字段指向的对象的类型，0标识指向ziplist，1表示链表的头尾节点不压缩，2标识头尾各2各节点不压缩，其他为压缩后的quicklistLZF。</p></li><li><p><code>quicklistNode.encoding</code>，标识本链表节点是否压缩，1表示没压缩，2表示压缩了。</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压。如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><h2 id="字典-x2F-哈希表-Dict"><a href="#字典-x2F-哈希表-Dict" class="headerlink" title="字典&#x2F;哈希表 - Dict"></a>字典&#x2F;哈希表 - Dict</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103201159.png"></p><h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul><li>哈希算法：使用hash函数计算key的哈希值，使用sizemask与第一步得到的hash值，计算索引。</li><li>哈希冲突：链地址法（<strong>头插法</strong>）</li><li>扩容&#x2F;缩容：<ul><li>rehash，扩展时创建两倍大小的hash表，缩小时则创建缩小一倍的新哈希表</li><li>重新计算索引</li><li>迁移所有键值对，然后释放内存</li></ul></li><li>扩容条件：<ol><li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</li><li>ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</li></ol></li><li>缩容条件：负载引子小于0.1</li><li>渐进式rehash<ol><li>在字典中维护一个索引计数器变量idx，初始值为0</li><li>每次对字典进行CRUD时，除了执行指定语句，还会将idx上的所有键值对rehash到新的哈希表上，然后idx++。</li><li>最终某个时刻完成所有键值对的迁移，此时将idx标记为-1。</li><li>rehash期间的查找会在新旧两个哈希表上找，但是新增只会在新哈希表上新增。</li></ol></li></ul><div class="note note-primary">            <p><em>扩展：rehash与ConcurrentHashMap的扩容方式相比，有什么区别？</em></p><ol><li>rehash单线程扩容，ConcurrentHashMap多线程扩容，一般而言后者更快</li><li>对于读操作，两者响应速度差不多</li><li>对于写操作，rehash更快，因为ConcurrentHashMap中线程需要帮助完成扩容，扩容完成后才进行真正的写操作。</li><li>对于删除操作，同写操作。</li></ol>          </div><h2 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202006.png"></p><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><div class="note note-primary">            <p>可见intset就是一个排序的数组。</p>          </div><p>contents中每个元素的数据类型由encoding决定，当有数字的值超出范围时，集合需要升级，其会：</p><ul><li>扩展整数集合底层数组的可见大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上。（需要继续维持底层数组的有序性质不变）。</li><li>最后改变encoding的值，length+1。</li></ul><p>但intset不会降级，这是没必要的开销。</p><h2 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h2><p>跳表在redis中只用在zset数据类型中，其保证查找删除添加等操作在对数的期望时间内完成。</p><p>原理示例：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202637.png"></p><p>内存布局：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202658.png"></p><p><strong>zskiplist的核心设计要点</strong></p><ul><li><strong>头节点</strong>不持有任何数据, 且其<code>level[]</code>的长度为32。</li><li><strong>每个结点</strong><ul><li><code>ele</code>字段，持有数据，是sds类型</li><li><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li><code>level</code>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段<ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在<code>level[]</code>中的索引为X, 则其forward字段指向的结点, 其<code>level[]</code>字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1</li></ul></li></ul></li></ul><h3 id="为什么不用平衡树或者哈希表"><a href="#为什么不用平衡树或者哈希表" class="headerlink" title="为什么不用平衡树或者哈希表"></a>为什么不用平衡树或者哈希表</h3><p>hash无序，无法进行范围查找，平衡数的范围搜索也很复杂，子树的调整也很复杂。</p><h1 id="redis对象与编码-底层结构-对应关系"><a href="#redis对象与编码-底层结构-对应关系" class="headerlink" title="redis对象与编码(底层结构)对应关系"></a>redis对象与编码(底层结构)对应关系</h1><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203244.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串长度不能超过512M。</strong></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li><code>int 编码</code>：保存的是可以用 long 类型表示的整数值。</li><li><code>embstr 编码</code>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><code>raw 编码</code>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203355.png"><br>embstr少一次分配空间，但其为只读,修改时要重新分配一次raw空间。</p><p>ps:<strong>Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型</strong>。</p><ul><li><strong>编码的转换</strong></li></ul><blockquote><p>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。<br>对于embstr编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>按<strong>数值进行操作的数据</strong>，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>quicklist</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203823.png"></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 hashtable</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><ul><li>ziplist</li><li>dict<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204020.png"></li></ul><p>使用ziplist时，新的键值对作为entry插入list尾部。<br>使用hashtable编码时，使用dict。</p><p><strong>编码转换</strong><br>和上面列表对象使用 ziplist 编码一样，当<strong>同时满足下面两个条件</strong>时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节<br>不能满足这两个条件的时候使用 hashtable 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>hash类型下的value只能存储字符串</li><li>每个hash可以存储2^32-1个键值对</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="编码-3"><a href="#编码-3" class="headerlink" title="编码"></a>编码</h3><p>intset或hashtable</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204842.png"></p><p><strong>编码转换</strong><br>当集合同时满足以下两个条件时，使用intset编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512<br>不能满足这两个条件的就使用hashtable编码。第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="编码-4"><a href="#编码-4" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 skiplist(ziplist+dict)</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p>ziplist<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205150.png"></p><p>skiplist(ziplist+dict)<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205236.png"><br>字典可以快速查找成员，但无序，跳表可以快速执行范围查找，将两者结合共同实现有序集合。</p><p><strong>编码转换</strong><br>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。<br>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20231001212816.png"><br><code>list</code>，<code>hash</code>，<code>set</code>，<code>zset</code>都试图使用<strong>压缩的数据结构</strong>（压缩列表&#x2F;排序的压缩列表&#x2F;整数集合）来处理数量小于512&#x2F;512&#x2F;512&#x2F;128个且大小都小于64字节的元素集合，否则使用高级数据结构。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第1章（数据类型与结构）</title>
    <link href="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <url>/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis知识体系"><a href="#一、Redis知识体系" class="headerlink" title="一、Redis知识体系"></a>一、Redis知识体系</h1><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230191017.png"></p><h1 id="二、Redis概念与基础"><a href="#二、Redis概念与基础" class="headerlink" title="二、Redis概念与基础"></a>二、Redis概念与基础</h1><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。</li><li>数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>持久化：AOF&#x2F;RDB</li><li>发布订阅：Subscribe</li><li>分布式：RedisCluster</li><li>redis为每个服务提供有16个数据库，编号从0到15，默认为0号数据库</li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>热点数据的缓存</li><li>限时任务的运用</li><li>计数器</li><li>分布式锁</li><li>延时操作</li><li>排行榜</li><li>点赞</li></ul><h2 id="Redis与MemCache的对比"><a href="#Redis与MemCache的对比" class="headerlink" title="Redis与MemCache的对比"></a>Redis与MemCache的对比</h2><p>Redis 与 Memcached <strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p>Redis 与 Memcached <strong>区别</strong>：</p><ol><li>Redis 支持的<strong>数据类型</strong>更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li>Redis 支持数据的<strong>持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li>Redis 原生支持<strong>集群模式</strong>，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li><li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li></ol><h1 id="三、Redis基础数据类型"><a href="#三、Redis基础数据类型" class="headerlink" title="三、Redis基础数据类型"></a>三、Redis基础数据类型</h1><blockquote><p>Redis所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p></blockquote><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230200246.jpg"></p><div class="note note-primary">            <p><strong>String</strong>也可以是整数和浮点数，支持自增和自减操作。<br><strong>Zset</strong>说是set，实际上结构类似hash，其保存了<strong>字符串成员</strong>和<strong>浮点分数</strong>之间的映射关系。</p>          </div><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>GET,SET,INCR,DECR,INCRBY,DECRBY</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>缓存常用信息，计数器，session.</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis用双端链表实现List。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>LPUSH,LPOP,<strong>LRANGE</strong>(获取范围内元素),LINDEX(获取索引元素)</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>时间轴微博，消息队列（按照时间先后排序的场景）</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序集合，成员唯一。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p>SADD,<strong>SCARD</strong>(获取成员数),SMEMERS(返回所有成员),SISMEMBER(判断是否为成员)</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>文章标签，不需要时间排序的点赞、收藏等。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>field -&gt; value，适合存储对象</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><p>HSET,HGET,HGETALL,HDEL</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>缓存查询信息，适合存储结构体。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>成员唯一。通过了压缩列表和跳跃表两种数据结构实现。<br>压缩列表：提高了存储效率，特殊编码的双向链表。<br>跳跃表：快速查找，删除，添加（对数时间内）</p><div class="note note-primary">            <p>操作时按照跳跃表找到指定位置对数据进行修改，存储时以压缩列表形式存储。</p>          </div><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>ZADD,ZRANGE,ZREM</p><h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>排行榜</p><h1 id="四、Redis特殊类型结构"><a href="#四、Redis特殊类型结构" class="headerlink" title="四、Redis特殊类型结构"></a>四、Redis特殊类型结构</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构</p></blockquote><p>基数统计，可以理解为高性能的set，但精确度有限（0.81% 标准误差）。<br>基数指的是set中每一个不重复的元素，其可以解决海量数据统计的问题，其优势在于存储消耗的空间很小。</p><h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfadd key1 a b c  #创建第一组元素<br>pfcount key1 #统计元素个数<br>pfmerge key3 key1 key2 #合并key1,key2到key3<br></code></pre></td></tr></table></figure><h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><p>每日访问IP数，在线用户数等</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>位存储，使用位记录 0，1两个状态。</p><h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">setbit key 0 1  #设置第0位为1<br>getbit key 0 #获取第0位<br>bitcount key #求1的数量<br></code></pre></td></tr></table></figure><h3 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h3><p>记录每条的打卡情况</p><h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了!</p></blockquote><h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">geoadd china:city(相当于key) 118 32 beijing(相当于value对象)#即可以为一个区域添加多个点<br>geopos china:city beijing<br>geodist china:city beijing shenyang m #以M为单位求两地距离<br>georadius china:city 110 30 1000 km #求中国城市中，以110，30为中心，1000km为半径范围内所有城市。<br>geohash china:city beijing #较少使用,返回hash字符串<br></code></pre></td></tr></table></figure><h3 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h3><p>附近的人code</p><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>底层实现是Zset，其将经纬度转换为一个分数保存在其中。</p><h1 id="五、消息队列Steam"><a href="#五、消息队列Steam" class="headerlink" title="五、消息队列Steam"></a>五、消息队列Steam</h1><p>借鉴了Kafka，是一种消息队列的实现。</p><blockquote><p>Redis的消息队列实现很多：</p><ul><li>Pub&#x2F;Sub，缺点：丢失的消息无法持久化。</li><li>List，缺点：不支持多播，持久化。</li></ul></blockquote><p>消息队列设计<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230213704.png"></p><h2 id="Stream结构"><a href="#Stream结构" class="headerlink" title="Stream结构"></a>Stream结构</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230214054.png"></p><ul><li><code>Stream</code>：一种数据结构，每个Stream有一个唯一的名称，也就是key。</li><li><code>Comsumer Group</code>消费组：一个消费组有多个消费者，他们之间是<strong>竞争关系</strong></li><li><code>pending_ids</code>消费者状态变量：维护了消费者尚未确认的id。</li></ul><div class="note note-primary">            <p>对于每一条消息都要确保其被消费，或者确定这是一个投递不出去的坏消息（死信）。所以需要对<strong>每个消费者</strong>维护一个<strong>pending_ids</strong>，表示这个消息已经交给它处理，但它还没有完成对该消息的确认（ack）。</p><p>而对于<strong>每个消费组</strong>，则需要一个指针维护其最后一次读取到的消息id（<strong>Last_dilivered_id</strong>）。</p>          </div><p>另外，每个消息都有独一无二的ID，默认为时间戳，格式为1527846880572-5，当毫秒不够用时，使用<code>-</code>后面的数标注该消息是本毫秒的第几个消息。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>即不使用消费组的情况下进行消费。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xread count 2 streams key 0-0 #读取两条消息<br>xread block 0 count 1 streams key $ #阻塞读取队列最后的消息<br></code></pre></td></tr></table></figure><p>block 0表示永远阻塞，直到消息到，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil。</p><blockquote><p>独立消费不会自动维护last_read指针，需要用户自己记住最后消息ID，下次将其作为参数传递即可继续消费。</p></blockquote><h2 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230231440.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为”已处理”</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息<br>具体使用见<a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html">消费组命令使用</a></li></ul><p>xreadgroup也可以阻塞等待，读取后，消息进入消费者的pending_ids，当消费者回复xack时，将这个消息从其pending_ids消除。</p><div class="note note-primary">            <p>消费时，需要传入流名称、消费组名称、消费者名称3个参数。<br>ACK时，需要传入流名称、消费组名称、消息id。<br>可见回复时，不需要具体定位到消费者，因为redis本身就知道某个消息id属于消费组中的哪个消费者。</p>          </div><h2 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h2><p><code>Xinfo</code>命令可以查看stream的基本信息，如：</p><ul><li>XINFO STREAM keyName</li><li>XINFO GROUPS keyName</li><li>XINFO CONSUMERS keyName groupName</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>实时通讯、大数据分析、异地数据备份。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个<strong>64位整型</strong>（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>Redis生成的ID是单调递增有序的。若服务器时间错误，Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号）。</p><h3 id="消费者崩溃带来的会不会消息丢失问题"><a href="#消费者崩溃带来的会不会消息丢失问题" class="headerlink" title="消费者崩溃带来的会不会消息丢失问题?"></a>消费者崩溃带来的会不会消息丢失问题?</h3><p>Pending列表可以记录已读取但未ack的消息。<br>命令<code>XPENDIING</code>用来获消费组或消费内消费者的未处理完毕的消息。</p><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>其保证消费者恢复时，可重新从pending列表中取消息处理。</p><h3 id="消费者彻底宕机后如何转移给其它消费者处理？"><a href="#消费者彻底宕机后如何转移给其它消费者处理？" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理？"></a>消费者彻底宕机后如何转移给其它消费者处理？</h3><p>使用<code>XCLAIM</code>将目标消费者和消息ID转移到自己的pending列表中，同时需要提供<strong>IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p><h3 id="坏消息问题，Dead-Letter，死信问题"><a href="#坏消息问题，Dead-Letter，死信问题" class="headerlink" title="坏消息问题，Dead Letter，死信问题"></a>坏消息问题，Dead Letter，死信问题</h3><p>delivery counter，反复转给各个消费者时会累加，当到达临界值时将该消息视为死信，此时可以处理该消息，一般删除即可，XDEL。</p><h1 id="六、发布订阅详解"><a href="#六、发布订阅详解" class="headerlink" title="六、发布订阅详解"></a>六、发布订阅详解</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis有两种发布&#x2F;订阅模式：</p><ul><li>基于频道(Channel)的发布&#x2F;订阅</li><li>基于模式(pattern)的发布&#x2F;订阅</li></ul><h2 id="基于频道的发布和订阅"><a href="#基于频道的发布和订阅" class="headerlink" title="基于频道的发布和订阅"></a>基于频道的发布和订阅</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">publish channel:1 hi #发布消息<br><br>subscribe channel:1 #订阅频道，随后进入订阅状态<br></code></pre></td></tr></table></figure><p>处于订阅状态下客户端不能使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>和<code>punsubscribe</code>这四个属于”发布&#x2F;订阅”之外的命令，否则会报错。</p><h2 id="基于模式-pattern-的发布-x2F-订阅"><a href="#基于模式-pattern-的发布-x2F-订阅" class="headerlink" title="基于模式(pattern)的发布&#x2F;订阅"></a>基于模式(pattern)的发布&#x2F;订阅</h2><p>如果有某个&#x2F;某些模式和这个频道匹配的话，那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-6.svg"><br>通配符中<code>?</code>表示1个占位符，<code>*</code>表示任意个占位符(包括0)，<code>?*</code>表示1个以上占位符。</p><ul><li>psubscribe可以重复订阅一个频道，会收到多条消息。</li><li>subscribe和psubscribe是相互独立的，接受到消息时也会有区别。</li><li>使用punsubscribe只能退订通过psubscribe命令订阅的规则。</li></ul><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="基于频道"><a href="#基于频道" class="headerlink" title="基于频道"></a>基于频道</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-4.svg"></p><ul><li>订阅时，将客户端添加到对应channel的list中。</li><li>发布时，订阅到channel，发送给List中所有客户端。</li></ul><h3 id="基于模式"><a href="#基于模式" class="headerlink" title="基于模式"></a>基于模式</h3><ul><li>订阅时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-10.svg"></li><li>发布时，遍历pubsubPattern，逐一对比看是否要发送。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第6章（应用层）</title>
    <link href="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-968c1bcea54ea1f4.webp"><br>例子：<br><strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong>，该应用还涉及到域名到IP地址的转换，由属于<strong>应用层范畴的域名系统DNS</strong>完成。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4e9858624d4835ae.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c1c3868fb5e127b1.webp"></p><h1 id="二、两种组织方式"><a href="#二、两种组织方式" class="headerlink" title="二、两种组织方式"></a>二、两种组织方式</h1><h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-bbfb139bb8ffd796.webp"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-598b1158f5c33a11.webp"></p><div class="note note-primary">            <p>www,email,ftp为C&#x2F;S架构。</p>          </div><h1 id="三、动态主机配置协议DHCP"><a href="#三、动态主机配置协议DHCP" class="headerlink" title="三、动态主机配置协议DHCP"></a>三、动态主机配置协议DHCP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>DHCP</strong>使用了C&#x2F;S方式：</p><ul><li>主机在启动时向DHCP服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li><li>基于UDP工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><h4 id="发现报文"><a href="#发现报文" class="headerlink" title="发现报文"></a>发现报文</h4><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong>，其中包含<strong>事务ID</strong>，<strong>DHCP客户端的MAC地址</strong></p><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-6f9a9715f8b1c74a.webp"></p><blockquote><p>报文包括：</p><ul><li><strong>源IP地址</strong>：0.0.0.0，这是因为主机目前还未分配到IP地址。</li><li><strong>目的地址</strong>：广播地址255.255.255.255。</li><li><strong>MAC地址</strong>：主机MAC地址。</li></ul></blockquote><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送。</p><h4 id="提供报文"><a href="#提供报文" class="headerlink" title="提供报文"></a>提供报文</h4><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03ecd6d2838d4274.webp"></p><blockquote><p>报文包括</p><ul><li><strong>事务ID</strong>：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的。</li><li><strong>配置信息</strong>：IP地址、子网掩码、地址租期、默认网关、DNS服务器</li><li><strong>源IP地址</strong>：发送DHCP提供报文的DHCP服务器的IP</li><li><strong>目的地址</strong>：因为目的主机还没分配到IP，所以使用广播地址</li></ul></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-009b1e9a88976880.webp"></p><blockquote><p>报文包括<br><strong>事务ID</strong><br><strong>MAC地址</strong><br><strong>接受的IP地址</strong><br><strong>提供此租约的DHCP服务器端的IP地址</strong><br><strong>源IP地址</strong>：0.0.0.0<br><strong>目的地址</strong>：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们作为自己的DHCP服务器。</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文。</p><h4 id="确认报文"><a href="#确认报文" class="headerlink" title="确认报文"></a>确认报文</h4><p><strong>DHCP服务端将广播发送DHCP确认报文（DHCP ACK）</strong><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-35c9002bba766476.webp"></p><blockquote><p>报文包括：<br>源地址：DHCP服务器1的IP地址<br>目的地址：广播地址</p></blockquote><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong>，<strong>在使用前还会进行ARP检测</strong>。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-044fb99d76bd279c.webp"></p><h4 id="剩余流程"><a href="#剩余流程" class="headerlink" title="剩余流程"></a>剩余流程</h4><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a01eacfba40e9098.webp"></p><div class="note note-primary">            <p>由于确认客户端的IP地址前，其都没有IP地址，所以DHCP借用IP的过程中报文的目的IP都是广播，服务器的源IP地址都是自身IP地址，客户端IP地址为默认0.0.0.0。</p><p>客户端请求IP是一个4握手过程。前2个握手用于服务端和客户端明确对方的存在并给客户端一个Offer。后2个握手就是客户端确定这个Offer的过程。</p><p>第三个握手，虽然是广播，但其他的DHCP服务器是不会接受的，因为事物ID不符。</p><p>到达0.5倍租用期时，客户端会主动续租，若超过了租用期，则停止使用这个IP地址。</p>          </div><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-33c64efac75f0ad2.webp"></p><p>由于网络之间存在广播域，主机的广播消息可能无法送达DHCP服务器，可为路由器配置DHCP中继代理服务，路由器会将接受到的DHCP报文转发到DHCP服务器。</p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-37d8836f5ed85036.webp"></p><h1 id="四、域名系统DNS"><a href="#四、域名系统DNS" class="headerlink" title="四、域名系统DNS"></a>四、域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8dc45fb61122f775.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-31a3076fe8055379.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4655232a57435f63.webp"></p><blockquote><p>名称相同的域名等级未必相同。</p></blockquote><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c2350ce866abf74e.webp"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-aae45d426ec7fa49.webp"></p><div class="note note-primary">            <p>递归查询的过程是链式调用，最后将域名对应的IP地址返回给主机。<br>迭代查询的过程是由本地域名服务器作为请求主体，迭代查询各级服务器IP。</p>          </div><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-d2652511b6f2280d.webp"></p><div class="note note-primary">            <p>本地域名服务器使用高速缓存减少DNS查询次数，但需要保证正确性，所以对于每一项缓存都有倒计时，超时的记录会被删除。<br>同时，主机也需要做缓存（多级缓存），启动时便向本地域名服务器获取域名和IP的数据库信息，必要时再询问服务器。</p>          </div><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-93d3fbaa54195112.webp"></p><h1 id="五、文件传送协议FTP"><a href="#五、文件传送协议FTP" class="headerlink" title="五、文件传送协议FTP"></a>五、文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-df91fe396712c633.webp"></p><h2 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h2><p>FTP采用了C&#x2F;S方式，监听熟知端口（21）。</p><h3 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-885981a43745ae55.webp"></p><div class="note note-primary">            <p>主动、被动指的是数据通道的建立发起者是否是服务器，主动模式服务器会使用固定的端口号连接客户端的临时端口号，被动模式服务器会开启某个临时端口号等待客户端连接。<br>注意，两种方式最后都会建立两个连接通道，控制连接在整个会话期间保持打开状态，数据连接传输完毕后就关闭。</p>          </div><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/Pasted-image-20221230015319.png"></p><h1 id="六、电子邮件"><a href="#六、电子邮件" class="headerlink" title="六、电子邮件"></a>六、电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-905f080fde0331a5.webp"></p><blockquote><p>注意：SMTP是发送协议，POP3&#x2F;IMAP是读取协议。</p></blockquote><h2 id="邮件发送和接受过程"><a href="#邮件发送和接受过程" class="headerlink" title="邮件发送和接受过程"></a>邮件发送和接受过程</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a55537e03d980133.webp"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）"></a>简单邮件传送协议SMTP（<em>Simple Mail Transfer Protocol</em>）</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03f4877d2621c261.webp"></p><h3 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-fb16b5ace5466b25.webp"></p><div class="note note-primary">            <p><strong>MIME</strong>是一层非ASCII和ASCII码之间的扩展转换器，其可以协助非ASCII码邮件以SMTP的形式发送。</p>          </div><h3 id="邮件接受"><a href="#邮件接受" class="headerlink" title="邮件接受"></a>邮件接受</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c825d1ad122bd41c.webp"></p><blockquote><p><strong>POP3</strong>是正式标准，客户只读。<br><strong>IMAP4</strong>是建议标准，客户可以操作服务器中的邮件，需要联机。</p></blockquote><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-46b15b10a17604fa.webp"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-b400e3f6c0a87238.webp"></p><div class="note note-primary">            <p>POP3使用110端口，IMAP4使用143端口</p>          </div><h1 id="七、万维网WWW"><a href="#七、万维网WWW" class="headerlink" title="七、万维网WWW"></a>七、万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>基本概念</p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络，而是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。<strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8646898df7461ca3.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-05ae15f55de2ba0a.webp"></p><h2 id="HTTP（Hyper-Transfer-Protocol）"><a href="#HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="HTTP（Hyper Transfer Protocol）"></a>HTTP（<em>Hyper Transfer Protocol</em>）</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP是一个应用层协议，它使用 <strong>TCP 连接</strong>进行可靠的传送。</li><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-614d1960b2b805d9.webp"></li></ul><div class="note note-primary">            <p>可以注意到第三次握手的时候就发出了HTTP请求报文。</p>          </div><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-22dfb8a34acf459c.webp"><br>响应报文<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-0409ca153701fbb4.webp"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-969dc15b42399e98.webp"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-abf0fcf785757c26.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-e7f4b696946ffafa.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-14ec3f45c4af32f9.webp"></p><div class="note note-primary">            <p>为了保证缓存的正确性，设置有过期时间，若没有过期，则直接返回，若过期了，则询问服务器文档内容是否有变化：</p><ul><li>若没有则直接返回一个普通响应，缓存服务器接受后直接刷新倒计时。</li><li>若有则返回新的文档内容，缓存服务器接收并更新内容。</li></ul>          </div><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-dab94fae0e969502.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/3b490c10d129">计算机网络第6章（应用层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第5章（运输层）</title>
    <link href="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程之间通讯<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-86df51cb4523e3bf.webp"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><div class="note note-primary">            <p>NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议。</p>          </div><p>之前介绍的物理层、数据链路层、网络层解决了主机到主机的通讯。但通讯的真正实体是位于通讯两端主机的进程，如何为这两个进程提供通讯服务是运输层的任务，运输层协议也被称为端到端协议。</p><h2 id="端口号与复用"><a href="#端口号与复用" class="headerlink" title="端口号与复用"></a>端口号与复用</h2><p>端口号的使用<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-de597eda77aa6acd.webp"></p><h3 id="发送方与接受方的复用"><a href="#发送方与接受方的复用" class="headerlink" title="发送方与接受方的复用"></a>发送方与接受方的复用</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2a4ec3f5d5c11433.webp"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong><br><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p></blockquote><h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2117fa99a7f2a89c.webp"></p><h1 id="二、运输层传输流程（DNS）"><a href="#二、运输层传输流程（DNS）" class="headerlink" title="二、运输层传输流程（DNS）"></a>二、运输层传输流程（DNS）</h1><ul><li>DNS客户端（端口为短暂端口号）发送一个<strong>DNS请求报文</strong>（UDP）到DNS服务器（端口号为53）。</li><li>DNS服务器将接受到的信息上传给DNS服务器端进程（端口号为53），随后给用户回复<strong>DNS响应报文</strong>（UDP），目的端口为客户端的短暂端口号。</li><li>DNS客户端将接受到的信息上传给DNS客户端进程（端口号为短暂端口号），随后解析DNS响应报文，即可直到Web域名对应的IP地址。</li><li>向Web域名对应的IP发送http请求。</li></ul><h1 id="三、UDP与TCP对比"><a href="#三、UDP与TCP对比" class="headerlink" title="三、UDP与TCP对比"></a>三、UDP与TCP对比</h1><h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h2><ul><li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>；当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。；UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li><li>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接；UDP的通信是无连接的，不需要套接字（Socket）。</li></ul><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-58c94f043969af9a.webp"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>结构<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-624005a24bc5bfcd.webp"><br>实现</p><ul><li>UDP可以<strong>广播、多播和单播</strong></li><li>UDP对应用进程交下来的报文<strong>既不合并也不拆分</strong>，而是保留这些报文的边界</li><li>UDP向上层提供<strong>无连接不可靠传输服务</strong></li></ul><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h2><p>结构<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-db48b70af7fb7884.webp"><br>实现</p><ul><li>TCP只支持单播，端对端通讯</li><li>需要先通过3次握手建立连接</li><li>TCP是面向字节流的，即其<strong>可能会拆分上层交付的报文</strong>。</li><li>TCP向上层提供<strong>面向连接的可靠传输服务</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-b0c1d4146735458a.webp"></p><h1 id="四、TCP流量控制"><a href="#四、TCP流量控制" class="headerlink" title="四、TCP流量控制"></a>四、TCP流量控制</h1><p>目的：发送的速率尽可能快，但需要接受方来得及接受。<br>实现：滑动窗口。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=60">具体流程视频</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>累计确认+选择重传（只重传超时的，即每个窗口独立持有一个计时器）</p><ol><li>发送端和接受端分别具有发送窗口和接受窗口。发送端会将发送窗口内的字节数据依次发出。</li><li>接受方通过累计确认提示发送端应该<strong>如何调整发送窗口的大小</strong>（流量控制）以及<strong>已经接受到了n字节之前的数据</strong>。</li><li>发送方接受到累计确认后<strong>调整发送窗口大小</strong>并<strong>移动发送窗口</strong>。</li><li>移动发送窗口后：<ul><li>将刚进入窗口的窗口信息发送出去</li><li>同时等待看是否有窗口触发超时重传，若有则重传旧数据。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f73e94f75e94ea4c.webp"></li></ul></li><li>接受端将发送窗口调整为了0，说明暂时不接受数据，其恢复后给发送方的提示是可能丢失的。因此，<strong>当发送窗口为0（接受到0窗口通知）时，</strong>发送方<strong>持有持续计时器，超时时会发送</strong>零窗口探测报文**，确认接受端处理能力情况。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-5bd53b8a5a5ac400.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ea9dc3589e6c6bd1.webp"></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d8221e9dda7919f9.webp"></p><h1 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-9d4b410b2a44c125.webp"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><div class="note note-primary">            <p>理解拥塞原因：<br>1.传输时，链路容量不足；2.接受时，容量太小；3.处理时，速率太慢；4.负反馈。</p>          </div><p><strong>拥塞控制的一般原理</strong></p><ol><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ol><p><strong>开环控制和闭环控制</strong><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2740d71c5e1d6aac.webp"></p><p><strong>监测网络的拥塞</strong><br>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-67852fc13fc0e263.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c7682fe29ebcb6fd.webp"></p><blockquote><p>发送窗口大小 &#x3D; min(接受方窗口大小，拥塞窗口大小)</p></blockquote><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul><li><p>目的：用来确定网络的负载能力或拥塞程度。</p></li><li><p>算法的思路：由小到大逐渐增大拥塞窗口数值。</p></li><li><p>两个变量：</p><ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值有2 种设置方法。窗口值逐渐增大。第一种是1 至 2 个最大报文段 （旧标准）；第二种是2 至 4 个最大报文段 （RFC 5681）</li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li><li><p>实现：</p><ul><li>起初拥塞窗口按指数增加，当达到慢开始门限后，为了避免出现拥塞，每经过一个传输伦次，cwnd++</li><li>如果出现超时重传，则重新回到慢开始<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f5db7ea25d8aca73.webp"></li></ul></li></ul><div class="note note-primary">            <p>慢开始是为了从小到大且尽快的达到门限，门限后则缓慢的扩大拥塞窗口来试探网络情况，两者一起使用以实现动态调整拥塞窗口。</p>          </div><div class="note note-warning">            <p>注意：这里是拥塞窗口的变化，而不是发送窗口的变化，发送窗口的大小还受限于接受端的接受窗口。</p>          </div><h3 id="快重传（fast-retrasmit）与快恢复（fast-recovery）"><a href="#快重传（fast-retrasmit）与快恢复（fast-recovery）" class="headerlink" title="快重传（fast retrasmit）与快恢复（fast recovery）"></a>快重传（<em>fast retrasmit</em>）与快恢复（<em>fast recovery</em>）</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-a57c7cc819aa4bae.webp"></p><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ab5a63efbd586eb8.webp"></p><div class="note note-primary">            <p>一般接受方对接受到的报文段的确定都是捎带的，和窗口控制报文一起发送给发送端，导致重传开启较慢。<br><strong>快重传</strong>：需要接受端尽快的回复接受到的报文信息，然后发送端实现快重出传（接受到连续3个重复的确认报文）</p><p>发送端发生重传时，直接进入慢开始，这对于仅丢失个别报文的传输的效率较大，而快重传刚好可以确定这类情况。<br><strong>快恢复</strong>：当发送快重传时不进入慢开始，而是调节ssthresh值和cwnd值为一半后直接开始执行拥塞避免算法。</p><p>快恢复要和快重传结合使用，快恢复的具体调整依赖于发送端具体的实现。</p>          </div><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-8f61b8eddb5b2624.webp"></p><h1 id="六、TCP超时重传时间的选择"><a href="#六、TCP超时重传时间的选择" class="headerlink" title="六、TCP超时重传时间的选择"></a>六、TCP超时重传时间的选择</h1><p>不必要的重传会导致网络负荷的增大，但重传推迟的太久也会导致传输效率的降低。因此需要合理的设置超时重传时间<em>RTO</em>，其应该略大于往返时间<em>RTT</em>，具体计算：</p><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-20d1cf6bb211fe7e.webp"></p><h2 id="RTO"><a href="#RTO" class="headerlink" title="RTO"></a>RTO</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-39ab62874e65b623.webp"></p><div class="note note-primary">            <p>RTT计算：越近的RTT样本权重越大。<br>RTO计算：在RTT的基础上加上了RTT的偏差。(相当于加上了RTTs与新样本的差异，β只是一个权重参数，RTT（D1） &#x3D; RTT（1）&#x2F;2只是数据的初始化）。</p>          </div><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-dbc63525eab966e1.webp"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c94fa8a3ad6b277f.webp"></p><h1 id="七、TCP可靠传输的实现"><a href="#七、TCP可靠传输的实现" class="headerlink" title="七、TCP可靠传输的实现"></a>七、TCP可靠传输的实现</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-6d10ea76a1ea032b.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-92d975bc880db892.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-35bff0a8cc5b0d71.webp"></p><div class="note note-primary">            <p>发送方接收到确认消息后，需要1.前移2.调整窗口大小。<br>调整窗口大小时，原则上窗口的前沿是不推荐后移的，所以最好是通过 后沿前移+前沿不动 来实现窗口缩小。</p>          </div><div class="note note-primary">            <p>接收方对数据的确认有累计确认和捎带确认：</p><ul><li>累计确认要求接收方不要过迟的发送确认。</li><li>捎带确认使用较少。</li></ul>          </div><h1 id="八、TCP的运输连接管理"><a href="#八、TCP的运输连接管理" class="headerlink" title="八、TCP的运输连接管理"></a>八、TCP的运输连接管理</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e7d2329746de8e6a.webp"></p><h2 id="TCP连接建立（握手）"><a href="#TCP连接建立（握手）" class="headerlink" title="TCP连接建立（握手）"></a>TCP连接建立（握手）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-84c2b6dbb20379bd.webp"></p><div class="note note-primary">            <p><strong>双报文握手</strong>保证双方得知对方的存在，随后可以直接发送数据。<br><strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误，导致服务器资源浪费。</p>          </div><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-0a5773a600817c41.webp" alt="两报文握手"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e69d0e450b080e1f.webp" alt="服务器打开传输控制块"></li></ul><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。<br>之后，就准备接受TCP客户端进程的连接请求。<br>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求。<br>而TCP客户端在主动打开前也是要先创建传输控制块。</p></blockquote><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-3205fd7d7d75b62e.webp"></p><div class="note note-primary">            <p><strong>SYN</strong>，<strong>ACK</strong>是TCP报文头中的一个bit，其标识了当前TCP报文的属性：<br>SYN（同步标志位）表示请求同步，ACK（确认标识位）表示是对某报文的回复。<br><strong>seq</strong>，<strong>ack</strong>是TCP报文头中的两个字段，都占4个字节，其标识了端消息的id和确认收到的消息id+1。</p><p>TCP规定SYN&#x3D;1的报文段即使不携带数据，也要消耗掉一个序号。<br>普通的确认报文可以不消耗序号。</p>          </div><h2 id="TCP连接释放（挥手）"><a href="#TCP连接释放（挥手）" class="headerlink" title="TCP连接释放（挥手）"></a>TCP连接释放（挥手）</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-1c5e0c6357d039ed.webp"></p><ul><li>前两次握手是确认服务器接受到了释放连接的请求，此后服务器对剩余数据进行传输，客户端进入终止等待2状态。</li><li>后两次握手是确认客户端接受到了释放连接的命令，此后服务器关闭，客户端则继续等待2MSL，这是为了防止第四次握手丢失导致服务器资源浪费。若直接关闭：<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ef85470fe120f146.webp"></li><li>若服务器没有收到第四次握手，则会重传第三次握手，以确保收到第四次握手。</li></ul><div class="note note-warning">            <p>第二次握手和第三次握手的ack序号相同，说明这个消息是对同一个消息（第一次握手）的回应，分别表示服务器收到释放连接请求和服务器运行释放连接请求。</p>          </div><div class="note note-warning">            <p>可见握手和挥手，都需要客户端保证对服务器连接的最终确认以防止服务器的资源浪费。<br>在握手中体现在服务器之后接收到第三次握手确认在进入连接状态。<br>在挥手中体现在客户端会保持等待，服务器主动重传第三次握手以收到第四次握手。</p>          </div><div class="note note-primary">            <p><strong>FIN</strong>是TCP报文头中的一个bit，表示请求释放连接。在挥手中其会出现两次，一次是客户端主动请求释放连接，一次是服务器回复可以释放连接了。</p><p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>          </div><h2 id="TCP保活计时器"><a href="#TCP保活计时器" class="headerlink" title="TCP保活计时器"></a>TCP保活计时器</h2><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障，TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此，应当有措施使TCP服务器进程不要再白白等待下去<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2dc97e06fe1d82ed.webp"></p><h1 id="九、TCP报文段的首部格式"><a href="#九、TCP报文段的首部格式" class="headerlink" title="九、TCP报文段的首部格式"></a>九、TCP报文段的首部格式</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-df9263a14e1da2c1.webp"></p><h2 id="固定首部"><a href="#固定首部" class="headerlink" title="固定首部"></a>固定首部</h2><p>源端口和目的端口<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-27e4bd51d5db2f8e.webp"><br>序号、确认号和确认标志位<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-fd0e64d8be3f598b.webp"><br>数据偏移、保留、窗口和校验和<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d3d4c61af68fdb6d.webp"><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f09bdaba863c4ca3.webp"></p><h2 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d1a8d3ca5ac7f39d.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/ff5c1089a985">计算机网络第5章（运输层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第4章（网际层）</title>
    <link href="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li><li>为了实现这个任务，有以下问题：<ul><li>网络层提供可靠传输还是不可靠传输</li><li>网络层怎么寻址(IP地址做导航)</li><li>网络层路由选择(路由器根据路由表转发，为了记录路由需要人工配置或实现各种路由选择协议)</li></ul></li></ul><blockquote><p>网络层（网际层）,除了<strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><blockquote><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，因此在TCP&#x2F;IP协议中网络层常称为网际层。</p></blockquote><div class="note note-primary">            <ul><li>数据链路层能通过MAC地址与交换机实现数据的定向传输，但是对于庞大的因特网，这显然是不合理的，相比起MAC地址的无序序列，我们需要一个具有明显层级关系的地址（如湖北省武汉市洪山区）方便快速定位，统一管理，因此有了IP地址。</li><li>网络层需要实现数据在局域网和局域网之间的传递（不同于之前的局域网通过交换机互联，这样会扩大广播域，VLAN虽然能实现类似的功能，但依赖于用户设置，无法达到全网统一）。</li></ul>          </div><h1 id="二、网络层提供的服务"><a href="#二、网络层提供的服务" class="headerlink" title="二、网络层提供的服务"></a>二、网络层提供的服务</h1><p>网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”），实质就是<strong>在计算机通信中，可靠交付应当由网络还是端系统来负责</strong>？</p><ul><li>第一种观点是<strong>网络提供虚电路连接</strong>（一种使用<strong>面向连接</strong>的通信方式，通信之前先建立<strong>虚电路</strong>，保证所有网络资源，分组即可按顺序无差错的到达），由网络本身负责可靠交付。</li><li>另一种观点是<strong>网络只提供数据报服务</strong>，向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong>。</li></ul><blockquote><p>显然后者是我们现在使用的，其运行灵活，造价低，适应性强。</p><p><strong>区别</strong><br>终点地址：<br>1.仅在连接建立阶段使用，每个分组使用短的虚电路号<br>2.每个分组都有终点的完整地址</p><p>当结点出故障时：<br>1.所有通过出故障的结点的虚电路均不能工作<br>2.出故障的结点可能会丢失分组，一些路由可能会发生变化</p><p>端到端的差错处理和流量控制：<br>1.可以由网络负责，也可以由用户主机负责<br>2.由用户主机负责</p></blockquote><div class="note note-primary">            <p>当前网络层的服务实现是：<strong>尽最大努力交付</strong>。</p>          </div><h1 id="三、IPv4"><a href="#三、IPv4" class="headerlink" title="三、IPv4"></a>三、IPv4</h1><p><strong>IPv4地址</strong>是因特网（<em>Internet</em>）上每一个主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32bit（4个字节）的标识符。</p><div class="note note-warning">            <p>只有<strong>公网IP</strong>是全世界独一无二的，<strong>私网IP</strong>是在不同局域网中可以重复使用的：<br>RFC1918定义了私有IP的地址范围：<br>A:10.0.0.0 ~ 10.255.255.255即10.0.0.0&#x2F;8<br>B:172.16.0.0 ~ 172.31.255.255即172.16.0.0&#x2F;12<br>C:192.168.0.0 ~ 192.168.255.255 即192.168.0.0&#x2F;16</p>          </div><div class="note note-success">            <p><strong>私有IP是无法随意定义的</strong>，只有以上范围内的IP会被路由器视为内网IP，以这些IP为源IP的数据包只会在局域网内传递，不会在因特网上传递。</p><p>私有IP设备<strong>发送</strong>与<strong>接受</strong>外网数据包：<br>首先内网中的客户端将数据包传送给路由器，路由器解析数据包后发现，这个数据包是来自与私网、发送给外网的。例如某个数据包的源IP:192.168.1.2，当路由器检测到这个数据包的目标IP是外网IP的时候，路由器中会生成一个唯一端口号对应192.168.1.2，再生成一个随机端口号对应这个唯一端口号。然后路由器会将数据包的源IP改成公网IP，发送到互联网上。接收数据时，数据包会被发送到路由器的随机端口号上，这时和原来生成的映射表进行匹配，再把数据包传送到内网客户端，其实就是一个端口映射表。<br><a href="https://blog.csdn.net/weixin_39661353/article/details/110806482">路由器修改报文端口号</a></p>          </div><p>IPv4的编址方法经历了3个阶段：<br><strong>分类编址 -&gt; 划分子网 -&gt; 无分类编址</strong></p><h2 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h2><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-617a75508f564e07.webp"><br>其中有2个网络号无法分配，即A类地址：</p><ul><li><strong>最小网络号为0，保留不做指派</strong></li><li><strong>最大网络号为127，是本地回环测试地址，保留不做指派</strong></li></ul><p>有2类主机号无法分配：</p><ul><li>全0的主机号，其表示该网络的标识地址</li><li>全1的主机号，其表示该网络的广播地址</li></ul><div class="note note-primary">            <p>网络号，主机号都为0，即<code>0.0.0.0</code>，表示本网络上的本主机（见DHCP协议）</p>          </div><blockquote><ul><li><strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</li><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li><strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong></li></ul></blockquote><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>两级的IP地址会导致IP地址空间的利用率很低。<br>子网即从主机号借一部分作为子网号，从而将一个网络号分为多个子网。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5006c8be601f1a11.webp"><br>划分子网的工具即<strong>子网掩码</strong>。<br>其将<strong>两级的IP地址</strong>变成了<strong>三级的IP地址</strong>。</p><p><strong>默认子网掩码</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5e9d1b71bd598e62.webp"></p><p>IPv4地址与子网掩码相与即得到所在子网的网络地址。</p><blockquote><p>对于在因特网上传输的数据报，仍然是根据<strong>目的网络号</strong>net-id寻找下一跳路由器。到了该网络号的路由器时，路由器再根据<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</p></blockquote><div class="note note-primary">            <p><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。<br>这里所谈论的<strong>划分子网</strong>针对的仍然是因特网上的IP地址，其并没有造成IP地址重复（<code>相同的ip/不同的子网掩码</code>指的仍是同一个主机），只是单位内部对于可分配的主机号进行的一种再划分，即：</p><ul><li>子网掩码对于外网路由器没有作用。</li><li>内网路由器根据接受到的IP匹配对于的子网，能实现对该子网更精准的路由。<br>（最长前缀匹配）</li></ul>          </div><blockquote><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个记录，除了要记载目的网络地址外，还必须同时记载该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><div class="note note-primary">            <p>以上路由器行为是为了保证在传递IP数据报时，能够选择最符合的端口转发数据</p>          </div><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><strong>无分类域间路由选择 CIDR</strong> (<em>Classless Inter-Domain Routing</em>)。</p><ul><li>CIDR消除了A、B、C类地址和划分子网的概念。</li><li>CIDR能更有效的分配IPv4的地址空间。</li></ul><p><strong>特点</strong></p><ul><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li><li>IP 地址的形式为：<code>a.b.c.d/x</code>，其中地址的 <code>x</code> 最高比特构成了 IP 地址的<strong>网络部分（即网络前缀）</strong>，所以 <strong>CIDR 中 IP 地址由前缀和主机号构成</strong>，<code>x</code> 为前缀长度，<code>/x</code> 的记法也称为<strong>子网掩码</strong>。</li></ul><div class="note note-primary">            <p><strong>CIDR</strong>只是在网络实现层面消除了这些概念，并不代表A、B、C类地址和划分子网的协议行为不存在了。具体而言，总服务商分配到的公网IP地址基本仍为A、B、C类地址（如130.67.0.0&#x2F;16），不过服务商可以把这些地址再划分下去给子服务商(如130.67.0.0&#x2F;17和130.67.128.0&#x2F;17)使用，我们也不再把这样的关系称为总网、子网关系。</p><p>问题：130.67.0.0&#x2F;16 和130.67.0.0&#x2F;17还是同一个目标IP地址吗？<br>答：这个问题本身就是错误的。</p><ol><li><strong>IP地址仍然为一个全网唯一的IP地址</strong>，并没有后面的网络前缀的区分。</li><li>对于一个目标IP地址，<strong>不会也不可能在数据传递时携带网络前缀</strong>。</li><li>在数据的传输中，<strong>网络前缀只保存在路由器表中</strong>，用于记录与路由器相连接的网络的所在的网络号。</li></ol><p>问题：如果两个服务商，一个分到了<code>130.67.0.0/16</code>的公网IP，一个分到了<code>130.67.128.0/17</code>的公网IP，此时服务商1内部划分出子网<code>130.67.128.0/17</code>，其是否会与服务商2的IP在公网上重复？<br>答：不会。如上面所说，IP地址在分配时仍有等级之分，服务商一般只会分到<code>/8</code>，<code>/16</code>，<code>/24</code>这样的网络前缀，像<code>/17</code>这样的IP和网络前缀，本身就是由服务商1分发出来的，不可能由服务商2获得。</p>          </div><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p><strong>超网（路由聚合）技术是为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。</strong></p><p>即路由器发现其某个端口与多个具有相同前缀的网络对应，会将这些记录合并。</p><blockquote><p>举个例子，如果路由器1与路由器2连接，路由器2的各个端口连接了不同的网络（本质上是多个子网）。<br>经过路由器交换学习，路由器1会得知路由器2所在网络号和网络前缀，而路由器2的不同接口在不同的网络号中，因此路由器1学习到了路由器2的多个网络。（如<code>67.67.0.0/18</code>，<code>67.67.64/18</code>, <code>67.67.128.0/18</code>,<code>67.67.192.0/18</code>)<br>此时，路由器1发现虽然有多个网络，但他们都对应着同一个端口，并且具有相同前缀（<code>67.67.0.0/16</code>）。此时路由器1会将这些记录合并，这种行为叫做路由聚合，也叫构造超网。</p></blockquote><h3 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h3><p>最长匹配 是指存在多条目的网段相同的路由时，匹配掩码最长的那一条。因为掩码越长，表示的网段就越小，匹配也就越精确。</p><div class="note note-primary">            <p>条件：</p><ul><li>路由器1：外部路由器。</li><li>路由器2：连接多个网段（子网）路由器。</li><li>路由器3：连接路由器2的一个子网路由器。</li><li>网段3：路由器3所在的网络。</li><li>3个路由器两两相连。<br>对于划分子网的IPv4地址，同一网络号的不同子网的记录只保存在该网络的中转的路由器2中。对于路由器1，其只需要知道路由器2的总网络号即可，其子网的划分对路由器1是<strong>屏蔽的</strong>。</li></ul><p>但CIDR不再区分子网，路由器1会学习与之相连接的路由器2的所有网络号（IP和网络前缀）。这导致路由器2所在的子网对路由器1也是<strong>可见的</strong>，因此需要将这些网络号在本路由器的路由表中聚合起来，避免路由表内存浪费。</p><p>至于最长匹配原则，则可以当某个数据包要从路由器1要发往子网3。此时路由器1会优先匹配到最长的网段3，并将数据转发到路由器3。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/routeUnion.png"></p><h2 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h2><ul><li>定长的子网掩码FLSM（<em>Fixed Length Subnet Mask</em>）</li><li>变长的子网掩码VLSM（<em>Variable Length Subnet Mask</em>）</li></ul><blockquote><p>前者就是分类IP，后者就是无分类IP<br>定长的子网掩码只能划分出2^n个子网，而变长的子网掩码可以按需分配，减少对IP地址的浪费。</p></blockquote><h1 id="四、IP数据包的发送和转发过程"><a href="#四、IP数据包的发送和转发过程" class="headerlink" title="四、IP数据包的发送和转发过程"></a>四、IP数据包的发送和转发过程</h1><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>,由默认网关帮忙转发</li><li>为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong>。（具体地，默认网关指的是与本机网络直接相连的路由器<strong>接口</strong>，即下图中的0。通俗的讲，默认网关就是本网络与外网的默认接口）</li></ul></blockquote><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0351946f5505b37a.webp"></p><div class="note note-primary">            <p>前提：</p><ul><li>本机IP ＆ 本机掩码 &#x3D; 本机网络</li><li>目的IP ＆ 目的掩码 &#x3D; 目的网络</li></ul><p>正向来看：<br>如果：目的网络 &#x3D;&#x3D; 本机网络（即目的掩码 &#x3D; 本机掩码）<br>那么：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络（目的网络）</p><p>反向来看：<br>条件：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络<br>问题：目的网络是否为本机网络呢？<br>答案：<strong>是</strong>。考虑这个问题的时候主要在想以下情形：<br>”如果目的网络（<code>190.68.16.128/25</code>）是本机网络（<code>190.68.16.0/24</code>）的子网，那么上面条件是成立的，但该子网和该网络并不能划等号。“<br>但实际上这个想法本质就是错误的，在<strong>CIDR和变长的子网掩码</strong>中：</p><ol><li>IP网络之间的关系已经没有了父子关系，</li><li>对于变长子网掩码，不同的子网之间的关系依然是并列的。也就是说，如果本机IP的网络会被划分成（<code>190.68.16.0/24</code>），就说明已经有一个网段包含了<code>190.68.16.xxx</code>的所有主机，<code>190.68.16.128/25</code>网络根本就不可能存在，即若有某主机IP为<code>190.68.16.129</code>，其子网掩码也一定是<code>/24</code>。</li></ol><p>以上证明了可以根据本机掩码和目的IP判断目的网络是否为本机网络，但如果不是本机网络，则不能直接判断目的网络的具体掩码长度，不过对于本机而言，只需要操心一个IP是由自己直接交付（本机网络）还是交给路由器（外网网络）处理即可。</p>          </div><h2 id="路由器行为"><a href="#路由器行为" class="headerlink" title="路由器行为"></a>路由器行为</h2><ol><li>检查IP数据报首部是否出错<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ol><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>静态路由配置指用户或网络管理员使用路由器的相关命令给路由<strong>人工配置路由表</strong>。</p><p><strong>默认路由</strong><br>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是<strong>优先级最低</strong>的。一般为0.0.0.0&#x2F;0(可以匹配所有地址)</p><p><strong>特定主机路由</strong><br>给路由器添加的针对某个主机的特定主机路由条目，可以指定其下一条目的。一般用于网络管理人员对网络的管理和测试。</p><div class="note note-primary">            <p>当多条路由可选时，使用最长匹配原则。</p>          </div><p><strong>静态路由配置</strong>其可能出现以下导致产生<strong>路由环路</strong>的错误。</p><ul><li><strong>配置错误</strong>（手动配置错误）</li><li><strong>聚合了不存在的网络</strong>（解决办法：黑洞路由）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-caeddc52bde20f9c.webp"></li><li><strong>网络故障</strong>（解决方法：为故障网路添加黑洞路由，故障恢复后使该黑洞路由失效）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d8107f8fc71dd1f4.webp"></li></ul><h2 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>动态路由选择</strong>相比<strong>静态路由选择</strong>能更好适应网络状态的变化，且适用于大规模网络。其路由器通过路由选择协议自动获取路由信息。</p><blockquote><p><strong>因特网采用分层次的路由选择协议</strong></p></blockquote><p><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器。自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-9e37d1229ec7836e.webp"></p><p><strong>路由选择协议</strong>：域间路由选择使用外部网关协议<strong>EGP</strong>这个类别的路由选择协议，域内路由选择使用内部网关协议<strong>IGP</strong>这个类别的路由选择协议。<strong>网关协议</strong>的名称可称为<strong>路由协议</strong>。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8729bdd2bd367edf.webp"></p><div class="note note-primary">            <p><strong>路由选择协议</strong>的本质是路由器之间交换信息、判断某网络是否可达并进行路径选择的规则。由于路由器之间交换信息需要进行广播行为，由于路由表容量有限和避免广播的泛滥，需要使用<strong>自治系统</strong>来隔离网络中的路由器，并保证<strong>同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</strong></p>          </div><h3 id="常见的路由选择协议"><a href="#常见的路由选择协议" class="headerlink" title="常见的路由选择协议"></a>常见的路由选择协议</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b1876963d6d9de0.webp"></p><h3 id="路由器基本结构和功能"><a href="#路由器基本结构和功能" class="headerlink" title="路由器基本结构和功能"></a>路由器基本结构和功能</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e6b69c1f176e24c5.webp"></p><p><strong>分组转发部分</strong><br>转发时需要注意的行为：</p><ul><li>若在转发表中找不到匹配条目则<strong>丢弃分组</strong></li><li>转发时会<strong>更新分组首部的某些字段</strong>，如分组生存时间</li><li>各端口都有缓冲区，每个端口一般都具有输入、输出功能</li></ul><p><strong>路由选择部分</strong><br>路由选择处理器根据所使用的路由选择协议周期性的与其他路由器进行路由信息交互来更新路由表。<br>如果路由器接受到的分组是路由器之间交换路由信息的<strong>路由报文</strong>，则会把这种分组送交给<strong>路由选择处理器</strong>进行处理。</p><p>路由选择处理器的行为：</p><ul><li>路由表一般只包含从目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表生成的</li><li>转发表的结构应当使查找过程最优化</li></ul><div class="note note-primary">            <p>路由表（RIB）和转发表（FIB）的联系和区别：</p><ul><li><p>联系<br>转发表是路由器使用一个特定的进程通过路由表中的信息和自身的网卡等信息综合得到的。转发表类似于交换机的地址信息表。</p></li><li><p>区别<br>首先，”转发”和”路由选择”是有区别的，”转发”时，路由器只需要把接受到的信息从合适的端口发送出去即可，只涉及到一个路由器。”路由选择”则是许多路由器协同工作的结果。<br>其次，路由表只存储三元素：目标，掩码，下一跳；而转发表存储更详细的信息：比如输出端口信息，某些MAC地址，比如标记信息等。</p></li></ul><p>这里的描述都屏蔽了MAC地址的问题，这里在汇总对比一下：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。</li></ul><p>举例：<br>局域网：使用MAC表和ARP表即可实现局域网内主机通讯（使用交换机，虽然现在不会这么使用）<br>主机流程：目的IP地址 -&gt; 目的MAC地址 -&gt;端口<br>路由器流程同上。</p><p>因特网：但不同网段之间的通讯，要涉及到网络路线选择问题。<br>主机流程：目的IP地址(非本网段) -&gt; 目的MAC地址（默认网关）-&gt;端口<br>路由器流程：目的IP地址 -&gt; 下一跳IP地址（路由选择） -&gt;MAC地址 -&gt; 端口</p>          </div><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由信息协议RIP(<em>Routing Information Protocol</em>)<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-850c29aaf1e744d6.webp"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>思路</strong></p><ul><li>距离最短为最好路由</li><li>相同距离则负载均衡</li><li><strong>只和相邻的路由器周期性的交换自己的路由表</strong></li></ul><h5 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6bf4e045a90846e0.webp"></p><p><strong>路由更新细节</strong><br>接受到更新报文后和自己的路由器对比：</p><ul><li>未知的Net，插入新信息。</li><li>相同Net和相同下一跳，<strong>覆盖距离信息</strong>。</li><li>相同Net和不同下一跳，距离不同则使用，若<strong>相等则都保留并负载均衡</strong>。</li></ul><h4 id="RIP存在的问题"><a href="#RIP存在的问题" class="headerlink" title="RIP存在的问题"></a>RIP存在的问题</h4><p>如果网络出现故障，由于远处的路由器获知这个消息慢，先发出了自己的更新报文，则可能造成路由器之间互相认为对方可以到达一个不可达的网络，形成<strong>网络环路</strong>。</p><p>解决方法<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-3a055002b79a9cda.webp"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><h4 id="RIP的优缺点"><a href="#RIP的优缺点" class="headerlink" title="RIP的优缺点"></a>RIP的优缺点</h4><blockquote><p>RIP 协议的优缺点<br>优点：</p><ol><li>实现简单，开销较小。<br>缺点：</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p>开放最短路径优先 OSPF (<em>Open Shortest Path First</em>)。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f5dc77f36b5b1047.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="OSPF五种分组类型"><a href="#OSPF五种分组类型" class="headerlink" title="OSPF五种分组类型"></a>OSPF五种分组类型</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a2a83ab2654e270f.webp"></p><h5 id="基本工作过程-1"><a href="#基本工作过程-1" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-339786779f0e1a82.webp"></p><p>部分细节：<br><strong>Hello分组</strong><br>建立并维护路由器关系的分组。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f9c642e76e871651.webp"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong><br>包含具体的路由信息，被封装在<strong>LSU分组</strong>中<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bbed8a0d31bf19c3.webp"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b8e10e2d82cfa6f.webp"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-4239eee0b6040f52.webp"></p><div class="note note-primary">            <p>总结，OSPF是一个路由器通过获取AS内所有路由器之间边信息，然后建立一个以自己为根节点的无环图的过程。<br>具体地，相邻路由器会通过Hello分组维护关系，并互相简单介绍自己已知的路由信息，然后各自通过路由信息请求、路由信息返回、路由信息确认等过程逐步获得整个AS内的路由信息，最后构建各自的路由表。</p>          </div><h4 id="OSPF存在的问题"><a href="#OSPF存在的问题" class="headerlink" title="OSPF存在的问题"></a>OSPF存在的问题</h4><h5 id="大量多播分组"><a href="#大量多播分组" class="headerlink" title="大量多播分组"></a>大量多播分组</h5><p>多点接入（较多路由器互联）时，会产生大量的多播分组，通讯量过大。<br><strong>解决方法</strong><br>1）屏蔽部分路径，因此只与部分路由器进行数据交换。DR出现问题后使用BDR替换。</p><p> 2）路由分区，<strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-725b3aab5aa350b1.webp"></p><blockquote><p>实现细节：</p><ul><li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域，每个区域都有一个32比特的区域标识符，主干区域的区域标识符必须为0，主干区域用于连通其他区域，其他区域的区域标识符不能为0且不相同。</li><li>每个区域一般不应包含路由器超过200个。</li><li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量。</li></ul></blockquote><h4 id="OSPF的优缺点"><a href="#OSPF的优缺点" class="headerlink" title="OSPF的优缺点"></a>OSPF的优缺点</h4><div class="note note-primary">            <p>优点：</p><ul><li>从算法上避免了环路的产生。</li><li>基于链路状态，相比RIP考虑了更多对链路代价的影响因素。</li><li>不限制网络规模（没有最长距离限制）</li></ul><p>缺点：</p><ul><li>实现较复杂。</li><li>路由器需要获取AS内所有路由器信息，通信量大，可以通过<strong>指定路由器</strong>和<strong>划分区域</strong>的手段解决。</li></ul>          </div><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（<em>Border Gateway Protocol</em>） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><strong>为何需要BGP？</strong><br>AS之间没有统一度量，且需要一个网关去解决AS之间通讯时的相关策略问题（政治、经纪、安全等），因此需要一个外部网关协议。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5aae9c53795e17a7.webp"></p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-04fe6f98036db57c.webp"><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bc71c2ee5976ac53.webp"><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-b472dd1a51f30666.webp"></p><h5 id="BGP-4四种分组类型"><a href="#BGP-4四种分组类型" class="headerlink" title="BGP-4四种分组类型"></a>BGP-4四种分组类型</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-67b837e6c27d5e9c.webp"></p><div class="note note-primary">            <p>总结，BGP协议要求每个AS有一个发言人，发言人之间建立TCP连接建立会话，交换路由信息。类似于OSPF协议，发言人也会构造一个无环路的AS连通图。<br>注意，<strong>BGP不保证最好路由，只选择较好路由</strong>。</p>          </div><h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-40cf22cbd65e9ed8.webp"></p><h1 id="五、IPv4数据包格式"><a href="#五、IPv4数据包格式" class="headerlink" title="五、IPv4数据包格式"></a>五、IPv4数据包格式</h1><h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><blockquote><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li></ul></blockquote><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-73800cce52c3a91e.webp"></p><h3 id="固定部分"><a href="#固定部分" class="headerlink" title="固定部分"></a>固定部分</h3><p><strong>基本信息</strong><br>主要记录一些版本，服务约定，和后续数据长度。</p><ul><li>版本：占4比特，目前最广泛的是4（IPv4）</li><li>首部长度：占4比特，该字段的取单位为<strong>4个字节</strong>（即上图的一行）。<ul><li>最小十进制取值为5，即20字节固定部分</li><li>最大十进制取值为15，即20字节固定部分和40字节可变部分</li></ul></li><li>区分服务：占8比特，需要区分服务（不同等级的服务质量）时才起作用，一般不适用该字段。</li><li>总长度：占16比特，表示<strong>单位为字节</strong>的IP数据报总长度（包括首部长度）。最大值为65535，即2^16-1</li></ul><p><strong>分片信息</strong><br>主要用于IP数据报分片<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a014cde6b0ff9691.webp"></p><ul><li>标识：占16比特，同一个IP数据包的分片应该有同一个标识，类似ID</li><li>标志：占3比特：<ul><li>DF位：1个比特，1表示不允许分片；0表示允许分片。</li><li>MF位：1个比特，1表示不是最后一个分片，0表示是最后一个分片。</li><li>保留位：1个比特。</li></ul></li><li>片偏移：占13比特，表示分片数据包的“数据载荷部分”相比原数据报中的“数据载荷部分”偏移了多少。（<strong>单位为8字节</strong>，注意，由于这里的偏移量比特位小于总长比特位，为了完成表达必须使用更大的单位。）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5d538557f988dc41.webp"></li></ul><p><strong>解析信息</strong></p><ul><li>生存时间TTL：占8比特，以“跳数”为单位，每次路由器转发该IP数据包，TTL-1，若为0则丢弃。</li><li>协议：占8比特，指明IPv4数据包的数据部分向上交付给什么协议。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-94a3b7c0b1f01488.webp"></li><li>首部检验和：占16比特，检测首部在传输过程中是否出现差错。比CRC检验码简单，被称为因特网检验和。（由于TTL、片偏移、标志等可能发生变化，每次路由器转发时都要重新计算该值，耗时太大，在IPv6中已经不再计算首部校验和）</li></ul><p><strong>地址信息</strong><br>目的IP和源IP地址：各占32比特。</p><h3 id="可变部分"><a href="#可变部分" class="headerlink" title="可变部分"></a>可变部分</h3><ul><li>可选字段：长度从1到40字节不等</li><li>填充字段：确保<strong>首部长度为4字节</strong>（呼应首部长度的单位是4个字节）的整数倍，使用全0填充。</li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h3><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><div class="note note-primary">            <p>简而言之，需要一个与路由器之间的协议来<strong>监测数据的转发情况</strong>。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8739d970a0300acc.webp"></p><blockquote><p><strong>ICMP报文会被封装到IP数据报中，但其不是高层协议，而是IP层的特殊协议（起控制作用，所以也叫网际控制报文协议ICMP）。</strong></p></blockquote><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6a02675fccdc2958.webp"></p><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p><strong>终点不可达</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-855edabd9c1e6298.webp"><br><strong>源点抑制</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e7f27ef6c93c9621.webp"><br><strong>时间超过</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-49d82185c88813fe.webp"><br><strong>参数问题</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e2457fe1291c9bca.webp"><br><strong>改变路由（重定向）</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0ef50227f921ca79.webp"></p><p><strong>另外，不应发送ICMP差错报告报文情况</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a0c3a21bb04ede42.webp"></p><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（<em>Packet InterNet Groper</em>）</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-75d7bc12ca942415.webp"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（<em>traceroute</em>）</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-185af899d5e5a922.webp"><br>实现原理：<br>使用从1开始递增的TTL发送多个报文，报文在路由器超时时会返回给源主机ICMP差错报告，从而得到各跳的信息。</p><h1 id="六、虚拟专用网VPN与网络地址转换NAT"><a href="#六、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="六、虚拟专用网VPN与网络地址转换NAT"></a>六、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（<em>Virtual Private Network</em>）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>虚拟专用网络</strong>VPN的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><div class="note note-primary">            <p>顾名思义，指一种利用公网实现专用网访问的技术。</p><p>简单的说就是两个专用网络之间通过公网IP进行加密通讯。VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ad9e5dcca8c0a1c9.webp"></p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6731dbc8b1ee1abc.webp"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（<em>Network Address Translation</em>）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>目的：大量的办公室网络和家庭网络导致IP地址仍然不够，需要实现IP复用。NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p>专有NAT软件的路由器叫做NAT路由器，其有至少一个公网IP地址。</p><p>以上只解决了发送信息的问题，为了实现接受消息后的对内网用户的分发需要使用NAPT技术，具体见以下实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-05d3e1e3fd4b1998.webp"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>外网无法直接访问内网<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d2fd109d060e4853.webp"></li><li>NAT对内网主机提供了一定的安全保护<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ff43ea52e61da271.webp"></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/0f6de444f46c">计算机网络第4章（网络层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第3章（数据链路层）</title>
    <link href="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>物理层已经保证了数据在物理层面上的传输功能，但无法避免传输中发生的错误。数据链路层作为网络层、物理层之间的桥梁，<strong>主要的职责则是保证数据传输过程的差错控制和可靠传输</strong>，即识别、纠正传输中发生的错误。</p><p>网络中的主机、路由器、交换机等都必须实现数据链路层。</p><p>术语：</p><ul><li><strong>链路</strong>（<em>Link</em>）表示一段没有交换节点<strong>物理</strong>线路</li><li><strong>数据链路</strong>（<em>Data Link</em>）表示具有通讯协议的软硬件实现的<strong>链路</strong></li></ul><div class="note note-primary">            <p>数据链路层的协议是多样的，两个主机之间的数据传输，可能会经过多个不同协议数据链路，他们只需要保证实现数据链路层的功能和对网络层的服务相同即可。</p>          </div><p>使用的信道类型分类：</p><ul><li>点对点信道</li><li>广播信道</li></ul><blockquote><p><strong>局域网属于数据链路层</strong><br>局域网虽然也是个互联网，但我们不将其放在网络层考虑，因为网络层的主要职责是将分组从一个网络通过路由器发送到另一个网络。而局域网的功能，使用交换机即可实现。<br>PS：路由器也可以称为三级交换机，我们平时说的交换机就是二级交换机。</p></blockquote><h2 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong><br><strong>封装成帧</strong>：将数据加上帧头和帧尾，用于<strong>帧定界</strong><br><strong>差错控制</strong>：识别传输中的错误。<br><strong>可靠传输</strong>：识别错误后确保重传。</p><blockquote><p>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决，如帧识别（确认是发给自己的帧）、数据碰撞问题（共享信道的问题）。下面我们只讲PPP的例子。</p></blockquote><blockquote><p>目前，在有线（局域网）领域使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>已经取代了<del>共享式局域网</del><br>而在无线局域网中仍然使用的是共享信道技术</p></blockquote><h1 id="二、主要职责"><a href="#二、主要职责" class="headerlink" title="二、主要职责"></a>二、主要职责</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-bf6fe42eeea3f376.webp"><br>封装成帧的目的是识别帧分界，不同数据链路层协议对此的实现是不同的：</p><ul><li>PPP，帧头和帧尾有1字节的标识符</li><li>EtherNet的V2的MAC帧，使用一个前导码，例如：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f1441c531b4d740e.webp"></li></ul><blockquote><p>为了实现定界，需要一个开始和结尾符，以太网规定开始符为前导码，结尾符的功能通过保持帧的间距（以太网还规定了帧间间隔为96比特时间）实现（说明PPP的帧是连续的？也合理，点对点连着传）</p><p>前导码包括前同步码和帧开始定界符</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧（这里是从右往左看）</li></ul></blockquote><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，因此我们要避免上层数据中也出现帧定界符导致的解析混淆。</p><p><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (<em>byte stuffing</em>) 或<strong>字符填充</strong> (<em>character stuffing</em>)，面向比特的物理链路使用比特填充的方法实现透明传输。</p><p>具体的:</p><ul><li>发送端对于上层交付数据中出现的与定界符相同的字符，在其前插入转义字符“ESC”（十六进制编码是1B），若上层数据本身有该转义字符，则再其前插入一个转义字符。</li><li>接受端将内容中的转义字符剔除即可。</li></ul><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-9d3f61fdd96b7dee.webp"></p><p>最大传送单元MTU 规定了帧的<strong>数据部分</strong>的长度上限。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><strong>比特差错</strong>：1变0，0变1<br><strong>误码率BER</strong>(<em>Bit Error Rate</em>)：错误bit占总bit的比率。</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>使用1位bit来标记 数据中“1”个数的奇偶性，只要出现两个相同类型误码就会漏检。</p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(<em>Cyclic Redundancy Check</em>)</h3><p>约定好一个生成多项式G(x)，其实就是一段bit串，如：10111<br>将这个bit串作为除数，原数据作为被除数，得到余数，这个数称为<strong>检错码</strong>，也称为<strong>帧校验序列 FCS</strong></p><blockquote><p>检错码只有检查错误的能力，<strong>不知道错误发送的位置</strong><br><strong>纠错码</strong>可以进行前向纠错，但成本高，使用少<br>CRC非常易于硬件实现，被<strong>广泛应用于数据链路层</strong><br>检查出错误后，是丢弃还是重传，往往取决于数据链路层向上层提供的是<strong>可靠传输服务</strong>还是<strong>不可靠传输服务</strong>。</p></blockquote><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><strong>比特差错</strong></p><ul><li>对于可靠传输要求实现重传，对于不可靠传输，交给上层协议处理。</li><li><strong>一般而言</strong>，有限链路不要求可靠，无线链路要求可靠（误码率高）。</li></ul><p><strong>分组丢失、分组失序、分组重复</strong><br>一般不发生在数据链路层，而是发送在上层。</p><div class="note note-primary">            <p>理解：在单条数据链路上，数据一般不会丢失。失序、重复，这些问题往往发生在网络层。</p>          </div><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/Pic0.png"></p><p>为了解决以上错误，有以下三种可靠协议，这三种协议更多体现的是一种事件确认思想，因此可以应用到各层的协议中。</p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><h4 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>发送端发送数据DATA0后，等待接受方返回一个确认信息ACK0后，再发送下一条数据DATA1。</li><li>为了防止数据的丢失、错误，需要设置<strong>重传时间</strong></li><li>为了防止数据重传造成的重复发送、接受，需要设置一个<strong>Bit位标识数据</strong>区别</li></ul><div class="note note-primary">            <p>这部分的各种特殊情况比较复杂，我们按照事件的发生进行梳理。<br>在数据传输过程中有三个基本问题需要解决：<br><strong>数据丢失</strong>（没传到）、<strong>数据错误</strong>（传错了）、<strong>数据延迟</strong>（传慢了）。</p><p>为了解决<strong>数据丢失</strong>和<strong>数据错误</strong>的问题，发送端需要重发数据，所以设置了一个超时时间，超过时间就会进行<strong>重传</strong>。（实际上对于<strong>数据错误</strong>，接受端也可以主动回复NAK提醒发送端尽快重发，但有线网内这种情况较少，一般只在误码率较高的时候进行）。</p><p>对于<strong>数据延迟</strong>的问题，理想情况其实是等待数据达到，即不需要我们解决。但实际上无法确定是数据是延迟还是丢失，也会导致触发重传，这里就衍生出了一个新问题，即<strong>发送端和接受端都可能接受到两条甚至更多相同的数据</strong>（因为接受端对每条信息都会回复确认，所以发送端也会收到两条确认ACK信息），显然我们要对后面的数据进行忽略，因此需要一个数据标识符做区分，在这里体现为一个bit。</p><p>至此，我们解决了3个基本问题和1个衍生问题。</p>          </div><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-8dbdfdbac8087fd21.webp"></p><h5 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3b4b0d81e5dd78eb.webp"></li></ul><blockquote><p>停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><div class="note note-warning">            <p>为了解决RTT过长的问题，有以下两种协议。</p>          </div><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cc9d42f63bd259cc.webp"></p><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-2a7141766ab1aa80.webp"></p><ul><li>发送方可以一次性<strong>连续发送</strong>多个数据分组，接受方每接受到一个数据就移动一次窗口，且不需要对每个分组逐个确认，一般设置在接受到若干个数据分组，对接受到的最后一个数据分组进行一次<strong>累计确认</strong>即可。</li><li>传递发生错误时，例如5号分组出现错误则丢弃，此后接收方每接受到一个不是5号的信息都会<strong>主动回复</strong>一个ACK4，请求发送端尽快发送DATA5（发送端在收到多少个ACK4后会提前发送DATA5，由具体实现决定，实际上就算收不到，也会超时重发。）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-215e8704b22ef7f2.webp"></li><li><strong>使用n位bit标识分组</strong>，则编号范围为0~2^n-1，发送窗口大小必须小于2^n-1，否则接收方会出现误判。</li></ul><div class="note note-primary">            <p>相对SW协议，GBN协议为了提高信道利用率，采用了<strong>连续发送与累计确认、主动回复</strong>等方式，在具体的实现上出现了新的问题和解决：</p><ul><li>针对<strong>连续发送与累计确认</strong>，为了识别正确接受顺序，需要使用多bit位标识数据，bit的位数也限制了发送窗口大小。</li><li>针对<strong>主动回复</strong>，客户端之前接受到错误信息和重复分组时会直接舍弃。现在客户端只舍弃错误信息，也因此会接收到许多错误分组信息（不是当前需要的分组），对这些都要进行重复确认ACK。</li></ul><p>当然，超时重传的性质依然存在，这是避免信息丢失的必要手段，主动回复只是一种加速，不是一种保证。</p>          </div><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><h5 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li><strong>扩大接受窗口的尺寸</strong>，接收方可以不用按照顺序接受分组，避免浪费。发送方也可以只重传错误分组。</li><li>由于不再按顺序接受分组，所以需要<strong>逐条确认</strong>，累计确认不再有效。发送，接受方都需要逐个确认。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=27&vd_source=7324e975d0c1b4b4719d1194e3649ff8">视频参考</a></li></ul><div class="note note-primary">            <p>相当于对分组进行批量的发送接受，只重传错误分组，重传机制仍是超时判断。接收方根据接受到的分组DATA滑动窗口，发送方根据接受到的ACK滑动窗口。</p>          </div><h1 id="三、点对点协议PPP"><a href="#三、点对点协议PPP" class="headerlink" title="三、点对点协议PPP"></a>三、点对点协议PPP</h1><ul><li>点对点协议PPP（<em>Point-to-Point Protocol</em>）是目前使用最广泛的点对点数据链路层协议。</li></ul><div class="note note-primary">            <p>端对端是P2P(Peer-to-Peer)。</p>          </div><h2 id="职责实现"><a href="#职责实现" class="headerlink" title="职责实现"></a>职责实现</h2><p>上文介绍了数据链路层的主要职责和方法，具体协议则需要对各功能做具体实现。</p><h3 id="封装成帧-1"><a href="#封装成帧-1" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>使用了帧头帧尾和对应的转义字符。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-b384615e861000f3.webp"></p><h4 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h4><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d40da4575c590f5c.webp"></li><li>面向比特的同步链路：比特填充法（插入“比特0”）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6290c73d8957ee8d.webp"></li></ul><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>使用FCS计算帧部分，立即丢弃错误帧。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-501e6b9dd2afcee3.webp"></p><h1 id="四、媒体接入控制——广播信道"><a href="#四、媒体接入控制——广播信道" class="headerlink" title="四、媒体接入控制——广播信道"></a>四、媒体接入控制——广播信道</h1><blockquote><p><em>Medium Access Control</em>翻译成媒体接入控制，有些翻译成<strong>介质访问控制</strong>，是一种主要用于局域网的数据链路层的广播通信方式。</p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>网络拓扑结构：星形、总线、环形</p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><div class="note note-primary">            <p>PPP协议是目前使用最广泛的点对点数据链路层协议，但数据链路层需要解决局域网问题，局域网常常会有共享信道，广播等需求。对于不同类型的局域网，这些需求的解决方式也不尽相同，因此又将数据链路层分为两层，一层解决类似PPP（PPP基本没有第二层问题，其独占信道）的问题，另一层解决传输媒体（主要是信道冲突）上的问题。</p>          </div><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3d6792f6b442b459.webp"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><div class="note note-primary">            <p>PPP协议对应的交换机技术可以很好的解决共享信道问题，但是无线网络仍需要共享媒体。信道复用问题之前在物理层也提过，但由于物理层主要只解决01传递的问题，这种与传媒相关的问题则交给了数据链路层的MAC子层解决。</p>          </div><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>频分复用FDM</strong> (<em>Frequency Division Multiplexing</em>)</p><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。<br><strong>时分复用TDM</strong> (<em>Time Division Multiplexing</em>)</li><li><strong>时分复用</strong>则是将时间划分为一段段<strong>等长</strong>的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。  </li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong><br><strong>波分复用 WDM</strong>(<em>Wavelength Division Multiplexing</em>)</li><li>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。<br><strong>码分复用 CDM</strong> (<em>Code Division Multiplexing</em>)<blockquote><p>复用：信道分为多个子信道，用户使用子信道。<br>多址：动态分配信道给用户，用户暂时占用信道。<br>因此码分复用更多的被称为码分多址。</p></blockquote></li></ul><p>具体实现：使用多个bit位表示1个bit位，解释如下：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-91ed6f416ae8fad6.webp"><br>这样，接受方通过向量计算即可从叠加信号中解析中指定发送方发出的信息。</p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>总线局域网</strong>使用CSMA&#x2F;CD（<em>Carrier Sense Multiple Access&#x2F;Collision Detection</em>）协议，即载波监听多址接入&#x2F;碰撞检测。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-00eb7fba113030d2.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-574d77a51611a634.webp"></p><div class="note note-primary">            <p>CD的硬件实现：判断总线电压摆动值变大超过门限。<br>为什么需要CD：CS具有传播延迟。</p>          </div><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1.准备发送-&gt;2.载波监听（信道忙则回到1）-&gt;3.发送并碰撞检测（碰撞则停止并等待一段时间回到1）-&gt;4.发送直到完毕</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a77d88a950995527.webp"></p><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-423fe21ffdbacb81.webp"></p><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-fa63a8f164fb9191.webp"></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-93f832e4b0a569ae.webp"></p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dc35877bb4bead1a.webp"></p><h4 id="帧接受过程"><a href="#帧接受过程" class="headerlink" title="帧接受过程"></a>帧接受过程</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cf2d95546ecf2664.webp"></p><div class="note note-primary">            <p>以上特性、限制都是为了在保证<strong>数据不碰撞</strong>的情况下保证<strong>合理性</strong>。<br><strong>保证不碰撞</strong>：<strong>争用期</strong>，<strong>最小帧长</strong>都是为了保证能检测信道是否有碰撞。<br><strong>合理性</strong>：<strong>最大帧长</strong>，单帧不能过长占用信道，<strong>截断二进制指数退避算法</strong>，灵活延迟避让时间，防止多次重传。</p>          </div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。<br><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong><br><strong>主要的无线网标准：802.11标准</strong><br>为什么无线局域网要使用CSMA&#x2F;CA协议：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dd01f296832d017a.webp"></p><div class="note note-primary">            <p>分布式协调功能DCF是各站点争用的方式。<br>点协调功能PCF则有一个中心站做协调，但使用较少。</p>          </div><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6c9fe4ae6927eb02.webp"><br>相比载波监听，有信道空闲持续时间限制，其控制了帧的发送间隔。</p><blockquote><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul></blockquote><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a756ebbd569e600a.webp"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><ul><li>防止多个站点同时发送数据而产生碰撞</li></ul></blockquote><p><strong>使用退避算法的时机</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f0d70f0b26645fb4.webp"></p><p><strong>CSMA&#x2F;CA协议的退避算法</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-1de197cb6f859f3c.webp"></p><p>示例：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-12262e66fc986d52.webp"></p><div class="note note-primary">            <p><strong>碰撞检测CD</strong>的思想类似于<strong>乐观锁</strong>，即先发送，发送后碰撞则进行退避处理。<br><strong>碰撞避免CA</strong>的思想类似于<strong>悲观锁</strong>，需要尽可能的保证信道通畅（通过退避的方式）然后再发送。<br>载波监听则是一种判断是否有锁的工具。</p><p>在CD中，如果当前信道空闲则直接发送信号，失败后则停止发送并等待，随后尝试重新发送。<br>在CA中，如果当前信道空闲，<strong>首先要等待一个DIFS时间</strong>，等待<strong>优先级</strong>更高的站点先尝试获取信道，这个时间之后，<strong>再根据信道的状况判断是否需要进行退避。</strong></p><ul><li><strong>DIFS时间是DCF模式（分布式协调功能）下的退避时间的基本单位。</strong></li><li><strong>默认的DIFS间隔时间并不在退避算法中</strong>。其是整个共享信道的处理完一个帧之后的间隙时间，各个站点以通过信道的这个间隙时间来判断信道进入了空闲状态（空闲了一个DIFS时间），然后解冻倒计时，进行<strong>优先级</strong>争夺。</li></ul>          </div><h4 id="信道预约和虚拟载波监听"><a href="#信道预约和虚拟载波监听" class="headerlink" title="信道预约和虚拟载波监听"></a>信道预约和虚拟载波监听</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-98353d62c0ef033f.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ac35b15f5f22bf7d.webp"></p><div class="note note-primary">            <p>以上为可选功能，通过向目的站发送“要发送数据帧”的请求（<strong>信道预约</strong>），目的站同意这个请求后发出“允许发送数据帧”的广播，此时其他站点就不能使用该信道了。由于RTS、CTS都携带了下次传递的大数据帧信息，因此其他站点知道本次信道会被占用的时间，实现了<strong>虚拟载波</strong>。<br>此时，如果其他站只能监听到目的站信息，监听不到源站信息，其也可以收到CTS从而避免在这个时间段内发送信息，减少了隐蔽站的问题。</p>          </div><h1 id="五、MAC地址、IP地址、ARP地址"><a href="#五、MAC地址、IP地址、ARP地址" class="headerlink" title="五、MAC地址、IP地址、ARP地址"></a>五、MAC地址、IP地址、ARP地址</h1><p>三者的关系：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ede2c92a0c809e6c.webp"></p><h2 id="MAC-Media-Access-Control-地址"><a href="#MAC-Media-Access-Control-地址" class="headerlink" title="MAC(Media Access Control)地址"></a>MAC(<em>Media Access Control</em>)地址</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><div class="note note-primary">            <p>注意：MAC地址的主要作用标记目的物理地址和源物理地址，在<strong>广播信道</strong>中，所有站点都会接受到MAC帧（也可以由交换机进行调度），然后根据目的物理地址是自身而决定是否舍弃该帧，但对于<strong>点对点的信道（不是协议）</strong> 则不需要MAC帧。</p>          </div><blockquote><ul><li><strong>MAC地址又称为硬件地址或物理地址</strong>。但其属于数据链路层而不是物理层。</li><li>MAC地址是对网络上各接口的唯一标识。</li></ul></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-70ee74506eca1df4.webp"></p><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。<br>无效MAC帧：</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；<br>（防止bit丢失）</li><li>用收到的帧检验序列 FCS 查出有差错；<br>（防止bit错误）</li><li>数据字段的长度不在 46 ~ 1500 字节之间。<br> (防止bit增加)<br>以太网检测到无效MAC帧直接丢弃。</li></ul><p>MAC帧发送顺序</p><ul><li>从第一字节发到第六字节</li><li>每字节从b0发到b7</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>单播（单选）：根据站点根据目标地址与自己是否相符决定是否舍弃。</li><li>广播（全选）：<strong>广播MAC地址为全F</strong>，所有站点都接受该帧</li><li>多播（多选）：只发送给指定的若干目的站点。<strong>多播MAC帧的目的地址的第一个bit为1</strong>，即第一个字节的b0位为1。其他站点是否接受则根据自身多播组列表设置。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴。</p><ul><li>对于局域网而言MAC地址即可区分设备（但现在实际上还是会使用IP地址而不是MAC地址）。</li><li>对于因特网而言MAC地址无法区分一个网络，需要使用IP地址加MAC地址。</li><li>例子：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-77c204bc8181b3ed.webp"></li></ul><div class="note note-primary">            <p>参考现实中根据地图导航。<br><strong>IP地址</strong>用来标记起点和终点，从起点到终点需要经过很多交通工具。<br><strong>MAC地址</strong>根据目的IP地址选择当前交通应该在哪站下车然后换乘。<br>这个根据IP地址选择下车站的方法就是<strong>ARP协议</strong></p>          </div><h2 id="ARP协议（地址解析协议Address）"><a href="#ARP协议（地址解析协议Address）" class="headerlink" title="ARP协议（地址解析协议Address）"></a>ARP协议（地址解析协议Address）</h2><p>主机都有一个ARP高速缓存表，其中记录了IP地址和MAC地址的映射。</p><ul><li>如果表中记录了IP地址对应的MAC地址，则可以直接填写目的MAC地址发送MAC帧。</li><li>如果不知道，则发送<strong>ARP请求报文</strong>（广播）。目的IP地址的主机接受到该请求后会给源主机回复自己的MAC地址。</li></ul><p><strong>ARP高速缓存表</strong><br>有动态记录和静态记录。</p><ul><li>动态记录为自动获取，有持续时间、过期作废（默认两分钟）</li><li>静态记录为手工设置，始终保存（实际上依赖于操作系统的实现）。</li></ul><blockquote><p>ARP是逐段链路进行的。即主机只记录和自己直接连接主机的MAC地址，跨网络的地址则不管。</p></blockquote><div class="note note-primary">            <p>这里的ARP的作用主要是让机器通过广播形式学习和自己直连的设备的IP-MAC映射关系，<strong>方便其填入MAC帧的目的地址</strong>，并不能告知他应该如何把数据准确的发送到哪个主机。</p><p>ARP没有安全验证机制，可能<strong>存在ARP欺骗（攻击）问题</strong>。</p><p>ARP表中记录<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>          </div><h1 id="六、集线器和交换机"><a href="#六、集线器和交换机" class="headerlink" title="六、集线器和交换机"></a>六、集线器和交换机</h1><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>在总线型网络中，所有站点共享一个信道。但总线的拓扑结构在<strong>物理层</strong>实现很不方便，所以可以使用集线器作为中点，网络结构则变成了<strong>星型结构</strong>。</li><li>但实际上其在以太网上仍是一个<strong>总线型网络</strong>。集线器也只工作在物理层，并没有网络管理作用。</li><li>集线器是也可以看做多口<strong>中继器</strong>，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>扩展网络（<strong>扩大广播域</strong>），两个集线器直接连接即构成了更大的总线网络。但<strong>碰撞域</strong>却增大了。</p><blockquote><p><strong>碰撞域</strong>（<em>collision domain</em>）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p></blockquote><div class="note note-primary">            <p>集线器工作在物理层，而下文中的交换机工作在数据链路层。</p>          </div><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是网桥的替代品，是一个多接口的网桥。<br><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃（<strong>具有管理作用</strong>）。<br><strong>交换机</strong></li><li>1990 年问世的交换式集线器 (<em>switching hub</em>) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (<em>switch</em>) 或<strong>第二层交换机</strong> (<em>L2 switch</em>)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul><p>相对于集线器，其可以进行ARP自学习，并将数据帧定向转发。</p><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度</li><li>不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d5c429a2f92149ff.webp"></p><p><strong>扩大广播域</strong>的同时，<strong>隔离碰撞域</strong></p><blockquote><p><strong>广播域</strong>（<em>broadcast domain</em>）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。注意要与前面的碰撞域做区分。</p></blockquote><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-25db1be3ca96bc2f.webp"></p><h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>以太网交换机通过<strong>自学习算法</strong>建立<strong>帧交换表</strong></p><h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><ul><li>交换机接受到一个数据帧后就会记录这个帧的<strong>源地址</strong>和对应的交换机<strong>端口</strong>（没有则插入，有则更新）</li></ul><h4 id="转发行为"><a href="#转发行为" class="headerlink" title="转发行为"></a>转发行为</h4><ul><li>交换接的帧交换表中如果有该帧<strong>目标地址</strong>对应的端口，则直接将消息转发到该端口，否则发送<strong>广播</strong>（但不对源地址发送）。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每条记录都有有效时间，有效时间到期后删除。（主机可能换网卡，交换机可能改接另一台主机）</li></ul><div class="note note-primary">            <p>注意本处的自学习和前面提到的ARP的异同：<br>异：</p><ul><li>ARP记录的是IP和MAC地址之间的映射关系，记录在ARP高速缓存表中。交换机的自学习记录的是MAC地址与自己的端口的关系，记录在帧交换表中。</li><li>ARP高速缓存表主要用于根据上层的目的IP地址填入目的MAC地址。交换机帧纪录表则用于根据目的MAC地址选择往哪个端口发送。</li><li>实现在不同层面，ARP的实现在逻辑上，依赖于非目标主机会自行舍弃帧；交换机实现在物理上，依赖于只发送给目标机。可以认为交换机是对ARP的总线结构下的一种信道层面优化，减少了各个客户端识别帧的负担并解决碰撞问题。<br>同：</li><li>有已知记录时都会直接发送，没有时都会进行广播学习。</li></ul>          </div><h1 id="七、生成树协议STP"><a href="#七、生成树协议STP" class="headerlink" title="七、生成树协议STP"></a>七、生成树协议STP</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>想要提高以太网的<strong>可靠性</strong>，可以尽可能多的添加交换机之间的连线（<strong>冗余链路</strong>）。这样两个交换机之间就不会因为一条链路出现故障而无法通讯。但这样会造成重复广播等问题，因此需要避免<strong>逻辑上的环路</strong>（保留物理上的环路以备用）。</p><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a65d811129786ec6.webp"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</p></blockquote><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (<em>Spanning Tree Protocol</em>)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><h1 id="八、虚拟局域网VLAN"><a href="#八、虚拟局域网VLAN" class="headerlink" title="八、虚拟局域网VLAN"></a>八、虚拟局域网VLAN</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>集线器和交换机扩大了广播域，但是广播域过于又会造成广播风暴，我们希望能够实现局部广播功能。</p><p><strong>广播风暴</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a2a78b40ae5307db.webp"></p><h2 id="分割局域网的方法"><a href="#分割局域网的方法" class="headerlink" title="分割局域网的方法"></a>分割局域网的方法</h2><ol><li>使用路由器</li><li>VLAN(<em>Virtual LAN</em>)虚拟局域网</li></ol><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>： <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li></ul></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>本质上是要求使用<strong>交换机</strong>实现逻辑上将一个局域网划分成几个虚拟局域网（将一个交换机分成多个交换机），即判断一条广播消息属于哪一个组，因此这种MAC帧需要多一个明确的标识符以供交换机判断。</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li></ul><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-5d3549cc02f9a3b4.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6af352f81b800a98.webp"></p><h3 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h3><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-44a2e259c33ecfd3.webp"></p><h4 id="Truck端口"><a href="#Truck端口" class="headerlink" title="Truck端口"></a>Truck端口</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a93996aae716c6aa.webp"></p><h4 id="Hybrid端口"><a href="#Hybrid端口" class="headerlink" title="Hybrid端口"></a>Hybrid端口</h4><p>是华为私有的端口类型，既可以用于交换机之间或交换机与路由器之间互连，也可以用于交换机与计算机之间互联。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-primary">            <p>数据链路层主要要负责将数据正确的送到目的地。</p><p>其需要在逻辑上实现其职责(逻辑链路控制LLC)：封装帧、差错检测和可靠重传。典型实现是PPP。</p><p>也需要与物理层的交界处实现对共享媒体控制(媒体接入控制MAC)：控制共享媒介的使用策略。典型实现是CSMA&#x2F;CA协议。</p><p>以上内容保证了数据的完整性，但我们还需要保证数据能正确送到指定主机或进行广播。因此需要ARP表来指明目的主机的MAC地址。</p><p>集线器与普通总线结构网络没有区别，而交换机则在可以根据目标MAC地址定向转发MAC帧，避免了碰撞问题，扩大了广播域。</p><p>最后，由于广播域的扩大会造成广播风暴，也有以下两种解决方法：</p><ul><li>为了避免循环广播，需要生成树协议。</li><li>为了避免广播到不必要的区域，需要VLAN。</li></ul>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/6b82134a4325">计算机网络第3章（数据链路层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第2章（物理层）</title>
    <link href="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、物理层的基本概念"><a href="#一、物理层的基本概念" class="headerlink" title="一、物理层的基本概念"></a>一、物理层的基本概念</h1><p>物理层主要考虑如何传输数据比特流。</p><h1 id="二、物理层传输媒体"><a href="#二、物理层传输媒体" class="headerlink" title="二、物理层传输媒体"></a>二、物理层传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><ol><li>同轴电缆（已被淘汰）</li><li>双绞线（主要用于局域网）</li><li>光纤（主要用于ISP接入服务）<ul><li>多模光纤：允许多条不同角度的光纤同时传输</li><li>单模光纤：如同一根波导，没有反射</li></ul></li><li>电力线（主要用于家庭网络扩展：猫）</li></ol><h2 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h2><ol><li>无线电波（波长1m-10km）</li><li>微波（波长1mm-1m）</li><li>红外线（已淘汰，只能直线传输）</li><li>可见光（LIFI）</li></ol><h1 id="三、传输方式"><a href="#三、传输方式" class="headerlink" title="三、传输方式"></a>三、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><strong>串行传输</strong>：数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可<br><strong>并行传输</strong>：一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p><div class="note note-primary">            <p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>          </div><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><strong>同步传输</strong>：以<strong>比特流</strong>的形式传输。字节之间没有间隔。<br><strong>异步传输</strong>：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</p><p>同步传输需要解决时钟问题，即数据的接收方如何判断哪一部分是一个字节：<br>对于同步传输，有两种方式同步时钟：</p><ul><li>外同步：添加独立时钟信号线</li><li>内同步：通过编码信息判断</li></ul><p>异步传输把字节之间断开，根据字节开始和结尾判断即可：</p><ul><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><h2 id="单双工"><a href="#单双工" class="headerlink" title="单双工"></a>单双工</h2><p>信道（<em>channel</em>）：信道一般都是用来表示向某一个方向传送信息的媒体。</p><p>单工：单向传输<br>半双工：双向（不能同时，需要两条信道）<br>双工：双向（同时，需要两条信道）</p><h1 id="四、编码和调制"><a href="#四、编码和调制" class="headerlink" title="四、编码和调制"></a>四、编码和调制</h1><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-acc59055804f0890.webp"></p><blockquote><p>术语：<br><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote><div class="note note-primary">            <p>编码和调制主要解决如何将0，1比特流转化为可以传输的信号形式。<br>码元（code）：对于本章的学习，可以理解为表示一个比特的单元波形。<strong>实际上，根据编码的不同，一个码元可以对应于几个比特，但也可以是几个码元对应于一个比特</strong>。</p><p>基带信号：表示数据传输前的原始信号。</p><p>针对不同的信道（媒介）有不同的方式：</p><ul><li>对于数字信道，其可以清楚的区分电平的高低，因此可以采用<strong>编码</strong>的方式处理原始信号。</li><li>对于模拟信道，一般使用波作为媒介，需要通过控制信号的频率和相位（即<strong>调制</strong>）的方式处理原始信号</li></ul>          </div><blockquote><p>严格来说，传输媒体 ≠ 信道，使用信道复用技术时，一条传输媒体可以包含多个信道。</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>不归零编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-0732d0edc74846b5.webp"><br>缺点：没有时钟同步。<br><strong>归零编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-8aa838a116fdafb4.webp"><br>缺点：每个码元都要归零，数据量太大，编码效率低。<br><strong>曼彻斯特编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-a34a686a9d052e9c.webp"><br>通过跳变方向判断比特位。</p><div class="note note-primary">            <p>相对归零编码，省去了当比特变化为<code>10101010</code>样式时的归零行为，不过对于<code>00000000</code>形式的编码，数据量仍比较大，每次上升后需要在码元间隙下降，如上图的第二个0后面，以便于下一次上升。</p><p>问题：<br>这个码元间隙的下降行为是否导致时钟的误判问题。<br>解释：<br>所谓时钟同步，可以理解为一个打点计时器（？），设备根据打点瞬间电信号的电平判断这个比特位为0还是1，所以若是打点计时器的频率或初始时间与发送端不一致，就会得到失真的信号，这种现象也叫时钟滑移。<br>而曼彻斯特码元间的下降&#x2F;上升行为其实不会被视为下降沿&#x2F;上升沿，因为其实这种编码还是有一个隐藏时钟。对于设备来说，其可以判断接受到的电信号的最短时间间隔，从而判断一个码元的时间长度。（1个码元时间&#x3D;2个最短时间间隔），这样就解决了频率问题。<br>而一个码元单元必然有一个跳变，码元之间不一定有，从而解决了相位问题。</p>          </div><p><strong>差分曼彻斯特编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-9a758474e374329a.webp"><br>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li>跳变仅表示时钟</li><li>码元开始处电平是否变换表示数据<br>优点：比曼彻斯特编码的变化少，曼彻斯特编码为了得到正确的跳变方向有时需要在码元结束时置反，即（连续1和连续0时会导致码元间置反），而这里连续0<strong>或</strong>连续1时（具体看规定变化为0还是1），不需要进行置反。变化相对少一些。</li></ul><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。<br>每个基本波形只能表示1比特信息量。</li></ul><h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><ul><li>在编码中两个电位（一个表示时钟一个表示值）的信息即可表示1比特信息。而对于模拟信号，其有更多维度的信息（同上调制的基本方法），因此可以尝试使用一个码元表示多个比特。</li><li>频率就是相位的变化速率，因此两者不可同时调制。</li></ul><p><strong>正交振幅调制QAM</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1cb6de826ba63b70.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1e2617434d904ce4.webp"></p><ul><li>给出了12个相位（角度），其中有4个角度（45°）有两个振幅，则共有：8 * 1 + 4 * 2 &#x3D; 16种码元。</li><li>故一个码元的信息量为 2^4，可以表示4位bit。</li></ul><h1 id="五、信道的极限容量"><a href="#五、信道的极限容量" class="headerlink" title="五、信道的极限容量"></a>五、信道的极限容量</h1><p>传输信号时会产生各种失真。</p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-b90918937a54faa6.webp"></p><div class="note note-primary">            <p>奈氏准则主要给出一条信道的最高码元传输效率（理论）<br>波特率：码元传输速率<br>比特率&#x3D;波特率 * 每波特携带比特数<br>那么要提高比特率，则要提高每波特携带比特数。</p>          </div><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-57e105e5df793b93.webp"></p><div class="note note-primary">            <p>信噪比：理解起来可以视为信号相对噪音的占比，这个值越大，极限传输速率越高。</p>          </div><div class="note note-info">            <p>奈氏准则主要指出<strong>码元比特量</strong>对传输极限的影响。<br>香农准则主要指出<strong>信噪比</strong>对传输极限的影响。</p>          </div><h1 id="六、信道复用技术"><a href="#六、信道复用技术" class="headerlink" title="六、信道复用技术"></a>六、信道复用技术</h1><h2 id="复用技术类型"><a href="#复用技术类型" class="headerlink" title="复用技术类型"></a>复用技术类型</h2><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽（频率带宽）资源</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-bcb9321a6a8a3d7a.webp"></li><li><strong>时分复用TDM</strong>（<em>Time Division Multiplexing</em>）则是将时间划分为一段段等长的**时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。（可能浪费）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-cb9a20b7ce00d497.webp"></li><li><strong>统计时分复用 STDM</strong> (<em>Statistic TDM</em>)，弥补时分中的浪费，按需分配。<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-7f0b54d1c14702ca.webp"></li><li><strong>波分复用WDM</strong>(<em>Wavelength Division Multiplexing</em>)<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-039cdf67599ebe3b.webp"></li><li><strong>码分复用</strong>（<em>Code Division Multiplexing</em>），常用的名词是<strong>码分多址</strong> CDMA (<em>Code Division Multiple Access</em>)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/792648675640">计算机网络第2章（物理层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第1章（概述）</title>
    <link href="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <url>/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong>互连网</strong>（<em>internet</em>）：多个网络通过路由器互连起来构成的网络（通用名词，可使用任意协议）<br><strong>因特网</strong>（<em>Internet</em>）：是世界上最大的互连网（专有名词，使用TCP&#x2F;IP协议）<br><strong>ISP</strong>（<em>Internet Service Provider</em>）：因特网服务提供者，如电信、联通、移动。</p><p><strong>端系统之间通信</strong>：主机 A 的某个进程和主机 B 上的另一个进程进行通信。</p><div class="note note-primary">            <p>端对端通讯分为两大类：C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p>          </div><h1 id="二、交换方式"><a href="#二、交换方式" class="headerlink" title="二、交换方式"></a>二、交换方式</h1><h2 id="1-电路交换（Circuit-Switching）"><a href="#1-电路交换（Circuit-Switching）" class="headerlink" title="1.电路交换（Circuit Switching）"></a>1.电路交换（<em>Circuit Switching</em>）</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-acb87df045723236.webp"></p><blockquote><p>步骤：<br>1.建立连接 2.通话 3.释放连接</p></blockquote><h2 id="2-分组交换（Packet-Switching）"><a href="#2-分组交换（Packet-Switching）" class="headerlink" title="2.分组交换（Packet Switching）"></a>2.分组交换（<em>Packet Switching</em>）</h2><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>称为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方：</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器：</p><ul><li>缓存分组</li><li>转发分组</li></ul><p>接收方：</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h2><p>报文交换对报文的大小没有限制，主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="4-对比"><a href="#4-对比" class="headerlink" title="4.对比"></a>4.对比</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e655a213714d1871.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-c56f91f290cbc92b.webp"></p><h1 id="三、定义与分类"><a href="#三、定义与分类" class="headerlink" title="三、定义与分类"></a>三、定义与分类</h1><h2 id="按覆盖范围"><a href="#按覆盖范围" class="headerlink" title="按覆盖范围"></a>按覆盖范围</h2><ul><li>广域网WAN（<em>Wide Area Network</em>）</li><li>城域网MAN（<em>Metropolitan</em>）</li><li>局域网LAN（<em>Local</em>）</li><li>个域网PAN（<em>Personal</em>）</li></ul><h2 id="按结构"><a href="#按结构" class="headerlink" title="按结构"></a>按结构</h2><ul><li>总线<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-4ed63e74d9ced719.webp"></li><li>星型<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f6a1849bcc443935.webp"></li><li>环形<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ca133aaaf8fe8659.webp"></li><li>网络<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-d0d30cddc7356396.webp"></li></ul><h1 id="四、性能指标"><a href="#四、性能指标" class="headerlink" title="四、性能指标"></a>四、性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ba6c4e627a62c05e.webp"></p><div class="note note-primary">            <p>速率的k一般指1000，数据量的k为1024</p>          </div><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f4b18e0039f4a6c6.webp"></p><div class="note note-primary">            <p>带宽在模拟信号中指频率范围，在计网中指最高<strong>速率</strong>。<br>关联在于，频率越高，速率越高。</p>          </div><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位时间通过某网络的数据量</p><div class="note note-primary">            <p>带宽相当于理论值、吞吐量为真实值。</p>          </div><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</p><blockquote><p>有时会把排队时延看成<strong>处理时延的一部分</strong><br>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><div class="note note-primary">            <p>m &#x3D; 2 * 10^8</p>          </div><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><div class="note note-primary">            <p>表示链路上有多少个bit正在流动</p>          </div><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>RTT(<em>Round-Trip Time</em>)</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-62d6da59682ef67f.webp"></p><div class="note note-primary">            <p>信道利用率针对具体信道，网络针对全网络信道，都是对时间的利用统计。</p>          </div><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>一定时间范围内，丢失分组数量与总分组数量的比率</p><h1 id="五、体系结构"><a href="#五、体系结构" class="headerlink" title="五、体系结构"></a>五、体系结构</h1><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b5174af1551d6cee.webp"></p><div class="note note-primary">            <p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。<br>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>          </div><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6800e214b18c47c3.webp"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="1-发送"><a href="#1-发送" class="headerlink" title="1.发送"></a>1.发送</h3><p>应用层（<strong>HTTP请求报文</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ac36f7a9544dde9f.webp"><br>传输层（<strong>TCP报文段</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-cc2b73b1736d5809.webp"><br>网络层（<strong>IP数据报</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-dc02183dcf759d9e.webp"><br>数据链路层（<strong>帧</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f8cf8ce4a6bfdb54.webp"><br>物理层（<strong>比特流</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e7285afa504bce0d.webp"></p><h3 id="2-路由转发"><a href="#2-路由转发" class="headerlink" title="2.路由转发"></a>2.路由转发</h3><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b9824f4625354b9b.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-09a0b27933c9895e.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6eace5a882cca26d.webp"><br>再整个封装回去。</p><div class="note note-primary">            <p>路由器主要作用在网络层及以下，主要根据路由表查询端口转发IP数据包。</p>          </div><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>实体：任意可发送或接受信息的硬件或进程</li><li>对等实体：相同层次的实体</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-01d621fd0afde0a2.webp"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合<br><strong>协议三要素：</strong></p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f9bd7898a7f2dadd.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/541d4f0c0f1e">计算机网络第1章（概述）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-基础篇</title>
    <link href="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP-x2F-IP网络模型"><a href="#一、TCP-x2F-IP网络模型" class="headerlink" title="一、TCP&#x2F;IP网络模型"></a>一、TCP&#x2F;IP网络模型</h1><p>主要针对TCP&#x2F;IP网络模型。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层</strong>（<em>Application Layer</em>）只专注于提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="传输层"></p><p>传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p><strong>TCP</strong> 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p><strong>UDP</strong> 只负责发送数据包，不保证数据包是否能抵达对方。但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><h3 id="应用层与传输层的交互"><a href="#应用层与传输层的交互" class="headerlink" title="应用层与传输层的交互"></a>应用层与传输层的交互</h3><p>应用需要传输的数据可能会非常大，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E6%AE%B5.png" alt="TCP段"></p><p>传输层其实并不负责整个传输过程，它的作用是相对应用层而言的，即它可以帮助应用层实现数据传输。</p><p>到传输层数据到达目标设备时，传输层则要负责把数据包传给应用，但一台设备有多个应用，这时需要使用端口号将应用区分开来。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层报文中携带端口号，因此可以识别数据要发给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>如上所述，传输层其实主要做区分应用，把应用数据下发的作用，真正使数据在互联网上传输的功能在<strong>网络层</strong>（<em>Internet Layer</em>）上。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/112.jpg"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p><p>将IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>配合<strong>子网掩码</strong>，可以将一个网络号同时给多个主机使用，子网掩码则用于计算 网络号和主机号。</p><p>如10.100.122.0&#x2F;24后面的<code>/24</code>表示就是 <code>255.255.255.0</code>，将IP地址与子网掩码按位与，得到网络号，与子网掩码的取反按位与，则得到主机号。</p><p>寻找目标地址的过程，就是一个寻找网络-&gt;寻找主机的过程。</p><p><strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网路接口层"><a href="#网路接口层" class="headerlink" title="网路接口层"></a>网路接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="网络接口层"></p><p>网络层实现了信息在互联网上传输的功能，而要将信息传输到互联网，我们还需要经过网络接口层。</p><p>网络接口层的功能主要体现在以太网技术上，即通过局域网把网络包发送到目的地。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务。个人理解是在数据的传输中，数据包会经过很多交换机，交换机会将数据包解包至网络接口层，然后再封装，发送。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>使用 MAC 地址，我们可以标识网络上的设备，实现在以太网、WiFi 这样的底层网络上发送原始数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="tcpip参考模型"></p><p>封装格式：</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.png" alt="封装"></p><div class="note note-info">            <p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>          </div><blockquote><p>应用层负责将应用产生的数据传递给传输层，将从传输层接受到的数据组合，返回给应用。</p><p>传输层负责将从应用层接受到的数据包传递给网络层，这个过程会携带应用端口</p><p>网络层负责将从传输层接受到的数据包发送到网络，这个过程会携带IP地址（网络号+主机号&#x2F;子网掩码）</p><p>网络接口层负责将网络层的数据通过以太网技术的方式发送到数据库</p></blockquote><h1 id="二、浏览器请求过程"><a href="#二、浏览器请求过程" class="headerlink" title="二、浏览器请求过程"></a>二、浏览器请求过程</h1><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/2.webp"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-解析URL"><a href="#1-解析URL" class="headerlink" title="1.解析URL"></a>1.解析URL</h3><p>浏览器先解析URL地址，然后生成给WEB服务器的信息。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/103.webp"><br>如果省略资源路径，则会访问Web服务根目录的<code>index.html</code>或<code>default.html</code></p><h3 id="2-生成HTTP请求信息"><a href="#2-生成HTTP请求信息" class="headerlink" title="2.生成HTTP请求信息"></a>2.生成HTTP请求信息</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/104.webp"></p><div class="note note-primary">            <p>HTTP报文三要素：</p><ul><li>请求报文：请求行(req)+请求头(head)+请求体(body)</li><li>响应报文：状态行(status)+消息头(head)+消息体(body)</li></ul>          </div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>消息发送前需要<strong>查询服务器域名对应的IP地址</strong><br>因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DNS是一种服务器，其专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>，这与中文相反。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。即<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><p>所以实际上是 .  –&gt; .com –&gt;server<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/105.webp"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><p>也就是说，查询域名IP时：</p><ol><li>客户端只会向最近的本地DNS服务器请求ip地址。</li><li>本地DNS服务器若记录了ip地址，则直接返回，若没有记录，则进行以下操作。</li><li>本地DNS向根DNS服务器请求ip地址，根DNS将.com的DNS服务器给本地DNS服务器。</li><li>本地DNS服务器再向.com的DNS（顶级域名服务器）请求ip地址，顶级域名服务器将<a href="http://www.server.com的权威/">www.server.com的权威</a> DNS 服务器给本地DNS服务器。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接。</li></ol><div class="note note-warning">            <p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明目标服务器的位置。</p>          </div><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/106.webp"></p><blockquote><p>DNS 域名解析的过程是一个<strong>只指路不带路</strong>的过程。</p></blockquote><div class="note note-primary">            <p>当然，浏览器、操作系统、hosts文件都有缓存，在这些地方都找不到时才会向本地DNS服务器发请求。</p>          </div><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过DNS获取到IP后，就可以把HTTP的传输工作交给操作系统中的<strong>协议栈</strong>。</p><div class="note note-primary">            <p>注意这里开始进入操作系统层面。</p>          </div><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/107.webp"></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。</p><p>协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code>用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><p>进入协议栈后，就依靠各层协议一步一步完成数据传输。 </p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>HTTP 是<strong>基于TCP协议</strong>传输的，TCP报文格式如下：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/108.webp" alt="TCP报文"></p><p>理解：</p><ul><li><strong>源端口号</strong>和<strong>目标端口</strong>号：这是与应用层交互的关键识别信息。</li><li>包<strong>序</strong>号，防止乱序</li><li><strong>确认号</strong>，防止丢包</li><li><strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>：TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，从而实现<strong>拥塞控制</strong>：即控制发送的速度。</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓的握手就是使通讯双方维护一个状态机。<br><img src="/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp"></p><blockquote><p>SYN指<strong>SYN：同步序列编号</strong>（ Synchronize Sequence Numbers ）<br>ACK指<strong>ACK：确认字符</strong>（Acknowledge character）</p></blockquote><div class="note note-success">            <p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>          </div><div class="note note-primary">            <p>TCP 的连接状态查看，在Linux可以通过<code>netstat -napt</code>命令查看。</p>          </div><h3 id="TCP数据分割"><a href="#TCP数据分割" class="headerlink" title="TCP数据分割"></a>TCP数据分割</h3><p>若HTTP请求报文较长，超过了 <code>MSS</code> 的长度则需要拆解。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/111.webp"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/112.webp"></p><p>拆分出来的每一块数据都会被放进单独的网络包中，分别加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/113.webp"></p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/114.webp"></p><ul><li>IP包头的<strong>协议号</strong>，要填写为<code>06</code>（十六进制），表示协议为 TCP。</li></ul><h3 id="网卡选择"><a href="#网卡选择" class="headerlink" title="网卡选择"></a>网卡选择</h3><p>如何填写源地址IP？<br>根据<strong>路由表</strong>规则，判断哪个网卡作为源地址。<br>使用 <code>route -n</code> 命令查看当前系统的路由表。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/115.webp"></p><ol><li>将目标IP地址与掩码逐行做 <strong>与运算</strong>，如果等于目的Destination，则匹配成功。</li><li>如果都无法匹配，则匹配最后一行，将IP发送给路由器（<strong>默认网关</strong>）</li></ol><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/118.webp"></p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ：IP协议</li><li><code>0806</code> ：ARP协议</li></ul><p><strong>接收方MAC地址如何填写？</strong><br>ARP协议，通过广播的方式获取以太网中路由器的MAC地址。<br>ARP有缓存空间（几分钟），可以先查询缓存，未命中才广播。</p><h2 id="出口-网卡"><a href="#出口-网卡" class="headerlink" title="出口-网卡"></a>出口-网卡</h2><p><strong>数字信息转换为电信号</strong>。<br>通过网卡（硬件）+网卡驱动程序（软件）一起完成数据的发送。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.webp"></p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。<br>交换机：</p><ol><li>电信号-&gt;数字信号</li><li>MAC帧FCS矫错</li><li>根据MAC帧地址转发MAC帧</li><li>找不到则广播（除源端口）</li><li>只有相应的接受者才会接受MAC帧</li></ol><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/123.webp"></p><p>PS：这里注意<strong>交换机的端口不具有MAC地址</strong>，其只起转发包作用。</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/124.webp"></p><p>路由器工作：</p><ol><li>接受发送给自己的MAC帧</li><li>FCS矫错</li><li>根据帧中IP查找路由表，确定对应的接口</li><li>若找不到则选择默认路由。</li><li>要根据目标IP行的网关列判断发送到目标IP后是否还需要继续转发<ul><li>网关为IP地址，说明还要继续转发（IP聚合）</li><li>网关为空，则说明达到了目标地址</li></ul></li><li>根据ARP协议，使用IP地址查询MAC地址（路由器也有ARP缓存）</li><li>发送</li></ol><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h2 id="服务端与客户端"><a href="#服务端与客户端" class="headerlink" title="服务端与客户端"></a>服务端与客户端</h2><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/125.webp"></p><h1 id="三、Linux系统如何收发网络包"><a href="#三、Linux系统如何收发网络包" class="headerlink" title="三、Linux系统如何收发网络包"></a>三、Linux系统如何收发网络包</h1><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/OSI%E4%B8%8ETCP.webp"></p><h2 id="Linux-网络协议栈"><a href="#Linux-网络协议栈" class="headerlink" title="Linux 网络协议栈"></a>Linux 网络协议栈</h2><p>封装：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.webp"><br>以太网中，规定了<strong>最大传输单元</strong>（MTU）是 <code>1500</code> 字节，也就是规定了单次传输的最大 IP 包大小。</p><p>Linux网络栈：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8D%8F%E8%AE%AE%E6%A0%88.webp"></p><ul><li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li><li>Socket 层的下面就是传输层、网络层和网络接口层；</li></ul><h2 id="Linux接受包"><a href="#Linux接受包" class="headerlink" title="Linux接受包"></a>Linux接受包</h2><p>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>方式：</p><ul><li>触发中断：也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。（网络包过多时中断也太多，过时）</li><li><strong>NAPI 机制</strong>：<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</li></ul><p>硬件中断处理函数会做如下的事情：</p><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免CPU不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><div class="note note-primary">            <ol><li>DMA技术写入<strong>ring buffer</strong>，然后触发<strong>硬件中断请求</strong>。</li><li>CPU在中断表中调用注册好的中断函数：<ul><li>软中断：不直接中断，而是暂时屏蔽中断并发起软中断。</li></ul></li><li>软中断后内核线程ksoftirqd轮询处理数据。</li></ol>          </div><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<br>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><h3 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.webp"></p><h2 id="Linux-发送包"><a href="#Linux-发送包" class="headerlink" title="Linux 发送包"></a>Linux 发送包</h2><ol><li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的sk_buff内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li><li>网络协议栈从 Socket 发送缓冲区中取出sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</li><li>TCP 传输协议发送数据，那么<strong>先拷贝一个新的sk_buff 副本</strong>，这是因为sk_buff后续在调用网络层，最后到达网卡发送完成的时候，这个sk_buff会被释放掉。而TCP协议是支持丢失重传的，在收到对方的ACK之前，这个sk_buff不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</li><li>对 sk_buff 填充 TCP 头。sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</li><li>交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</li><li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。</li><li>这一些工作准备好后，会触发「<strong>软中断</strong>」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将sk_buff数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li><li>当发送完成的时候，网卡设备会触发一个<strong>硬中断</strong>来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li></ol><p>通过调整 sk_buff 中 <code>data</code> 的指针，比如：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/sk_buff.webp"><br>即可实现使用同一个数据结构描述各层的数据。</p><p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p><ul><li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li><li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</li></ul><div class="note note-primary">            <p>注意这个sk_buff</p>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
