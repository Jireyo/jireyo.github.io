<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法专题（SQL）</title>
    <link href="/2023/04/30/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88SQL%EF%BC%89/"/>
    <url>/2023/04/30/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88SQL%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、表达式规则"><a href="#一、表达式规则" class="headerlink" title="一、表达式规则"></a>一、表达式规则</h1><p><em>等于</em></p><ul><li>任何值与NULL比较都返回<code>NULL</code>，而不是<code>1</code>或<code>0</code></li><li>不等于：<code>!=</code> 或 <code>&lt;&gt;</code></li><li>安全等于：<code>&lt;=&gt;</code>，两个值都为NULL时返回1，一个值为NULL时返回0</li></ul><p><em>其他</em></p><ul><li><code>between a and b</code>，是一个闭合区间</li></ul><p><em>分组</em></p><ul><li><code>group</code>会将所有null值视为同一项</li></ul><p><em>count</em></p><ul><li><code>count(列名)</code>不统计该列为null的记录</li><li><code>count(distinct 列名)</code>可以去重</li><li><code>count(1)与count( * )</code>包含null的记录</li><li>条件写法：<ul><li>性质：<code>count(任意数) = 1</code>，<code>count(NULL)=0</code></li><li>条件计数：<code>count(布尔表达式 or null) = count(if(布尔表达式,1,null)) = sum(布尔表达式)</code></li><li>条件比例：<code>avg(布尔表达式) = sum(布尔表达式)/count(1)</code></li><li>条件统计：<code>sum(if(条件,列名,0))</code></li></ul></li></ul><blockquote><p>count执行速度区别：</p><ul><li>速度上：<code>count(主键)&gt;count(1)≈count(*)&gt;count(其他列)</code></li><li>无主键时：<code>count(1)&gt;count(*)</code></li><li>只有一个字段时：<code>count(*)&gt;count(1)</code></li></ul></blockquote><p><em>if</em></p><ul><li><code>if(条件,表达式1,表达式2)</code>，根据条件为1或0取值</li><li><code>ifnull(表达式1,表达式2)</code>，如果表达式1&#x3D;null，返回表达式2，否则返回表达式1</li><li><code>nullif(表达式1,表达式2)</code>，如果表达式1&#x3D;表达式2，返回null，否则返回表达式1</li><li><code>isnull(表达式1)</code>，表达式1为null时返回1，否则返回0</li></ul><p><em>union</em></p><ul><li>union用于合并多个select的结果，会合并重复项</li><li>union all不会合并重复项</li></ul><p><em>join</em></p><ul><li>cross join就是笛卡尔积，使用on则从该结果集中筛选满足条件的连接行</li><li>full join可以保证连接同时保留不满足条件的连接行，但mysql中不支持，可以通过left join、union、right join三步实现替换</li></ul><p><em>group_concat</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 例子</span><br><span class="hljs-keyword">select</span><br>    sell_date,<br>    <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> product) num_sold,<br>    group_concat(<br>        <span class="hljs-keyword">distinct</span> product<br>        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> product<br>        separator <span class="hljs-string">&#x27;,&#x27;</span><br>    ) products<br><span class="hljs-keyword">from</span> <br>    Activities<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sell_date<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sell_date<br></code></pre></td></tr></table></figure><h1 id="二、语句结构处理"><a href="#二、语句结构处理" class="headerlink" title="二、语句结构处理"></a>二、语句结构处理</h1><p><em>子查询与交叉连接</em></p><ul><li>一般都用于要在本表中找到分组中某列最大的一条记录，子查询和交叉连接在此处都是可以的，两者区别在于：</li><li>子查询是先查询筛选再连接，需要考虑子查询出的记录数量决定语句编写逻辑，交叉连接则先连接再筛选。</li></ul><p><em>隐式交叉连接</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> O.ID, O.ORDER_NUMBER, C.ID, C.NAME<br><span class="hljs-keyword">FROM</span> ORDERS O , CUSTOMERS C<br><span class="hljs-keyword">WHERE</span> O.ID<span class="hljs-operator">=</span>C.ID;<br></code></pre></td></tr></table></figure><p><em>虚拟表</em><br>可以用于枚举不存在于表中的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">with</span> a <span class="hljs-keyword">as</span> (<br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;High Salary&#x27;</span> category<br><span class="hljs-keyword">union</span> <br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Low Salary&#x27;</span><br><span class="hljs-keyword">union</span> <br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Average Salary&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="三、API"><a href="#三、API" class="headerlink" title="三、API"></a>三、API</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p><em>小数处理</em></p><ul><li>round(数值，保留小数位数)，返回浮点数</li><li>format(数据或字符串，格式)，可以用于格式化日期和小数，处理小数时用法同round，但返回的是字符串</li></ul><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p><em>日期差</em></p><ul><li>datediff(日期1,日期2)，返回整数天</li><li>timestampdiff(单位,时间1,时间2)，可以额外指定时间差的单位</li></ul><p><em>日期计算</em></p><ul><li>date(日期+1)，加一天，这种用法额外要求日期数据类型为date，不可为字符串，其他函数不受限制</li><li>date_add(日期,interval 1 day)，加1天</li><li>date_sub(日期,interval 1 day)，减1天</li></ul><p><em>变量</em></p><ul><li>赋予初值：<code>SELECT @pre := 0</code></li><li>操作：<code>@pre := @pre+1</code></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><em>正则表达式</em><br><a href="https://www.runoob.com/mysql/mysql-regexp.html">菜鸟</a></p><ul><li>用法：<code>WHERE str REGEXP &#39;正则表达式&#39;;</code></li><li>注意：空格可以用<code>\s</code>表示，但mysql也要一个<code>\</code>，所以使用<code>\\s</code>表示空格。</li></ul><p><em>字符串拼接</em><br><code>concat(str1,str2,...)</code></p><p><em>字符串截取</em></p><ul><li>截取左端：<code>left(str,int)</code></li><li>截取右端：<code>right(str,int)</code></li></ul><p><em>字符串大小写</em></p><ul><li>大写：<code>UPPER(str)</code></li><li>小写：<code>LOWER(str)</code></li></ul><h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p><em>用法</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">[你要的操作] <span class="hljs-keyword">OVER</span> ( <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span>  <span class="hljs-operator">&lt;</span>用于分组的列名<span class="hljs-operator">&gt;</span><br>                    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>按序叠加的列名<span class="hljs-operator">&gt;</span> <br>                    <span class="hljs-keyword">ROWS</span> <span class="hljs-operator">&lt;</span>窗口滑动的数据范围<span class="hljs-operator">&gt;</span> )<br></code></pre></td></tr></table></figure><p><em>滑动窗口数据范围</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">当前行 <span class="hljs-operator">-</span> <span class="hljs-keyword">current</span> <span class="hljs-type">row</span><br>之前的行 <span class="hljs-operator">-</span> preceding<br>之后的行 <span class="hljs-operator">-</span> following<br>无界限 <span class="hljs-operator">-</span> unbounded<br>表示从前面的起点 <span class="hljs-operator">-</span> unbounded preceding<br>表示到后面的终点 <span class="hljs-operator">-</span> unbounded following<br><br>例子：<br><span class="hljs-keyword">ROWS</span> <span class="hljs-number">6</span> preceding <span class="hljs-comment">--当前行和前6行，共7行</span><br><span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">between</span> <span class="hljs-number">6</span> preceding <span class="hljs-keyword">and</span> <span class="hljs-keyword">current</span> <span class="hljs-type">row</span> <span class="hljs-comment">--同上</span><br><span class="hljs-keyword">ROWS</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> preceding <span class="hljs-keyword">and</span> <span class="hljs-number">5</span> folowing <span class="hljs-comment">--前后5行加当前行，共11行</span><br></code></pre></td></tr></table></figure><h1 id="四、例题"><a href="#四、例题" class="headerlink" title="四、例题"></a>四、例题</h1><p><a href="https://leetcode.cn/problems/game-play-analysis-iv/">550. 游戏玩法分析 IV</a><br>分析问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Write your MySQL query statement below<br><span class="hljs-comment">-- 注册日记录</span><br><span class="hljs-comment">-- select player_id,min(event_date) from activity group by player_id</span><br><br><span class="hljs-comment">-- 筛选第二天记录，发现注册日记录可以顺便统计总数：</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-built_in">count</span>(a1.games_played<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">null</span>)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),<span class="hljs-number">2</span>) fraction<br><span class="hljs-keyword">from</span> activity a1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span><br> (<span class="hljs-keyword">select</span> player_id,<span class="hljs-built_in">min</span>(event_date) event_date <span class="hljs-keyword">from</span> activity <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> player_id) a2<br><span class="hljs-keyword">on</span> a1.event_date <span class="hljs-operator">=</span> <span class="hljs-type">date</span>(a2.event_date<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br><span class="hljs-keyword">and</span> a1.player_id <span class="hljs-operator">=</span> a2.player_id;<br><br><span class="hljs-comment">-- 也可以不使用join加count(条件)，而是使用where</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>)<span class="hljs-operator">/</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> player_id) <span class="hljs-keyword">from</span> activity),<span class="hljs-number">2</span>) fraction<br><span class="hljs-keyword">from</span> activity a1 <br><span class="hljs-keyword">where</span> (player_id,event_date) <span class="hljs-keyword">in</span> (<br>    <span class="hljs-keyword">select</span> player_id,<span class="hljs-type">date</span>(<span class="hljs-built_in">min</span>(event_date)<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">from</span> activity <br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> player_id<br>)<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/last-person-to-fit-in-the-bus/">1204. 最后一个能进入电梯的人</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 自连接写法，有点类似交叉连接后筛选</span><br><span class="hljs-keyword">SELECT</span> a.person_name<br><span class="hljs-keyword">FROM</span> Queue a, Queue b<br><span class="hljs-keyword">WHERE</span> a.turn <span class="hljs-operator">&gt;=</span> b.turn<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.person_id <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">SUM</span>(b.weight) <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.turn <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">1</span><br><br><br><span class="hljs-comment">-- 变量写法，在from中赋初值，select中迭代</span><br><span class="hljs-keyword">SELECT</span> a.person_name<br><span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> person_name, <span class="hljs-variable">@pre</span> :<span class="hljs-operator">=</span> <span class="hljs-variable">@pre</span> <span class="hljs-operator">+</span> weight <span class="hljs-keyword">AS</span> weight<br><span class="hljs-keyword">FROM</span> Queue, (<span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@pre</span> :<span class="hljs-operator">=</span> <span class="hljs-number">0</span>) tmp<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> turn<br>) a<br><span class="hljs-keyword">WHERE</span> a.weight <span class="hljs-operator">&lt;=</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.weight <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/restaurant-growth/">1321. 餐馆营业额变化增长</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 滑动窗口<br># 过滤最早的<span class="hljs-number">6</span>天<br><span class="hljs-keyword">SELECT</span> visited_on,amount,average_amount<br><span class="hljs-keyword">FROM</span> (<br>    #统计每个日期及其前<span class="hljs-number">6</span>个日期的消费量<br>    <span class="hljs-keyword">SELECT</span> visited_on,<br>           <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> visited_on <span class="hljs-keyword">ROWS</span> <span class="hljs-number">6</span> PRECEDING) <span class="hljs-keyword">AS</span> amount,<br>           ROUND(<span class="hljs-built_in">AVG</span>(amount)<span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> visited_on <span class="hljs-keyword">ROWS</span> <span class="hljs-number">6</span> PRECEDING),<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> average_amount<br>    <span class="hljs-keyword">FROM</span> (<br>        #先统计每日消费量<br>        <span class="hljs-keyword">SELECT</span> visited_on,<span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> amount<br>        <span class="hljs-keyword">FROM</span> Customer<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> visited_on<br>    ) TABLE_1<br>) TABLE_2<br><span class="hljs-keyword">WHERE</span> DATEDIFF(visited_on,(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(visited_on) <span class="hljs-keyword">FROM</span> Customer)) <span class="hljs-operator">&gt;=</span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/department-top-three-salaries/">185. 部门工资前三高的所有员工</a><br>top n问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 连接员工与部门<br><span class="hljs-keyword">select</span> d.name department,e1.name employee,e1.Salary Salary<br><span class="hljs-keyword">from</span> employee e1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> department d<br><span class="hljs-keyword">on</span> e1.departmentId <span class="hljs-operator">=</span> d.id<br># 公司里前 <span class="hljs-number">3</span> 高的薪水意味着有不超过 <span class="hljs-number">3</span> 个工资比这些值大。<br><span class="hljs-keyword">where</span> <span class="hljs-number">3</span> <span class="hljs-operator">&gt;</span> (<br>    # 获取同部门中，比e1的薪水高的薪水种类，如果小于<span class="hljs-number">3</span>则说明e1为前<span class="hljs-number">3</span><br>    <span class="hljs-keyword">SELECT</span><br>        <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> e2.Salary)<br>    <span class="hljs-keyword">FROM</span><br>        Employee e2<br>    <span class="hljs-keyword">WHERE</span><br>        e2.Salary <span class="hljs-operator">&gt;</span> e1.Salary <span class="hljs-keyword">AND</span> e1.DepartmentId <span class="hljs-operator">=</span> e2.DepartmentId<br>)<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/second-highest-salary/">176. 第二高的薪水</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ifNull(<br>    (<br>    <span class="hljs-keyword">select</span> e1.salary<br>    <span class="hljs-keyword">from</span> Employee e1,Employee e2<br>    <span class="hljs-keyword">where</span> e1.salary<span class="hljs-operator">&lt;</span>e2.salary<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> e1.salary<br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> e2.salary) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    )<br>,<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">as</span> SecondHighestSalary;<br><br><span class="hljs-comment">-- 另解</span><br><span class="hljs-keyword">select</span> ifNull((<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> salary<br><span class="hljs-keyword">from</span> Employee <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Salary <span class="hljs-keyword">Desc</span><br>limit <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">as</span> SecondHighestSalary;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/delete-duplicate-emails/">196. 删除重复的电子邮箱</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> p1 <span class="hljs-keyword">FROM</span> Person p1,<br>    Person p2<br><span class="hljs-keyword">WHERE</span><br>    p1.Email <span class="hljs-operator">=</span> p2.Email <span class="hljs-keyword">AND</span> p1.Id <span class="hljs-operator">&gt;</span> p2.Id<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-users-with-valid-e-mails/">1517. 查找拥有有效邮箱的用户</a><br>正则表达式</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、硬件结构"><a href="#一、硬件结构" class="headerlink" title="一、硬件结构"></a>一、硬件结构</h1><h2 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h2><p><em>图灵机</em><br>栈式读取操作数和操作指令并执行</p><p><em>冯诺依曼模型</em><br>组成：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp"></p><p><em>内存</em><br>以字节byte为单位的存储空间，从0开始编号。</p><p><em>CPU</em><br>包括控制单元、寄存器（包括通用寄存器、程序计数器、指令寄存器）、逻辑运算单元。32位CPU一次计算4字节，64位CPU一次计算8字节，对于小数字而言，64位和32位的运算速度接近。</p><p><em>总线</em><br>当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：</p><ul><li>首先要通过「地址总线」来指定内存的地址；</li><li>然后通过「控制总线」控制是读或写命令；</li><li>最后通过「数据总线」来传输数据；</li></ul><p><em>线路位宽</em></p><ul><li>地址总线的条数（线路位宽）决定了指定一个内存地址需要在地址总线上进行几次传输。</li><li>CPU的位宽应该不小于线路位宽，否则其无法操作所有内存。</li><li>32位CPU最大操作4GB内存，64位CPU最大寻址空间为<code>2^64</code>。</li></ul><p><em>程序执行过程</em></p><ol><li>程序计数器：存储了指令的内存地址（硬件位宽指CPU的位宽，软件位宽指的是指令的位宽，两者相等才能正常运作）。</li><li>控制单元：操作地址总线指定指令的内存地址，通过数据总线获取指令，将指令存储到指令寄存器中，程序计数器自增。</li><li>CPU：分析指令寄存器中指令：计算类将给逻辑运算单元处理；读写类交给控制单元处理。</li></ol><p><em>指令周期</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/CPU%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.webp"><br>获取指令-&gt;指令译码(控制单元完成)-&gt;执行指令(算数逻辑单元完成)-&gt;数据回写</p><p><em>指令执行速度</em><br>时钟周期是CPU执行时间的基本单位，执行时间：<br><code>CPU执行时间 = 指令数 * CPI(平均每个指令的周期数) * 时钟周期</code></p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><em>结构</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/CPU-Cache.webp"></p><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.webp"><br>访问内存数据时，逐层查看是否有缓存。</p><p><em>内存</em><br>DRAM （_Dynamic Random Access Memory_，动态随机存取存储器），基于电容，需要不断刷新才能存储数据。</p><p><em>SSD&#x2F;HDD硬盘</em></p><ul><li>SSD固体硬盘，结构与内存类似，比HDD快。</li><li>HHD机械硬盘，传统结构，速度很慢。</li></ul><h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>CPU Cache是内存体系中的组成部分，但硬件上属于CPU。<br><em>Cache与内存的映射</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%B1%82%E6%A8%A1%E6%98%A0%E5%B0%84%E7%AD%96%E7%95%A5.webp"><br>内存块(Block)会按照地址求模映射到Cache Line上。</p><p><em>结构</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%9B%B4%E6%8E%A5Cache%E6%98%A0%E5%B0%84.webp"></p><ul><li>有效位：本记录是否有效；</li><li>组标记：记录本CacheLine当前记录的Block；</li><li>实际数据：内存块的数据缓存。</li></ul><blockquote><p>CPU读取数据时，需要以块为单位将内存加载到缓存，但不需要读取整个块，所以还会指定偏移量。</p></blockquote><p><em>如何提高CPU速度？</em></p><ul><li>提高数据缓存命中率：尽量访问连续内存，如顺序访问数组。</li><li>提高指令缓存命中率：CPU有分支预测器，如果某条件判断的跳转大概率成立，则会缓存跳转后的相关指令。</li><li>提高多核CPU命中率：一个用户线程绑定在一个CPU核心上，防止切换CPU对缓存命中率的影响。</li></ul><h4 id="CPU-Cache一致性"><a href="#CPU-Cache一致性" class="headerlink" title="CPU Cache一致性"></a>CPU Cache一致性</h4><p><em>两种同步方案</em></p><ul><li>写直达(Write Through)：把数据同时写入内存和 Cache 中</li><li>写回(Write Back)：只把数据写入Cache Block中（标记为脏块），当其被替换时，才写回内存。</li></ul><p><em>缓存一致性问题</em><br>CPU的不同核心同时对相同的内存块进行操作。</p><p><em>需要解决的问题</em><br>要解决缓存一致性，需要解决两个问题：</p><ul><li>写传播（可见性）：某CPU写内存后对其他CPU可见。</li><li>事物串行化（有序性）：其他CPU收到的写传播顺序与原CPU写入顺序一致。</li></ul><p><em>总线嗅探</em><br>某CPU修改内存数据后，通过总线广播到其他CPU，实现了<strong>写传播</strong>。</p><p><em>MESI协议</em><br>概念：Cache Line具有4种状态（Modified、Exclusive、Shared、Invalidated）。<br>工作原理：</p><ul><li>某CPU核心读取内存后为Cache Line独占模式</li><li>此时其他CPU也读取相同内存，对应得Cache Line都变成共享模式。</li><li>某CPU要对共享模式的Cache Line写入时，将其他CPU的Cache Line标记为无效，然后再更新。</li></ul><p><em>伪共享问题</em></p><ul><li>定义：由于Cache是以块为单位读取的，会出现两个线程操作同一个块中不同的变量却导致彼此反复失效的情况，严重消耗性能。</li><li>解决：为变量后面填充空白，使2个相邻变量其在内存中位于不同的Block。</li></ul><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p><em>十进制与二进制</em><br>十进制转二进制：小数使用乘2取整法，可能会产生无限循环的二进制表达，但计算机位数有限，造成了精度损失。</p><p><em>浮点数的存储</em><br>默认整数部分为1，且省略。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/float.webp"></p><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>磁盘调度算法：</p><ul><li>先来先服务：寻找最早请求的扫描点，效率低下；</li><li>最短寻道时间优先算法：寻找距离当前磁头最近的扫描点，折返的无效路径较多；</li><li>扫描算法：往一个方向访问完到终点后转头，效率高，但中间部分扫描频率更高；</li><li>循环扫描算法：总是从同一个方向开始扫描，解决扫描算法响应频率不均匀的问题，但效率会低一些；</li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-SCAN%E7%AE%97%E6%B3%95.webp"></p><ul><li>LOOK与C-LOOK算法：优化了扫描和循环扫描算法，即不需要扫描到终点，只扫描到最远处的请求即转向。</li></ul><h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Kernel_Layout.webp"><br>操作系统内核是应用连接硬件设备的桥梁。</p><p><em>内存空间</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/systemcall.webp"><br>操作系统将内存分为了用户空间和系统空间，当程序使用用户空间时，称程序在<strong>用户态</strong>执行，当程序使用内核空间时，程序在<strong>内核态</strong>执行。</p><p><em>Linux 内核设计的理念</em></p><ul><li>MultiTask，多任务。支持并发、并行。</li><li>SMP，对称多处理。即每个CPU地位相等。</li><li>ELF，可执行文件链接格式。</li><li>Monolithic Kernel，宏内核。即系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li></ul><p><em>Window 内核设计的理念</em></p><ul><li>MultiTask和SMP</li><li>PE，可移植执行文件。</li><li>Mix Kernel，混合内核。即内核中有一个微内核，其他模块在这个微内核的基础上搭建，一起组成整个内核。</li></ul><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><em>概念</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/72ab76ba697e470b8ceb14d5fc5688d9.webp"></p><ul><li>程序所使用的内存地址叫做虚拟内存地址</li><li>硬件所使用的空间地址叫做物理内存地址</li><li>MMU（内存管理单元负责虚拟内存地址和物理内存地址的映射）</li></ul><p><em>映射方式</em></p><ul><li>内存分段</li><li>内存分页</li></ul><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/a9ed979e2ed8414f9828767592aadc21.webp"></p><ul><li>段选择因子：确定了段描述符，可以得到段的元信息。</li><li>段内偏移量：确定了地址在段内的偏移量</li></ul><p><em>内存分段的问题</em></p><ul><li>存在外部内存碎片：<ul><li>分段做到了按需求分配内存，<strong>不会出现内部内存碎片</strong>。</li><li>段之间<strong>存在外部内存碎片</strong>。可以使用内存交换，通过挂起后唤醒程序的方式调整。</li></ul></li><li>内存交换效率低：内存空间不足时，需要将段换出到硬盘上，频繁的swap会导致效率低下。</li></ul><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/7884f4d8db4949f7a5bb4bbd0f452609.webp"><br>当进程访问<strong>页表</strong>中查不到的虚拟地址时，产生<strong>缺页异常</strong>，会进入物理地址分配物理内存并更新<strong>页表</strong>。</p><p><em>缺页异常</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.webp"></p><p><em>内存分页的问题</em></p><ul><li>存在<strong>内部内部碎片</strong><ul><li>页与页之间紧密排列，<strong>不会出现外部碎片</strong>。</li><li>页是最小的内存分配单元，可能造成浪费，即<strong>内部内存碎片</strong>。</li></ul></li><li>内存交换效率高：内存空间不足时，每次只会把其他允许进程中最近没有被使用的少数内存页面换出到硬盘上。</li></ul><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>简单分页会导致页表过于庞大。因此引入多级页表。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/19296e249b2240c29f9c52be70f611d5.webp"></p><ul><li>多级页表中，一级页表映射了全部虚拟地址。</li><li>对于没有使用的一级页表，可以不创建其对应的二级页表，从而实现页表空间的节省。</li></ul><p><em>64位系统</em></p><ul><li>全局页目录项 PGD（Page Global Directory）；</li><li>上层页目录项 PUD（Page Upper Directory）；</li><li>中间页目录项 PMD（Page Middle Directory）；</li><li>页表项 PTE（Page Table Entry）；<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.webp"></li></ul><p><em>TLB</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/a3cdf27646b24614a64cfc5d7ccffa35.webp"><br>为了解决多级页表访问速度慢的问题，加入了TLB（Translation Lookaside Buffer），常称为页表缓存。CPU寻址时，先搜索TLB，找不到再搜索页表。</p><h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>将内存先划分成有意义的段，然后按页分配。地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/8904fb89ae0c49c4b0f2f7b5a0a7b099.webp"></p><h3 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h3><p><em>Intel处理器内存</em><br>历史问题：先有段式内存管理，后续的页式管理就只能基于这个段式上做映射。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/bc0aaaf379fc4bc8882efd94b9052b64.webp"></p><p><em>Linux内存</em><br>页式管理：为了屏蔽段式管理，每个段都是0-&gt;4GB的整个虚拟空间。</p><p><em>虚拟地址空间分布</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.webp"><br>所有进程虚拟地址空间中的内核空间关联了相同的物理内存：<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/48403193b7354e618bf336892886bcff.webp"></p><p><em>用户空间的段分布</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.webp"></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><em>malloc分配内存</em><br>malloc函数有两种方式申请<strong>虚拟内存</strong>，申请后访问时出现缺页中断才会申请<strong>物理内存</strong>：</p><ul><li>brk()从堆中分配内存</li><li>mmap()在文件映射区中分配内存</li></ul><p>malloc(1)</p><p><em>free()释放内存</em></p><ul><li>brk()申请的内存：free释放内存时，会将内存缓存在内存池中以便复用，进程退出后才释放。</li><li>mmap()申请的内存：free释放内存时直接归还资源给操作系统。</li><li>内存块头信息：每个内存块有16Byte记录头信息，因此free时知道需要释放多少内存。</li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/cb6e3ce4532ff0a6bfd60fe3e52a806e.webp"></p><p><em>mmap()的缺点</em><br>mmap会对操作系统频繁的申请、释放内存。频繁的缺页中断和切换运行态，对CPU造成了较大的消耗。</p><p><em>brk()的缺点</em><br>free释放的内存不归还操作系统，造成内存碎片。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/75edee0cb75450e7987a8a482b975bda.webp"></p><p><em>申请超过物理内存的虚拟内存</em></p><ul><li>32位：进程理论最大申请3GB虚拟内存，超出则申请失败。</li><li>64位：不会受理论最大空间限制。如果访问超出物理内存的虚拟内存，要看系统有没有 Swap 分区：<ul><li>如果没有 Swap 分区，OOM杀死进程。</li><li>如果有 Swap 分区，正常运行。</li></ul></li></ul><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p><em>申请内存过程</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/2f61b0822b3c4a359f99770231981b07.webp"></p><p><em>内存阈值</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/166bc9f5b7c545d89f1e36ab8dd772cf.webp"></p><ul><li>超过页低阈值时开始异步回收</li><li>超过最小阈值时直接回收</li></ul><p><em>回收哪些内存</em></p><ul><li>文件页：直接释放，需要时再从磁盘读即可</li><li>匿名页：Swap机制，将内存换入磁盘</li></ul><p><em>回收算法</em><br>使用了<strong>LRU算法</strong>，维护了active和inactive两个双向链表，优先淘汰inactive。</p><p><em>回收性能消耗</em><br>文件页回收时脏页的写回、匿名页回收时的Swap操作都有较大的内存消耗。</p><p><em>回收性能优化</em></p><ul><li>调整文件页和匿名页的回收倾向，如多回收文件页，这样干净的文件页就不需要磁盘IO。</li><li>尽早触发kswapd异步回收内存，如调整页低阈值。</li></ul><p><em>NUMA架构</em></p><ul><li>一致性存储访问UMA架构：所有CPU共享硬件（总线、内存、IO等），导致CPU数量变多时，每个CPU资源变少。</li><li>非一致性存储访问NUMA架构：CPU分组，每组为一个Node，一个Node独立拥有硬件资源，访问远端资源时比本地内存耗时。</li></ul><p><em>NUMA架构下的垃圾回收</em><br>垃圾回收策略zone_reclaim_mode：</p><ul><li>0（默认）：回收本地内存前，在其他Node中寻找空闲内存。</li><li>1：只回收本地内存。</li><li>2：只回收本地内存，回收脏页。</li><li>4：只回收本地内存，回收匿名页</li></ul><p><em>OOM</em><br>OOM会对进程打分，因素有：</p><ul><li>内存使用的物理内存页面</li><li>OOM分数<code>oom_score_adj</code>，默认为0，范围-1000~1000。</li></ul><p>为了防止进程被OOM杀死，可调节其<code>oom_score_adj</code>为-1000，但不建议这样做。</p><h2 id="页面置换调度算法"><a href="#页面置换调度算法" class="headerlink" title="页面置换调度算法"></a>页面置换调度算法</h2><p><em>页面置换</em><br>页面置换算法指的是：解决当出现缺页异常，需调入新页面而内存已满时，如何选择被置换的物理页面的问题。为了实现页面置换算法，页表项有一些相关字段：<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.webp"></p><ul><li>状态位：是否是有效页</li><li>访问字段：一段时间内的被访问次数</li><li>修改位：是否为脏页</li><li>硬盘地址：页在硬盘上的地址</li></ul><p><em>最佳页面置换算法</em><br>置换在「未来」最长时间不访问的页面。是理想状态，但无法实现。</p><p><em>先进先出置换算法</em><br>选择在内存驻留时间很长的页面进行中置换。性能较差。</p><p><em>最近最久未使用的置换算法</em><br>LRU算法，理论上可行，但链表更新的时间复杂度较高，不常用。</p><p><em>时钟页面置换算法</em><br>与LRU类似，但更方便实现。优先置换访问频率低的页面，否则对页的访问频率计数降级。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.webp"></p><p><em>最不常用算法</em><br>LRU算法，当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。这种方法需要对计数做热点衰减以实现模拟近期的频率。</p><h3 id="Linux-内存页面置换"><a href="#Linux-内存页面置换" class="headerlink" title="Linux 内存页面置换"></a>Linux 内存页面置换</h3><p>Linux使用了双LRU链表实现页面置换算法，并对其做了一些优化。</p><p><em>预读失效和缓存污染</em><br>内存预读的目的是提高效率，但其可能造成预读失效和缓存勿污染，导致命中率下降。</p><p><em>预读失效</em></p><ul><li>定义：使用预读提前加载进来的页并没有被访问。</li><li>解决：没有被真正使用的页应该被视为冷数据：<ul><li>Linux使用了活跃LRU链表和非活跃LRU链表。</li><li>Mysql将LRU链表分为了young区和old区</li></ul></li></ul><p><em>缓存污染</em></p><ul><li>定义：只使用了一次的页占用热数据。</li><li>解决：降低热数据的门槛：<ul><li>Linux只有数据被访问第二次时才加入活跃链表。</li><li>Mysql只有数据两次访问时间之差<strong>超过1秒</strong>时才加入young区</li></ul></li></ul><h1 id="四、进程管理"><a href="#四、进程管理" class="headerlink" title="四、进程管理"></a>四、进程管理</h1><h2 id="进程、线程与调度"><a href="#进程、线程与调度" class="headerlink" title="进程、线程与调度"></a>进程、线程与调度</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><em>进程七态模型</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.webp"><br>为了避免阻塞的进程浪费物理内存，将其换出到硬盘，运行时再换回。</p><p><em>进程控制块PCB组成</em></p><ul><li>进程描述信息（pid，userid）</li><li>进程控制和管理信息（状态、优先级）</li><li>资源分配（内存地址空间信息）</li><li>CPU寄存信息</li></ul><p><em>进程控制块PCB组织</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.webp"></p><p><em>进程的控制</em><br>进程的控制主要包括<strong>创建、终止、阻塞、唤醒</strong>。具体的过程总结下来就是：</p><ul><li>查找&#x2F;创建PCB</li><li>判断PCB状态，根据指令改变进程状态。</li><li>申请&#x2F;释放资源</li><li>删除&#x2F;移动PCB</li></ul><p><em>进程上下文切换</em><br>进程阻塞或时间片用完等情况时需要切换线程，此时会把CPU上下文（寄存器和程序计数器）保存到PCB中，下次运行时恢复。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><em>定义</em><br>线程是进程当中的一条执行流程。</p><p><em>进程与线程对比</em></p><ul><li>进程是资源分配的单位，线程是CPU调度的单位。</li><li>进程信息只有寄存器和栈，创建、释放、上下文切换更快速。</li><li>线程之间通过同一个进程的内存实现数据共享。</li></ul><p><em>线程实现</em></p><ul><li>用户线程：多对一，用户空间实现线程管理TCB</li><li>内核线程：一对一，线程TCB由操作系统管理</li><li>轻量级进程：内核支持的用户线程，与内核线程一对一</li></ul><p><em>各种线程实现的注意点</em></p><ul><li>用户线程不需要切换内核态调度，但可能阻塞饿死其他线程。内核线程相反。</li><li>用户线程可以在轻量级进程上再实现M：N的线程对应模型。</li></ul><p><em>一个进程可以创建多少线程</em><br>进程需要为线程在虚拟内存空间中创建栈空间：</p><ul><li>32位：主要受线程的栈空间大小和<strong>用户态虚拟内存空间</strong>（Linux下为3G）大小的限制。</li><li>64位：虚拟内存足够，主要受系统参数和性能的限制。</li></ul><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p><em>需要调度的情况</em></p><ul><li>线程就绪态 -&gt; 运行态</li><li>线程运行态 -&gt; 阻塞态</li><li>线程运行态 -&gt; 结束态</li><li>其他优先级等因素导致的调度</li></ul><p><em>时钟中断</em><br>以某个时间频率检查进程状态，考虑是否调度CPU资源。<br>根据是否使用时钟中断，调度算法分：</p><ul><li>非抢占式调度算法：让进程运行到阻塞或退出再调度。</li><li>抢占式调度算法：触发时钟中断，然后将CPU资源给调度程序，执行调度程序后再给进程分配CPU程序。</li></ul><p><em>调度相关指标</em></p><ul><li>CPU利用率：CPU工作时间&#x2F;总时间</li><li>系统吞吐量：单位时间CPU完成的进程数量</li><li>进程周转时间：运行+阻塞+等待的时间</li><li>等待时间：进程处于就绪态的时间</li><li>响应时间：用户请求到返回的时间</li></ul><p><em>调度算法</em><br>针对长、短作业：</p><ul><li>先来先服务FCFS：对长作业有利，但短作业等待时间太久。</li><li>最短作业优先SJF：对短作业有利，但长作业饿死。</li><li>高响应比优先HRRN：平衡长、短作业。但要求服务时间无法预估，其无法实现。</li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.webp"></p><ul><li>时间片轮转RR：时间上公平。但时间片太短会造成上下文切换频繁资源浪费，太长则短作业浪费CPU资源。</li></ul><p>引入优先级：</p><ul><li>最高优先级HPF：优先级分静态优先级和动态优先级（进程优先级随等待时间变化），处理分非抢占式和抢占式。但低优先级一直得不到执行。</li><li>多级反馈队列MFQ：设置多级的就绪队列，高优先级作业获得执行后若梅结束会降低优先级，低优先级作业能获得更多的时间片。兼顾了长短作业，短作业在前面的队列即完成执行，长作业也可以获得更长的运行时间。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.webp"></li></ul><h2 id="Linux-CPU调度"><a href="#Linux-CPU调度" class="headerlink" title="Linux CPU调度"></a>Linux CPU调度</h2><p>Linux的CPU调度方式类似多级反馈队列算法：分实时作业和普通作业，实现优先级；根据进程已经获得的执行时间动态调节其优先级，保证公平。<br><em>线程调度</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%BB%BB%E5%8A%A1.webp"><br>所有线程在Linux调度器中都是一个task_struct。</p><p><em>任务分类</em></p><ul><li>实时任务：优先级0-99范围。</li><li>普通任务：优先级100-129范围。</li></ul><p><em>调度类</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%B0%83%E5%BA%A6%E7%B1%BB.webp"></p><p><em>调度策略</em><br>DeadLine和RT调度器用于实时任务，调度策略：</p><ul><li>SCHED_DEADLINE：按照deadline优先级调度。</li><li>SCHED_FIFO：优先级高的先服务，相同优先级先到先服务。</li><li>SCHED_RR：高优先级的任务可以抢夺低优先级任务的时间，相同优先级的任务轮流执行。</li></ul><p>Fair调度类用于普通任务，调度策略：</p><ul><li>SCHED_NORMAL：普通任务使用的调度策略。</li><li>SCHED_BATCH：后台任务的调度策略。</li></ul><p><em>完全公平调度</em><br>CFS调度器会通过计算vruntime保证任务公平，优先执行vruntime少的任务：<br>vruntime +&#x3D; 实际运行时间delta_exec * NICE_0_LOAD&#x2F;权重</p><p><em>CPU运行队列</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/CPU%E9%98%9F%E5%88%97.webp"><br>优先级如下：Deadline &gt; Realtime &gt; Fair</p><p><em>默认优先级</em><br>默认情况下，任务都是普通任务，调度类为Fair，若想要调整任务优先级，可以启动时指定nice值。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%BC%98%E5%85%88%E7%BA%A7.webp"></p><p><em>中断</em><br>从调度的角度，中断是一种抢占性的任务调度行为；从程序的角度，中断是一种异步的事件处理机制，操作系统收到了中断请求，会打断其他进程的运行，并执行中断处理程序。</p><p><em>软中断</em><br>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p><ul><li>上半部分处理硬件请求（硬中断）：短暂关闭中断请求，立即执行中断处理程序。</li><li>下半部分由内核触发（软中断）：使用内核线程ksoftirqd延迟处理中断回调函数。</li></ul><h2 id="进程之间的通讯方式"><a href="#进程之间的通讯方式" class="headerlink" title="进程之间的通讯方式"></a>进程之间的通讯方式</h2><p><em>管道</em></p><ul><li>单向传输</li><li>命名管道<code>mkfifo</code>保存在文件中、匿名管道保存在内存中。本质上就是内存中的一串缓存。</li><li>会阻塞直到管道内容被读取</li><li>匿名管道只能在父子关系的进程中通过共享文件描述符的方式通讯，eg:shell中使用<code>A|B</code>：</li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/8-%E7%AE%A1%E9%81%93-pipe-shell.webp"></p><p><em>消息队列</em></p><ul><li>异步，但通讯不及时</li><li>大小有限制，本质上是内核中的消息链表、</li><li>存在内核态切换开销</li></ul><p><em>共享内存</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.webp"></p><p><em>信号量</em></p><ul><li>整形计数器，支持P、V操作。<ul><li>P操作：-1，发现≥0后执行，否则阻塞。</li><li>V操作：+1，发现≤0后唤醒阻塞线程。</li></ul></li><li>初始化为1可实现互斥（先P后V），初始化为0可实现序列化（先V后P）</li></ul><p><em>信号</em><br><code>kill -?</code><br>进程间<strong>唯一的异步通讯机制</strong>，进程对接受到的信号可执行默认操作，也可以捕捉处理信号。（SIGKILL和SIGSTOP无法被捕捉忽略，即强制结束或中断）</p><blockquote><p>线程崩溃了，进程会崩溃吗？<br>不一定，崩溃本身是系统通过信号通知进程执行退出的过程。如Java对部分信号如SIGSEGV进行了捕获，不会直接退出整个JVM。</p></blockquote><p><em>Socket</em><br>实现跨网络和主机的进程通讯，系统调用参数有：</p><ul><li>协议：IPV4、IPV6或本地等（本地socket不需要绑定ip和端口，而是绑定本地文件，效率比网络socket高。）。</li><li>类型：UDP、TCP等。</li><li>协议：默认0，已经废弃。</li></ul><h2 id="线程冲突与死锁"><a href="#线程冲突与死锁" class="headerlink" title="线程冲突与死锁"></a>线程冲突与死锁</h2><p><em>互斥与同步的定义</em></p><ul><li>互斥：临界区代码是互斥的，只允许一个线程在临界区执行。</li><li>同步：并发线程在某些时间点要形成互相等待与互通消息。</li></ul><p><em>互斥同步的实现</em></p><ul><li>锁：实现互斥</li><li>信号量：init 1实现互斥，init 0实现同步</li></ul><p><em>死锁的条件</em><br>只有同时满足以下4个条件才能形成死锁。</p><ul><li>互斥条件：唯一资源</li><li>不可剥夺：不会主动释放</li><li>持有等待：等待另一个唯一资源</li><li>环路等待：形成了环路等待</li></ul><p><em>排查死锁</em><br><code>jstack</code>可排查死锁</p><p><em>避免死锁</em><br>一般会破坏环路等待，即编码时使资源的获取有序。</p><h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p><em>生产者消费者问题</em></p><ul><li>一个互斥信号量实现访问互斥</li><li>一个同步信号量初始化为0实现notEmpty通知</li><li>一个同步信号量初始化为n实现notFull通知</li></ul><p><em>哲学家就餐问题</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/23-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E6%A8%A1%E5%9E%8B.webp"><br>哲学家需要同时拿起左右两侧的叉子才吃面，如何防止死锁：</p><ul><li>一个互斥信号量代表当前是否有人拿起筷子：只有没人拿起筷子时，才允许拿筷子，效率较低。</li><li>五个互斥信号量代表叉子：偶数先拿左边，奇数先拿右边。</li><li>五个互斥信号量代表人：只有两个邻居都没有拿起筷子时，才允许拿筷子。</li></ul><p><em>读者-写者问题</em><br>为了保证读者和写者都不被饿死，读者和写者应该在同一个队列中等待，实现FIFO：</p><ul><li>一个普通量记录读者数量</li><li>一个互斥信号量控制对读者数量的修改</li><li>一个互斥信号量控制写者写操作</li><li><strong>一个互斥信号量保证写者排队时，后续读者阻塞</strong>。</li></ul><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>银行家算法是资源分配层面上避免死锁的著名方法。<br><em>条件</em></p><ul><li>系统当前可利用资源向量Avaliable</li><li>进程最大需求矩阵Max</li><li>进程当前分配矩阵Allocate</li><li>进程需求矩阵Need（进程需求矩阵 &#x3D; 进程最大需求矩阵-进程当前分配矩阵）</li></ul><p><em>银行家算法</em></p><ul><li>进程请求资源大于其最大需求资源时出现错误，不分配</li><li>进程请求资源大于可利用资源时，不分配</li><li>否则，可以尝试分配，执行安全性算法。</li></ul><p><em>安全性算法</em><br>安全性算法的目的就是找到一个安全执行序列，难点在于如何判断找不到该安全序列。</p><ol><li>第一轮：先假定一个序列，逐个判断进程是否能被执行。</li><li>第二轮：第一轮中能够被执行的进程添加到安全序列中，再次遍历该序列，这次只针对第一轮中判断无法被执行的进程判断。</li><li>如果第二轮中发现了新的可被执行进程，则循环第二轮；如果某轮发现剩余进程都无法执行，则说明找不到安全序列。</li></ol><h1 id="五、文件系统"><a href="#五、文件系统" class="headerlink" title="五、文件系统"></a>五、文件系统</h1><h2 id="文件系统组成和基本使用"><a href="#文件系统组成和基本使用" class="headerlink" title="文件系统组成和基本使用"></a>文件系统组成和基本使用</h2><p><em>概念</em></p><ul><li>文件：普通的文件，其数据块中记录文件数据，保存在硬盘中。</li><li>目录：特殊的文件，其数据块中记录文件信息（文件名和文件inode号，并使用一个hash表维护inode号和块号），保存在硬盘中。</li><li>目录项：内核维护的数据结构，缓存在内存中，其既可以表示目录，也可以表示文件。</li></ul><p><em>硬链接与软连接</em><br>硬链接：是<strong>多个目录项中的「索引节点」指针指向一个文件</strong>，也就是指向同一个inode。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.webp"></p><p>软连接：创建独立的inode，可以跨文件系统。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%BD%AF%E9%93%BE%E6%8E%A5.webp"></p><p><em>基本结构</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.webp"></p><ul><li>超级块：存储文件系统信息，文件系统挂载时进入内存。</li><li>索引节点：存储索引节点，文件被访问时进入内存。</li></ul><blockquote><p>用户进程对文件的基本操作单位是<strong>字节</strong>，文件系统的基本操作单位是<strong>数据块</strong>，文件系统则屏蔽了这种操作差异。</p></blockquote><p><em>虚拟文件系统</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.webp"><br>操作系统需要为用户提供统一的文件接口，根据存储位置不同，分为：</p><ul><li>磁盘文件系统（如Ext 2）</li><li>内存文件系统（如<code>/proc</code>）</li><li>网络文件系统（如NFS）</li></ul><p><em>文件的使用</em><br><code>open()</code>、<code>write()</code>、<code>read()</code>。<br>每个进程会维护一个打开文件表，每一项通过一个文件描述符，记录：</p><ul><li>文件指针</li><li>打开计数器</li><li>文件磁盘位置</li><li>访问权限</li></ul><h2 id="文件的存储"><a href="#文件的存储" class="headerlink" title="文件的存储"></a>文件的存储</h2><p><em>连续空间存储方式</em><br>文件头需要指定起始块位置和长度。会造成<strong>磁盘空间碎片</strong>和<strong>文件长度不易扩展</strong>的问题。</p><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.webp"></p><p><em>非连续空间存放方式</em></p><ul><li><p>隐式链表：每个数据块用一个指针存放下一块的位置。缺点为必须遍历访问；稳定性差，若一个指针丢失则文件不可用。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.webp"></p></li><li><p>显式链表：使用<strong>文件分配表</strong>，显示的记录文件使用的磁盘块链，遍历到-1说明结束。缺点为由于文件分配表存在于内存中，其不适用大磁盘。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.webp"></p></li><li><p>索引方式：为每个文件创建<strong>索引数据块</strong>，相当于文件的数据块目录。当文件过大一个索引块不够用时，可以使用<strong>链式索引块</strong>或<strong>多级索引块</strong>。</p></li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.webp"><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.webp"><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.webp"></p><p><em>文件存储方式对比</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.webp"></p><h4 id="Unix文件实现"><a href="#Unix文件实现" class="headerlink" title="Unix文件实现"></a>Unix文件实现</h4><p>Linux Ext 2&#x2F;3文件系统方案如下，其适用于不同大小的文件索引需求：<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Unix-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.webp"></p><h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p><em>空闲表法</em><br>为所有空闲空间建立一张表，空间消耗大且查询效率较低。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.webp"></p><p><em>空闲链表法</em><br>主存只需要保存一个指针，简单，但无法随机访问，查询效率低。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.webp"></p><p><em>位图法</em><br>使用bitmap记录磁盘块的使用情况，Linux中采用的方案。位图存储在磁盘中。</p><p><em>文件系统结构</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%9D%97%E7%BB%84.webp"></p><blockquote><p>块组0类似数据库设计中表空间的第一个页的作用。</p></blockquote><h2 id="文件缓存与I-x2F-O"><a href="#文件缓存与I-x2F-O" class="headerlink" title="文件缓存与I&#x2F;O"></a>文件缓存与I&#x2F;O</h2><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/72568a29816fa9b505f15edac68adee2.webp"><br><em>概念</em></p><ul><li>Page Cache是操作系统中的内存缓存，其由多个page组成。</li><li>Swap out时换出的内存Swap Cached也可以被视为Page Cache。</li><li>Page Cache用于缓存文件的页数据，与文件系统同级；buffer cache用于缓存块设备（如磁盘）的块数据，与驱动程序同级；现在两者已经几乎被统一了，统称为<code>Page Cache</code>。</li></ul><p><em>预读机制</em><br>read时，内核调用了readhead。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/ae8252378169c8c14b8b9907983f7d8b-20230309235145646.webp"></p><p><em>一致性与可靠性保证</em><br>Linux 下以两种方式实现文件一致性：</p><ul><li>写穿(Write Through)：同步写入磁盘，保证一致性。</li><li>写回(Write Back)：默认方案，定时任务将Page Cache刷回脏数据块，无法保证一致性。</li></ul><p><em>文件I&#x2F;O</em></p><ul><li>缓冲与非缓冲 I&#x2F;O：根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲 I&#x2F;O。</li><li>直接与非直接I&#x2F;O：根据是「否利用操作系统的缓存（Page Cache）」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O。直接I&#x2F;O不会发生内核缓存和用户程序之间数据复制。</li><li>阻塞与非阻塞I&#x2F;O：见后文I&#x2F;O模型。</li></ul><h1 id="六、设备管理"><a href="#六、设备管理" class="headerlink" title="六、设备管理"></a>六、设备管理</h1><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230409194607.png"><br><em>概念</em></p><ul><li>每个设备都有一个叫<strong>设备控制器（Device Control）</strong>。</li><li>控制器是有三类寄存器：<ul><li>状态寄存器（Status Register）：命令执行状态</li><li>命令寄存器（Command Register）：具体命令</li><li>数据寄存器（Data Register）：命令参数</li></ul></li><li>按照数据存在位置可分为两大类：<ul><li>块设备（Block Device）：硬盘等数据保存在块中的设备</li><li>字符设备（Character Device）：鼠标等数据只以字符形式在数据流中存在的设备。</li></ul></li><li>按通讯方式可以分两大类：<ul><li>端口I&#x2F;O：每个寄存器分配一个端口</li><li>内存映射：将寄存器映射到内存空间</li></ul></li></ul><p><em>I&#x2F;O控制方式</em></p><ul><li>轮询等待：CPU轮询寄存器</li><li>中断机制：包括硬中断、软中断</li></ul><p><em>设备驱动程序</em><br>设备驱动程序会提供<strong>统一的接口</strong>给操作系统，它会及时<strong>响应控制器发来的中断请求</strong>，并根据这个中断的类型调用响应的<strong>中断处理程序</strong>进行处理。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%B8%AD%E6%96%AD%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.webp"></p><p><em>块设备管理</em><br>为了屏蔽不同块设备差异，Linux通过统一的<strong>通用块层</strong>来管理块设备。通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，其向上提供标准接口，向下实现I&#x2F;O调度和管理。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/I_O%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82.webp"></p><p><em>键盘敲入字母后，发生了什么？</em></p><ul><li>键盘控制器扫描到数据，将其缓冲到寄存器中并发起<strong>中断请求</strong>。</li><li>CPU收到中断请求，保存当前CPU上下文，<strong>调用键盘的中断处理程序</strong>。</li><li>中断处理程序<strong>读取寄存器缓冲区数据并识别处理</strong>，将识别到的字符放入显示设备的<strong>读缓冲区队列</strong>。</li><li>显示设备将<strong>读缓冲区队列</strong>数据放入<strong>写缓冲区队列</strong>，然后写入到显示设备的<strong>寄存器数据缓冲区</strong>。</li><li><strong>恢复被中断的进程上下文</strong>。</li></ul><h1 id="七、网络系统"><a href="#七、网络系统" class="headerlink" title="七、网络系统"></a>七、网络系统</h1><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p><strong>直接内存访问</strong>(Direct Memory Access)：将I&#x2F;O设备与内存间的数据传输工作交给DMA控制器。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/DRM-I_O-%E8%BF%87%E7%A8%8B.webp"></p><h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h2><ul><li><p>传统文件传输<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.webp"><br>发生了4次状态切换和4次拷贝。</p></li><li><p>mmap+write</p></li></ul><p><img src="/mmap%20+%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.webp"><br>发生了4次状态切换和3次拷贝。</p><ul><li>sendfile</li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.webp"><br>发生了2次状态切换和3次拷贝。</p><ul><li>sendfile(网卡支持SG-DMA时)</li></ul><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.webp"><br>发送了2次状态切换和2次拷贝。</p><h2 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h2><p><em>内核缓冲区</em><br>内核缓冲区本质上是page cache，零拷贝中使用到了这个技术。但对于过大的文件（GB级别），使用零拷贝会过度占用page cache。因此，<strong>传输大文件时不应该使用零拷贝技术</strong>。</p><p><em>大文件传输方案</em><br>在高并发的场景下，针对大文件的传输的方式，应该使用 <strong>「异步 I&#x2F;O + 直接 I&#x2F;O」</strong> 来替代零拷贝技术：</p><ul><li>直接 I&#x2F;O 绕过了 PageCache</li><li>异步 I&#x2F;O 避免了直接 I&#x2F;O效率较慢的阻塞</li></ul><p><em>总结</em></p><ul><li>小文件用零拷贝技术</li><li>大文件用异步I&#x2F;O+直接I&#x2F;O技术</li></ul><h2 id="Unix-I-x2F-O模型"><a href="#Unix-I-x2F-O模型" class="headerlink" title="Unix I&#x2F;O模型"></a>Unix I&#x2F;O模型</h2><h3 id="IO阶段"><a href="#IO阶段" class="headerlink" title="IO阶段"></a>IO阶段</h3><p>一个输入操作通常包括<strong>两个阶段</strong>:</p><ol><li>等待数据准备</li><li>等待从内核向进程复制数据</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><em>同步IO</em></p><ul><li>阻塞式I&#x2F;O(<code>recvfrom</code>)</li><li>非阻塞式I&#x2F;O(<code>recvfrom</code>)</li><li>多路复用I&#x2F;O(<code>select</code>或<code>poll</code>+<code>recvfrom</code>)</li><li>信号驱动式I&#x2F;O(<code>sigaction</code>+<code>recvfrom</code>)</li></ul><p><em>异步IO</em></p><ul><li>异步I&#x2F;O(<code>aio_read</code>)</li></ul><p><em>文件、网络I&#x2F;O</em></p><ul><li>多路复用I&#x2F;O模型中的<strong>select等方法</strong>主要针对socket的读写，是网络I&#x2F;O模型。</li><li>其他I&#x2F;O模型既可以用于网络I&#x2F;O，又可以用于文件I&#x2F;O。</li></ul><h4 id="阻塞式-I-x2F-O"><a href="#阻塞式-I-x2F-O" class="headerlink" title="阻塞式 I&#x2F;O"></a>阻塞式 I&#x2F;O</h4><p>应用调用<code>recvfrom</code>，被阻塞，直到数据复制到应用进程缓冲区中才返回。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213143753.png"><br>阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。</p><h4 id="非阻塞式I-x2F-O"><a href="#非阻塞式I-x2F-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h4><p>应用进程不断的执行<code>recvfrom</code>来获知 I&#x2F;O 是否完成，这种方式称为轮询(<code>polling</code>)。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213143817.png"><br>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p><h4 id="多路复用I-x2F-O"><a href="#多路复用I-x2F-O" class="headerlink" title="多路复用I&#x2F;O"></a>多路复用I&#x2F;O</h4><ol><li>使用<code>select</code>或者<code>poll</code>等待数据（<strong>支持阻塞和非阻塞</strong>），并且可以<strong>等待多个套接字</strong>中的任何一个变为可读，当某一个套接字可读时返回。</li><li>使用<code>recvfrom</code>把数据从内核复制到进程中。</li></ol><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150145.png"><br>I&#x2F;O多路复用本质上仍然是<strong>阻塞IO</strong>，只不过其将阻塞等待数据准备的过程交给了操作系统进行监听，且一次可以注册多个socket，从而使单个进程具有处理多个I&#x2F;O事件的能力。</p><h4 id="信号驱动I-x2F-O"><a href="#信号驱动I-x2F-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h4><ol><li>应用进程使用 <code>sigaction</code> 系统调用，内核立即返回(非阻塞)。</li><li>内核在数据到达时向应用进程发送 <code>SIGIO</code> 信号，应用进程收到之后在信号处理程序中调用 <code>recvfrom</code> 将数据从内核复制到应用进程中。</li></ol><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150246.png"></p><h4 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h4><ol><li>应用进行 aio_read 系统调用立即返回。</li><li>内核会在所有操作完成之后向应用进程发送信号。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150315.png"></li></ol><h3 id="I-x2F-O模型比较"><a href="#I-x2F-O模型比较" class="headerlink" title="I&#x2F;O模型比较"></a>I&#x2F;O模型比较</h3><h4 id="阻塞、非阻塞、同步、非同步"><a href="#阻塞、非阻塞、同步、非同步" class="headerlink" title="阻塞、非阻塞、同步、非同步"></a>阻塞、非阻塞、同步、非同步</h4><p><em>阻塞的概念</em><br>阻塞是一般指，应用程序调用某系统函数后，是否需要等待操作系统准备好资源。</p><p><em>IO场景</em><br>具体到IO场景，等待分「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程，做出了以下分类。</p><p><em>阻塞与非阻塞</em></p><ul><li>强调的是应用行为，即在等待函数执行结果时的行为，如果一直阻塞等待则是阻塞的，如果直接返回了当前的状态则是非阻塞的。</li><li>阻塞IO与非阻塞IO：讨论的是第一阶段是否需要阻塞，即应用程序是否等待资源准备好。</li></ul><p><em>同步与异步</em></p><ul><li>强调的是通讯机制，即应用执行函数时直接返回（异步肯定是非阻塞的），执行完毕后通知应用结果。</li><li>同步IO与异步IO：讨论的是第二阶段是否需要阻塞，即应用程序是否等待资源拷贝到用户空间内存。</li></ul><p><em>阻塞socket与非阻塞socket</em><br>首先明确，socket本身只是一个文件描述符，执行函数时会根据其模式判断执行方式。</p><ul><li>Windows和Linux，创建<code>socket</code>都是阻塞模式的；</li><li>Linux中,可以在创建<code>socket</code>是直接将它设置为非阻塞模式；</li></ul><p><em>accept&#x2F;connect&#x2F;recv&#x2F;read&#x2F;send&#x2F;write</em><br>在网络I&#x2F;O中，这些函数根据socket的模式决定是否阻塞等待资源准备好。</p><ul><li>其中，recv&#x2F;read等待的资源是应用程序接受缓冲区。</li><li>其中，send&#x2F;write等待的资源是内核缓存区，如果缓冲区满了且在非阻塞状态会返回发送失败。</li></ul><p><em>select&#x2F;poll&#x2F;epoll</em><br>这些函数始终是阻塞的函数，可以设置超时时间实现<strong>类似</strong>非阻塞的状态。</p><h4 id="五大I-x2F-O模型比较"><a href="#五大I-x2F-O模型比较" class="headerlink" title="五大I&#x2F;O模型比较"></a>五大I&#x2F;O模型比较</h4><p><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230213150509.png"><br>这些I&#x2F;O模型描述的是一次I&#x2F;O行为的过程，而一个网络应用需要处理大量不同类型的Socket，故会使用多种I&#x2F;O模型组合的架构。</p><h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><h4 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h4><p>基于阻塞I&#x2F;O。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230405144258.png"></p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>基于阻塞I&#x2F;O，但节省了进程创建销毁的开销。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Pasted-image-20230405144507.png"></p><h4 id="网络I-x2F-O多路复用"><a href="#网络I-x2F-O多路复用" class="headerlink" title="网络I&#x2F;O多路复用"></a>网络I&#x2F;O多路复用</h4><p>之前的方法在进行网络I&#x2F;O时都需要至少一个线程维护一个socket，造成了大量的浪费，I&#x2F;O多路复用使用一个线程监听多个socket上的事件，并对其逐一处理。</p><h5 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h5><p><em>过程</em></p><ul><li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select&#x2F;poll 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生。</li><li>内核<strong>遍历</strong>检查发现事件后，将该Socket标记，并<strong>拷贝</strong>回用户态。</li><li>用户态再<strong>遍历</strong>找到可读、可写的事件并处理。</li></ul><p><em>select</em><br>使用bitmap存储文件描述符集合，只能监听1024个socket。</p><p><em>poll</em><br>使用链表存储文件描述符集合，突破了1024个，但仍然受系统限制。</p><h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p><em>过程</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/epoll.webp"></p><ul><li>epoll在为应用在内核中维护一个<strong>文件描述符</strong>红黑树，用户需要新增加socket时，只需要调用<code>epoll_ctl()</code>即可，不再需要拷贝整个集合。</li><li>epoll使用了一个链表记录就绪事件，当用户调用<code>epoll_wait()</code>时，只会复制就绪链表中的socket到用户态进行处理。</li></ul><p><em>触发模式</em></p><ul><li>LT 水平触发：进程调用epoll_wait()，当有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，<strong>支持阻塞I&#x2F;0和非阻塞I&#x2F;0</strong>，是默认的触发模式。</li><li>ET 边缘触发：进程调用epoll_wait()，服务器端只会从 epoll_wait 中苏醒一次，只支持<strong>非阻塞I&#x2F;O</strong>。</li></ul><p><em>触发模式对比</em></p><ul><li>LT是默认的触发模式；</li><li>ET模式因为要循环读完所有数据后要正常返回而不是阻塞，所以只支持非阻塞I&#x2F;O；</li><li>ET模式因为epoll_wait苏醒的次数少，效率更高。</li></ul><h3 id="I-x2F-O复用模型对比"><a href="#I-x2F-O复用模型对比" class="headerlink" title="I&#x2F;O复用模型对比"></a>I&#x2F;O复用模型对比</h3><ul><li>select实时性更高，一致性更好</li><li>poll无最大描述符限制</li><li>epoll处理大量文件描述符时最好</li></ul><h2 id="高性能网络模式"><a href="#高性能网络模式" class="headerlink" title="高性能网络模式"></a>高性能网络模式</h2><p>基于I&#x2F;O多路复用模型的特性，在应用程序中实现高性能的网络模式，主要有Reactor、Proactor模型。</p><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>非阻塞同步网络模式，组成有Reactor、Acceptor、Handler。<br><em>单Reactor单线程</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.webp"></p><ul><li>说明：Reactor通过select监听事件，根据监听到的事件类型分发给acceptor或handler</li><li>缺点：无法充分利用CPU。</li><li>应用：Redis中使用的方案。</li></ul><p><em>单Reactor多线程</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp"></p><ul><li>说明：普通多线程模型中每个线程需要负责一个socket，Reactor中多线程只是完成业务处理，Socket的维护都交给了Reactor对象。</li><li>缺点：单Reactor容易称为并发时的性能瓶颈。</li></ul><p><em>多Reactor多进程</em><br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.webp"></p><ul><li>说明：不再由一个Reactor对象负责所有Socket管理，而是由主Reactor负责监听Accptor事件，子Reactor负责业务处理。</li><li>应用：Netty中使用的方案。</li></ul><h3 id="Proactor模型"><a href="#Proactor模型" class="headerlink" title="Proactor模型"></a>Proactor模型</h3><p>异步网络模式。使用了异步I&#x2F;O技术，但在Linux下目前不完善，Window支持较好。<br><img src="/2023/04/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/Proactor.webp"></p><h3 id="网络模式对比"><a href="#网络模式对比" class="headerlink" title="网络模式对比"></a>网络模式对比</h3><ul><li>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。</li><li>Proactor 是异步网络模式， 感知的是已完成的读写事件。</li></ul><h1 id="八、性能指标"><a href="#八、性能指标" class="headerlink" title="八、性能指标"></a>八、性能指标</h1><p><em>性能指标</em></p><ul><li>带宽：b&#x2F;s</li><li>延时：s</li><li>吞吐率：B&#x2F;s</li><li>PPS：包&#x2F;s</li></ul><p><em>查看配置</em></p><ul><li>网络配置：<code>ifconfig</code>、<code>ip</code></li><li>socket信息：<code>netstat</code>、<code>ss</code></li><li>吞吐率和PPS：<code>sar -n</code></li><li>连通性和延时：<code>ping</code></li></ul><p><em>查看日志</em><br>原则：尽量不要使用<code>cat</code>，应该使用<code>less</code>查看。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch基础</title>
    <link href="/2023/03/31/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/ElasticSearch/ElasticSearch%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/31/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/ElasticSearch/ElasticSearch%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><em>ELK</em><br>ELK(elastic stack)是一个日志数据分析、监控技术栈，包括如下技术：<br><img src="/Pasted%20image%2020230423185915.png"></p><ul><li>Beats：面向轻量采集器平台；</li><li>Logstash：动态数据收集管道，支持不同来源采集数据；</li><li>ElasticSearch：对数据进行<strong>搜索、分析和存储</strong>；<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html">手册</a></li><li>Kibana：数据可视化，以图表方式展示。<a href="https://www.elastic.co/guide/cn/kibana/current/index.html">手册</a></li></ul><blockquote><p>用户密码为：elastic、elastic</p></blockquote><p><em>Elastic Search</em><br>基于lucene，是一个基于Java语言的搜索引擎类库。</p><p><em>日志最佳实践</em><br><img src="/Pasted%20image%2020230423225047.png"></p><p><em>应用性能管理最佳实践</em><br><img src="/Pasted%20image%2020230423225105.png"></p><p><em>高可用方案</em><br><img src="/Pasted%20image%2020230423225241.png"></p><p><em>多数据源上传</em><br><img src="/Pasted%20image%2020230423225310.png"></p><p><em>跨集群搜索</em><br><img src="/Pasted%20image%2020230423225329.png"></p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p><em>目的</em><br>正向索引如mysql在进行模糊搜索时需要进行全表扫描，效率过低，因此引入倒排索引。</p><p><em>概念</em></p><ul><li>文档：用于数据搜索，每条数据就是一个文档。</li><li>词条：对文档数据或用户搜索数据，利用分词器进行分词，得到若干词条。</li><li>倒排索引：对文档进行分词，保存在<strong>倒排索引表</strong>中；搜索时分词，匹配词条搜索；</li></ul><p><em>正向与倒排</em></p><ul><li>正向：根据文档找词条，对非索引字段只能全表扫描</li><li>倒排：根据词条找文档，不能对字段创建索引</li></ul><p><em>与SQL对比</em></p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引库(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p><em>Mapping</em></p><ul><li>type：字段数据类型：常见的有<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li><li>地理位置：geopoint（坐标点）、geo_shape（由坐标点组成的复杂图像）</li></ul></li><li>index：是否创建索引（与索引库是两个概念），默认为true</li><li>analyzer：使用的分词器</li><li>properties：子字段</li><li>copy_to：表示会将该字段拷贝到指定字段，通过该方式可以将多个字段合并以供搜索</li></ul><p><em>分词器</em></p><ul><li>查询粒度设置：<ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员学习java太棒了&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>词条设置：修改<code>IkAnalyzer.cfg.xml</code>文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">properties</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典  *** 添加停用词词典--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span>stopword.dic<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h1><h2 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h2><p><em>增加索引库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /<span class="hljs-punctuation">&#123;</span>索引库名称<span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;子字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// ...略</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>修改索引库</em><br><strong>无法修改mapping中已有的字段</strong>，否则需要重建倒排索引，过于复杂。但允许新增字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>查询索引库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库库名称<br></code></pre></td></tr></table></figure><p><em>删除索引库</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /索引库名<br></code></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><p><em>新增文档</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><em>查询文档</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库名称/_doc/文档id<br></code></pre></td></tr></table></figure><p><em>修改文档</em></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//全量修改</span><br>PUT /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">//增量修改</span><br>POST /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;新的值&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意到增量修改url中使用了<code>_update</code>，json中需要补充<code>&quot;doc&quot;</code>表示修改文档。</p></blockquote><h2 id="JavaClient"><a href="#JavaClient" class="headerlink" title="JavaClient"></a>JavaClient</h2><p><em>依赖与配置</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据SpringBoot的需要，可能要覆盖默认版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建客户端</span><br><span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure><p><em>索引操作</em><br><img src="/Pasted%20image%2020230424195524.png"></p><p><em>操作模板</em><br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-getting-started.html">官网API</a></p><ul><li>创建请求对象：<code>[Create][Index]Request</code><ul><li>根据需要，<code>Create</code>可替换为<code>Get</code>、<code>Delete</code></li><li>修改文档时，<code>Create</code>改为<code>Index</code>，不写第二个<code>Index</code></li></ul></li><li>携带请求参数：<code>request.source(json文本，XContentType.JSON)</code></li><li>发起请求：<code>client.indices().[create](request,RequestOptions.DEFAULT)</code>，同理<code>Create</code>可替换为其他参数</li><li>批量请求：可创建<code>BulkRequest</code>对象然后将其他请求add进来一起发送</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>数据库DB</category>
      
      <category>ElasticSearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>ElasticSearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL复习</title>
    <link href="/2023/03/31/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/31/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/30/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/English%20Interview/Optiver(hr%E9%9D%A23.30)/"/>
    <url>/2023/03/30/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/English%20Interview/Optiver(hr%E9%9D%A23.30)/</url>
    
    <content type="html"><![CDATA[<h1 id="电面（30分钟）"><a href="#电面（30分钟）" class="headerlink" title="电面（30分钟）"></a>电面（30分钟）</h1><ol><li>确认基本情况，是否是中国学习，什么时候毕业</li><li>为什么申请Optiver的软件开发岗位</li><li>你对软件开发的理解？</li><li>你是如何知道Optiver的</li><li>有参加过我们的校园campus吗？</li><li>微信是否关注了Optiver公众号</li><li>你还知道类似Optiver的公司吗？</li><li>Optiver哪一点最吸引你？（答：mission”we improve the market”）</li><li>Optiver如何improve the market?</li><li>什么时候对计算机感兴趣的？</li><li>你是如何学习的编程？</li><li>为什么没有申请计算机专业的研究生？</li><li>你个人的优势是什么？</li><li>能告诉我一件你在做但你并不感兴趣的事情吗？</li><li>你现在还在申请哪些公司的暑期实习吗？进行到了哪一个阶段？</li><li>反问：你最喜欢现在公司的哪一点？</li><li>2周后回复，肯定寄了。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>先删除<code>.ssh</code>，生成密钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C renyu.jin@outlook.com<br></code></pre></td></tr></table></figure><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name 用户名设置用户签名<br>git config --global user.email 邮箱设置用户email地址<br>git init初始化本地库<br>git status查看本地库状态<br>git add 文件名添加到暂存区<br>git commit -m “日志信息” 文件名提交到本地库<br>git reflog查看所有历史记录<br>git log 查看版本信息<br>git reset --hard 版本号版本穿梭<br></code></pre></td></tr></table></figure><h1 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch 分支名创建分支<br>git branch -v查看分支<br>git checkout 分支名切换分支<br>git merge 分支名把指定的分支合并到当前分支上<br></code></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v查看当前所有远程地址别名<br>git remote add 别名 远程地址起别名<br>git push 别名 分支推送本地分支上的内容到远程仓库<br>git clone 远程地址将远程仓库的内容克隆到本地<br>git pull 远程库地址别名 远程分支名将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>常用工具</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>常用工具</tag>
      
      <tag>概念整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p><em>NAT（VMnet8）</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/v2-cba959e53f730199ecfb6b001e0497ea_1440w.webp"><br>每台虚拟机有自己的虚拟网卡与虚拟交换机通讯，本处未标出来。<br>为整个虚拟网络设置了一个虚拟DHCP服务器，并为该DHCP服务器分配了一个子网。后续Linux操作系统开启时，自动获得IP。<br><strong>每个虚拟机和主机不需要在同一个网段，而是通过NAT转换实现借用主机网关发送请求。</strong></p><p><em>Briged（VMnet0）</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/v2-3c4584024508a5632e1932b5e524ecdf_1440w.webp"><br>每台虚拟机有自己的虚拟网卡与虚拟交换机通讯，本处未标出来。<br><strong>虚拟机和主机要在同一个网段，相当于只是借用主机网关向真路由器发请求。</strong></p><p><em>Only Host（VMnet1）</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Linux/v2-f3d48608da3167419b71c740e11d6c37_1440w.webp"><br>只与主机内网通讯。</p><h2 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h2><p>1.本地生成RSA公钥和密钥，将公钥上传到Linux服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp C:\Users\Jin\.ssh\id_rsa.pub root@192.168.196.128<br></code></pre></td></tr></table></figure><p>2.远程连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@192.168.196.128<br></code></pre></td></tr></table></figure><p>3.输入密码：root</p><h1 id="二、Linux"><a href="#二、Linux" class="headerlink" title="二、Linux"></a>二、Linux</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><em>用户相关</em></p><ul><li>&#x2F;bin：二进制文件</li><li>&#x2F;sbin：超级管理员二进制文件</li><li>&#x2F;home：普通用户的主目录，相当于Users，其下每一个文件夹代表一个用户的文件</li><li>&#x2F;root：超级管理员的主目录</li></ul><p><em>应用程序</em></p><ul><li>&#x2F;usr：相当于program files，可安装应用的核心文件</li><li>&#x2F;etc：配置文件和子目录</li></ul><p><em>文件相关：</em></p><ul><li>&#x2F;mnt：挂载文件系统</li><li>&#x2F;opt：额外安装软件使用的目录，如数据库内存</li><li>&#x2F;usr&#x2F;local：也是供本机额外安装软件的目录</li><li>&#x2F;var：日志文件等经常修改的文件</li></ul><p><em>系统相关：</em><br>常用：</p><ul><li>&#x2F;boot：Linux启动核心文件</li><li>&#x2F;lib：动态连接共享库，应用程序都需要用到这个文件夹下的文件</li><li>&#x2F;lost+found：非法关机后存放临时文件</li></ul><p>不常用（不要修改）：</p><ul><li>&#x2F;proc：虚拟目录，是内存映射</li><li>&#x2F;srv：service缩写</li><li>&#x2F;sys：文件系统</li></ul><p><em>设备相关：</em></p><ul><li>&#x2F;dev：设备管理器</li><li>&#x2F;media：外接设备</li></ul><p><em>磁盘挂载</em>：<br>磁盘的不同分区会挂载在文件系统的不同目录中</p><h1 id="三、Vi与Vim"><a href="#三、Vi与Vim" class="headerlink" title="三、Vi与Vim"></a>三、Vi与Vim</h1><p>基本概念：</p><ul><li><code>vim 文件</code>后进入<strong>一般模式</strong></li><li>使用<code>i</code>或<code>a</code>或<code>r</code>进入<strong>编辑模式</strong>，ESC返回一般模式</li><li>使用<code>:</code>或<code>/</code>进入<strong>命令模式</strong>，ESC返回一般模式，命令模式下使用<code>:wq</code>、<code>:q</code>、<code>:q!</code>等退出vim。</li></ul><p><em>快捷键</em></p><ul><li>拷贝：<code>yy</code>，拷贝当前行下5行 5yy</li><li>删除：<code>dd</code>，删除当前行下5行 5dd</li><li>命令模式下：<code>/关键词</code></li></ul><h1 id="四、开机、重启"><a href="#四、开机、重启" class="headerlink" title="四、开机、重启"></a>四、开机、重启</h1><p><em>关机、重启</em></p><ul><li>shutdown -h now 现在关机</li><li>shutdown -h 1 1分钟后关机</li><li>shutdown -r now 现在重启计算机</li><li>halt 关机</li><li>reboot 重启</li><li>sync 内存同步到磁盘</li></ul><blockquote><p>所有关机操作都会先执行sync</p></blockquote><p><em>用户登录和注销</em></p><ul><li>su user 切换到user用户</li><li>sudo cmd 允许临时使用超级管理员身份执行cmd，需要输入密码</li><li>logout 登出</li></ul><h1 id="五、用户管理"><a href="#五、用户管理" class="headerlink" title="五、用户管理"></a>五、用户管理</h1><p><em>用户管理</em></p><ul><li>useradd 添加用户</li><li>userdel 删除用户</li><li>su user 切换用户（高权限可随意切低权限，低权限切高权限要密码）</li><li>passwd user 修改用户密码</li><li>whoami 查询用户名</li></ul><p><em>组管理</em></p><ul><li>groupadd 添加组</li><li>groupdel 删除组</li></ul><p><em>用户与组</em></p><ul><li>useradd -g 用户组 用户名</li><li>usermod -g 用户组 用户名</li></ul><p><em>权限</em><br>权限分类：rwx，可读&#x2F;可写&#x2F;可执行，通过<code>ll</code>命令可查看权限：第一位为文件类型，后面三组，分别是所属用户&#x2F;所属组&#x2F;其他用户的权限。</p><ul><li>ls -ahl 查看文件管理者</li><li>chown 用户名 文件名 修改文件管理者</li><li>chgrp 组名 文件名 将文件转入该组</li><li>chmod ?+? 修改权限，前一个？可以为u、g、o代表不同所属，后一个？可以为rwx。</li></ul><h1 id="六、实用指令"><a href="#六、实用指令" class="headerlink" title="六、实用指令"></a>六、实用指令</h1><p><em>运行级别</em><br>例子：0：关机 3：多用户有网络 5：图形界面<br>指令：init n</p><p><em>获取帮助</em></p><ul><li>man cmd，包括shell外部信息</li><li>help cmd，只包括shell内部信息</li></ul><p><em>文件目录类</em></p><ul><li>pwd 当前目录绝对路径</li><li>ls 当前目录下文件和目录 <code>-l</code>以列表形式给出</li><li>cd 移动</li><li>mkdir 生成目录 <code>-p</code>生成多级目录</li><li>rmdir 删除目录，只能删除空目录，删除非空目录：<code>rm -rf 文件夹</code></li></ul><p><em>文件类</em></p><ul><li>touch 生成空文件</li><li>cp source target 拷贝文件 <code>-r</code>递归复制</li><li>rm 删除</li><li>mv old new 移动&#x2F;重命名文件</li></ul><p><em>文件查看</em></p><ul><li>cat 查看 <code>-n</code>显示行号</li><li>more 查看文本查看器，内置了很多翻页的快捷键，如空格翻页</li><li>less 查看文本查看器，更强大的文本查看器</li><li>echo 将内容输出到控制台</li><li>head 显示文件前10行</li><li>tail 显示文件后10行，<code>-f</code> 可以追踪文件更新，实时监控</li></ul><p><em>写入和追加</em></p><ul><li><code>&gt;</code>:ls -l&gt;文件 写入文件</li><li><code>&gt;&gt;</code>:ls -al&gt;&gt;文件 追加到文件末尾</li></ul><p><em>常用的文件查找</em></p><ul><li>find 查找起点 查找文件名 递归查找文件 eg: <code>find /home hello.txt</code></li><li>locate 文件名 快速定位文件 eg:<code>locate hello.txt</code></li><li><strong>grep 查找内容 源文件</strong>，可以将源文件以管道的形式传入，eg：<code>cat /home/hello.txt |grep &quot;yes&quot;</code></li></ul><p><em>其他</em></p><ul><li>ln -s sourse 链接名， 创建一个软连接</li><li>history 查看历史命令</li><li>data “+%Y-%m-%d %H:%M:%S” 显示年月日时分秒 <code>-s</code>设置</li></ul><p><em>打包压缩</em></p><ul><li>gzip&#x2F;gunzip</li><li>zip&#x2F;unzip</li><li>tar xxx.tar.gz 打包内容 （打包到压缩文件，格式未.tar.gz）</li></ul><h1 id="七、定时任务"><a href="#七、定时任务" class="headerlink" title="七、定时任务"></a>七、定时任务</h1><p><em>任务调度</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.crontab -e<br>2.*/1 * * * * * 任务内容<br>2.或sh脚本<br></code></pre></td></tr></table></figure><p><em>cron其他</em></p><ul><li>crontab -r终止</li><li>crontab -l查看</li></ul><p><em>定时任务（一次性）</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1.at 5pm + 2days<br>2.任务内容<br></code></pre></td></tr></table></figure><p><em>at其他</em></p><ul><li>atrm删除</li><li>atq查看</li></ul><h1 id="八、进程管理"><a href="#八、进程管理" class="headerlink" title="八、进程管理"></a>八、进程管理</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>-a</code>显示所有，<code>-u</code>显示详情，<code>-x</code>显示其他使用者的线程<br><code>-e</code>显示所有进程<br><code>-f</code>全格式<br>常用： ps -ef|grep xxx</p><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p>pstree，可以看进程树，<code>-u</code>查看用户</p><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><code>-P</code>按CPU使用率排序，默认<br><code>-M</code>按内存使用率排序<br><code>-N</code>按PID排序</p><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill -9 pid，-9表示强制<br>killall name，支持通配符杀进程</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>服务本质就是运行在后台的守护进程，在&#x2F;etc&#x2F;init.d中执行程序<br>service xxx start&#x2F;stop&#x2F;reload&#x2F;status<br>可以为服务设置在对应的运行级别下是否自动开启关闭。<br>chkconfig –level 3 服务名 off</p><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p><strong>systemctl兼容了service</strong>，也会去&#x2F;etc&#x2F;init.d中执行程序<br>systemctl start xxx服务</p><p>systemctl start farewalld 开启防火墙<br>firewall-cmd –premanent -add-port&#x3D;端口 打开端口<br>firewall-cmd –premanent -remove-port&#x3D;端口 打开端口</p><h1 id="九、Shell编程"><a href="#九、Shell编程" class="headerlink" title="九、Shell编程"></a>九、Shell编程</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>key&#x3D;value，定义变量</li><li>unset key 撤销变量</li><li>readonly key&#x3D;value，定义静态变量（无法撤销）</li><li>read -p “aaaaaa&#x3D;” num1 阻塞获取控制台输入，赋值给变量num1</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>export key&#x3D;value 设置环境变量</li><li>source 配置文件 修改后信息立刻生效</li><li>echo $key 查询环境变量</li></ul><h2 id="shell内置变量"><a href="#shell内置变量" class="headerlink" title="shell内置变量"></a>shell内置变量</h2><ul><li><code>$1</code>，获取执行shell脚本时携带的参数</li><li><code>$*</code>，获取执行shell脚本时携带的所有</li><li><code>$#</code>，获取执行shell脚本时携带的参数列表</li><li><code>$$</code>，当前进程号</li><li><code>$!</code>，后台运行的最后一个进程号</li><li><code>$?</code>，上一个指令的返回状态，0为成功</li></ul><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><ul><li>$计算，使用<code>()或[]</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">res=$((2+3)*4)<br>echo &quot;res=$res&quot;<br></code></pre></td></tr></table></figure></li><li>expr计算<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">res=`expr 2+3`<br></code></pre></td></tr></table></figure></li></ul><h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><p><em>包下载器</em><br>rpm、yum、apt-get（Unbuntu）</p><p><em>环境变量配置</em><br>vim &#x2F;etc&#x2F;profile 系统环境变量<br>vim ~&#x2F;.bashrc 用户环境变量</p><p><em>备份与恢复</em><br>dump、restore，需要下载</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>常用工具</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用工具</tag>
      
      <tag>概念整理</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker&amp;K8S</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&amp;K8S/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&amp;K8S/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Docker"><a href="#一、Docker" class="headerlink" title="一、Docker"></a>一、Docker</h1><h2 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h2><ol><li><a href="https://cloud.tencent.com/developer/article/1632429">docker安装</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc">镜像站</a></li><li>切换镜像源后，使用<code>systemctl restart docker.service</code>重启docker引擎</li></ol><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p><em>结构</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230331231005.png"></p><p><em>运行中</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230331231228.png"></p><p><em>命令</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 80:80 --name containerName nginx<br></code></pre></td></tr></table></figure><blockquote><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口 </li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li><li>e xxx&#x3D;”xxx” 环境变量</li></ul></blockquote><p><em>进入容器</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it containerName bash<br>docker attach containId<br></code></pre></td></tr></table></figure><blockquote><ul><li>docker exec ：进入容器内部，执行一个命令</li><li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li><li>containerName ：要进入的容器的名称</li><li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed 修改文本，具体使用参考相关案例，一般不这样做，很不方便<br></code></pre></td></tr></table></figure><p><em>退出容器</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br>Ctrl + D<br></code></pre></td></tr></table></figure><p><em>其他</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs -f （持续）查看日志<br>docker ps -a 查看（所有）容器<br>docker stop containId 停止<br>docker restart containId 重启<br>docker container prune 清理停止的容器<br></code></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><em>创建数据卷</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230331233025.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker volume [COMMAND]<br></code></pre></td></tr></table></figure><blockquote><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息，可查看volume位置。</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul></blockquote><p><em>挂载数据卷</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name containName -v html:/root/html -p 8080:80 nginx \<br></code></pre></td></tr></table></figure><blockquote><p><code>:</code>，相关的指令一般本机在前，宿主机在后<br><code>v</code>，也可以挂载目录，可自定义，但需要我们自己管理目录</p></blockquote><h2 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h2><p>只需要告知docker，镜像的基本依赖、项目文件、启动脚本即可构建。<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230401000841.png"><br><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer，在DockerFile文本所在目录下，执行build：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t imageName:v1.0<br></code></pre></td></tr></table></figure><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p><em>Compose文件</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker&K8S/Pasted-image-20230401003504.png"></p><p>分布式应用编排，解决命令行逐个运行容器的过程。<br><code>docker-compose.yml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &quot;3.8&quot;<br>services:<br>  nacos:<br>    image: nacos/nacos-server<br>    environment:<br>      MODE: standalone<br>    ports:<br>      - &quot;8848:8848&quot;<br>  mysql:<br>    image: mysql:5.7.25<br>    environment:<br>      MYSQL_ROOT_PASSWORD: 123<br>    volumes:<br>      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;<br>      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;<br>  userservice:<br>    build: ./user-service<br>  orderservice:<br>    build: ./order-service<br>  gateway:<br>    build: ./gateway<br>    ports:<br>      - &quot;10010:10010&quot;<br></code></pre></td></tr></table></figure><p>文件中<code>build:</code>表示这是一个临时起的DOCKER镜像，其中都有DockerFile文件。</p><p><em>通讯修改</em><br>服务之间的通讯不再通过<code>ip</code>，而是通过容器名称。（可以理解为容器之间根据容器名实现了一个DNS）。</p><p><em>部署</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><p>使用本地仓库必须先tag:名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><p><em>推送仓库</em></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker push 192.168.150.101:8080/nginx:1.0<br></code></pre></td></tr></table></figure><p><em>拉取镜像</em></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull 192.168.150.101:8080/nginx:1.0 <br></code></pre></td></tr></table></figure><h1 id="二、K8S"><a href="#二、K8S" class="headerlink" title="二、K8S"></a>二、K8S</h1><p>todo:file:&#x2F;&#x2F;&#x2F;D:&#x2F;Download&#x2F;kubernetes-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.pdf</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>容器技术</category>
      
      <category>Docker&amp;K8S</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Docker&amp;K8S</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker&amp;K8S</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一、消息队列概念"><a href="#一、消息队列概念" class="headerlink" title="一、消息队列概念"></a>一、消息队列概念</h1><h2 id="基本概念与场景"><a href="#基本概念与场景" class="headerlink" title="基本概念与场景"></a>基本概念与场景</h2><p><em>MQ是什么？</em><br>Message Queue（MQ）主要用于不同进程&#x2F;线程之间的通讯，本质是一个队列。</p><p><em>消息队列的作用</em>&#x2F;场景<br>异步、解耦、削峰、日志（如kafka）</p><p><em>与java阻塞队列之间的区别</em><br>消息队列可以实现高可用（集群、分布式），持久化，pull与push两种消费方式，去重、排序等功能。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h2><p><em>push</em><br>服务端推送。无法获取消费者状态，面对多消费者无法处理消费速度差异；<br><em>pull</em><br>客户端拉取。实时性较差；<br><em>Long-Polling</em><br>长请求，服务器有消息时才返回；<br><em>Dynamic Push&#x2F;Pull</em><br>long-polling请求+缓冲数组，每次polling请求时，告知Broker当前消费者的消费能力，从而批量获取，减少请求次数，单需要考虑更多丢包、顺序问题。</p><h3 id="重复消息问题"><a href="#重复消息问题" class="headerlink" title="重复消息问题"></a>重复消息问题</h3><p><em>重复生产消息</em></p><ul><li>对于相同id的消息，消息队列只做一次处理</li><li>对于不同id相同含义的消息，不做处理，令消费者避免重复消费即可。</li></ul><p><em>重复消费消息</em></p><ul><li>消费者确认后通过数据库记录消息，遇到相同消息时避免重复消费。</li><li>使用redis消费，set&#x2F;setnx具有幂等性。</li></ul><h2 id="消息丢失问题"><a href="#消息丢失问题" class="headerlink" title="消息丢失问题"></a>消息丢失问题</h2><p>使用消息发送表，之后收到消费者消费成功的通知时，才将其标记为发送成功。</p><h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p><em>同步重试</em><br>处理失败后立刻执行几次（可能消息堆积）<br><em>异步重试</em><br>写入重试表，稍后重试（影响消费顺序）</p><h2 id="消息顺序问题"><a href="#消息顺序问题" class="headerlink" title="消息顺序问题"></a>消息顺序问题</h2><p>分布式环境下，将同一个来源的消息发到同一个partion上。</p><h2 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h2><p>本质上需要加快消费：</p><ul><li>不需要保证顺序的，使用多线程加快处理。</li><li>需要保证顺序的，按合理的顺序分发到多个指定队列中。</li></ul><p>如果无法保证可靠性：</p><ul><li>限制队列大小、长度</li><li>限制队列、消息TTL</li></ul><h2 id="主流消息队列"><a href="#主流消息队列" class="headerlink" title="主流消息队列"></a>主流消息队列</h2><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-0f4f29094907bd57584b0caeb6242177_1440w.webp"></p><h1 id="二、RabbitMQ"><a href="#二、RabbitMQ" class="headerlink" title="二、RabbitMQ"></a>二、RabbitMQ</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20230331215449.png"></p><ul><li>Vitual host：虚拟分组，实现用户隔离</li><li>Exchange：对消息进行路由发配，匹配查询表中的routing key，并分发到queue中。</li></ul><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><em>docker启动</em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name rabbitmq -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> rabbitmq:<span class="hljs-number">3</span>.<span class="hljs-number">11</span>-management<br></code></pre></td></tr></table></figure><p><em>用户管理</em><br>默认会有一个guest用户为administrator。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl add_user root root<br>rabbitmqctl set_user_tags root administrator<br>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;<br>rabbitmqctl list_users<br></code></pre></td></tr></table></figure><p><em>进程管理</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl stop_app<br>rabbitmqctl reset<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><em>java库</em><br>java需要使用（amqp-client依赖），生产者和消费者都需要使用用户名和密码与MQServer建立Connection，并通过Channel向Server发送请求。</p><p><em>基本组成</em></p><ul><li>生产者发布消息时：<ul><li>需要先声明队列；</li><li>需要指明是否持久化该消息；</li><li>需要指明<strong>交换机和路由</strong>，以及消息体；</li></ul></li><li>消费者消费消息时：<ul><li>需要指明消费<strong>路由</strong></li><li>消费成功后是否自动应答</li><li>消费消息的回调函数（手动应答发送在回调函数中）</li><li>消费被中断（如消息队列被删除）时的回调函数。</li></ul></li></ul><p><em>消息应答</em><br>mq收到消息应答后即可移除消息。</p><ul><li>关闭(none)</li><li>自动应答(auto)：消费者收到消息即回复，只用于消费者消费能力很强的时候。</li><li>手动应答(manual)：<ul><li><code>channel.basicAck(tag,true)</code>，可通过参数指定是否批量应答。</li><li><code>channel.basicNack(tag)</code>，消费失败。</li><li><code>channel.basicReject(tag)</code>，拒绝该消息（可能是死信）。</li></ul></li></ul><p><em>不公平分发实现与预取值</em><br>消费者指定自己的qos等级，其值表示该消费者通道上允许的未确认消息的最大数量。这个值可以在测试中调节到最优。</p><p><em>持久化</em></p><ul><li>队列持久化：声明队列时指定，如过该队列已存在需要先删除。</li><li>消息持久化：生产消息时指定，通知MQ对该消息持久化（默认持久化，不需要特别指定）。</li></ul><h3 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h3><p><em>基本原理</em></p><ul><li>生产者可以将<strong>通道</strong>设置成confirm模式，此后所有的发布的消息都会被指定唯一id（由mq指定，java可以通过<code>getNextPublishSeqNo()</code>获取）。</li><li>生产者消息投递到队列上后，Broker会异步返回消息，告知生产者已经收到消息。<ul><li>如果是持久化队列，Broker会在在完成持久化后返回</li><li>如果MQ出现错误，会返回nack给生产者</li></ul></li></ul><p><em>发布模式</em></p><ul><li>单个确认(<code>simple</code>)：生产者只有确认消息投递成功后，才投递下一条消息。</li><li>批量确认：批量确认，确认前需要保存批量信息在内存中，出现问题时，需要定位出错的消息。</li><li>异步确认(<code>correlated</code>)：生产者通过回调函数来处理投递情况，配合<code>ConcurrentSkipListMap</code>缓存消息，收到ack后移除对应消息或比该消息小的所有消息（取决于mq返回的确认信息时批量确认还是单个确认）</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p><em>临时队列</em><br>如果希望在连接时临时生成一个队列，断开连接后将队列删除，可使用<code>channel.queueDecalare().getQueue()</code>。</p><p><em>bindings</em><br>exchange可以和queue进行绑定，这段绑定关系可以用一个routingKey指定。<br><code>channel.queueBind(queueName,EXCHANGE_NAME,&quot;routingKey&quot;)</code>。</p><p><em>类型分类</em><br>fanout、direct、topic、headers</p><p><em>fanout</em><br>广播交换机，该交换机会把消息转发到所有与其绑定的队列中。</p><p><em>direct</em><br>直连交换机，交换机与各队列绑定时指定了routingKey，只有发布消息时携带的routingKey与绑定key一致时才转发到对应队列，支持多重绑定（不同队列使用同一个routingKey绑定，匹配时都会转发到这些队列中）。</p><p><em>topic</em><br>话题交换机（类似redis的基于模式匹配），使用<code>*</code>代替一个单词，使用<code>#</code>代替0或多个单词。<br>eg:<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Pasted-image-20230401221735.png"></p><p><em>headers</em><br>不使用<code>routingKey</code>，而是使用若干<code>key:value</code>与队列绑定。生产者发送消息时，需要以requestHeader的方式携带<code>key:value</code>，只有与绑定时的某个<code>key:value</code>匹配时才转发到对应队列。</p><p><em>默认交换机</em><br>空字符串即可指定默认交换机，是一个direct型的交换机；创建queue时，会自动为该交换机绑定以队列名为routingKey与队列进行绑定。</p><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p><em>概念</em><br>work模型，即多消费者。</p><p><em>公平性配置</em><br>队列会默认平均分发消息，可配置消费者的<code>listener.simple.prefetch</code>指定一次最多获取消息的数量，消息处理完成回复ack后才会接受新的消息。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p><em>死信来源</em></p><ul><li>TTL：可以为消息和队列设置TTL</li><li>队列达到最大长度</li><li>消息被拒绝（reject）或nack且requeue&#x3D;false（否则会尝试重新获取）</li></ul><p><em>如何使用死信队列</em></p><ul><li>死信交换机：每个需要使用死信的业务队列都需要配置一个死信交换机，死信交换机的类型也是可选择的。同项目可共用一个死信交换机，不过需要为每个队列分配一个独立的路由key。</li><li>死信队列：为死信交换机配置死信队列并将其绑定在死信交换机上，不同死信队列也用不同的路由key绑定。一般每个业务队列都会配置一个死信队列以处理。</li><li>死信路由：每个业务队列可配置一个<code>x-dead-letter-routing-key</code>参数，当某个消息被判定为死信时，其路由会变成该参数的值；若不配置，则保持原路由。</li></ul><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p><em>两种TTL区别</em></p><ul><li>队列TTL：消息在队列中存活超过TTL后立刻被丢弃（或路由到死信交换机）</li><li>消息TTL：消费者消费时判断是否过期，因此会存在消息过期仍未丢弃的情况，且如果先投递的消息延迟时间很久，后面的消息即使会过期了也会一直积压。</li></ul><p><em>延迟队列的实现</em></p><ul><li>利用消息丢弃，可以拒绝一些超时未完成的业务。</li><li>利用死信队列，可以实现一些定时任务，即<strong>延迟队列</strong>。</li></ul><p><em>优化</em></p><ul><li>安装延迟队列插件，其提供了新的路由器类型，其支持消息在路由器的数据表中存储，到达投递时间时，才会投递到对应队列，实现延迟。</li></ul><p><em>其他延迟队列实现</em><br>Java的DelayQueue，Redis的zset，Quartz，Kafka的时间轮。</p><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="可靠投递"><a href="#可靠投递" class="headerlink" title="可靠投递"></a>可靠投递</h3><h4 id="生产者处理投递失败"><a href="#生产者处理投递失败" class="headerlink" title="生产者处理投递失败"></a>生产者处理投递失败</h4><p><em>投递交换机确认（ConfirmCallback）参数配置</em><br><code>spring.rabbitmq.publisher-confirm-type</code>，有以下参数可选：</p><ul><li>NONE：禁用发布确认模式</li><li>CORRELATED：发布消息成功到交换器触发回调方法ConfirmCallback</li><li>SIMPLE：发布消息成功到交换器触发回调方法waitForConfirm等待交换机路由队列的结果，根据结果判断下一步的逻辑。</li></ul><blockquote><p>ConfirmCallBack可以在rabbitTemplate上全局注册，也可以注册在具体消息的关联数据CorrelationData上：<code>correlationData.getFuture().addCallback(result-&gt;&#123;&#125;)</code>。</p></blockquote><h4 id="生产者处理路由失败"><a href="#生产者处理路由失败" class="headerlink" title="生产者处理路由失败"></a>生产者处理路由失败</h4><p><em>路由到队列确认（ReturnCallback）参数配置</em><br><code>spring.rabbitmq.publisher-returns</code>，有以下参数可选：</p><ul><li>false：关闭失败回调</li><li>true：开启失败回调，失败时触发ReturnCallback</li></ul><blockquote><p>在RedisTemplate中可以通过<code>setMandatory(boolean mandatory)</code>方法或者在yml配置文件中通过<code>template.mandatory: true</code>来配置当消息没能路由到指定队列时消息是重回生产者还是丢弃。</p></blockquote><h4 id="备份交换机处理路由失败"><a href="#备份交换机处理路由失败" class="headerlink" title="备份交换机处理路由失败"></a>备份交换机处理路由失败</h4><p><em>目的</em><br>无法路由的消息返回生产者也很难处理，在集群下更需要统一处理。</p><p><em>功能实现</em><br>为原交换机配置备份交换机，当原交换机无法路由消息时，将其转发到备份交换机（Fanout），从而实现对无法路由的消息的消费（单独做报警）</p><p><em>其他</em><br>备份交换机和madatory参数优先级中，备份交换机优先级更高。</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>在业务上一般而言，保证<strong>消费者</strong>的幂等性即可，重复投递是为了保证消息不丢失的必然措施，且mq对每条消息都有一个全局唯一id，可以判断重复的消息。</p><h4 id="重复投递"><a href="#重复投递" class="headerlink" title="重复投递"></a>重复投递</h4><p><em>原因</em><br>队列发送的投递成功的ack丢失，可能造成生产者重复投递。<br><em>解决</em><br>消息队列MQ本身有全局唯一id，可判断重复消息。</p><h4 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h4><p><em>原因</em><br>消费者发送消费成功的ack丢失，可能造成队列向其重复发送。<br><em>解决</em></p><ul><li>全局唯一ID，消费前先去db查询该消息（有性能瓶颈），不存在则正常消费，然后写入db。</li><li>消费者使用redis消费，set&#x2F;setnx操作天然具有幂等性</li></ul><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p><em>优先队列</em><br>将队列设置为优先级队列，投递消息时指定消息的优先级。</p><p><em>惰性队列</em><br>将队列设置成惰性队列，队列会将消息存入磁盘，只有被消费时加载到内存中，主要解决消费者因各种原因可能宕机导致消息堆积的情况。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="集群基础"><a href="#集群基础" class="headerlink" title="集群基础"></a>集群基础</h3><p><a href="https://cloud.tencent.com/developer/article/1174657?from=article.detail.1795578&areaSource=106000.2&traceId=JELSFIqWoI8zLnesxfh4Q">集群全解与docker搭建</a><br><a href="https://juejin.cn/post/7085011568991141919#heading-3">镜像队列策略全解</a></p><p><em>为什么集群？</em><br>高并发、高性能、高可用的需求</p><p><em>节点类型</em></p><ul><li>内存节点</li><li>磁盘节点<ul><li>单节点模式下必须使用磁盘节点，否则可能丢数据。</li><li>集群中至少要有一个磁盘节点，其他节点离开时必须通知磁盘节点。（启动时先启动磁盘节点，关闭时最后关闭磁盘节点）</li><li>如果唯一的磁盘节点崩溃了，不允许对rabbitmq集群做任何修改，只能使用已有的交换机、队列进行生产消费。</li></ul></li></ul><p><em>集群模式</em></p><ul><li>普通模式：分布式集群，节点可转发请求，无法实现高可用</li><li>镜像模式：主从集群，一般3节点以上，同时持有彼此的副本实现高可用</li><li>仲裁队列：与镜像模式类似，由于镜像模式不是强一致的，仲裁队列通过Raft协议保证一致性</li></ul><p><em>rabbitmq集群基础</em></p><ul><li>节点之间通过domain域名识别，所以要修改各节点host文件</li><li>rabbitmq集群基于erlang集群，需要让所有节点的cookie文件值相同，具体为复制一个节点的cookie文件到其他节点覆盖。</li><li>启动一个节点，其他节点逐一加入集群。</li></ul><p><em>docker启动</em></p><ul><li>启动的时候指定hostname和containName，并通过 <code>--link</code>指定其他节点的<code>containName:alias</code>进行连接，alias表示别名。</li><li>其他节点containName,alias都可以作为其hostname由当前节点访问，所以分别进入容器执行mq的集群相关命令</li></ul><p><em>镜像模式配置</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl set_policy mypolicy &quot;^amp*&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2&#125;&#x27;<br></code></pre></td></tr></table></figure><ul><li>name：名称，随意填</li><li>“匹配规则”：正则表达式，匹配集群内的交换机或队列</li><li>“镜像队列：”json：{}<ul><li>ha-mode：镜像模式，可使用all&#x2F;exactly&#x2F;nodes，all表示备份所有队列，excaclt表示随机存储部分数量节点，nodes，表示存储指定存储节点。</li><li>ha-params：作为mode的补充，指定数量或节点名称</li><li>ha-sync-mode：同步方式，automatic表示自动向master同步数据，manually表示手动向master同步数据。</li></ul></li></ul><p><em>集群异常</em></p><ul><li>消息持久化，节点掉线后上线可恢复。</li><li>消息未持久化，双活冗余队列和镜像队列实现可靠性。</li></ul><h4 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式</h4><h5 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h5><p><em>从节点晋升策略</em><br><code>ha-promote-on-shutdown</code>、<code>ha-promote-on-failure</code>分别配置在主节点正常关闭和掉线时，从节点是否需要保证数据同步才提升。</p><p><em>主队列选择策略</em><br><code>queue-master-locator</code>，主队列应该绑定在哪个节点的策略。</p><p><em>多少镜像合适？</em><br>建议复制到（N&#x2F;2+1）个节点。</p><p><em>生产者确认机制</em><br>允许生产者开启事物，只有完成对主队列和所有镜像队列的投递时才收到执行完成的消息。</p><p><em>流控</em><br>生产者只有收到所有镜像授予的信用许可后才能发送新的消息，否则会阻塞。</p><p><em>消费者取消消费</em><br>从镜像队列中消费的客户端希望感知到队列的失败转移，使用<code>x-cancel-on-ha-failover</code>参数进行消费，故障转移发生时，该消费会被取消。此时创建新的消费者进行消费。</p><h5 id="镜像队列数据流"><a href="#镜像队列数据流" class="headerlink" title="镜像队列数据流"></a>镜像队列数据流</h5><p><em>客户端连接主节点时</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/051f3722fd064e08b961581611ab3e04_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"><br><em>客户端连接从节点</em><br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/e1f636d367614a798ae701766d750dd5_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h5 id="镜像队列实现原理"><a href="#镜像队列实现原理" class="headerlink" title="镜像队列实现原理"></a>镜像队列实现原理</h5><p><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/ab1e1b406af641e883bb00c0ec1ab4fb_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><ul><li>amqqueue_process处理协议</li><li>backing_queue是主从节点上特殊的queue</li><li>GM分两部分，一部分负责广播，一部分负责接受消息并回调。其中主节点的回调函数是<code>coordinator</code>、从节点上则是<code>mirror_queue_slave</code>。</li></ul><p><em>GM</em><br>原子广播，所有节点形成链表，消息循环传播回自己则说明同步完成。</p><h5 id="镜像队列缺点"><a href="#镜像队列缺点" class="headerlink" title="镜像队列缺点"></a>镜像队列缺点</h5><ul><li>broker重新上线：此时是否应该从leader同步？可能回丢弃其所有数据。</li><li>同步阻塞：同步镜像耗时太长。</li></ul><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>RabbitMQ中使用Keepalived和HaProxy实现集群的高可用和负载均衡。<br><em>HAProxy</em><br>负载均衡代理，但本身单机也可能宕机，需要集群。<br><em>Keepalived</em><br>协助HAProxy集群，自身也是集群，起类似哨兵的作用，只允许一个master HAProxy，统一了访问路径。（提供一个虚拟IP，由HAProxy集群的节点争夺）<br><em>VRRP</em><br>虚拟路由冗余协议，keepalived这种提供虚拟IP的机制属于VRRP</p><h3 id="集群之间"><a href="#集群之间" class="headerlink" title="集群之间"></a>集群之间</h3><p>为了实现高可用，有一些模式：</p><ul><li>主备模式：主备节点共享存储空间。</li><li>镜像模式：节点之间互相备份的镜像模式。</li><li>远程模式：Shovel集群，模型会变成<strong>近端同步确认</strong>、<strong>远端异步确认</strong>两步。近端集群同步确认后转发给远端。</li><li>多活模式：基于AMQP协议实现多中心通讯（不同于集群），连接双方可以使用不同users和vhost，不同版本MQ。某节点使用federated exchange，实现向远程另一节点订阅消息的功能，并放入本地队列。</li></ul><h2 id="实战代码风格"><a href="#实战代码风格" class="headerlink" title="实战代码风格"></a>实战代码风格</h2><ul><li>使用一个Config类文件，通过@Bean的方式生成所有的队列、交换机、绑定关系。</li><li>使用@RabbitListener做消息回调函数。</li><li>引入依赖，修改序列化方式，在启动类上添加消息转换器：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">jsonMessageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker&amp;K8S</title>
    <link href="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><em>分布式架构</em><br>分布式是一种架构，具有松耦合、扩展性好等特点。</p><p><em>微服务</em><br>微服务则是分布式架构的一种方案。</p><p><em>落地实现</em></p><ul><li>SpringCloud</li><li>Dubbo</li></ul><p><em>微服务架构</em><br><img src="/Pasted%20image%2020230418212829.png"><br><img src="/Pasted%20image%2020230418212907.png"></p><blockquote><p>Dubbo是一个微服务框架，其实现了RPC和服务治理。现常利用其RPC能力，并将其与SpringCloud进行整合。</p></blockquote><p><em>服务拆分原则</em><br>不同服务访问不同的数据库。</p><h1 id="二、SpringCloud"><a href="#二、SpringCloud" class="headerlink" title="二、SpringCloud"></a>二、SpringCloud</h1><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p><em>概念</em><br><strong>SpringCloud</strong>常用的注册中心，其本身也是一个微服务组件。</p><p><em>启动eureka</em></p><ol><li>创建独立项目，添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>启动类上标注：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br></code></pre></td></tr></table></figure><ol start="3"><li>配置文件：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># eureka server占用端口</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-comment"># 为eureka client配置server url，这里配置是因为eureka本身也是client</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span><br></code></pre></td></tr></table></figure><p><em>配置eureka客户端</em></p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置文件同eureka服务配置，修改<code>spring.application.name</code>即可。</li></ol><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p><em>概念</em><br>阿里开源的注册中心。</p><p><em>依赖</em><br>nacos本身是打包好的服务端，直接运行即可，而对于客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>配置</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">HZ</span> <span class="hljs-comment"># 集群名称</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="hljs-comment"># 命名空间，填ID</span><br><br><span class="hljs-comment"># 引入nacos的负载均衡规则，实现集群优先</span><br><span class="hljs-attr">userservice:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><ul><li>添加了Cluster配置的微服务注册到nacos中会被自动分类。</li><li>nacosrule功能为调用优先在同一集群内执行，随机选取。</li></ul><p><em>权重配置</em><br>在nacos可视化界面修改节点权重，默认为1，越小越不可能被随机。</p><p><em>环境隔离</em><br>nacos有默认命名空间，也可以为服务指定命名空间，不同命名空间之间的服务完全隔离，互相不可见。</p><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p><em>配置管理</em><br>可将需要热更新的配置放置在nacos管理，新增时填写配置id和分组、配置信息即可，其中id一般命名为<code>appname-dev.yaml</code>形式。</p><p><em>配置拉取</em><br>bootstrap.yml文件会在application.yml文件之前被读取<br><img src="/Pasted%20image%2020230422170242.png"></p><p><em>依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos配置管理依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>拉取规则</em><br>bootstrap.yml文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#开发环境，这里是dev </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># Nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br></code></pre></td></tr></table></figure><p>会从server-addr拉取<code>userservice-dev.yaml</code>配置文件。</p><p><em>热更新</em></p><ul><li>方式一：在@Value注入的变量的<strong>类</strong>上注解@RefreshScope。</li><li>方式二：使用@ConfigurationProperties注解一个配置类，该类的变量会得到热更新，其他类可以通过引用该配置类获取配置。</li></ul><p><em>配置共享</em><br>nacos中配置id不标注环境，即为：application.name.yaml时，可被多环境共享。</p><p><em>配置优先级</em><br><img src="/Pasted%20image%2020230422171030.png"></p><h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><ul><li>配置数据库：nacos0.7版本后提供数据库存储数据，使用nacos-mysql.sql语句初始化数据库<code>nacos-config</code>，然后配置<code>application.properties</code>文件的数据库访问url；</li><li>修改每个nacos服务目录下的<code>application.properties</code>文件，修改端口；</li><li>修改每个nacos服务目录下的<code>cluster.conf.example</code>文件，并将其后缀<code>.example</code>删除，如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs conf">ip1:port1<br>ip2:port2<br>ip3:port3<br></code></pre></td></tr></table></figure><h3 id="注册中心对比"><a href="#注册中心对比" class="headerlink" title="注册中心对比"></a>注册中心对比</h3><p><em>实例类型</em><br>nacos有临时实例和非临时实例两种实例，其中临时实例在宕机超时后会被剔除。</p><p><em>心跳对比</em><br><img src="/Pasted%20image%2020230419003048.png"></p><ul><li>Eureka：实例主动向注册中心发送心跳。</li><li>Nacos：临时实例主动向注册中心发送心跳，注册中心主动询问非临时实例的心跳</li></ul><p><em>服务发现</em></p><ul><li>Eureka：只支持拉取。</li><li>Nacos：支持拉取和注册中心主动推送，实现更新。</li></ul><p><em>CAP</em></p><ul><li>Eureka：AP模式（保证可用性）</li><li>Nacos：默认AP，集群中存在非临时实例时，使用CP（保证一致性）</li></ul><h2 id="调用组件"><a href="#调用组件" class="headerlink" title="调用组件"></a>调用组件</h2><h3 id="负载均衡（Ribbon）"><a href="#负载均衡（Ribbon）" class="headerlink" title="负载均衡（Ribbon）"></a>负载均衡（Ribbon）</h3><p><strong>Ribbon</strong>是SpringCloud<strong>默认</strong>依赖的负载均衡类。<br><em>LoadBalanced</em><br>需要<strong>手动</strong>配合RestTemplete可以实现负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-keyword">public</span> RestTemplete <span class="hljs-title function_">restTemplete</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplete</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><em>底层实现</em></p><ul><li>RestTemplete使用服务名替换域名发起请求。</li><li>@LoadBalanced实现切面，发起请求时先到注册中心拉取服务名对应的服务节点列表，并实现负载均衡。</li></ul><p><img src="/Pasted%20image%2020230418223553.png"></p><p><em>修改负载均衡</em></p><ol><li>代码方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> IRule <span class="hljs-title function_">randomRule</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>配置方式</li></ol><p>对需要做负载均衡的服务（如本服务希望以指定的负载均衡方式调用userservice），则可以将本配置添加到本服务配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span> <span class="hljs-comment"># 负载均衡规则 </span><br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</code>属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>较好的策略是ZoneAvoidanceRule，即优先轮询同一个区域内的服务器。</p><p><em>饥饿加载</em><br>默认懒加载，开启以下配置则开启饥饿加载。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><p><em>服务列表更新</em><br>Ribbon定时向服务器拉取服务列表并缓存（默认）和Ribbon订阅事件两种方式。</p><h3 id="远程调用（Feign）"><a href="#远程调用（Feign）" class="headerlink" title="远程调用（Feign）"></a>远程调用（Feign）</h3><p><em>概念</em><br>上文提到默认使用了restTemplete发起请求，但代码可读性和可维护性较差。因此引入Feign，其是一个声明式http客户端。</p><p><em>依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类上添加注解开启Feign功能：<code>@EnableFeignClients</code></p><p><em>使用</em><br>编写客户端，本质上就是写一个调用<strong>接口</strong>，创建了一个针对userservice服务的客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>配置使用</em></p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE（默认值）、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign.contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign.retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr><tr><td>配置文件方式：</td><td></td><td></td></tr></tbody></table><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span> <br>      <span class="hljs-attr">userservice:</span> <span class="hljs-comment"># 针对某个微服务的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span> <span class="hljs-comment">#  日志级别 </span><br></code></pre></td></tr></table></figure><p>代码方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写以下类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfiguration</span>  &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.BASIC; <span class="hljs-comment">// 日志级别为BASIC</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在启动类上添加@EnableFeignClients注解，表示全局配置</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> <br><br><span class="hljs-comment">//在Feign类上添加@EnableFeignClients注解，表示局部配置</span><br><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span><br></code></pre></td></tr></table></figure><p>显然代码方式可以做到更细的颗粒度。</p><p><em>优化</em><br>Feign底层发起http请求依赖于其他框架，实现有：</p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>可替换其底层框架使用连接池优化，具体为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--httpClient的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-comment"># default全局的配置</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">BASIC</span> <span class="hljs-comment"># 日志级别，BASIC就是基本的请求和响应信息</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对HttpClient的支持</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 最大的连接数</span><br>    <span class="hljs-attr">max-connections-per-route:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 每个路径的最大连接数</span><br></code></pre></td></tr></table></figure><p><em>最佳实践</em><br>FeignClient与被调用方的Controller很类似，希望能减少代码重复编写。</p><ul><li>继承方式：编写一个UserAPI接口，FeignClient和Controller分别继承该接口。<ul><li>特点：简单、实现了代码共享；耦合度高、且注解映射无法继承，Conrtoller必须再次声明发布方法、参数列表、注解。<strong>基本不考虑使用。</strong></li></ul></li><li>抽取方式：将Feign的Client抽取到一个feign-api包中，所有微服务可引用该依赖包来实现对其他微服务的调用。<ul><li>特点：为所有微服务只需要编写一个feign-api包即可，实现所有微服务的Feign代码共享。</li><li>使用：需要解决包扫描问题，引入feign-api包后，需要全局修改启动类<code>@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</code>扫描包。</li></ul></li></ul><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p><em>核心功能</em><br><img src="/Pasted%20image%2020230422175957.png"></p><ul><li>权限控制</li><li>路由和负载均衡</li><li>限流</li></ul><p><em>网关实现</em></p><ul><li>Zuul：基于Servlet实现，阻塞式编程</li><li>SpringCloud GateWay：基于WebFlux实现，响应式编程，性能更好</li></ul><h3 id="SpringCloud-GateWay"><a href="#SpringCloud-GateWay" class="headerlink" title="SpringCloud GateWay"></a>SpringCloud GateWay</h3><p><em>依赖</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>配置</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment"># 网关端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span> <span class="hljs-comment"># nacos地址</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 网关路由配置</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 路由id，自定义，只要唯一即可</span><br>          <span class="hljs-comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <span class="hljs-comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <span class="hljs-comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></code></pre></td></tr></table></figure><h4 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h4><p>断言本质就是一种条件判断，不同的断言工厂提供了不同的判断条件，通过条件判断的请求才会被路由。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver],  2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method&#x3D;GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query&#x3D;name, Jack或者-  Query&#x3D;name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td>Weight</td><td>权重处理,在servicename中，权重值为x</td><td>-Weight&#x3D;servicename,5</td></tr></tbody></table><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p><img src="/Pasted%20image%2020230422181240.png"></p><p><em>过滤器种类</em></p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><p><em>使用</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>  <span class="hljs-comment"># 只对通过断言的请求执行对应的过滤器</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span> <br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://userservice</span> <br>        <span class="hljs-attr">predicates:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/user/**</span> <br>        <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <span class="hljs-comment"># 添加请求头</span><br>      <span class="hljs-comment">#对所有路由执行的过滤器</span><br>      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># 默认过滤项</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Truth,</span> <span class="hljs-string">Itcast</span> <span class="hljs-string">is</span> <span class="hljs-string">freaking</span> <span class="hljs-string">awesome!</span> <br></code></pre></td></tr></table></figure><p><em>自定义全局过滤器</em><br>自定义过滤器可以实现更具体的登录状态、限流、权限功能，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 1.获取请求参数</span><br>        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();<br>        <span class="hljs-comment">// 2.获取authorization参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> params.getFirst(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-comment">// 3.校验</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(auth)) &#123;<br>            <span class="hljs-comment">// 放行</span><br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">// 4.拦截</span><br>        <span class="hljs-comment">// 4.1.禁止访问，设置状态码</span><br>        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);<br>        <span class="hljs-comment">// 4.2.结束处理</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>过滤器执行顺序</em></p><ul><li>按照各过滤器的order值，越小越先执行；</li><li>路由过滤器和默认过滤器的order由spring指定，默认按声明顺序从1递增；</li><li>order相同时，按照defaultFilter&gt;routeFilter&gt;globalFilter顺序执行；<br><img src="/Pasted%20image%2020230422182309.png"></li></ul><p><em>跨域问题</em><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域问题介绍</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-comment"># 。。。</span><br>      <span class="hljs-attr">globalcors:</span> <span class="hljs-comment"># 全局的跨域处理</span><br>        <span class="hljs-attr">add-to-simple-url-handler-mapping:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 解决options请求被拦截问题</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-comment"># 允许哪些网站的跨域请求 </span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;http://localhost:8090&quot;</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-comment"># 允许的跨域ajax的请求方式</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;GET&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;POST&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;DELETE&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;PUT&quot;</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;OPTIONS&quot;</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment"># 允许在请求中携带的头信息</span><br>            <span class="hljs-attr">allowCredentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否允许携带cookie</span><br>            <span class="hljs-attr">maxAge:</span> <span class="hljs-number">360000</span> <span class="hljs-comment"># 这次跨域检测的有效期</span><br></code></pre></td></tr></table></figure><h1 id="X、服务保护"><a href="#X、服务保护" class="headerlink" title="X、服务保护"></a>X、服务保护</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><em>雪崩问题</em><br>某个服务出现故障，依赖该服务的的服务也会被阻塞，从而形成级联失败。<br><img src="/Pasted%20image%2020230420153707.png" alt="服务D故障导致链路服务都发生故障"></p><p><em>解决方案</em></p><ul><li>超时处理：请求超时没得到响应即返回，不会无休止等待。</li><li>仓壁模式：业务线程限制，限制每个业务的最大线程数，避免影响其他业务。</li><li>断路器：统计<strong>异常比例</strong>，超出阈值则熔断。</li><li>限流（预防性措施）：为服务做限流处理。</li></ul><p><em>实现</em></p><table><thead><tr><th></th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离&#x2F;信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="介绍与使用"><a href="#介绍与使用" class="headerlink" title="介绍与使用"></a>介绍与使用</h3><p><em>介绍</em><br><a href="https://sentinelguard.io/zh-cn/index.html">官网</a></p><p><em>依赖</em><br>为微服务引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改微服务配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span> <br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span><br></code></pre></td></tr></table></figure><p>完成后，对该微服务的端点调用会触发sentinel监控。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><em>簇点链路</em><br>Controller -&gt; Service -&gt;Mapper调用链是一个簇点链路，每个节点都是一个<strong>资源</strong>。资源是流控、降级、热点参数限流、授权的基本控制单元。</p><p><em>流控阈值设置</em></p><ul><li>QPS：限制每秒最大请求数</li><li>线程数：限制业务最大线程数（需要配合FeighClient一起使用）</li></ul><p><em>流控模式</em></p><ul><li>直接：根据自身的QPS或线程数控制流量</li><li>关联：当<strong>关联资源</strong>触发阈值时，对<strong>当前资源</strong>限流</li><li>链路：只有从<strong>指定入口</strong>进入当前资源的请求才会被限流。</li></ul><blockquote><p>其中：</p><ul><li>关联模式常用于两个竞争关系资源，可限制优先级，比如写业务频繁则限制读业务。</li><li>链路模式用于存在调用关系的资源，即限制某个资源对当前资源的调用。</li></ul><p>另外，Sentinel默认会给进入MVC的请求设置同一个资源，即将一个服务调用（Controller-&gt;Service-&gt;Mapper）视为一个资源节点，如果需要将Service类中的方法单独视为资源，应该：主动为其添加注解@SentinelResource(“resource_name”)</p></blockquote><p><em>流控效果</em></p><ul><li>快速失败：达到阈值后直接返回flowexception。</li><li>warm up：预热模式，根据设置的<strong>预热时间</strong>，阈值从1&#x2F;3最大阈值逐渐升高到最大阈值</li><li>排队等待：超阈值请求排队等待，如果排队等待的预计等待时间（前面的请求数 × 平均请求处理时间）超过<strong>指定时间</strong>，则返回flowexception。</li></ul><p><em>热点参数限流</em></p><ul><li>全局参数限流：设置参数索引、单机阈值、统计窗口。表示<strong>统计窗口</strong>内<strong>参数索引</strong>位置上相同的参数的请求不能超过<strong>阈值</strong>。</li><li>热点参数限流：在全局参数限流的基础上，独立限制某个<strong>具体参数的请求值</strong>的阈值。</li></ul><blockquote><p>在热点参数限制中，MVC中所有资源无效，需要利用@SentinelResource注解标记资源。</p></blockquote><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p><em>机制</em><br>断路器使用了状态机实现功能：<br><img src="/Pasted%20image%2020230420210113.png"></p><p><em>熔断策略</em></p><ul><li>慢调用：<strong>统计时间</strong>内，时长超过<strong>最大RT</strong>的请求比例大于<strong>比例阈值</strong>，且总请求数大于<strong>最小请求数</strong>，则熔断<strong>指定时长</strong>。</li><li>异常比例：<strong>统计时间</strong>内，异常请求数量大于<strong>比例阈值</strong>，且总请求数大于<strong>最小请求数</strong>，则熔断<strong>指定时长</strong>。</li><li>异常数：<strong>统计时间</strong>内，异常请求数量大于<strong>异常数</strong>，且总请求数大于<strong>最小请求数</strong>，则熔断<strong>指定时长</strong>。</li></ul><h3 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h3><p>todo，GateWay学完后补充</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><em>数据流</em><br>dashboard是sentinel控制台，core是微服务的sentinel依赖。</p><ul><li>sentinel dashboard启动在指定的ip和port上；</li><li>sentinel core通过配置dashboard的ip和port与dashboard建立连接；</li><li>sentinel core通过HeartbeatSender向dashboard发送自己的存活信息，包括ip和port，dashboard将该信息保存；</li><li>sentinel core通过CommandCenter向dashboard提供数据请求服务，dashboard通过http向sentinel core请求数据。<br><img src="/2023/03/27/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5417792-3d9042c0162c45c0.webp"></li></ul><p><em>实现原理</em></p><ul><li>每个资源都通过一个Entry对象维护资源的流量控制功能；</li><li>整个调用链路是通过 Entry 的父子指针来描述的，SphU.Entry对象有如下属性：<ul><li>上下文对象context，贯穿整个请求的过程，保存于ThreadLocal中，每次调用链路开始都会创建一个context实例。保存有入口名称、调用根节点、调用源、当前执行点Entry。</li><li>资源对象，包括资源名、入口&#x2F;出口流量，资源类型。</li><li>ProcessSlot链，一个责任链，判断请求是否能否进入，通过SpiOrder可以设置各slot优先级。</li></ul></li></ul><p><img src="/Pasted%20image%2020230420213145.jpg"></p><ul><li>entry.exit()：资源访问完毕后退出，为每个slot做一些资源清理和数据统计。</li></ul><blockquote><p>集群环境统计某一资源的所有访问量，Sentinel 中还对统计量进行了聚合，聚合后的统计节点会包含某一资源在不同入口下的所有访问量（称之为 ClusterNode），Sentinel 为了能够根据访问源进行流控还会针对每一个资源的每一类访问源分别进行流量统计（称之为 OriginNode）：</p></blockquote><p><img src="/Pasted%20image%2020230420214041.png"><br><em>资源访问链</em></p><ul><li>资源的根节点为machine-root</li><li><code>ContextUtil.enter(resourceName,appname)</code>表示调用进入该resourceName节点，该节点将被作为入口节点。</li><li><code>SphU.entry(&quot;nodeA&quot;)</code>表示调用进入nodeA节点，并会经过该资源节点entry的slot链（entry中的clusterNode节点记录并提供资源的统计数据）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ContextUtil.enter(<span class="hljs-string">&quot;entrance1&quot;</span>, <span class="hljs-string">&quot;appA&quot;</span>); <br><span class="hljs-type">Entry</span> <span class="hljs-variable">nodeA</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeA&quot;</span>); <br><span class="hljs-type">Entry</span> <span class="hljs-variable">nodeB</span> <span class="hljs-operator">=</span> SphU.entry(<span class="hljs-string">&quot;nodeB&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>分布式</category>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>分布式</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据类型与结构"><a href="#一、数据类型与结构" class="headerlink" title="一、数据类型与结构"></a>一、数据类型与结构</h1><p>基本数据结构：String、List、Set、Zset、Hash<br>高级数据结构：Bitmap、Geo、HyberLogLog、Stream</p><h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><p>type和encoding共同实现了redis对象的多态处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230103190014.png"></p><p><em>对象共享</em><br>redis也有常量池，存了命令返回值（”OK”）和10000以内整数，但不是所有对象都共享，否则复杂度较高，用其换取内存不划算。</p><p><em>引用计数</em><br>refCount引用计数归零后可被回收</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><em>编码</em><br>有三种编码类型：int、embstr、raw，其中字符串内容的字节超过一定阈值（不同版本阈值不一样）时使用raw。<br>int：long对象，与RedisObject一起分配内存。<br>embstr：SDS对象，与RedisObject一起分配内存，不可变（<strong>只读</strong>）。<br>raw：SDS对象，与RedisObject分开分配内存，可变。</p><p><em>限制</em><br>value最多容纳512M。</p><p><em>应用</em><br>缓存对象，计数，<strong>分布式锁</strong>（SETNX实现「key不存在才插入」，同时设置过期时间PX），Session（分布式环境下去同一个Redis）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET lock_key unique_value NX PX 10000<br></code></pre></td></tr></table></figure><p>优点：高性能，实现方便，避免单点故障<br>缺点：超时时间不好设置（解决：使用守护线程续约枷锁）、异步复制可能导致不可靠。</p><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>简单动态字符串（simple dynamic string,SDS）</p><p><em>组成</em><br><code>len</code>(字符串长度)+<code>alloc</code>(分配的字节数)+<code>flags</code>(类型标志)+<code>buf[]</code>(数据)<br><code>alloc-len</code>可以得到剩余空间的大小，作为是否需要扩容的依据。</p><p><em>优点</em></p><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。<ul><li>小于1MB时，翻倍扩容</li><li>大于1MB时，多给1MB空间</li></ul></li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li><li><strong>动态分配内存</strong>：节省空间，还会禁止编译器做优化对齐。</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>按插入顺序排序。</p><p><em>编码</em><br>List 类型的底层数据结构是由<strong>双向链表</strong>或<strong>压缩列表</strong>实现的（元素个数小于512个且都小于64字节时使用压缩链表，否则使用双向链表。）<br>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 <strong>Quicklist</strong> 实现了。</p><p><em>应用</em><br>消息队列（不支持消费组）</p><ul><li>为避免消费者循环读取，提供了阻塞式读取。</li><li>若要处理重复信息：需要为每个消息打上全局ID。</li><li>消费者读取时将其存在另一个待完成list（备份）中。</li></ul><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cadf797496816eb343a19c2451437f1e.webp"><br>dup、free、match是可以自定义实现的函数。</p><p><em>优点</em><br>在于访问&#x2F;添加头节点尾节点快<br><em>缺点</em><br>在内存碎片多且浪费大</p><h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/a3b1f6235cf0587115b21312fe60289c.webp"><br><em>组成</em></p><ul><li>zlbytes，记录整个压缩列表占用内存字节数（整个内存）；</li><li>zltail，记录压缩列表「尾部」节点距离起始地址由多少字节（entryN起始位置，便于查找），也就是列表尾的偏移量；</li><li>zllen，记录压缩列表包含的节点数量；</li><li>zlend，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li></ul><p><em>Entry组成</em></p><ul><li>prevlen，上一个节点的长度（占用1字节或5字节：以254字节为分界）</li><li>encoding，指定类型为字符串或整数以及其长度（整数占1字节，字符串占1&#x2F;2&#x2F;5字节）。</li><li>data，实际数据</li></ul><p><em>特点</em></p><ul><li>每个entry保存了本entry长度和前一个entry的长度，便于逆向搜索</li><li>每个entry的类型根据实际长度灵活变化</li></ul><p><em>优点</em><br>省空间</p><p><em>缺点</em></p><ul><li>entry内容变化时会改变prelen，prelen因此也变化长度，可能需要<strong>连锁更新</strong>；</li><li>节点数量过多时，搜索缓慢</li></ul><h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/f46cbe347f65ded522f1cc3fd8dba549.webp"><br>双向链表 + 压缩列表（控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题）。</p><h4 id="ListPack"><a href="#ListPack" class="headerlink" title="ListPack"></a>ListPack</h4><p>Redis7.0中取代了压缩列表<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/c5fb0a602d4caaca37ff0357f05b0abf.webp"><br>整体结构：相比压缩列表，少了尾部指针。<br>Entry结构：相比压缩列表，len放在末尾标识本entry长度，同样可以倒序。<br>暂未使用。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><em>编码</em><br><strong>压缩列表</strong>（元素个数小于512个，所有值小于64字节）或<strong>哈希表</strong></p><p><em>应用</em><br>缓存对象</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><code>dict</code> -&gt; <code>dictht</code> -&gt; <code>dictEntry[]</code><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2fedbc9cd4cb7236c302d695686dd478.webp"></p><p><em>rehash</em><br>触发条件：</p><ol><li>负载因子大于1且没有bgsave或bgrewriteaof任务。</li><li>负载因子大于5时。<br>过程：</li><li>正常过程写入<code>ht1</code>中。</li><li>扩容时，为<code>ht2</code>赋予一个长度为2倍<code>ht1</code>的哈希表。</li><li>逐步迁移数据。</li><li>释放「ht1」，并使用「ht2」替换「ht1」。</li></ol><p><em>渐进式rehash</em></p><ul><li>给「ht2」分配空间</li><li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis除了会执行对应的操作（查找时先找old再找new，新增时直接添加在new上）之外，还会顺序将「ht1」中索引位置上的所有 key-value 迁移到「ht2」上；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「ht1」的所有 key-value 迁移到「ht2」，从而完成 rehash 操作。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>无序集合，成员唯一。</p><p><em>编码</em><br>整数集合（元素数量不超过512）或哈希表</p><h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p><em>组成</em></p><ul><li><code>encoding</code>：标识整数的类型（int16、int32、int64）；</li><li><code>length</code>：记录压缩列表「尾部」节点距离起始地址由多少字节（entryN起始位置，便于查找），也就是列表尾的偏移量；</li><li><code>contents[]</code>：记录压缩列表包含的节点。</li></ul><p><em>升级</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/e84b052381e240eeb8cc97d6b729968b.webp"><br><strong>节省内存资源</strong>。且不支持降级。</p><p><em>应用</em><br>点赞、共同关注</p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>权重排序</p><p><em>编码</em><br><strong>压缩列表（小于128个元素，且元素小于64B）</strong> 或 <strong>跳表（加哈希表）</strong></p><p><em>应用</em><br>排行榜</p><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>注意跳表是结合了dict结构使用的，但dict主要起常数时间获取权重的作用。<br><em>结构</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323223354.png"><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323215824.png"><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.webp"></p><ol><li>zskiplistNode：其包含ele（数据），score（权重），backward（前一个节点指针，便于后序遍历），zskiplistLevel数组；</li><li>zskipLevel：记录了指向节点的指针和距离；</li><li>zskipList：记录头尾指针、链表长度、最大层数。</li></ol><p><em>设计细节</em><br>查询</p><ul><li>为了实现快速跳跃，从<strong>头节点的最高层</strong>开始搜索：发现目标节点在该节点之后（目标权重更高或权重相同但键更大），继续同层搜索，否则降层搜索。<br>层次</li><li>相邻两层的节点数量的比例会影响跳表的查询性能，理想的比例是1:2，但会带来调整开销，所以选择随机生成每层的节点数：循环生成一个<code>[0,1]</code>的随机数，其小于0.25则加一层，直到大于0.25。最高为64层。</li><li>头节点不保存数据，64层。</li></ul><p><em>为什么使用跳表而不是红黑树？</em></p><ol><li>范围查找跳表更方便，找到端点后遍历即可，红黑树还要想办法中序遍历。</li><li>内存占比上，每个节点的指针更少。</li><li>算法实现更简单，不需要调整。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>String：int&#x2F;SDS(embstr，raw)</li><li>List：ziplist&#x2F;linkedlist -&gt; quicklist(3.2) -&gt; ListPack</li><li>Hash：ziplist&#x2F;dict</li><li>Set：intset&#x2F;dict</li><li>Zset：ziplist&#x2F;skip</li></ul><p>list，hash，set，Zset都试图使用<strong>压缩列表</strong>（排序的压缩列表或整数集合）来处理数量小于512&#x2F;512&#x2F;512&#x2F;128个且大小都小于64字节的元素集合，否则使用高级数据结构。</p><h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>统计01<br><em>原理</em><br>string，二进制字节数组</p><p><em>应用</em><br>签到统计</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>不精确的去重计数，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数。</p><p><em>应用</em><br>日活</p><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>保存经纬度</p><p><em>编码</em><br>Zset</p><p><em>应用</em><br>打车</p><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>消息队列（基于内存的不可靠版）</p><p><em>特点</em></p><ul><li>可自动生成不重复、<strong>递增</strong>的id（eg：时间戳-序号）。</li><li>有消费组，组内消费者为竞争关系。</li><li>每个消费组维护一个pending_ids，保证可靠性。只有消费者回复ACK后才将其标记为完成，消费者宕机重启后可查看未处理完的消息。</li><li>其他消费组也可以将目标消费者<strong>超时未处理</strong>的消息转移到自己的pending列表</li><li>死信，转发一定次数后都无法被消费者处理的消息，可输出XDEL。</li></ul><p><em>与专业消息队列的差别</em></p><ul><li>redis基于内存，宕机时磁盘中不是最新数据，主从切换时同理。专业消息队列基于集群，有多个副本。</li><li>redis基于内存，可能OOM，而Kafka和RabbitMQ基于磁盘</li></ul><p><em>Stream会丢消息吗？</em></p><ul><li>生产者处理好与队列的ACK确认就，不会发生丢失。</li><li>消费者将消息处理完成后再XACK，不会发送丢失。</li><li>中间件会丢消息吗？会，AOF时没完成写盘，或主从复制切换。</li></ul><p><em>Stream能处理消息挤压吗？</em><br>Stream能指定最大长度，超出后旧消息会被删除。而传统MQ则会存在内存中。</p><h3 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h3><p>发布订阅是redis开放的一个通讯功能，消息队列stream是对其可靠性的补充。<br><em>两种发布&#x2F;订阅模式</em></p><ul><li>基于频道(Channel)的发布&#x2F;订阅：频道以哈希表结构保存，订阅同一频道的消费者以链表保存，发布的消息只发布给对于频道的消费者。</li><li>基于模式(pattern)的发布&#x2F;订阅：模式以链表结构保存，发布消息时，对每个模式进行表达式对比，然后选择发送。</li></ul><p><em>发布订阅方式（只适合即时通讯场景）为什么不能做消息队列</em></p><ul><li>不具有数据持久化</li><li>不保存历史信息</li><li>消息挤压时，消费者可能被强制断开</li></ul><h1 id="二、持久化"><a href="#二、持久化" class="headerlink" title="二、持久化"></a>二、持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><em>流程</em><br>主线程阻塞进行或子线程后台进行，使用COW技术应对主线程的修改。</p><p><em>执行策略</em></p><ul><li>主动执行：<ul><li>save&#x2F;bgsave</li></ul></li><li>自动执行：<ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul></li></ul><p><em>特点</em></p><ul><li>文件小，且加载速度快。</li><li>全量快照，执行缓慢，实时性差。</li></ul><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><em>流程</em><br>主线程先执行命令，成功后写入aof_buf<strong>内核</strong>缓冲区，aof_buf根据策略刷新到磁盘。</p><p><em>写回策略</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/98987d9417b2bab43087f45fc959d32a.webp"><br>底层：在不同的时间点调用<code>fsync()</code>函数。（请求将内核缓冲区内容立刻刷盘）</p><p><em>重写机制</em><br>会使用<em>bgrewriteaof</em>后台重写：<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/t_70-20230309231944807.webp"></p><ul><li>fork子进程（复制虚拟页表，<strong>第一次阻塞</strong>）</li><li>主线程同时需要完成写内存，写aof缓存（仍正常刷盘在原文件上），写aof重写缓存（方便后续追加在重写文件上）</li><li>使用CopyOnWrite技术（复制物理内存，<strong>第二次阻塞</strong>，如果修改的是bigkey，则阻塞更久）和解决一致性；</li><li>子线程完成rewrite，发送<strong>信号</strong>（<strong>第三次阻塞</strong>），通知主线程追加aof命令和改名<strong>原子覆盖</strong>。</li></ul><p><em>重写触发</em></p><ul><li>当前文件大小超过上次重写后的百分之多少。</li><li>当前文件大小超过设置大小。</li></ul><h2 id="RDB和AOF混合持久化"><a href="#RDB和AOF混合持久化" class="headerlink" title="RDB和AOF混合持久化"></a>RDB和AOF混合持久化</h2><p><em>开启</em></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">aof-<span class="hljs-keyword">use</span>-rdb-preamble yes<br></code></pre></td></tr></table></figure><p><em>流程</em><br>AOF文件：前半部分记录RDB内容，后半部分记录AOF部分。本质是通过 <strong>AOF 后台重写</strong>触发完成的，会重新生成RDB内容，并将期间产生的AOF部分添加在AOF文件后面。</p><p><em>加载流程</em><br>优先加载AOF，不存在再加载RDB。</p><h2 id="big-key"><a href="#big-key" class="headerlink" title="big key"></a>big key</h2><p><em>Big Key的影响</em></p><ul><li>客户端超时</li><li>网络阻塞</li><li>DEL阻塞</li><li>内存分布不均匀</li><li>AOF日志：刷盘阻塞耗时</li><li>AOF重写：快速触发重写，拷贝大虚拟页表阻塞耗时，如果对big key写，COW的物理内存复制也阻塞耗时。</li></ul><p>寻找Big Key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --bigkeys<br></code></pre></td></tr></table></figure><p><em>避免Big Key</em></p><ul><li>拆分big key</li></ul><p>删除Big Key</p><ul><li>对其的删除使用unlink，异步延迟释放内存。</li><li>分批次删除</li></ul><p><em>Linux开启内存大页</em><br>会允许以2MB为单位分配内存，会导致小数据修改也要在COW中拷贝大页。</p><h1 id="三、事件机制"><a href="#三、事件机制" class="headerlink" title="三、事件机制"></a>三、事件机制</h1><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.webp"><br><em>Redis事件处理模型</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235505.png"></p><p><code>aeEventLoop</code>是事件驱动的核心，同时管理<strong>文件事件</strong>和<strong>时间时间</strong>。</p><p><em>Redis与IO多路复用</em><br>redis支持select、epoll、kqueue等技术，适配操作系统实现。</p><p><em>Redis文件事件</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323235714.png"><br>使用<strong>Redis文件事件处理器</strong>实现<strong>连接应答</strong>、<strong>请求处理</strong>、<strong>响应处理</strong>等事件的分发。</p><p><em>Redis时间事件</em><br>时间事件执行器运行时，遍历整个时间事件<strong>无序链表</strong>，查找已经到达的时间事件并调用相应事件处理器。</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><blockquote><p>Redis一般只使用<code>serverCron</code>时间事件，用于统计，删除过期键，RDB，AOF，同步，心跳等，周期执行</p></blockquote><p><em>实现</em><br>初始化函数<code>initServer</code>创建了aeEventLoop对象，初始化文件、时间事件表，创建epoll实例。<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000231.png"></p><h1 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h1><p><em>语句</em><br><code>MULTI</code>开启事务，<code>EXEC</code>执行事务，<code>DISCARD</code>取消事务。</p><p><em>回滚</em><br>Redis不支持回滚：</p><ul><li>若出现语法错误，整个事务不执行。</li><li>若出现类型错误，错误语句执行失败，其他语句依然执行。</li></ul><p><em>ACID</em><br>A：<strong>官方认为支持</strong>原子性，要么全执行要么全不执行（不保证每个语句都执行成功）。<br>C：<strong>支持</strong>，WATCH锁<br>I：<strong>支持</strong>，单线程<br>D：<strong>不支持</strong>，AOF刷盘时机 ，RDB间隔都可能丢数据。</p><p><em>乐观锁</em></p><ul><li><code>WATCH KEY</code>：在<code>MULTI</code>前执行，在<code>EXEC</code>时若发现KEY被修改，则不会执行事务。</li><li><code>UNWATCH</code>：取消对所有key的监视。</li></ul><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324000718.png"></p><h1 id="五、删除策略和淘汰策略"><a href="#五、删除策略和淘汰策略" class="headerlink" title="五、删除策略和淘汰策略"></a>五、删除策略和淘汰策略</h1><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p><em>设置过期时间</em><br><code> expire key 100</code></p><p><em>过期判断</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230323234744.png"><br>redis会将会过期的键放在过期字典（key:expire）中，get key时，先在字典中搜索，看是否存在以及是否过期。</p><p><em>删除策略</em></p><ul><li>定时删除</li><li>定期删除（定期删除行为会在ServerCron函数中执行）</li><li>惰性删除</li></ul><p>Redis 选择「<strong>惰性删除+定期删除</strong>」这两种策略配和使用</p><blockquote><p>对于RDB，其不会记录已经删除的键<br> 对于AOF文件，键过期后会在文件后面加上DEL key的命令，重写时则不会记录该key。</p></blockquote><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p><em>内存淘汰策略</em></p><ol><li>noeviction：写满了就停止服务。</li><li>volatile-ttl：对即将过期的时间进行排序，删除</li><li>volatile-random：对会过期的键随机删除</li><li>volatile-lru(last-recently-used)：对最后使用时间进行排序，删除最后一次使用较早的数据</li><li>volatile-lfu（4.0后新增）：对使用次数进行排序，删除最少使用的数据</li><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ol><p><em>redis实现lru&#x2F;lfu淘汰</em><br>lru模式：最近最少使用，用redisObject的lru字段（24位记录时间戳）记录，会造成<strong>缓存污染</strong><br>lfu模式：最近最不常用，用redisObject的lru字段（16位记录时间戳，8位记录访问次数，会衰减）。<br>随机选一批数据，排序。</p><p><em>原理</em><br>新数据进入redis时，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，则执行淘汰算法。</p><h1 id="六、高可用"><a href="#六、高可用" class="headerlink" title="六、高可用"></a>六、高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><em>作用</em></p><ul><li>数据冗余 -&gt; 故障恢复</li><li>负载均衡</li><li>读写分离</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><em>初次建立连接（全量复制）</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/ea4f7e86baf2435af3999e5cd38b6a26.webp"><br>注意点：</p><ul><li><strong>psync</strong>请求可以和aof刷盘的fsync联合记忆</li><li><strong>runID</strong>和复制进度<strong>offset</strong>。</li><li>最后发送<strong>replcation buffer</strong>。</li></ul><p><em>命令传播</em><br>长连接！<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/03eacec67cc58ff8d5819d0872ddd41e.webp"></p><p><em>再次连接（增量复制）</em><br>注意：</p><ul><li><strong>repl_backlog_buffer</strong>，「环形」缓冲区。</li><li><strong>replication offset</strong>，标记缓冲区的同步进度。<ul><li>主服务器使用 <code>master_repl_offset</code> 来记录自己「_写_」到的位置。</li><li>从服务器使用 <code>slave_repl_offset</code> 来记录自己「_读_」到的位置。</li></ul></li></ul><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2db4831516b9a8b79f833cf0593c1f12.webp"><br>若<code>slave_repl_offset</code>在<code>repl_backlog_buffer</code>中，则会将增量数据写入<code>replication buffer</code>，继续传播。否则，全量复制。</p><blockquote><p>可适当调节repl_backlog_buffer避免频繁全量复制。</p></blockquote><p><em>心跳机制</em><br>主节点：10秒ping一次从节点。<br>从节点：1秒发送一次replconf ack{offset}上报存活和当前复制进度。</p><p><em>过期key</em><br>主节点发送DEL KEY指令给从节点。<br>Redis3.2版本后，从节点也会判断过期数据。</p><p><em>replication buffer 、repl backlog buffer</em></p><ul><li>一个主节点只分配一个 repl backlog buffer，满了之后覆盖。</li><li>每个从节点分配一个replication buffer，满了之后断开连接并删除该buffer，等待从节点重连后全量复制。</li></ul><h3 id="主从复制优化"><a href="#主从复制优化" class="headerlink" title="主从复制优化"></a>主从复制优化</h3><p><em>数据不一致</em><br>优化网络环境，集群扩展负载能力，检测并断开网络过于差的节点。</p><p><em>减少切换的数据丢失</em></p><ul><li>异步复制，主节点宕机后恢复：<ul><li><code>min-slaves-max-lag x</code>参数，主节点要求至少要有一个从节点与主节点的同步进度小于x秒，否则禁止写数据。</li></ul></li><li>异步复制，主节点宕机后成为从节点 <strong>（脑裂）</strong>：<ul><li><code>min-slaves-to-write x</code>参数，主节点至少要有x个从节点，否则禁止写数据。</li><li><code>min-slaves-max-lag x</code>参数，主节点要求至少要有一个从节点与主节点的同步进度小于x秒，否则禁止写数据。</li></ul></li></ul><blockquote><p>都是在宕机是禁止对原节点的写入，通过队列缓存等待恢复或直接写入新节点。</p></blockquote><p><em>故障自动切换</em><br>哨兵可以完成故障发现、转移、停止。</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p><em>哨兵的作用</em></p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p><em>哨兵集群构建</em></p><ul><li>哨兵一般至少为3个，应该为奇数个，<code>quorum</code>一般设置成<code>哨兵数量/2+1</code>。</li><li>通过主节点的<code>__sentinel__:hello</code>频道完成哨兵直接的互相发现与连接。</li><li>通过每10s一次的消息头部请求，获取主节点和从节点的基本信息，实现对从节点的连接。</li></ul><p><em>监控</em></p><ol><li>首个发现哨兵A将其标记为<strong>主观下线</strong>，并询问其他哨兵是否下线。</li><li>当哨兵A收集到达到<code>quorum</code>数量的赞成票时，将其标记为<strong>客观下线</strong>。</li><li>做出<strong>客观下线判定的哨兵</strong>就是执行故障转移的Leader候选人，Leader候选人需要拿到达到<code>quorum</code>数量且达到<code>哨兵数量/2+1</code>数量的赞成票才能当选（Raft选举算法）。</li></ol><p><em>Raft选举算法</em><br><a href="https://juejin.cn/post/6998470783831900197">Raft选举算法</a><br>概念：</p><ul><li>Raft定义了三种角色：<strong>领导者（Leader）</strong>、<strong>跟随者（Follower）</strong> 和 <strong>候选人（Candidate）</strong>。跟随者发现领导者掉线时（收不到leader的心跳）成为候选人。</li><li>节点属性：<ul><li>任期：相当于版本号，过期的任期请求是无用的</li><li>跟随节点ID：即给谁投票或现在跟随谁</li></ul></li><li>超时计时器：<ul><li>选举超时时间：发现leader掉线时随机延迟一段时间选举，防止多节点同时候选</li><li>投票超时时间：收集投票时间的倒计时，结束时统计票数</li><li>竞选等待超时时间：选举失败后且没有其他领导者诞生时，等待一段时间再次选举</li></ul></li></ul><p>实现：</p><ul><li>RPC通讯，只有数据追加请求（心跳）和投票请求（投票）</li><li>任期保证了节点不会使用受到的过期消息，并会跟随最新的任期</li><li>多领导人同时选举时，每个节点只会对一个版本号的投票请求投出一次票。</li></ul><blockquote><p>更详细内容见分布式算法专题。</p></blockquote><p><em>故障转移与通知</em></p><ol><li>挑选新主节点，优先级如下：<ul><li>其中，网络状况不好指：与主节点的断连超过10次以上的从节点</li></ul></li></ol><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B.webp"><br>2. 对新主发送<code>SLAVEOF no one</code>，对其他节点发送<code>SLAVEOF 新主节点</code>命令<br>3. 通知客户故障转移，通过哨兵的<code>+switch-master</code>频道订阅<br>4. 若后续旧主节点上线，也对其发送<code>SLAVEOF 新主节点</code>命令</p><h2 id="集群机制"><a href="#集群机制" class="headerlink" title="集群机制"></a>集群机制</h2><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165951.png"></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><em>hash slot</em><br>redis cluster有16384（2的14次方，bitmap压缩，2kB大小既可以描述）个槽，每个节点管理部分槽。</p><p><em>hash tags</em><br>只使用<code>&#123;&#125;</code>的部分计算hash，实现key的定向存放。</p><p><em>分配方案</em></p><ul><li><code>cluster create</code>创建时平均分配</li><li><code>cluster meet</code>扩容后手动分配</li></ul><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p><em>cluster nodes</em><br>每个节点维护必要的信息：</p><ul><li>该节点的node id，slots，版本号，连接状态</li><li>其他节点的node id，ip，port，slots，master id，版本号，连接状态（最后一次ping，pong的响应时间）</li></ul><p><em>cluster bus</em><br>node通过<code>10000+port</code>端口与其他节点建立连接。</p><p><em>集群拓扑</em><br>redis集群是一个全网拓扑，节点之间两两相连。</p><p><em>cluster handshake</em><br>node通过cluster bus监听消息：</p><ul><li>ping messgae：心跳消息，收到该消息后肯定回复pong消息。<ul><li>若是集群成员，则处理ping消息中携带的gossip信息，识别可能的新节点。</li><li>若不是集群成员，则丢弃该消息。</li></ul></li><li>meet message：发现消息，收到该消息后将消息源视为集群的一部分</li><li>ping message：交换消息，收到集群内其他节点的gossip消息后，将消息中的新节点视为集群的一部分。</li></ul><p><em>请求重定向</em></p><ul><li>MOVED重定向：槽不命中时返回MOVED重定向</li><li>ACK重定向：槽命中但找不到key，且槽在迁移中，则返回ASK重定向</li></ul><p><em>SMART客户端</em><br>通过<code>cluster slots</code>命令获取集群的slots信息，自主计算key所在节点并访问，失败时随机访问节点，并更新slots缓存。</p><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p><strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。</strong></p><p><em>为什么不使用发布订阅</em><br>消息量太大，消耗带宽。（可以使用bloom过滤器优化）</p><p><em>节点结构</em><br>epoch表示版本</p><p><em>gossip消息类型</em><br>ping、pong、meet、failover四种基本类型。另外有<strong>广播通知</strong>，不同于gossip，会发送，使用于标记客观下线，故障恢复请求和故障恢复完成。</p><p><em>心跳发送</em></p><ul><li>每次Cron向所有未建立链接的节点发送ping或meet。</li><li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li><li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li><li>收到ping或meet，立即回复pong</li></ul><p><em>心跳处理</em><br>1.新节点加入：<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324172724.png"></p><p>2.slots、master slave、fail等信息的更新与传播。</p><p><em>故障检测</em><br>节点状态：<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p><ol><li><strong>主节点A</strong>检测到<strong>主节点B</strong>下线，将<strong>疑似下线</strong>该消息保存到其维护的字典中<code>节点B的clusterNode</code>结构的<code>fail_reports</code>链表中，通过gossip协议传播。</li><li><strong>主节点C</strong>收到<strong>主节点A</strong>的gossip消息，也对其进行检查，标记和传播。</li><li>传播到某<strong>主节点D</strong>时，主节点D判断其已经下线，且发现已经有半数以上<strong>主节点</strong>认为节点B疑似下线，则<strong>主节点D</strong>将其标记为<strong>已下线状态</strong>，并发送<strong>广播通知</strong>。</li></ol><p><em>故障恢复</em></p><ol><li>各从节点接受到其主节点客观下线的<strong>广播通知</strong></li><li>各从节点将epoch+1并发送failover requsest<strong>广播通知</strong></li><li>其他主节点响应并投票，对相同epoch只投一次票</li><li>获得超过半数投票后，某从节点当选，并发送failover complete<strong>广播通知</strong></li></ol><blockquote><p>可见集群中，各个主节点充当了哨兵的作用，完成下线判断和投票。</p></blockquote><h3 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h3><p><em>节点加入集群</em><br>加入集群后节点默认为主节点，但无slot</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster meet ip:port<br>redis-cli --cluster add-node ip:port<br></code></pre></td></tr></table></figure><p><em>将节点设置为从节点</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cluster replicate 4b339ad25b4884c2ff6de8a8ec2bc8766f8faf0b<br></code></pre></td></tr></table></figure><p><em>手动迁移</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --cluster reshard 192.168.100.100:8001<br></code></pre></td></tr></table></figure><p><em>缩容</em><br>判断下线节点类型，若是主节点，则先将其迁移后将其标记为待下线，最后将下线主节点的从节点指向其他主节点。</p><h1 id="七、缓存"><a href="#七、缓存" class="headerlink" title="七、缓存"></a>七、缓存</h1><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。<strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>大量缓存数据同时过期</strong>，或<strong>Redis宕机</strong>，导致对数据库的大量请求并引起一连串的连锁反应。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h4><p>首先过期的主要目的是为了实现数据的更新。</p><ul><li>大量：<strong>接口限流或熔断</strong> 或 <strong>互斥锁</strong>（一次只允许一个请求构建缓存，防止对数据库的大量请求，记得设置超时时间）。</li><li>同时：<strong>设置均匀的过期时间</strong>。</li><li>过期：<ul><li><strong>后台更新缓存</strong>：不设置过期时间，数据发送变化时后台主动更新缓存，但可能出现内存紧张发生淘汰，解决方法有：<ul><li>后台定时检测key是否被淘汰。</li><li>淘汰时以消息队列通知后台更新，并暂时返回空。</li></ul></li><li><strong>双key</strong>：使用两个key，主key会过期方便更新，备key则临时应付主键过期时的请求。应用程序发现主key过期则访问备key，并触发主备key的更新（也要配合互斥锁实现更新）。</li></ul></li></ul><h4 id="Redis故障宕机"><a href="#Redis故障宕机" class="headerlink" title="Redis故障宕机"></a>Redis故障宕机</h4><ul><li><strong>服务熔断</strong>或<strong>请求限流</strong></li><li>构建Redis高可用集群（主从）</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>某个热点数据过期</strong>，导致对数据库的大量请求并引起一连串的连锁反应。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>大量：<strong>接口限流或熔断</strong>、互斥锁方案</li><li>不设置过期时间，后台异步更新缓存及其过期时间</li></ul><blockquote><p>接口限流和熔断和互斥锁几乎是万金油机制</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致对数据库大量请求。</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>限制非法请求，检查请求参数</li><li>缓存空值或默认值</li><li>布隆过滤器快速判定是否命中缓存</li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><em>组成</em><br>位图数组 + N个哈希函数</p><p><em>标记步骤</em><br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/86b0046c2622b2c4bda697f9bc0f5b28.webp"></p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p><em>查询步骤</em><br>计算N个hash值并取模，判断这些位是否都为1：</p><ul><li>全1不代表一定存在</li><li>存在0代表一定不存在</li></ul><p><em>哈希冲突</em><br><strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，redis中一定就不存在这个数据</strong>。</p><blockquote><p>更详细内容见大数据处理算法专题。</p></blockquote><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>并发问题和行为不执行都可能导致缓存的不一致性。</p><h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>主动更新在<strong>并发写</strong>时存在不一致问题，如下：</p><ul><li>先更新数据库，再更新缓存</li></ul><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/8febac10b14bed16cb96d1d944cd08da.webp"><br><strong>无法保证一致性。</strong></p><ul><li>先更新缓存，再更新数据库</li></ul><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/454a8228a6549176ad7e0484fba3c92b.webp"><br><strong>无法保证一致性。</strong></p><h3 id="更新删除策略"><a href="#更新删除策略" class="headerlink" title="更新删除策略"></a>更新删除策略</h3><p>更新数据库并删除缓存在<strong>并发读、写</strong>时存在不一致问题，如下：</p><h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/6e3db3ba2f829ddc14237f5c7c00e7ce.webp"></p><ul><li>先删除缓存，再更新数据库</li></ul><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/cc208c2931b4e889d1a58cb655537767.webp"><br><strong>无法保证一致性。</strong></p><ul><li>先更新数据库，再删除缓存</li></ul><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/1cc7401143e79383ead96582ac11b615.webp"><br><strong>无法保证一致性。</strong><br>虽然仍可能存在不一致性，但发生的概率较低：</p><ul><li>请求A更新缓存只发送在缓存未命中的情况（可能键恰好失效）。</li><li>缓存的写速度远快于数据库写入，请求A的写缓存行为几乎不会发生在请求B完成删除缓存之后。</li></ul><div class="note note-primary">            <p><strong>先更新数据库，后删除缓存</strong>是可行的，虽然不能完全保证一致性，但可以接受。</p>          </div><h3 id="缓存代理模式（使用较少）"><a href="#缓存代理模式（使用较少）" class="headerlink" title="缓存代理模式（使用较少）"></a>缓存代理模式（使用较少）</h3><h4 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165034.png"></p><h4 id="Write-Behind-Caching-Pattern（异步缓存写入）"><a href="#Write-Behind-Caching-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Caching Pattern（异步缓存写入）"></a>Write Behind Caching Pattern（异步缓存写入）</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324165054.png"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><em>主动更新策略</em><br>主动更新策略能更好的保证实时性和命中率，但存在并发问题，解决方案：</p><ul><li>使用分布式锁，只允许一个请求更新缓存</li><li>使用较短的过期时间，即使存在过期数据也快速刷新</li></ul><p><em>更新删除策略</em></p><ul><li>延迟双删：更新数据库前<strong>删除缓存</strong>，更新数据库后<strong>睡眠</strong>一小段时间，再执行一次<strong>删除缓存</strong>。</li></ul><p><em>执行失败</em><br>「先更新数据库， 再删除缓存」行为中，删除缓存可能未得到执行。</p><h3 id="解决强一致性问题"><a href="#解决强一致性问题" class="headerlink" title="解决强一致性问题"></a>解决强一致性问题</h3><p>由于更新删除策略中删除缓存可能得不到执行，需要优化流程：<br><em>方案1：队列+重试</em><br>将删除缓存行为加入到消息队列保证其得到执行。<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164739.png"></p><p><em>方案2：队列+重试+非业务代码异步更新</em><br>使用数据库更新日志binlog，中间件（Canal 中间件，阿里巴巴开源）提取key并执行缓存删除，这中间也需要使用消息队列保证执行成功，但可以使用非业务代码完成这个操作。</p><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/Pasted-image-20230324164801.png"></p><p><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/2ee2280e9f59b6b4879ebdec6eb0cf52.webp"></p><h1 id="八、常见"><a href="#八、常见" class="headerlink" title="八、常见"></a>八、常见</h1><p><em>什么是Redis?</em><br>nosql，基于内存，数据格式为键值对，单线程。</p><p><em>Redis 和 Memcached 有什么区别？</em><br>都基于内存。但redis可以持久化、集群。</p><p><em>为什么Redis可以做缓存？</em><br>高性能、高并发。</p><p><em>单线程？</em></p><ul><li>处理文件事件是主线程单线程完成。</li><li>关闭文件、AOF 刷盘、lazyfree等操作都由子线程异步完成。</li><li>之前使用单线程，因为CPU不是性能瓶颈；6.0后使用了多线程，因为网络上开始出现瓶颈。</li></ul><p><em>为什么单线程模型如此快？</em></p><ul><li>内存</li><li>无锁</li><li>I&#x2F;O多路复用</li></ul><p><em>如何实现延迟队列？</em><br>zset记录目标延迟时间，业务循环处理，对比score和当前时间得到range，取出任务。</p><p><em>管道？</em><br>管道技术（Pipeline）是客户端提供的一种批处理技术。<br><img src="/2023/03/25/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E5%A4%8D%E4%B9%A0/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.webp"></p><p><em>分布式锁？</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET lock_key unique_value NX PX 10000 <br></code></pre></td></tr></table></figure><p>由于异步复制导致<strong>不可靠</strong>，官方提供了RedLock算法：</p><ol><li>记录开始时间t1。</li><li>为所有redis加锁，加锁超时（几十毫秒）则判定失败。</li><li>成功加了N&#x2F;2+1的锁时，获取时间t2，判断总耗时。</li><li>若总耗时也通过检测，则计算有效时间，若<code>过期时间-耗时&lt;0</code>则释放锁。（此时已经没有时间完成业务了）。</li></ol><p>即：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功，此时判断这个锁是否还有时间可用，不可用则释放。</p><blockquote><p>lua脚本可以原子执行</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java复习</title>
    <link href="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h1><h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><p>开单依接里迪合</p><ul><li>开放封闭原则：对扩展开放，对修改关闭。</li><li>单一职责原则：一个类、接口或方法只负责一个职责。</li><li>依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。</li><li>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。</li><li>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。</li><li>迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。</li><li>合成复用原则：聚合 &gt; 继承，降低耦合度。</li></ul><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul><li>创建型模式：单抽工建原</li><li>结构型模式：适装代外桥组享</li><li>行为型模式：策模观迭责命，状备访中解</li></ul><p><em>单例模式</em><br>双重校验锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>工厂</em><br>简单工厂模式：根据方法参数返回不同子类<br>工厂方法模式：对接口进行不同子类实现<br>抽象工厂模式：创建对象家族</p><p><em>外观模式</em><br>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><p><em>桥接模式</em><br>将抽象与实现分离开来，使它们可以独立变化。</p><p><em>享元模式</em><br>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><p><em>观察者模式</em><br>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><p><em>访问者模式</em><br>为数据结构中的每个元素提供多种访问方式。它将<strong>对数据的操作与数据结构进行分离</strong>。</p><h1 id="二、Java基础复习"><a href="#二、Java基础复习" class="headerlink" title="二、Java基础复习"></a>二、Java基础复习</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p><em>类型转换</em><br>字面浮点数是double类型的。<br>字面整数是int类型的。<br><code>+=</code>可以隐式转换</p><p><em>缓存池</em><br>boolean、bytes、short、int、char有-128~127的缓存池，<code>valueOf()</code>可以获取。</p><p><em>String</em></p><ul><li>不可变，便于hash使用和网络传输，线程安全</li><li>StringBuffer线程安全，StringBuilder线程不安全</li><li>JDK8前是<code>char[]</code>(UTF-16)，JDK9时是<code>byte[]</code>（Latin-1），动态调整字符集。</li></ul><p><em>字符串常量池</em><br>规范上在方法区，1.6在永久代，1.7在堆，1.8在堆中。</p><p><em>运算</em><br>%向0取整，mod向下取整</p><p><em>位运算</em><br><code>&gt;&gt;&gt;</code>无符号右移<br><code>~</code>以-0.5为轴反转</p><p><em>switch</em><br>byte,short,char,int,枚举(jdk5.0)，String对象(jdk7.0)，但不能使用long类。<strong>对String的支持是语法糖</strong>。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>封装、继承、多态（编译时多态：<strong>重载</strong>、运行时多态：<strong>重写</strong>）。</p><p><em>权限修饰符</em><br>private、default（包可见）、protected（包、子类可见）、public<br>类修饰符只有default和public。</p><p><em>static</em><br>静态类不依赖于外部类实例。<br>静态变量可以不赋予初值，在链接阶段的准备过程会赋予默认值。</p><p><em>对象构造</em><br>一个类至少一个构造器，显示定义构造器后，默认的无参构造器失效。</p><p><em>初始化顺序</em></p><ul><li>类初始化（static从上至下）</li><li>默认初始化（0，false）</li><li>构造初始化（普通赋值和普通代码块从上至下）</li><li>构造函数</li></ul><p><em>super</em><br>super()父类构造函数</p><p><em>toString</em><br>默认返回对象类型 + @ + 16进制的hashCode()</p><p><em>Clone</em><br>native的clone()是<strong>浅拷贝</strong>。</p><ul><li>继承Cloneable接口</li><li>重写clone()</li><li>抛出CloneNotSupportedException</li></ul><p><em>Enum</em><br>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>  <br>&#123;  <br>RED, GREEN, BLUE;  <br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;  <br>RED(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">1</span>), GREEN(<span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">2</span>), BLANK(<span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-number">3</span>), YELLO(<span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">4</span>);  <br><span class="hljs-comment">// 成员变量  </span><br><span class="hljs-keyword">private</span> String name;  <br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;  <br><span class="hljs-comment">// 构造方法  </span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> index)</span> &#123;  <br><span class="hljs-built_in">this</span>.name = name;  <br><span class="hljs-built_in">this</span>.index = index;  <br>&#125;  <br><span class="hljs-comment">// 普通方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br><span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;  <br><span class="hljs-keyword">if</span> (c.getIndex() == index) &#123;  <br><span class="hljs-keyword">return</span> c.name;  <br>&#125;  <br>&#125;  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>&#125;  <br>get,set...  <br>&#125;<br></code></pre></td></tr></table></figure><p><em>Externalizable</em><br>继承<code>externalizable</code>，重写<code>writeExternal</code>和<code>readExternal</code>。</p><p><em>序列化</em><br>声明为static和transient类型的数据不能被序列化，只存在内存，Externalizable不受影响。</p><p><em>finally</em><br>finally必然执行，其会插入在return语句前，但不影响return结果。</p><p><em>局部变量手动赋值</em><br>都进行一次初始化消耗太大。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li>成员内部类<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>非成员内部类<ul><li>局部内部类、匿名内部类</li></ul></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>继承角度：</p><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口（is a和like a）</li></ul><p>构造角度：</p><ul><li>抽象类可以有构造方法, 接口没有构造方法</li></ul><p>成员变量角度：</p><ul><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能<strong>public static final</strong>(默认)</li></ul><p>成员方法角度：</p><ul><li>抽象类方法可以是public、protected；</li><li>接口方法在JDK8之前只有public abstract；接口方法在JDK8可以有default方法，在JDK9中允许有private方法。</li><li>抽象类可以有静态方法；接口在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）；</li></ul><p>实用角度：</p><ul><li>接口：多重继承，主要用于表示实现类拥有具体方法。  </li><li>抽象类：主要用于在相关类中共享代码。</li></ul><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p><em>作用</em></p><ul><li>屏蔽真实角色</li><li>增强功能，如添加权限，访问控制和申计</li><li>延迟加载</li></ul><p><em>条件</em><br>被代理类A实现接口C，使用类B实现代理</p><ul><li>静态代理：类B实现接口C，聚合A类对象；</li><li>动态代理：<ul><li>类B实现<code>InvocationHandler</code>接口，聚合A类对象，并重写<code>invoke</code>方法；</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>创建代理对象。</li></ul></li><li>Cglib代理：<ul><li>类B实现<code>MethodInterceptor</code>接口，重写<code>intercept</code>方法;</li><li>使用<code>Enhancer</code> 类设置类加载器，被代理类A，代理类B，并使用<code>create()</code>创建代理类；</li></ul></li></ul><p><em>对比</em></p><ul><li><strong>静态代理与动态代理</strong><ul><li><strong>灵活性</strong>：动态代理更灵活</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul></li><li><strong>JDK 动态代理和 CGLIB 动态代理对比</strong><ul><li>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。（另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。）</li><li>大部分情况都是 JDK 动态代理更优秀。</li></ul></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><em>目的</em><br>代码复用，使用一个代码流程适配多个类型，提供类型检查<br><em>用法</em><br>泛型类、泛型接口、泛型方法、使用泛型类参数的普通方法<br><em>上下限</em><br>extends（生产T）、super（消费T）提供上下限检查<br><em>泛型数组</em></p><ul><li>不能<code>new ArrayList&lt;String&gt;[n]</code></li><li>可以<code>new ArrayList&lt;?&gt;[n]</code></li></ul><p><em>泛型擦除</em><br>编译前做检查，编译后类型擦除<br><code>extends T</code>会替换成T<br><code>super T</code>会提换成Object</p><p><em>泛型方法</em></p><ul><li>不指定泛型，为同一父类的最小级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span><br></code></pre></td></tr></table></figure><ul><li>指定泛型，则必须为该泛型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float</span><br></code></pre></td></tr></table></figure><p><em>泛型多态</em><br>类A继承了泛型类并重写方法，编译器会为该类A生成桥方法，桥方法实现了父类方法的重写，并在其中调用用户写的方法。</p><p><em>获取泛型参数</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericType&lt;String&gt; genericType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;  <br><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> genericType.getClass().getGenericSuperclass();<br></code></pre></td></tr></table></figure><p><strong>Type</strong>是Java所有类型实现的<strong>公共接口</strong>。</p><p><em>注意</em></p><ul><li>基本类型不能作为泛型类型</li><li>泛型数组不能初始化</li><li>泛型数组如何正确初始化，使用集合</li><li>异常中使用泛型，可以抛出，不能捕获（会导致错误捕获）</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><em>注解的作用</em></p><ul><li><strong>生成文档</strong></li><li><strong>编译检查</strong></li><li><strong>编译时动态处理</strong></li><li><strong>运行时动态处理</strong></li></ul><p><em>元注解</em></p><ul><li>@Target</li><li>@Retention，保留时间</li><li>@Document</li><li>@Inherited，子类是否继承</li><li>@Reaptable</li><li>@Native</li></ul><p><em>内置注解</em></p><ul><li>@Override，内置注解</li><li>@Deprecated，已过时</li><li>@WarningSupress，警告抑制</li><li>@Repeatable</li></ul><p><em>注解与反射接口</em><br><code>Annotation[] getAnnotations()</code></p><p><em>注解原理</em></p><ul><li>注解之间无法继承</li><li>注解是一个继承自Annotation的接口，里面每一个属性其实是一个接口的抽象方法。</li></ul><p><em>应用</em></p><ul><li>框架注解化</li><li>AOP</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324213918.png"></p><p><strong>throw</strong> – 用于<strong>抛出</strong>异常。<br><strong>throws</strong> – 用在方法签名中，用于声明该方法<strong>可能抛出</strong>的异常。</p><p><em>异常表</em><br>按catch顺序记录：from、to、type、target。</p><p><em>finally</em><br>可能硬编码到try、catch中。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><em>获取class对象</em></p><ul><li>Class.class</li><li>object.getClass()</li><li>Class.forName()</li><li>loadClass()</li></ul><p><em>构造器</em><br>可以通过class对象获取该类的构造器。</p><ul><li>getConstructors() 获取所有public构造器</li><li>getDeclaredConstructors() 获取所有声明的构造器<br>  以上两个方法不构成覆盖关系，getDeclaredConstructors能获取私有构造器，却无法获取继承到的public构造器。</li></ul><p><em>method</em><br>invoke</p><p><em>深入反射</em><br><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324214405.png"></p><p>ReflectionData存在Class对象中，<strong>软引用</strong>，使用<code>reflection()</code>方法获取缓存。</p><p><em>线程安全</em></p><ul><li>反射保证线程安全，对于method会先copy一份（数据隔离）再invoke，最终都是由JVM执行<code>invoke0()</code>方法。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324214713.png"></p><p><em>ArrayList</em></p><ul><li><code>Object[]</code>、size；</li><li>扩容<code>ensureCapacity()</code>1.5倍；</li><li>modCount可以Fail-Fast机制。</li></ul><p><em>LinkedList</em></p><ul><li>fisrt Node、last Node、size；</li><li>clear()会迭代清空，help GC</li></ul><p><em>ArrayDeque</em><br>循环数组</p><ul><li><code>Object[]</code>、size、head、tail</li><li>addFisrt：<code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code></li><li>扩容<code>doubleCapacity()</code>2倍，先复制head右侧的部分</li></ul><p><em>PriorityQueue</em></p><ul><li><code>Object[]</code>、size</li><li><code>leftNode = parentNode*2+1</code></li><li>扩容<code>grow()</code>，复制原数组到新数组</li></ul><p><em>HashMap&amp;HashSet JDK7</em></p><p><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324215427.png" alt="JDK7"></p><ul><li>组成：<ul><li><code>Entry[]</code></li><li>初始容量(<em>inital capacity</em>)：16</li><li>负载系数(<em>load factor</em>)：0.75</li></ul></li><li>添加：<ul><li>头插法</li><li>先判断是否扩容再插入</li></ul></li><li>扩容：<ul><li>rehash 2倍</li></ul></li></ul><p><em>HashMap&amp;HashSet JDK8</em><br><img src="/2023/03/24/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%A4%8D%E4%B9%A0/Java%E5%A4%8D%E4%B9%A0/Pasted-image-20230324215507.png"></p><ul><li>组成：<ul><li><code>Node[]</code></li><li>初始容量(<em>inital capacity</em>)：16</li><li>负载系数(<em>load factor</em>)：0.75</li></ul></li><li>添加：<ul><li>判断头节点类型，看使用链表头插还是红黑树（超过8个转红黑树）</li><li>先插入再判断是否扩容（有时put只会覆盖不会生产新节点，先插入后扩容可以避免不必要的扩容发生）</li></ul></li><li>扩容：<ul><li>rehash 2倍</li></ul></li></ul><p><em>LinkedHashMap</em><br>HashMap的子类，使用双向链表将所有entry相连接，遍历更快。</p><p><em>WeakHashMap</em><br>弱引用管理，可用作缓存。</p><p><em>TreeMap</em><br>基于红黑树，性质有：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li><strong>根节点必须是黑色</strong></li><li><strong>红色节点不能连续</strong>。</li><li><strong>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。</strong></li></ol><p>调整要点：</p><ul><li>尽量调整颜色完成调整</li><li>尽量调整叶子节点，如删除时可考虑前继&#x2F;后继节点</li><li>左右旋转能借到节点最好，否则使用父节点迭代。</li></ul><p><em>ConcurrentHashMap JDK1.7</em><br>分段锁：</p><ul><li>组成：<ul><li><code>Segment[]</code>，每个Segment有一个<code>Entry[]</code></li><li>初始容量(<em>inital capacity</em>)：16个Segment，每个Segment16个Entry</li><li>负载系数(<em>load factor</em>)：Segement数组初始化后不可修改，Entry负载系数0.75，可扩容</li></ul></li><li>添加：<ul><li>先使用二次hash定位segment</li><li>加锁，使用一次hash定位entry所在位置，并添加，失败则自旋，自旋失败次数过大则阻塞。</li><li>先插入再判断是否扩容(每个Segment内部判断、扩容)</li></ul></li><li>扩容：<ul><li>rehash 2倍</li></ul></li></ul><p><em>ConcurrentHashMap JDK1.8</em></p><ul><li>组成：<ul><li><code>Node[]</code></li><li>初始容量(<em>inital capacity</em>)：16</li><li>负载系数(<em>load factor</em>)：0.75</li><li>创建时指定大小(<code>sizeCtl</code>)，但不实例化</li></ul></li><li>添加：<ul><li>初始化整个对象（<strong>初始化被延迟到第一次put</strong>，且该操作通过CAS修改sizeCtl保证只执行一次）</li><li>对于空桶，CAS尝试写入，失败则自旋。</li><li>若hashCode &#x3D;&#x3D; -1，则需要<strong>扩容</strong>。</li><li>对桶头部加锁，判断类型并执行添加。</li></ul></li><li>扩容：<a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">图文参考</a><ul><li>触发条件：达到载荷&#x2F;putAll空间不足&#x2F;某链表长度达到8，但数组长度小于64。</li><li>红黑树转化条件：链表长度达到8，且数组长度大于64。（即优先扩容数组，后转红黑树）</li><li>根据CPU个数、判断每个线程负责的桶个数，从右至左，使用<code>transferIndex</code>标识迁移工作的发配工作进度，每个线程扩容时，移动该指针即可。</li><li>链表迁移：先将原链表复制出来分成两个链表，再分别放入桶中。（涉及一个lastrun节点概念）</li><li>红黑树迁移：先将原红黑树复制出来分成两个链表，根据大小判断直接放入桶中还是构建红黑树。</li><li>扩容时读：每个桶有一个标记，标识其迁移中还是迁移完成。原桶迁移完成中仍存在，直接读原桶即可；迁移完成后，直接读新桶即可。</li><li>扩容时写：阻塞</li><li>多线程迁移：使用sizeCtl判断完成，完成后最后一个线程检查整个table。</li></ul></li></ul><p><em>CopyOnWriteArrayList JDK1.8</em></p><ul><li><code>Object[]</code>、Lock</li><li>写时加锁，创建一个大小比当前数组大1的数组，并复制原数组到新数组</li><li>然后将新数组设置成原数组</li></ul><h1 id="三、JUC"><a href="#三、JUC" class="headerlink" title="三、JUC"></a>三、JUC</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><em>用户空间与内核空间</em><br>这是基于<strong>内存</strong>的划分，运行在用户空间的进程叫处于用户态，运行在内核空间的进程叫处于内核态。</p><p><em>线程实现</em></p><ul><li>用户空间实现：不需要切换进程到内核态，但会发生阻塞影响整个进程。</li><li>内核空间实现：CPU时间片，分一对一、一对多、多对多（线程池）。</li></ul><p><em>Java线程</em><br>采用宿主机的线程库实现。</p><p><em>虚拟机栈</em><br>Java线程上下文需要保存虚拟机栈，切换的原因一般有：</p><ul><li>GC线程</li><li>CPU用完</li><li>获取锁失败阻塞</li><li>主动等待</li></ul><p><em>JAVA并发的问题</em></p><ul><li>原子性：原子操作（lock、unlock、read、write、load、store、use、assign），锁，CAS</li><li>可见性：final、volatile、synchronized</li><li>有序性：<ul><li>单线程：as-if-serial</li><li>多线程：happens-before（程管V启中终对传）</li></ul></li></ul><p><em>操作系统线程五态模型</em><br><img src="/Pasted%20image%2020230325220625.png"></p><p><em>Java线程六态模型</em><br><img src="/Pasted%20image%2020230325220630.png"></p><p><em>创建线程</em></p><ul><li>创建一个类并继承Thread</li><li>创建一个类并实现Runnable，将该类对象作为参数传入Thread的构造器</li><li>创建一个类并实现Callable，使用FutureTask包装该Callable对象成Runnable，传入Thread的构造器</li></ul><h2 id="三大关键字"><a href="#三大关键字" class="headerlink" title="三大关键字"></a>三大关键字</h2><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul><li>synchronized 关键词是悲观锁、排他锁、可重入锁、(某些状态下可自旋)、非公平锁。</li><li>Lock接口的实现是悲观锁、可重入锁<ul><li>ReentrantLock是排他锁、有公平和非公平两种实现。</li><li>ReentrantReadWriteLock读锁是共享的，写锁是排他的。</li></ul></li><li>JUC原子类是乐观锁，自旋锁（可以认为，自旋操作的实现就是CAS，但乐观锁的实现不只CAS）。</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><em>锁住的对象</em></p><ul><li>普通方法：调用实例对象，底层加ACC_SYNCHRONIZED</li><li>静态方法：Class对象，底层加ACC_SYNCHRONIZED</li><li>同步块：synchonized括号中的对象，底层使用monitorenter和monitorexit字节码。</li></ul><p><em>内存语义</em></p><ul><li>释放对象时写主内存</li><li>获取对象是读主内存（实际上是在写内存时就无效了）</li></ul><p><em>ObjectMonitor对象</em><br><img src="/Pasted%20image%2020230325224306.png"></p><ul><li><code>count</code>计数器</li><li><code>_WaitSet</code></li><li><code>_EntryList</code></li><li><code>_owner</code></li></ul><p><em>wait</em><br>只有在synchronized中才可以调用wait</p><p><em>Java对象头</em><br><img src="/Pasted%20image%2020230325224258.png"></p><ul><li>大小：2或3个字宽（一个字宽为32或64bit）</li></ul><p><em>MarkWord</em><br>32位：<br><img src="/Pasted%20image%2020230325224333.png"><br>64位：<br><img src="/Pasted%20image%2020230325224349.png"></p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p><em>等级</em><br>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p><p><em>无锁（自旋）</em><br>自旋-&gt;适应性自选（自旋成功率高才自旋，默认10次获取不到锁就阻塞）</p><p><em>轻量级锁</em><br>栈帧上使用LockRecord（displace hdr、owner）记录获得到的锁对象头，步骤：<br><img src="/Pasted%20image%2020230325225005.png"></p><ol><li>确定对象的无锁状态</li><li>创建<code>Lock Record</code></li><li>复制对象头到<code>Lock Record</code>中的<code>displace hdr</code></li><li><strong>CAS</strong>替换对象头成本记录的指针</li></ol><ul><li>判断重入时：重入时复制创建空LockRecord</li><li>CAS失败时：膨胀成重量级锁</li></ul><p><em>偏向锁（JDK15已废除）</em><br>轻量级的CAS还是太麻烦了，使用偏向锁，获取该锁时不需要替换Lock Record，只需要检查对象头中的Thread ID，且线程不会主动释放锁。工作流程：<br>（1）判断是否可偏向（<strong>偏向锁</strong>标识为1 且 <strong>锁标志位</strong> 为 01）。<br>（2）判断其Thread ID是否指向自己，指向自己则直接执行，否则尝试<strong>CAS</strong>替换这个Therad ID：<br>    - CAS成功：获取偏向锁<br>    - CAS失败：判断Thread ID线程是否退出同步块：<br>        - 若退出了，则先将该锁变成无锁状态，然后可以通过CAS<strong>重偏向</strong>。<br>        - 若没退出，则让Thread ID线程将其升级为<strong>轻量级锁</strong>（<strong>撤销</strong>）。</p><p><em>批量重偏向和批量撤销</em><br>批量重偏向：<strong>某个类</strong>的所有对象的锁，锁<strong>撤销（偏向锁-&gt;轻量级）次数</strong>大于20时，认为是有可能最初偏向错了，再对该对象加锁时则<strong>重偏向（偏向锁-&gt;偏向锁）</strong>。<br>批量撤销：<strong>某个类</strong>的所有对象的锁，锁<strong>撤销（偏向锁-&gt;轻量级）次数</strong>大于40时，认为这个类的对象的锁确实要撤销，把该类的所有偏向锁<strong>撤销</strong>，再创建<strong>新对象也默认不可偏向</strong>。</p><div class="note note-primary">            <p>重偏向和升级轻量级是两个对立的行为，通过判断锁的情况来决定如何选择该行为。</p>          </div><p><em>锁消除</em><br>如果编译器认定一个锁只会被单个线程访问（即无<strong>线程逃逸</strong>），那么这个锁就可以被消除，即<strong>同步省略</strong>。</p><p><em>PS：逃逸分析类型</em></p><ul><li>方法逃逸</li><li><strong>线程逃逸</strong></li></ul><p><em>PS：逃逸优化</em></p><ul><li><strong>同步省略</strong></li><li>栈上分配</li><li>标量替换</li></ul><p><em>锁粗化</em><br>连续的加锁操作合并成一个</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>保证可见性和有序性，不能保证原子性。</p><p><em>可见性</em><br>通过写内存的内存语义，写时会直接将工作内存同步到主内存并无效其他线程中的内存。</p><p><em>有序性</em><br>volatile写：前插入storestore内存屏障，后插入storeload内存屏障。<br>volatile读：后插入loadload,loadstore内存屏障。</p><p><em>双重校验锁</em><br>单例模式的健全版</p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>保证<strong>可见性</strong>。<br><strong>不可变对象永远是线程安全的。</strong>（只要发生方法逃逸）</p><p><em>重排序规则</em></p><ul><li><strong>禁止编译器</strong>将final的写指令重排序到构造函数外，在写指令<strong>后</strong>插入一个storestore屏障<strong>禁止处理器</strong>重排序。</li><li><strong>禁止编译器</strong>将final的读指令重排序到对对象的读之前，在读指令<strong>前</strong>插入一个loadload屏障<strong>禁止处理器</strong>重排序。</li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><em>概念</em><br>Compare And Swap，可用于无锁编程，底层处理器有相关指令实现。</p><p><em>问题</em></p><ul><li>ABA问题：使用版本号解决<code>AtomicStampedReference</code></li><li>作用对象问题：使用锁或将变量合并，操作后再拆解（<code>AtomicReference</code>）</li><li>循环开销：JVM支持<code>pause</code>指令，允许竞争失败后短暂睡眠，防止空转。</li></ul><p><em>Unsafe类</em><br>底层类，不建议直接使用，有native的CAS方法，支持类、数组、引用、字段的原子更新。</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p><em>lock与synchronized的使用区别</em></p><ul><li>lock更灵活。</li><li>lock可以实现共享锁。</li><li>lock可以被中断，synchronized不能被中断，可能阻塞。</li><li>lock效率相对较低。</li></ul><p><em>lock接口方法</em></p><ul><li><code>lock()</code></li><li><code>lockInterruptibly()</code></li><li><code>tryLock()</code></li><li><code>tryLock(long time,TimeUnit unit)</code></li><li><code>unlock()</code></li><li><code>newCondition()</code></li></ul><p><em>lock接口具体实现</em><br><code>Lock</code>接口的具体实现类，如<code>ReentrantLock</code>都聚合了一个<strong>AQS的子类</strong>，来实现同步。</p><ul><li>AQS(<code>AbstractQueuedSynchronizer</code>)：抽象类，内部实现了状态量和同步队列，提供了共享模式的方法和独占模式的方法。</li><li><code>ReentrantLock</code>中实现了内部抽象类<code>Sync</code>，继承了<code>AQS</code>，对部分方法进行了重写</li></ul><p><em>AQS字段</em></p><ul><li><code>volatile int state</code>表示同步状态</li><li><code>CLH</code>队列实现同步</li><li>内部类Node:<ul><li>记录线程</li><li>Node：prev、next、nextWaiter</li><li>身份（共享、排他）</li><li>模式（CANCELLED取消、SINGAL<strong>后继节点</strong>正在挂起）</li></ul></li></ul><p><em>AQS模板方法</em></p><ul><li><code>acquire(int arg)</code>，被final修饰，<strong>不可被重写</strong>，其中调用的<code>tryAcqure(arg)</code>，<strong>可被子类重写</strong>。</li></ul><p><em>AQS共享模式</em></p><ul><li><code>tryAcquireShared(int)</code>，返回值为int。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p><em>ReentrantLock获取锁</em><br>lock()方法工作流程：</p><ul><li>cas state为1<ul><li>成功则获取锁</li><li>失败则调用<code>acquire</code><ul><li><code>acquire</code>调用重写后的<code>tryAquire(arg)</code></li><li>tryAquire失败则入队：<ul><li><code>addWaiter()</code>方法，其中使用了<code>compareAndSetTail</code>做CAS操作，CAS失败则进入<code>enq()</code>方法做死循环保证节点添加）</li><li><code>acquireQueued()</code>会获取到<code>addWaiter</code>添加队列成功的节点，然后做<strong>死循环</strong>（目的是防止虚假wake up）访问前驱节点，如果前驱节点是头节点，本节点则会尝试获取<code>tryAquire</code>：<ul><li>成功则修改头指针并退出循环</li><li>失败则进入等待</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReentrantLock Method</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))   <br>        <span class="hljs-comment">// CAS 成功，即没有线程持有锁，此时当前线程可直接获取锁，不需要再CAS入队</span><br>        setExclusiveOwnerThread(Thread.currentThread()); <br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// CAS 失败，acquire会调用被重写的tryAquire(arg)再次尝试获取，失败则入队</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//AQS Method</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 此方法会尝试去获取锁</span><br>        <span class="hljs-comment">// 将当前线程加入 CLH 队列中</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Pasted%20image%2020230326135302.png"></p><p><em>ReentrantLock释放锁</em><br>unlock工作流程：</p><ul><li>调用被重写的<code>tryRelease</code>，成功则唤醒后续节点<code>unparkSuccessor</code>：<ul><li>改变头节点waitStatus</li><li>校验后继节点waitStatus</li><li>唤醒后继节点，由后继节点来执行移出头节点等事件</li></ul></li></ul><p><em>ReentrantLock重入实现</em><br>tryAcquire() -&gt; nonfairTryAcquire() -&gt; state++;</p><p><em>公平锁与非公平锁</em><br><img src="/Pasted%20image%2020230326142111.png"><br>ReentrantLock默认非公平实现，也可传true实现公平<br><img src="/Pasted%20image%2020230326142306.png"><br>底层区别在于tryAcuire中CAS state之前判断当前是否有排队。</p><p><em>调用链</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReentrantLock.lock -&gt; NonfairSync/FairSync.lock -&gt; AQS.acquire -&gt; NonfairSync/FairSync.tryAcquire() -&gt; AQS.acquireQueued(addWaiter());<br></code></pre></td></tr></table></figure><p><em>总结</em><br>AQS实现了队列的主要功能：</p><ul><li>只开放了tryAcquire和tryRelease这样的方法：以供子类来做是否公平的实现，改写内容一般是对state的CAS处理</li><li>不论被重写成什么样，失败后都走的AQS的排队方法，获取者会死循环直到添加成功；释放者也会死循环直到释放成功。</li></ul><p><em>ReentrantReadWriteLock</em><br><img src="/Pasted%20image%2020230326142621.png"><br>使用一个state同时维护读、写状态，将 32 位的整型变量 state 切分成两个部分，高 16 位表示读，低 16 位表示写：<br>[<img src="http://localhost:4000/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170539.png"></p><p><em>锁降级</em><br>读写锁中的锁降级指的是，<strong>写锁降级成为读锁</strong>。</p><p><em>Condition</em><br><img src="/Pasted%20image%2020230326142914.png"><br>步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Codition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Codition</span>()<br>condition.await()<br>condition.signal()<br>condition.signalAll()<br></code></pre></td></tr></table></figure><h2 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h2><p><em>CountDownLatch</em><br>倒计时器，替代join()，更灵活，信号量通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);  <br>countDownLatch.countDown();<br>countDownLatch.await(); <span class="hljs-comment">// 阻塞线程，等待countdown为0</span><br></code></pre></td></tr></table></figure><p><em>CyclicBarrier</em><br>同步屏障，可添加释放前方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>,function());<br>cyclicBarrier.await(); <span class="hljs-comment">// 子线程已达到屏障</span><br>cyclicBarrier.await(); <span class="hljs-comment">// 主线程已到达屏障</span><br></code></pre></td></tr></table></figure><p><em>Semaphore</em><br>信号量，用于流量控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">20</span>);<br>s.acquire()<br>s.release()<br></code></pre></td></tr></table></figure><p><em>Exchanger</em><br>线程之间交换对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">strA</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;大佬 A 的钥匙&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">strB</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;大佬 B 的钥匙&quot;</span>);<br></code></pre></td></tr></table></figure><p><em>ThreadLocal</em><br>ThreadLocalMap由线程独有，其Entry以ThreadLocal为键，value为值。<br><img src="/Pasted%20image%2020230326143937.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  <br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>  <br>    Object value;<br>    <span class="hljs-comment">//private ThreadLocal referent; 继承字段</span><br>  <br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;  <br>        <span class="hljs-built_in">super</span>(k);  <span class="hljs-comment">// referent = k</span><br>        value = v;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意ThreadLocalMap.Entry中：</p><ul><li>key是<strong>弱引用</strong>，因为ThreadLocal过多时会出现内存泄漏，而在强引用下其是不可回收的。</li><li>value是强引用，因为value可能还存在其他引用，不可盲目回收，且要避免key还在而value为null的情况。</li></ul><p>因此，需要手动的remove(key)实现资源释放。</p>          </div><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><img src="/Pasted%20image%2020230326145701.png"><br><em>工作流程</em><br><img src="/Pasted%20image%2020230326145908.png"></p><p><em>Executors</em><br>封装了6种方法，对应6种线程池：</p><ul><li>FixedThreadPool：核心线程n，最大线程n</li><li>CachedThreadPool：核心线程0，最大线程无穷，动态回收创建</li><li>SingleThreadExecutor：核心线程1，最大线程1</li><li>WorkStealingPool：任务抢占式执行的线程池</li><li>ScheduledThreadPool：定时线程池</li><li>SingleThreadScheduledExecutor：单核定时线程池</li></ul><div class="note note-primary">            <p>不建议使用Executors，应该使用ThreadPoolExecutor暴露细节。</p>          </div><p><em>ThreadPoolExecutor</em><br><img src="/Pasted%20image%2020230326150521.png"><br><strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>阻塞队列</strong>是限制大小的。<br><strong>存活时间</strong>和<strong>单位</strong>是管理非核心线程的回收的。<br><strong>工厂</strong>管理生成线程策略。<br><strong>处理器</strong>决定饱和策略。</p><p>拒绝策略：</p><ul><li>AbortPolicy (默认策略)：拒绝执行并抛出异常</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy：抛弃阻塞队列头部（最旧）的一个任务，并执行当前任务</li><li>DiscardPolicy：忽略并抛弃当前任务</li></ul><p><em>Executor</em><br>是一个线程池框架<br><img src="/Pasted%20image%2020230326155236.png"><br><img src="/Pasted%20image%2020230326154737.png"></p><p><em>Executors、Executor、ExecutorService</em></p><ul><li>ExecutorService接口继承了Executor接口，加强对线程任务的控制支持，如提供了submit()方法，允许shutdown()等。</li><li>Executors只是一个工具类，用过来生成ExecutorService接口的实现类，不推荐使用。</li></ul><p><em>配置线程池经验</em></p><ul><li>重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>。</li><li>根据线上线下：<ul><li>线上要求高响应速度，调高 <code>corePoolSize</code> 和 <code>maxPoolSize</code></li><li>线下要求高处理速度，调高调整合适的<code>corePoolSize</code>(一般为处理器数量+1)去设置处理任务的核心线程数。</li></ul></li><li>根据任务类型：<ul><li>CPU密集型，设置<code>corePoolSize</code>为CPU数量+1。</li><li>IO密集型，尽可能多的配置核心线程，IO等待时让其他线程占用CPU。</li></ul></li></ul><h1 id="四、JVM"><a href="#四、JVM" class="headerlink" title="四、JVM"></a>四、JVM</h1><h2 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h2><ul><li>基于栈的指令集架构（另一种是基于寄存器的，移植性差）</li><li>生命周期：<ul><li>启动：引导类加载器创建初始类完成。</li><li>退出：Error，exit，操作系统错误。</li></ul></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><em>加载类的过程</em></p><ul><li>加载：二进制字节流 &#x3D;&gt; 方法去运行时数据结构</li><li>链接<ul><li>验证：<ul><li>文件格式验证(文件格式、魔数、长度等)</li><li>元数据验证（继承关系是否合法等）</li><li>字节码验证（方法体是否合法等）</li><li>符号引用验证（引用类型是否存在等）</li></ul></li><li>准备：分配内存，赋默认值</li><li>解析：符号引用转化为直接引用</li></ul></li><li>初始化：<code>&lt;clinit&gt;</code>，该过程会加锁</li></ul><p><em>加载类的来源</em><br>本地、网络、数据库、动态生成等</p><p><em>类加载器分类</em><br>父子关系：<br><img src="/Pasted%20image%2020230326192426.png"><br>实现关系：<br><img src="/Pasted%20image%2020230326192822.png"></p><ul><li>引导类加载器由C、C++编写</li><li>系统类加载器也叫应用程序类加载器AppClassLoader</li><li>底层loadClass()模板方法实现了双亲委派，一般重写findClass()即可。</li></ul><p><em>为什么需要自定义加载器</em><br>隔离加载类、扩展加载源、自定义加载方式（还可防止源码泄漏）</p><p><em>如何自定义加载器</em><br>一般继承URLClassLoader，再重写findClass即可。</p><p><em>双亲委派</em><br>加载类时向上委托，父加载器加载不了时才主动加载，保证了可见性和单一性。</p><p><em>双亲委派机制的破坏</em></p><ul><li>早期的loadClass()方法被重写</li><li>线程上下文加载器：为了实现系统类调用用户类</li><li>热替换&#x2F;热部署。</li></ul><p><em>两个相同的class对象</em><br>同加载器（在同一个命名空间里）、同完整类名。</p><p><em>类主动使用</em><br>使用静态字段、静态方法、生成实例、forName()</p><p><em>数组类加载</em><br>由数组对应的类的类加载器加载。</p><p><em>static与static final</em><br>两者都在堆中，跟随class对象：</p><ul><li>对于基本类型&#x2F;字符串字面量，前者初始化时赋值，后者链接环节赋初值。</li><li>对于引用对象类型，初始化时赋值。</li></ul><p><em>类的卸载前提</em></p><ul><li>类对象全回收</li><li>类的引用全回收</li><li>类的加载器被回收</li></ul><p><em>沙箱安全机制</em><br>JDK1.0<br><img src="/Pasted%20image%2020230327001401.png"><br>JDK1.1<br><img src="/Pasted%20image%2020230327001408.png"><br>JDK1.2<br><img src="/Pasted%20image%2020230327001421.png"><br>JDK1.6<br><img src="/Pasted%20image%2020230327001429.png"></p><p><em>Java9特性</em></p><ul><li>URLClassLoader &#x3D;&gt; BuiltinClassLoader</li><li>ExtClassLoader &#x3D;&gt; PlatformClassLoader</li><li>SystemClassLoader由java实现</li><li>双亲委派机制现在可以跨级直接委托</li></ul><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="/Pasted%20image%2020230326193259.png"></p><p><em>JVM系统线程</em><br>虚拟机线程（管理、调度线程）、GC线程、编译线程、周期任务线程、信号调度线程。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><em>PC寄存器</em><br>线程私有，执行native方法时为Undefined。</p><p><em>虚拟机栈</em><br>由栈帧构成，栈帧由：</p><ul><li>局部变量表（slot数组，一个slot占32位，一个64位的变量占2个slot，可复用）。</li><li>操作数栈（栈顶缓存技术:<strong>将栈顶元素全部缓存在物理CPU的寄存器中</strong>，降低内存读写消耗）</li><li>方法返回地址（返回调用该方法的指令的下一条指令；异常退出时返回到异常表的target，且不返回值）</li><li>动态链接（指向方法区中本类的Vtable）</li></ul><p><em>Vtable</em></p><ul><li>非虚方法：静态链接对应早期绑定，编译期确定方法</li><li>虚方法：动态链接对应晚期绑定，运行期确定方法</li><li>绑定：符号引用变成直接引用的过程</li></ul><p><em>本地方法栈</em><br>native修饰的方法，每个线程只有一个。HotSpot中，虚拟机栈与本地方法栈是一体的。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><em>堆结构</em><br>JDK7.0：新生区（Eden区和Survivor区8:1:1）、养老区、永久区<br>JDK8.0：新生区、养老区、元空间</p><p><em>对象分配原则</em></p><ul><li>小对象分配：Eden出生，MinorGC后Survivor，15次后进Old。</li><li>大对象分配：Old。</li><li>动态对象年龄分配：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保（-XX:HandlerPromotionFailure，已经废除）：开启后MinorGC前检查老年代是否还有可用的<strong>连续空间</strong>：若有，则GC；若没有，则根据历次GC后移动到老年代的平均对象大小评估是否可以冒险GC，评估失败或冒险失败后FullGC。</li></ul><p><em>TLAB</em><br>JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。</p><p><em>GC分类</em></p><ul><li>Minor&#x2F;Young</li><li>Major&#x2F;Old，绝大多数(CMS除外)会同时触发YoungGC</li><li>Full，注意FullGC是可以回收方法区的。</li><li>Mixed，G1回收期特有的混合回收。</li></ul><p><em>堆外对象？</em><br>栈上分配、标量替换都未实现，所以对象都在堆上。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><em>存储内容</em></p><ol><li>类信息，包括类本身、字段、方法的所有信息。</li><li>运行时常量池，静态常量池（class文件中）加载后就变成了运行时常量池（方法区中），符号引用被转化为真实地址。</li><li>字符串常量池，逻辑上在方法去，<strong>实际上在堆中</strong>。</li></ol><blockquote><p>JDK1.7时，字符串常量池和静态变量就从永久代移动到了堆中，后续又取消了永久代，变成元空间。</p></blockquote><p><em>元空间</em><br>元空间可以使用直接内存。</p><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ol><li>执行类、父类、接口的加载、初始化</li><li>内存分配</li><li>对象准备（赋默认值）</li><li>设置对象头</li><li>init初始化（赋显示初值、构造器最后执行）</li></ol><p><img src="/Pasted%20image%2020230326230516.png"></p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><em>解释器</em><br>字节码 &#x3D;&gt; 机器码<br>HotSpotVM中，解释器由Interpreter模块和Code模块构成：</p><ul><li>Interpreter模块：实现了解释器的核心功能，将字节码翻译为机器码</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><p><em>编译器</em><br>前端编译器AOT：java代码 &#x3D;&gt; 字节码<br>后端编译器JIT：字节码 &#x3D;&gt; 机器码</p><p><em>JIT编译器分类</em><br>C1：方法内联（把引用的函数编译到引用处）、去虚拟化（对唯一的实现类进行内联）、冗余消除（折叠不执行的代码）。<br>C2：标量替换、栈上分配、同步消除。</p><p><em>JIT热点代码</em><br>计数器：方法调用计数器+回边计数器<br>热点衰退：GC时进行，半衰</p><h2 id="StringPool"><a href="#StringPool" class="headerlink" title="StringPool"></a>StringPool</h2><p>底层是HashTable（默认大小：JDK6&#x3D;1009；JDK7&#x3D;60013），JDK6及以前在永久代，JDK7后在堆中。</p><p><em>intern()</em><br>JDK6中调用intern，将其复制一份在pool中并返回；<br>JDK7中调用intern，pool中创建堆该string的引用。</p><p>G1中String回收<strong>去重</strong><br>将候选string放入hashtable，发现重复时则将引用改成hashtable中的string并释放本string。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p><em>finalize()</em><br>Object原生方法，一个对象只会执行一次。</p><p><em>垃圾回收算法</em></p><ul><li>标记：引用计数算法和可达性算法（root包括栈和方法区引用，同步锁对象，脏表上的对象等）。<ul><li>判断对象是否可直接回收，finalize()方法可能复活，需要交付给F-Queue队列执行finalize方法，执行后GC再扫描该队列看是否可触及。</li></ul></li><li>回收：标记-清除算法、复制算法、标记-压缩算法、增量收集（G1）</li><li>分配内存方法：指针碰撞法、空闲列表法</li></ul><p><em>应用</em><br>复制算法一般在YoungGC中，迁移到Survivor。<br>标记压缩算法一般在OldGC中。<br>标记清除算法一般在CMS或G1的GC中，因为其需要并发标记清除。<br>增量收集只在G1中，</p><p><em>System.gc()</em><br>不一定立刻生效</p><p><em>STW</em><br>枚举GCRoots和修正标记结果时必须STW。</p><p><em>安全点&#x2F;安全区域</em><br>引用关系不会发送变化的时点或区域。<br>中断方式：抢占式（让线程在安全点时中断）、主动式（线程在安全的主动询问）</p><p><em>引用</em><br>强&#x2F;软&#x2F;弱&#x2F;虚。软引用空间不足时回收，弱引用GC则回收，虚引用关联一个引用队列，可以获取其回收通知。<br>终结器引用，GC时，终结器引用进入F-QUEUE，Finalizer线程执行队列中对象的finalize()方法。</p><p><em>并行与并发</em><br>并行（Parallel）：<strong>多条GC线程</strong>同时执行GC。<br>串行（Serial）：<strong>单GC线程</strong>执行GC。<br>并发（Concurrent）：<strong>用户线程与GC线程</strong>交替执行。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><em>分类</em><br>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。<br>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。<br>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。<br>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p><p><em>性能指标</em><br>主要关注<strong>吞吐量</strong>和<strong>响应速度</strong></p><p><em>经典垃圾回收器</em><br><img src="/Pasted%20image%2020230326233958.png"></p><p><em>Serial GC&#x2F;Serial Old GC</em><br>单线程、STW、复制&#x2F;标记压缩算法（JDK8下的默认Client）</p><p><em>ParNew</em><br>多线程版Serial GC</p><p><em>Parallel Scavenge&#x2F;Parallel Old</em><br>多线程、STW、复制&#x2F;标记压缩算法，追求吞吐量（JDK8下的默认Server）</p><p><em>CMS（JDK9中已过时）</em><br>追求低延迟。<br><img src="/Pasted%20image%2020230326234445.png"></p><ul><li>单&#x2F;多线程，重新标记时使用多线程，低延迟。</li><li>因为并发清理，所以使用了标记清除算法，存在内存碎片</li><li>三色标记法，修正时把不考虑浮动垃圾，若A新增了指向B的指针，则把A标记为灰色。</li></ul><p><em>G1</em><br>延迟可控的情况下吞吐量，一般设置延迟和最大堆内存即可。<br><strong>现在互联网的项目，基本都是使用G1。</strong></p><p><em>G1分区</em><br>H区装大对象，Region之间使用空闲链表，Region内部使用指针压缩。<br><img src="/Pasted%20image%2020230326234923.png"></p><p><em>Rset</em><br>记忆集，避免全表扫描的关键，也用于其他分代GC。脏表是其具体实现，一个表512B，基于卡精度。<br>在发生引用关系变化时插入内存屏障（与volatile内存屏障是不同的概念），实现AOP的作用。<br><img src="/Pasted%20image%2020230326235238.png"></p><p><em>G1回收模式</em><br>Young GC：<br><img src="/Pasted%20image%2020230326235543.png"><br><strong>年轻代空间不足触发</strong>，回收Eden和Survivor区，STW，复制算法。</p><p>Mixed GC：</p><ul><li>并发标记<ul><li>STW，Root扫描使可达的年轻代晋级，然后触发一次YGC</li><li>并发标记，扫描区域回收价值</li><li>再次标记，三色标记法，B被取消引用时，将B标记为灰色</li><li>排序回收区域</li><li>并发清理（清除全为垃圾的Region）</li></ul></li><li>混合回收<ul><li>分8次回收，每次回收的流程与YoungGC类似（整理垃圾碎片）</li></ul></li></ul><p>Full GC：<br>复制算法时没有空的内存分段，回退到FullGC</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p><em>优化步骤</em><br>监控 &#x3D;&gt; 分析 &#x3D;&gt; 优化</p><p><em>指标</em><br>吞吐量、并发数、内存占用</p><p><em>监控依据</em></p><ul><li>日志</li><li>Exception堆栈</li><li>线程快照</li></ul><p><em>常用命令</em></p><ul><li>jps，查看java进程</li><li>jstat，查看统计信息</li><li>jinfo，JVM参数</li><li>jmap，内存dump文件</li><li>jstack，线程快照</li></ul><p><em>GUI</em></p><ul><li>Arthas：在线远程排查，需要在服务端开启arthas，客户端对其进行连接；<ul><li>启动：<code>java -jar arthas-boot.jar</code>，选择进程后开启监控面板；</li><li><code>thread 1</code>打印线程id为1的栈；</li></ul></li><li>JProfiler：有样本采集（每隔一段时间快照）和重构模式（侵入式统计）两种模式。</li></ul><p><em>火焰图</em><br>对栈的采样，横轴不代表时间，仅仅将顶部方法按字母排列，但宽度更宽的表示采样中出现的频率越多，可能是性能瓶颈。</p><p><em>运行参数</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">//大小设置<br>-Xms&lt;size&gt; 设置初始 Java 堆大小  <br>-Xmx&lt;size&gt; 设置最大 Java 堆大小  <br>-Xss&lt;size&gt; 设置 Java 线程堆栈大小<br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8  <br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br><br>//快照<br>-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件<br><br>//GC选择<br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务<br>//GC信息<br>-XX:+PrintGC &lt;==&gt; -verbose:gc 打印简要日志信息<br>-XX:+TraceClassLoading 监控类的加载<br></code></pre></td></tr></table></figure><p><em>GC日志</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br><br>[GC(原因)][GC回收器：年轻代回收前内存占用-&gt;年轻代回收后内存占用（区域总内存）]总内存变化，时间][时间：用户时间，核心时间，实际时间]<br></code></pre></td></tr></table></figure><p><em>JVM调优实际案例</em></p><ul><li>合理配置JVM参数，如栈(-xss)、堆内存(-xms,-xmx)，选择合适的GC回收器。（IO密集型的可以稍微把「年轻代」空间加大些，因为大多数对象都是在年轻代就会灭亡。内存计算密集型的可以稍微把「老年代」空间加大些，对象存活时间会更长些）</li><li>项目应用中，就适当调大了young区，因为接收到的大多数产线数据处理后即回收。</li><li>-XX:MetaspaceSize，初始元空间大小，建议设置大一点，以免项目启动时为了调整元空间大小频繁Full GC。</li></ul><p><em>其他概念</em></p><ul><li>浅堆：对象本身的内存</li><li>保留集：对象及其可访问的对象</li><li>深堆：保留集中对象的内存</li><li>对象实际大小：深堆</li><li>支配树：如果所有指向B的支配路径都经过A，则A支配B，如果A离B最近，则A是B的直接支配者。</li><li>内存泄漏：有不用或不常用的垃圾无法回收</li><li>内存溢出：内存泄漏常常导致内存溢出</li></ul><h1 id="五、IO"><a href="#五、IO" class="headerlink" title="五、IO"></a>五、IO</h1><h1 id="六、Spring"><a href="#六、Spring" class="headerlink" title="六、Spring"></a>六、Spring</h1>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java复习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计网复习</title>
    <link href="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><em>端对端通信的方式</em><br>C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p><p><em>互联网与因特网的区别</em><br>互联网通用名词，因特网是专有名词（指基于TCP&#x2F;IP的世界最大的互联网）</p><p><em>信号的交换方式</em><br>电路交换、报文交换、分组交换，特点：</p><ul><li>电路交换：需要提前建立连接预约信道。</li><li>报文交换：时延较高、需要较大的缓存空间。</li><li>分组交换：存在分组乱序、重复、丢失的问题。</li></ul><p><em>网络按覆盖范围分类</em><br>广域网（WAN）、城域网（MAN）、局域网（LAN）、个域网（PAN）</p><p><em>性能指标</em></p><ul><li>速率：kb&#x2F;s，其中k是1000<ul><li>带宽：最高速率</li><li>吞吐量：实际速率</li></ul></li><li>时延：时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</li><li>时延带宽积：时延带宽积 &#x3D; 传播时延 * 带宽</li><li>往返时间：RTT</li><li>利用率：信道上有数据流动的时间&#x2F;总时间</li><li>丢包率：丢失分组&#x2F;总分组</li></ul><p><em>体系结构</em><br>物数网传会表应</p><p><em>协议三要素</em></p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><p><em>物理层的责任</em><br>传输比特流</p><p><em>串行与并行传输</em></p><ul><li>串行传输（主要用于传输链路上）：一条信道</li><li>并行传输（主要用于计算机内部）：多条信道</li></ul><p><em>同步与异步传输</em></p><ul><li>同步传输：以<strong>比特流</strong>的形式传输，字节之间没有间隔。</li><li>异步传输：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</li></ul><p><em>单工与双工传输</em></p><ul><li>单工：单向传输</li><li>半双工：双向（不能同时）</li><li>双工：双向（同时）</li></ul><p><em>编码与调制</em></p><ul><li>码元：基本波形</li><li>处理信号的方式：编码（数字信号）、调制（模拟信号）。</li><li>编码方式：不归零编码 -&gt; 归零编码 -&gt; 曼彻斯特编码（跳变方向决定0，1） -&gt; 差分曼彻斯特编码（码元开始处是否跳变决定0,1）</li><li>调制方式：调幅、调频、调相，其中调频和调相不同时进行。</li></ul><p><em>信道极限容量</em></p><ul><li>奈氏准则：最高码元速率 &#x3D; 2 * W 信道带宽（Hz） * 每秒码元数（Baud）</li><li>香农公式：极限传输速率 &#x3D; W * log(1+S&#x2F;N)，主要体现信噪比对极限的影响</li></ul><p><em>信道利用率</em><br>发送时延&#x2F;(发送时延+往返时间+接受时延)</p><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><p><em>数据链路层的责任</em><br>数据链路层传送的协议数据单元是<strong>帧</strong>，要实现<strong>封装成帧</strong>，<strong>差错控制</strong>，<strong>可靠传输</strong>的功能。</p><blockquote><p>相关协议：PPP协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议、ARP协议。</p></blockquote><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><h3 id="MAC帧与PPP帧"><a href="#MAC帧与PPP帧" class="headerlink" title="MAC帧与PPP帧"></a>MAC帧与PPP帧</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/24878825-bf6fe42eeea3f376.webp"></p><p>MAC帧(6624)：MAC，MAC，类型，FCS<br>PPP帧(111221)：标志F、地址A、控制C、协议P、FCS、标志</p><p><em>前导码</em><br>MAC帧有前导码，其包括前同步码与帧定界符，同时维持帧间间隔（96比特时间）作为分界点。<br>PPP帧有前后标志符。</p><p><em>透明传输</em><br>为了实现透明传输，使用了转义字符防止混淆定界符。</p><p><em>MTU(Max Transfer Unit)</em><br>1500，MAC帧携带的数据载荷不能超过MTU。</p><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>CRC（<em>Cyclic Redundancy Check</em>）循环冗余校验。<br>错误时是丢弃还是重传取决于向上提供可靠的传输服务还是不可靠的传输服务。</p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>对于比特差错：根据要求实现重传或交由上层处理。<br>对于分组差错（丢失、失序、重复）：数据链路一般是单条链路的，分组差错一般发生在上层（网络层）。</p><p><em>可靠协议</em><br>核心是超时重传机制、标识符ID，也可以有快速重传。其思想不仅用于数据链路层，而是被更广泛的应用于传输层和应用层。</p><ul><li>停止等待：发送窗口 &#x3D; 1，接受窗口 &#x3D; 1。</li><li>回退N帧：发送窗口 &#x3D; n，接受窗口 &#x3D; 1，累计确认。</li><li>选择重传：发送窗口 &#x3D; n，接受窗口 &#x3D; n，逐条确认。</li></ul><h2 id="具体协议"><a href="#具体协议" class="headerlink" title="具体协议"></a>具体协议</h2><p>针对不同信道有不同实现</p><h3 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h3><h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/24878825-b384615e861000f3.webp"><br>PS：端对端是P2P(Peer-to-Peer)。</p><h3 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h3><ul><li>CSMA&#x2F;CD协议：载波监听、多址接入、碰撞检测。（因为交换机的出现，现在不会发生碰撞，该协议已经过时）</li><li>CSMA&#x2F;CA协议：载波监听、多址接入、碰撞避免。（主要用于无线网）。实现细节有帧间间隔、退避算法、信道预约。</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p><em>Media Access Control</em><br>点对点信道中不需要，但广播信道中需要地址识别，因此有MAC地址，又称<strong>硬件地址或物理地址</strong>。</p><ul><li>长度：6字节</li><li>广播：FFFFFF</li><li>多播：第一个bit为1，其余根据多播列表设置。</li></ul><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>根据IP地址获取MAC地址，工作于数据链路层。</p><p><em>ARP高速缓存表</em><br>根据IP地址在<strong>ARP高速缓存表</strong>（自动获取的会过期，也可手动设置）中搜索MAC地址。</p><p><em>ARP请求报文</em><br>MAC帧广播（数据链路层协议），目的IP地址的主机接受到请求后返回其对应的MAC地址。</p><blockquote><p>数据的转发过程中，源IP和目的IP地址不会变动，而源MAC地址和目的MAC地址会变动。</p></blockquote><p><em>帧交换表</em><br>交换机需要通过自学习算法（也会广播搜索），获取MAC地址对端口的映射关系，并记录在帧交换表中。</p><p><em>生成树协议STP</em><br>避免网络环路带来的广播风暴，从逻辑上切断某些链路实现无环路的树状结构，故障时再启用。</p><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>为避免广播风暴，建立虚拟局域网（逻辑上），隔离广播域。</p><h1 id="四、网际层"><a href="#四、网际层" class="headerlink" title="四、网际层"></a>四、网际层</h1><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong><br>MAC 的作用是实现「直连」的两个设备之间通信，而 IP 负责在「没有直连」的两个网络之间进行通信传输。</p><blockquote><p>相关协议：IP协议、网际控制报文协议ICMP、网际组管理协议IGMP。</p></blockquote><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><p><em>首部格式</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/24878825-73800cce52c3a91e.webp"><br>版首服总标标片，生协首源目。</p><blockquote><p>IP数据报，源IP在目的IP前；TCP报文，源端口在目标端口前。<br>但对于MAC帧的MAC地址，则是目地MAC地址在源MAC地址前。</p></blockquote><p>具体：</p><ul><li>标志（3bit）：<ul><li>DF位：是否允许分片；</li><li>MF位：是否是最后一个分片；</li><li>保留位。</li></ul></li><li>片偏移：单位为8字节。</li></ul><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>分类编址 -&gt; 划分子网 -&gt; 无分类编址</p><h4 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/7.webp"></p><p><em>广播</em><br>主机号全0即发送广播。</p><ul><li>本网络内的广播叫本地广播。</li><li>不同网络之间的广播叫直接广播。（有安全问题，默认为不转发）</li></ul><p><em>多播</em><br><strong>D类和E类地址是没有主机号的，所以不可用于主机 IP</strong><br>D类常被用于<strong>多播</strong>，后28位为组号，E类是预留的分类，暂时未使用。</p><p><em>缺点</em></p><ul><li>同一网络下没有地址层次</li><li>不能很好的与现实网络匹配</li></ul><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>子网掩码（划分子网纯属一个单位内部的事情，对外部网络透明）。</p><h4 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a>无分类编址</h4><p>不再有分类和子网概念。</p><p><em>路由聚合</em><br>为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。（配合最长路径匹配原则，解决路径寻优和静态路由配置产生的错误聚合问题。）</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6 的地址是 <code>128</code> 位的，每 16 位作为一组，每组用冒号 「:」 隔开。（与IPv4不兼容）<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/29.webp"></p><p><em>与IPv4分类上的区别</em></p><ul><li><strong>链路本地单播地址</strong>表示不经过路由器的同链路通信</li><li><strong>唯一本地地址</strong>相当于私有IP</li><li><strong>全局单播地址</strong>相当于公有IP</li></ul><p><em>与IPv4头部的区别</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/31.webp"></p><ul><li><strong>取消了首部校验和字段。</strong>（数据链路和传输层都校验，这里就省略了）</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong>（路由器不再可以分片，只允许源与目标主机分片重组）</li><li><strong>取消选项字段。</strong>（变成了下一个首部）。</li></ul><h2 id="IP数据包转发过程"><a href="#IP数据包转发过程" class="headerlink" title="IP数据包转发过程"></a>IP数据包转发过程</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/25.webp"></p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>目标IP地址与本网络掩码做与运算，判断是否属于本网段，若不属于则交付给默认网关。<br>当IP数据包大小大于MTU时，IP数据包就会被分片，TCP通过MSS提前分片，避免整个IP数据包重传。</p><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><ul><li>静态路由配置：手动配置，可能出现配置错误和聚合错误的问题。</li><li>动态路由配置：适应大规模网络，分层次，同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</li></ul><h3 id="交换机层次"><a href="#交换机层次" class="headerlink" title="交换机层次"></a>交换机层次</h3><ul><li>路由选择部分：路由表。通过与其他路由器之间交互得到最优的【目标IP、掩码、下一跳IP】。</li><li>分组转发部分：转发表，由路由表生成并存储更多的内容。另外包括了【MAC地址、端口、标记等】。</li></ul><blockquote><p>对比：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。</li><li>转发表：以上三表的组合。记录目标IP地址，子网掩码，网关，接口，跃点数等。</li><li>网关为空时默认已经到达目标地址</li><li>否则需要再转发</li></ul></blockquote><h3 id="路由选择协议-1"><a href="#路由选择协议-1" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><ul><li>RIP(<em>Routing Information Protocol</em>)，路由信息协议（自治系统内部，UDP）。以最短距离为最优，只和与本节点直接相连的路由器通讯，存在坏消息传的慢问题。</li><li>OSPF(<em>Open Shortest Path First</em>)，开放最短路径优先（自治系统内部）。以代价最低为最优，</li><li>BGP(<em>Border Gateway Protocol</em>)，边界网关协议（不同自治系统，TCP），自治系统选出发言人，由发言人进行可达性信息的交互，构造自治系统之间的联通图。</li></ul><blockquote><p>与ARP的STP生成树协议对比，STP协议是为了消除环路，而OSPF是为了找最佳路径。</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS域名解析，将域名转换为IP地址，是一个<strong>应用层协议</strong>（DNS是基于UDP的，其报文长度较短。）</p><p><em>运行机制</em><br>客户端向<strong>本地DNS服务器</strong>获取域名对应的地址，本地DNS通过<strong>迭代</strong>的域名解析方式寻找对应的IP地址，最后返回给客户端。</p><p><em>缓存</em><br>有浏览器缓存和操作系统缓存，且有时间限制。</p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>工作在<strong>传输层</strong>，在因为和IP地址的配置关系较密切，所以放在这里，基于UDP广播。<br>与 ARP 协议正好相反，它是<strong>已知MAC地址求IP地址</strong>。<br>通过提前配置RARP服务器，客户端可以发请求获取自己的IP地址，这是一种静态配置的方式。</p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>动态IP地址配置，全部基于UDP广播，是<strong>应用层协议</strong>。<br><em>流程</em></p><ol><li>客户端发起：DHCP DISCOVER报文+事务ID</li><li>服务端们回复：DHCP OFFER报文（包括自身信息和分配IP信息，租期）+事务ID</li><li>客户端发起：DHCP REQUEST报文（选择服务端和IP，租期）+事务ID</li><li>服务端回复：DHCP ACK报文</li></ol><p><em>续租</em></p><ol><li>客户端发起：DHCP REQUSET</li><li>服务端回复：DHCP ACK&#x2F;NACK</li></ol><p><em>中继代理</em><br>不同网段共用同一个DHCP服务器，通过路由器做中继代理。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p><em>Internet Control Message Protocol</em><br>网际控制报文协议，ICMP报文是基于IP数据报的。</p><h3 id="差错报文"><a href="#差错报文" class="headerlink" title="差错报文"></a>差错报文</h3><p><em>五种差错报文</em></p><ul><li>终点不可达：网络&#x2F;主机&#x2F;协议&#x2F;端口等找不到或由于路由器不支持分片导致不可达。</li><li>源点抑制：线路拥堵</li><li>超时：TTL超时</li><li>参数问题</li><li>重定向：发现不是最优路径</li></ul><h3 id="查询报文"><a href="#查询报文" class="headerlink" title="查询报文"></a>查询报文</h3><p><em>两种询问报文</em></p><ul><li>回送请求和响应</li><li>时间戳请求和响应</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><em>Ping</em><br>Packet InterNet Groper，分组网间探测，基于ICMP，基于UDP，封装在IP数据包中。<br>用于测试可达性和RTT，每条消息序号不同保证RTT的正确性。</p><p><em>traceroute</em><br>跟踪路由。原理是从1开始递增TTL发送报文，封装在IP数据包中，基于UDP。<br>故意不设置分片，可以确定路径的MTU。</p><h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><p><strong>IGMP是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p><p><em>工作机制</em></p><ol><li>路由器<strong>周期性</strong>发起<strong>IGMP 常规查询报文</strong>。</li><li>主机收到并随机延时后，回复<strong>IGMP成员关系报告报文</strong>，如果延时时收到其他主机的关系报文，则不再发送，减少网络中IGMP报文数量。</li><li>路由器接受到被注册的多播地址，则会进行转发。</li></ol><p><em>离开机制</em></p><ol><li>主机主动发起IGMP离开广播</li><li>路由器询问是否还有组成员</li><li>若有，则之后会继续转发该组播消息；否则，不再转发。</li></ol><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p><em>VPN</em><br>虚拟专用网（<em>Virtual Private Network</em>），功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p><em>NAT</em><br>网络地址转换（<em>Network Address Translation</em>），目的是IP复用，NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p><em>NATP</em><br>网络地址与端口转换，即同时进行端口转换。</p><p><em>缺点</em></p><ul><li>外部无法与内部客户端建立连接。</li><li>性能开销。</li><li>NAT路由器重置后所有TCP连接重置。</li></ul><p><em>解决</em></p><ul><li>IPv6</li><li>NAT穿透技术，应用程序主动绑定公网IP和端口</li></ul><h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><p><em>ping</em></p><ul><li>ping是应用层协议</li><li>ping 127.0.0.1时，软中断时会使消息直接返回，不走网卡。</li><li>ping 真实本地IP和ping 127.0.0.1一样，软中断直接返回，不走网卡。</li></ul><p><em>127.0.0.1与localhost</em></p><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h1 id="四、传输层"><a href="#四、传输层" class="headerlink" title="四、传输层"></a>四、传输层</h1><p>传输层的作用是<strong>向上面的应用层提供通信服务</strong>。只有位于网络边缘部分的主机的协议栈才有运输层，NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议。</p><p><em>端口号</em><br>端口号由16bit表示，范围为0-65535，<strong>不同的传输层协议（TCP、UDP）可以使用相同的端口，这是两个不同的通信模块。</strong><br>常见端口号：HTTP（80）、HTTPS（443）、FTP（20&#x2F;21）、DNS（53）</p><h2 id="TCP与UDP对比"><a href="#TCP与UDP对比" class="headerlink" title="TCP与UDP对比"></a>TCP与UDP对比</h2><blockquote><p>记忆思路：<br>从TCP的特点来看：</p><ul><li>面向连接、基于字节流、可靠性；</li></ul><p>然后对比UDP展开细节：</p><ul><li>UDP无连接，所以服务对象也可以是多播和广播</li><li>UDP以包为单位发送，包头小，不分片</li><li>UDP不基于流，没有滑动窗口的限制，因此无法实现流量控制和拥塞控制，无法防止乱序</li><li>UDP不可靠，只能尽可能交付。</li></ul></blockquote><p>根据上述思路，以下内容尽可能地阐述即可：<br><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议。</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 <strong>MSS</strong> 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 <strong>MTU</strong> 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><em>应用场景</em></p><ul><li>TCP用于文件传输、HTTP传输</li><li>UDP用于总量较少的数据如DNS，视频音频、广播通讯</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。<br><em>头结构</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207114528.png"></p><p><em>TCP连接本质</em><br>四元组、滑动窗口、序列号的信息组合，在Linux中就是一个文件。针对系统、用户、进程，有不同先最大个数文件描述符数量限制。</p><p><em>唯一的TCP连接</em><br>源地址、源端口、目标地址、目标端口。</p><p><em>TCP为什么分片MSS</em><br>将重传的基本单位由整个IP数据包缩小到TCP报文，实现最高的传输效率。</p><p><em>MSS与MTU</em><br>MTU &#x3D; IP头+TCP头+MSS</p><p><em>基于字节流</em><br>一条消息可能分为多个TCP报文，两个消息可能被分到同一个TCP报文。<br>由于TCP是基于流式处理的（UDP是基于数据包的），可能会导致粘包问题，需要手动解决，一般交给应用层：</p><ul><li>固定消息长度</li><li>指定边界字符（HTTP）</li><li>自定义消息结构</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><h4 id="TCP握手过程"><a href="#TCP握手过程" class="headerlink" title="TCP握手过程"></a>TCP握手过程</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp"><br>客户端状态：SYN_SEND-&gt;ESTABLISHED<br>服务端状态：LISTEN-&gt;SYN_RCVD-&gt;ESTABLISHED<br>（第三次握手时，可以携带数据）</p><p><em>三次握手原因</em><br>1.同步序列号（没必要四次） 2.避免历史连接（至少三次） 3.避免服务端资源浪费（至少三次）</p><p><em>随机初始化序列号的目的</em><br>1.防止历史消息 2.防止伪造消息（若初始化序列号总是相同则可能被伪装）</p><p><em>如何初始化序列号</em><br>client_isn &#x3D; M + F(四元组)</p><ul><li>其中M是计时器，4微妙加1，4.55小时一个循环。</li><li>其中F是Hash函数，推荐使用MD5防止被推测</li></ul><div class="note note-primary">            <p>只有初始化序列号的生成是随机的，后续序列号随字节数增长，循环的速度会很快，一圈大概为4G？，所以有时需要开启时间戳额外判断历史报文。</p>          </div><h4 id="TCP握手丢失"><a href="#TCP握手丢失" class="headerlink" title="TCP握手丢失"></a>TCP握手丢失</h4><p><em>第一次握手丢失</em></p><ul><li>客户端以相同序列号重传第一次握手。重发次数取决于<code>tcp_syn_retries</code>，默认为5次，初始重传时间为1s，总共耗时63s。</li><li>如果一直丢失，则重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>第二次握手丢失</em></p><ul><li>客户端以相同序列号重传第一次握手，细节同上。</li><li>服务端以相同序列号重传第二次握手。重发次数取决于<code>tcp_synack_retries</code>，默认为5次，初始重传时间为1s，总共耗时63s。</li><li>如果一直丢失，则<strong>客户端</strong>在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li><li>如果一直丢失，则<strong>服务端</strong>在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>第三次握手丢失</em></p><ul><li>服务端以相同序列号重传第二次握手，细节同上。</li><li>客户端收到第二次握手后回复第三次握手（不会主动重传ACK），如果一直丢失。</li><li>如果一直丢失，则<strong>服务端</strong>在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>总结</em></p><ul><li>SYN报文、SYNACK报文没收到回应会反复重传，直到次数用尽后自动关闭连接。</li><li>ACK报文不会重传。</li></ul><blockquote><p>对于非握手报文，重传的次数取决于<code>tcp_retries2</code>，默认为15次。</p></blockquote><p><em>TCP Fast Open</em><br>再次握手时简化握手流程，可设置<code>net.ipv4.tcp_fastopen</code>决定是否开启。<br>第一次连接时，由服务端在第二次握手时给客户端签发cookie，第二次连接时，直接在第一次握手时携带cookie和数据。</p><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230208000041.png"><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/3.webp"></p><h5 id="TCP半连接溢出"><a href="#TCP半连接溢出" class="headerlink" title="TCP半连接溢出"></a>TCP半连接溢出</h5><p><em>最大值</em><br>长度为max_syn_backlog和全连接队列长度中较小者的两倍。</p><p><em>策略</em><br>默认丢弃；若开启了tcp_syncookies（不使用 SYN 半连接队列的情况下成功建立连接，注意与TCP Fast Open区分），则不丢弃。</p><h5 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h5><p><em>方式</em><br>打满半连接队列</p><p><em>应对</em></p><ul><li>扩大半连接队列长度，扩大容量。</li><li>减少syn+ack重传次数，快速拒绝不合理的连接。</li><li>开启syncookies功能，绕过队列。</li></ul><h4 id="序列号和确认号"><a href="#序列号和确认号" class="headerlink" title="序列号和确认号"></a>序列号和确认号</h4><p>syn &#x3D; 上次syn + 上次数据长度len，（但SYN和FIN作为主动发出的控制，都需要占用1个syn）。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h4 id="TCP挥手过程"><a href="#TCP挥手过程" class="headerlink" title="TCP挥手过程"></a>TCP挥手过程</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207141651.png"><br>客户端状态：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE<br>服务端状态：ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSE</p><p><em>特殊情况：同时挥手</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/38.webp"><br>即在等待第二次握手时，直接收到了第三次握手需要的FIN。</p><p><em>四次挥手原因</em><br>关闭需要双方都没有数据再发送，两次FIN报文分别代表双方各自不再有数据发送。当然如果没有数据发送，且开启了<strong>TCP延迟确认机制</strong>功能，则可以变成3次。</p><p><em>TCP延迟确认机制</em></p><ul><li>没数据需要主动发送时延迟确认。</li><li>有数据发送时或再收到SYN时则立刻确认回复。</li></ul><p><em>两种关闭</em></p><ul><li><code>close</code>函数，该进程不再使用该连接，如果此时连接的引用计数变为0，则关闭该连接的读功能和写功能，并发送FIN报文。</li><li><code>shutdown</code>函数，立刻将该连接的写方向关闭，并发送FIN报文，更加优雅。</li></ul><div class="note note-primary">            <p>SHUTDOWN比CLOSE优雅，但CLOSE仍然是主流的断开连接方式，并且可以指定CLOSE行为（挥手或直接RST）</p>          </div><p>当客户端调用<code>close</code>且发送FIN后，再收到服务端的数据时，会回复RST：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230208001214.png"></p><h4 id="TCP挥手丢失"><a href="#TCP挥手丢失" class="headerlink" title="TCP挥手丢失"></a>TCP挥手丢失</h4><p><em>第一次挥手丢失</em></p><ul><li>客户端重传第一次挥手。重发次数取决于<code>tcp_orphan_retries</code>，默认为8次。</li><li>如果一直丢失，则重传次数用完后，等待2倍上次重传间隔时间后关闭连接。</li></ul><p><em>第二次挥手丢失</em></p><ul><li>客户端重传第一次挥手，细节同上。</li><li>如果一直丢失，则重传次数用完后，等待2倍上次重传间隔时间后关闭连接。服务端在没有消息需要发送时，会发送第三次握手。</li></ul><p><em>第三次挥手丢失</em></p><ul><li>服务端重传第三次挥手，细节同上。</li><li>如果一直丢失，服务端在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。客户端的<strong>FIN_WAIT2状态超时</strong>后自动关闭（默认60s）。</li></ul><p><em>第四次挥手丢失</em></p><ul><li>服务端重传第三次挥手，细节同上。</li><li>客户端进入TIME_WAIT状态，接收到第三次挥手后继续回复第四次挥手，帮助服务端正常关闭。</li><li>如果一直丢失，服务端在重传次数用完后，等待2倍上次重传间隔时间后关闭连接。客户端的<strong>TIME_WAIT状态超时</strong>后自动关闭（默认60s）。</li></ul><div class="note note-primary">            <p>FIN_WAIT2和TIME_WAIT的默认时间都是60s，为2 × MSL（最大生存时间），即一来一回的时间。</p>          </div><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p><em>TIME_WAIT作用</em></p><ul><li>帮助服务端正确关闭（进入CLOSE状态则会回复RST给服务端）。</li><li>处理本次会话中的历史消息，避免被后面相同的四元组连接接受。</li></ul><p><em>TIME_WAIT过多</em></p><ul><li>占用资源，端口</li></ul><p><em>TIME_WAIT优化</em></p><ul><li>增大<code>net.ipv4.tcp_max_tw_buckets</code>，超过时后面的TIME_WAIT状态直接重置。</li><li>开启<code>net.ipv4.tcp_tw_reuse</code>和<code>net.ipv4.tcp_timestamps</code>选项，将TIME_WAIT超过1s的连接随机取出复用。</li><li>开启SO_LINGER，更改close函数的行为变成直接发送RST跳过挥手环节。</li><li><code>tcp_tw_recycle</code>，其允许快速挥手TW状态，但由于PAWS判断历史报文机制的依据是IP而不是IP+端口，所以可能导致NAT条件（多设备复用IP）下不同设备时间戳不同引起的干扰问题，从而丢弃报文。</li></ul><div class="note note-primary">            <p>close函数成功关闭连接时，发送FIN，后续若接受到服务端的新数据时回复RST。<br>开启SO_LINGER后，直接发送RST。</p>          </div><p><em>服务端大量TIME_WAIT</em><br>注意只有主动关闭TCP连接的一方会有TIME_WAIT状态。</p><ul><li>HTTP未开启长连接，此时需要服务端主动关闭TCP连接。</li><li>HTTP长连接超时，此时需要服务端主动关闭TCP连接。</li><li>HTTP长连接请求数量达到上限，此时需要服务端主动关闭TCP连接。</li></ul><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>服务端和客户端都可以开启。<br>长时间没有消息来往，会每隔一段时间发送探测报文，如均无响应则关闭。默认为2小时开始发送，时间间隔为75s（均匀的时间），默认9次。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，客户端程序正常工作的。会响应探测信息，重置保活。</li><li>第二种，客户端程序崩溃，不会触发保活，操作系统会回收资源完成挥手。</li><li>第三种，客户端主机宕机并重启。回复RST，直接触发关闭。</li><li>第四种，客户端主机宕机或报文不可达。多次探测后关闭连接。</li></ul><h3 id="重传滑动窗口、流量控制、拥塞控制"><a href="#重传滑动窗口、流量控制、拥塞控制" class="headerlink" title="重传滑动窗口、流量控制、拥塞控制"></a>重传滑动窗口、流量控制、拥塞控制</h3><h4 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h4><p>几种常见重传机制：</p><ul><li>超时重传（超时重传时间RTO略大于RTT，过小造成不必要的重传、过大导致传输效率低下）</li><li>快速重传（连续三个相同ACK则快速重传）</li><li>SACK，选择性确认（接受方回复已经收到的数据区间）</li><li><strong>D-SACK</strong>，重复确认（接受方回复接受到的重复数据区间），默认开启</li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>通过滑动窗口实现<strong>批量发送，累计确认、累计应答</strong>。<br>底层实现是数组，属性有数组长度以及相关指针。<br>发送窗口swnd &#x3D; min(拥塞窗口cwnd，接受窗口rwnd)，即窗口大小同时受接受方接受能力和网络负荷的影响。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方接受到ACK后移动窗口并调整发送窗口。<br>接受方接受到SEQ后移动窗口并调整接受窗口。</p><p>移动窗口和调整窗口本质上是指针的移动，考虑如下场景：<br>1）接受方应用程序读取较慢：</p><ol><li>首先窗口移动应用程序读走的字节数量（长度不变）</li><li>对于已经接受但来不及被应用程序读走的字节数，通过移动左指针的方式收缩窗口（长度变短），并通知发送方缩小窗口，发送方也只移动左指针。</li></ol><p>2）接受方资源紧张</p><ol><li>此时操作系统可能会直接减少<strong>接受缓冲区</strong>的大小，导致右指针左移（长度变短）。</li><li>由于应用程序来不及都走部分字节，导致左指针右移（长度变短）。</li><li>接受方通知发送方缩小窗口，但由于1中左移，可能导致发送方已经发出了接受方此时无法接受的消息。</li></ol><p>因此，TCP不允许同时<strong>缩小窗口</strong>和<strong>减少缓存</strong>，必须先缩小窗口，再减少缓存。（保证右端不会左移）。</p><p><em>零窗口探测报文</em><br>窗口大小为0时，可能造成双方的无限等待，因此发送方会在零窗口通知后启动计时器，默认每30s发送一个探测报文，发送3次，若均接受不到回复或窗口仍为0，则发送RST断开连接。<br>注意与保活报文对比，保活报文会在无消息后2小时以75秒为周期发送9次，零窗口探测报文会在窗口大小为0后以30s为周期发送3次。</p><p><em>糊涂窗口综合征</em><br>发送方为了几个字节而发送一个TCP包，叫做糊涂窗口综合症。</p><p><em>解决糊涂窗口综合征</em><br>1）Nagle算法</p><ol><li>接受方在<strong>窗口大小&lt;min(MSS，缓存空间&#x2F;2)</strong> 时，通知发送方窗口为0。</li><li>发送方开启Nagle算法，即只有<strong>窗口&gt;&#x3D;MSS且数据大小&gt;&#x3D;MSS</strong>或<strong>收到ACK包</strong>才发送。</li></ol><p>2)开启延迟确认<br>可以避免小报文，会导致4次挥手变成3次。</p><p>以上两种方案不能同时使用：<br>延迟确认和Nagle算法互锁，导致只能等接受方延迟超时回复，网络传输效率降低。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p><strong>拥塞窗口cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>主要有4种算法：<br>1.慢启动 2.拥塞避免 3.拥塞发生 4.快速恢复</p><p><em>慢启动</em><br>每收到一个ack（ack字节数，不是ACK报文数），cwnd大小加1，指数增长。</p><p><em>拥塞避免</em><br>每收到一个ack（ack字节数，不是ACK报文数），cwnd增加1&#x2F;cwnd，线性增长。</p><p><em>拥塞发生</em><br>1）如果是超时重传机制，则<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/299.webp"></p><ul><li><code>ssthresh</code> &#x3D; <code>cwnd/2</code>，即慢启动门限为当前窗口大小的一半。</li><li><code>cwnd</code> &#x3D; <code>1</code>，重置拥塞窗口。</li></ul><p>2）如果是快速重传机制，则：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230318013534.png"></p><ul><li><code>ssthresh = cwnd/2</code>，即慢启动门限为当前窗口大小的一半。;</li><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li>触发快速恢复算法</li></ul><p><em>快速恢复算法</em></p><ul><li><code>cwnd = ssthresh + 3</code>，快速重传丢失的数据包，收到新ACK后，恢复拥塞避免。</li><li><code>cwnd = ssthresh</code></li></ul><h3 id="TCP优化"><a href="#TCP优化" class="headerlink" title="TCP优化"></a>TCP优化</h3><p>主要是修改一些参数实现机制、性能的修改。</p><h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p><em>客户端优化</em><br>修改tcp_syn_retries</p><p><em>服务端优化</em></p><ul><li>tcp_synack_retries</li><li>扩大半&#x2F;全队列大小</li><li>tcp_syn_cookies</li><li>tcp_fastopen</li></ul><h4 id="挥手"><a href="#挥手" class="headerlink" title="挥手"></a>挥手</h4><p><em>客户端优化</em><br>1）FIN_WAIT1优化</p><ul><li>tcp_orphan_retries</li><li>tcp_max_orphans</li><li>SO_LINGER修改CLOSE默认行为为直接发送RST</li></ul><p>2）FIN_WAIT2优化</p><ul><li>修改FIN_WAIT2最长持续时间</li></ul><p>3）TIME_WAIT优化</p><ul><li>tw-reuse + timestamp（防止过期和绕回）</li><li>max_tw_buckets</li></ul><p><em>服务端优化</em><br>1）CLOSE_WAIT优化<br>tcp_orphan_retries</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li>滑动窗口大小</li><li>缓存区大小</li><li>最大传输速度</li><li>TCP内存大小</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><em>SYN报文什么时候情况下会被丢弃</em></p><ul><li>半连接、全连接队列数量限制且没开syncookies设置。</li><li>为了复用TIME_WAIT开启<strong>tcp_tw_recycle</strong>，开启了时间戳，在NAT网络下消息过期被丢弃。</li></ul><p><em>已建立连接的TCP，收到SYN会发生什么</em></p><ul><li>客户端的SYN报文里的端口号与历史连接不相同：建立新连接。（如Socket编程中的accept）</li><li>客户端的SYN报文里的端口号与历史连接相同：<ul><li>服务端回复ACK（Challenge ACK：包含正确的序列号和确认号）。</li><li>客户端回复RST（即这个ACK处理不了）</li></ul></li></ul><p><em>发起RST的情况</em></p><ul><li>接受端在已经建立了TCP连接的情况下，收到SYN序列同步报文，回复一个Challenge ACK，发送端发现处理不了这个ACK，意味着发送端无法再发送正确的报文，从而回复RST。</li><li>主动端调用close，且使用了SO_LINGER行为。</li><li>主动端调用close关闭读和写方向后，服务端继续发送应用数据过来，回复RST。</li><li>接受端处于CLOSE状态，收到普通报文。</li><li>零窗口探测，窗口始终为0，发送RST</li></ul><p><em>收到乱序的FIN包如何处理</em><br>对方数据包发生延迟，导致先收到了对方的FIN报文，因此会将其放入到「乱序队列」，等待延迟数据包到达后，检查乱序队列并选择进入下一阶段。</p><p><em>在TIME_WAIT状态的TCP连接，收到SYN后会发生什么</em><br>判断序列号是否合法：若时间戳和syn序号都比期望大，说明是新连接请求</p><ul><li>合法SYN则重用</li><li>非法SYN则回复Challenge ACK，对方会回复RST，接受RST后根据策略选择抛弃RST或维持TIME_WAIT状态到结束。</li></ul><div class="note note-primary">            <p>接收方发现非法SYN会回复正确（Challenge）的ACK。<br>发送方发现非法ACK会回复RST。</p>          </div><p><em>TCP 连接，一端断电和进程崩溃有什么区别？</em><br>根据是否有数据传输、是否重启分类讨论。</p><p><em>拔掉网线后， 原本的 TCP 连接还存在吗？</em><br>本质就是数据丢包了。</p><p><em>tcp_tw_reuse 为什么默认是关闭的</em></p><ul><li>tw是很有必要的</li><li>要防止tcp_tw_recycle和PWSA机制带来的问题。</li></ul><p><em>TLS和TCP可以同时握手吗</em><br>只有以下两点同时满足，因为发TLS的前提是TCP的建立，跳过TCP的三步握手则需要TCP Fast Open，此时可以携带TLS信息发起握手，使用TLS1.3，直接通过Ticket实现快速连接。</p><ul><li><strong>客户端和服务端已经完成过一次通信。</strong></li><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li></ul><p><em>TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</em><br>TCP保活是探测目标是否存活的机制。<br>Http保活则是复用TCP连接。</p><p><em>TCP一定可靠吗？</em><br>只保证传输层的可靠性。</p><p><em>队列满了的行为</em></p><ul><li>半连接队列满了，根据cookies判断是否丢弃。</li><li>全连接队列满了，根据策略判断是丢弃还是RST。</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207115326.png"></p><p><strong>为什么UDP头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207115616.png"><br>UDP的头部理论上也可这样省略，保留的原因可能有：</p><ul><li>保持4的整数倍。</li><li>当年UDP协议可能不是基于IP发展的。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC是一个基于UDP的传输层协议，其实现了可靠传输。</p><p><em>特点</em></p><ul><li>无队头阻塞：不像TCP会发送传输层阻塞，本stream建立在传输层，不同stream之间不需要保证顺序。</li><li>快速连接：不像TCP要建立连接，且握手过程与TLS合并。</li><li>连接迁移：不像TCP通过4元组标识连接，而是通过连接id确定连接。</li></ul><p><em>连接过程</em><br>QUIC三次握手，交换连接id。同时合并TLS&#x2F;1.3的3次握手，实现1RTT握手。<br>再次连接时，通过连接id记录和TLS的Ticket技术，实现0RTT握手。</p><p><em>连接时间</em><br>以下是TCP+TLS1.2，TCL+TLS1.3，QUIC三种情况在首次和再次需要的RTT时间：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230206210341.png"></p><div class="note note-primary">            <p><strong>RTT是针对客户端建立连接耗时。</strong><br>TCP+TLS1.2：</p><ul><li>首次：TCP三次握手+TLS四次握手（TCP第三次握手合并TLS第一次握手，最后合并为6个）：3RTT</li><li>再次：TCP三次握手+TLS两次握手（TCP第三次握手合并TLS第一次握手，TLS使用Session技术，合并为4个）：2RTT<br>TCP+TLS1.3:</li><li>首次：TCP三次握手+TLS三次握手（TCP第三次握手合并TLS第一次握手，合并为5个）：2RTT</li><li>再次：TCP三次握手+TLS零次握手（TCP第三次握手合并TLS第一次握手，TLS使用Ticket技术，合并为3个）：1RTT<br>QUIC+TLC1.3：</li><li>首次：QUIC三次握手+TLS三次握手（全程合并，为3个）：1RTT</li><li>再次：QUIC一次握手+TLS零次握手（QUIC连接迁移，TLS使用Ticket技术，合并为1个）：0RTT</li></ul><p>RTT记忆：32,21,10。</p>          </div><h1 id="五、应用层"><a href="#五、应用层" class="headerlink" title="五、应用层"></a>五、应用层</h1><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>超文本传输协议，<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。<br>超文本：超越文本；<br>传输：双向协议；<br>协议：约定与规范。</p><p><em>状态码</em></p><ul><li>1xx，中间状态，提示信息</li><li>2xx，成功，如「<strong>200 OK</strong>」，「2O4 N0 Content」，「2O6 Partial Content」</li><li>3xx，重定向，如「<strong>301 Moved Permanently</strong>」，「302 Found」。</li><li>4xx，失败，如「<strong>400 Bad Request</strong>」，「403 Forbidden」，「<strong>404 Not Found</strong>」</li><li>5xx，服务器错误，如「<strong>500 Internal Server Error</strong>」，「<strong>502 Bad Gateway</strong>」</li></ul><p><em>常见字段</em></p><ul><li>Host：服务器域名</li><li>Connection：Keep-Alive</li><li>Accept：可接受格式</li><li>Content-Type：本次数据格式</li><li>Content-Length：数据长度</li><li>Content-Encoding：压缩方式</li></ul><p><em>GET和POST</em><br>get：语义是获取资源（<strong>可放入body也可放入url</strong>）<br>post：语义是操作资源（<strong>请求参数放入body</strong>）</p><p><em>安全和幂等</em><br>安全：不破坏服务器资源<br>幂等：多次执行结果不变<br>GET安全且幂等，POST不安全不幂等</p><blockquote><p>实际上开发者也可以不遵守这个规定。</p></blockquote><h3 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h3><p><em>强制缓存和协商缓存</em><br>强制缓存默认使用缓存，协商缓存可以每次询问服务器是否有更新，必须配合</p><p><em>两种强制缓存方式</em><br>HTTP响应头可以表示资源的缓存时间：</p><ul><li><code>Cache-Control</code>，是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p><em>两种协商缓存方式</em><br><strong>以下两种协商缓存需要配合强制缓存Cache-Control使用，强制缓存未命中时进行协商，尽可能减少服务器负担。</strong><br>方法一：时间戳</p><ul><li>响应头中的<code>Last-Modified</code>：资源最后的修改时间</li><li>请求头中的<code>If-Modified-Since</code>：告诉服务器上次接受资源的时间</li></ul><p>方法二：E-tag（优先级更高，更合理，因为时间戳是秒级的）</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：告诉服务器上次接受资源的ID。</li></ul><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p><em>特点</em></p><ul><li>HTTP长连接：复用TCP连接（可以指定时间，一般由服务器关闭）</li><li>管道网络传输（默认关闭，且未被浏览器使用）：解决请求的<strong>队头</strong>阻塞，但要按照接受到请求的顺序返回响应</li></ul><p><em>缺点</em><br>性能：数据量大、响应队头阻塞<br>安全性：不安全，明文</p><p><em>优化</em></p><ol><li>避免发送请求<ul><li>使用HTTP缓存</li></ul></li><li>减少发送请求<ul><li>减少重定向（代理服务器完成重定向）</li><li>合并请求</li><li>延迟请求</li></ul></li><li>减少响应数据大小（主要用于视频，音频）<ul><li>压缩数据</li><li>增量数据（在原帧上迭代）</li></ul></li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>在TCP和HTTP层之间添加了SSL&#x2F;TLS 安全协议。</p><p><em>解决的问题</em><br>窃听，篡改，冒充</p><p><em>如何解决</em></p><ul><li><strong>混合加密</strong>，使用非对称加密交换密钥，使用对称加密加密信息防止<strong>窃听</strong></li><li>使用<strong>摘要算法</strong>防止<strong>篡改</strong></li><li>使用CA<strong>数字证书</strong>防止<strong>冒充</strong></li></ul><p><em>混合加密</em></p><ul><li>对称加密，一个密钥，速度快。</li><li>非对称加密，两个密钥，速度慢，公钥加密私钥解密防止窃听，私钥加密公钥解密防止冒充。</li></ul><p><em>摘要算法</em><br>使用摘要算法（Hash）计算内容，防止被篡改，一般算法有SHA系列。<br>但如果原文和摘要一起被替换，则无法保证安全。</p><p><em>数字证书</em><br>数字证书机构CA流程：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp"></p><ul><li>服务器可将自己的基本信息和公钥以及摘要注册到CA机构</li><li>CA机构使用自己的私钥加密摘要信息，并颁发CA证书</li><li>客户端只有使用CA的公钥解密服务器的摘要（保证是CA认证过的证书），再对比服务器发出的CA证书的摘要，才可确定是否可信。</li></ul><p>CA机制：</p><ul><li>信任链：一般操作系统和浏览器不会直接信任根CA，而是通过信任链的方式，确保根节点的安全性，进行多级隔离。</li><li>验证链：验证时，服务器找中间证书验证，中间证书找根证书认真，根证书自认证。</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p><em>SSL&#x2F;TLS</em><br>SSL标准化后变成TSL。<br>SSL（“_Secure Sockets Layer_”） 即「安全套接层」。<br>TLS（ “_Transport Layer Security_” ），即「传输层安全协议」。</p><h4 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h4><p>TLS 协议建立的详细流程：<br><em>1. ClientHello</em>（明文）<br>（1）客户端生产的随机数（<code>Client Random</code>）。<br>（2）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2.SeverHello</em>（明文）<br>（1）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。<br>（2）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</p><p><em>3.客户端回应</em>（服务器公钥加密）<br>验证CA证书，取出服务器公钥：<br>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><em>4. 服务器的最后回应</em><br>计算出本次通信的「会话秘钥」。<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><h4 id="握手算法"><a href="#握手算法" class="headerlink" title="握手算法"></a>握手算法</h4><p><em>RSA</em><br>无法前向加密，服务器私钥泄漏后第三个随机数可被解析，之前的密文都会被解密。</p><p><em>DH</em><br>非对称加密算法，使用私钥根据特定离散数学算法可以算出公钥，但无法反推。<br>双方各自计算非对称密钥并交换公钥，根据<strong>对方公钥和我方私钥</strong>，得到相同的密钥（交换律）。</p><ul><li>static DH，每次使用相同的密钥，废弃</li><li>DHE，动态生成密钥，常用</li></ul><p><em>ECDHE</em><br>使用椭圆曲线加速DHE的计算过程，需要协商曲线和基点，步骤：</p><ul><li>第一次握手类似，发出<strong>随机数1</strong>。</li><li>第二次握手回复<strong>随机数2</strong>，服务器选择DHE密码套件，并选择<strong>曲线和基点</strong>，<strong>使用RSA签名曲线公钥</strong></li><li>第三次握手客户端验证CA后，就可以计算出<strong>曲线私钥和曲线公钥</strong>，<strong>使用对称加密的方式加密公钥并回复</strong></li><li>第四次握手类似。</li></ul><blockquote><p>第二次握手时，双方共享了<strong>随机数1、随机数2、曲线、基点、服务端公钥</strong>。<br>最终密钥在结合椭圆曲线密钥混合结果的情况下，还混入了两个随机数，进一步加强保密性。</p></blockquote><h4 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h4><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/tls1.2and1.3-1.webp"><br><em>流程</em><br>默认使用ECDHE，跳过了密钥选择的过程，只需要3次握手。</p><ul><li>第一次握手，由客户端完成椭圆曲线、基点的选择并直接发送公钥</li><li>第二次握手，服务端根据椭圆生成私钥和公钥后，发送公钥</li><li>第三次握手，此时已经完成了密钥计算，进行验证，且可携带请求。</li></ul><p><em>Ticket</em><br>Ticket技术可以实现1RTT重连，但无法实现前向安全性。</p><p><em>Pre-shared Key</em><br>类似Ticket，0RTT重连，因为其会把HTTP请求与TLS连接一同发送给服务器。</p><h4 id="TLS底层实现"><a href="#TLS底层实现" class="headerlink" title="TLS底层实现"></a>TLS底层实现</h4><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议，指TLS握手交换密钥得到对称加密的密钥的过程。</li><li>TLS 记录协议，指使用对称加密密钥加密记录的过程。</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的<strong>切割</strong>，<strong>压缩</strong>，<strong>认证</strong>，<strong>加密</strong>，过程如下图：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p><em>HTTPS一定可靠吗？</em><br>一定，除非用户接受不可信的证书。</p><p><em>如何避免被抓包？</em></p><ol><li>不允许非法证书</li><li>HTTPS双向认证，服务端也要验证客户端的CA证书。</li></ol><p><em>优化</em></p><ul><li>选择特化算法的CPU</li><li>使用新协议，TLS&#x2F;1.3，ECDHE</li><li>证书优化<ul><li>证书吊销列表CRL维护复杂，淘汰</li><li>在线证书状态协议OCSP，由服务端在线维护证书。</li></ul></li><li>会话复用<ul><li><strong>Session ID</strong> 1RTT，不一定命中</li><li><strong>Session Ticket</strong> 1RTT，性能消耗，不具有前向安全性</li><li><strong>Pre-shard Key</strong> 0RTT，TLS1.3使用，原理与Ticket类似。</li></ul></li></ul><blockquote><p><strong>重放攻击</strong>：session或ticket被获取，从而模仿攻击，因此需要给session和ticket设置过期时间。</p></blockquote><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/25-HTTP2.webp"><br><em>特性</em></p><ul><li>头部压缩：HPACK算法<ul><li>维护头信息表：id-&gt;请求头</li><li>分静态和动态字典（有上限，到达后关闭）</li><li>使用Huffman编码</li></ul></li><li>二进制格式：<ul><li>不再使用换行来分隔，而是使用length来分割id和value。</li><li>数据帧会被分为控制帧和数据帧（头信息帧和数据帧）。</li></ul></li><li>并发传输<ul><li>引入strean概念，一个stream表示一次请求中双方会进行的所有通信。</li><li>多个stream复用一个TCP连接，不同的stream之间的frame互不干涉，同一个stream中的frame必须有序发送接受。</li></ul></li><li>主动推送<ul><li>服务器建立的stream id肯定为偶数，其可主动推送数据（如css文件）。需要在响应中通知客户端接下来将在哪个stream id中发送包体。</li></ul></li></ul><p><em>缺点</em><br>仍存在队头阻塞问题，问题出在TCP层面。</p><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p>UDP+QUIC<br>基于QUIC，帧格式也发生了变化：<br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230206225705.png"><br><em>特性</em></p><ul><li>头部压缩：QPACK，静态字典扩大了。且使用两个独立的单向流实现字典的请求和响应。</li><li>二进制：分为数据帧和控制帧</li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），远程过程调用</p><p><em>RPC与HTTP区别</em></p><ul><li>RPC可以找中间服务获取IP，然后对目标IP地址访问。</li><li>都支持长连接和连接池</li><li>RPC定制化程度更高，性能一般更好</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><em>建立</em></p><ol><li>客户端先通过HTTP请求申请升级协议（Connection: Upgrade），同时携带随机base64码。</li><li>服务端升级，将base64码使用公开算法变成另一个字符串并返回。</li><li>客户端也将base64码使用公开算法变成字符串，与服务端传回的对比，若相同则建立连接。</li></ol><p><em>消息格式</em><br><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207113622.png"></p><p><em>场景</em><br>全双工、频繁交互、实时响应。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>C&#x2F;S模式，监听21端口</p><h1 id="六、Linux网络"><a href="#六、Linux网络" class="headerlink" title="六、Linux网络"></a>六、Linux网络</h1><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/OSI%E4%B8%8ETCP.webp"></p><h2 id="各层交互"><a href="#各层交互" class="headerlink" title="各层交互"></a>各层交互</h2><p>网络接口层的传输单位是MAC帧（frame）<br>IP 层的传输单位是包（packet）<br>TCP 层的传输单位是段（segment）<br>HTTP 的传输单位则是消息.或报文（message）<br>但这些名词并没有什么本质的区分，可以统称为数据包。</p><h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/107.webp"></p><ol><li>解析URL</li><li>生成HTTP请求头</li><li>DNS获取IP地址</li><li>交付给操作系统协议栈</li><li>选择网卡，根据<strong>路由表规则</strong>，判断以哪个网卡作为源地址，都不匹配则选择默认网关。</li></ol><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E5%8D%8F%E8%AE%AE%E6%A0%88.webp"></p><h2 id="Linux接受包"><a href="#Linux接受包" class="headerlink" title="Linux接受包"></a>Linux接受包</h2><ol><li>DMA技术将网络包写到Ring Buffer中</li><li>触发<strong>硬件中断</strong>：<ul><li>触发中断：收到一个包就中断操作系统一次</li><li>NAPI机制：先屏蔽中断，并发起<strong>软中断</strong>，通知操作系统内核线程ksoftirqd来轮询获取数据，然后恢复被屏蔽的中断。</li></ul></li></ol><h2 id="Linux发送包"><a href="#Linux发送包" class="headerlink" title="Linux发送包"></a>Linux发送包</h2><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/sk_buff.webp"></p><ol><li>应用程序调用socket发送数据，切换至内核态，将数据拷贝到<strong>Socket发送缓冲区</strong>（第一次sk_buff拷贝）。</li><li>如果是TCP协议处理，则对sk_buff进行切片、拷贝（第二次sk_buff拷贝），填充TCP头交给网络层。</li><li>网络层进行路由选择，填充IP头，切片（可能的第三次sk_buff）后交付网络接口层。</li><li>网络接口层通过ARP协议获取下一跳MAC地址，对sk_buff填充MAC帧头和帧尾，将其放入发送队列。</li><li>触发<strong>软中断</strong>通知网卡驱动程序发送，将sk_buff挂载在Ring Buffer中，并映射到网卡可访问的DMA区域，触发真实发送。</li><li>触发<strong>硬中断</strong>释放sk_buff内存和RingBuffer内存。</li></ol><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="ping回环"><a href="#ping回环" class="headerlink" title="ping回环"></a>ping回环</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230208114527.png"></p><h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><p><em>服务端大量CLOSE_WAIT</em><br>顾名思义，没有及时调用close函数，一般是代码问题。</p><h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207155558.png"></p><ul><li>accept职责是从全连接队列中取出一个已经建立好的连接。</li><li>TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。</li></ul><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/Pasted-image-20230207155715.png"></p><p><em>没有accept，能建立TCP连接吗？可以</em></p><ul><li>客户端可以自连接。</li><li>两个客户端同时发起SYN可以互连。</li></ul><p><em>不使用listen，可以建立连接吗？可以</em><br>情景与上一个问题相同。</p><p><em>服务端没有listen，可以建立连接吗？不可以</em><br>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。bind只是表示进程会占用该端口发送消息，只有listen后才会创建全连接队列，半连接队列。</p><p><em>多个TCP服务进程可以listen同一个端口吗？不可以</em></p><p><em>多个客户端可以bind同一个端口吗？</em><br>以下两种情况可以：</p><ol><li>绑定了不同的IP（不包括0.0.0.0）</li><li>绑定相同IP而开启了SO_REUSEADDR。</li></ol><blockquote><p>所谓bind，是一种手动选择端口的行为，后面调用connect时会跳过随机选择端口的过程而直接使用bind的端口。</p></blockquote><p><img src="/2023/03/16/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.webp"></p><p><em>同一个TCP服务进程如何复用TCP连接</em><br>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？因为有TIME_WAIT状态，服务器进程可以bind前开启<strong>SO_REUSEADDR</strong>，即仅针对自己这个进程的TW复用。</p><p><em>绑定不同IP相同Port可行吗</em><br>可以，但如果有进程绑定了0.0.0.0的某个port，其他进程无法绑定该任意IP的该端口。<br>开启<strong>SO_REUSEADDR</strong>后，只要求IP和端口不完全一样即可，所以这个特例也变成可行的。</p><p><em>客户端的端口可以重复使用吗？</em><br>遵从4元组分析即可。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IO</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java-IO基础"><a href="#一、Java-IO基础" class="headerlink" title="一、Java IO基础"></a>一、Java IO基础</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="按数据分类"><a href="#按数据分类" class="headerlink" title="按数据分类"></a>按数据分类</h3><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/Pasted-image-20230213142717.png"></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/Pasted-image-20230213142723.png"></p><h4 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h4><ul><li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同。)</li><li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li><li>字节流名往往是Stream，字符流名往往是Reader&#x2F;Writer。</li></ul><blockquote><p>Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。<br>char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p></blockquote><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//InputStream转Reader</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InputStreamReader</span><span class="hljs-params">(InputStream in,String charsetName)</span>;<br><span class="hljs-comment">//OutputStream转Writer</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">OutputStreamWriter</span><span class="hljs-params">(OutputStream out,String charsetName)</span>;<br></code></pre></td></tr></table></figure><h3 id="按操作对象分类"><a href="#按操作对象分类" class="headerlink" title="按操作对象分类"></a>按操作对象分类</h3><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/Pasted-image-20230213142850.png"></p><blockquote><p>根据操作对象分类的流，很多都需要套接在其他stream上，实现功能增强（装饰者模式）</p></blockquote><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>流的创建使用了装饰者模式：<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/Pasted-image-20230213143013.png"><br>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)。<br><em>eg：</em><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/Pasted-image-20230213143042.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath); <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>这些流都需要显示的关闭。</p>          </div><h2 id="Java-IO常见类"><a href="#Java-IO常见类" class="headerlink" title="Java IO常见类"></a>Java IO常见类</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String pathname)</span>;<br><span class="hljs-comment">//以parent为父路径，child为子路径创建File文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String parent,String child)</span>;<br><span class="hljs-comment">//常量，根据操作系统动态提供文件的分隔符</span><br>File.sepatator<br><span class="hljs-comment">//获取路径</span><br>String <span class="hljs-title function_">getPath</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//获取名称</span><br>String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//获取长度</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span><br><span class="hljs-comment">//将该地址视为目录并创建，若上层目录不存在则不创建</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//将该地址视为目录并创建，若上层目录不存在则仍创建</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">mkdirs</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>该对象包含记录指针，可标记当前读写位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打开文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomAccessFile</span><span class="hljs-params">(File file,String mode)</span><br><span class="hljs-comment">//获取文件指针</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getFilePointer</span><span class="hljs-params">()</span><br><span class="hljs-comment">//设置文件指针</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">seek</span><span class="hljs-params">(<span class="hljs-type">long</span> pos)</span>;<br></code></pre></td></tr></table></figure><h3 id="Path-x2F-Paths-x2F-Files"><a href="#Path-x2F-Paths-x2F-Files" class="headerlink" title="Path&#x2F;Paths&#x2F;Files"></a>Path&#x2F;Paths&#x2F;Files</h3><p>这几个类是在nio类中新增的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Paths</span><br><span class="hljs-comment">//目标文件不存在也可以获取</span><br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(String url);<br><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(URL url);<br><br><span class="hljs-comment">//Path</span><br><span class="hljs-comment">//Path转File</span><br>File <span class="hljs-title function_">toFile</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//Files</span><br><span class="hljs-comment">//文件复制</span><br>Path <span class="hljs-title function_">copy</span><span class="hljs-params">(Path src,Path dest,CopyOption ... how)</span>;<br></code></pre></td></tr></table></figure><h2 id="Java网络常见类"><a href="#Java网络常见类" class="headerlink" title="Java网络常见类"></a>Java网络常见类</h2><ul><li>InetAddress: 用于表示网络上的硬件资源，即 IP 地址；</li><li>URL: 统一资源定位符；</li><li>ServerSocket&#x2F;Socket: 使用 TCP 协议实现网络通信；</li><li>Datagram: 使用 UDP 协议实现网络通信。</li></ul><blockquote><p>URI：统一资源<strong>标识</strong>符：在某一规则下标识出一个资源的字符串。<br>URL：统一资源<strong>定位</strong>符：指定了访问机制（即网络位置）的URI。<br>URN：统一资源命名：指定了资源名称的URI。<br>URL和URN都是URI的子集。</p></blockquote><h1 id="二、Java-NIO基础"><a href="#二、Java-NIO基础" class="headerlink" title="二、Java NIO基础"></a>二、Java NIO基础</h1><p><code>NIO</code>(non blocking io)是库是在 JDK 1.4 中引入的包，其提供了<strong>高速的、面向块</strong>的 I&#x2F;O。<br>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流(字节)的方式处理数据，而 NIO 以块（数据块）的方式处理数据。</p><h2 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><em>介绍</em><br>buffer用来缓冲读写数据，<strong>必须通过读写buffer来实现对channel的读写</strong>。缓冲区实质上是一个<strong>数组</strong>。</p><p><em>实现</em></p><ul><li>ByteBuffer：是一个抽象类，实现有：<ul><li>HeapByteBuffer：<code>ByteBuffer.allocate()</code></li><li>DirectByteBuffer：<code>ByteBuffer.allocateDirect()</code></li><li>MappedByteBuffer：<code>fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 1024)</code></li></ul></li><li>IntBuffer等其他所有基本类型的Buffer，实现有：<ul><li>IntBuffer：<code>IntBuffer.wrap(arr)</code></li><li>IntBuffer：<code>byteBuffer.asIntBuffer()</code>，若原ByteBuffer为Direct，则该Buffer也为Direct。</li></ul></li></ul><blockquote><p>其中MappedByteBuffer将filaChannel对应文件的0至1024个字节映射到了buffer中。</p></blockquote><p><em>结构</em></p><ul><li>capacity: 最大容量；</li><li>position: 当前指针；</li><li>limit: 可读&#x2F;写的最大指针。</li></ul><p><em>方法</em></p><ul><li><code>clear()</code>把buffer清空，进入写模式，此时能读、写。</li><li><code>compact()</code>会把未读完的部分压缩到前面，进入写模式，此时能读、写。</li><li><code>flip()</code>进入读模式，此时不能读写。</li></ul><blockquote><p>写模式下可能会出现脏读的情况。所以一旦决定要从Buffer中读取数据，一定要将Buffer的状态改为读模式。</p></blockquote><p><em>操作</em><br>buffer是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成buffer</span><br><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//写数据，从channel数据流读出，写入buf</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br>buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br><br><span class="hljs-comment">//读数据，从buf中读出数据，写入channel</span><br><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br><br><span class="hljs-comment">//position标记与复位</span><br>buf.mark()<br>buf.reset()<br><br><span class="hljs-comment">//字符串转buffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><br><span class="hljs-comment">//buffer转字符串</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> buffer3.toString();<br></code></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><em>介绍</em><br>channel 类似于 stream，它就是读写数据的<strong>双向通道</strong>。channel 比 stream 更为底层，且是双向的。</p><p><em>实现</em></p><ul><li>FileChannel: 从文件中读写数据；</li><li>DatagramChannel: 通过 UDP 读写网络中数据；</li><li>SocketChannel: 通过 TCP 读写网络中数据；</li><li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><p><em>操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//channel常常不能直接获取，需要通过stream获取</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> FileInputStream.getChannel() <span class="hljs-comment">//只能读</span><br><br><span class="hljs-comment">//读取channel</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> channel.read(buffer);<br><span class="hljs-comment">//写入channel，应该循环保证全部写入</span><br><span class="hljs-keyword">while</span>(buffer.hasRemaining())&#123;<br>channel.write(buffer);<br>&#125;<br><br><span class="hljs-comment">//关闭，必须关闭，也可调用stream的close来间接关闭</span><br>channel.close();<br></code></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><em>介绍</em><br>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件。适合连接数特别多，但流量低的场景。实现了Reactor模型。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/1676302539083.png"></p><blockquote><p>FileChannel没有非阻塞模式，也不继承SelectableChannel，因此无法配合selector使用。</p></blockquote><p><em>操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建选择器</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//创建Channel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open(); ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//注册Channel到selector上</span><br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br><span class="hljs-comment">//一般会循环</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();<br>    <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>        keyIterator.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类:</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝，主要包括通过mmap和sendfile实现的I&#x2F;O。</p><p>在 Java NIO 中：</p><ul><li><strong>通道</strong>（Channel） 相当于操作系统的<strong>内核空间</strong>（kernel space）的缓冲区</li><li><strong>缓冲区</strong>（Buffer）相当于操作系统的<strong>用户空间</strong>（user space）中的缓冲区。</li></ul><h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><p>FileChannel调用map函数创建MappedByteBuffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> MappedByteBuffer <span class="hljs-title function_">map</span><span class="hljs-params">(MapMode mode, <span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p><em>底层原理</em></p><ul><li>调用链：<code>map()</code> -&gt; 本地方法<code>map0()</code> -&gt; Linux方法<code>mmap64()</code></li><li>会创建一个DirectByteBuffer（是MapeedByteBuffer的子类）对象引用在Java内存模型中，字节缓冲区在直接内存中。</li></ul><p><em>特点</em></p><ul><li>使用堆外内存。</li><li>处理大文件时，内存占用大</li><li>手动释放内存需要反射，麻烦</li></ul><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>ByteBuffer调用allocateDirect函数创建DirectByteBuffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title function_">allocateDirect</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectByteBuffer</span>(capacity); &#125;<br></code></pre></td></tr></table></figure><p><em>底层原理</em><br>对象引用在Java内存模型中，字节缓冲区在直接内存中，底层调用<code>malloc()</code>函数</p><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>并发环境下是线程安全的。<br><em>相关方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//把文件数据写入target Channel</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> count, WritableByteChannel target)</span> <span class="hljs-keyword">throws</span> IOException;<br><br><span class="hljs-comment">//把src Channel数据写入文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferFrom</span><span class="hljs-params">(ReadableByteChannel src, <span class="hljs-type">long</span> position, <span class="hljs-type">long</span> count)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p><em>底层原理</em><br>Linux <code>sendFile()</code></p><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>netty在用户态中对零拷贝进行了优化：</p><ul><li>DefaultFileRegion类，包装了<code>transferTo()</code>，直接将；</li><li>ByteBuf类，包装了ByteBuffer，避免了用户态中Buf之间的拷贝。</li></ul><h1 id="三、JAVA-I-x2F-O模式"><a href="#三、JAVA-I-x2F-O模式" class="headerlink" title="三、JAVA I&#x2F;O模式"></a>三、JAVA I&#x2F;O模式</h1><p>具体细节见操作系统章节，这里主要关注java代码实现。</p><h2 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h2><p><em>原始阻塞模式</em><br>单线程负责建立连接，并处理连接上数据的读写。<br>缺点：只能处理一条Socket连接上的请求。</p><p><em>多线程阻塞模式</em><br>单线程负责建立连接，为建立好的连接分配线程进行处理。<br>缺点：只解决了处理请求的并发问题，但没有解决接受请求的并发问题。且会消耗大量线程资源。</p><p><em>实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept(); <span class="hljs-comment">//阻塞</span><br><span class="hljs-comment">//以下可单/多线程完成</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>in.read() <span class="hljs-comment">//阻塞</span><br></code></pre></td></tr></table></figure><p><em>结论</em><br>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于<code>accept()</code>、<code>read()</code>的操作点都是被阻塞。</p><h2 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h2><p>NIO提供的SocketChannel可以代替Socket，可以将其设置为非阻塞。配合Buffer实现非阻塞模式。</p><p><em>多线程非阻塞模式</em><br><code>accept()</code>、<code>read()</code>的操作点都不会阻塞。</p><p><em>实现</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0. ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 1. 创建了服务器</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>ssc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br><span class="hljs-comment">// 2. 绑定监听端口</span><br>ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><span class="hljs-comment">// 3. 连接集合</span><br>List&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> ssc.accept(); <span class="hljs-comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span><br>    <span class="hljs-keyword">if</span> (sc != <span class="hljs-literal">null</span>) &#123;<br>        log.debug(<span class="hljs-string">&quot;connected... &#123;&#125;&quot;</span>, sc);<br>        sc.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 非阻塞模式</span><br>        channels.add(sc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (SocketChannel channel : channels) &#123;<br>        <span class="hljs-comment">// 5. 接收客户端发送的数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<span class="hljs-comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span><br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>            buffer.flip();<br>            debugRead(buffer);<br>            buffer.clear();<br>            log.debug(<span class="hljs-string">&quot;after read...&#123;&#125;&quot;</span>, channel);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>NIO提供的Selector，可以完成对多个Chaannel读写事件的控制。<br>目前流程的多路复用IO模型主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>：</p><table><thead><tr><th>IO模型</th><th>相对性能</th><th>关键思路</th><th>操作系统</th><th>JAVA支持情况</th></tr></thead><tbody><tr><td>select</td><td>较高</td><td>Reactor</td><td>windows&#x2F;Linux</td><td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td></tr><tr><td>poll</td><td>较高</td><td>Reactor</td><td>Linux</td><td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td></tr><tr><td>epoll</td><td>高</td><td>Reactor&#x2F;Proactor</td><td>Linux</td><td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td></tr><tr><td>kqueue</td><td>高</td><td>Proactor</td><td>Linux</td><td>目前JAVA的版本不支持</td></tr></tbody></table><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reactor</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    serverSocket = ServerSocketChannel.open();  <span class="hljs-comment">// 创建服务端的ServerSocketChannel</span><br>    serverSocket.configureBlocking(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 设置为非阻塞模式</span><br>    selector = Selector.open();  <span class="hljs-comment">// 创建一个Selector多路复用器</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> serverSocket.register(selector, SelectionKey.OP_ACCEPT);<br>    serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));  <span class="hljs-comment">// 绑定服务端端口</span><br>    key.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Acceptor</span>(serverSocket));  <span class="hljs-comment">// 为服务端Channel绑定一个Acceptor</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        selector.select();  <span class="hljs-comment">// 服务端使用一个线程不断等待客户端的连接到达</span><br>        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-comment">//获取到连接，则将它交付给Acceptor</span><br>          dispatch(iterator.next());  <span class="hljs-comment">// 监听到客户端连接事件后将其分发给Acceptor</span><br>          iterator.remove();<br>        &#125;<br><br>        selector.selectNow();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 这里的attachement也即前面为服务端Channel绑定的Acceptor，调用其run()方法进行</span><br>    <span class="hljs-comment">// 客户端连接的获取，并且进行分发</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> (Runnable) key.attachment();<br>    attachment.run();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Acceptor负责获取连接并分发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">20</span>);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverSocket)</span> &#123;<br>    <span class="hljs-built_in">this</span>.serverSocket = serverSocket;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> serverSocket.accept();  <span class="hljs-comment">// 获取客户端连接</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != channel) &#123;<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(channel));  <span class="hljs-comment">// 将客户端连接交由线程池处理</span><br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Handler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Selector selector;<br>  <span class="hljs-comment">//有一个私有客户端连接</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel channel;<br>  <span class="hljs-keyword">private</span> SelectionKey key;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-comment">//线程池创建Handler</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(SocketChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-built_in">this</span>.channel = channel;<br>    channel.configureBlocking(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 设置客户端连接为非阻塞模式</span><br>    selector = Selector.open();  <span class="hljs-comment">// 为客户端创建一个新的多路复用器</span><br>    key = channel.register(selector, SelectionKey.OP_READ);  <span class="hljs-comment">// 注册客户端Channel的读事件</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (selector.isOpen() &amp;&amp; channel.isOpen()) &#123;<br>        Set&lt;SelectionKey&gt; keys = select();  <span class="hljs-comment">// 等待客户端事件发生</span><br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>          <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>          iterator.remove();<br>          <span class="hljs-comment">// 如果当前是读事件，则读取数据</span><br>          <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            read(key);<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isWritable()) &#123;<br>           <span class="hljs-comment">// 如果当前是写事件，则写入数据</span><br>            write(key);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这里处理的主要目的是处理Jdk的一个bug，该bug会导致Selector被意外触发，但是实际上没有任何事件到达，此时的处理方式是新建一个Selector，然后重新将当前Channel注册到该Selector上</span><br>  <span class="hljs-keyword">private</span> Set&lt;SelectionKey&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    selector.select();<br>    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>    <span class="hljs-keyword">if</span> (keys.isEmpty()) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> key.interestOps();<br>      selector = Selector.open();<br>      key = channel.register(selector, interestOps);<br>      <span class="hljs-keyword">return</span> select();<br>    &#125;<br>    <span class="hljs-keyword">return</span> keys;<br>  &#125;<br><br>  <span class="hljs-comment">// 读取客户端发送的数据</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    channel.read(input);<br>    <span class="hljs-keyword">if</span> (input.position() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    input.flip();<br>    process();  <span class="hljs-comment">// 对读取的数据进行业务处理</span><br>    input.clear();<br>    key.interestOps(SelectionKey.OP_WRITE);  <span class="hljs-comment">// 读取完成后监听写入事件</span><br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    output.flip();<br>    <span class="hljs-keyword">if</span> (channel.isOpen()) &#123;<br>      channel.write(output);  <span class="hljs-comment">// 当有写入事件时，将业务处理的结果写入到客户端Channel中</span><br>      key.channel();<br>      channel.close();<br>      output.clear();<br>    &#125;<br>  &#125;<br>    <br>  <span class="hljs-comment">// 进行业务处理，并且获取处理结果。本质上，基于Reactor模型，如果这里成为处理瓶颈，则直接将其处理过程放入线程池即可，并且使用一个Future获取处理结果，最后写入客户端Channel</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[input.remaining()];<br>    input.get(bytes);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, CharsetUtil.UTF_8);<br>    System.out.println(<span class="hljs-string">&quot;receive message from client: \n&quot;</span> + message);<br><br>    output.put(<span class="hljs-string">&quot;hello client&quot;</span>.getBytes());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、AIO"><a href="#四、AIO" class="headerlink" title="四、AIO"></a>四、AIO</h1><p>异步IO则是采用“订阅-通知”模式: 即应用程序向操作系统注册IO监听，然后继续做自己的事情。</p><h2 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h2><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/JAVA-IO/Java-IO/Pasted-image-20230213174047.png"><br><em>实现</em></p><ul><li>JAVA AIO框架在windows下使用windows IOCP技术</li><li>Linux下使用epoll多路复用IO技术模拟异步IO</li></ul><p><em>要点</em></p><ul><li>不再需要selector监听就绪事件，由channel通道注册监听已完成事件。</li><li>通过<code>AsynchronousServerSocketChannel</code>和<code>AsynchronousSocketChannel</code>实现异步功能。</li></ul><h1 id="五、Netty"><a href="#五、Netty" class="headerlink" title="五、Netty"></a>五、Netty</h1><p>todo<br><em>特点</em></p><ul><li>处理了信息格式封装，如JSON。</li><li>可靠、易维护、高性能等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java-IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java-IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发问题</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java"><a href="#一、Java" class="headerlink" title="一、Java"></a>一、Java</h1><p><em>jar包和war包的区别</em></p><ul><li>jar包：java类集合的压缩包，便于代码统一管理。</li><li>war包：包含整个web引用程序，是一个可直接运行的web模块，可直接部署在tomcat中发布。</li><li>ear包：企业引用程序，一般是多个jar包、war包的集合。</li></ul><blockquote><p>springboot项目中对比：</p><ul><li>可直接打jar包利用内置tomcat运行，所有tomcat的配置应该在springboot配置文件中修改；</li><li>可打包为war包，作为传统的应用交付方式，可灵活选择tomcat版本和修改配置。</li></ul></blockquote><p><em>同源政策</em><br><a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">同源政策</a></p><ul><li>定义：浏览器政策，在一个页面中，浏览器只能访问同源（协议相同、域名相同、端口相同）的资源；</li><li>目的：保护cookie，避免cookie共享；</li><li>限制范围：主要限制cookie、LocalStorage、IndexDB、dom、ajax请求的发送；</li><li>规避方法：不同限制类型都有具体的规避方法，这里主要介绍ajax请求规避同源政策的一种方法：跨域CORS</li></ul><blockquote><p>Nginx代理请求可解决同源政策问题。</p></blockquote><p><em>跨域</em><br><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域详解</a></p><ul><li>CORS需要浏览器和服务器同时支持，具体地</li><li>对于简单请求：浏览器发送请求时会增加Origin字段，表示本次请求来源，服务器根据该值判断是否允许访问：<ul><li>如果不在许可范围，则返回正常HTTP响应，浏览器会对其进行拦截并抛出错误。</li><li>如果在许可范围内，响应头上会新增一些字段，如许可范围、是否接受cookie、允许查看的响应头字段。</li></ul></li><li>对于复杂请求（<code>PUT</code>或<code>DELETE</code>请求或<code>Content-Type</code>字段的类型是<code>application/json</code>的请求）：浏览器需要先询问服务器（预检），得到许可后才会发起正式的请求。</li></ul><h1 id="二、项目部署"><a href="#二、项目部署" class="headerlink" title="二、项目部署"></a>二、项目部署</h1><p><em>前端Vue项目部署</em></p><ul><li><code>vue.config.js</code>里的<code>publicPath</code>指的是打包后，所有资源相对根路径（nginx配置到的路径）所在的位置，如果应用被部署在一个子路径上，就需要用这个选项指定这个子路径。(同时需要注意静态资源的访问情况)</li></ul><p><em>开发环境代理</em><br>开发环境的devServer可实现页面请求的代理</p><p><em>若依部署</em><br><a href="https://blog.csdn.net/u014440968/article/details/115753615">ruoyi部署</a><br><a href="http://doc.ruoyi.vip/ruoyi-vue/document/hjbs.html#tomcat%E9%85%8D%E7%BD%AE">官方文档</a></p><h1 id="三、Ruoyi项目"><a href="#三、Ruoyi项目" class="headerlink" title="三、Ruoyi项目"></a>三、Ruoyi项目</h1><h2 id="ruoyi-server项目结构"><a href="#ruoyi-server项目结构" class="headerlink" title="ruoyi-server项目结构"></a>ruoyi-server项目结构</h2><ul><li>ruoyi-admin：主程序入口，依赖了framework、quartz、generator模块<ul><li><code>common</code>:包含&#x3D;&#x3D;验证码&#x3D;&#x3D;接口和&#x3D;&#x3D;文件上传&#x2F;下载&#x3D;&#x3D;接口（Service文件在framework中）</li><li><code>monitor</code>:包含&#x3D;&#x3D;缓存监控&#x3D;&#x3D;接口、&#x3D;&#x3D;服务器监控&#x3D;&#x3D;接口、&#x3D;&#x3D;系统访问记录&#x3D;&#x3D;接口、&#x3D;&#x3D;操作日志记录&#x3D;&#x3D;接口、&#x3D;&#x3D;在线用户监控&#x3D;&#x3D;接口。</li><li><code>system</code>:包含&#x3D;&#x3D;参数管理、部门管理、字典管理、登录认证、菜单管理、通告管理、岗位管理、个人信息管理、注册管理、角色管理、用户管理&#x3D;&#x3D;。（Service文件在System中）</li><li><code>tools</code>:有&#x3D;&#x3D;Swagger接口&#x3D;&#x3D;访问。</li><li><code>resources</code>:包含&#x3D;&#x3D;i18n、mybatis&#x3D;&#x3D;等配置。</li></ul></li><li>ruoyi-common：主要是一些通用功能。<ul><li><code>annotation</code>:主要注释</li><li><code>config</code>:配置文件，读取yml信息</li><li><code>constant</code>:常用常量</li><li><code>core</code>:常用基类:&#x3D;&#x3D;BaseController&#x3D;&#x3D;、&#x3D;&#x3D;系统类entity&#x3D;&#x3D;、&#x3D;&#x3D;登录对象model&#x3D;&#x3D;、&#x3D;&#x3D;AjaxResult&#x3D;&#x3D;、&#x3D;&#x3D;TreeEntity&#x3D;&#x3D;</li><li><code>enum</code>:常用枚举</li><li><code>exception</code>:包含各种&#x3D;&#x3D;异常entity&#x3D;&#x3D;</li><li><code>filter</code>:请求过滤器，包括&#x3D;&#x3D;包装可重复读取inputStream的request&#x3D;&#x3D;(因为多次读取会报错，我们缓存起来)和&#x3D;&#x3D;防止xss攻击&#x3D;&#x3D;</li><li><code>utils</code>:常用工具类,包括&#x3D;&#x3D;对象处理、文件处理、HTML处理、HTTP处理、IP地址获取处理、Excel处理、反射工具类、加密处理、Spring工具类、SQL处理、ID生成器、浮点数、时间、日期、异常、日志、安全、分页、字符串、线程等处理类。&#x3D;&#x3D;</li><li><code>xss</code>:防止xss注入的的&#x3D;&#x3D;validator&#x3D;&#x3D;和注解</li></ul></li><li>ruoyi-framework：主要为系统层的框架配置，如鉴权、限流、拦截、异常、校验等功能。<ul><li><code>aspectj</code>:切面，包括&#x3D;&#x3D;数据权限鉴别，多数据源切换，日志，限流&#x3D;&#x3D;切面</li><li><code>config</code>:配置文件</li><li><code>datasource</code>:&#x3D;&#x3D;多数据源&#x3D;&#x3D;</li><li><code>interceptor</code>:&#x3D;&#x3D;防止重复提交&#x3D;&#x3D;的拦截器</li><li><code>security</code>: 实现&#x3D;&#x3D;jwt功能&#x3D;&#x3D;</li><li><code>manager</code>: 异步任务管理器</li><li><code>web</code>: 服务器相关信息，&#x3D;&#x3D;全局异常处理器&#x3D;&#x3D;，&#x3D;&#x3D;权限实现服务，登录服务，注册校验方法，token验证处理，用户验证处理服务&#x3D;&#x3D;</li></ul></li><li>ruoyi-generator：代码生成器</li><li>ruoyi-quartz：定时任务</li><li>ruoyi-system：主要为system类的vo，mapper，service等，有用户角色等一些服务业务。</li><li>pom：管理子模块、管理公共依赖，子模块要依赖该公共依赖时，不用再指定版本。</li></ul><p><em>新功能编写步骤</em></p><ol><li>sql结构编写</li><li>配置好数据字典</li><li>前后台代码生成</li><li>部分服务代码修改，如导入导出代码、更新和插入判断重复代码</li></ol><h2 id="业务功能"><a href="#业务功能" class="headerlink" title="业务功能"></a>业务功能</h2><p><em>分页</em></p><ul><li>使用：<code>startPage()</code>会使下一个sql语句分页。</li><li>原理：<ul><li>从Request中获取分页参数（起始索引，每页记录，排序，排序方向）注入<code>PageDomain</code>实体，调用<code>PageHelper.startPage()</code>；</li><li><code>PageHelper.startPage()</code>将分页信息通过<code>setLocalPage</code>存入当前线程中；</li><li>SpringBoot启动时，为<code>SqlSessionFactory</code>添加了<code>PageHelperInterceptor</code>，其在SQL执行前为其添加分页信息；</li></ul></li><li>注意：<ul><li>该分页请求参数的获取基于GET请求的路径，所以其他如POST请求若有分页需求，需要将请求参数添加在请求路径上，eg：<code>?pageSize=20&amp;pageNum=1</code></li><li><code>startPage()</code>是一个重载函数，其可接受参数：<ul><li>pageNum(int)：起始页</li><li>pageSize(int)：每页数量</li><li>reasonable(bool)：是否允许非法的pageNum和pageSize</li><li><strong>count</strong>(bool)：是否预先执行一次count以得到本查询的结果总数。</li><li>pageSizeZero(bool)：该值为true时，如果 pageSize&#x3D;0就会查询出全部的结果，不进行分页。</li></ul></li></ul></li></ul><p><em>功能权限</em><br>基于角色和细分权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;@ss.hasRole(&#x27;user&#x27;)&quot;)</span><br><span class="hljs-meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;system:user:list&#x27;)&quot;)</span><br></code></pre></td></tr></table></figure><p><em>数据权限</em></p><ul><li>使用：在controller上注解<code>@DataScope</code>，并在mapper.xml中加上<code>&#123;params.dataScope&#125;</code></li><li>原理：<ul><li>通过用户id获取部门dept_id，根据用户的数据权限等级（超级管理员、本部门、部门及以下、本人）判断执行方式。</li><li>根据<code>@DataScope</code>获取当前查询的表别名，进行sql字符串拼接，添加到BaseEntity的params属性中。</li></ul></li></ul><p><em>日志</em><br>在接口上标注log，会在数据库中记录系统日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log(title = &quot;用户管理&quot;, businessType = BusinessType.INSERT)</span><br><span class="hljs-keyword">public</span> AjaxResult <span class="hljs-title function_">addSave</span><span class="hljs-params">(...)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> success(...);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>事务</em></p><ul><li><code>@Transactional</code>只回滚运行异常<code>（RuntimeException）</code>和程序错误<code>（Error）</code>，若需要回滚其他，需要标识<code>@Transactional(rollbackFor = Exception.class)</code></li><li>推荐服务层抛出异常，只在控制层处理异常</li></ul><h1 id="四、MyBatis"><a href="#四、MyBatis" class="headerlink" title="四、MyBatis"></a>四、MyBatis</h1><p><em>使用map传值</em></p><ul><li>Map接受值可能会忽略为null的值，需要在mybatis-config中配置：<code> &lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;true&quot;/&gt;</code></li></ul><h1 id="六、数据类型对照"><a href="#六、数据类型对照" class="headerlink" title="六、数据类型对照"></a>六、数据类型对照</h1><h2 id="SQL-to-Java"><a href="#SQL-to-Java" class="headerlink" title="SQL to Java"></a>SQL to Java</h2><p><em>字符</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th></tr></thead><tbody><tr><td align="left">varchar</td><td align="left">java.lang.String</td></tr><tr><td align="left">char</td><td align="left">java.lang.String</td></tr><tr><td align="left">nchar</td><td align="left">java.lang.String</td></tr><tr><td align="left">nvarchar</td><td align="left">java.lang.String</td></tr><tr><td align="left">text</td><td align="left">java.lang.String</td></tr><tr><td align="left">ntext</td><td align="left">java.lang.String</td></tr></tbody></table><p><em>整数</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th><th align="left">描述</th><th>项目中使用</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">java.lang.Boolean</td><td align="left">tiny(1)的另一种写法</td><td>Boolean</td></tr><tr><td align="left">bit(1)&#x2F;bit(n)</td><td align="left">java.lang.Boolean&#x2F;byte[]</td><td align="left">根据n&#x3D;1和其他分别对应</td><td>Boolean&#x2F;byte[]</td></tr><tr><td align="left">tinyint</td><td align="left">java.lang.Integer</td><td align="left">n&#x3D;1时为boolean</td><td>Integer</td></tr><tr><td align="left">smallint</td><td align="left">java.lang.Integer</td><td align="left">有无符号都是Integer</td><td>Integer</td></tr><tr><td align="left">int</td><td align="left">java.lang.Integer&#x2F;Long</td><td align="left">无符号时为Long</td><td>Long</td></tr><tr><td align="left">bigint</td><td align="left">java.lang.Long</td><td align="left">无符号时是BigInteger</td><td>BigInteger</td></tr></tbody></table><p><em>浮点类</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">java.lang.Float</td></tr><tr><td align="left">double</td><td align="left">java.lang.Double</td></tr><tr><td align="left">decimal</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">money</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">smallmoney</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">numeric</td><td align="left">java.math.BigDecimal</td></tr><tr><td align="left">real</td><td align="left">java.lang.Float</td></tr><tr><td align="left">说明：</td><td align="left"></td></tr></tbody></table><ul><li>Mysql中小数实际上只有<strong>float</strong> 和 <strong>decimal</strong>两种类型，分别是近似数值和精确数值。<code>double = float(53)</code>，<code>real = float(24) </code>，<code>numeric = decimal</code>。</li><li>float存在精度损失，实际上只有float(53)和float(24)两种类型，分别占用8byte和4byte。</li><li>decimal不存在精度损失，decimal(p,s)中p指定最大位数，s指定小数点右侧的最大位数。</li></ul><p><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422234611.png"></p><p><em>其他类</em></p><table><thead><tr><th align="left">数据库类型</th><th align="left">JDBC类型</th><th>项目中使用</th></tr></thead><tbody><tr><td align="left">date</td><td align="left">java.sql.Date</td><td>java.util.Date</td></tr><tr><td align="left">datetime</td><td align="left">java.sql.Timestamp</td><td>java.util.Date</td></tr><tr><td align="left">timestamp</td><td align="left">java.sql.Timestamp</td><td>java.util.Date</td></tr><tr><td align="left">binary</td><td align="left">byte[]</td><td></td></tr><tr><td align="left">image</td><td align="left">byte[]</td><td></td></tr><tr><td align="left">blob</td><td align="left">byte[]</td><td></td></tr><tr><td align="left">说明：</td><td align="left"></td><td></td></tr></tbody></table><ul><li><code>date</code>：YY-MM-DD</li><li><code>time</code>：HH:MM:SS</li><li><code>datetime</code>：YY-MM-DD HH:MM:SS</li><li><code>timestamp</code>：同datetime，可表示的时间范围不同，且受时区影响</li><li>实际上，mysql中datetime、timestamp可以表示到毫秒，只需要设置<code>datetime(3)/datetime(6)</code>或<code>timestamp(3)/timestamp(6)</code>即可。</li><li>java.sql.Date是java.util.Date的子类，前者无法表示毫秒而后者可以。</li></ul><h2 id="PLC-to-Java"><a href="#PLC-to-Java" class="headerlink" title="PLC to Java"></a>PLC to Java</h2><table><thead><tr><th>类型</th><th>精度(位)</th><th>说明（以java为基准）</th></tr></thead><tbody><tr><td><strong>bit</strong></td><td>1</td><td>相当于Boolean</td></tr><tr><td>Byte</td><td>8</td><td>byte</td></tr><tr><td>Int</td><td>?</td><td>与机器相关</td></tr><tr><td>Short</td><td>16</td><td>相当于short</td></tr><tr><td>Long</td><td>32</td><td>相当于int</td></tr><tr><td>Real</td><td>32</td><td>相当于float</td></tr><tr><td>Double</td><td>64</td><td>相当于double</td></tr></tbody></table><h2 id="OPCUA-to-Java"><a href="#OPCUA-to-Java" class="headerlink" title="OPCUA to Java"></a>OPCUA to Java</h2><table><thead><tr><th>类型</th><th>精度(位)</th><th>说明（以java为基准）</th></tr></thead><tbody><tr><td>Int8~Int64</td><td>8~64</td><td>相当于byte~long</td></tr><tr><td>Float</td><td>32</td><td>相当于float</td></tr><tr><td>Double</td><td>64</td><td>相当于Double</td></tr><tr><td>Boolean</td><td>1</td><td>相当于Boolean</td></tr></tbody></table><h1 id="X、流媒体"><a href="#X、流媒体" class="headerlink" title="X、流媒体"></a>X、流媒体</h1><h2 id="ZLMediaKit"><a href="#ZLMediaKit" class="headerlink" title="ZLMediaKit"></a>ZLMediaKit</h2><p><em>工作原理</em><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422235927.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422235934.png"><br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98/Pasted-image-20230422235940.png"></p><p><em>虚拟主机</em><br>虚拟主机的设置在没有域名的情况下作用不大，但是在关闭流和拉取流的时候，要使用正确的虚拟主机域才能正常使用，播放格式为：<code>http://132.186.192.100:8088/camera/1.flv?vhost=newwish</code></p><p><em>rtsp鉴权</em><br>在局域网内拉流会出现授权问题，需要在配置文件中修改参数为不鉴权。</p><h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><p><em>摄像头配置问题</em><br>对于摄像头，需要注意是否开启音频，flv.js播放时可能会有点问题，解决方案：<br>1.设置海康威视摄像头的音频输出为第一个或ACC（默认的设置不行）；<br>2.可能在设置文件中把enable_audio关闭即可；</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>开发问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>开发问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring基础</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/Spring%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring/Spring%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring基础概念"><a href="#一、Spring基础概念" class="headerlink" title="一、Spring基础概念"></a>一、Spring基础概念</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><em>概念</em><br>控制反转指的是在程序中，原本需要我们手动创建的对象现在可以由 Spring 的 IoC 容器帮助创建和注入依赖对象，我们只需要告诉容器什么时候创建对象、创建什么对象，完全不用考虑对象是怎么创建出来的。</p><p><em>传统程序设计与 IoC 模式的区别</em><br>传统：用户主动创建对象并关联<br>IoC：只需通知IoC容器执行</p><p><em>介绍一下 Spring IoC 容器的初始化过程</em></p><ol><li><strong>Bean 的资源定位</strong>。</li><li><strong>BeanDefinition 的载入</strong>。将用户定义好的 Bean 表示成 IoC 容器内部的数据结构，而这个容器内部的数据结构就是 BeanDefinition；</li><li><strong>向 IoC 容器注册这些 BeanDefinition</strong>。这个注册过程就是将在 IoC 容器内部将 BeanDefinition 注入到一个 HashMap 中去的过程。</li></ol><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p><em>介绍一下依赖注入（DI）</em><br>依赖注入是控制反转的一种实现方式，指的是程序所依赖的组件在运行时会动态地加载到程序中。</p><p><em>依赖注入的方式有哪些</em></p><ol><li>构造器注入；</li><li>Setter 方法注入；</li><li>属性（p）命名空间或者构造器（c）命名空间注入。</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><em>介绍一下 AOP</em><br>面向切面编程是面向对象编程的补充，它将面向对象编程产生的各个业务模块所共同调用的部分封装起来，达到与主业务逻辑解耦的目的。<br>同时，AOP 可以在不改变原来的代码的情况下，实现对原有功能的增强。（代理模式，开闭原则）。</p><p><em>介绍一下 Spring AOP 中创建代理的方式</em><br>Spring AOP 就是基于动态代理的，Spring 中的 AOP 目前支持 JDK 动态代理和 Cglib 代理。</p><p><em>说一下 JDK 动态代理和 Cglib 代理的区别</em></p><ol><li>JDK 动态代理本质上是实现了被代理对象的接口，而 Cglib 本质上是继承了被代理对象，覆盖其中的方法；</li><li>JDK 动态代理只能对实现了接口的类生成代理，Cglib 则没有这个限制。但是 Cglib 因为使用继承实现，所以 Cglib 无法代理被 final 修饰的方法或类；</li><li>在调用代理方法上，JDK 动态代理是通过反射机制调用，Cglib 是通过 FastClass 机制直接调用。FastClass 简单的理解，就是使用 index 作为入参，可以直接定位到要调用的方法直接进行调用；</li><li>在性能上，JDK1.7 之前，由于使用了 FastClass 机制，Cglib 在执行效率上比 JDK 快，但是随着 JDK 动态代理的不断优化，从 JDK 1.7 开始，JDK 动态代理已经明显比 Cglib 更快了。</li></ol><p><em>说一下 Spring AOP 和 AspectJ AOP 的区别</em></p><ol><li>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强；</li><li>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)；</li><li>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单；</li><li>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</li></ol><h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><p><em>什么是 Spring bean 容器</em></p><ol><li>bean 是对象，一个或者多个不限定；</li><li>bean 由 Spring 中一个叫 IoC 的东西管理；</li><li>我们的应用程序由一个个 bean 构成。</li></ol><p><em>将⼀个类声明为 Spring 的 bean 的注解有哪些</em></p><ul><li>@Component ：通⽤的注解，可标注任意类为 Spring 组件，如果⼀个Bean不知道属于哪个层，可以使⽤ @Component 注解标注；</li><li>@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作；</li><li>@Service : 对应服务层，主要涉及⼀些复杂的逻辑；</li><li>@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数据给前端⻚⾯。</li></ul><p><em>Spring bean 生命周期</em><br><img src="/Pasted%20image%2020230213135711.jpg"></p><p><em>bean 的作用域</em><br><img src="/Pasted%20image%2020230213135728.png"></p><p><em>Spring 中的单例 bean 的线程安全问题了解吗？</em><br>常见的有两种解决办法：</p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）；</li><li>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中。</li></ol><blockquote><p>只要求可见性的对象可以使用volatile+CAS，或者使用悲观锁完成。</p></blockquote><p><em>@Component 和 @Bean 的区别</em></p><ol><li>@Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法；</li><li>@Component 通常是通过类路径扫描来⾃动侦测并⾃动装配到 Spring 容器中；@Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean。</li><li>@Bean 注解⽐ Component 注解的⾃定义性更强，如第三方库。</li></ol><h2 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h2><p><em>Spring 管理事务的方式</em></p><ol><li>编程式事务，在代码中硬编码(不推荐使用)；</li><li>声明式事务，在配置文件中配置（推荐使用）；<ul><li>基于 XML 的声明式事务；</li><li>基于注解的声明式事务；</li></ul></li></ol><p><em>事务的实现原理</em><br>Spring 事务的底层实现主要使用的技术：AOP（动态代理） + ThreadLocal + try&#x2F;catch。 </p><ul><li>动态代理：基本所有要进行逻辑增强的地方都会用到动态代理，AOP 底层也是通过动态代理实现；</li><li>ThreadLocal：主要用于线程间的资源隔离，以此实现不同线程可以使用不同的数据源、隔离级别等等；</li><li>try&#x2F;catch：最终是执行 commit 还是 rollback，是根据业务逻辑处理是否抛出异常来决定。</li></ul><p><img src="/Pasted%20image%2020230213140151.jpg"></p><p><em>Spring 事务中的隔离级别</em></p><ul><li>TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别；</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><p><em>Spring 事务中有哪几种事务传播行为</em><br><strong>支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；</li><li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><p><em>Spring 的事务隔离级别是如何做到和数据库不一致的</em><br>Spring 的事务隔离级别本质上还是通过数据库来控制的，具体是在执行事务前先执行命令修改数据库隔离级别：<br><code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED</code></p><h1 id="二、Spring-MVC"><a href="#二、Spring-MVC" class="headerlink" title="二、Spring MVC"></a>二、Spring MVC</h1><p><em>什么是 MVC</em><br><img src="/Pasted%20image%2020230213141252.jpg"><br>在 Spring MVC 下，我们⼀般把后端项⽬分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层。</p><p><em>SpringMVC 的核心入口类是什么</em><br>DispatchServlet。</p><p><em>SpringMVC 的控制器是不是单例模式？</em><br>是单例模式，所以在多线程访问的时候有线程安全问题，不过不能使用同步，因为会影响性能的，解决方案是在控制器里面不能写字段（只有方法）。</p><p><em>SpingMVC 中的控制器的注解一般用哪个，有没有别的注解可以替代</em><br>@Conntroller</p><p><em>@RequestMapping 注解用在类上面有什么作用</em><br>其用于类上，表示类中的所有请求与响应的方法都是以该地址作为父路径。</p><p><em>怎么样把某个请求映射到特定的方法上面</em><br>在方法上面加上注解 @RequestMapping，并且在这个注解里面写上要拦截的路径。</p><p><em>如果前台有很多个参数传入，并且这些参数都是一个对象的,那么怎么样快速得到这个对象</em><br>直接声明这个对象。</p><h1 id="三、MyBatis"><a href="#三、MyBatis" class="headerlink" title="三、MyBatis"></a>三、MyBatis</h1><p><em>说一说什么是 MyBatis</em><br>Mybatis 是一个半 ORM（对象关系映射）的持久层框架，它内部封装了JDBC、加载驱动、创建连接、创建 statement 等繁杂的过程，开发者开发时只需要关注如何编写 SQL 语句，可以严格控制 SQL 执行性能，灵活度高。</p><p><em>那什么是持久化</em><br>将程序数据在持久状态和瞬时状态间转换的机制，即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）的机制。</p><p><em>为什么说 MyBatis 是半自动的 ORM 映射工具</em></p><ul><li>Hibernate 属于全⾃动 ORM 映射⼯具，使⽤ Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全⾃动的。</li><li><strong>Mybatis 在查询关联对象或关联集合对象时，需要⼿动编写 sql 来完成，所以，称之为半⾃动 ORM 映射⼯具</strong>。</li></ul><p><em>#{} 和 ${} 的区别是什么</em><br><strong>#{} 是预编译处理，${} 是字符串替换</strong>。</p><p><em>MyBatis 的生命周期</em></p><ol><li>SqlSessionFactoryBuilder 通过配置文件生成 SqlSessionFactory，一旦创建完后，就可以销毁它；</li><li>SqlSessionFactory 在 MyBatis 中以单例模式存在，创建于程序开始，销毁于程序结束，类似于线程池；</li><li>sqlSession 类似于线程池中的一个线程，线程结束后就归还于线程池；</li><li>Mapper 是 SqlSession 创建的一个具体的业务，一旦处理完了这个业务，就可以销毁它。</li></ol><table><thead><tr><th>类名</th><th>作用域</th></tr></thead><tbody><tr><td>SqlSessionFactoryBuilder</td><td>方法作用域</td></tr><tr><td>SqlSessionFactory</td><td>全局作用域</td></tr><tr><td>SqlSession</td><td>方法作用域</td></tr><tr><td>Mapper</td><td>方法作用域</td></tr></tbody></table><p><em>Mybatis 是如何进行分页的？分页插件的原理是什么？</em></p><ol><li>使用 limit 进行分页；</li><li>使用 RowBounds 分页，这个属于逻辑分页，即实际上 sql 查询的是所有的数据，在业务层进行了分页而已，比较占用内存，而且数据更新不及时，可能会有一定的滞后性；</li><li>使用分页插件（jar 包）进行分页；</li></ol><p><em>说一说 MyBatis 的缓存</em><br>MyBatis 中默认定义了两级缓存：一级缓存和二级缓存。</p><ul><li>一级缓存，又称为本地缓存，是 SqlSession 级别的缓存，默认情况下是开启的；</li><li>二级缓存是基于 namespace 级别的缓存，则需要手动开启和配置。</li></ul><p><strong>查询缓存的顺序</strong>：二级缓存 → 一级缓存 → 数据库。</p><p><em>说一说 MyBatis 的一级缓存</em><br>与数据库同一次会话期间查询到的数据会放在一级缓存中，以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库。</p><p>一级缓存失效的四种情况：</p><ul><li>当 SqlSession 相同，两次查询中出现了增删改。</li><li>SqlSession 相同，但查询不同的东西。</li><li>SqlSession 不同时。</li><li>SqlSession 相同，手动清除一级缓存。</li></ul><p><em>说一说 MyBatis 的二级缓存</em><br>一级缓存当会话关闭后就会释放，所以我们需要一个这个情况下数据依然存在的缓存。<br><strong>不过查出的数据都会被默认先放在一级缓存中，只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中。</strong></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>其他依赖</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/%E5%85%B6%E4%BB%96%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Log"><a href="#一、Log" class="headerlink" title="一、Log"></a>一、Log</h1><p><em>主流依赖</em></p><ul><li>slf4j：日志的统一接口，@sLf4相当于为该类添加默认logger实例。</li><li>log4j：一种日志框架</li><li>logback：一种日志框架，Spring默认使用</li></ul><p><em>使用</em><br>在静态资源文件夹创建logback.xml配置文件。</p><ul><li>logger和root都是日志调度器，root是所有logger的父调度器</li><li>日志会根据最长包名匹配寻找处理自己的logger&#x2F;root</li><li>logger行为<ul><li>根据level对日志过滤</li><li>根据appender-ref调用处理器</li><li>根据additivity属性判断是否要传播该日志给父logger</li></ul></li></ul><blockquote><p>一般希望独立处理的日志可以使用logger拦截处理，并设置additivity不传播。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!-- property定义基本属性 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 日志存放路径 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.path&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;d:/data/logs/newwish/picker&quot;</span> /&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 日志输出格式 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;20&#125; - [%method,%line] - %msg%n&quot;</span> /&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- appender是日志的输出器，指定了将哪些日志输出到哪里 --&gt;</span><br>   <span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  <br>   <span class="hljs-comment">&lt;!-- 系统日志输出 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file_info&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/info.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!-- 循环政策：基于时间创建日志文件 --&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 日志文件名格式 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>  <br>         <span class="hljs-comment">&lt;!-- 日志最大的历史 60天 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 过滤的级别 --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>INFO<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 匹配时的操作：接收（记录） --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 不匹配时的操作：拒绝（不记录） --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file_error&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;log.path&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!-- 循环政策：基于时间创建日志文件 --&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 日志文件名格式 --&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>  <br>         <span class="hljs-comment">&lt;!-- 日志最大的历史 60天 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span>  <br>            <span class="hljs-comment">&lt;!-- 过滤的级别 --&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>WARN<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- 系统模块日志级别控制,拦截这些日志，只通过info以上的日志  --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.newwish.picker&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> /&gt;</span>  <br>   <span class="hljs-comment">&lt;!-- Spring日志级别控制，拦截这些日志，只通过warn以上的日志  --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;warn&quot;</span> /&gt;</span>  <br>  <br>    <span class="hljs-comment">&lt;!-- root是logger的根节点，会在控制台打印所有大于info的日志 --&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;console&quot;</span> /&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>  <br>   <span class="hljs-comment">&lt;!--系统操作日志，所有等级大于info的日志都会输出到appender--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file_info&quot;</span> /&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;file_error&quot;</span> /&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二、Maven"><a href="#二、Maven" class="headerlink" title="二、Maven"></a>二、Maven</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn clean</td><td>清理项⽬⽣产的临时⽂件,⼀般是模块下的target⽬录</td></tr><tr><td>mvn compile</td><td>编译源代码，⼀般编译模块下的src&#x2F;main&#x2F;java⽬录</td></tr><tr><td>mvn package</td><td>项⽬打包⼯具,会在模块下的target⽬录⽣成jar或war等⽂件</td></tr><tr><td>mvn test</td><td>测试命令,或执⾏src&#x2F;test&#x2F;java&#x2F;下junit的测试⽤例</td></tr><tr><td>mvn –version</td><td>显示版本信息</td></tr><tr><td>mvn install</td><td>将打包的jar&#x2F;war⽂件复制到你的本地仓库中,供其他模块使⽤</td></tr><tr><td>mvn deploy</td><td>将打包的⽂件发布到远程参考,提供其他⼈员进⾏下载依赖</td></tr><tr><td>mvn site</td><td>⽣成项⽬相关信息的⽹站</td></tr><tr><td>mvn eclipse:eclipse</td><td>将项⽬转化为Eclipse项⽬</td></tr><tr><td>mvn dependency:tree</td><td>打印出项⽬的整个依赖树</td></tr><tr><td>mvn archetype:generate</td><td>创建Maven的普通java项⽬</td></tr><tr><td>mvn tomcat7:run</td><td>在tomcat容器中运⾏web应⽤</td></tr><tr><td>mvn jetty:run</td><td>调⽤ Jetty 插件的 Run ⽬标在 Jetty Servlet 容器中启动 web 应⽤</td></tr></tbody></table><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- maven模型版本，必须为4.0.0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目所属公司 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目标准名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 打包方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>maven01<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 项目描述 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>description<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多环境打包"><a href="#多环境打包" class="headerlink" title="多环境打包"></a>多环境打包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">env</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">env</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">env</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filters</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>config/$&#123;env&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filters</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--过滤配置文件作为配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>config/$&#123;env&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 除配置文件外也是资源文件，但不过滤 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>config/$&#123;env&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打包命令：<br><code>mvn package -Pdev -Dmaven.test.skip=true</code>，<code>&lt;id&gt;</code>表示识别到<code>-P</code>携带了<code>dev</code>参数后，将env变量的值赋值为dev，然后maven到<code>resources/filter</code>中寻找配置文件。</p><blockquote><p><code>&lt;include&gt;</code>与<code>&lt;exclude&gt;</code>是用来圈定和排除某一文件目录下的文件是否是工程资源的。如果<code>&lt;include&gt;</code>与<code>&lt;exclude&gt;</code>划定的范围存在冲突时，以<code>&lt;exclude&gt;</code>划定的范围为准。大多数情况下，人们使用<code>&lt;include&gt;</code>和<code>&lt;exclude&gt;</code>是为了配合<code>&lt;filtering&gt;</code>实现过滤特定文件的需要。</p></blockquote><h2 id="多模块构建"><a href="#多模块构建" class="headerlink" title="多模块构建"></a>多模块构建</h2><p><em>依赖复用</em><br><code>&lt;dependencies&gt;</code>，父项目pom文件可以引入一些通用依赖，子模块会直接继承这些依赖。</p><p><em>版本管理</em><br><code>&lt;dependencyMangement&gt;</code>，父项目pom可以声明一些通用依赖，子模块在引用该依赖时则可以不指定版本号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--spring boot 2.2.2--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>模块依赖</em><br>子模块之间互相添加彼此的依赖以实现相互调用，打包时需要对各模块进行install，以供其他模块引入。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>其他依赖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>其他依赖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式七大原则"><a href="#一、设计模式七大原则" class="headerlink" title="一、设计模式七大原则"></a>一、设计模式七大原则</h1><p>开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。<br>单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。<br>依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。<br>接口隔离原则：将不同功能定义在不同接口中实现接口隔离。<br>里氏替换原则：任何基类可以出现的地方，子类一定可以出现。<br>迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。<br>合成复用原则：尽量使用组合(has-a)&#x2F;聚合(contains-a)而不是继承(is-a)达到软件复用的目的。</p><div class="note note-primary">            <p>开单依接里迪合</p>          </div><h1 id="二、设计模式分类"><a href="#二、设计模式分类" class="headerlink" title="二、设计模式分类"></a>二、设计模式分类</h1><p><em>创建型模式</em>：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><em>结构型模式</em>：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><em>行为型模式</em>：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><div class="note note-primary">            <p>单抽工建原<br>适装代外桥组享<br>策模观迭责命<br>备状访中解</p>          </div><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>定义：</strong> 是确保某一个类只有一个实例，并且提供一个全局访问点。<br><strong>应用实例：</strong> 唯一序列号、web页面计数器</p><div class="note note-primary">            <p>若想实现线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>              <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">synchronized</span> (instance) &#123;<br>                           <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                           &#125;<br>                     &#125;<br>              &#125;<br>              <span class="hljs-keyword">return</span> instance;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><em>简单工厂模式</em>：一个工厂类根据传入的参量决定创建出那一种产品类的实例。<br>问题在于类的创建依赖工厂，扩展类时也要修改工厂类，不属于23类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimplePizzaFactory</span> &#123;<br>       <span class="hljs-keyword">public</span> Pizza <span class="hljs-title function_">CreatePizza</span><span class="hljs-params">(String ordertype)</span> &#123;<br>              <span class="hljs-type">Pizza</span> <span class="hljs-variable">pizza</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>              <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheesePizza</span>();<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;greek&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GreekPizza</span>();<br>              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ordertype.equals(<span class="hljs-string">&quot;pepper&quot;</span>)) &#123;<br>                     pizza = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PepperPizza</span>();<br>              &#125;<br>              <span class="hljs-keyword">return</span> pizza;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>工厂方法模式</em><br><strong>定义了一个创建对象的接口</strong>，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。（只实现某一实例的多样化生产）<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213113030.png"></p><p><em>抽象工厂模式</em><br><strong>定义一个接口用于创建对象族</strong>，无需指定它们的具体类。（实现某一类产品的多样化生产）<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213113259.png"></p><p>区别：<br>工厂方法重点在于<strong>方法</strong>：一个工厂（品牌）只能生产一种产品（鼠标），通过实现多个工厂扩展产品类型。<br>抽象工厂重点在于<strong>工厂</strong>：一个工厂（品牌）可以生产一系列不同产品（鼠标、键盘），通过实现多个工厂扩展产品系列的类型。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>封装一个<strong>复杂对象</strong>构造过程，并允许按步骤构造。<br>创建复杂一个对象需要为其装载很多属性，将这些装载属性的方法封装在不同方法中，子类继承时通过重写不同的方法，实现对对象创建的精准控制。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>复制现有实例：</p><ol><li>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</li><li>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</li></ol><blockquote><p>简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单(简)抽工建原</p><h2 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h2><p>适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>定义：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p><p>分类：</p><ul><li>类适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li><li>对象适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li><li>接口适配器模式：当不需要全部实现接口提供的方法时，可先设计一个抽象类（接口）实现接口，并为该接口中每一个方法提供一个空方法，那么继承该抽象类的子类则会有选择的覆盖父类的某些方法来实现需求。</li></ul><p>简单来说就是希望一个类、对象、接口（抽象类）实现一个新的接口：</p><ul><li>类可以继承原类，实现新接口（少用）</li><li>对象可以实现新接口，聚合原类</li><li>使用抽象类实现接口，并提供空方法。子类继承抽象类时则可以有选择性的覆盖方法实现需求。</li></ul><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>定义：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。</p><p>例子：为咖啡添加牛奶，但他们都属于饮品。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213123111.png"><br>代码上，先生成coffee，为其装饰时，将coffer作为参数传入milk的构造器，由milk中的方法对其进行修饰。</p><p><strong>装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。</strong></p><blockquote><p>根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。</p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ol><li>静态代理 2. 动态代理 3. CGLIB代理</li></ol><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>定义：</strong> 隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213123610.png"><br>破坏了开放封闭原则</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>例子：<br><img src="/2023/02/13/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Pasted-image-20230213124307.png"><br>某个类可能在不同的功能方向进行扩展，如果使用继承会造成类爆炸。通过将不同方向的扩展转变成通过聚合来实现，实现解偶。本例中将软件作为成员提炼出来，此后软件的实现类就可以独立变化。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>定义：通过共享的方式高效的支持大量细粒度的对象。<br>简单来说：抽取出一个对象的外部状态（不能共享）和内部状态（可以共享）。然后根据外部状态的决定是否创建内部状态对象。内部状态对象是通过哈希表保存的，当外部状态相同的时候，不再重复的创建内部状态对象，从而减少要创建对象的数量。<br><strong>应用实例：</strong> JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>适配器模式：转化对象接口。<br>装饰者模式、代理模式：增强原对象。<br>外观模式、桥接模式、组合模式、享受元模：系统封装、功能隔离、功能分级、功能共享。</p><p>适、装代、外桥组享</p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>定义：</strong> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><blockquote><p>可以理解成针对算法（策略）的工厂模式。</p></blockquote><h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p><strong>定义：</strong> 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。<br><strong>应用实例</strong>：AQS</p><h3 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><strong>定义：</strong> 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br><strong>应用实例：</strong> JAVA 中的 iterator。</p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>定义：</strong> 如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。<br><strong>应用实例：</strong> Handler</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>定义：</strong> 将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><h3 id="类的状态"><a href="#类的状态" class="headerlink" title="类的状态"></a>类的状态</h3><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p><strong>定义：</strong> 当对象的状态改变时，同时改变其行为<br><strong>应用实例：</strong> 如Reentrant锁的state</p><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><strong>定义：</strong> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><h3 id="通过中间类"><a href="#通过中间类" class="headerlink" title="通过中间类"></a>通过中间类</h3><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p><strong>定义：</strong> 将作用于某种数据结构中的各元素的操作分离出来<strong>封装成独立的类</strong>，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将<strong>对数据的操作与数据结构进行分离</strong>。</p><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p><strong>定义：</strong> 定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p><strong>定义：</strong> 为语言创建解释器，通常由语言的语法和语法分析来定义。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>策模观迭责命<br>状备访中解</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p><em>设计模式七大原则：</em><br>开单依接里迪合</p><p><em>设计模式：</em><br>单抽工建原<br>适装代外桥组享<br>策模观迭责命<br>状备访中解</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（内存与事务）</title>
    <link href="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Buffer-Poll"><a href="#一、Buffer-Poll" class="headerlink" title="一、Buffer Poll"></a>一、Buffer Poll</h1><h2 id="Buffer-Poll概念"><a href="#Buffer-Poll概念" class="headerlink" title="Buffer Poll概念"></a>Buffer Poll概念</h2><p><code>MySQL</code>服务器启动的时候就向操作系统申请了一片<strong>连续的内存</strong>，叫做<code>Buffer Pool</code>（缓冲池）。</p><h3 id="Buffer-Pool大小"><a href="#Buffer-Pool大小" class="headerlink" title="Buffer Pool大小"></a>Buffer Pool大小</h3><p>默认情况<code>Buffer Pool</code>只有<code>128M</code>，可以在启动服务器的时候配置<code>innodb_buffer_pool_size</code>参数的值来改变该值的大小。</p><h3 id="Buffer-Pool内部组成"><a href="#Buffer-Pool内部组成" class="headerlink" title="Buffer Pool内部组成"></a>Buffer Pool内部组成</h3><p><code>Buffer Pool</code>中默认的缓存页大小和在磁盘上默认的页大小是一样的，都是<code>16KB</code>。<br>每一个缓存页都有一个<strong>控制块</strong>，来装一些<code>控制信息</code>，这些控制信息包括该页所属的表空间编号、页号、缓存页在<code>Buffer Pool</code>中的地址、链表节点信息、一些锁信息以及<code>LSN</code>信息。</p><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2b9d6dd1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="Buffer-Poll管理"><a href="#Buffer-Poll管理" class="headerlink" title="Buffer Poll管理"></a>Buffer Poll管理</h2><h3 id="缓存页的哈希处理"><a href="#缓存页的哈希处理" class="headerlink" title="缓存页的哈希处理"></a>缓存页的哈希处理</h3><p>Buffer Poll以<code>表空间号 + 页号</code>作为<code>key</code>，<code>缓存页</code>作为<code>value</code>创建了一个Hash表，如果访问时命中则直接访问，否则在free链表中申请。</p><h3 id="free链表"><a href="#free链表" class="headerlink" title="free链表"></a>free链表</h3><p>把所有空闲的缓存页对应的控制块作为一个节点放到一个链表中，这个链表也可以被称作<code>free链表</code><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e300173c1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>链表的<code>基节点</code>占用的内存空间并不包含在<code>Buffer Pool</code>中，而是另外单独申请的一块内存空间，后续的各种链表基节点同理。</p></blockquote><h3 id="flush链表"><a href="#flush链表" class="headerlink" title="flush链表"></a>flush链表</h3><p>修改后的缓存页叫做<code>脏页</code>，为了避免频繁写磁盘影响性能，通过flush链表记录脏页，实现异步的写入磁盘。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2ec4572a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="LRU链表"><a href="#LRU链表" class="headerlink" title="LRU链表"></a>LRU链表</h3><p><code>Buffer Pool</code>大小有限，有时需要将一些页淘汰出缓存。</p><h4 id="简单的LRU链表"><a href="#简单的LRU链表" class="headerlink" title="简单的LRU链表"></a>简单的LRU链表</h4><p>以<code>按照最近最少使用</code>的原则去淘汰缓存页，实现这个功能的链表被称为<code>LRU链表</code>（Least Recently Used）。<br>页面在被访问后就放在LRU链表的头部，淘汰时从尾部开始淘汰即可。</p><h4 id="划分区域的LRU链表"><a href="#划分区域的LRU链表" class="headerlink" title="划分区域的LRU链表"></a>划分区域的LRU链表</h4><h5 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h5><ol><li>InnoDB对于可能会读取的页面，会进行预加载，也叫<strong>预读</strong>。<ul><li>线性预读：如果访问某个区的页面超过56，则异步读取<strong>下一个区所有页面</strong>。</li><li>随机预读：如果缓存了某区的13个连续页面，则异步读取<strong>本区所有页面</strong>，默认关闭。</li></ul></li></ol><p>这会造成加载到Buffer Poll的页不一定用到，导致真正的热点数据淘汰。</p><ol start="2"><li>全表扫描</li></ol><p>非常多的使用频率偏低的页被同时加载到<code>Buffer Pool</code>时，可能会把那些使用频率非常高的页从<code>Buffer Pool</code>中淘汰掉。</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>InnoDB把这个<code>LRU链表</code>按照一定比例分成两截，分别是：</p><ul><li>一部分链表叫做<code>热数据</code>，或者称<code>young区域</code>。</li><li>另一部分叫做<code>冷数据</code>，或者称<code>old区域</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2a3fffa3_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>默认情况下，<code>old</code>区域在<code>LRU链表</code>中所占的比例是<code>37%</code>。</p><p>通过分区和访问策略，分别解决了预读和全表扫描的问题。</p><p><em>访问策略</em></p><ul><li>页面初次加载时，对应控制块放在old区头部。</li><li>在控制块上记录<strong>第一次访问时间</strong>，如果在特别短的时间（<code>innodb_old_blocks_time</code> &#x3D; 1s）内再次访问，不会将其移动到young区头部。</li></ul><h4 id="优化LRU链表"><a href="#优化LRU链表" class="headerlink" title="优化LRU链表"></a>优化LRU链表</h4><p>频繁操作头节点开销较大，要降低调整LRU链表的频率。选择只有被访问的缓存页位于<code>young</code>区域的<code>1/4</code>的后边，才会被移动到<code>LRU链表</code>头部。</p><h3 id="其他的一些链表"><a href="#其他的一些链表" class="headerlink" title="其他的一些链表"></a>其他的一些链表</h3><p>比如<code>unzip LRU链表</code>用于管理解压页，<code>zip clean链表</code>用于管理没有被解压的压缩页，<code>zip free数组</code>中每一个元素都代表一个链表，它们组成所谓的<code>伙伴系统</code>来为压缩页提供内存空间等等。</p><div class="note note-primary">            <p>Buffer Poll中有：HashMap、FREE链表、LRU链表、FLUSH链表、其他链表。</p>          </div><h3 id="空间释放"><a href="#空间释放" class="headerlink" title="空间释放"></a>空间释放</h3><p>后台有专门的线程每隔一段时间负责把脏页刷新到磁盘，主要有两种刷新路径：</p><ul><li><code>BUF_FLUSH_LRU</code>：从<code>LRU链表</code>的冷数据中刷新一部分页面到磁盘</li><li><code>BUF_FLUSH_LIST</code>：从<code>flush链表</code>中刷新一部分页面到磁盘</li></ul><p><em>空间释放策略</em></p><ol><li>当空间不够时，用户线程看<code>LRU链表</code>尾部有没有可以释放未修改页面<ul><li>有则释放</li><li>没有则将LRU尾部脏页写盘后释放</li></ul></li><li>特别繁忙时，用户线程批量从<code>flush链表</code>中将脏页刷入盘中。</li></ol><h2 id="多Buffer-Pool实例"><a href="#多Buffer-Pool实例" class="headerlink" title="多Buffer Pool实例"></a>多Buffer Pool实例</h2><p>通过修改<code>innodb_buffer_pool_instances</code>设置Buffer Poll的个数。各Buffer Poll完全独立，提高了并发处理能力：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2abd79c1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>每个Buffer Poll内存大小</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">innodb_buffer_pool_size/innodb_buffer_pool_instances<br></code></pre></td></tr></table></figure><p>即总共的大小除以实例的个数。</p><p><em>热更改</em></p><ul><li>MySQL5.7.5之前，只能在启动时配置Buffer Pool内存大小。</li><li>MySQL5.7.5之后，可以在运行时修改。<ul><li>如果想调整<code>Buffer Poll</code>大小，需要重新向操作系统申请连续内存空间，并将旧<code>Buffer Poll</code>复制过来。<strong>为了避免申请连续内存和复制的开销，MySQL将以<code>chunk</code>为单位向操作系统申请空间。</strong></li><li>一个<code>Buffer Pool</code>实例其实是由若干个<code>chunk</code>组成的，一个<code>chunk</code>就代表一片连续的内存空间。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1693e86e2a5de8f2_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>上图表明，1个<code>Buffer Pool</code>由2个实例组成的，每个实例中又包含2个<code>chunk</code>。</p></blockquote><div class="note note-primary">            <p><code>chunk</code>是MySQL通过<code>innodb_buffer_pool_chunk_size</code>启动参数指定的，默认为128M，运行时无法修改。</p>          </div><blockquote><p>注意：</p><ul><li><code>innodb_buffer_pool_size</code>必须是<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances</code>的倍数，否则系统会自动调整<code>innodb_buffer_pool_size</code>的大小。</li><li>如果<code>innodb_buffer_pool_chunk_size × innodb_buffer_pool_instances&gt;innodb_buffer_pool_size</code>，则系统会自动调整<code>innodb_buffer_pool_chunk_size</code>大小。<br>即：</li><li>总大小 &lt; 分片 * 每片大小，则会调整每片大小</li><li>总大小 &gt; 分片 * 每片大小，但不是后者的整数倍，则会调节成后者的整数倍。</li></ul></blockquote><h2 id="Buffer-Pool中存储的其它信息"><a href="#Buffer-Pool中存储的其它信息" class="headerlink" title="Buffer Pool中存储的其它信息"></a>Buffer Pool中存储的其它信息</h2><p>链表和各种内存访问操作的统计数据。</p><h1 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h1><h2 id="事务基本性质"><a href="#事务基本性质" class="headerlink" title="事务基本性质"></a>事务基本性质</h2><ul><li>原子性（<code>Atomicity</code>）：事务是不可分割的操作</li><li>一致性（<code>Consistency</code>）：保证数据库符合现实世界约束。</li><li>隔离性（<code>Isolation</code>）：两个并发事务之间不能互相影响。</li><li>持久性（<code>Durability</code>）：<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来。</li></ul><blockquote><p>原子性和隔离性都是保证一致性的手段。</p></blockquote><h2 id="事务语法"><a href="#事务语法" class="headerlink" title="事务语法"></a>事务语法</h2><h2 id="事务五态模型"><a href="#事务五态模型" class="headerlink" title="事务五态模型"></a>事务五态模型</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169d7fd5bd4ce2f1_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>目前只有<code>InnoDB</code>和<code>NDB</code>存储引擎支持事务。</p></blockquote><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><ul><li><code>BEGIN</code></li><li><code>START TRANSACTION</code>：后面可接修饰符指定事务模式（默认为读写模式）：<ul><li><code>READ ONLY</code>：只读事务</li><li><code>READ WRITE</code>：读写事务</li><li><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读todo</li></ul></li></ul><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><ul><li><code>COMMIT [WORK]</code></li></ul><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>，默认开启，表示每一条SQL语句是一个独立事务。</p><p><em>关闭自动提交</em></p><ul><li>显示开启事务。</li><li>修改系统变量<code>autocommit</code>为<code>true</code>。</li></ul><h4 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h4><p>有些语句会将本语句和之前的语句隐式提交</p><ul><li>定义或修改数据库对象的数据定义语言</li><li>使用或修改<code>mysql</code>数据库中的表</li><li>事务控制或关于锁定的语句</li><li>加载数据</li><li>复制（主从）语句</li></ul><h3 id="中止事务"><a href="#中止事务" class="headerlink" title="中止事务"></a>中止事务</h3><ul><li><code>ROLLBACK [WORK]</code></li></ul><h4 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h4><p>定义保存点和回滚保存点的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SAVEPOINT 保存点名称;<br>ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;<br></code></pre></td></tr></table></figure><h1 id="三、redo日志"><a href="#三、redo日志" class="headerlink" title="三、redo日志"></a>三、redo日志</h1><h2 id="redo日志简介"><a href="#redo日志简介" class="headerlink" title="redo日志简介"></a>redo日志简介</h2><p>redo日志的目的是<strong>保证一致性</strong>（事务提交后一定执行）:</p><ul><li>若修改一个字段就对页进行一次刷盘，效率很低。</li><li>事务可能涉及多个页，随机I&#x2F;O效率低。</li></ul><p>mysql通过redo日志记录事务执行的结果，并持久化到硬盘，相比将脏页持久化到硬盘:</p><ul><li>效率更高。</li><li>顺序IO执行的。</li></ul><h2 id="redo日志格式"><a href="#redo日志格式" class="headerlink" title="redo日志格式"></a>redo日志格式</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdec61898_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="简单redo日志"><a href="#简单redo日志" class="headerlink" title="简单redo日志"></a>简单redo日志</h3><p>只需要记录在某个页面修改&#x2F;写入了几字节值类型的redo日志叫做简单redo日志，也叫物理日志：</p><ul><li><code>MLOG_1/2/4/8BYTE</code>（<code>type</code>字段对应的十进制数字为<code>1/2/4/8</code>）：表示在页面的某个偏移量处写入<code>1/2/4/8</code>个字节的<code>redo</code>日志类型。</li><li><code>MLOG_WRITE_STRING</code>（<code>type</code>字段对应的十进制数字为<code>30</code>）：表示在页面的某个偏移量处写入一串数据，日志多了一个len字段。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdf053082_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdf3da823_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><div class="note note-primary">            <p>简单redo日志只记录在哪个地方写入了什么数据。</p>          </div><h3 id="复杂redo日志（插入日志）"><a href="#复杂redo日志（插入日志）" class="headerlink" title="复杂redo日志（插入日志）"></a>复杂redo日志（插入日志）</h3><p>插入新记录可能修改多个B+树，每个页面的统计信息也会更新：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694892fdfa7d8ce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>解决方案</em></p><ul><li>方案一：在每个修改的地方都记录一条<code>redo</code>日志。</li><li>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。</li></ul><p><em>InnoDB的解决</em><br>提出了一些新的<code>redo</code>日志类型，比如：</p><ul><li><code>MLOG_REC_INSERT</code>（对应的十进制数字为<code>9</code>）：表示插入一条使用非紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_REC_INSERT</code>（对应的十进制数字为<code>38</code>）：表示插入一条使用紧凑行格式的记录时的<code>redo</code>日志类型。</li><li><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>44</code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的<code>redo</code>日志类型。</li><li>等等…</li></ul><blockquote><p>逻辑上看，这些复杂redo日志无法用来直接记录修改结果，而是将修改时的行为记录下来，恢复时需要调用相关函数进行恢复。</p></blockquote><h2 id="redo日志分组"><a href="#redo日志分组" class="headerlink" title="redo日志分组"></a>redo日志分组</h2><h3 id="实现分组"><a href="#实现分组" class="headerlink" title="实现分组"></a>实现分组</h3><p>一条Sql语句可能产生多条redo日志，这些redo日志应该以组的形式写入磁盘，这是<strong>原子性</strong>的需要。</p><p><em>如何分组？</em></p><ul><li>每组的最后一条<code>redo</code>日志<strong>后边</strong>加上一条特殊类型的<code>redo</code>日志（分界符，只有一个type字段）</li><li>对于只有一条redo日志的组，通过<code>type</code>的第一个<code>bit</code>位标识即可，避免浪费。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489301685dcb4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="Mini-Transaction"><a href="#Mini-Transaction" class="headerlink" title="Mini-Transaction"></a>Mini-Transaction</h3><p>对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303b9e5c9f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="redo日志的写入"><a href="#redo日志的写入" class="headerlink" title="redo日志的写入"></a>redo日志的写入</h2><h3 id="redo-log-block"><a href="#redo-log-block" class="headerlink" title="redo log block"></a>redo log block</h3><p>通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。这里的页与前面16KB的页不同，可以将其称为<code>block</code>加以区分。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303bff8e20_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303c1fb389_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><em>LOG_BLOCK_HDR_NO是如何计算的</em><br>32位，前2位为0，所以该值最大为1G，意味着block块的个数不能超过1G。</p><h3 id="redo-log-buffer"><a href="#redo-log-buffer" class="headerlink" title="redo log buffer"></a>redo log buffer</h3><p><code>redo</code>日志也不能直接直接写到磁盘上，服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的<strong>连续内存空间</strong>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489303ceeb982_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小（默认16MB）。</p><h3 id="redo日志写入log-buffer"><a href="#redo日志写入log-buffer" class="headerlink" title="redo日志写入log buffer"></a>redo日志写入log buffer</h3><p>redo日志的写入是顺序的，InnoDB通过一个全局变量<code>buf_free</code>指明后续应该写入到哪个地方。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/1694893043dc7344_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>一个事务对应多个mtr，一个mtr对应一组redo日志，即一个事务有多个redo日志组。<br>由于事务是并发进行的，所以两个事务的redo日志组可能交替存储：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169489304969c9d7_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="redo日志写入磁盘"><a href="#redo日志写入磁盘" class="headerlink" title="redo日志写入磁盘"></a>redo日志写入磁盘</h2><p>在一些情况下redo日志会从log buffer中刷新到磁盘里，比如：</p><ul><li><code>log buffer</code>空间不足时</li><li>事务提交时（持久性）</li><li>将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中。</li><li>后台线程</li><li>正常关闭服务器时</li><li>做<code>checkpoint</code>时</li></ul><h3 id="redo日志文件组"><a href="#redo日志文件组" class="headerlink" title="redo日志文件组"></a>redo日志文件组</h3><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，两个文件循环写入：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899033f3b35d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>也可以修改配置指定多个文件，<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p><h3 id="redo日志文件格式"><a href="#redo日志文件格式" class="headerlink" title="redo日志文件格式"></a>redo日志文件格式</h3><p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p><ul><li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li><li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</li></ul><blockquote><p>注意，这里都是以block作为单位，也就是一个日志存储单元的大小。</p></blockquote><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899033e1cb89_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p><em>log file header：</em><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899065200011_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td>LOG_HEADER_FORMAT</td><td>4</td><td>redo日志的版本，在MySQL 5.7.21中该值永远为1</td></tr><tr><td>LOG_HEADER_PAD1</td><td>4</td><td>做字节填充用的，没什么实际意义，忽略～</td></tr><tr><td>LOG_HEADER_START_LSN</td><td>8</td><td>标记本redo日志文件开始的LSN值，也就是文件偏移量为2048字节初对应的LSN值（关于什么是LSN我们稍后再看哈，看不懂的先忽略）。</td></tr><tr><td>LOG_HEADER_CREATOR</td><td>32</td><td>一个字符串，标记本redo日志文件的创建者是谁。正常运行时该值为MySQL的版本号，比如：”MySQL 5.7.21”，使用mysqlbackup命令创建的redo日志文件的该值为”ibbackup”和创建时间。</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><p><em>checkpoint1</em><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899037defb21_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>属性名</th><th>长度（单位：字节）</th><th>描述</th></tr></thead><tbody><tr><td>LOG_CHECKPOINT_NO</td><td>8</td><td>服务器做checkpoint的编号，每做一次checkpoint，该值就加1。</td></tr><tr><td>LOG_CHECKPOINT_LSN</td><td>8</td><td>服务器做checkpoint结束时对应的LSN值，系统崩溃恢复时将从该值开始。</td></tr><tr><td>LOG_CHECKPOINT_OFFSET</td><td>8</td><td>上个属性中的LSN值在redo日志文件组中的偏移量</td></tr><tr><td>LOG_CHECKPOINT_LOG_BUF_SIZE</td><td>8</td><td>服务器在做checkpoint操作时对应的log buffer的大小</td></tr><tr><td>LOG_BLOCK_CHECKSUM</td><td>4</td><td>本block的校验值，所有block都有，我们不关心</td></tr></tbody></table><h2 id="redo日志的id"><a href="#redo日志的id" class="headerlink" title="redo日志的id"></a>redo日志的id</h2><h3 id="log-sequence-number（LSN）"><a href="#log-sequence-number（LSN）" class="headerlink" title="log sequence number（LSN）"></a>log sequence number（LSN）</h3><p><code>log sequence number</code>是一个全局变量，初始值为8704。其帮助标识了<strong>每个mtr的redo日志组</strong>在log buffer中的起始和结束位置。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899037f19b86_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="flushed-to-disk-lsn"><a href="#flushed-to-disk-lsn" class="headerlink" title="flushed_to_disk_lsn"></a>flushed_to_disk_lsn</h3><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。</p><ul><li><code>log sequence number</code>：全局变量，初始值为8704，标识<strong>mtr的redo日志组</strong>在log buffer中的位置。</li><li><code>flushed_to_disk_lsn</code>：全局变量，表示刷新到磁盘中的<code>redo</code>日志量的全局变量。</li><li><code>buf_free</code>：全局变量（指针），标志下一个mtr写入指针。</li><li><code>buf_next_to_write</code>：全局变量（指针），标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899065ece690_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>总结：当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。</p><blockquote><p>lsn值和redo日志文件偏移量的对应关系：<br><code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（加上<code>log block header</code>和<code>log block trailer</code>的大小）</p></blockquote><h3 id="flush链表中的LSN"><a href="#flush链表中的LSN" class="headerlink" title="flush链表中的LSN"></a>flush链表中的LSN</h3><p>修改页内容后要将其控制块加入flush链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b899094bcc632_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>每个控制块记录两个属性：</p><ul><li><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</li><li><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</li></ul><p><em>eg:</em><br>修改页顺序：</p><ul><li>mtr_1：a</li><li>mtr_2：b,c</li><li>mtr_3：b,d<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b89909693bfe9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></li></ul><blockquote><p>一个mtr中修改的两个页的o_m和n_m字段是相同的，所以lsn的变动单位是一个mtr而不是一个redo日志！</p></blockquote><h2 id="redo日志的释放"><a href="#redo日志的释放" class="headerlink" title="redo日志的释放"></a>redo日志的释放</h2><h3 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h3><p>redo日志文件大小有限，需要循环写入，因此redo日志文件需要释放空间：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b8990a1ec0f87_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>脏页刷盘前，redo日志必须写入磁盘；</li><li>脏页刷盘后，redo日志可释放；</li></ul><p>脏页刷盘、释放redo日志的过程本质是增加<code>checkpoint_lsn</code>的操作：</p><ul><li>计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。</li><li>将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/169b8990aeb41002_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>checkpoint_lsn：脏页已持久化<br>flushed_to_dick_lsn：redo日志已持久化<br>lsn：当前redo日志序列</p><h3 id="批量从flush链表中刷出脏页"><a href="#批量从flush链表中刷出脏页" class="headerlink" title="批量从flush链表中刷出脏页"></a>批量从flush链表中刷出脏页</h3><p>当lsn增长过快时，系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘。</p><h3 id="innodb-flush-log-at-trx-commit的用法"><a href="#innodb-flush-log-at-trx-commit的用法" class="headerlink" title="innodb_flush_log_at_trx_commit的用法"></a>innodb_flush_log_at_trx_commit的用法</h3><p>如果对持久性要求不太高，可以修改<code>innodb_flush_log_at_trx_commit</code>系统变量</p><ul><li><code>0</code>：当该系统变量值为0时，表示在事务提交时不立即向磁盘中同步<code>redo</code>日志；</li><li><code>1</code>：当该系统变量值为1时，表示在事务提交时需要将<code>redo</code>日志同步到磁盘；</li><li><code>2</code>：当该系统变量值为2时，表示在事务提交时需要将<code>redo</code>日志写到操作系统的缓冲区中；（这种情况下如果数据库挂了，操作系统没挂的话，事务的<code>持久性</code>还是可以保证的，但是操作系统也挂了的话，那就不能保证<code>持久性</code>了）。</li></ul><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p><em>恢复的起点</em><br><code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖。</p><p><em>恢复的终点</em><br>log buffer文件是顺序IO的，找到没写满的block即可</p><p><em>怎么恢复</em></p><ul><li>Hash：使用hash将同一个表中同一个页的redo日志放在一起处理。</li><li>跳过已经刷新到磁盘的页面：<code>checkpoint_lsn</code>之后的<code>redo</code>日志可能也已经刷盘，根据每个页的<code>File Header</code>部分中的lsn字段可以判断本页最后一次刷盘时的lsn号，若其大于<code>checkpoint_lsn</code>，也不用恢复。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>redo日志的作用：记录事务执行的结果&#x2F;过程，主要数据库崩溃时的恢复，实现持久性。</li><li>redo日志的结构：每条语句可能修改多个页面，对应着若干条redo日志记录，这些记录以组的形式（mtr）存在。</li><li>redo日志的存储：redo日志会先写入log buffer区，然后同步到系统上的log file中。<ul><li>log buffer分若干个block块</li><li>相比log buffer，log file的前4个块是固定的</li></ul></li><li>redo日志的释放：脏页被刷盘时，形成一个check-point事件（记录当前check point lsn），该lsn之前redo日志不再被需要，可以释放。</li><li>崩溃恢复时：从check point lsn开始恢复，遇到页的lsn记录大于check point lsn时略过。</li></ul><h1 id="四、undo日志"><a href="#四、undo日志" class="headerlink" title="四、undo日志"></a>四、undo日志</h1><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>redo是为了防止数据库崩溃（持久性），undo是为了防止事件回滚（原子性）。</p><h2 id="事务id"><a href="#事务id" class="headerlink" title="事务id"></a>事务id</h2><p>当一个事务涉及到对某个表执行了增、删、改操作时，会为其分配一个事务id。<br>事务id由一个全局变量维护，新事务id自增1，当事务id达到<code>256</code>的倍数时，会将其记录下来<code>Max Trx ID</code>，下次启动时在该值基础上加256，防止事务id冲突。</p><h2 id="undo日志的格式"><a href="#undo日志的格式" class="headerlink" title="undo日志的格式"></a>undo日志的格式</h2><p><code>undo日志</code>是被记录到类型为<code>FIL_PAGE_UNDO_LOG</code>的页面中。<br>类似于<code>redo日志</code>：</p><ul><li>一个事务操作对应多个mtr，一个mtr对应多个<code>undo日志</code>。</li><li><code>undo no</code>在<strong>一个事务</strong>中是从<code>0</code>开始递增的，也就是说只要事务没提交，每生成一条<code>undo日志</code>，那么该条日志的<code>undo no</code>就增1。<ul><li>redo是以组mtr为单位记录，复写的；</li><li>undo日志是以事务为单位记录、还原的。</li></ul></li><li><code>undo日志</code>也有很多种类。</li></ul><h3 id="行记录"><a href="#行记录" class="headerlink" title="行记录"></a>行记录</h3><h4 id="trx隐藏列"><a href="#trx隐藏列" class="headerlink" title="trx隐藏列"></a>trx隐藏列</h4><p>行格式中有一个<code>trx_id</code>字段，表示现在对该行进行修改的事务id。</p><h4 id="roll-pointer隐藏列"><a href="#roll-pointer隐藏列" class="headerlink" title="roll_pointer隐藏列"></a>roll_pointer隐藏列</h4><p>指向记录对应的<code>undo日志</code>的一个指针。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875af986df5c6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="undo日志类型"><a href="#undo日志类型" class="headerlink" title="undo日志类型"></a>undo日志类型</h2><h4 id="insert类"><a href="#insert类" class="headerlink" title="insert类"></a>insert类</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afa8857a9e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>只需要记录插入id即可，回滚时根据id删除。</p><h4 id="delete类"><a href="#delete类" class="headerlink" title="delete类"></a>delete类</h4><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afcafda5bf_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>在对一条记录进行<code>delete mark</code>操作前，需要把该记录的旧的<code>trx_id</code>和<code>roll_pointer</code>隐藏列的值都给记到对应的<code>undo日志</code>中来，形成版本链：</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afef7f83bf_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afd18e701d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>额外记录<strong>删除时记录各列数据</strong>和<strong>索引各列信息</strong>。</li></ul><p><em>删除页的过程：</em><br>1）将记录的<code>delete_mask</code>标识为改为1<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afc12f5533_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>2）删除事务提交后，有专门线程来将delete标识位为1的记录回收<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875afc377e08f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h4 id="update类"><a href="#update类" class="headerlink" title="update类"></a>update类</h4><h5 id="不更新主键"><a href="#不更新主键" class="headerlink" title="不更新主键"></a>不更新主键</h5><ul><li>如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行<code>就地更新</code>。</li><li>否则，用户线程直接先删除记录（记录加入垃圾链表），然后插入新记录。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16b875b00a275e91_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h5 id="更新主键"><a href="#更新主键" class="headerlink" title="更新主键"></a>更新主键</h5><ul><li>将旧记录进行<code>delete mark</code>操作</li><li>创建新记录并插入</li></ul><blockquote><p>对应主键更新，可以delete mask，否则必须先硬删除记录再插入新记录。</p></blockquote><h2 id="undo页面"><a href="#undo页面" class="headerlink" title="undo页面"></a>undo页面</h2><p>FIL_PAGE_UNDO_LOG页面，该页面专门存储undo日志<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a7fd0d7f9fa_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16f3b5361c14d1b9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>TRX_UNDO_PAGE_TYPE</code>：本页面准备存储什么种类的<code>undo日志</code>。</li><li><code>TRX_UNDO_PAGE_START</code>：表示在当前页面第一条<code>undo日志</code>的起始偏移量。</li><li><code>TRX_UNDO_PAGE_FREE</code>：最后一条<code>undo</code>日志结束时的偏移量。</li><li><code>TRX_UNDO_PAGE_NODE</code>：代表一个<code>List Node</code>结构，连接前后的Undo页面（就像INODE页面一样）。</li></ul><h3 id="Undo页面链表"><a href="#Undo页面链表" class="headerlink" title="Undo页面链表"></a>Undo页面链表</h3><p>通过<code>TRX_UNDO_PAGE_NODE</code>形成链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a8074556f5d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>一个undo页只记录一种类型的undo日志，不同类型的undo页形成链表：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a808197ad5b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>针对普通表和临时表，又分别形成两组Undo日志。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80840261ec_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>这些链表是按需分配的。</p></blockquote><p>undo链表是属于事务的：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80bf9229a6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>每个事务分两组（普通&#x2F;临时），每组有两条链表（update&#x2F;insert），每个链表由若干该类型的undo页面连接构成。</p>          </div><h2 id="undo日志具体写入过程"><a href="#undo日志具体写入过程" class="headerlink" title="undo日志具体写入过程"></a>undo日志具体写入过程</h2><h3 id="undo-log-segment-header"><a href="#undo-log-segment-header" class="headerlink" title="undo log segment header"></a>undo log segment header</h3><p>每一个<code>Undo</code>链表都对应着一个<code>段</code>，称之为<code>Undo Log Segment</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80e0dadcce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>对于数据页，每个索引分两个段（叶子段&#x2F;非叶子段），每个段有若干页面。<br>对于undo页，每个链表就是一个段。</p></blockquote><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80e753a16e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>TRX_UNDO_STATE</code>：本<code>Undo</code>链表处在什么状态。<ul><li><code>TRX_UNDO_ACTIVE</code>：活跃状态，也就是一个活跃的事务正在往这个段里边写入<code>undo日志</code>。</li><li><code>TRX_UNDO_CACHED</code>：被缓存的状态，等待被重用</li><li><code>TRX_UNDO_TO_FREE</code>：<code>insert undo</code>链表不能被重用</li><li><code>TRX_UNDO_TO_PURGE</code>：<code>update undo</code>链表不能被重用</li><li>处于<code>PREPARE</code>阶段的事务产生的<code>undo日志</code>。</li></ul></li><li><code>TRX_UNDO_LAST_LOG</code>：本<code>Undo页面</code>链表中最后一个<code>Undo Log Header</code>的位置。</li><li><code>TRX_UNDO_FSEG_HEADER</code>：本<code>Undo页面</code>链表对应的段的<code>Segment Header</code>信息</li><li><code>TRX_UNDO_PAGE_LIST</code>：<code>Undo页面</code>链表的基节点。</li></ul><blockquote><ul><li><code>undo page header</code> 主要记录本页的指针信息</li><li><code>undo log segment</code> 主要记录本undo log页链表的信息，便于快速搜索。</li><li><code>Segment Header</code> 可以用来快速定位本段的INODE Entry（INODE Entry用来管理一个段中各页面的链表）。</li></ul></blockquote><h3 id="undo-log-header"><a href="#undo-log-header" class="headerlink" title="undo log header"></a>undo log header</h3><p>定义：同一个事务向一个<code>Undo页面</code>链表中写入的<code>undo日志</code>算是一个组，在undo log header记录这些组信息。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f1d5b422_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>链表的第一个页面，会填充<code>Undo Page Header</code>、<code>Undo Log Segment Header</code>、<code>Undo Log Header</code>这3个部分，之后才开始正式写入<code>undo日志</code>。</li><li>对于其他的页面只会填充<code>Undo Page Header</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f3cc070f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>如前面总结，一个事务会持有多个undo log页面链表，在第一个链表中放入：</p><ul><li>undo log segment header：记录本链表的状态（写入中？），并定位到INODE Entry，便于页面管理。</li><li>undo log header：记录本链表与事务相关的记录。</li></ul>          </div><h2 id="重用Undo页面"><a href="#重用Undo页面" class="headerlink" title="重用Undo页面"></a>重用Undo页面</h2><p><code>Undo页面</code>链表是否可以被重用的条件很简单：</p><ul><li>该链表中只包含一个<code>Undo页面</code>。</li><li>该<code>Undo页面</code>已经使用的空间小于整个页面空间的3&#x2F;4：<ul><li><code>insert undo</code>链表可立刻删除。</li><li><code>update undo</code>链表不能立刻删除。</li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a80f3f150f4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a81007cdf9f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h2><h3 id="Rollback-Segment-Header页面"><a href="#Rollback-Segment-Header页面" class="headerlink" title="Rollback Segment Header页面"></a>Rollback Segment Header页面</h3><p>在这个页面中存放了各个<code>Undo页面</code>链表的<code>frist undo page</code>的<code>页号</code>，他们把这些<code>页号</code>称之为<code>undo slot</code>。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a810434772a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>每个链表的头部记录了链表的状态信息和事务信息<br>这个页面中通过引用各个链表头部对链表进行统一的管理，方便复用：</p><ul><li>事务从回滚段中申请Undo链表。</li><li>事务提交后，符合重用条件的可复用，不可重用的根据类型区分：</li><li>insert类型可释放</li><li>update类型需要放入history链表中。</li></ul></blockquote><h3 id="多个回滚段"><a href="#多个回滚段" class="headerlink" title="多个回滚段"></a>多个回滚段</h3><p>InnoDB中有127个回滚段，一个回滚段管理1024个undo链表。<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a24a8116df4474_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="回滚段的分类"><a href="#回滚段的分类" class="headerlink" title="回滚段的分类"></a>回滚段的分类</h3><ul><li>普通表回滚段</li><li>临时表回滚段</li></ul><blockquote><p>划分原因：在修改针对普通表的回滚段中的Undo页面时，需要记录对应的redo日志，而修改针对临时表的回滚段中的Undo页面时，不需要记录对应的redo日志。</p></blockquote><h3 id="回滚段相关配置"><a href="#回滚段相关配置" class="headerlink" title="回滚段相关配置"></a>回滚段相关配置</h3><ul><li>配置回滚段数量：启动参数<code>innodb_rollback_segments</code></li><li>通过<code>innodb_undo_directory</code>指定<code>undo表空间</code>所在的目录</li><li>通过<code>innodb_undo_tablespaces</code>定义<code>undo表空间</code>的数量</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>一个事务对应多个mtr，一个mtr对应多个undo日志</li><li>undo日志存在undo页中，undo页分update和insert类。</li><li>一个undo页不够记录一个事务的所有操作，所以要形成链表。每个事务持有2部分链表（普通&#x2F;临时），1部分链表包括2条链表（update&#x2F;insert）链表。（insert类型的undo页面在事务提交后就可以释放，update则不可以，这是处于版本链管理的需要）</li><li>一个链表就是一个undo页面段，其也有一个INODE结构来管理这个段中各个页面?</li><li>回滚段页面有各个链表头，实现对链表的管理。</li></ul><h1 id="五、事务隔离级别和MVCC"><a href="#五、事务隔离级别和MVCC" class="headerlink" title="五、事务隔离级别和MVCC"></a>五、事务隔离级别和MVCC</h1><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr><td>SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><h3 id="MySQL中支持的隔离级别"><a href="#MySQL中支持的隔离级别" class="headerlink" title="MySQL中支持的隔离级别"></a>MySQL中支持的隔离级别</h3><p>MySQL支持4种隔离级别。MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的。</p><h3 id="设置事务的隔离级别"><a href="#设置事务的隔离级别" class="headerlink" title="设置事务的隔离级别"></a>设置事务的隔离级别</h3><p><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level</code>；</p><h2 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/b6c72ab37d5a42b9a431d737f3c3b5ee_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>注意insert操作提交后对应的undo日志就没用了。</p></blockquote><p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a33e277a98dbec_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说：<br>必须保证可以读到已经提交了的事务修改过的记录。（未提交则不可见）</p><p>事务为了保证这种一致性，会在创建时，生成一个<code>ReadView</code>对象。</p><ul><li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的<code>事务id</code>列表。</li><li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</li><li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。</li><li><code>creator_trx_id</code>：表示生成该<code>ReadView</code>的事务的<code>事务id</code>。</li></ul><p>这样事务可以根据被访问版本的trx_id值判断：</p><ul><li>小于min_trx_id，说明trx_id事务已经被提交，可访问</li><li>大于max_trx_id，说明trx_id事务在本事务开启后开启的，不可访问</li><li>等于creator_trx_id，说明是本事务进行的修改，可访问</li><li>min与max之间，判断trx_id是否在m_ids中，在则说明开启本事务时trx_id事务未提交，不可访问，否则说明trx_id事务已经提交，可访问。</li></ul><h2 id="不同隔离级别的策略"><a href="#不同隔离级别的策略" class="headerlink" title="不同隔离级别的策略"></a>不同隔离级别的策略</h2><ul><li>READ COMMITTED —— 每次读取数据前都生成一个ReadView</li><li>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</li></ul><h1 id="六、锁"><a href="#六、锁" class="headerlink" title="六、锁"></a>六、锁</h1><h2 id="锁概念"><a href="#锁概念" class="headerlink" title="锁概念"></a>锁概念</h2><p><code>锁</code>其实是一个内存中的结构：<br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a680105d9425c2_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting</code>：代表当前事务是否在等待。</li></ul><blockquote><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别实际上就已经解决了<code>幻读</code>问题。</p></blockquote><p><em>如何实现多隔离级别？</em></p><ul><li>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</li><li>方案二：读、写操作都采用<code>加锁</code>的方式。</li></ul><h2 id="不同SQL操作对应的锁"><a href="#不同SQL操作对应的锁" class="headerlink" title="不同SQL操作对应的锁"></a>不同SQL操作对应的锁</h2><ul><li>一致性读：也叫<code>快照读</code>，不加锁：<code>SELECT ...</code></li><li>锁定读：<ul><li>共享锁（S锁）：<code>SELECT ... LOCK IN SHARE MODE;</code></li><li>排他锁（X锁）：<code>SELECT ... FOR UPDATE;</code></li></ul></li></ul><table><thead><tr><th>兼容性</th><th>X</th><th>S</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S</td><td>不兼容</td><td>兼容</td></tr></tbody></table><ul><li>写操作：<ul><li>DELETE：X锁</li><li>UPDATE：<ul><li>原地更新字段时（长度无变化）：X锁</li><li>删除新增字段时（长度有变化）：先后执行<code>DELETE</code>和<code>INSERT</code>。</li><li>更新主键时：先后执行<code>DELETE</code>和<code>INSERT</code>。</li></ul></li><li>INSERT：不加锁，但使用隐式锁保证新增记录在提交前无法被访问。</li></ul></li></ul><h2 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h2><p>锁影响的范围称为锁的粒度，常见的有行级锁和表级锁。</p><p>意向锁：</p><ul><li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li><li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li></ul><p>意向锁：想加<strong>表锁</strong>的事务可以通过查看本表有没有意向锁判断是否有其他事务已经加了<strong>行锁</strong>。</p><p>IS锁和IX锁是兼容的：表示有事务在对表进行读、写（不是同一行）。</p><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h2 id="MySQL中的行锁和表锁"><a href="#MySQL中的行锁和表锁" class="headerlink" title="MySQL中的行锁和表锁"></a>MySQL中的行锁和表锁</h2><h3 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h3><p>对于<code>MyISAM</code>、<code>MEMORY</code>、<code>MERGE</code>这些存储引擎来说，它们只支持表级锁，也不支持事务。</p><h3 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h3><h4 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h4><p><code>InnoDB</code>存储引擎既支持表锁，也支持行锁：</p><ul><li>表级别的<code>S锁</code>、<code>X锁</code></li><li>表级别的<code>IS锁</code>、<code>IX锁</code></li><li>表级别的<code>AUTO-INC锁</code>：插入时上AUTO-INC锁，插入完成就释放</li></ul><h4 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h4><ul><li><code>Record Locks</code>：分S、X</li><li><code>Gap Locks</code>：解决了幻读问题，加锁后其他事务无法在锁记录前面插入新记录，通过将锁放置在页面的最大记录上，其他事务就不能插入新记录了。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a5ddeea09f4b64_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd4244481b96_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>Next-Key Locks</code>：相当于<code>Record Locks+Gap Locks</code>。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd42446ce8b5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li><code>Insert Intention Locks</code>：插入意向锁，事务在插入时被gap锁或者next-key lock阻塞，则生成一个<code>Insert Intention Locks</code>锁，主要起唤醒作用。</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a6dd424353495e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a72bf8133eb1dc_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>隐式锁：如果某事务插入记录时，另一个事务要读取这个记录，会产生冲突（因为此时初始化未完成）。<ul><li>对于聚簇索引，另一个事务发现trx_id处于活跃状态时，会为插入事务创建一个X锁，并为自己创建一个X锁，形成等待。</li><li>对于二级索引，通过Page Header中的<code>PAGE_MAX_TRX_ID</code>属性判断该页面的记录是否都是已提交状态（与当前活跃事务的最小id对比）。</li></ul></li></ul><h2 id="InnoDB锁结构"><a href="#InnoDB锁结构" class="headerlink" title="InnoDB锁结构"></a>InnoDB锁结构</h2><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a68cda54348429_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>事务信息：事务的指针</li><li>索引信息：加锁记录所属的索引</li><li>表锁／行锁信息：<ul><li>标记锁了哪个表：SpaceID</li><li>哪个表哪行记录：SpaceID,PageNumber,n_bits(一个数量，以便后面通过bit位标记页内哪些行加了锁)</li></ul></li><li>type_mode：这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：<ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<ul><li><code>LOCK_IS</code>（十进制的<code>0</code>）：表示共享意向锁，也就是<code>IS锁</code>。</li><li><code>LOCK_IX</code>（十进制的<code>1</code>）：表示独占意向锁，也就是<code>IX锁</code>。</li><li><code>LOCK_S</code>（十进制的<code>2</code>）：表示共享锁，也就是<code>S锁</code>。</li><li><code>LOCK_X</code>（十进制的<code>3</code>）：表示独占锁，也就是<code>X锁</code>。</li><li><code>LOCK_AUTO_INC</code>（十进制的<code>4</code>）：表示<code>AUTO-INC锁</code>。</li></ul></li><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<ul><li><code>LOCK_TABLE</code>（十进制的<code>16</code>），也就是当第5个比特位置为1时，表示表级锁。</li><li><code>LOCK_REC</code>（十进制的<code>32</code>），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在<code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<ul><li><code>LOCK_ORDINARY</code>（十进制的<code>0</code>）：表示<code>next-key锁</code>。</li><li><code>LOCK_GAP</code>（十进制的<code>512</code>）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。</li><li><code>LOCK_REC_NOT_GAP</code>（十进制的<code>1024</code>）：也就是当第11个比特位置为1时，表示<code>正经记录锁</code>。</li><li><code>LOCK_INSERT_INTENTION</code>（十进制的<code>2048</code>）：也就是当第12个比特位置为1时，表示插入意向锁。</li><li><code>LOCK_WAIT</code>（十进制的<code>256</code>） ：也就是当第9个比特位置为<code>1</code>时，表示<code>is_waiting</code>为<code>true</code>，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为<code>0</code>时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul></li></ul></li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a864f3298df751_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>其他信息：为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</li><li>一堆比特位：数量由行锁信息的<code>n_bits</code>属性决定，每bit与页内记录的heap_no对应</li></ul><p><img src="/2023/02/12/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%86%85%E5%AD%98%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/16a69c2f7b413698_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（查询与优化）</title>
    <link href="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <url>/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单表访问"><a href="#一、单表访问" class="headerlink" title="一、单表访问"></a>一、单表访问</h1><h2 id="访问方法（access-method）"><a href="#访问方法（access-method）" class="headerlink" title="访问方法（access method）"></a>访问方法（access method）</h2><p>Mysql中查询的执行方式大致分两种：</p><ul><li>使用全表扫描进行查询</li><li>使用索引进行查询（使用xx索引的xx查询）</li></ul><p>访问方法分类：</p><ul><li>all：全表</li><li>const：主键 &#x3D; 常数</li><li>ref：二级索引 &#x3D; 常数</li><li>ref_or_null：二级索引 &#x3D; 常数 或 二级索引 &#x3D; null</li><li>range：利用索引进行范围查询</li><li>index：不用回表的二级索引搜索</li><li>index merge：使用到多个索引来完成一次查询</li></ul><h3 id="range优化"><a href="#range优化" class="headerlink" title="range优化"></a>range优化</h3><ul><li>多range合并</li><li>对于<code>range and 其他条件</code>，先根据range确定范围（将其他搜索条件替换为true，之后在筛选)。</li></ul><h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index merge"></a>index merge</h3><ul><li>Intersection合并，分别使用索引确定备选，然后取交集，出现以下情况才<strong>可能</strong>这样执行：<ul><li>情况一：二级索引列是等值匹配的情况。</li><li>情况二：主键列可以是范围匹配</li></ul></li><li>Union合并，分别使用索引确定备选，然后取并集，出现以下情况才<strong>可能</strong>这样执行：<ul><li>情况一：二级索引列是等值匹配的情况</li><li>情况二：主键列可以是范围匹配</li><li>情况三：与<code>Intersection的筛选结果</code>取并集</li></ul></li><li>Sort-Union合并，两个二级索引搜索结果先按照主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并。</li></ul><blockquote><p>注意：往往应该使用联合索引替代Intersection索引合并，即一个索引完成了两个列的范围搜索。</p></blockquote><h1 id="二、连接的原理"><a href="#二、连接的原理" class="headerlink" title="二、连接的原理"></a>二、连接的原理</h1><h2 id="连接本质"><a href="#连接本质" class="headerlink" title="连接本质"></a>连接本质</h2><p><code>连接</code>的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户，如下，这样的结果集称为<code>笛卡尔积</code>。<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3feccc29_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><p><em>驱动表</em><br>第一个需要查询的表，这个表称之为<code>驱动表</code>。<br><em>被驱动表</em><br>使用<code>驱动表</code>中的搜索结果，每条记录都对<code>被驱动表</code>进行一次搜索，过滤得到满足连接的结果。</p><p><em>eg:</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1, t2 <span class="hljs-keyword">WHERE</span> t1.m1 <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> t1.m1 <span class="hljs-operator">=</span> t2.m2 <span class="hljs-keyword">AND</span> t2.n2 <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;d&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3a02660b_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>两表连接查询中，驱动表只需要访问一次，被驱动表可能被访问多次。</p></blockquote><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><ul><li>对于<code>内连接</code>的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录<strong>不会</strong>加入到最后的结果集。</li><li>对于<code>外连接</code>的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也<strong>仍然会</strong>加入到结果集。在<code>MySQL</code>中，根据选取驱动表的不同，外连接仍然可以细分为2种：<ul><li>左外连接：选取左侧的表为驱动表。</li><li>右外连接：选取右侧的表为驱动表。</li></ul></li></ul><h2 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h2><p>通用的两表连接过程如下图所示：<br><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3fa0f107_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>如果有3个表进行连接的话，那么<code>步骤2</code>中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上面过程。</p><blockquote><p>这是最简单和笨拙的连接查询算法。</p></blockquote><h3 id="使用索引加快连接速度"><a href="#使用索引加快连接速度" class="headerlink" title="使用索引加快连接速度"></a>使用索引加快连接速度</h3><p>加速连接查询主要是要加速被驱动表的查询。</p><ul><li>参考单表查询中索引的使用，建立合适的所以避免对被驱动表全表扫描。</li><li>为了避免被驱动表反复被加载到内存中，使用join buffer：<ul><li>执行连接查询前申请一块固定大小的内存，先把若干条<strong>驱动表结果集</strong>中的记录装在这个<code>join buffer</code>中</li><li>然后开始扫描被驱动表，每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表记录做匹配</li></ul></li></ul><p><img src="/2023/02/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%89/167e43ab3e5fa2f6_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>加入了<code>join buffer</code>的嵌套循环连接算法称之为<code>基于块的嵌套连接</code>（Block Nested-Loop Join）算法。</p><blockquote><p>驱动表的记录并不是所有列都会被放到<code>join buffer</code>中，只有查询列表中的列和过滤条件中的列才会被放到<code>join buffer</code>。</p></blockquote><h1 id="三、查询成本优化"><a href="#三、查询成本优化" class="headerlink" title="三、查询成本优化"></a>三、查询成本优化</h1><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><p><code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p><ul><li><code>I/O</code>成本</li><li><code>CPU</code>成本</li></ul><p><em>成本常数</em></p><ul><li>读取一个页面花费的成本默认是<code>1.0</code>。</li><li>读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。</li></ul><h2 id="单表查询的成本"><a href="#单表查询的成本" class="headerlink" title="单表查询的成本"></a>单表查询的成本</h2><p>过程总结一下就是这样：</p><ol><li>根据搜索条件，找出所有可能使用的索引</li><li>计算全表扫描的代价</li><li>计算使用不同索引（包括是否能使用联合索引）执行查询的代价</li><li>对比各种执行方案的代价，找出成本最低的那一个</li></ol><h3 id="全表扫描成本计算"><a href="#全表扫描成本计算" class="headerlink" title="全表扫描成本计算"></a>全表扫描成本计算</h3><p>由于查询成本&#x3D;<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p><ul><li>聚簇索引占用的页面数</li><li>该表中的记录数</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>I/O成本<br>聚簇索引页数 * <span class="hljs-number">1.0</span> + <span class="hljs-number">1.1</span><br><span class="hljs-regexp">//</span>CPU成本<br>rows * <span class="hljs-number">0.2</span> + <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><h3 id="索引查询成本的代价"><a href="#索引查询成本的代价" class="headerlink" title="索引查询成本的代价"></a>索引查询成本的代价</h3><blockquote><p>范围搜索：</p><ul><li>查询优化器粗暴的认为读取索引的<strong>一个范围区间</strong>的<code>I/O</code>成本和读取一个页面是相同的。</li><li>对于范围搜索如<code>IN</code>，会预估rows：</li><li>先获取<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，在统计两者之间的记录数量（<code>index dive</code>）</li><li>IN中参数过多（多于200）时，会使用基数估算索引。</li></ul></blockquote><p><em>使用索引处理对于range类型的查询条件</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>I/O成本<br><span class="hljs-regexp">//</span>根据索引搜索一个范围<br><span class="hljs-number">1.0</span><br><span class="hljs-regexp">//</span>回表<br>rows * <span class="hljs-number">1.0</span><br><br><span class="hljs-regexp">//</span>CPU成本<br><span class="hljs-regexp">//</span>读取二级索引<br>rows * <span class="hljs-number">0.2</span> + <span class="hljs-number">0.01</span><br><span class="hljs-regexp">//</span>读取聚簇索引<br>rows * <span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><h2 id="连接查询的成本"><a href="#连接查询的成本" class="headerlink" title="连接查询的成本"></a>连接查询的成本</h2><p>查询成本由下边两个部分构成：</p><ul><li>单次查询驱动表的成本</li><li>多次查询被驱动表的成本</li></ul><p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code><br>两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p><ul><li>全表扫描时，猜满足搜索条件的记录到底有多少条。</li><li>索引扫描，猜满足除索引搜索条件外的其他搜索条件的记录有多少条。</li></ul><h3 id="两表连接的成本分析"><a href="#两表连接的成本分析" class="headerlink" title="两表连接的成本分析"></a>两表连接的成本分析</h3><p>内连接时，分析不同驱动表的情形，重点优化查询被驱动表的成本。</p><h3 id="多表连接的成本分析"><a href="#多表连接的成本分析" class="headerlink" title="多表连接的成本分析"></a>多表连接的成本分析</h3><p>多表时，可能的搜索策略过多，MySQL有以下方法减少计算连接顺序的成本：</p><ul><li>提前结束某种顺序的成本评估：如果某次计算已经大于其他执行方式的成本，提前结束。</li><li>系统变量<code>optimizer_search_depth</code>：连接表大于该值时，只对该值数量的表进行穷举分析。</li><li>根据某些规则不考虑某些连接顺序：<code>启发式规则</code>，就是使用经验。</li></ul><h2 id="调节成本常数"><a href="#调节成本常数" class="headerlink" title="调节成本常数"></a>调节成本常数</h2><ul><li>读取一个页面花费的成本默认是<code>1.0</code></li><li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li></ul><p>成本常数被存在mysql数据库中的server_cost表和engine_cost表中。</p><h1 id="四、统计数据的收集"><a href="#四、统计数据的收集" class="headerlink" title="四、统计数据的收集"></a>四、统计数据的收集</h1><h2 id="两种的统计数据存储方式"><a href="#两种的统计数据存储方式" class="headerlink" title="两种的统计数据存储方式"></a>两种的统计数据存储方式</h2><ul><li>永久性的统计数据：存硬盘</li><li>非永久性的统计数据：存内存</li></ul><p><code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，通过修改表可调整策略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名 (...) Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>); <br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 Engine<span class="hljs-operator">=</span>InnoDB, STATS_PERSISTENT <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">|</span><span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="基于磁盘的永久性统计数据"><a href="#基于磁盘的永久性统计数据" class="headerlink" title="基于磁盘的永久性统计数据"></a>基于磁盘的永久性统计数据</h3><p>统计数据存储到了两个表里，都位于<code>mysql</code>系统数据库，其中：</p><ul><li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li><li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li></ul><h4 id="innodb-table-stats"><a href="#innodb-table-stats" class="headerlink" title="innodb_table_stats"></a>innodb_table_stats</h4><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>database_name</td><td>数据库名</td></tr><tr><td>table_name</td><td>表名</td></tr><tr><td>last_update</td><td>本条记录最后更新时间</td></tr><tr><td>n_rows</td><td>表中记录的条数</td></tr><tr><td>clustered_index_size</td><td>表的聚簇索引占用的页面数量</td></tr><tr><td>sum_of_other_index_sizes</td><td>表的其他索引占用的页面数量</td></tr></tbody></table><blockquote><p>n_rows是估计值</p></blockquote><h4 id="innodb-index-stats"><a href="#innodb-index-stats" class="headerlink" title="innodb_index_stats"></a>innodb_index_stats</h4><table><thead><tr><th>字段名</th><th>描述</th></tr></thead><tbody><tr><td>database_name</td><td>数据库名</td></tr><tr><td>table_name</td><td>表名</td></tr><tr><td>index_name</td><td>索引名</td></tr><tr><td>last_update</td><td>本条记录最后更新时间</td></tr><tr><td>stat_name</td><td>统计项的名称</td></tr><tr><td>stat_value</td><td>对应的统计项的值</td></tr><tr><td>sample_size</td><td>为生成统计数据而采样的页面数量</td></tr><tr><td>stat_description</td><td>对应的统计项的描述</td></tr></tbody></table><h4 id="定期更新统计数据"><a href="#定期更新统计数据" class="headerlink" title="定期更新统计数据"></a>定期更新统计数据</h4><ul><li><code>innodb_stats_auto_recalc</code>：系统变量。默认为开启状态，当发送变动的记录超过表大小的10%，即重新计算。</li><li><code>ANALYZE TABLE</code>：手动调用命令，重新计算。</li></ul><h3 id="基于内存的非永久性统计数据"><a href="#基于内存的非永久性统计数据" class="headerlink" title="基于内存的非永久性统计数据"></a>基于内存的非永久性统计数据</h3><p>非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p><h4 id="innodb-stats-method"><a href="#innodb-stats-method" class="headerlink" title="innodb_stats_method"></a>innodb_stats_method</h4><p>是一个系统变量，设置对于<code>允许NULL的索引列</code>的基数计算策略：</p><ul><li><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。</li><li><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</li><li><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</li></ul><h1 id="五、基于规则优化"><a href="#五、基于规则优化" class="headerlink" title="五、基于规则优化"></a>五、基于规则优化</h1><h2 id="条件化简"><a href="#条件化简" class="headerlink" title="条件化简"></a>条件化简</h2><ul><li>移除不必要的括号</li><li>常量传递</li><li>等值传递</li><li>移除没用的条件</li><li>表达式计算</li><li>HAVING子句和WHERE子句的合并：没有出现聚集函数时，合并HAVING子句和WHERE子句。</li><li>常量表检测：表中只有一条数据或使用主键等值匹配的子句，优先执行。</li><li>外连接消除：WHERE子句中指定<code>被驱动表</code>的 <code>连接列</code> 不为NULL，则变成了内连接。</li></ul><h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h2><h3 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h3><p><em>按查询结果分类</em></p><ul><li>标量子查询</li><li>行子查询</li><li>列子查询</li><li>表子查询</li></ul><p><em>按与外层查询关系分类</em></p><ul><li>不相关子查询：子查询可以独立运行</li><li>相关子查询：子查询的执行需要依赖于外层查询的值（一般表现为子查询中有带有外层表的条件）</li></ul><p><em>子查询语法注意事项</em></p><ul><li>子查询必须用小括号扩起来。</li><li>在<code>SELECT</code>子句中的子查询必须是标量子查询。</li><li>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。</li><li>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</li></ul><h3 id="子查询在MySQL中执行"><a href="#子查询在MySQL中执行" class="headerlink" title="子查询在MySQL中执行"></a>子查询在MySQL中执行</h3><p>原始子查询：先执行子查询，然后将结果作为外层参数。</p><h4 id="标量子查询、行子查询"><a href="#标量子查询、行子查询" class="headerlink" title="标量子查询、行子查询"></a>标量子查询、行子查询</h4><p>原始子查询。</p><h4 id="IN子查询优化（列子查询）"><a href="#IN子查询优化（列子查询）" class="headerlink" title="IN子查询优化（列子查询）"></a>IN子查询优化（列子查询）</h4><h5 id="物化表"><a href="#物化表" class="headerlink" title="物化表"></a>物化表</h5><p>将不相关子查询的结果集写入一个临时表（基于内存的使用<code>Memory</code>存储引擎，并且会自动去重，如果太大了就会转而使用磁盘和B+树存储），这个表叫做<strong>物化表</strong>。</p><p><em>物化表转连接</em><br>将物化表转化成内连接，提供了转换驱动表的可能。</p><h5 id="semi-join"><a href="#semi-join" class="headerlink" title="semi-join"></a>semi-join</h5><p>对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录。</p><blockquote><p>内连接时，驱动表的每行都要在被驱动表中匹配（被驱动表中可能有多条匹配的行），但IN子句查询，只需要判断被驱动表中有匹配的行即可。</p></blockquote><p>实现方式：</p><ul><li>Table pullout （子查询中的表上拉）：连接列是被驱动表的唯一索引时，连接；</li><li>DuplicateWeedout execution strategy （重复值消除）：临时表去重；</li><li>LooseScan execution strategy （松散扫描）：子查询做驱动表，使用其结果扫描主表的各行结果是否满足条件；</li><li>Semi-join Materialization execution strategy：物化；</li><li>FirstMatch execution strategy （首次匹配）：原始查询。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>满足转换为<code>semi-join</code>的条件时，查询优化器会优先把该子查询转换为<code>semi-join</code>，然后再考虑下边5种执行半连接的策略中哪个成本最低。</li><li>不满足转换<code>semi-join</code>的条件时，查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：<ul><li><p>先将子查询物化之后再执行查询</p></li><li><p>执行<code>IN to EXISTS</code>转换，转化后可能可以使用索引。</p><p>  任意一个IN子查询都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">outer_expr <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where)<br><span class="hljs-comment">--可转化为：</span><br><span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> inner_expr <span class="hljs-keyword">FROM</span> ... <span class="hljs-keyword">WHERE</span> subquery_where <span class="hljs-keyword">AND</span> outer_expr<span class="hljs-operator">=</span>inner_expr)<br></code></pre></td></tr></table></figure><h4 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY&#x2F;ALL子查询优化"></a>ANY&#x2F;ALL子查询优化</h4><table><thead><tr><th>原始表达式</th><th>转换为</th></tr></thead><tbody><tr><td>&lt; ANY (SELECT inner_expr …)</td><td>&lt; (SELECT MAX(inner_expr) …)</td></tr><tr><td>&gt; ANY (SELECT inner_expr …)</td><td>&gt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&lt; ALL (SELECT inner_expr …)</td><td>&lt; (SELECT MIN(inner_expr) …)</td></tr><tr><td>&gt; ALL (SELECT inner_expr …)</td><td>&gt; (SELECT MAX(inner_expr) …)</td></tr></tbody></table><h4 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h4><ul><li>对于不相关子查询，查出来true&#x2F;false然后重写原语句</li><li>对于相关子查询，只能使用原始子查询</li></ul><h4 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h4><p>子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code></p><div class="note note-primary">            <p>列子查询结果叫<strong>物化表</strong><br>表子查询结果叫<strong>派生表</strong></p>          </div><h1 id="六、Explain"><a href="#六、Explain" class="headerlink" title="六、Explain"></a>六、Explain</h1><p><code>EXPLAIN</code>是一个语句，能帮助我们查看查询语句的执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>输出结果的各列：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><ul><li>id，查询语句中每出现一个<code>SELECT</code>关键字，设计<code>MySQL</code>的大叔就会为它分配一个唯一的<code>id</code>值。<ul><li>若被转化为连接则与驱动表查询SELECT的id相同。</li><li>若创建了临时表，则临时表的id为null。</li></ul></li><li>select_type：<ul><li>SIMPLE：独立查询</li><li>PRIMARY：驱动表查询</li><li>UNION：被驱动表查询</li></ul></li><li>type：访问方法，如const,ref</li><li>filtered：估算满足驱动表查询条件的结果占比，用于估计扇出</li><li>Extra：一些可并列的额外信息</li></ul><h2 id="JSON格式的执行计划"><a href="#JSON格式的执行计划" class="headerlink" title="JSON格式的执行计划"></a>JSON格式的执行计划</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN FORMAT<span class="hljs-operator">=</span>JSON <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br></code></pre></td></tr></table></figure><p>输出json形式的查询语句执行策略，包括成本计算过程。</p><h2 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h2><p><code>optimizer trace</code>是一个系统变量，开启后可以到<code>information_schema</code>数据库下的<code>OPTIMIZER_TRACE</code>表中查看完整的优化过程。</p><p>优化过程大致分为了三个阶段：</p><ul><li><code>prepare</code>阶段</li><li><code>optimize</code>阶段（优化主要在这个阶段）</li><li><code>execute</code>阶段</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（InnoDB数据存储）</title>
    <link href="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/"/>
    <url>/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、InnoDB记录"><a href="#一、InnoDB记录" class="headerlink" title="一、InnoDB记录"></a>一、InnoDB记录</h1><h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>目前有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式<br>可以指定表的行格式：<code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></p><h2 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e8fafc21aa_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e8fe4ee6b0_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>按字段顺序，逆序存放各变长字段的长度（Null值除外）。<br>每个可变字段可能占1到2字节来表示长度。</p><p>前提：</p><ul><li>某个字符集中表示一个字符最多需要使用的字节数为<code>W</code></li><li>这种类型表示能存储最多<code>M</code>个字符，如VARCHAR(M)</li><li>它实际存储的字符串占用的字节数是<code>L</code></li></ul><p>策略：</p><ul><li>如果<code>M×W &lt;= 255</code>，使用1字节表示</li><li>如果<code>M×W &gt; 255</code>，则分为两种情况：<ul><li>如果<code>L &lt;= 127</code>，则用1个字节来表示真正字符串占用的字节数。</li><li>如果<code>L &gt; 127</code>，则用2个字节来表示真正字符串占用的字节数。</li></ul></li></ul><blockquote><p>先判断<code>M*W</code>，然后通过判断第一个比特位是0或1即可知道是1字节存储还是2字节存储了。</p></blockquote><div class="note note-primary">            <p>尽量使用1字节来存储。<br>这个字段只记录变长字段如VARCHAR，长度固定的字段不用记录。<br>对于溢出数据，只保留只保留前<code>768</code>个字节和<code>20</code>个字节的溢出页面地址，所以2字节足够表达长度。</p>          </div><h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e944a8af0c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>对于允许存null的字段，逆序排列，使用比特记录，0表示非空，1表示为空。<br>但是NULL值列表整体长度必须用字节表示，即未使用的高位会补0。</p><h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e97718ef01_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在本页（记录堆）的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h3 id="真实数据"><a href="#真实数据" class="headerlink" title="真实数据"></a>真实数据</h3><h4 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h4><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><blockquote><ul><li>transaction_id表示最后操作的事务</li><li>roll_pointer指向版本日志</li></ul></blockquote><p>对于主键，用户自行实现了就不会创建隐藏列，否则InnoDB为其添加<code>row_id</code>。</p><h4 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h4><h5 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h5><p>字符串的长度可能因为编码不同而不同，对于CHAR(M)：</p><ul><li>当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表</li><li>而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</li></ul><h2 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h2><p>古老的行格式<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e99a69ba3d_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>特点是：</p><ul><li>通过<strong>偏移（相对偏移）</strong> 替代<strong>变长字段长度</strong>保存各字段记录结束处的长度。</li><li>对于溢出页，使用2字节存储地址即可。</li><li>使用字段偏移量的第一个Bit作为是否为Null的判断方法。</li><li>对于CHAR(M)，给出最大的空间，不会产生碎片</li></ul></blockquote><h2 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h2><h3 id="行数据上限"><a href="#行数据上限" class="headerlink" title="行数据上限"></a>行数据上限</h3><p>除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过<code>65535</code>个字节。（<code>4*16KB</code>，即需要4个页存储）<br>所以，对于<code>VARCHAR(M)</code>类型的列最多可以占用<code>65535</code>个字节。</p><p>在<code>Compact</code>和<code>Redundant</code>行格式中，对于占用存储空间非常大的列，在<code>记录的真实数据</code>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<code>记录的真实数据</code>处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页，如图所示：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/169710e9aab47ea5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h3><p><code>MySQL</code>中规定一个页中至少存放两行记录！所以当某列占用字节过多时就会溢出。</p><blockquote><p>如果一个页只放一个页面，B+树的目录层级会非常高！</p></blockquote><h2 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h2><p><code>5.7</code>版本的MYSQL默认行格式是<code>Dynamic</code>，只不过在处理<code>行溢出</code>数据时不一样，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9b2c2b71e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image_1conbtnmr1sg1hao1nf41pi1eb72a.png-29.9kB"></p><h1 id="二、InnoDB数据页结构"><a href="#二、InnoDB数据页结构" class="headerlink" title="二、InnoDB数据页结构"></a>二、InnoDB数据页结构</h1><p>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>，也可以叫<code>索引页</code>。</p><h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16f13ee1e2dfac7c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26字节</td><td>两个虚拟的行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中的某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p>其中，<strong>FileHeader</strong>和<strong>FileTrailer</strong>是所有页的通用部分。</p><h2 id="文件头部（File-Header）"><a href="#文件头部（File-Header）" class="headerlink" title="文件头部（File Header）"></a>文件头部（File Header）</h2><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4字节</td><td>页的校验和（checksum值）</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页属于哪个表空间</td></tr><tr><td><code>FIL_PAGE_PREV</code>和<code>FIL_PAGE_NEXT</code>，分别代表上一个页和下一个页之间的页号：</td><td></td><td></td></tr><tr><td><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c10eb9d61ce_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></td><td></td><td></td></tr></tbody></table><blockquote><p>不是所有的页都有<code>File Header</code>属性。</p></blockquote><h2 id="文件尾部（File-Trailer）"><a href="#文件尾部（File-Trailer）" class="headerlink" title="文件尾部（File Trailer）"></a>文件尾部（File Trailer）</h2><p>这个部分由<code>8</code>个字节组成，可以分成2个小部分：<br>前4个字节代表页的校验和，后4个字节代表页面被最后修改时对应的日志序列位置（LSN）。</p><div class="note note-primary">            <p>文件首部和尾部都会记录校验和<code>checkSum</code>和最后日志序列位置<code>LSN</code>，如果某项校验不成功说明同步出现问题。</p>          </div><h2 id="页头（Page-Header）"><a href="#页头（Page-Header）" class="headerlink" title="页头（Page Header）"></a>页头（Page Header）</h2><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，该值仅在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><p>用来存储一个数据页的基本信息。</p><h2 id="用户信息（User-Record）"><a href="#用户信息（User-Record）" class="headerlink" title="用户信息（User Record）"></a>用户信息（User Record）</h2><p>介绍行格式时提到过，InnoDB记录中，每条记录都有一个记录头：</p><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td><strong>n_owned</strong></td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td><strong>heap_no</strong></td><td>13</td><td>表示当前记录在本页中的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示本页最小记录，3表示本页最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>去除预留位，剩余的部分如下：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c1084c440b4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>heap_no，表示当前记录在<strong>本页</strong>中的位置，0代表最小记录，1代表最大记录，所以某个页中这个记录从2开始。</li><li>最小记录和最大记录是哑节点，各自保存了一个字符串，且没有放在User Records部分。</li><li>n_owned：记录当前记录所在的组有多少条数据。</li><li>next_record:记录当前记录到下一天记录的地址偏移量。</li></ul><p><img src="/16a95c1084c440b4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0%201.webp"></p><blockquote><p>链表会随着删除而变化，但删除时只会改变标记delete_mask，然后将其放入一个垃圾链表中，当新插入记录时，可以复用垃圾链表中旧记录的空间。</p></blockquote><div class="note note-primary">            <p>记录会按照索引从小到大通过链表连接，但不一定在空间上连续。</p>          </div><h2 id="页目录（Page-Directory）"><a href="#页目录（Page-Directory）" class="headerlink" title="页目录（Page Directory）"></a>页目录（Page Directory）</h2><p>为了避免查看某个页记录时通过遍历来查看索引，将正常记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组，每个组的最后一条记录通过<code>n_owned</code>属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</p><p>将每个组的最后一条记录的地址偏移量单独提取出来<strong>按顺序存储</strong>到靠近<code>页</code>的尾部的地方，这个地方就是所谓的<code>Page Directory</code>。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a95c10f2e61ad5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>对于最小记录所在的分组只能有 <em><strong>1</strong></em> 条记录，最大记录所在的分组拥有的记录条数只能在 <em><strong>1~8</strong></em> 条之间，剩下的分组中记录的条数范围只能在是 <em><strong>4~8</strong></em> 条之间。</p><blockquote><p>初始情况下有两个分组，先填充最大记录所在分组，然后创建新分组。</p></blockquote><p><em>从数据页中找数据分两步：</em><br><strong>通过二分法确认记录所在的组，通过next_record遍历找到组内对应的记录。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做<code>数据页</code>。</li><li>一个数据页可以被大致划分为7个部分，见上文图中所示。</li><li>每个记录的头信息中都有一个<code>next_record</code>属性，从而使页中的所有记录串联成一个<code>单链表</code>。</li><li><code>InnoDB</code>会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<code>槽</code>，存放在<code>Page Directory</code>中，所以在一个页中根据主键查找记录是非常快的，分为两步：<ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ul></li><li>每个数据页的<code>File Header</code>部分都有上一个和下一个页的编号，所以所有的数据页会组成一个<code>双链表</code>。</li><li>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的<code>LSN</code>值，如果首部和尾部的校验和和<code>LSN</code>值校验不成功的话，就说明同步过程出现了问题。</li></ol><h1 id="三、B-树索引"><a href="#三、B-树索引" class="headerlink" title="三、B+树索引"></a>三、B+树索引</h1><h2 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h2><p>为了快速检索，将记录按索引顺序连接（同页或跨页），并为页其添加目录记录，和在页中将数据分组的思想类似。<br>目录记录一般叫做<code>目录项</code>，其中的两个列是<code>主键</code>和<code>页号</code>，其中主键记录的是某个页首个记录的id。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a01bd295fd42b5_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h3 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a01bd2a6c7a65f_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>满足以下条件的就是聚簇索引：</p><ul><li>聚簇索引使用记录主键值的大小进行记录和页的排序</li><li><code>B+</code>树的叶子节点存储的是完整的用户记录。</li></ul><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>满足以下条件的就是二级索引，也叫辅助索引：</p><ul><li>使用非主键做顺序进行记录和页的排序</li><li><code>B+</code>树的叶子节点存储的是二级索引和<strong>主键</strong></li></ul><p>通过二级索引查询时，若要找完整数据行数据则需要<strong>回表</strong>，即根据查到的ID再在聚簇索引中搜索一次。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>同时以多个列作为排序规则：</p><ul><li>同时以多个列作为排序规则，根据列出现的前后顺序，依次排序</li><li><code>B+</code>树的叶子节点存储的是联合索引和<strong>主键</strong></li></ul><h2 id="B-树变化过程"><a href="#B-树变化过程" class="headerlink" title="B+树变化过程"></a>B+树变化过程</h2><h3 id="B-树形成过程"><a href="#B-树形成过程" class="headerlink" title="B+树形成过程"></a>B+树形成过程</h3><ol><li>先在B+根节点上添加用户数据</li><li>根节点满后将记录复制到新页中，并对新页A进行分裂，得到新页A1和新页A2，新记录选择性的插入页A或页B，然后根节点升级成目录页。</li></ol><h3 id="二级索引B-树"><a href="#二级索引B-树" class="headerlink" title="二级索引B+树"></a>二级索引B+树</h3><p>二级索引B+树的主键不唯一，可能导致无法确定唯一的索引方向，所以<strong>二级索引的非叶子节点</strong>也会保存<strong>主键</strong>列，以便快速确定新记录位置。</p><h2 id="MyISAM中的索引方案"><a href="#MyISAM中的索引方案" class="headerlink" title="MyISAM中的索引方案"></a>MyISAM中的索引方案</h2><p><code>MyISAM</code>的索引方案虽然也使用树形结构，但是却将索引和数据分开存储。</p><ul><li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为<code>数据文件</code>。</li><li><code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。</li></ul><blockquote><p>所以MyISAM搜索记录至少要进行一次回表。</p></blockquote><h2 id="MySQL如何创建-x2F-删除索引"><a href="#MySQL如何创建-x2F-删除索引" class="headerlink" title="MySQL如何创建&#x2F;删除索引"></a>MySQL如何创建&#x2F;删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> TALBE 表名 (<br>    各种列的信息 ··· , <br>    [KEY<span class="hljs-operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)<br>)<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名 (需要被索引的单个列或多个列);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> [INDEX<span class="hljs-operator">|</span>KEY] 索引名;<br></code></pre></td></tr></table></figure><blockquote><p>KEY和INDEX是同义词。</p></blockquote><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><ul><li><p>空间上的代价：建立一个索引需要耗费空间</p></li><li><p>时间上的代价：update类操作需要同时更新多个索引</p></li><li><p>对于二级索引：获取id后还要回到聚簇索引中搜索，这个过程称为<strong>回表</strong>。（一次顺序IO，一次随机IO），查询优化器会衡量回表消耗选择合适的搜索方式。</p></li></ul><h3 id="匹配方式"><a href="#匹配方式" class="headerlink" title="匹配方式"></a>匹配方式</h3><p>InnoDB会为每个索引都会建立一个B+树。<br>可以使用索引的方式有：</p><ul><li>全值匹配：搜索条件为<code>索引 = 常量</code>。</li><li>匹配左边的列：搜索条件为 <code>联合索引中的第一个索引 = 常量</code>。</li><li>匹配列前缀：搜索条件为 <code>索引 like &#39;A%&#39;</code>(‘%A’则不行)</li><li>匹配范围：搜索条件为 <code>索引&gt;常量 and 索引&lt;常量</code></li><li>精确匹配某一列并范围匹配另外一列：搜索条件为 <code>联合索引中的第一个索引 = 常量</code> + <code>联合索引中的第二个索引 &gt; 常量</code></li><li>用于排序：搜索条件为<code>order by 索引</code><ul><li>不可以使用索引进行排序的几种情况：<ul><li>ASC、DESC混用</li><li>排序列包含非同一个索引的列</li><li>排序列使用了复杂的表达式</li></ul></li></ul></li><li>用于分组：搜索条件为<code>group by 索引</code></li></ul><h3 id="如何选择索引"><a href="#如何选择索引" class="headerlink" title="如何选择索引"></a>如何选择索引</h3><ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li></ul><h1 id="四、MySQL数据目录"><a href="#四、MySQL数据目录" class="headerlink" title="四、MySQL数据目录"></a>四、MySQL数据目录</h1><p><code>数据目录</code>是用来存储<code>MySQL</code>在运行过程中产生的数据的。</p><h2 id="数据目录的结构"><a href="#数据目录的结构" class="headerlink" title="数据目录的结构"></a>数据目录的结构</h2><h3 id="InnoDB文件系统"><a href="#InnoDB文件系统" class="headerlink" title="InnoDB文件系统"></a>InnoDB文件系统</h3><h4 id="库在文件系统中的表示"><a href="#库在文件系统中的表示" class="headerlink" title="库在文件系统中的表示"></a>库在文件系统中的表示</h4><ol><li>在<code>数据目录</code>下创建一个和数据库名同名的子目录（或者说是文件夹）。</li><li>在该与数据库名同名的子目录下创建一个名为<code>db.opt</code>的文件，其中有数据库的基本属性。</li></ol><h4 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h4><p><em>表结构</em><br><code>InnoDB</code>和<code>MyISAM</code>这两种存储引擎都在<code>数据目录</code>下对应的<strong>数据库子目录</strong>下创建了一个专门用于描述<strong>表结构</strong>的文件<code>表名.frm</code></p><p><em>表空间</em></p><ul><li>系统表空间：对应文件系统上一个或多个实际的文件，默认情况下，<code>InnoDB</code>会在<code>数据目录</code>下创建一个名为<code>ibdata1</code>，该文件是自扩展的。（<strong>在MYSQL5.5.7到MYSQL5.6.6之间，所有表数据都默认存放在系统表空间</strong>）</li><li>独立表空间：<strong>MYSQL5.6.6之后，InnoDB为每一个表建立一个独立表空间</strong>，文件名为<code>表名.ibd</code>。</li><li>其他类型的表空间：通用表空间，undo表空间等。</li></ul><blockquote><p>将用户数据存在在系统表空间还是独立表空间是可以配置的，但只对新表有用。旧的表只能转移。</p></blockquote><div class="note note-primary">            <p>表空间是一个抽象的概念，对应系统中一个或多个文件。</p>          </div><h4 id="视图在文件系统中的表示"><a href="#视图在文件系统中的表示" class="headerlink" title="视图在文件系统中的表示"></a>视图在文件系统中的表示</h4><p>对于视图，不需要存储真实的数据的，只需要把它的结构存储起来就行了，只存储一个<code>视图名.frm</code>文件。</p><h3 id="MyISAM文件系统"><a href="#MyISAM文件系统" class="headerlink" title="MyISAM文件系统"></a>MyISAM文件系统</h3><p>没有表空间，表数据都放在数据库的子目录下，如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">test.frm <span class="hljs-regexp">//</span>表结构<br>test.MYD <span class="hljs-regexp">//</span>数据<br>test.MYI <span class="hljs-regexp">//</span>索引<br></code></pre></td></tr></table></figure><h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><p><code>数据目录</code>下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：</p><ul><li>服务器进程文件。</li><li>服务器日志文件。</li><li>默认&#x2F;自动生成的SSL和RSA证书和密钥文件。</li></ul><h2 id="MYSQL系统数据库"><a href="#MYSQL系统数据库" class="headerlink" title="MYSQL系统数据库"></a>MYSQL系统数据库</h2><ul><li><code>mysql</code>：存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</li><li><code>information_schema</code>：这个数据库保存着MySQL服务器维护的所有<strong>其他数据库的信息</strong>，有时候也称之为元数据。</li><li><code>performance_schema</code>：这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，MySQL服务器的一个性能监控。</li><li><code>sys</code>： 这个数据库主要是通过视图的形式把<code>information_schema</code> 和<code>performance_schema</code>结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。</li></ul><h1 id="五、InnoDB表空间"><a href="#五、InnoDB表空间" class="headerlink" title="五、InnoDB表空间"></a>五、InnoDB表空间</h1><h2 id="页面回顾"><a href="#页面回顾" class="headerlink" title="页面回顾"></a>页面回顾</h2><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>BLOB页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是我们所说的数据页</td></tr></tbody></table><h3 id="页面通用部分"><a href="#页面通用部分" class="headerlink" title="页面通用部分"></a>页面通用部分</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f33c338667_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>File Header和File Trailder都保存了LSN！</p>          </div><h2 id="独立表空间结构"><a href="#独立表空间结构" class="headerlink" title="独立表空间结构"></a>独立表空间结构</h2><h3 id="区（Extent）"><a href="#区（Extent）" class="headerlink" title="区（Extent）"></a>区（Extent）</h3><p>物理概念，连续的64个页。+</p><h3 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h3><p>物理概念，连续的256个区。</p><blockquote><p>注意，这里的组与页里面几个记录为一组不是一个东西！</p></blockquote><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f33df9307a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>信息：</p><ul><li>第一个页<ul><li>表空间的在<strong>第一个组的第一个页</strong>中使用一个<code>FSP_HDR</code>的页来存储<strong>表信息和本组的页面信息</strong>。</li><li>除了第一个组，<strong>每个组的第一个页</strong>使用一个<code>XDES</code>的页来存储<strong>本组页面的信息</strong>。</li></ul></li><li>第二个页<ul><li><strong>每组的第二个页</strong>使用了一个<code>IBUF_BITMAP</code>页保存了本组页面的<code>INSERT BUFFER</code>的信息。</li></ul></li><li>第三个页<ul><li>第一个组的第三个页使用一个<code>INODE</code>页保存段信息。</li></ul></li></ul><div class="note note-primary">            <p><strong>为了管理，分配页空间</strong>，把每64个页作为一个区，每256个区作为一个组。<br>以<strong>组</strong>为单位维护组内<strong>各个区</strong>的<strong>页面</strong>使用情况。<br>目的在于尽可能让同一个索引树的数据在一个连续的空间中，实现顺序IO。即当数据量很大时，以区（64个页）为单位分配空间。</p>          </div><h3 id="段（segment）"><a href="#段（segment）" class="headerlink" title="段（segment）"></a>段（segment）</h3><p>段是一个抽象的概念，1个索引会生成2个段，一个叶子节点段，一个非叶子节点段。<br>为段分配空间的策略：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了32个碎片区页面之后，就会<strong>以完整的区为单位</strong>来分配存储空间。</li></ul><h2 id="区的分类与管理"><a href="#区的分类与管理" class="headerlink" title="区的分类与管理"></a>区的分类与管理</h2><p>区有4种状态：</p><ul><li>空闲的区：现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li></ul><table><thead><tr><th>状态名</th><th>含义</th></tr></thead><tbody><tr><td>FREE</td><td>空闲的区</td></tr><tr><td>FREE_FRAG</td><td>有剩余空间的碎片区</td></tr><tr><td>FULL_FRAG</td><td>没有剩余空间的碎片区</td></tr><tr><td>FSEG</td><td>附属于某个段的区</td></tr></tbody></table><h3 id="XDES-Entry"><a href="#XDES-Entry" class="headerlink" title="XDES Entry"></a>XDES Entry</h3><p>为了集中管理区的状态，使用了<code>XDES Entry</code>结构保存区状态。<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f343654829_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>XDES Entry保存了这个区：</p><ul><li>State状态：是否为空，或者是否附属于什么段。</li><li>XDES指针(一前一后)：便于快速检索每个区的状态。</li><li>Segment ID：所属段ID。</li><li>Page State Bitmap：标记本区的各个页是否空闲。</li></ul><h3 id="XDES-Entry链表"><a href="#XDES-Entry链表" class="headerlink" title="XDES Entry链表"></a>XDES Entry链表</h3><h4 id="全局的XDES-Entry链表"><a href="#全局的XDES-Entry链表" class="headerlink" title="全局的XDES Entry链表"></a>全局的XDES Entry链表</h4><p>除了FSEG状态，<strong>每个表会维护以下三个链表</strong>：</p><ul><li><code>FREE</code>链表</li><li><code>FREE_FRAG</code>链表</li><li><code>FULL_FRAG</code>链表</li></ul><p>这样在为段分配新空间时就可以快速找到碎片区和空闲区</p><h4 id="段中的XDES-Entry链表"><a href="#段中的XDES-Entry链表" class="headerlink" title="段中的XDES Entry链表"></a>段中的XDES Entry链表</h4><p>向段中插入数据时：</p><ol><li>段中碎片少时先找碎片区，找<code>FREE_FRAG</code>链表</li><li>段占满32个离散的页后，开始申请完整的区，找<code>FREE</code>链表</li></ol><p>区被分配给段之后，<strong>每个段也会维护以下三个链表</strong>：</p><ul><li><code>FREE</code>链表</li><li><code>FREE_FRAG</code>链表</li><li><code>FULL_FRAG</code>链表</li></ul><p>这三个链表是属于具体的段的，这样为该段的新数据找区分配时也可以直接找，不需要找全局申请。</p><h3 id="链表基节点"><a href="#链表基节点" class="headerlink" title="链表基节点"></a>链表基节点</h3><p><code>List Base Node</code>的结构：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f388927e1c_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>每个链表都有一个这样的头节点，来描述这个链表的基本属性。</p><div class="note note-primary">            <p>通过在全局维护不同类型区的链表和为每个段维护不同类型的区的链表，为管理区提供了条件。</p>          </div><h2 id="段的属性（INODE-Entry）"><a href="#段的属性（INODE-Entry）" class="headerlink" title="段的属性（INODE Entry）"></a>段的属性（INODE Entry）</h2><p>每个区使用了<code>XDES Entry</code>记录区的信息。<br>每个段使用了<code>INODE Entry</code>记录段的信息：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4087c4a56_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><div class="note note-primary">            <p>这里可见，段使用<code>INODE Entry</code>结构记录自己的信息，通过引用链表基节点<code>List Base</code>访问记录各个区信息的<code>XDES Entry</code>结构来实现对本段持有的区的管理。</p>          </div><h2 id="各种类型页面"><a href="#各种类型页面" class="headerlink" title="各种类型页面"></a>各种类型页面</h2><p>上面介绍了<code>XDES Entry</code>和<code>INODE Entry</code>结构分别记录区信息和段信息，现在介绍这些结构实际存储在哪里。</p><h3 id="FSP-HDR页面"><a href="#FSP-HDR页面" class="headerlink" title="FSP_HDR页面"></a>FSP_HDR页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4733af475_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br><code>FSR_HDR</code>是表空间中第一个组的第一个区的第一个页面，具体信息如下：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>File Space Header</td><td>表空间头部</td><td>112字节</td><td>表空间的一些整体属性信息</td></tr><tr><td>XDES Entry</td><td>区描述信息</td><td>10240字节</td><td>存储本组256个区对应的属性信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>5986字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><blockquote><p>这个页记录了：</p><ul><li>本表的属性</li><li>本组的各个区（256个区）的属性信息。</li></ul></blockquote><p><em>File Space Header</em></p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>Space ID</td><td>4字节</td><td>表空间的ID</td></tr><tr><td>Not Used</td><td>4字节</td><td>这4个字节未被使用，可以忽略</td></tr><tr><td>Size</td><td>4字节</td><td>当前表空间占有的页面数</td></tr><tr><td>FREE Limit</td><td>4字节</td><td>尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表</td></tr><tr><td>Space Flags</td><td>4字节</td><td>表空间的一些占用存储空间比较小的属性</td></tr><tr><td>FRAG_N_USED</td><td>4字节</td><td>FREE_FRAG链表中已使用的页面数量</td></tr><tr><td>List Base Node for FREE List</td><td>16字节</td><td>FREE链表的基节点</td></tr><tr><td>List Base Node for FREE_FRAG List</td><td>16字节</td><td>FREE_FRAG链表的基节点</td></tr><tr><td>List Base Node for FULL_FRAG List</td><td>16字节</td><td>FULL_FRAG链表的基节点</td></tr><tr><td>Next Unused Segment ID</td><td>8字节</td><td>当前表空间中下一个未使用的 Segment ID</td></tr><tr><td>List Base Node for SEG_INODES_FULL List</td><td>16字节</td><td>SEG_INODES_FULL链表的基节点</td></tr><tr><td>List Base Node for SEG_INODES_FREE List</td><td>16字节</td><td>SEG_INODES_FREE链表的基节点</td></tr></tbody></table><h3 id="XDES页面"><a href="#XDES页面" class="headerlink" title="XDES页面"></a>XDES页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f475c0ec2a_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>这个页记录了：</p><ul><li>本组的各个区（256个区）的属性信息。</li></ul></blockquote><p>与<code>FSR_HDR</code>相似，只是没有<em>File Space Header</em>字段。</p><h3 id="IBUF-BITMAP页面"><a href="#IBUF-BITMAP页面" class="headerlink" title="IBUF_BITMAP页面"></a>IBUF_BITMAP页面</h3><p>记录页面是否有操作缓存</p><h3 id="INODE页面"><a href="#INODE页面" class="headerlink" title="INODE页面"></a>INODE页面</h3><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16ef3a8df380813e_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><blockquote><p>前面说过每个段设计了一个<code>INODE Entry</code>结构，通过<code>INODE Entry</code>结构找<code>XDES Entry</code>实现段对区的管理。</p></blockquote><p>表空间在第一个组的第一个区的第三个页面保存这些<code>INODE</code>节点，具体：</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>List Node for INODE Page List</td><td>通用链表节点</td><td>12字节</td><td>存储上一个INODE页面和下一个INODE页面的指针</td></tr><tr><td>INODE Entry</td><td>段描述信息</td><td>16320字节</td><td></td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>6字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>List Node for INODE Page List</code>：该页面只能创建85个<code>INODE Entry</code>，如果这个表空间的索引较多（一个索引对应两个段，一个段就有一个INODE Entry），则需要使用其他的页来记录，这里用来存储上一个和下一个INODE Entry页面。</p><p>为了管理INODE Entry页面，也创建了两个链表：</p><ul><li><code>SEG_INODES_FULL</code>链表：该链表中的<code>INODE</code>类型的页面中已经没有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li><li><code>SEG_INODES_FREE</code>链表：该链表中的<code>INODE</code>类型的页面中还有空闲空间来存储额外的<code>INODE Entry</code>结构了。</li></ul><p>而这两个链表的基节点在<code>File Space Header</code>（在FSP_HDR页面中）。</p><h2 id="Segment-Header-结构"><a href="#Segment-Header-结构" class="headerlink" title="Segment Header 结构"></a>Segment Header 结构</h2><p>每个段用一个<code>INODE Entry</code>记录属性，同时也需要建立段中页面和<code>INODE Entry</code>的对应方式。</p><p>每个索引页都有一个Page Header部分（存放这个数据页的基本信息），对于每个索引的<strong>根节点</strong>，都有两个属性：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的根页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的根页定义</td></tr></tbody></table><p>这两个属性都对应一个<code>Segment Header</code>结构：<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f48c4472a3_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"><br>各个部分的具体释义如下：</p><table><thead><tr><th>名称</th><th>占用字节数</th><th>描述</th></tr></thead><tbody><tr><td>Space ID of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的表空间ID</td></tr><tr><td>Page Number of the INODE Entry</td><td>4</td><td>INODE Entry结构所在的页面页号</td></tr><tr><td>Byte Offset of the INODE Ent</td><td>2</td><td>INODE Entry结构在该页面中的偏移量</td></tr></tbody></table><div class="note note-primary">            <p>即<strong>索引的根节点</strong>的<strong>页头信息</strong>中记录了对<strong>该索引的两个段的INODE结构</strong>的指针。</p>          </div><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p><code>系统表空间 ID</code>（Space ID）是<code>0</code>。<br><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4911220d8_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><ul><li>第一个区extend 0中有许多页来记录系统属性：</li></ul><table><thead><tr><th>页号</th><th>页面类型</th><th>英文描述</th><th>描述</th></tr></thead><tbody><tr><td>3</td><td>SYS</td><td>Insert Buffer Header</td><td>存储Insert Buffer的头部信息</td></tr><tr><td>4</td><td>INDEX</td><td>Insert Buffer Root</td><td>存储Insert Buffer的根页面</td></tr><tr><td>5</td><td>TRX_SYS</td><td>Transction System</td><td>事务系统的相关信息</td></tr><tr><td>6</td><td>SYS</td><td>First Rollback Segment</td><td>第一个回滚段的页面</td></tr><tr><td>7</td><td>SYS</td><td>Data Dictionary Header</td><td>数据字典头部信息</td></tr></tbody></table><ul><li><code>extent 1</code>和<code>extent 2</code>这两个区被称为双写缓冲区</li></ul><h3 id="InnoDB数据字典"><a href="#InnoDB数据字典" class="headerlink" title="InnoDB数据字典"></a>InnoDB数据字典</h3><p>InnoDB存储引擎特意定义了一些列的内部系统表（internal system table）来记录这些这些<code>元数据</code>：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个InnoDB存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个InnoDB存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个InnoDB存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个InnoDB存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个InnoDB存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个InnoDB存储引擎中所有的外键对应列的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个InnoDB存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个InnoDB存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIRTUAL</td><td>整个InnoDB存储引擎中所有的虚拟生成列的信息</td></tr><tr><td>这些系统表也被称为<code>数据字典</code>。</td><td></td></tr></tbody></table><h4 id="SYS-TABLES表"><a href="#SYS-TABLES表" class="headerlink" title="SYS_TABLES表"></a>SYS_TABLES表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>NAME</td><td>表的名称</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个表都有一个唯一的ID</td></tr><tr><td>N_COLS</td><td>该表拥有列的个数</td></tr><tr><td>TYPE</td><td>表的类型，记录了一些文件格式、行格式、压缩等信息</td></tr><tr><td>MIX_ID</td><td>已过时，忽略</td></tr><tr><td>MIX_LEN</td><td>表的一些额外的属性</td></tr><tr><td>CLUSTER_ID</td><td>未使用，忽略</td></tr><tr><td>SPACE</td><td>该表所属表空间的ID</td></tr></tbody></table><h4 id="SYS-COLUMNS表"><a href="#SYS-COLUMNS表" class="headerlink" title="SYS_COLUMNS表"></a>SYS_COLUMNS表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该列所属表对应的ID</td></tr><tr><td>POS</td><td>该列在表中是第几列</td></tr><tr><td>NAME</td><td>该列的名称</td></tr><tr><td>MTYPE</td><td>main data type，主数据类型，就是那堆INT、CHAR、VARCHAR、FLOAT、DOUBLE之类的东东</td></tr><tr><td>PRTYPE</td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许NULL值，是否允许负数啥的</td></tr><tr><td>LEN</td><td>该列最多占用存储空间的字节数</td></tr><tr><td>PREC</td><td>该列的精度，不过这列貌似都没有使用，默认值都是0</td></tr></tbody></table><h4 id="SYS-INDEXES表"><a href="#SYS-INDEXES表" class="headerlink" title="SYS_INDEXES表"></a>SYS_INDEXES表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该索引所属表对应的ID</td></tr><tr><td>ID</td><td>InnoDB存储引擎中每个索引都有一个唯一的ID</td></tr><tr><td>NAME</td><td>该索引的名称</td></tr><tr><td>N_FIELDS</td><td>该索引包含列的个数</td></tr><tr><td>TYPE</td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td>SPACE</td><td>该索引根页面所在的表空间ID</td></tr><tr><td>PAGE_NO</td><td>该索引根页面所在的页面号</td></tr><tr><td>MERGE_THRESHOLD</td><td>如果页面中的记录被删除到某个比例，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><h4 id="SYS-FIELDS表"><a href="#SYS-FIELDS表" class="headerlink" title="SYS_FIELDS表"></a>SYS_FIELDS表</h4><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>INDEX_ID</td><td>该索引列所属的索引的ID</td></tr><tr><td>POS</td><td>该索引列在某个索引中是第几列</td></tr><tr><td>COL_NAME</td><td>该索引列的名称</td></tr></tbody></table><h3 id="Data-Dictionary-Header页面"><a href="#Data-Dictionary-Header页面" class="headerlink" title="Data Dictionary Header页面"></a>Data Dictionary Header页面</h3><p>以上的四个系统表描述了用户表的元数据，而这四个系统表的元数据则通过固定页面（Data Dictionary Header）来存储。</p><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16efe1e5a01aeac9_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>简单描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Data Dictionary Header</td><td>数据字典头部信息</td><td>56字节</td><td>记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息</td></tr><tr><td>Segment Header</td><td>段头部信息</td><td>10字节</td><td>记录本页面所在段对应的INODE Entry位置信息</td></tr><tr><td>Empty Space</td><td>尚未使用空间</td><td>16272字节</td><td>用于页结构的填充，没啥实际意义</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><p><code>Data Dictionary Header</code>描述了整个系统分配下一个表空间ID，列ID等的策略。</p><blockquote><p>在<code>information_schema</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表，但可以参考。</p></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%89/16a739f4a99c9a08_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.webp"></p><p>用户表空间结构：</p><ol><li>每个页通过将记录分成多组，使用页头管理</li><li>每个区由64个连续页组成，通过XDES结构管理每个页的状态</li><li>每个组由256个连续区组成，通过FSP_HDR&#x2F;XDES页面管理每个区的状态。</li><li>每个表由若干组组成，通过INODE页面管理本表的段。</li><li>每个索引由2个段组成，段是一个逻辑上的概念。</li></ol><p>空间分配：<br>当段占用的页面超过32个时，开始以区为单位分配空间，因此：</p><ol><li>每个表空间有3个全局链表，分别代表了不同状态的XDES结构。</li><li>每个段也有3个链表，维护属于本段的XDES结构。</li></ol>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础（启动选项与字符集）</title>
    <link href="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/"/>
    <url>/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、启动选项"><a href="#一、启动选项" class="headerlink" title="一、启动选项"></a>一、启动选项</h1><h2 id="mysqld"><a href="#mysqld" class="headerlink" title="mysqld"></a>mysqld</h2><p><em>eg:</em><br><code>--skip-networking</code> 禁止网络<br><code>--default-storage-engine=MyISAM</code> 选择默认存储引擎</p><p>注意：</p><ul><li>选项有长形式和短形式<ul><li>长形式前面<code>--</code></li><li>短形式前面<code>-</code></li><li>一般短形式后面要直接加参数（不能空格）</li></ul></li><li>选项名是区分大小写的</li></ul><div class="note note-primary">            <p><code>mysqld_safe</code>会间接调用<code>mysqld</code></p>          </div><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可以在配置文件中修改启动参数。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>我们可以在选项组的名称后加上特定的<code>MySQL</code>版本号，比如对于<code>[mysqld]</code>选项组来说，我们可以定义一个<code>[mysqld-5.7]</code>的选项组，它的含义和<code>[mysqld]</code>一样，只不过只有版本号为<code>5.7</code>的<code>mysqld</code>程序才能使用这个选项组中的选项。</p><h3 id="配置文件的优先级"><a href="#配置文件的优先级" class="headerlink" title="配置文件的优先级"></a>配置文件的优先级</h3><ul><li>不同配置文件和同一个配置文件中的相同选项，按扫描最后出现的为准。</li><li>可以<code>defaults-extra-file</code>指定额外的配置文件，这样会只使用该指定文件。</li></ul><h1 id="二、系统变量"><a href="#二、系统变量" class="headerlink" title="二、系统变量"></a>二、系统变量</h1><h2 id="系统变量基本概念"><a href="#系统变量基本概念" class="headerlink" title="系统变量基本概念"></a>系统变量基本概念</h2><ul><li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li><li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li></ul><h2 id="系统变量基本操作"><a href="#系统变量基本操作" class="headerlink" title="系统变量基本操作"></a>系统变量基本操作</h2><h3 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h3><p><code>SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];</code></p><h3 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h3><h4 id="启动时"><a href="#启动时" class="headerlink" title="启动时"></a>启动时</h4><ul><li>启动时指定</li><li>配置文件中配置</li></ul><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><p>设置不同作用范围的系统变量：<br><code>SET [GLOBAL|SESSION] 系统变量名 = 值;</code><br>或<br><code>SET [@@(GLOBAL|SESSION).]var_name = XXX;</code></p><blockquote><p>注意：</p><ul><li>并不是所有系统变量都具有<code>GLOBAL</code>和<code>SESSION</code>的作用范围。</li><li>有些系统变量是只读的，并不能设置值。</li></ul></blockquote><h4 id="启动选项和系统变量的区别"><a href="#启动选项和系统变量的区别" class="headerlink" title="启动选项和系统变量的区别"></a>启动选项和系统变量的区别</h4><ul><li>大部分的系统变量都可以被当作启动选项传入。</li><li>有些系统变量是在程序运行过程中自动生成的，是不可以当作启动选项来设置，比如<code>auto_increment_offset</code>、<code>character_set_client</code>啥的。</li><li>有些启动选项也不是系统变量，比如<code>defaults-file</code>。</li></ul><h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><h3 id="查看状态变量"><a href="#查看状态变量" class="headerlink" title="查看状态变量"></a>查看状态变量</h3><p><code>SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];</code></p><h1 id="三、字符集"><a href="#三、字符集" class="headerlink" title="三、字符集"></a>三、字符集</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>主要字符集：</p><ul><li><code>ASCII</code>字符集：128个字符，<strong>1字节</strong>编码</li><li><code>ISO 8859-1</code>字符集：256个字符，<strong>1字节</strong>编码</li><li><code>GB2312</code>字符集：汉字，ASCII中1字节编码，其他<strong>2字节</strong>编码</li><li><code>GBK</code>字符集：对<code>GB2312</code>扩充，<strong>1～2字节</strong>编码。</li><li><code>utf8</code>字符集：兼容<code>ASCII</code>字符集，采用变长编码方式，编码一个字符需要使用<strong>1～4个字节</strong>。</li></ul><h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>每个字符集都有对应的若干个比较规则，如针对二进制编码比较，大小写比较等等。</p><h2 id="MySQL中支持的字符集和排序规则"><a href="#MySQL中支持的字符集和排序规则" class="headerlink" title="MySQL中支持的字符集和排序规则"></a>MySQL中支持的字符集和排序规则</h2><h3 id="utf8和utf8mb4"><a href="#utf8和utf8mb4" class="headerlink" title="utf8和utf8mb4"></a>utf8和utf8mb4</h3><ul><li><code>utf8mb3</code>：阉割过的<code>utf8</code>字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code>：正宗的<code>utf8</code>字符集，使用1～4个字节表示字符。</li></ul><p>因为4字节的字符很少，有时可以使用utf8mb3。</p><h3 id="字符集的查看"><a href="#字符集的查看" class="headerlink" title="字符集的查看"></a>字符集的查看</h3><p><code>SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];</code></p><h3 id="比较规则的查看"><a href="#比较规则的查看" class="headerlink" title="比较规则的查看"></a>比较规则的查看</h3><p><code>SHOW COLLATION [LIKE 匹配的模式];</code></p><table><thead><tr><th>后缀</th><th>英文释义</th><th>描述</th></tr></thead><tbody><tr><td><code>_ai</code></td><td>accent insensitive</td><td>不区分重音</td></tr><tr><td><code>_as</code></td><td>accent sensitive</td><td>区分重音</td></tr><tr><td><code>_ci</code></td><td>case insensitive</td><td>不区分大小写</td></tr><tr><td><code>_cs</code></td><td>case sensitive</td><td>区分大小写</td></tr><tr><td><code>_bin</code></td><td>binary</td><td>以二进制方式比较</td></tr></tbody></table><h3 id="字符集与比较规则的应用"><a href="#字符集与比较规则的应用" class="headerlink" title="字符集与比较规则的应用"></a>字符集与比较规则的应用</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><code>MySQL</code>有4个级别的字符集和比较规则，分别是：</p><ul><li>服务器级别：系统变量</li><li>数据库级别：创建库时指定</li><li>表级别：创建表时指定</li><li>列级别：创建表时指定</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>在创建库&#x2F;表&#x2F;列时，若没有指定，默认使用上一级的参数。</li><li>只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。</li><li>只修改比较规则，则字符集将变为修改后的比较规则对应的字符集。</li></ul><h4 id="客户端和服务器通信中的字符集"><a href="#客户端和服务器通信中的字符集" class="headerlink" title="客户端和服务器通信中的字符集"></a>客户端和服务器通信中的字符集</h4><p><img src="/2023/02/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Mysql/Mysql%E5%9F%BA%E7%A1%80/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E5%AD%97%E7%AC%A6%E9%9B%86%EF%BC%89/f87857b928f84edca6a6cf127b3fda5a_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp"></p><table><thead><tr><th>系统变量</th><th>描述</th></tr></thead><tbody><tr><td>character_set_client</td><td>服务器解码请求时使用的字符集</td></tr><tr><td>character_set_connection</td><td>服务器处理请求时会把请求字符串从character_set_client转为character_set_connection</td></tr><tr><td>character_set_results</td><td>服务器向客户端返回数据时使用的字符集</td></tr></tbody></table><p>MYSQL会使用<code>character_set_client</code>字符集来解码客户端传来的二进制数据，然后将其编码成<code>character_set_connection</code>执行，最后将结果编码成<code>character_set_results</code>返回给客户端。</p><h4 id="比较规则的应用"><a href="#比较规则的应用" class="headerlink" title="比较规则的应用"></a>比较规则的应用</h4><p>比较规则的作用通常体现比较字符串大小的表达式以及对某个字符串列进行排序中。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Mysql</category>
      
      <category>Mysql基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（API）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整数处理"><a href="#整数处理" class="headerlink" title="整数处理"></a>整数处理</h3><p><em>取余</em><br>%是取余操作，向零取整，<strong>结果符号随被除数</strong>。</p><p><em>取模</em><br>mod，操作为<code>Math.floorMod(a,b)</code>，向下取整，<strong>结果符号随除数</strong>。</p><p><em>设置</em><br><code>int mod = (int)1e9+7;</code></p><p><em>交换</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.临时变量</span><br><span class="hljs-comment">//2.加减</span><br>x = x + y;<br>y = x - y;<br>x = x - y;<br><span class="hljs-comment">//3.或运算，存在缺陷，若x和y是同一个对象，会导致结果置0。</span><br>x = x^y;<br>y = x^y;<br>x = x^y;<br></code></pre></td></tr></table></figure><p><em>值传递</em><br>若需要维护整数全局遍历，应该使用<code>int[1]</code>实现整数对象在方法中的操作。</p><blockquote><p>Integer为什么不可行？<br>方法中若操作了Integer，本质上调用了Integer.valueOf()创建了一个新的Integer对象赋值给形参，此时形参指向的地址改变；若方法不对外返回这个Integer，外部方法的Integer仍为原值；</p></blockquote><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88API%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%A8%A1%E6%9D%BF%EF%BC%89/Pasted-image-20230315234608.png"></p><ul><li>其他类型转Integer：Integer.valueOf()</li><li>其他类型转String：String.valueOf()</li><li>Integer转int：Integer.intValue();</li><li>String转int：Integer.parseInt(“123”)</li></ul><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>取<code>[0,val)</code>之间的随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>random.nextInt(val);<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><p>对比<code>int[]</code>、<code>Integer[]</code>、<code>List&lt;Integer&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a,b,c&#125;;<br>Integer[] aO = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;a,b,c&#125;;<br><br><span class="hljs-comment">//双括号初始化</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;()&#123;&#123;<br>add(Integer i1);<br>add(Integer i2);<br>&#125;&#125;;<br><span class="hljs-comment">//生成一个不可变对象</span><br>List&lt;Integer&gt; list = Arrays.asList(o1,o2,o3);<br><span class="hljs-comment">//生成一个可变对象，基于new ArrayList&lt;&gt;(Collection&lt;&gt;);</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(o1,o2,o3));<br></code></pre></td></tr></table></figure><h3 id="数组转化"><a href="#数组转化" class="headerlink" title="数组转化"></a>数组转化</h3><ul><li>其他类型转<code>int[]</code>，使用流，转化为基本类型后<code>toArray()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer[] -&gt; int[]</span><br><span class="hljs-type">int</span>[] ints = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();<br><span class="hljs-comment">//List&lt;Integer&gt; --&gt; int[]</span><br><span class="hljs-type">int</span>[] ints = list.stream().mapToInt(Integer::valueOf).toArray();<br></code></pre></td></tr></table></figure><ul><li><code>int[]</code>转其他类型，使用流，做包装</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//int[] --&gt; Integer[]</span><br>Integer[] integers = Arrays.stream(ints).boxed().toArray(Integer::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">//int[] --&gt; List&lt;nteger&gt;()</span><br>List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li>集合类型直接互相转化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer[] -&gt; List&lt;Integer&gt;</span><br>List&lt;Integer&gt; list = Arrays.asList(integers);<br><span class="hljs-comment">//List&lt;Integer&gt; --&gt; Integer[]</span><br>Integer[] integers = list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><ul><li>流处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(ints).sum();<br>Arrays.stream(ints).max().getAsInt();<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//int[] / Integer[] 排序</span><br>Arrays.sort(T[],Comparator);<br><br><span class="hljs-comment">//list排序</span><br>Collections.sort(T[],Comparator);<br>list.sort(Comparator);<br><span class="hljs-comment">//特殊用法</span><br>list.sort(Comparator.comparing(a-&gt;a.getId()));<br>list.sort(Comparator.comparing(Employee:getName));<br><br><span class="hljs-comment">//搜索</span><br><span class="hljs-comment">//二分查找，若找不到，则会返回-index-1(index为其插入后应该有的位置。</span><br>Arrays.binarySearch(<span class="hljs-type">int</span>[],x);<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="生成字符串"><a href="#生成字符串" class="headerlink" title="生成字符串"></a>生成字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以填入基本类型，包括char</span><br>String.valueOf()<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[]);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[],left,right-left+<span class="hljs-number">1</span>)  <span class="hljs-comment">//字符数组转化为字符串</span><br></code></pre></td></tr></table></figure><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转字符数组</span><br><span class="hljs-type">char</span>[] cs = string.toCharArray();<br><br><span class="hljs-comment">//formIndex可选</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> string.indexOf(<span class="hljs-type">int</span> ch);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> string.indexOf(String s,<span class="hljs-type">int</span> fromIndex);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> string.lastIndexOf(String s,<span class="hljs-type">int</span> fromIndex);<br><br><span class="hljs-comment">//分割，如果分隔符连续出现，得到的结果中会有一个空元素</span><br>String[] sArr = string.split(<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">//子串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">substr</span> <span class="hljs-operator">=</span> string.substring(<span class="hljs-type">int</span> startIndex,<span class="hljs-type">int</span> endIndex);<br><br><span class="hljs-comment">//替换字符/字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">repstr</span> <span class="hljs-operator">=</span> string.replace(<span class="hljs-type">char</span> oldChar,String newChar);<br><span class="hljs-type">String</span> <span class="hljs-variable">repstr</span> <span class="hljs-operator">=</span> string.replace(String oldString,String newString);<br><span class="hljs-type">String</span> <span class="hljs-variable">repstr</span> <span class="hljs-operator">=</span> string.replaceAll(String oldString,String newString);<br><br><span class="hljs-comment">//转小写</span><br><span class="hljs-type">String</span> <span class="hljs-variable">lowStr</span> <span class="hljs-operator">=</span> string.toLowerCase();<br></code></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除最后一个字符</span><br>sb.deleteCharAt(sb.length()-<span class="hljs-number">1</span>);<br><span class="hljs-comment">//删除指定区间</span><br>sb.delete(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end);<br><span class="hljs-comment">//反转</span><br>sb.reverse();<br><span class="hljs-comment">//获取索引</span><br>sb.indexOf(String str);<br><span class="hljs-comment">//插入</span><br>sb.insert(<span class="hljs-type">int</span> offset,String string);<br></code></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><ul><li>数字(0 -&gt; 9)的ASCII，48-&gt;57;</li><li>小写字母(a-&gt;z)的ASCII，97-&gt;122;</li><li>大写字母(A-&gt;Z)的ASCII，65-&gt;90;<ul><li>可见之间隔了32，因此若要进行大小写转换，以90为界限，加减32即可。</li><li>若要保存数字+字母，使用<code>int[128]</code>即可</li><li>若只保存字母，使用<code>int[58]</code>即可，索引为<code>c-&#39;A&#39;</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断</span><br>Character.isLetterOrDigit()<br><span class="hljs-comment">//转化大小写，upper</span><br>Character.toLowerCase(<span class="hljs-type">char</span>)<br><br><span class="hljs-comment">//数字&lt;==&gt;字符</span><br><span class="hljs-number">8</span>+<span class="hljs-string">&#x27;0&#x27;</span><br><span class="hljs-string">&#x27;8&#x27;</span>-<span class="hljs-string">&#x27;0&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//常用</span><br>map.getOrDefault(key,<span class="hljs-number">0</span>);<br>map.putIfAbsent(key,<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet())<br><span class="hljs-comment">//遍历器</span><br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> hashMap.entrySet().iterator();<br><span class="hljs-comment">//排序</span><br>List&lt;Map.Entry&lt;String, String&gt;&gt; entryList1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map.Entry&lt;String, String&gt;&gt;(map1.entrySet());<br>Collections.sort(entryList1, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;String, String&gt; me1, Entry&lt;String, String&gt; me2)</span> &#123;<br><span class="hljs-keyword">return</span> me1.getKey().compareTo(me2.getKey()); <span class="hljs-comment">// 升序排序</span><br><span class="hljs-comment">//return me2.getKey().compareTo(me1.getKey()); // 降序排序</span><br>&#125;<br>&#125;);<br><br><span class="hljs-comment">//流处理（记不住）</span><br>Map&lt;String, String&gt; result1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, String&gt;();<br>map1.entrySet()<br>.stream().sorted(Map.Entry.comparingByKey())<br>.forEachOrdered(x -&gt; result1.put(x.getKey(), x.getValue()));<br><br><span class="hljs-comment">//按值排序</span><br>List&lt;Map.Entry&lt;String,String&gt;&gt; entrys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stu.entrySet());<br>Collections.sort(entrys, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;String, String&gt; me1, Entry&lt;String, String&gt; me2)</span> &#123;<br><span class="hljs-keyword">return</span> me1.getValue().compareTo(me2.getValue()); <span class="hljs-comment">// 升序排序</span><br><span class="hljs-comment">//return me2.getKey().compareTo(me1.getKey()); // 降序排序</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>常用LinkedList、ArrayDeque，可使用offer、poll(不会异常)操作结合fisrt、last使用。</p><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分搜索树，会自动去重并从小到大排列</span><br>Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>();<br><span class="hljs-comment">//返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素,返回null。</span><br>set.ceiling(x);<br><span class="hljs-comment">//返回在这个集合中小于或等于给定元素的最大元素，如果不存在这样的元素,返回null。</span><br>set.floor(x);<br><span class="hljs-comment">//大于</span><br>set.higher(x);<br><span class="hljs-comment">//小于</span><br>set.lower(x);<br></code></pre></td></tr></table></figure><h3 id="常见方法-1"><a href="#常见方法-1" class="headerlink" title="常见方法"></a>常见方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反转</span><br>Collections.reverse(list);<br><span class="hljs-comment">//二分查找，若找不到，则会返回-index-1(index为其插入后应该有的位置。</span><br>Collections.binarySearch(list,x);<br><span class="hljs-comment">//排序，需要T实现Comparable，即重写compareTo。底层调用list.sort();</span><br>Collections.sort(list);<br></code></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="控制台IO"><a href="#控制台IO" class="headerlink" title="控制台IO"></a>控制台IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//读该行剩下的所有内容并换行</span><br>in.readLine();<br><span class="hljs-comment">//越过空格和回车，读下一个int，再次遇到空格或回车后停止，因此如果在readInt后需要换行读取，需要执行一次空的in.readLine()读走换行符。</span><br>in.readInt();<br></code></pre></td></tr></table></figure><h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字节IO</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath); <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br><span class="hljs-comment">//将字节读入数组，返回-1则说明读完了。</span><br>bufferedInputStream.read(<span class="hljs-type">byte</span>[] bytes);<br><br><span class="hljs-comment">//字符io</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);  <br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fileReader);  <br>bufferedReader.readLine();<br></code></pre></td></tr></table></figure><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>若是双指针二分，根据取中的方法，总数为偶数时最终中值会偏向一边的端点，代码要保证当偏向的那段的值为target时，另一边能一直收缩。<br>双指针本质上，是一个指针做判断，一个指针做范围压缩，而一般压缩不能越过正确值。</p><p>1.若想找到一个数，或有重复数的最左边，则以左指针做边界判断（+1），右指针做压缩，同时mid偏左。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid]&lt;target)&#123;<br>left = mid+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    right = mid;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.若想找到一个数的最右边，则以右指针作为边界判断（-1)，左指针做压缩，同时mid偏右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid]&lt;=target)&#123;<br>left=mid;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>right = mid-<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>注意点：数组的长度是n+1，0不存储元素，而是作为query的终止值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += a[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            a[x] += dt;<br>            x += lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br><span class="hljs-keyword">if</span>(i == len) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-comment">//记忆化，不记忆isLimit和非isNum的情况</span><br><span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] &gt;=<span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> dp[i][mask];<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(!isNum) res += dfs(i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=isNum?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,up=isLimit?s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;j&lt;=up;j++)&#123;<br><span class="hljs-keyword">if</span>(((mask&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>res += dfs(i+<span class="hljs-number">1</span>,mask|(<span class="hljs-number">1</span>&lt;&lt;j),isLimit&amp;&amp;(s[i]-<span class="hljs-string">&#x27;0&#x27;</span> == j),<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum)&#123;<br>dp[i][mask] = res;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-type">int</span>[] parent;<br><span class="hljs-type">int</span>[] size;<br><span class="hljs-type">int</span> setCount;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-built_in">this</span>.n = n;<br><span class="hljs-built_in">this</span>.setCount = n;<br><span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-built_in">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>Arrays.fill(size,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>parent[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//缩小集的操作在这里</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">return</span> parent[x] == x?x:(parent[x] = root(parent[x]));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>x = root(x);<br>y = root(y);<br><span class="hljs-keyword">if</span>(x == y)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>x = x^y;<br>y = x^y;<br>x = x^y;<br>&#125;<br>parent[y] = x;<br>size[x] += size[y];<br>setCount--;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">return</span> root(x) == root(y);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-comment">//可以使用数组</span><br>    <span class="hljs-keyword">public</span> Trie[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br><span class="hljs-comment">//也可以使用hash</span><br><span class="hljs-comment">//public Map&lt;?,Trie&gt; children = new HashMap&lt;&gt;();</span><br><br><span class="hljs-comment">//可以记录本节点是一个单词结束点，也可以记录本节点所对应的单词等</span><br>    <span class="hljs-comment">//boolean isEnd = null;</span><br>    <span class="hljs-comment">//public String word = null;</span><br><br><span class="hljs-comment">//获取指定字符的节点</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br><span class="hljs-comment">//插入单词</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>)<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            node = node.children[<span class="hljs-type">char</span>];<br>        &#125;<br>        <span class="hljs-comment">//node.isEnd = true;</span><br>        <span class="hljs-comment">//node.word = word;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    Node head;<br>    Node tail;<br>    Node[] nodes;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[capacity];<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">this</span>.tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> getFromHash(key);<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        unlink(temp);<br>        insert(temp);<br>        <span class="hljs-keyword">return</span> temp.value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> getFromHash(key);<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>)&#123;<br>            temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key,value);<br>            insertToHash(temp);<br>            insert(temp);<br>            size++;<br>            <span class="hljs-keyword">if</span>(size &gt; capacity)&#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">needRemove</span> <span class="hljs-operator">=</span> tail.pre;<br>                unlink(needRemove);<br>                removeFromHash(needRemove.key);<br>                size--;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp.value = value;<br>            unlink(temp);<br>            insert(temp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> node.pre;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>        node.pre = <span class="hljs-literal">null</span>;<br>        node.next = <span class="hljs-literal">null</span>;<br>        pre.next = next;<br>        <span class="hljs-keyword">if</span>(next != <span class="hljs-literal">null</span>)&#123;<br>            next.pre = pre;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">oldHead</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-comment">//与头建立连接</span><br>        head.next = node;<br>        node.pre = head;<br>        <span class="hljs-comment">//与尾建立连接</span><br>        node.next = oldHead;<br>        <span class="hljs-keyword">if</span>(oldHead != <span class="hljs-literal">null</span>)&#123;<br>            oldHead.pre = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getFromHash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key%capacity;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nodes[hash];<br>        <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(temp.key == key)&#123;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                temp = temp.nextHash;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertToHash</span><span class="hljs-params">(Node node)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> node.key%capacity;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nodes[hash];<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-literal">null</span>)&#123;<br>            nodes[hash] = node;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node.nextHash = nodes[hash];<br>            nodes[hash] = node;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeFromHash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key%capacity;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nodes[hash];<br>        <span class="hljs-keyword">if</span>(temp.key == key) nodes[hash] = temp.nextHash;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> temp;<br>        <span class="hljs-keyword">while</span>(temp.nextHash != <span class="hljs-literal">null</span>)&#123;<br>            temp = temp.nextHash;<br>            <span class="hljs-keyword">if</span>(temp.key == key)&#123;<br>                last.nextHash = temp.nextHash;<br>                temp.nextHash = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            last = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> value;<br>    Node next;<br>    Node pre;<br>    Node nextHash;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（排序）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p><a href="https://leetcode.cn/leetbook/read/sort-algorithms/eu039h/">参考LeetBook</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h3><p>每个数与后一个数比较，如果逆序则交换，故每次可冒出一个最大值，经过n次操作得到有序数组</p><h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>                swap(arr, j, j + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 交换元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-升级"><a href="#3-升级" class="headerlink" title="3.升级"></a>3.升级</h3><ul><li>有时整个数组已经有序了，不需要排n次，应该直接返回。  </li><li>有时数组的后半段已经有序了，不需要反复对比到结尾，应该直接进入下一个循环。</li></ul><h3 id="4-处理"><a href="#4-处理" class="headerlink" title="4.处理"></a>4.处理</h3><ul><li>记录每次循环是否发生过交换，若没有则直接返回。 </li><li>记录每次循环最后一个发生交换的索引，下次循环只需要遍历到这个索引，该索引后面的数组已经有序。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">swapped</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 最后一个没有经过排序的元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">indexOfLastUnsortedElement</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 上次发生交换的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">swappedIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (swapped) &#123;<br>        swapped = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>                swap(arr, i, i + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 表示发生了交换</span><br>                swapped = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 更新交换的位置</span><br>                swappedIndex = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 最后一个没有经过排序的元素的下标就是最后一次发生交换的位置</span><br>        indexOfLastUnsortedElement = swappedIndex;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 交换元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="1.思路"></a>1.思路</h3><p>每次遍历，然后把最小的放到最前面。<br>与冒泡有点相似，不过冒泡是每次循环中每次对比都做交换，选择排序一个循环只做一次交换。</p><h3 id="2-基本实现-1"><a href="#2-基本实现-1" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> minIndex;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最小值的下标</span><br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将最小元素交换至首位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化"><a href="#3-优化" class="headerlink" title="3.优化"></a>3.优化</h3><ul><li>每次同时记录最大，最小值，减半循环次数</li></ul><h3 id="4-处理-1"><a href="#4-处理-1" class="headerlink" title="4.处理"></a>4.处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> minIndex, maxIndex;<br>    <span class="hljs-comment">// i 只需要遍历一半</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length / <span class="hljs-number">2</span>; i++) &#123;<br>        minIndex = i;<br>        maxIndex = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最小值的下标</span><br>                minIndex = j;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;<br>                <span class="hljs-comment">// 记录最大值的下标</span><br>                maxIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成</span><br>        <span class="hljs-keyword">if</span> (minIndex == maxIndex) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 将最小元素交换至首位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>        <span class="hljs-comment">// 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。</span><br>        <span class="hljs-keyword">if</span> (maxIndex == i) maxIndex = minIndex;<br>        <span class="hljs-comment">// 将最大元素交换至末尾</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span> - i;<br>        temp = arr[lastIndex];<br>        arr[lastIndex] = arr[maxIndex];<br>        arr[maxIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一般而言，冒泡排序是稳定的，选择排序是不稳定的。</p></blockquote><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="1.思路"></a>1.思路</h3><p>把一个新的数插入到原先的有序数组中<br>插入排序有两种写法：</p><ul><li>交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</li><li>移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。</li></ul><h3 id="2-基本写法"><a href="#2-基本写法" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//交换法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// j 记录当前数字下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>            swap(arr, j, j - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 更新当前数字下标</span><br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br><br><span class="hljs-comment">//移动法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-1"><a href="#3-优化-1" class="headerlink" title="3.优化"></a>3.优化</h3><p>移动法本身就是一种优化，不需要每次都交换，一直把比当前数大的数往后移动就好了。</p><blockquote><p>稳定</p></blockquote><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="1.思路"></a>1.思路</h3><p>对插入排序的一种优化，将数组拆分分别做插入排序，不断缩减分组的间隔。<br><em>原理</em></p><div class="note note-primary">            <p>希尔排序与 O(n^2)级排序算法的本质区别：<br>排序算法本质上就是一个消除逆序对的过程。如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对。反过来说，基于交换元素的排序算法要想突破 O(n^2)级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。</p>          </div><p><em>重要性质</em><br>D(k+1)间隔有序的序列，结果D(k)间隔排序后们仍然是D(k+1)间隔有序的：<br><a href="https://zhuanlan.zhihu.com/p/137355984">证明</a></p><h3 id="2-基本写法-1"><a href="#2-基本写法-1" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 间隔序列，在希尔排序中我们称之为增量序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 分组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">groupStartIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; groupStartIndex &lt; gap; groupStartIndex++) &#123;<br>            <span class="hljs-comment">// 插入排序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> groupStartIndex + gap; currentIndex &lt; arr.length; currentIndex += gap) &#123;<br>                <span class="hljs-comment">// currentNumber 站起来，开始找位置</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[currentIndex];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> currentIndex - gap;<br>                <span class="hljs-keyword">while</span> (preIndex &gt;= groupStartIndex &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;<br>                    <span class="hljs-comment">// 向后挪位置</span><br>                    arr[preIndex + gap] = arr[preIndex];<br>                    preIndex -= gap;<br>                &#125;<br>                <span class="hljs-comment">// currentNumber 找到了自己的位置，坐下</span><br>                arr[preIndex + gap] = currentNumber;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-2"><a href="#3-优化-2" class="headerlink" title="3.优化"></a>3.优化</h3><ul><li>对于计算机而言，连续的访问数组元素更加快捷</li><li>增量序列：增量序列的选择会极大地影响希尔排序的效率。增量序列如果选得不好，希尔排序的效率可能比插入排序效率还要低，常用序列有Hibbard，Knuth，Sedgewick等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSortByKnuth</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 找到当前数组需要用到的 Knuth 序列中的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxKnuthNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (maxKnuthNumber &lt;= arr.length / <span class="hljs-number">3</span>) &#123;<br>        maxKnuthNumber = maxKnuthNumber * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 增量按照 Knuth 序列规则依次递减</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> maxKnuthNumber; gap &gt; <span class="hljs-number">0</span>; gap = (gap - <span class="hljs-number">1</span>) / <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-comment">// 从 gap 开始，按照顺序将每个元素依次向前插入自己所在的组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// currentNumber 站起来，开始找位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">// 该组前一个数字的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[preIndex]) &#123;<br>                <span class="hljs-comment">// 向后挪位置</span><br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap;<br>            &#125;<br>            <span class="hljs-comment">// currentNumber 找到了自己的位置，坐下</span><br>            arr[preIndex + gap] = currentNumber;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其平均时间复杂度为n到n^2之间，普遍认为其最好时间复杂度为n^1.3。一般可以认为其是一个nlogn的的排序算法。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="1.思路"></a>1.思路</h3><p><strong>构建大顶堆 &amp; 调整堆</strong><br>构建大顶堆有两种方式：</p><ul><li>方案一：从 0 开始，将每个数字依次插入堆中，一边插入，一边调整堆的结构，使其满足大顶堆的要求；</li><li>方案二：将整个数列的初始状态视作一棵完全二叉树，自底向上调整树的结构，使其满足大顶堆的要求，<strong>更为常用</strong>。</li></ul><h3 id="2-基本实现-2"><a href="#2-基本实现-2" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 构建初始大顶堆</span><br>    buildMaxHeap(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 将最大值交换到数组最后</span><br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">// 调整剩余数组，使其满足大顶堆</span><br>        maxHeapify(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 构建初始大顶堆</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        maxHeapify(arr, i, arr.length);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maxHeapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>    <span class="hljs-comment">// 左子结点下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右子结点下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 记录根结点、左子树结点、右子树结点三者中的最大值下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-comment">// 与左子树结点比较</span><br>    <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; arr[l] &gt; arr[largest]) &#123;<br>        largest = l;<br>    &#125;<br>    <span class="hljs-comment">// 与右子树结点比较</span><br>    <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; arr[r] &gt; arr[largest]) &#123;<br>        largest = r;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-comment">// 将最大值交换为根结点</span><br>        swap(arr, i, largest);<br>        <span class="hljs-comment">// 再次调整交换数字后的大顶堆</span><br>        maxHeapify(arr, largest, heapSize);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-分析"><a href="#3-分析" class="headerlink" title="3.分析"></a>3.分析</h3><p>初始化建堆的时间复杂度为 O(n)<br>重建堆的时间复杂度为 O(nlogn)<br>堆排序总的时间复杂度为 O(nlogn)<br><strong>不稳定</strong></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1.基本思想"></a>1.基本思想</h3><p>从数组中取出一个数，称之为基数（pivot）。遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。</p><h3 id="2-基本写法-2"><a href="#2-基本写法-2" class="headerlink" title="2.基本写法"></a>2.基本写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 如果区域内的数字少于 2 个，退出递归</span><br>    <span class="hljs-keyword">if</span> (start &gt;= end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将数组分区，并获得中间值的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> partition(arr, start, end);<br>    <span class="hljs-comment">// 对左边区域快速排序</span><br>    quickSort(arr, start, middle - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 对右边区域快速排序</span><br>    quickSort(arr, middle + <span class="hljs-number">1</span>, end);<br>&#125;<br><span class="hljs-comment">// 将 arr 从 start 到 end 分区，左边区域比基数小，右边区域比基数大，然后返回中间值的下标</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">// 取第一个数为基数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[start];<br>    <span class="hljs-comment">// 从第二个数开始分区</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 找到第一个大于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) left++;<br>        <span class="hljs-comment">// 找到第一个小于基数的位置</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) right--;<br>        <span class="hljs-comment">// 交换这两个数，使得左边分区都小于或等于基数，右边分区大于或等于基数</span><br>        <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>            exchange(arr, left, right);<br>            left++;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果 left 和 right 相等，单独比较 arr[right] 和 pivot</span><br>    <span class="hljs-keyword">if</span> (left == right &amp;&amp; arr[right] &gt; pivot) right--;<br>    <span class="hljs-comment">// 将基数和轴交换</span><br>    exchange(arr, start, right);<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br><br>作者：力扣 (LeetCode)<br>链接：https:<span class="hljs-comment">//leetcode.cn/leetbook/read/sort-algorithms/eul7hm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><blockquote><p>也可以双指针</p></blockquote><p>平均时间复杂度为 O(nlogn)<br>最坏的时间复杂度为O(n^2)<br>空间复杂度与递归的层数有关，每层递归会生成一些临时变量，所以空间复杂度为O(logn)~O(n)，平均空间复杂度为 O(logn)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="1.思路"></a>1.思路</h3><p>两个数组合并成有序数组可以使用双指针的方式，那么我们可以从以1为数组长度开始合并，最后合成一个有序数组。</p><h3 id="2-基本实现-3"><a href="#2-基本实现-3" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span>[] result = mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将结果拷贝到 arr 数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对 arr 的 [start, end] 区间归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>    <span class="hljs-comment">// 只剩下一个数字，停止拆分，返回单个数字组成的数组</span><br>    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;arr[start]&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 拆分左边区域</span><br>    <span class="hljs-type">int</span>[] left = mergeSort(arr, start, middle);<br>    <span class="hljs-comment">// 拆分右边区域</span><br>    <span class="hljs-type">int</span>[] right = mergeSort(arr, middle + <span class="hljs-number">1</span>, end);<br>    <span class="hljs-comment">// 合并左右区域</span><br>    <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-3"><a href="#3-优化-3" class="headerlink" title="3.优化"></a>3.优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, result);<br>&#125;<br><br><span class="hljs-comment">// 对 arr 的 [start, end] 区间归并排序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] result)</span> &#123;<br>    <span class="hljs-comment">// 只剩下一个数字，停止拆分</span><br>    <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 拆分左边区域，并将归并排序的结果保存到 result 的 [start, middle] 区间</span><br>    mergeSort(arr, start, middle, result);<br>    <span class="hljs-comment">// 拆分右边区域，并将归并排序的结果保存到 result 的 [middle + 1, end] 区间</span><br>    mergeSort(arr, middle + <span class="hljs-number">1</span>, end, result);<br>    <span class="hljs-comment">// 合并左右区域到 result 的 [start, end] 区间</span><br>    merge(arr, start, end, result);<br>&#125;<br><br><span class="hljs-comment">// 将 result 的 [start, middle] 和 [middle + 1, end] 区间合并</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>[] result)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end1</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> end1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 用来遍历数组的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> start2;<br>    <span class="hljs-keyword">while</span> (index1 &lt;= end1 &amp;&amp; index2 &lt;= end) &#123;<br>        <span class="hljs-keyword">if</span> (arr[index1] &lt;= arr[index2]) &#123;<br>            result[index1 + index2 - start2] = arr[index1++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result[index1 + index2 - start2] = arr[index2++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将剩余数字补到结果数组之后</span><br>    <span class="hljs-keyword">while</span> (index1 &lt;= end1) &#123;<br>        result[index1 + index2 - start2] = arr[index1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (index2 &lt;= end) &#123;<br>        result[index1 + index2 - start2] = arr[index2++];<br>    &#125;<br>    <span class="hljs-comment">// 将 result 操作区间的数字拷贝到 arr 数组中，以便下次比较</span><br>    <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>        arr[start] = result[start++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 logn 次，每层执行的比较次数都约等于 n 次，所以时间复杂度是&#x3D;&#x3D;O(nlogn)。</p><p>分析归并的过程可知，归并排序是一种稳定的排序算法。</p><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>归并排序的过程必然可以消除逆序对，且不会进行多余的交换，因此可以从其入手，通过求数组某一范围内的逆序对个数，排序后归并，再次求逆序对个数。</p><p><strong>数组中的逆序对</strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> mergeSort(nums);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">return</span> mergeSort(nums, result, <span class="hljs-number">0</span>, length-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span>[] result,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start == end) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> mergeSort(nums,result,start,middle);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightCount</span> <span class="hljs-operator">=</span> mergeSort(nums,result,middle+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mergeCount</span> <span class="hljs-operator">=</span> merge(nums,result,start,end);<br>        <span class="hljs-keyword">return</span> leftCount+mergeCount+rightCount;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span>[] result,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start2</span> <span class="hljs-operator">=</span> middle+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index2</span> <span class="hljs-operator">=</span> start2;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(index1&lt;=middle &amp;&amp; index2&lt;=end)&#123;<br>            <span class="hljs-keyword">if</span>(nums[index1]&lt;=nums[index2])&#123;<br>                result[index1+index2-start2] = nums[index1++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result[index1+index2-start2] = nums[index2++];<br>                count += middle-index1+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index1&lt;=middle)&#123;<br>            result[index1+index2-start2] = nums[index1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index2&lt;=end)&#123;<br>            result[index1+index2-start2] = nums[index2++];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;i++)&#123;<br>            nums[i] = result[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h3 id="1-思路-6"><a href="#1-思路-6" class="headerlink" title="1.思路"></a>1.思路</h3><p>统计每个数的大小和出现的次数，然后按从小到达排列。</p><h3 id="2-基本实现-4"><a href="#2-基本实现-4" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 判空及防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定计数范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[range];<br>    <span class="hljs-comment">// 遍历 arr 中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span><br>        counting[element - min]++;<br>    &#125;<br>    <span class="hljs-comment">// 记录前面比自己小的数字的总数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">preCounts</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; range; i++) &#123;<br>        <span class="hljs-comment">// 当前的数字比下一个数字小，累计到 preCounts 中</span><br>        preCounts += counting[i];<br>        <span class="hljs-comment">// 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。</span><br>        counting[i] = preCounts - counting[i];<br>    &#125;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// counting[element - min] 表示此元素在结果数组中的下标</span><br>        result[counting[element - min]] = element;<br>        <span class="hljs-comment">// 更新 counting[element - min]，指向此元素的下一个下标</span><br>        counting[element - min]++;<br>    &#125;<br>    <span class="hljs-comment">// 将结果赋值回 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-优化-4"><a href="#3-优化-4" class="headerlink" title="3.优化"></a>3.优化</h3><p>在计算元素在最终结果数组中的下标位置这一步，不是计算初始下标位置，而是计算最后一个下标位置。最后倒序遍历 arr 数组，逐个将 arr 中的元素放到最终位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定计数范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[range];<br>    <span class="hljs-comment">// 遍历 arr 中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : arr) &#123;<br>        <span class="hljs-comment">// 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内</span><br>        counting[element - min]++;<br>    &#125;<br><br><span class="hljs-comment">//关键</span><br>    <span class="hljs-comment">// 每个元素在结果数组中的最后一个下标位置 = 前面比自己小的数字的总数 + 自己的数量 - 1。我们将 counting[0] 先减去 1，后续 counting 直接累加即可</span><br>    counting[<span class="hljs-number">0</span>]--;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; range; i++) &#123;<br>        <span class="hljs-comment">// 将 counting 计算成当前数字在结果中的最后一个下标位置。位置 = 前面比自己小的数字的总数 + 自己的数量 - 1</span><br>        <span class="hljs-comment">// 由于 counting[0] 已经减了 1，所以后续的减 1 可以省略。</span><br>        counting[i] += counting[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-comment">// 从后往前遍历数组，通过 counting 中记录的下标位置，将 arr 中的元素放到 result 数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// counting[arr[i] - min] 表示此元素在结果数组中的下标</span><br>        result[counting[arr[i] - min]] = arr[i];<br>        <span class="hljs-comment">// 更新 counting[arr[i] - min]，指向此元素的前一个下标</span><br>        counting[arr[i] - min]--;<br>    &#125;<br>    <span class="hljs-comment">// 将结果赋值回 arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        arr[i] = result[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计数排序的时间复杂度为 O(n + k)，k 表示数据的范围大小。<br>用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 O(n + k)。</p><blockquote><p>计数排序只适用于数据范围不大的场景，否则count数组会很大。如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。</p></blockquote><blockquote><p>计数排序凭什么能够突破 O(nlogn)的下界呢？<br>如果基于比较来进行排序，无论怎么优化都无法突破 O(nlog n)的下界。计数排序和基于比较的排序算法相比，根本区别就在于：它不是基于比较的排序算法，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。</p></blockquote><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="1-思路-7"><a href="#1-思路-7" class="headerlink" title="1.思路"></a>1.思路</h3><p>类似于计数排序，但是每次只计算数值特定位数（基数）的出现次数和大小，这样，从低位往高位循环排列，最后就可以得到一个有序的数组。</p><h3 id="2-基本实现-5"><a href="#2-基本实现-5" class="headerlink" title="2.基本实现"></a>2.基本实现</h3><ul><li>「最低位优先法」，简称 <code>LSD (Least significant digital)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找出最长的数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-keyword">if</span> (Math.abs(value) &gt; max) &#123;<br>            max = Math.abs(value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算最长数字的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxDigitLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>        maxDigitLength++;<br>        max /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-comment">// 使用计数排序算法对基数进行排序，下标 [0, 18] 对应基数 [-9, 9]</span><br>    <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">19</span>];<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigitLength; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-comment">// 下标调整</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> value / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            counting[radix]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; counting.length; j++) &#123;<br>            counting[j] += counting[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 使用倒序遍历的方式完成计数排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 下标调整</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[j] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            result[--counting[radix]] = arr[j];<br>        &#125;<br>        <span class="hljs-comment">// 计数排序完成后，将结果拷贝回 arr 数组</span><br>        System.arraycopy(result, <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, arr.length);<br>        <span class="hljs-comment">// 将计数数组重置为 0</span><br>        Arrays.fill(counting, <span class="hljs-number">0</span>);<br>        dev *= <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为此处考虑了加入负数的排序，所以基数应该为-9~9，共19位数，所以创建一个19长度的count数组。求出绝对值最大的数的长度后，按照这个长度进行循环的计数排序并重置数组。</p></blockquote><ul><li>「最高位优先法」，简称 <code>MSD (Most significant digital)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 找到最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (Math.abs(value) &gt; max) &#123;<br>                max = Math.abs(value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算最大长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDigitLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>            maxDigitLength++;<br>            max /= <span class="hljs-number">10</span>;<br>        &#125;<br>        radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxDigitLength);<br>    &#125;<br><br>    <span class="hljs-comment">// 对 arr 数组中的 [start, end] 区间进行基数排序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> position)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start == end || position == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 使用计数排序对基数进行排序</span><br>        <span class="hljs-type">int</span>[] counting = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">19</span>];<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[end - start + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, position - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-comment">// MSD, 从最高位开始</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[i] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            counting[radix]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; counting.length; j++) &#123;<br>            counting[j] += counting[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// 拷贝 counting，用于待会的递归</span><br>        <span class="hljs-type">int</span>[] countingCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[counting.length];<br>        System.arraycopy(counting, <span class="hljs-number">0</span>, countingCopy, <span class="hljs-number">0</span>, counting.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> end; i &gt;= start; i--) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> arr[i] / dev % <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>            result[--counting[radix]] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">// 计数排序完成后，将结果拷贝回 arr 数组</span><br>        System.arraycopy(result, <span class="hljs-number">0</span>, arr, start, result.length);<br>        <span class="hljs-comment">// 对 [start, end] 区间内的每一位基数进行递归排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; counting.length; i++) &#123;<br>            radixSort(arr, i == <span class="hljs-number">0</span> ? start : start + countingCopy[i - <span class="hljs-number">1</span>], start + countingCopy[i] - <span class="hljs-number">1</span>, position - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="3. 复杂度"></a>3. 复杂度</h3><p>无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 O(n + k)，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 k &#x3D; 10，如果是对包含负数的数组排序，则 k &#x3D; 19。</p><p>所以基数排序的时间复杂度为&#x3D;&#x3D;O(d(n + k))&#x3D;&#x3D;(d 表示最长数字的位数，k 表示每个基数可能的取值范围大小)。<br>使用的空间和计数排序是一样的，空间复杂度为 &#x3D;&#x3D;O(n + k)&#x3D;&#x3D;（k 表示每个基数可能的取值范围大小）。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="1-思路-8"><a href="#1-思路-8" class="headerlink" title="1.思路"></a>1.思路</h3><p>将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶;遍历数组，将每个数字装入桶中;对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等;最后按照顺序将所有桶内的数字合并起来。</p><blockquote><p>桶排序在实际工作中的应用较少，不仅因为它需要借助于其他排序算法，还因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。</p></blockquote><h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2.优化"></a>2.优化</h3><p>这两个因素会直接影响到桶排序的内存和效率：<br><strong>桶的数量</strong>：桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。具体设置多少个桶需要根据实际情况决定。</p><p><strong>桶的数据结构</strong>：如果将桶的数据结构设置为数组，那么每个桶的长度必须设置为待排序数组的长度，因为我们需要做好最坏的打算，即所有的数字都被装入了同一个桶中，所以这种方案的空间复杂度会很高。</p><ul><li>以数组作为桶</li></ul><p>默认以原数组的长度作为桶数组的长度，但这样很可能会造成大量的空间浪费。因此可以对此做优化，声明时所有的数组都为空，当需要添加数字时，不断扩容，并加入新数字。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 判空及防止数组越界</span><br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 找到最大值，最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) max = arr[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; min) min = arr[i];<br>    &#125;<br>    <span class="hljs-comment">// 确定取值范围</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> max - min;<br>    <span class="hljs-comment">// 设置桶的数量，这里我们设置为 100 个，可以根据实际情况修改。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketAmount</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 桶和桶之间的间距</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> range * <span class="hljs-number">1.0</span> / (bucketAmount - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 用二维数组来装桶，第一个维度是桶的编号，第二个维度是桶中的数字。初始化长度为 0</span><br>    <span class="hljs-type">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bucketAmount][];<br>    <span class="hljs-comment">// 装桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-comment">// 找到 value 属于哪个桶</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((value - min) / gap);<br>        buckets[index] = add(buckets[index], value);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 对每个桶内的数字进行单独排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucketAmount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">null</span> || buckets[i].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 这里需要结合其他排序算法，例如：插入排序</span><br>        insertSort(buckets[i]);<br>        <span class="hljs-comment">// 排序完成后将桶内的结果收集起来</span><br>        System.arraycopy(buckets[i], <span class="hljs-number">0</span>, arr, index, buckets[i].length);<br>        index += buckets[i].length;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 数组扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] add(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> num) &#123;<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;num&#125;;<br>    <span class="hljs-type">int</span>[] newArr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>    newArr[arr.length] = num;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br><span class="hljs-comment">// 插入排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以链表为桶，则创建一个：<code>HashMap&lt;Integer,Integer&gt;</code>，链表不需要扩容，但排序慢，一般采用插入排序。</li><li>折中的方案:装桶时用链表，桶内排序用数组。</li></ul><h3 id="3-复杂度-1"><a href="#3-复杂度-1" class="headerlink" title="3.复杂度"></a>3.复杂度</h3><ul><li>第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 O(n)，空间复杂度 O(1)。</li><li>第二步：装桶的过程需要遍历一轮数组，时间复杂度 O(n)，空间复杂度与桶的数量以及数据结构有关，设桶的数量为 k，如果使用 k 个长度为 n 的数组作为桶，则空间复杂度为 O(kn)，如果采用 ArrayList 或 LinkedList 来装桶，或者采用初始长度为 0 ，装桶时不断扩容的数组，则空间复杂度为 O(n)。</li><li>第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为 n&#x2F;k，如果采用 O(n^2)级排序算法，则每个桶内排序的时间复杂度为 O((n&#x2F;k)^2)，所有桶完成排序的时间复杂度为 O(k(n&#x2F;k)^2，即 O(n^2 &#x2F; k)。<ul><li>如果采用O(nlogn) 级排序算法，每个桶内排序的时间复杂度 O((n&#x2F;k) log (n&#x2F;k))，所有桶完成排序的时间复杂度为 O(k(n&#x2F;k) log (n&#x2F;k))，即 O(n log (n&#x2F;k))。</li><li>在桶的数量合适的情况下，时间复杂度 O(n^2 &#x2F; k)和 O(nlog(n&#x2F;k)) 都约等于 O(n)。</li><li>桶内排序的空间复杂度也和具体的排序算法有关，O(1)O(1) 或者 O(n)O(n)。</li></ul></li><li>第四步：如果采用 LinkedList 转 int[] 再排序这种方式，由于转换过程需要一轮遍历，所以会增加O(n)的时间复杂度和O(n)的空间复杂度。</li></ul><p><strong>综上可知，桶排序的时间复杂度为 O(n)，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 O(n log n) 级的排序算法快。空间复杂度为 O(n)。</strong></p><div class="note note-primary">            <p>个人理解，这里复杂度为n的方法都是利用了数字本身的性质，即每个待比较的对象都是利用数字进行比较，这个数字是一个绝对且具有传递性（x&gt;y,y&gt;z，则x&gt;z）的属性，所以我们可以直接根据该属性为对象排到其相应的位置。</p>          </div><h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><table><thead><tr><th>算法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡</td><td>n2</td><td>1</td><td>稳定（取决于实现）</td></tr><tr><td>选择</td><td>n2</td><td>1</td><td>不稳定（另开一个数组时稳定）</td></tr><tr><td>插入</td><td>n2</td><td>1</td><td>稳定</td></tr><tr><td>希尔</td><td>nlogn</td><td>1</td><td>不稳定</td></tr><tr><td>堆</td><td>nlogn</td><td>1</td><td>不稳定</td></tr><tr><td>快排</td><td>nlogn</td><td>logn</td><td>不稳定</td></tr><tr><td>归并</td><td>nlogn</td><td>n</td><td>稳定</td></tr><tr><td>计数</td><td>n+k</td><td>n+k</td><td>稳定</td></tr><tr><td>基数</td><td>d(n+k)</td><td>n+k</td><td>稳定</td></tr><tr><td>桶</td><td>n</td><td>n</td><td>稳定</td></tr></tbody></table><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><code>swap(int[] arr,int l,int r)</code>其中l和r不能相等，否则相当于与自己异或，等于0。</p><h1 id="三、工业级排序"><a href="#三、工业级排序" class="headerlink" title="三、工业级排序"></a>三、工业级排序</h1><h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><h2 id="1-总体流程"><a href="#1-总体流程" class="headerlink" title="1.总体流程"></a>1.总体流程</h2><p><code>Arrays</code> 类中有很多个 <code>sort</code> 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">int</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">long</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">long</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">short</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">short</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">char</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">char</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">byte</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">byte</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">float</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">float</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">double</span>[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(<span class="hljs-type">double</span>[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(Object[])</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(Object[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(T[], Comparator)</span>  <br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span> <span class="hljs-params">(T[], <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, Comparator)</span><br></code></pre></td></tr></table></figure><blockquote><p>这些 sort 函数可以分为两类：</p><ul><li>对基本类型的排序（int、long、short、char、byte、float、double），对基本类型的排序是通过调用对应的 <code>DualPivotQuicksort.sort()</code> 函数完成的。</li><li>对非基本类型的排序（Object、T），对非基本类型的排序采用的是 TimSort 或者归并排序，在 JDK 1.7 之前，默认采用归并排序，JDK 1.7 及之后，默认采用 TimSort。</li><li>但可以通过设置 JVM 参数 <code>-Djava.util.Arrays.useLegacyMergeSort=true</code> 继续使用归并排序。</li></ul></blockquote><h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2.基本类型"></a>2.基本类型</h2><p><code>dualPivotQuicksort</code>源码很长，是Arrays.sort在处理基本类型的排序时的实现。<br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89/Pasted-image-20230313102458.png"></p><h3 id="TimSort"><a href="#TimSort" class="headerlink" title="TimSort"></a>TimSort</h3><p><code>TimSort</code>的主要思想是：通过遍历数组，将数组拆分成若干个单调递增的子数组。每一块称为一个 run。拆分完成后，再将 run 两两合并起来。<br><code>TimSort</code> 在对<strong>部分有序</strong>的数组进行排序时，速度很快。因为整个数组可以拆分成少量的 run 小块，将其合并即可完成排序。我们称这一类只能被拆分成少量 run 小块的数组是「高度结构化」的 (<strong>highly structured</strong>)。</p><p>在拆分 run 小块的过程中，有两个条件会<strong>停止调用 TimSort</strong>：</p><ul><li>连续相同的数字的数量到达了33个：</li><li>排序时以 k 为索引遍历整个数组，比较相邻数字的大小关系：<ul><li>如果数字在递增，记录下此 run 小块</li><li>如果数字在递减，记录下此 run 小块，并翻转这部分子数组</li><li>如果数字相等，记录下此 run 小块，并判断连续相等的数字是否达到了 MAX_RUN_LENGTH 个，如果达到了 <code>MAX_RUN_LENGTH</code>，则不再使用 TimSort，改为调用 sort(int[] a, int left, int right, boolean leftmost) (leftMost参数)函数进行排序。<br>  在这个被调用的方法中，有对重复数字过多时的排序改进。</li></ul></li><li>run的块数量达到了<code>MAX_RUN_COUNT</code>(67)，如果run块的数量超过了67，说明其并不是高度结构化数据，不适合TimSort。</li></ul><div class="note note-primary">            <p>总结：timsort是对归并算法的优化，通过将归并的分块变成直接使用数组中的递增，递减数组。但若这样的分块过多或重复数字过多，则退化成其他排序方法。</p>          </div><h3 id="插入排序-amp-双插入排序"><a href="#插入排序-amp-双插入排序" class="headerlink" title="插入排序 &amp; 双插入排序"></a>插入排序 &amp; 双插入排序</h3><p>首先仍然是判断数组长度，如果小于 INSERTION_SORT_THRESHOLD（它的值是 47），则采用插入排序算法或双插入排序算法进行排序。如果数据量达到了 47，则采用双轴快排算法进行排序。这是因为<strong>插入排序在数据量小的时候，排序性能比较好</strong>。</p><p><strong>leftMost</strong>表示当前排序的数据范围是否是待排序区间的最左端。如果是最左端，则采用插入排序算法对其排序，否则采用双插入排序的算法进行排序。</p><p>插入排序和双插入排序的区别是（以排升序为例）：</p><ul><li>插入排序时，每次从待排序的数字中取一个数字，将其插入到前方已经有序的数组中。（移动法）</li><li>双插入排序时，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。</li></ul><blockquote><p>当前排序的数据范围如果不是待排序区间最左端，则保证left-1不越界，且left-1的数值一定比left及其右边的小，从而保证插入排序不会越界。</p><p>双轴快排会把数组分为左中右三个区域，分区之后，左边区域的任何一个数字都小于中间区域，中间区域的任何一个数字都小于右边区域，所以每个待排序区间的前一个数字都承担了「哨兵」的职责。</p><p>这也正是 <code>leftMost</code> 参数存在的意义：<strong>因为最左端区间没有「哨兵」，所以只有对非最左端区间排序时，才能采用这种不做边界检查的双插入排序</strong>。</p></blockquote><h3 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h3><p>双轴快排每轮选取两个轴 pivot1、pivot2 (pivot1 &lt; pivot2)，然后以两个轴为分界，将数组分为左中右三个区域。交换三个区域内的数字，使得三个区域分别属于区间 (-∞, pivot1)、[pivot1, pivot2]、(pivot2, +∞)。然后再对左中右区域不断重复此过程，直至排序完成。</p><p>通过从中间位置往前和往后分别走两次数组长度的 1&#x2F;7步长，取到了5个备选轴的下标：e1、e2、e3、e4、e5。</p><p>选择第二、四个数做轴，如果五个备选轴中，出现了相等元素，用单轴进行分区。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><blockquote><ol><li><p>当数组长度达到 286 ，并且不存在较多连续相等元素，并且「高度结构化」时，采用类似 TimSort 的算法进行排序。<br>其中用到的 TimSort 思想是：先拆分出单调递增的 run 小块，然后将 run 小块两两合并完成排序，合并时原数组和辅助数组会交替合并。</p></li><li><p>当数组长度小于 INSERTION_SORT_THRESHOLD（即 47）时，采用插入排序或双插入排序。<br>其中，双插入排序的思想是，每次从待排序的数字中取两个数字，并将这两个数字从大到小排好序。先将大的数字插入到前方已经有序的数组中，然后小的数字直接从大的数字插入的位置开始，向前寻找插入位置。</p></li><li><p>否则，采用双轴快排进行排序。双轴快排的思想是：每轮选取两个轴 pivot1、pivot2 (pivot1 &lt; pivot2)，然后以两个轴为分界，将数组分为左中右三个区域。交换三个区域内的数字，使得三个区域分别属于区间 (-∞, pivot1)、[pivot1, pivot2]、(pivot2, +∞)。然后再对左中右区域不断重复此过程，直至排序完成。<br>分区后，如果中间区域过大（大于数组长度的 4&#x2F;7），则将中间区域再次分成三个区域： [pivot1, pivo1]、(pivot1, pivot2)、[pivot2,pivot2]，只让 (pivot1, pivot2) 区间参与下一轮双轴快排。<br>如果整个数组中存在较多的相等元素，则不再取两个轴，而是只取一个轴，按照 (-∞, pivot)、[pivot, pivot]、(pivot, +∞)(−∞,pivot)、[pivot,pivot]、(pivot,+∞) 进行分区。然后对左右两个区域不断重复此过程，直至排序完成。</p></li></ol></blockquote><h1 id="三、排序-x2F-二分搜索问题"><a href="#三、排序-x2F-二分搜索问题" class="headerlink" title="三、排序&#x2F;二分搜索问题"></a>三、排序&#x2F;二分搜索问题</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a><br>计数后堆排序解决。</p><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a><br>以任意一点为节点，其左右两侧必然有一侧是单调递增的。考察看目标数在不在这个范围内。</p><p><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a><br>元素的右上角相当于一个二叉搜索树的根节点。</p><p><a href="https://leetcode.cn/problems/wiggle-sort/">280. 摆动排序</a><br><a href="https://leetcode.cn/problems/wiggle-sort-ii/">324. 摆动排序 II</a></p><ol><li>先排序，将数组分前后两段（前段长度 &#x3D;&#x3D; 后段 或 ＞ 后段），错位插入。</li><li>对于Ⅱ，注意，如果某个中位数的重复次数等于数组的长度，可能会导致错位插入。因此应该将两个数组倒置，这样中位数就在前段的头部和后段的末尾，再错位插入就无法相遇了。</li></ol><p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a><br>双堆</p><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p><ol><li>堆</li><li>快排，并剪枝</li></ol><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><ol><li>利用归并排序，每次归并两个线段时，可以通过索引判断这个数的逆序对。</li><li>离散化树状数组：一个逆序对，即一个数字后面有多少个比该数小的元素，如果采用从后往前填入，则可以很方便的查询逆序对。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reversePairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        System.arraycopy(nums, <span class="hljs-number">0</span>, tmp, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-comment">//对原数进行排序，找到每一个值在树状数组中的索引+1。</span><br>        Arrays.sort(tmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            nums[i] = Arrays.binarySearch(tmp, nums[i]) + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 建立树状数组</span><br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-comment">//从后开始搜索每一个原值在树状数组中的位置，并添加比该值大的数。</span><br>            ans += bit.query(nums[i] - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//添加该数</span><br>            bit.update(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] tree;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += tree[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            ++tree[x];<br>            x += lowbit(x);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a><br>二分搜索，遇到相等的值</p><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素</a><br>对于任意一个数，其左上角部分的元素肯定是比该数小的。</p><ol><li>归并排序，直接对各行进行归并，找到第k个即可返回。</li><li>从右上角开始应用二叉搜索树的性质找分界线。</li></ol><p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a><br>相当于寻找第k小的数（k&#x3D;(m+n)&#x2F;2 || k&#x3D;(m+n+1)&#x2F;2）。<br>可以先将两个数组的前k个数都取出来，然后每次淘汰某个数组中k&#x2F;2的人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLength</span> <span class="hljs-operator">=</span> length1 + length2;<br>        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midIndex</span> <span class="hljs-operator">=</span> totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> median;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">midIndex1</span> <span class="hljs-operator">=</span> totalLength / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">median</span> <span class="hljs-operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">return</span> median;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getKthElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><br><span class="hljs-comment">         * 这里的 &quot;/&quot; 表示整除</span><br><span class="hljs-comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><br><span class="hljs-comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="hljs-comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><br><span class="hljs-comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><br><span class="hljs-comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kthElement</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-keyword">if</span> (index1 == length1) &#123;<br>                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index2 == length2) &#123;<br>                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Math.min(nums1[index1], nums2[index2]);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> k / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newIndex1</span> <span class="hljs-operator">=</span> Math.min(index1 + half, length1) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newIndex2</span> <span class="hljs-operator">=</span> Math.min(index2 + half, length2) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot1</span> <span class="hljs-operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（数学）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><p><a href="https://leetcode.cn/problems/recursive-mulitply-lcci/">面试题 08.05. 递归乘法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B)</span> &#123;<br>        <span class="hljs-keyword">return</span> B!=<span class="hljs-number">0</span>?multiply(A&lt;&lt;<span class="hljs-number">1</span>,B&gt;&gt;<span class="hljs-number">1</span>)+((B&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>?A:<span class="hljs-number">0</span>):<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（贪心）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、区间贪心"><a href="#一、区间贪心" class="headerlink" title="一、区间贪心"></a>一、区间贪心</h1><p>优选问题一般体现为：</p><ul><li>相同成本，不同收益（871.加油次数）</li><li>相同收益，不同成本（630.课程表3）</li><li>相同成本和收益，但某种选择对后续的选择更有利。</li><li>有选择限制：如必须在某时间前才能选择&#x2F;必须到达某处才能选择</li></ul><p>贪心的思路也因此分几种：</p><ul><li>先尽可能地不选择，等遇到选择限制时，再选择最优选择。</li><li>先尽可能地选择，等遇到选择限制时，再替换现有地选择。</li></ul><p><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/">871. 最低加油次数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minRefuelStops</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> startFuel, <span class="hljs-type">int</span>[][] stations)</span> &#123;<br>        <span class="hljs-comment">//加油站排序</span><br>        Arrays.sort(stations,(a,b) -&gt; a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">//当前可以添加的燃料集合（最大堆）</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; b-a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sBound</span> <span class="hljs-operator">=</span> stations.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//当前无法到达目的</span><br>        <span class="hljs-keyword">while</span>(startFuel&lt;target)&#123;<br>            <span class="hljs-comment">//将当前可以加到的燃料添加到堆中</span><br>            <span class="hljs-keyword">while</span>(sIndex&lt;sBound &amp;&amp; stations[sIndex][<span class="hljs-number">0</span>]&lt;=startFuel)&#123;<br>                queue.add(stations[sIndex++][<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//优先加最大的燃料，没燃料可加时返回-1</span><br>            <span class="hljs-keyword">if</span>(queue.isEmpty())&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//加燃料</span><br>                startFuel += queue.poll();<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/course-schedule-iii/">630. 课程表 III</a><br>贪心思路引导：</p><ul><li>如果每节课需要的时间为0，则从开始不停地<strong>一直学</strong>肯定能在各截止时间前完成。</li><li>时间相同时先后顺序：假如现实中每节课需要的时间相同且不为0，则优先策略肯定是先学截止时间早的。</li><li>先后交叠时时间不同：如果学第x节课时，发现时间不够。如果发现前面的某节课耗时比本节课长，说明放弃前面的那节课必然可以学第x节课，可以放弃前面课程来学学x课程，此时则必然对后面的课程选择更有利。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">scheduleCourse</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] courses)</span> &#123;<br>    <span class="hljs-comment">//对截止时间进行顺序排序</span><br>        Arrays.sort(courses, (a, b) -&gt; a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">//大顶堆优先队列，表示已经学习的所有课程</span><br>        PriorityQueue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; b - a);<br>        <span class="hljs-comment">// 优先队列中所有课程的总时间，表示目前学习的课程的总时长</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] course : courses) &#123;<br>        <span class="hljs-comment">//本节课的耗时和截止时间</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ti</span> <span class="hljs-operator">=</span> course[<span class="hljs-number">0</span>], di = course[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//如果本节课可以学</span><br>            <span class="hljs-keyword">if</span> (total + ti &lt;= di) &#123;<br>                total += ti;<br>                q.offer(ti);<br>                <span class="hljs-comment">//如果不能学，则查看上一节课与本节课的耗时，调整课程</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!q.isEmpty() &amp;&amp; q.peek() &gt; ti) &#123;<br>                total -= q.poll() - ti;<br>                q.offer(ti);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后</span><br>        <span class="hljs-keyword">return</span> q.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a><br>按照截止时间排序，覆盖时优先保留前面的。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a><br>对气球的末尾排序，每次射箭优先射击尾部边缘，对于刁钻的边界条件需要先将第一个气球打破。</p><p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a><br>每次跳跃时，衡量目的跳跃点可以提供的 “最远距离”来选择目的跳跃点，当可以直接跳到末尾时返回。</p><p><a href="https://leetcode.cn/problems/minimum-number-of-food-buckets-to-feed-the-hamsters/">2086. 从房屋收集雨水需要的最少水桶数</a><br>为一个房屋添加水桶时，显然应该添加在其右侧，这样才能尽可能照顾到后面的房子。但如果其右侧没有空位时，则妥协地添加到其左侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumBuckets</span><span class="hljs-params">(String hamsters)</span> &#123;<br>        <span class="hljs-type">char</span>[] hamster = hamsters.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> hamster.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">filled</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//如果当前位置是房子</span><br>            <span class="hljs-keyword">if</span>(hamster[i] == <span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>                <span class="hljs-comment">//如果房子前面有水桶</span><br>                <span class="hljs-keyword">if</span>(filled == i-<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//如果房子后面有空位</span><br>                    <span class="hljs-keyword">if</span>(i&lt;n-<span class="hljs-number">1</span> &amp;&amp; hamster[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                        filled = i+<span class="hljs-number">1</span>;<br>                        ans++;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//如果房子前面有空位</span><br>                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; hamster[i-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                            filled = i-<span class="hljs-number">1</span>;<br>                            ans++;<br>                            <span class="hljs-comment">//都没有则返回失败</span><br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、过程贪心"><a href="#二、过程贪心" class="headerlink" title="二、过程贪心"></a>二、过程贪心</h1><p><a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/">1605. 给定行和列的和求可行矩阵</a><br>优先将行列中还可以填入的数字填入，具体地：遍历矩阵，每次取当前行，列中较小值，然后将对应行，列的和减去该值。</p><p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></p><ol><li>一次遍历，从左往右发糖果时贪心的思路：<ul><li>遇到递增的分数，每次给孩子比上一个人多一个糖果即可，如果孩子比上一个人分数低，则直接分一个。</li><li>但是如果后面的孩子分数更低，却无法分0个，导致无解。我们可以通过记录递减孩子队列的长度，最后将所有递减队列中的孩子的糖果提高到0以上，此时并不会破坏递增序列中的摆放。</li></ul></li><li>两次遍历，题目的要求本质上是两个条件：<ul><li>如果右边的孩子比左边的孩子分数高，则糖果更多，递增序列。</li><li>如果左边的孩子比右边的孩子分数高，则糖果更多，递减序列。</li><li>分别使用条件处理后，将两侧的分数合并取最高值即可。</li></ul></li></ol><h1 id="三、数值贪心"><a href="#三、数值贪心" class="headerlink" title="三、数值贪心"></a>三、数值贪心</h1><p><a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></p><ol><li>对于相邻两个数字，其对结果的长度影响相同，肯定优先保留数字小的。</li><li>对于不相邻的两个数字，如移除1468中的4，8，会得到168和146的结果，所以比较不相邻的两个数字是没有意义的，移除结果仍取决于6这个数字。</li><li>确定贪心思路，为了让前面的数尽可能小，每个数与前面的数对比，如果其更大说明其更应该被移除，后面的数再与前面的数对比，维护一个单调递增的队列，直到后面的数比前面的数小，则说明前面这个数必须移除了。（因为移除后面的数效果肯定不如移除这个数）。</li></ol><p><a href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a><br>对于每一个数：</p><ul><li>如果其右边有比该数大的数，则可以与其交换得到更大的数。</li><li>如果其右边有若干个比该数大的数，则选择其中最大的数与其交换。</li><li>如果其右边有若干个相同的最大数，选择其中最左侧的数。</li></ul><p>对于整体序列：</p><ul><li>如果上面这种交换发生在越左侧的数上则越有利。</li></ul><p>为了维护上面这些规则：</p><ul><li>从右往左遍历，维护最大值，每次就可以判断当前值是否可以与后面的值交换。注意处理，遇到等于最大值的数，我们不更新max索引（取最右侧的最大值）。每次遇到可交换的，则将这次交换作为最终交换（越左侧数与后面的数交换得到的数越大）。</li></ul><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/">2457. 美丽整数的最小增量</a><br>注意处理技巧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">makeIntegerBeautiful</span><span class="hljs-params">(<span class="hljs-type">long</span> n, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">//当前数字</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-comment">//当前可能考虑的进位</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获取当前sum</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> getSum(cur);<br>            <span class="hljs-comment">//若不满足，获取下一个可行的数</span><br>            <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>                cur = cur + unit-(cur%unit);<br>                unit *= <span class="hljs-number">10</span>;<br>                <span class="hljs-comment">//若满足，则直接返回</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> cur-n;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//计算各位的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            sum += n%<span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a><br>每个数都是一个32位长的比特串，两个数做异或时，越左边的位出现比特值不同则结果会更大。考虑使用前缀树用于比特位比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            root.add(num);<br>            ans = Math.max(ans,root.max(num));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>&#123;<br>    Trie[] next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span>&#123;<br>        next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (num&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(root.next[temp] == <span class="hljs-literal">null</span>)&#123;<br>                root.next[temp] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>            &#125;<br>            root = root.next[temp];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (num&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(root.next[<span class="hljs-number">1</span>-temp] != <span class="hljs-literal">null</span>)&#123;<br>                ans |= <span class="hljs-number">1</span>&lt;&lt;i;<br>                root = root.next[<span class="hljs-number">1</span>-temp];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.next[temp] != <span class="hljs-literal">null</span>)&#123;<br>                root = root.next[temp];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-product-after-k-increments/">2233. K 次增加后的最大乘积</a></p><ol><li>使用最小堆，每次增加最小的数</li><li>排序，顺序增加(也可批量增加)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-keyword">if</span>(index == n || nums[index] != last)&#123;<br>                index = <span class="hljs-number">0</span>;<br>                last = nums[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[index] == last)&#123;<br>                nums[index++]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            ans = (ans * nums[i])%MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/stone-game-vi/">1686. 石子游戏 VI</a><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89/Pasted-image-20230302134806.png"><br>为石头处理价值，排序，两者依次选择价值最大的石头即可。<br>但要注意，最后能否获胜</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stoneGameVI</span><span class="hljs-params">(<span class="hljs-type">int</span>[] aliceValues, <span class="hljs-type">int</span>[] bobValues)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> aliceValues.length;<br>        Integer[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            temp[i] = aliceValues[i]+bobValues[i];<br>        &#125;<br>        Arrays.sort(temp,(a,b) -&gt; b - a);<br>        <span class="hljs-comment">//alice与bob的价值差为alice[i]+bob[i]-sumbob;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                diff += temp[i];<br>            &#125;<br>        &#125;<br>        diff -= Arrays.stream(bobValues).sum();<br>        <span class="hljs-keyword">if</span>(diff &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(diff == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><p><a href="https://leetcode.cn/problems/construct-k-palindrome-strings/">1400. 构造 K 个回文字符串</a><br>每有一个奇数个数的字符，必然有一个对应的回文串，其决定了回文串数量的下线，而字符串总长决定了回文串数量的上线。<br>只需要保证<code>s.length()&lt;k</code>以及<code>奇数字符个数&lt;=k</code></p><p><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></p><ol><li>按身高从小到大摆放：前排的矮子不会影响到高子前面的空位。比当前人矮的人都已经排好了，当前人也知道自己前面还有多少高个子没排好，因此当前人可以方便找到自己的最终位置。<ul><li>一个人的坐标x &#x3D; 其前面比它大的数a（已知） + 其前面比它小的数b，所以只需要从小到达摆放，就可以确定其前面比它小的数的数量b。</li><li>具体的：<ul><li>将人按身高大小hi从矮到高排列。</li><li>相同身高则按ki从大到小排列，ki小的最终在前面，从而影响b的判断，因此先摆放ki大的。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> people.length;<br>        Arrays.sort(people,(a,b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> b[<span class="hljs-number">1</span>]-a[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] person:people)&#123;<br>            <span class="hljs-comment">//前面比当前人高的人,也就是前面需要留出的空位</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> person[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-comment">//这里主要要判断为空在执行操作，因为就算需要留出的空位数达到了，也要等到下一个空位插入该值</span><br>                <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-literal">null</span>)&#123;<br>                    space--;<br>                    <span class="hljs-keyword">if</span>(space == -<span class="hljs-number">1</span>)&#123;<br>                        ans[i] = person;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>按身高从大到小摆放：后排的矮子不会影响前排的高个子，比当前人高的（或相等）都已经排好了，直接插入到他们中间即可。<ul><li>将人的身高按从大到小，相同身高则先取会摆放在前排的。</li><li>使用list维护一个动态队列，从高到矮放入，每次放入时，根据其ki决定位置</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] reconstructQueue(<span class="hljs-type">int</span>[][] people) &#123;<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span>[] b)</span>&#123;<br>                <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>]-a[<span class="hljs-number">0</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;);<br>        List&lt;<span class="hljs-type">int</span>[]&gt; array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;people.length;i++)&#123;<br>            array.add(people[i][<span class="hljs-number">1</span>],people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> array.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array.size()][]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（链表）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、寻找链表中点"><a href="#一、寻找链表中点" class="headerlink" title="一、寻找链表中点"></a>一、寻找链表中点</h1><p>寻找链表中点，是很多链表题解题的关键，重点则在于终止条件和得到的中点位置以及断开连接等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getMid</span><span class="hljs-params">(ListNode head)</span>&#123;<br><span class="hljs-comment">//两个终止条件，避免fast指针出错。</span><br><span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span>(node.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-comment">//可以想象长度为2的链表和长度和3的链表分别会得到什么结果。</span><br><span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>slow = slow.next;<br>fast = fast.next.next;<br>&#125;<br><span class="hljs-comment">//slow永远在是“中点/右偏中点”的位置。将slow与后面的节点切割，对于只要求分割链表的题目这样操作已经足够。</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> slow.next;<br>    slow.next = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若希望得到绝对中点，实现断开功能，可以采用哑节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//让slow和fast都慢一步，这样slow则是“中点/左偏中点”。需要在初始化时执行。</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>dummy.next = head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br><br><span class="hljs-comment">//可以只让slow慢一步，这样slow就是&#x27;中点/左偏中点的前一个节点&#x27;，便于断开连接</span><br><span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>dummy.next = head;<br><span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br></code></pre></td></tr></table></figure><p>若不需要调整链表的结构，只需要节点中顺序摆放的值，也可以不断开链表，只通过设置终止节点来分割，如<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>的特殊解法。</p><h1 id="二、链表反转-x2F-排序"><a href="#二、链表反转-x2F-排序" class="headerlink" title="二、链表反转&#x2F;排序"></a>二、链表反转&#x2F;排序</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></p><blockquote><p>归并排序对链表很有效，通过寻找中点分割左右两侧。</p></blockquote><p>可以联动该题的常规解法：<a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>，子顶向下归并排序。也可以子底向上排序，逐渐扩大合并范围即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自顶向下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> sort(head);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sort</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(node.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> node;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> slow.next;<br>        slow.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//左侧节点排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">leftsort</span> <span class="hljs-operator">=</span> sort(node);<br>        <span class="hljs-comment">//右侧节点排序</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightsort</span> <span class="hljs-operator">=</span> sort(temp);<br>        <span class="hljs-comment">//合并节点</span><br>        <span class="hljs-keyword">return</span> merge(leftsort,rightsort);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode node1,ListNode node2)</span>&#123;<br>    <span class="hljs-comment">//创建哑节点方便返回。</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> ans;<br>        <span class="hljs-comment">//这里的外循环是左右都有值</span><br>        <span class="hljs-keyword">while</span>(node1 != <span class="hljs-literal">null</span> &amp;&amp; node2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1.val&lt;node2.val)&#123;<br>                pre.next = node1;<br>                node1 = node1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pre.next = node2;<br>                node2 = node2.next;<br>            &#125;<br>            pre = pre.next;<br>        &#125;<br>        <span class="hljs-comment">//然后接上还有值的节点即可</span><br>        pre.next = node1 == <span class="hljs-literal">null</span>?node2:node1;<br>        <span class="hljs-keyword">return</span> ans.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sort-linked-list-already-sorted-using-absolute-values/">2046. 给按照绝对值排序的链表排序</a><br>多指针完成有序移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortLinkedList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, cur = head.next; <br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// cur为非负数时则两个指针向后移动；</span><br>            <span class="hljs-keyword">if</span> (cur.val &gt;= <span class="hljs-number">0</span>)&#123;<br>                pre = pre.next;<br>                cur = pre.next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur.val &lt; <span class="hljs-number">0</span>)&#123;<br>                pre.next = cur.next;<br>                cur.next = head;<br>                head = cur;<br>                cur = pre.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p><ol><li>一次遍历，存数组双指针判断</li><li>递归判断</li><li>双指针</li></ol><blockquote><p>递归是反向遍历链表的好方式！可以通过递归先找到尾部节点，然后与外部的节点指针对比交互。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//函数外的节点，代表待比较的头节点</span><br>    ListNode l1;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        l1 = head;<br>        <span class="hljs-keyword">return</span> func(head);<br>    &#125;<br><span class="hljs-comment">//判断节点是否为回文链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">func</span><span class="hljs-params">(ListNode node)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">func</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//通过func递归，直接找到尾节点，然后与外部头节点逐一比较</span><br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>)&#123;<br>            func = func(node.next);<br>        &#125;<br>        <span class="hljs-comment">//如果最后一个节点与头节点相等，则返回true，并移动头节点，此时尾部节点的func出栈，对比新的头节点和倒数第二个尾节点。</span><br>        <span class="hljs-keyword">if</span> (l1.val == node.val &amp;&amp; func)&#123;<br>            l1 = l1.next;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、循环链表"><a href="#三、循环链表" class="headerlink" title="三、循环链表"></a>三、循环链表</h1><p><a href="https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/">708. 循环有序列表的插入</a><br>主要考察思维严谨性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">insert</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> insertVal)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(insertVal);<br>        <span class="hljs-comment">//空节点检测</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            node.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-comment">//单节点检测</span><br>        <span class="hljs-keyword">if</span> (head.next == head) &#123;<br>            head.next = node;<br>            node.next = head;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head, next = head.next;<br>        <span class="hljs-comment">//循环回初始点</span><br>        <span class="hljs-keyword">while</span> (next != head) &#123;<br>            <span class="hljs-comment">//如果大于当前点小于下一个点，可以插入</span><br>            <span class="hljs-keyword">if</span> (insertVal &gt;= curr.val &amp;&amp; insertVal &lt;= next.val) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//判断临近点是否变成降序，如果是，则说明遍历到了首节点</span><br>            <span class="hljs-keyword">if</span> (curr.val &gt; next.val) &#123;<br>                <span class="hljs-comment">//判断当前节点是否可能为首节点，若为，则可以插入</span><br>                <span class="hljs-keyword">if</span> (insertVal &gt; curr.val || insertVal &lt; next.val) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//否则，迭代</span><br>            curr = curr.next;<br>            next = next.next;<br>        &#125;<br>        curr.next = node;<br>        node.next = next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（DFS与BFS）</title>
    <link href="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/"/>
    <url>/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、DFS与BFS"><a href="#一、DFS与BFS" class="headerlink" title="一、DFS与BFS"></a>一、DFS与BFS</h1><p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a><br>简单的搜索，注意终止条件的写法，由于不需要记录路径，所以不需要使用回溯，成功时直接返回即可。</p><p><a href="https://leetcode.cn/problems/battleships-in-a-board/">419. 甲板上的战舰</a><br>DFS，也可以只找左上角块统计。</p><p><a href="https://leetcode.cn/problems/strobogrammatic-number-iii/">248. 中心对称数 III</a><br>思路：</p><ul><li>长度为0的对称数为{null};</li><li>长度为1的对称数为{0,1,8};</li><li>在s的基础上，左右扩充{0+s+0,1+s+1,6+s+9,8+s+8,9+s+6};</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strobogrammaticInRange</span><span class="hljs-params">(String low, String high)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=high.length();<br>        <span class="hljs-type">int</span> n=low.length();<br><span class="hljs-comment">//如果m == n，直接取所有该长度的对称数，然后判断范围。</span><br>        <span class="hljs-keyword">if</span>(m-n==<span class="hljs-number">0</span>)&#123;<br>           List&lt;String&gt; res=helper(n,n);<br>           <span class="hljs-keyword">for</span>(String s :res)&#123;<br>           <span class="hljs-keyword">if</span>(Long.parseLong(s)&gt;=Long.parseLong(low)&amp;&amp;Long.parseLong(s)&lt;=Long.parseLong(high)) sum++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-comment">//遍历长度为n-&gt;m的所有对称数，注意判断范围</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m; i&gt;=n; i--)&#123;<br>                List&lt;String&gt; res=helper(i,i);<br>                <span class="hljs-keyword">for</span>(String s :res)&#123;<br>                <span class="hljs-keyword">if</span>(Long.parseLong(s)&gt;=Long.parseLong(low)&amp;&amp;Long.parseLong(s)&lt;=Long.parseLong(high)) sum++;<br>               &#125;    <br>            &#125;<br>         <br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-comment">// helper(n,m)求长度为n的对称数</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span>&#123;<br>        <span class="hljs-comment">// 第一步：判断输入或者状态是否合法，可省略</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        if(n&lt;0 || m&lt;0 || n&gt;m)&#123;</span><br><span class="hljs-comment">            throw  new IllegalArgumentException(&quot;invalid input&quot;);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        **/</span><br>        <span class="hljs-comment">// 第二步：初始状态</span><br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;&quot;</span>));<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>));<br>        <span class="hljs-comment">// 第三步：获取子问题答案</span><br>        List&lt;String&gt; list = helper(n-<span class="hljs-number">2</span>, m);<br>        <span class="hljs-comment">// 第四步：在子问题上，添加字符</span><br>        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String s : list)&#123;<br>            <span class="hljs-keyword">if</span> (n!=m) res.add(<span class="hljs-string">&quot;0&quot;</span>+s+<span class="hljs-string">&quot;0&quot;</span>);<br>                <span class="hljs-comment">// n=m时，表示最外层处理。</span><br>                <span class="hljs-comment">// 例如：原始需求n=m=2, &#x27;00&#x27;不合法</span><br>                <span class="hljs-comment">// 若原始需求n=m=4, 内层循环n=2,m=4,&#x27;00&#x27;;最外层循环，n=m=4时，&#x27;1001&#x27;  </span><br>            res.add(<span class="hljs-string">&quot;1&quot;</span>+s+<span class="hljs-string">&quot;1&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;6&quot;</span>+s+<span class="hljs-string">&quot;9&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;8&quot;</span>+s+<span class="hljs-string">&quot;8&quot;</span>);<br>            res.add(<span class="hljs-string">&quot;9&quot;</span>+s+<span class="hljs-string">&quot;6&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a><br>本题考查二叉树的字符串化：<br><strong>括号表达法：</strong><br><code>node.val + &quot;(&quot; + dfs(node.left) + &quot;)(&quot; + dfs(node.right) + &quot;)&quot;</code><br>或<br><code>&quot;(&quot; + dfs(node.left) + &quot;)&quot; +node.val+ &quot;(&quot; + dfs(node.right) + &quot;)&quot;</code></p><div class="note note-primary">            <p>本题开始尝试了以下表示方法，后来发现行不通：<br><code>dfs(node.left) + &quot;[&quot; + node.val + &quot;]&quot; + dfs(node.right)</code></p><ul><li>如果node.left没有叶子节点，则<code>dfs(node.left) = [node.left.val]</code>，则<code>dfs(node.left)</code>与<code>[node.val]</code>无法分出哪个是根节点。</li><li>所以如果使用括号类标识法，应该保证根节点唯一，左右节点可区分。</li></ul>          </div><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><p>用于寻找两数的公约数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> x % y;<br><span class="hljs-keyword">while</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>  x = y;<br>  y = remainder;<br>  remainder = x % y;<br>&#125;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过取余操作求公约数。</p><p><em>证明</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs math">令 a = kb + r，即r = a - kb<br>左右同时除a，b的最大公约数d：<br>r/d = a/d - kb/d<br>可知r/d为整数，即d也是r的约数。<br>问题由求a,b的最大公约数变成求b,r的最大公约数。<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/water-and-jug-problem/">365. 水壶问题</a><br><em>1. DFS&#x2F;BFS</em><br>分析情形，每次的操作共6种：装满x水壶、倒空x水壶、x水壶倒入y水壶、装满y水壶、倒空y水壶、y水壶倒入x水壶；递归寻找结果。<br>DFS种减枝：</p><ul><li>不装已经慢了的水壶</li><li>不倒已经空了的水壶</li><li>不到达已经到达了的状态（将两水壶的水量处理成int使用set保存）</li></ul><p><em>2. 贝祖定理</em><br>每次操作只会让水量增加x，增加y，减少x，或减少y，如果装一个不满水桶或倒一个不满水桶呢？</p><ul><li>两个桶不可能同时有水且不满（每个操作后必然有水桶满或空），因此只有以下几种状态：<ol><li>2个空水桶</li><li>2个满水桶</li><li>1个满水桶，1个空水桶</li><li>1个不满水桶，1个空水桶</li><li>1个不满水桶，1个满水桶</li></ol></li><li>对于1、2、3状态，不需要考虑，对于4，5状态，没有必要对一个不满进行装满或倒空，其结果等效于1、2、3状态。</li><li>因此每次有效操作，只会让水量增加x，增加y，减少x，或减少y。</li></ul><p>即问题转化是否有a,b满足：ax+by&#x3D;z<br>根据贝祖定理，只有z是x，y的最大公约数的倍数时，该式子才成立。所以问题转化为求x,y最小公约数，可以使用辗转相除法解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canMeasureWater</span><span class="hljs-params">(<span class="hljs-type">int</span> jug1Capacity, <span class="hljs-type">int</span> jug2Capacity, <span class="hljs-type">int</span> targetCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span>(targetCapacity&gt;jug1Capacity+jug2Capacity) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> gcd(jug1Capacity,jug2Capacity);<br>        <span class="hljs-keyword">return</span> targetCapacity%temp == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> x%y;<br>        <span class="hljs-keyword">while</span>(r != <span class="hljs-number">0</span>)&#123;<br>            x = y;<br>            y = r;<br>            r = x%y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>将树视为一个无向图，则任意两节点之间，都存在距离（两节点直连则距离为1），两节点节点之间的最长距离，就是这棵树的直径。<br>求树直径的方法主要为：2次DFS&#x2F;BFS（1次找直径的一个端点，1次找另一个端点）。<br>证明：<a href="https://blog.csdn.net/AC__dream/article/details/119101320">CSDN</a></p><p><a href="https://leetcode.cn/problems/minimum-height-trees/">310. 最小高度树</a><br>BFS&#x2F;DFS求直径端点，同时记录路径，便于找直径的中点（1个节点或2个节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">//根据边的信息，创建图结构</span><br>        List&lt;List&lt;Integer&gt;&gt; edgeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            edgeList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] edge:edges)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">1</span>];<br>            edgeList.get(x).add(y);<br>            edgeList.get(y).add(x);<br>        &#125;<br>        <span class="hljs-comment">//parent数组记录了遍历时节点之间路径</span><br>        <span class="hljs-type">int</span>[] parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">//直径的第一个端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> mostDeepNode(edgeList,<span class="hljs-number">0</span>,n,parent);<br>        <span class="hljs-comment">//复位parent</span><br>        Arrays.fill(parent,-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//直径的第二个端点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> mostDeepNode(edgeList,x,n,parent);<br>        <span class="hljs-comment">//将直径的路径从parent中取出</span><br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(y != -<span class="hljs-number">1</span>)&#123;<br>            path.add(y);<br>            y = parent[y];<br>        &#125;<br>        <span class="hljs-comment">//取路径中点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> path.size();<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        ans.add(path.get(length/<span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">if</span>(length%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            ans.add(path.get((length-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">//bfs求直径端点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mostDeepNode</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; list,<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>[] parent)</span>&#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.add(root);<br>        <span class="hljs-type">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        visited[root] =<span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            temp = deque.poll();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:list.get(temp))&#123;<br>                <span class="hljs-keyword">if</span>(!visited[next])&#123;<br>                    visited[next] = <span class="hljs-literal">true</span>;<br>                    parent[next] = temp;<br>                    deque.offer(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、回溯算法"><a href="#二、回溯算法" class="headerlink" title="二、回溯算法"></a>二、回溯算法</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a><br>先建立数字与字母<code>Map&lt;Integer,List&lt;Character&gt;&gt;</code>，使用一个<code>StringBuilder</code>，每层做循环，添加和删除末尾，当长度达到要求时返回一个记录并保存。<br><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a><br>记录左右括号的数量作为参数传递，左括号数量-右括号数量&gt;&#x3D;0时才能加右括号。<br><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></p><blockquote><p>注意复制list的方法：构造函数<code>new ArrayList&lt;T&gt;(Collection&lt;T&gt;)</code></p></blockquote><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a><br><a href="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索 II</a><br>要一次实现对每个单词的匹配，就不要有方向的寻找路径，而是枚举路径，只要判断出有一个单词之后就不会再核对这个路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯，不要对每个单词单独遍历，太慢超时</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">char</span>[][] board;<br>    <span class="hljs-type">int</span>[][] dirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-type">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">findWords</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] _board, String[] words)</span> &#123;<br>        board = _board;<br>        m = board.length; n = board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">for</span> (String w : words) set.add(w);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                vis[i][j] = <span class="hljs-literal">true</span>;<br>                sb.append(board[i][j]);<br>                dfs(i, j, sb);<br>                vis[i][j] = <span class="hljs-literal">false</span>;<br>                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, StringBuilder sb)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (set.contains(sb.toString())) &#123;<br>            ans.add(sb.toString());<br>            set.remove(sb.toString());<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] d : dirs) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> i + d[<span class="hljs-number">0</span>], dy = j + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span> || dx &gt;= m || dy &lt; <span class="hljs-number">0</span> || dy &gt;= n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[dx][dy]) <span class="hljs-keyword">continue</span>;<br>            vis[dx][dy] = <span class="hljs-literal">true</span>;<br>            sb.append(board[dx][dy]);<br>            dfs(dx, dy, sb);<br>            vis[dx][dy] = <span class="hljs-literal">false</span>;<br>            sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></p><ul><li>使用列数组，主对角线数组，副对角线数组保存每一列，对角线已经被使用的情况。</li><li>逐行遍历，每行逐一尝试当前可以填入的位置，并对该位置作出限制，递归，实现摆放后，返回一个结果。</li><li>过程中只需要记录各行中摆放的位置<code>List</code>，最后根据这个生成棋盘<code>char[][]</code></li></ul><p><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></p><ul><li>通过行数组，列数组，块数组，各使用一个int采用状态压缩的方式对后续填写作出限制。</li><li>将所有空棋放入一个list中，逐个选择，对选择出的棋子位置，遍历所有可能的选择，遇到成功即可返回true。（本质上是暴力尝试，遇到死局会返回）</li></ul><p><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></p><ul><li>遇到数字则直接填入</li><li>遇到字母则先填入，然后回溯尝试字母的大（小）写</li></ul><blockquote><p>Character.isDigit(char c); 判断字符是数字；<br>Character.isLetter(char c); 判断字符是字母；</p><ul><li>小写字母(a-&gt;z)的ASCII，97-&gt;122;</li><li>大写字母(A-&gt;Z)的ASCII，65-&gt;90;</li><li>可见之间隔了32，因此若要进行大小写转换，可以以90为界限，加减32即可。</li><li>若要保存数字+字母，使用<code>int[128]</code>即可</li><li>若只保存字母，使用<code>int[58]</code>即可，索引为<code>c-&#39;A&#39;</code>。</li></ul></blockquote><p><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a><br>注意题目，同一个元素不能以相同的身份出现在一个组合中。<br>采取先排序，然后剪枝的方法，避免全排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//全局记录答案</span><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><span class="hljs-comment">//记录元素是否使用，用于回溯</span><br><span class="hljs-type">boolean</span>[] used;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br><span class="hljs-comment">//先排序</span><br>Arrays.sort(candidates);<br>used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[candidates.length];<br>dfs(<span class="hljs-number">0</span>,candidates,target,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">//当前索引，距离target还差多少</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> index,<span class="hljs-type">int</span>[] candidates,<span class="hljs-type">int</span> target,List&lt;Integer&gt; list)</span>&#123;<br><span class="hljs-comment">//找到一个结果</span><br><span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)&#123;<br>res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list));<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//如果已经超过阈值/索引到达末尾/当前待选 == 上一个待选，且上一个没选，剪枝。</span><br><span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span> || index&gt;=candidates.length || index&gt;<span class="hljs-number">0</span>&amp;&amp;candidates[index]==candidates[index-<span class="hljs-number">1</span>]&amp;&amp;used[index-<span class="hljs-number">1</span>] ==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> candidates[index];<br>list.add(temp);<br>used[index] = <span class="hljs-literal">true</span>;<br>dfs(index+<span class="hljs-number">1</span>,candidates,target-temp,list);<br>list.remove(list.size()-<span class="hljs-number">1</span>);<br>used[index] = <span class="hljs-literal">false</span>;<br>dfs(index+<span class="hljs-number">1</span>,candidates,target,list);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>将本题与火柴题对比：<br>相同点在于，根据题目的要求，判断能否走下去只取决于状态，不取决于选择顺序（实际上，顺序在dp和dfs中就做过枚举处理。），只要有一种顺序方案成功，这个状态就是成功的。因此两者如果要使用dp方法做，都不需要保存某物品作为最后一个选择时的情形，即纬度只有状态。</p><p>比较dp和dfs的区别：</p><ul><li>dp时（转移方程是反向思维），对于某个状态s，<strong>枚举</strong>上一个状态s1，即可得知该状态是否可达。最后列举到最后状态<code>dp[(1&lt;&lt;n)-1]</code>即可得知结果。</li><li>dfs+回溯时（转移方程时正向思维），通过初始状态，<strong>枚举</strong>可选择的火柴，寻找后续状态的可行性。</li><li>因为枚举的方向不同，所以dfs判断无法到达结果后，可以直接剪枝，dp则会走完所有的情况。</li><li>本题显然需要剪枝，使用dfs较好，且在结果中要返回该方案本身，回溯更好处理。</li></ul>          </div><p><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a><br>排序去重，注意剪枝的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        n = nums.length;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//索引，上一个索引是否使用，当前状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span> lastUsed,List&lt;Integer&gt; cur)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(cur));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里注意，要先允许跳过该位置</span><br>        dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>,cur);<br>        <span class="hljs-comment">//然后再判断该位置能否选择，从而剪枝</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] &amp;&amp; !lastUsed) <span class="hljs-keyword">return</span>;<br>        cur.add(nums[i]);<br>        dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">true</span>,cur);<br>        cur.remove(cur.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/letter-tile-possibilities/">1079. 活字印刷</a><br>与子集2对比：</p><ul><li>对于子集而言，元素的顺序是无关紧要的，只要数量上不重复就是唯一子集，而本处的序列需要考虑元素的选择顺序</li></ul><p>先不考虑重复的情况下：</p><ul><li>对于子集的枚举，只需要逐一判断每个元素是否选择，并记录状态即可。是一个单根节点的问题。</li><li>对于子序列的枚举，还要针对下一个元素选择哪一个&#x2F;或不选进行遍历，如下图所示。</li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190007.png"><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228190717.png"></p><ol><li>dfs，排序剪枝头，通过排序+顺序遍历保证了每次使用一个字母时，使用的是最左侧的该字母。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">boolean</span>[] visited;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTilePossibilities</span><span class="hljs-params">(String tiles)</span> &#123;<br>        <span class="hljs-comment">//题目中字母序列不同与子序列，是无序的。</span><br>        <span class="hljs-comment">//为了去重，排序</span><br>        n = tiles.length();<br>        s = tiles.toCharArray();<br>        Arrays.sort(s);<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(visited[j] || (j&gt;<span class="hljs-number">0</span> &amp;&amp; s[j] == s[j-<span class="hljs-number">1</span>] &amp;&amp; !visited[j-<span class="hljs-number">1</span>])) <span class="hljs-keyword">continue</span>;<br>            visited[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//每次添加字符后，必然得到一个未见过的序列。</span><br>            res++;<br>            dfs(i+<span class="hljs-number">1</span>);<br>            visited[j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>统计各字母个数，每次从26个字母中选择，而不是从剩余元素（可能有重复字母）中选择。</li></ol><h1 id="三、图"><a href="#三、图" class="headerlink" title="三、图"></a>三、图</h1><p>图的题目主要为各个节点之间相互连接的问题，常常需要结合dfs，bfs，探索相邻点得到答案。</p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>拓扑排序中没有环，是一个无环图。</li></ul><h3 id="常见的处理方式"><a href="#常见的处理方式" class="headerlink" title="常见的处理方式"></a>常见的处理方式</h3><h4 id="正向思维-x2F-BFS"><a href="#正向思维-x2F-BFS" class="headerlink" title="正向思维&#x2F;BFS"></a>正向思维&#x2F;BFS</h4><p>节点之间有前后依赖关系，可以先统计每个节点的入度：</p><ul><li>将入度为0的节点放入队列中</li><li>逐一取出队列中节点，取出节点A时消去所有依赖节点A的节点B们的一个入度，如果某节点入度为0，表示其已经可以被消去，入队。</li><li>循环出队的过程</li></ul><h4 id="逆向思维-x2F-DFS"><a href="#逆向思维-x2F-DFS" class="headerlink" title="逆向思维&#x2F;DFS"></a>逆向思维&#x2F;DFS</h4><p>每个节点有三种状态：未搜索，搜索中，搜索完毕。类似JVM回收三色标记，本质上是先将出度为0的节点标记完成：</p><ul><li>对任意一个节点开始进行搜索直接&#x2F;间接依赖该节点的若干节点，并将该节点标记为<strong>搜索中</strong>：</li><li>搜索该节点的临近节点DFS，当某节点和直接&#x2F;间接依赖该节点的若干节点都<strong>搜索完毕</strong>后，该节点才能标至为<strong>搜索完毕</strong>。</li><li>利用拓扑排序中没有环的性质，从任意一点开始搜索，都不会搜索回自己，即在dfs时不可能遇到一个<strong>搜索中</strong>的节点，可以据此判断拓扑排序是否成立。</li></ul><p><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a><br>正向&#x2F;逆向思维均可。</p><p><a href="https://leetcode.cn/problems/course-schedule/">210. 课程表 Ⅱ</a><br>为了获取课程学习顺序，使用正向思维。</p><p><a href="https://leetcode.cn/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a><br>出度和入度倒置就可以了。</p><p><a href="https://leetcode.cn/problems/alien-dictionary/">269. 火星词典</a><br>本题的难点：</p><ul><li><p>如何记录优先级：可以拓扑排序！</p></li><li><p>由于题目不允许任何非法排序：</p><ul><li>不可以有前缀相同但更长的单词（字典规则）</li><li>对于游离的节点，本体允许对其排序，所以直接将其作为入度为0的节点处理即可，如果不允许，还需要额外处理。<ul><li>如果不允许出现游离节点，可以在统计后判断哪些节点，既没有出度也没有入度。</li></ul></li><li>不能有环（非法顺序）。<ul><li>对于环问题，会使拓扑排序提前结束（环上的节点入度永远不可能为0），可以比较<strong>总节点数</strong>和在<strong>排序链上的节点数</strong>。</li></ul></li></ul></li><li><p>本题有 出度详细统计 和 入度数量统计 作为全局变量，可以灵活判断是否初始化这两个变量来顺便实现统计：</p><ul><li>如本题利用出度详细统计，统计了全部节点数量。</li><li>如果遇到要处理游离节点的问题：<ul><li>如果想要找到游离节点：可以在完成图建立后，统计入度为0中出度为空的节点。</li><li>如果只想忽视游离节点：可以只对有入度和出度的节点做并集统计，游离节点则不在这两者中，具体而言，选择根节点时，在所有有出度的节点中寻找入度为0或不存在的即可。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//记录出边</span><br>    Map&lt;Character,List&lt;Character&gt;&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//记录入度</span><br>    Map&lt;Character,Integer&gt; in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//是否合法</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">alienOrder</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-comment">//初始化出边，入度不能初始化（有的字母无法判断任何顺序关系，不能认为其在最前面）</span><br>        <span class="hljs-keyword">for</span>(String word:words)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.length();i++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> word.charAt(i);<br>                edges.putIfAbsent(c,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Character&gt;());<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//比较字符串，添加字符顺序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n &amp;&amp; valid;i++)&#123;<br>            compare(words[i-<span class="hljs-number">1</span>],words[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!valid)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//字符队列</span><br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//所有有出边的字符</span><br>        Set&lt;Character&gt; letterSet = edges.keySet();<br>        <span class="hljs-comment">//遍历这些有出边的字符，如果其没有入度，则可以作为根节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> u : letterSet) &#123;<br>            <span class="hljs-keyword">if</span> (!in.containsKey(u)) &#123;<br>                deque.offer(u);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">Character</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>            sb.append(c);<br>            List&lt;Character&gt; neigh = edges.get(c);<br>            <span class="hljs-keyword">for</span>(Character c2:neigh)&#123;<br>                in.put(c2,in.get(c2)-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(in.get(c2) == <span class="hljs-number">0</span>)&#123;<br>                    deque.offerLast(c2);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.length() == edges.size() ? sb.toString() : <span class="hljs-string">&quot;&quot;</span>;<br>        <br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1,String s2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(s1.length(),s2.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s1.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s2.charAt(i);<br>            <span class="hljs-keyword">if</span>(s1.charAt(i) != s2.charAt(i))&#123;<br>                edges.get(c1).add(c2);<br>                in.put(c2,in.getOrDefault(c2,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == len &amp;&amp; s1.length()&gt;s2.length())&#123;<br>            valid = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h2><p>参考题目<a href="https://leetcode.cn/problems/cracking-the-safe/">753. 破解保险箱</a><br><em>分析：</em><br>最优解肯定是对于一个初始密码000，每次只在后面添加一个数字就可以得到一个新密码，如<code>0[001]</code>，可见影响下一个密码选项的是当前密码除第一位的数。我们视这样的数为一个节点。我们可以从00节点开始，它可以选择0，1两个后续数，整个密码像一个滑动窗口模型。</p><p><em>欧拉回路：</em><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233121.png"></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul><li>每个节点都有若干的出度（下一步选项），因此也有若干的入度（对称性）。</li></ul><p><em>推论：</em><br>从某个节点开始遍历，一定可以恰好回到该节点。（因为第一个出度给出去了，最后一个入度会回到这个点。对于本题，我们只需要保证，通过一次遍历能够遍历到所有节点即可。）</p><h3 id="常见处理方式"><a href="#常见处理方式" class="headerlink" title="常见处理方式"></a>常见处理方式</h3><h4 id="Hierholzer-算法（倒序）"><a href="#Hierholzer-算法（倒序）" class="headerlink" title="Hierholzer 算法（倒序）"></a>Hierholzer 算法（倒序）</h4><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230227233756.png"><br><em>代码实现：</em><br>节点可能会重复，但路径（也就是密码，比节点多一位）永远不会重复，通过记录密码就可以防止走重复的路径，从000开始搜索密码。</p><ul><li>有一个很重要的技巧，就是dfs之后再添加该节点：<ul><li>在某个节点状态Node下，可能有多个下次可成功密码。</li><li>在尝试下一个密码A成功时，并不能保证这个路径可以遍历所有路径，如果沿着这条路走到原点，并顺序添加路径到sb上，则sb的末尾不再是该节点Node，因此无法尝试另一个密码B。</li><li>我们可以倒序添加路径到sb上，先把v-&gt;u的路径以u-&gt;v的方式保存在sb上，此时v即可继续尝试下一个密码。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-type">int</span> highest;<br>    <span class="hljs-type">int</span> k;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//最高位的单位，若n=3，highest=100</span><br>        highest = (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.k = k;<br>        <span class="hljs-comment">//从00开始搜索</span><br>        dfs(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//ans，填充若干个0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>    <span class="hljs-comment">//下一个可选择的字符</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; k; ++x) &#123;<br>        <span class="hljs-comment">//下一个尝试密码</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nei</span> <span class="hljs-operator">=</span> node * <span class="hljs-number">10</span> + x;<br>            <span class="hljs-comment">//如果这个密码没有被尝试过</span><br>            <span class="hljs-keyword">if</span> (!seen.contains(nei)) &#123;<br>            <span class="hljs-comment">//则将该节点添加到已见过的密码</span><br>                seen.add(nei);<br>                <span class="hljs-comment">//搜索该节点</span><br>                dfs(nei % highest);<br>                <span class="hljs-comment">//最后将该字符添加到sb末尾，所以sb是倒序的，最后结尾时加00。</span><br>                ans.append(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012352.png"><br><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012728.png"></p><h4 id="贪心（顺序）"><a href="#贪心（顺序）" class="headerlink" title="贪心（顺序）"></a>贪心（顺序）</h4><p>我们选择”00”作为起始点。但是每次要选择添加的数字时，从大数字开始（即从 k-1遍历到 00）。这样可以尽可能晚地回到起始点。</p><ul><li>很显然，一直添加最小值0，会快速回到起始点。</li><li>事实上，Hierholzer算法中，下一个可选择字符是从小到达遍历的，所以从程序顺序角度看肯定会尽可能早的遍历回起点，因此要做倒序，先把最后这一段添加到sb中，再看其他未走过的路径。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">crackSafe</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span>&#123;<br>     <span class="hljs-comment">//map记录一个节点当前剩余的最大出边，最大为K-1。</span><br>     Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-comment">//所有节点的所有路径之和</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">kn</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(k,n);<span class="hljs-comment">//路径总数量</span><br>     <span class="hljs-comment">//一个节点有n-1个数字</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">kn_1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(k,n-<span class="hljs-number">1</span>);<span class="hljs-comment">//结点总数量</span><br>     <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>     <span class="hljs-comment">//初始结点为000...</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt; n;i++)&#123;<br>         ans.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>     &#125;<br>     <span class="hljs-comment">//如果密码长度为1，没有出入度，单纯枚举</span><br>     <span class="hljs-keyword">if</span>(ans.length() == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; k; i++)&#123;<br>             ans.append(i);<br>         &#125;<br>         <span class="hljs-keyword">return</span> ans.toString();<br>     &#125;<br>     <span class="hljs-comment">//遍历所有的路</span><br>     <span class="hljs-keyword">while</span> (kn != <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-comment">//获取当前节点</span><br>         <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> ans.substring(ans.length() - n + <span class="hljs-number">1</span>, ans.length());<br>         <span class="hljs-comment">//初始化节点</span><br>         <span class="hljs-keyword">if</span>(!map.containsKey(substring)) map.put(substring,k-<span class="hljs-number">1</span>);<br>         <span class="hljs-comment">//将当前节点的最大边添加到结果中</span><br>         ans.append(map.get(substring));<br>         <span class="hljs-comment">//删除当前节点的最大边</span><br>         map.put(substring,map.get(substring) - <span class="hljs-number">1</span>);<br>         kn--;<br>     &#125;<br>     <span class="hljs-keyword">return</span> ans.toString();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228012433.png"></p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-type">int</span>[] parent;<br><span class="hljs-type">int</span>[] size;<br><span class="hljs-type">int</span> setCount;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-built_in">this</span>.n = n;<br><span class="hljs-built_in">this</span>.setCount = n;<br><span class="hljs-built_in">this</span>.size = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><span class="hljs-built_in">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>Arrays.fill(size,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>parent[i] = i;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">return</span> parent[x] == x?x:(parent[x] = root(parent[x]));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>x = root(x);<br>y = root(y);<br><span class="hljs-keyword">if</span>(x == y)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(size[x] &lt; size[y])&#123;<br>x = x^y;<br>y = x^y;<br>x = x^y;<br>&#125;<br>parent[y] = x;<br>size[x] += size[y];<br>setCount--;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-keyword">return</span> root(x) == root(y);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></p><ol><li>染色，将两个连接的元素标上不同的颜色，如果遇到颜色冲突，则说明无法形成二分图。</li><li>并查集，通过</li></ol><p><a href="https://leetcode.cn/problems/path-with-maximum-minimum-value/">1102. 得分最高的路径</a></p><ol><li>遍历：使用<code>boolean[][]</code>记录已经访问过的路径+dfs回溯，携带路径上的最小值，到达终点时更新答案。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] DIRECTIONS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">boolean</span>[][] visited;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumMinimumPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//右侧为首尾中最小值，表示想要走通能够遇到的最小值，最大也只能为right。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> dfs(grid,m,n,mid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(pass == <span class="hljs-literal">true</span>)&#123;<br>                left = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=m||y&lt;<span class="hljs-number">0</span>||y&gt;=n||visited[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        visited[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(grid[x][y]&lt;mid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(x == m-<span class="hljs-number">1</span> &amp;&amp; y == n-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] direction:DIRECTIONS)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> x + direction[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> y + direction[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dfs(grid,m,n,mid,x1,y1))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>二分：通过限制最小分数min，并判断只能走比min分数大的方块时到达终点的可行性。</li><li>并查集：为每个边赋予分数（两个节点中较大的），然后按照分数从小到大连通边，直到首节点和尾节点相连。</li></ol><p><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a><br>并查集逐渐添加边解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] heights)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> heights.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights[<span class="hljs-number">0</span>].length;<br>List&lt;<span class="hljs-type">int</span>[]&gt; edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i * n + j;<br><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - n, id, Math.abs(heights[i][j] - heights[i - <span class="hljs-number">1</span>][j])&#125;);<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;id - <span class="hljs-number">1</span>, id, Math.abs(heights[i][j] - heights[i][j - <span class="hljs-number">1</span>])&#125;);<br>&#125;<br>&#125;<br>&#125;<br>edges.sort((a,b) -&gt; a[<span class="hljs-number">2</span>]-b[<span class="hljs-number">2</span>]);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">Collections.sort(edges, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="hljs-comment">public int compare(int[] edge1, int[] edge2) &#123;</span><br><span class="hljs-comment">return edge1[2] - edge2[2];</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;);</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">UnionFind</span> <span class="hljs-variable">uf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnionFind</span>(m * n);<br><span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], y = edge[<span class="hljs-number">1</span>], v = edge[<span class="hljs-number">2</span>];<br>uf.unite(x, y);<br><span class="hljs-keyword">if</span> (uf.connected(<span class="hljs-number">0</span>, m * n - <span class="hljs-number">1</span>)) &#123;<br>ans = v;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><ul><li>场景：Dijkstra算法主要用于解决带权重的有向图，权重只能为正值，是经典的求<strong>单源最短路径</strong>的一种方法。</li><li>思路：从源点开始BFS，同时更新各点到源点的距离。</li><li>复杂度：时间根据遍历最近点的方案（使用遍历时最大为n^2，使用二叉堆时最小为nlogn）；空间（n）；</li></ul><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><ul><li>场景：Floyd算法可以解决带负权重边（不能解决负权回路）的问题，是经典的求<strong>多源最短路径</strong>的一种方法。</li><li>思路：<ul><li>有以下两个对称矩阵：<ul><li>两点之间最短距离矩阵D</li><li>两点之间最短距离所经过的中介点矩阵P</li></ul></li><li>通过遍历各个点为中介点，看是否能缩短距离，缩短后更新D、P。</li></ul></li><li>复杂度：时间（n^3），空间（n^2）；</li></ul><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>对于无向有权图，寻找一个所有点连通而路径权重最小的图。</p><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><ul><li>思路：从任一节点开始搜索，每次选择距离当前集合最近的点加入集合，已经搜过的不重复搜，直到所有节点都完成搜索。</li><li>复杂度：O(n^2)</li></ul><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><ul><li>思路：将所有边按照权重从小到大排列，每次取最小权重且两顶点当前不在一个集合的边，直到所有节点连接。</li><li>复杂度：O(n+mlogm)，排序(mlogm)加出栈(n)。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></p><ol><li>dfs配合visited数组秒杀。</li><li>并查集也可以</li></ol><p><a href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a><br>贪心做法容易预先填入，后面因为冲突而无法处理的情况。<br>这里可以先把所有边统计起来，每个花园只影响比其编号大的花园的选择限制（通过位运算标记），这样后面的选择肯定不会干涉已经选择了的花园。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] gardenNoAdj(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] paths) &#123;<br>        <span class="hljs-type">int</span>[] canPicks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        HashMap&lt;Integer,Set&lt;Integer&gt;&gt; connected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] path:paths)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> path[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> end;<br>                end = start;<br>                start = temp;<br>            &#125;<br>            connected.putIfAbsent(start,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;());<br>            connected.get(start).add(end);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">canPick</span> <span class="hljs-operator">=</span> canPicks[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(((canPick&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                    ans[i-<span class="hljs-number">1</span>] = j+<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(connected.get(i) != <span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> next:connected.get(i))&#123;<br>                            canPicks[next] |= <span class="hljs-number">1</span>&lt;&lt;j;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、前缀树"><a href="#四、前缀树" class="headerlink" title="四、前缀树"></a>四、前缀树</h1><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-comment">//可以使用数组</span><br>    <span class="hljs-keyword">public</span> Trie[] children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>[<span class="hljs-number">26</span>];<br><span class="hljs-comment">//也可以使用hash</span><br><span class="hljs-comment">//public Map&lt;?,Trie&gt; children = new HashMap&lt;&gt;();</span><br><br><span class="hljs-comment">//可以记录本节点是一个单词结束点，也可以记录本节点所对应的单词等</span><br>    <span class="hljs-comment">//boolean isEnd = null;</span><br>    <span class="hljs-comment">//public String word = null;</span><br><br><span class="hljs-comment">//获取指定字符的节点</span><br>    <span class="hljs-keyword">public</span> Trie <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br><br><span class="hljs-comment">//插入单词</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">Trie</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> word.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>)<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            node = node.children[<span class="hljs-type">char</span>];<br>        &#125;<br>        <span class="hljs-comment">//node.isEnd = true;</span><br>        <span class="hljs-comment">//node.word = word;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/word-squares/">425. 单词方块</a></p><ul><li>先根据题目集合建立字典树（每个节点都记录当前字符串）</li><li>单词方块中的单词数量 &#x3D; 题目中单词的长度</li><li>建立方块数组，枚举第一个单词<ul><li>在前面单词的限制下得到后续单词的前缀，利用前缀树快速判断是否存在该前缀，若不存在直接返回，若存在则继续枚举。</li><li>直到填满方块，返回。</li></ul></li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228202925.jpg"></p><p><a href="https://leetcode.cn/problems/palindrome-pairs/">336. 回文对</a><br>分析：<br>对于两个单词(word1+word2)组成回文对，有三种情况：</p><ul><li>情形1：word1.length&gt;word2.length，此时应该满足，word1的前段与word2成回文，word1剩余长度自成回文。</li><li>情形2：word1.length&lt;word2.length，此时应该满足，word2的后段与word1成回文，word2前面部分自成回文。</li><li>情形3：word1.length &#x3D;&#x3D; word2.length，此时可以考虑为前面情况的特殊情况。</li></ul><p><img src="/2023/02/10/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88DFS%E4%B8%8EBFS%EF%BC%89/Pasted-image-20230228211251.png"><br>思路：</p><ul><li>为了比较回文，先为所有单词<strong>逆序</strong>构建字典树。同时记录每个单词的末尾是否为回文。</li><li>顺序遍历单词，在字典树中寻找<ul><li>为了处理情况1，word1的字符每走一步，判断一次word1后半段是否为回文，若是，则看这时有哪些word2（节点的words列表）。</li><li>为了处理情况2，word1的字符遍历结束时，看该节点是否有后缀的回文串。</li><li>情况3，可包含在情况1或2中解决。(节点的prefix列表)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">palindromePairs</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-comment">// 字典树的插入，注意维护每个节点上的两个列表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">//倒序单词</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rev</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(words[i]).reverse().toString();<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-comment">//如果本单词本身就是回文串，则将根节点的前缀列表上添加i</span><br>            <span class="hljs-keyword">if</span> (isPalindrome(rev.substring(<span class="hljs-number">0</span>))) cur.suffixs.add(i);<br>            <span class="hljs-comment">//插入单词</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; rev.length(); j++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> rev.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">null</span>) cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>                cur = cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br>                <span class="hljs-comment">//如果倒序单词的后缀是回文串，则说明原单词的前缀是回文串</span><br>                <span class="hljs-keyword">if</span> (isPalindrome(rev.substring(j+<span class="hljs-number">1</span>))) cur.suffixs.add(i);<br>            &#125;<br>            <span class="hljs-comment">//最后在该节点的word列表中添加i</span><br>            cur.words.add(i);<br>        &#125;<br>        <span class="hljs-comment">// 用以存放答案的列表</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//枚举单词</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> words[i];<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//枚举字符</span><br>            <span class="hljs-keyword">for</span> ( ;j &lt; word.length(); j++) &#123;<br>                <span class="hljs-comment">// 到j位置，后续字符串若是回文对，则在该节点位置上所有单词都可以与words[i]构成回文对 即 word+words[i]是回文对</span><br>                <span class="hljs-keyword">if</span>(isPalindrome(word.substring(j))) <br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : cur.words) <br>                        <span class="hljs-keyword">if</span> (k != i) ans.add(Arrays.asList(i,k));<br>                <span class="hljs-comment">// </span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> word.charAt(j);<br>                <span class="hljs-keyword">if</span> (cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>                cur = cur.children[ch-<span class="hljs-string">&#x27;a&#x27;</span>];<br><br>            &#125;<br>            <span class="hljs-comment">// words[i]遍历完了，现在找所有大于words[i]长度且符合要求的单词，suffixs列表就派上用场了:)</span><br>            <span class="hljs-keyword">if</span> (j == word.length()) <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : cur.suffixs) <br>                    <span class="hljs-keyword">if</span> (k != i) ans.add(Arrays.asList(i,k));<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>    <span class="hljs-comment">//  判断一个字符串是否是回文字符串</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String w)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = w.length()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (w.charAt(i) != w.charAt(j)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++; j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">public</span> Node[] children;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; words;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; suffixs;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-built_in">this</span>.words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.suffixs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>new StringBuilder(string).reverse.toString()</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>回溯算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（树）</title>
    <link href="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/"/>
    <url>/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h1><h2 id="二叉树遍历、路径与构造"><a href="#二叉树遍历、路径与构造" class="headerlink" title="二叉树遍历、路径与构造"></a>二叉树遍历、路径与构造</h2><h3 id="先中后序遍历"><a href="#先中后序遍历" class="headerlink" title="先中后序遍历"></a>先中后序遍历</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><ol><li>DFS</li><li>迭代，使用队列作为栈，然后让所有左节点入栈，出栈时添加其右节点（及其所有左子节点）到栈中。</li></ol><p><a href="https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/">1028. 从先序遍历还原二叉树</a></p><blockquote><p>可以将遍历理解成一个回溯的过程！</p></blockquote><p>逐个取出节点，使用链表保存路径上的节点，根据节点的深度判断：</p><ol><li>其是沿着上一个节点的左节点</li><li>之前别的的节点的右节点，此时可不停出列直到找到对应深度的节点。</li></ol><p><a href="https://leetcode.cn/problems/find-leaves-of-binary-tree/">366. 寻找二叉树的叶子节点</a><br>后序遍历，反向求各节点的深度，然后按照深度依次放入结果集即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ret;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findLeaves</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">//求节点到最近叶子节点的距离，或者叫反深度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//求左节点深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(node.left);<br>        <span class="hljs-comment">//求右节点深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(node.right);<br>        <span class="hljs-comment">//当前节点深度 = 最大深度+1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> Math.max(l, r) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//如果还没有创建该深度的List，创建一个</span><br>        <span class="hljs-keyword">if</span> (cur &gt;= ret.size()) &#123;<br>            ret.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-comment">//将该节点添加到对应列表中</span><br>        ret.get(cur).add(node.val);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p><ol><li>层序遍历</li><li>遍历当前节点时，就建立下一层节点之间的关系：为每层建立一个哑节点作为头节点，即可实现子节点的记录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span>(now != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> pre;<br>            <span class="hljs-keyword">while</span>(now != <span class="hljs-literal">null</span> &amp;&amp; now.left != <span class="hljs-literal">null</span>)&#123;<br>                pre.next = now.left;<br>                pre = pre.next;<br>                pre.next = now.right;<br>                pre = pre.next;<br>                now = now.next;<br>            &#125;<br>            now = index.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-iv/">666. 路径总和 IV</a><br>层数小于5和满二叉树的编号，已经提醒了我们可以使用数组来对树进行存储</p><ul><li>先逐个取出节点，保存到数组中</li><li>然后从根节点开始逐层计算分数，未发现叶子节点则结算当前节点，否则累加后等待子节点结算</li></ul><h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><blockquote><p>对于树的问题，要善于使用递归，通过递归传递出子节点的信息以供父节点使用。该题则需要传递出</p><ul><li>子节点能提供的最大path（小于0则提供0）</li><li>子节点及以下节点的可能出现的最大分数</li></ul></blockquote><p><a href="https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/">1530. 好叶子节点对的数量</a><br>迭代，同时返回各叶子节点的深度，数量和可以为结果作出的贡献，必要时建立结构体作为返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-type">Pair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> dfs(root, distance);<br>        <span class="hljs-keyword">return</span> pair.count;<br>    &#125;<br><br>    <span class="hljs-comment">// 对于 dfs(root,distance)，同时返回：</span><br>    <span class="hljs-comment">// 1）每个叶子节点与 root 之间的距离</span><br>    <span class="hljs-comment">// 2) 以 root 为根节点的子树中好叶子节点对的数量</span><br>    <span class="hljs-keyword">public</span> Pair <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> distance)</span> &#123;<br>        <span class="hljs-type">int</span>[] depths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//如果是叶子节点，直接返回。</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeaf</span> <span class="hljs-operator">=</span> root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (isLeaf) &#123;<br>            depths[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(depths, <span class="hljs-number">0</span>);<br>        &#125;<br><span class="hljs-comment">//</span><br>        <span class="hljs-type">int</span>[] leftDepths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] rightDepths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[distance + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取左右节点信息</span><br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">leftPair</span> <span class="hljs-operator">=</span> dfs(root.left, distance);<br>            leftDepths = leftPair.depths;<br>            leftCount = leftPair.count;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Pair</span> <span class="hljs-variable">rightPair</span> <span class="hljs-operator">=</span> dfs(root.right, distance);<br>            rightDepths = rightPair.depths;<br>            rightCount = rightPair.count;<br>        &#125;<br><span class="hljs-comment">//将左右叶子节点的深度加1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; distance; i++) &#123;<br>            depths[i + <span class="hljs-number">1</span>] += leftDepths[i];<br>            depths[i + <span class="hljs-number">1</span>] += rightDepths[i];<br>        &#125;<br><span class="hljs-comment">//统计当前节点为路径节点能得到的好子节点数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= distance; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j + i + <span class="hljs-number">2</span> &lt;= distance; j++) &#123;<br>                cnt += leftDepths[i] * rightDepths[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回更新后的叶子节点深度和数量，所有好子节点数量。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(depths, cnt + leftCount + rightCount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span> &#123;<br>    <span class="hljs-type">int</span>[] depths;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(<span class="hljs-type">int</span>[] depths, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-built_in">this</span>.depths = depths;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、二叉搜索树"><a href="#二、二叉搜索树" class="headerlink" title="二、二叉搜索树"></a>二、二叉搜索树</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a><br>删除二叉搜索树的节点，可以递归解决，可以参考红黑树中的做法，寻找待删除节点的后继节点，使用该后继节点代替原节点！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-comment">//左右递归判断</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>            root.left = deleteNode(root.left, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>            root.right = deleteNode(root.right, key);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">//需要删除本节点</span><br>        <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>    <span class="hljs-comment">//左右节点存在空节点的情况</span><br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> root.right;<br>            &#125;<br>            <span class="hljs-comment">//左右节点都不为空，则寻找后继节点，即找其右节点的（循环寻找左节点），这与使用迭代来遍历中序遍历二叉树有异曲同工之妙。</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-comment">//删除后继节点</span><br>            root.right = deleteNode(root.right, successor.val);<br>            <span class="hljs-comment">//使用后继节点代替本节点</span><br>            successor.right = root.right;<br>            successor.left = root.left;<br>            <span class="hljs-keyword">return</span> successor;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化写法：使用递归是因为要将子节点操作结果反馈给父节点，若主动记录父节点则可以避免递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root, curParent = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.val != key) &#123;<br>            curParent = cur;<br>            <span class="hljs-keyword">if</span> (cur.val &gt; key) &#123;<br>                cur = cur.left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span> &amp;&amp; cur.right == <span class="hljs-literal">null</span>) &#123;<br>            cur = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.right == <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.left;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur.left == <span class="hljs-literal">null</span>) &#123;<br>            cur = cur.right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">successor</span> <span class="hljs-operator">=</span> cur.right, successorParent = cur;<br>            <span class="hljs-keyword">while</span> (successor.left != <span class="hljs-literal">null</span>) &#123;<br>                successorParent = successor;<br>                successor = successor.left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (successorParent.val == cur.val) &#123;<br>                successorParent.right = successor.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                successorParent.left = successor.right;<br>            &#125;<br>            successor.right = cur.right;<br>            successor.left = cur.left;<br>            cur = successor;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (curParent == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (curParent.left != <span class="hljs-literal">null</span> &amp;&amp; curParent.left.val == key) &#123;<br>                curParent.left = cur;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                curParent.right = cur;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/depth-of-bst-given-insertion-order/">1902. 给定二叉搜索树的插入顺序求深度</a><br>使用TreeMap保存值和深度的关系，新值的深度肯定是其左右值深度的较大值+1。</p><p><a href="https://leetcode.cn/problems/split-bst/">776. 拆分二叉搜索树</a><br>注意题目条件，递归解决。</p><p><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></p><ol><li>普通做法是找中点，切断关系然后递归，因为需要根据中点来建立左右节点关系。</li><li>也可以认为有序链表就是二叉搜索树的先序遍历，建立一个假重点建立左节点关系，等左节点建立好之后，就可以获取到中节点的值，最后在建立右节点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode globalHead;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        globalHead = head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span>(index != <span class="hljs-literal">null</span>)&#123;<br>            index = index.next;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> midSearch(<span class="hljs-number">0</span>,end-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">midSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start+end)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        root.left = midSearch(start,mid-<span class="hljs-number">1</span>);<br>        root.val = globalHead.val;<br>        globalHead = globalHead.next;<br>        root.right = midSearch(mid+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><em>定义</em></p><ol><li>是「二叉排序树」</li><li>任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）</li></ol><p><em>评价指标</em></p><ol><li>平衡因子BF：左子树和右子树高度差</li><li>最小不平衡子树：距离插入节点最近的，并且 BF 的绝对值大于 1 的节点为根节点的子树。</li></ol><p><em>平衡二叉树调整</em><br>左右旋转调整即可，参考<a href="https://blog.csdn.net/jarvan5/article/details/112428036?ops_request_misc=%7B%22request_id%22:%22163126248116780357294578%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163126248116780357294578&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112428036.first_rank_v2_pc_rank_v29&utm_term=%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1018.2226.3001.4187">平衡二叉树</a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>优先队列的良好实现，使用<strong>完全二叉树</strong>存储。也可数组实现，可参考排序算法中的K排序算法。</p><h1 id="三、赫夫曼树"><a href="#三、赫夫曼树" class="headerlink" title="三、赫夫曼树"></a>三、赫夫曼树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/v2-561bb507a8adcbbed29281abac1d3485_1440w.webp"></p><ul><li>二叉树的各节点有权重</li><li>带权路径长度 &#x3D; 叶子节点到根节点的距离×自身权重</li><li>WPL：所有叶子节点的带权路径长度之和。</li></ul><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>每次将根节点权值最小的树合并即可。<br><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/Pasted-image-20230404233232.jpg"></p><h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h2><p>统计各字符使用次数，将其作为权重然后构造赫夫曼树。</p><h1 id="四、B树和B-树"><a href="#四、B树和B-树" class="headerlink" title="四、B树和B+树"></a>四、B树和B+树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/Pasted-image-20230423002057.png"><br><em>定义</em></p><ul><li>多路自平衡的搜索树，B树允许每个节点有多个子节点。</li><li>关键字分布在整颗树中。</li></ul><p><em>优点</em></p><ul><li>相对二叉树，逻辑上接近的节点物理上也会更近，可以充分利用磁盘预读。</li><li>相比二叉树，有效降低了树的高度，且每个节点区确定的范围更精确。</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="/2023/02/09/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%A0%91%EF%BC%89/Pasted-image-20230423002105.png"><br><em>定义</em></p><ul><li>B树的变体，多路自平衡的搜索树。</li><li>关键字存储在叶子节点上，且叶子节点之间存在链指针。</li></ul><p><em>与B树的区别</em></p><ul><li>结构上，由于关键字存储位置不同，B+树的查询时间复杂度更固定，B树则取决于搜索关键字的位置；</li><li>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</li><li>B+树更适合外部存储，由于内节点不保存数据，每个节点占用空间更少，意味着一次可以读出更多的节点，读出的索引更多，搜索更快。</li></ul><h2 id="为什么使用B-x2F-B-树做存储？"><a href="#为什么使用B-x2F-B-树做存储？" class="headerlink" title="为什么使用B-&#x2F;B+树做存储？"></a>为什么使用B-&#x2F;B+树做存储？</h2><p><em>预备知识</em></p><ul><li>存储时总存在一个<strong>存储最小单元</strong>（如InnoDB的页）；</li><li>主存的存取过程中，通过地址总线传入矩阵后即可从数据总线中得到存储数据，该过程中数据之间的距离对效率<strong>没有影响</strong>；</li><li>磁盘I&#x2F;O的存取过程中，存在机械运动，每个<strong>扇区是磁盘的最小存储单元</strong>；</li><li><strong>局部性原理</strong>：当一个数据被用到时，其附近的数据也通常会马上被使用。</li></ul><p><em>解释</em></p><ul><li>由于磁盘I&#x2F;O相对主存过慢，为提高效率，需要减少磁盘I&#x2F;O，即进行预读；</li><li>预读一般以页为基本单位，B-树和B+树为磁盘位置检索和预读提供了良好的数据结构。</li></ul><h1 id="五、序列化与反序列化"><a href="#五、序列化与反序列化" class="headerlink" title="五、序列化与反序列化"></a>五、序列化与反序列化</h1><p><em>解释</em></p><ul><li>树的反序列化，最需要关注和维护的就是节点之间的父子和子子关系，实现隔离一个父的多个子；</li><li>其维护的难点在于，遍历子节点时，需要维护其父节点以维护父子关系。</li></ul><p><em>方法</em><br>无论使用那种方法，序列化的字符串中每个节点或特殊标记之间需要用<strong>空格</strong>或<strong>逗号</strong>等隔开，反序列化时才方便执行：</p><ul><li>DFS+递归：顺序构建字符串，字符串记录节点值后记录子节点值。<ul><li>序列化时：为了区分出子节点结构，对于二叉树，空节点传<code>&quot;Null&quot;</code>，对于N叉树，固定使用一位记录节点数量即可。</li><li>反序列化时：使用一个全局变量代表索引即可；</li></ul></li><li>DFS+递归：中序构建字符串，并特殊处理，如二叉树使用<code>(leftNode)root.val(rightNode)</code>序列化，反序列化时，先建立根节点，然后依次、创建左节点、为根节点赋值、创建右节点，其本质与DFS相同；</li><li>BFS(DFS)+建立映射关系：使用数组记录各节点的值和父节点的索引<code>node.val,parentNode.index;</code>，反序列化时依次实例化并建立关系即可；</li><li>DFS+迭代+栈：使用<code>root.val(childrens)</code>的方式记录，遇到<code>(</code>将上一个节点入栈，遇到<code>)</code>将节点出栈，栈顶维护了当前父节点；</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DFS方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">return</span> encode(root,sb).toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">encode</span><span class="hljs-params">(TreeNode node,StringBuilder sb)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>)&#123;<br>            sb.append(<span class="hljs-string">&quot;null,&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            sb.append(node.val).append(<span class="hljs-string">&quot;,&quot;</span>);<br>            encode(node.left,sb);<br>            encode(node.right,sb);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>        <br>    &#125;<br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        String[] str = data.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">int</span>[] index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        index[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> decode(str,index);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">decode</span><span class="hljs-params">(String[] str,<span class="hljs-type">int</span>[] index)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index[<span class="hljs-number">0</span>] == str.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[index[<span class="hljs-number">0</span>]].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>            index[<span class="hljs-number">0</span>]++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(Integer.valueOf(str[index[<span class="hljs-number">0</span>]++]));<br>            node.left = decode(str,index);<br>            node.right = decode(str,index);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/">428. 序列化和反序列化 N 叉树</a><br>方法：</p><ul><li>标注父节点的索引；</li><li>通过<code>[]</code>框住所有的子节点，使用栈维护；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解法一，使用了全局变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        dfsEnocde(root, builder); <br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br><span class="hljs-comment">//记录子节点的个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsEnocde</span><span class="hljs-params">(Node root, StringBuilder builder)</span> &#123;<br>        builder.append(root.val).append(<span class="hljs-string">&quot; &quot;</span>);<br>        builder.append(root.children.size()).append(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; root.children.size(); i++) &#123;<br>            dfsEnocde(root.children.get(i), builder);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//全局变量</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">null</span> || data.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        String[] arr = data.split(<span class="hljs-string">&quot; &quot;</span>);<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> decode(arr);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">decode</span><span class="hljs-params">(String[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == arr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//解码节点，由于可以判断个数，故可以确定循环次数，通过i传递遍历进度</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(arr[i++]), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Integer.valueOf(arr[i++]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123; <span class="hljs-comment">// 如果size == 0，则跳过，直接返回root</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> decode(arr);<br>            root.children.add(child);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解法二“1,-1;2,0;3,0;4,0;5,0;6,2;7,2;8,3;9,4;10,4;11,6;12,7;13,8;14,10&quot;。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Queue&lt;Node&gt; nodeQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Node&gt;();<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; indicesQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        nodeQueue.offer(root);<br>        indicesQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">while</span> (!nodeQueue.isEmpty()) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nodeQueue.poll();<br>            <span class="hljs-type">int</span>[] indices = indicesQueue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">childIndex</span> <span class="hljs-operator">=</span> indices[<span class="hljs-number">0</span>], parentIndex = indices[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!sb.isEmpty()) &#123;<br>                sb.append(<span class="hljs-string">&#x27;;&#x27;</span>);<br>            &#125;<br>            sb.append(node.val);<br>            sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>            sb.append(parentIndex);<br>            List&lt;Node&gt; children = node.children;<br>            <span class="hljs-keyword">for</span> (Node child : children) &#123;<br>                nodeQueue.offer(child);<br>                indicesQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;index, childIndex&#125;);<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        String[] arr = data.split(<span class="hljs-string">&quot;;&quot;</span>);<br>        String[] rootArr = arr[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.parseInt(rootArr[<span class="hljs-number">0</span>]), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        Node[] nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[length];<br>        nodes[<span class="hljs-number">0</span>] = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            String[] nodeArr = arr[i].split(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> Integer.parseInt(nodeArr[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> Integer.parseInt(nodeArr[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>            nodes[i] = node;<br>            nodes[parent].children.add(node);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//解法三，1 ( 2 3 ( 6 7 ( 11 ( 14 ) ) ) 4 ( 8 ( 12 ) ) 5 ( 9 ( 13 ) 10 ) )</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        sb.append(root.val);<br>        List&lt;Node&gt; children = root.children;<br>        <span class="hljs-keyword">if</span> (!children.isEmpty()) &#123;<br>            <span class="hljs-comment">//注意，在添加一个符号前总是添加一个空格，最后再使用空格把所有符号，数字分开，本质上是因为，数组可能不止一位数，对于值为2位数的数字，不加空格无法区分。</span><br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            sb.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            <span class="hljs-keyword">for</span> (Node child : children) &#123;<br>                sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>                sb.append(serialize(child));<br>            &#125;<br>            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            sb.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String data)</span> &#123;<br>        <span class="hljs-keyword">if</span> (data.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        String[] arr = data.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.parseInt(arr[<span class="hljs-number">0</span>]), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>        Deque&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Node&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;(&quot;</span>.equals(str)) &#123;<br>                stack.push(last);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;)&quot;</span>.equals(str)) &#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.parseInt(str), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Node&gt;());<br>                <span class="hljs-comment">//这里默认会先把数组都Push进stack，如果该数的前一个符号不是&#x27;(&#x27;，则把前一个数字pop出去。</span><br>                stack.peek().children.add(node);<br>                last = node;<br>            &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（应用类）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%BA%94%E7%94%A8%E7%B1%BB%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%BA%94%E7%94%A8%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="综合应用类"><a href="#综合应用类" class="headerlink" title="综合应用类"></a>综合应用类</h1><h3 id="对比两个文件-x2F-数组，文件过大时怎么办？"><a href="#对比两个文件-x2F-数组，文件过大时怎么办？" class="headerlink" title="对比两个文件&#x2F;数组，文件过大时怎么办？"></a>对比两个文件&#x2F;数组，文件过大时怎么办？</h3><ul><li>为了解决文件过大，使用分治；</li><li>最后需要将结果合并；</li><li>为了合并结果，可使用hash结构记录每一块的对比结果或对后续的影响；</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（动态规划）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、字符串问题"><a href="#一、字符串问题" class="headerlink" title="一、字符串问题"></a>一、字符串问题</h1><h2 id="通配符问题"><a href="#通配符问题" class="headerlink" title="通配符问题"></a>通配符问题</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/wildcard-matching/">44. 通配符匹配</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//*可以匹配空，所以要找到p的第一个非*的数，其前面的都可以与空匹配。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(p.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//c1 与 c2匹配</span><br>                <span class="hljs-keyword">if</span>(c1 == c2 || c2 == <span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-comment">//c2包含 c1时和 c2不包含c1时</span><br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] | dp[i][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回文问题"><a href="#回文问题" class="headerlink" title="回文问题"></a>回文问题</h2><p>对于寻找字符串的回文子串问题：</p><ul><li>可采用从中心扩展的方式（）</li><li>可使用dp的思想解决</li></ul><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p><ol><li>中心扩展，注意剪枝</li><li>dp，处理好索引</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//中心扩展</span><br>String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//边界条件判断</span><br>    <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-comment">//start表示最长回文串开始的位置，</span><br>    <span class="hljs-comment">//maxLen表示最长回文串的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ) &#123;<br>        <span class="hljs-comment">//如果剩余子串长度小于目前查找到的最长回文子串的长度，直接终止循环</span><br>        <span class="hljs-comment">// （因为即使他是回文子串，也不是最长的，所以直接终止循环，不再判断）</span><br>        <span class="hljs-keyword">if</span> (length - i &lt;= maxLen / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i;<br>        <span class="hljs-keyword">while</span> (right &lt; length - <span class="hljs-number">1</span> &amp;&amp; s.charAt(right + <span class="hljs-number">1</span>) == s.charAt(right))<br>            ++right; <span class="hljs-comment">//过滤掉重复的</span><br>        <span class="hljs-comment">//下次在判断的时候从重复的下一个字符开始判断</span><br>        i = right + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//然后往两边判断，找出回文子串的长度</span><br>        <span class="hljs-keyword">while</span> (right &lt; length - <span class="hljs-number">1</span> &amp;&amp; left &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(right + <span class="hljs-number">1</span>) == s.charAt(left - <span class="hljs-number">1</span>)) &#123;<br>            ++right;<br>            --left;<br>        &#125;<br>        <span class="hljs-comment">//保留最长的</span><br>        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt; maxLen) &#123;<br>            start = left;<br>            maxLen = right - left + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//截取回文子串</span><br>    <span class="hljs-keyword">return</span> s.substring(start, start + maxLen);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a><br>预判断回文串区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCut</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br><span class="hljs-comment">//预处理回文串区间</span><br>        <span class="hljs-type">boolean</span>[][] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            Arrays.fill(g[i], <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                g[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; g[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断各种分发能否构成回文串</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(f, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][i]) &#123;<br>                f[i] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (g[j + <span class="hljs-number">1</span>][i]) &#123;<br>                        f[i] = Math.min(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. 让字符串成为回文串的最少插入次数</a><br>方法一：求最长子序列，然后减去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minInsertions</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//求最大回文子序列，然后减去这个长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-comment">//dp[i][j]表示坐标i到j（包括j）的最大回文子序列</span><br>        <span class="hljs-comment">//if char[i] == char[j] : dp[i][j] = dp[i+1][j-1]+2</span><br>        <span class="hljs-comment">//else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</span><br>        <span class="hljs-comment">//可见这里的循环需要i从大到小，j从小到大遍历，因此有 i=n-1,j=i+1的索引初始化。</span><br>        <span class="hljs-comment">//另外，当j=i+1时，需要dp[i+1][j-1] == 0;dp[i][j-1] == 1，因此有每个i开头时的初始化dp[i][i] = 1。</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n-dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：传统dp，使用长度迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minInsertions</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;length&lt;=n;length++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-length;i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+length-<span class="hljs-number">1</span>;<br>                dp[i][j] = Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                    dp[i][j] = Math.min(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i);<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s.charAt(j);<br>                <span class="hljs-keyword">if</span>(c1 == c2)&#123;<br>                    dp[i][j] = Math.max(dp[i][j],dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span>);<br>                &#125;<br>                dp[i][j] = Math.max(dp[i][j],Math.max(dp[i][j-<span class="hljs-number">1</span>],dp[i+<span class="hljs-number">1</span>][j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-different-palindromic-subsequences/">730. 统计不同回文子序列</a><br>dp时一般会取一个窗口的两端进行判断，这里要避免重复有两个方案（看官方题解）：</p><ol><li><p><code>dp[i][j][k]</code>统计某个窗口<code>[i,j]</code>内以某单词<code>k</code>为两端的回文子序列数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//char[i] == char[j] == k时，所有回文串都可以加上前后的k得到新的回文串</span><br>dp[i][j][k] = <span class="hljs-number">2</span>+sum(m)(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][m]);<br><span class="hljs-comment">//char[j] == k</span><br>dp[i][j][k] = dp[i+<span class="hljs-number">1</span>][j][k];<br><span class="hljs-comment">//char[i] == k</span><br>dp[i][j][k] = dp[i][j-<span class="hljs-number">1</span>][k];<br><span class="hljs-comment">//char[i] != k &amp;&amp; char[j] != k</span><br>dp[i][j][k] = dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][k];<br></code></pre></td></tr></table></figure></li><li><p><code>dp[i][j]</code>统计某窗口内所有回文子序列数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//char[i] == char[j] =c时</span><br><span class="hljs-comment">//求i的nextC，j的preC:</span><br><span class="hljs-comment">//if nextC&lt;preC，减去重复的部分</span><br>dp[i][j] = <span class="hljs-number">2</span> * dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] - dp[nextC][preC]<br><span class="hljs-comment">//if nextC == preC，多加一个cc补充回文。</span><br>dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br><span class="hljs-comment">//if nextC&gt;preC，多加c和cc两个回文</span><br>dp[i][j] = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> * dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/">1147. 段式回文</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestDecomposition</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-keyword">return</span> divide(text);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(String text)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> text.length();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(text.substring(<span class="hljs-number">0</span>,i).equals(text.substring(len-i,len)))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>+divide(text.substring(i,len-i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h2><h3 id="拼接问题"><a href="#拼接问题" class="headerlink" title="拼接问题"></a>拼接问题</h3><p><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a><br><a href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a><br>使用set判断片段匹配，为每一个字符索引维护一个<code>List&lt;String&gt;</code>，发现匹配后，直接在原<code>String</code>后拼接即可。<br><a href="https://leetcode.cn/problems/shortest-way-to-form-string/">1055. 形成字符串的最短路径</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestWay</span><span class="hljs-params">(String source, String target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> source.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">while</span>( j &lt; target.length() )&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> j ;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; n ; i++)&#123;<br>                <span class="hljs-keyword">if</span>( j &lt; target.length() &amp;&amp; source.charAt(i) == target.charAt(j) )<br>                    j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>( prev == j ) <span class="hljs-comment">//如果j没有移动</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/scramble-string/">87. 扰乱字符串</a><br>3维dp<br>假设：S1&#x3D;A1+B1，S2&#x3D;A2+B2<br>结论：若A1和A2，B1和B2分别是扰乱字符串，则S1和S2也是；若A1和B2，B1和A2分别是扰乱字符串，则S1和S2也是扰乱字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以s1的i索引开头，s2的j索引开头，长度为n的字符串是否是扰乱字符串</span><br>dp[i][j][n] = (dp[i][j][len] &amp;&amp; dp[i+len][j+len][n-len]) || (dp[i][j+n-len][len] &amp;&amp; dp[i+n-len][j][len]);<br><span class="hljs-comment">//可以得知以n为外循环即可，n递增</span><br><br><span class="hljs-comment">//全解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isScramble</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s1.length() != s2.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">char</span>[] c1 = s1.toCharArray();<br>        <span class="hljs-type">char</span>[] c2 = s2.toCharArray();<br>        <span class="hljs-type">boolean</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(c1[i] == c2[j]) dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-len;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n-len;j++)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;len;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(dp[i][j][k] &amp;&amp; dp[i+k][j+k][len-k])&#123;<br>                            dp[i][j][len] = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(dp[i][j+len-k][k] &amp;&amp; dp[i+k][j][len-k])&#123;<br>                            dp[i][j][len] = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></p><blockquote><p>题目要求，最小且最左，使用DP解决时，考虑从左到右，每轮后需要对比看是否能得到更小的窗口结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s2.length();<br>        <span class="hljs-comment">//dp表示s1的前i个包含s2的前j个的初始位置.</span><br>        Integer[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//可以初始化dp[i][0]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">window_size</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//求每个i包含s2的前1,2,3,...m个字符的初始值.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//求s1中i下标之前，包含s2[:j]的起始位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                <span class="hljs-comment">//若s1的第i个刚好等于s2的第j个,则s1前i个包含s2的前j个的起始位置为s1前i-1个包含s2前j-1个的位置</span><br>                <span class="hljs-keyword">if</span>(s1.charAt(i-<span class="hljs-number">1</span>)==s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-comment">//否则,s1前i个包含s2的前j个的起始位置为s1前i-1个包含s2前j个的位置</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果当前i包含s2的前m个字符的初始值不为空,即满足条件,计算窗口大小和左右指针,</span><br>            <span class="hljs-keyword">if</span>(dp[i][m]!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cur_window_size</span> <span class="hljs-operator">=</span> i-dp[i][m];<br>                <span class="hljs-keyword">if</span>(cur_window_size&lt;window_size)&#123;<br>                    l = dp[i][m];<br>                    r = i-<span class="hljs-number">1</span>;<br>                    window_size = cur_window_size;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l==-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> s1.substring(l,r+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a><br>一开始想到用双指针，dfs函数中判断是否分支计算，但超时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        m = s.length();<br>        n = t.length();<br>        dfs(s,t,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s,String t,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(j == n)&#123;<br>            count++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == m)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(s,t,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == t.charAt(j))&#123;<br>            dfs(s,t,i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态规划可以更好的利用子问题的结果简化计算，实现剪枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//边界条件，对任意空串都有一个匹配！</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-comment">//不使用i匹配，默认有dp[i-1][j]个匹配。</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>                <span class="hljs-comment">//i可以匹配，再加上dp[i-1][j-1]。</span><br>                <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == t.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a><br>需要先处理i&#x3D;0的所有状态，因为<code>dp[0][?]</code>均可能为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> p.length();<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n1+<span class="hljs-number">1</span>][n2+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//注意这里的处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n2 ; j++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n2;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;.&#x27;</span> || c1 == c2)&#123;<br>                    dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(c2 == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> p.charAt(j-<span class="hljs-number">2</span>);<br>                    <span class="hljs-keyword">if</span>(c3 == <span class="hljs-string">&#x27;.&#x27;</span> || c3 == c1)&#123;<br>                        dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n1][n2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">940. 不同的子序列 II</a><br>与不同的回文串类似的思路<br>遍历到索引i的字母c时，根据i-1时的不同子序列：<br>索引i子序列数量 &#x3D; A（索引i-1子序列数量，不重复） + B（索引i-1子序列加上c，不重复）-A&amp;B（A中以上一个c结尾的子序列数量）+1（c本身）<br><code>dp[i] = dp[i-1] + dp[i-1] - dp[preC-1] +1</code><br>分类讨论：</p><ul><li>字母c没有出现过，则A&amp;B&#x3D;0，<code>dp[i] = 2*dp[i-1]+1</code></li><li>字母c出现过，则A中肯定有c本身，末尾的1要剪掉：<code>dp[i] = dp[i-1] + dp[i-1] - dp[preC-1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctSubseqII</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//记录某单词出现的索引+1；</span><br>        <span class="hljs-type">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">// Arrays.fill(pre,-1);</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preC</span> <span class="hljs-operator">=</span> pre[c];<br>            <span class="hljs-comment">//先默认加上边界c自身和可能重复的值</span><br>            dp[i] = (<span class="hljs-number">2</span>*dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)%MOD;<br>            <span class="hljs-comment">//如果之前有c出现，说明，c本身已经包含在默认的dp[i-1]中了，再将多出来的1个减去。</span><br>            <span class="hljs-keyword">if</span>(preC != <span class="hljs-number">0</span>)&#123;<br>                dp[i] = (dp[i]-dp[preC-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>+MOD)%MOD;<br>            &#125;<br>            pre[c] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二、状态转移类"><a href="#二、状态转移类" class="headerlink" title="二、状态转移类"></a>二、状态转移类</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a><br>状态：1.持有股票 2.不持有股票 3.不持有股票且今日卖出<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a><br>状态：1.未买入2.买入一次3.卖出一次4.买入两次5.卖出两次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">5</span>];<br>        <span class="hljs-comment">//不持有，未交易</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//持有，未交易</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//持有，交易过一次</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//不持有，交易过一次；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//不持有，交易过两次；</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]-prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]+prices[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dp[n][<span class="hljs-number">0</span>],Math.max(dp[n][<span class="hljs-number">3</span>],dp[n][<span class="hljs-number">4</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dp只取决于前一天的状态，因此可以简化dp数组为10个变量（昨日5个，今日5个）<br>但可以假设每天可以进行多次买入卖出（不影响当日结果），只要按照<br><strong>买入一次、卖出一次、买入两次、卖出两次</strong>的顺序计算，就不需要维护两日的信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">buy1</span> <span class="hljs-operator">=</span>-prices[<span class="hljs-number">0</span>],buy2=-prices[<span class="hljs-number">0</span>],sell1=<span class="hljs-number">0</span>,sell2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            buy1 = Math.max(buy1,-prices[i]);<br>            sell1 = Math.max(buy1+prices[i],sell1);<br>            buy2 = Math.max(buy2,sell1-prices[i]);<br>            sell2 = Math.max(sell2,buy2+prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a><br>注意交易相当于一次买入加卖出，这里将买入作为交易，卖出时不消耗操作次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//严格买入次数</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;  <br>    <span class="hljs-comment">//第i天结束时持有/不持有股票且交易次数为k的最大值</span><br>    <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>][k+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//预处理第0天，第0天执行一次买入情形：</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];  <br>    <span class="hljs-comment">//第0天执行1次以上的情况不存在：</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;i++)&#123;  <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][i] = Integer.MIN_VALUE/<span class="hljs-number">2</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-comment">//这里不处理j == 0的情况，因为j==0时，dp永远为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;  <br>            dp[i][<span class="hljs-number">1</span>][j] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][j],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]-prices[i]);  <br>            dp[i][<span class="hljs-number">0</span>][j] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][j],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][j]+prices[i]);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> Arrays.stream(dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]).max().getAsInt();  <br>&#125;<br><br><span class="hljs-comment">//单纬度解法（可以假设一天进行多次买入和卖出）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br><span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//天数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> prices.length;<br><span class="hljs-comment">//进行i次买入最大的收益</span><br><span class="hljs-type">int</span>[] buy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] sell = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//第0天，进行i次买入最大的收益为-price[i]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>buy[i] = -prices[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">//从第1天开始算</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-comment">//买卖次数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>buy[j] = Math.max(buy[j],sell[j-<span class="hljs-number">1</span>]-prices[i]);<br>sell[j] = Math.max(sell[j],buy[j]+prices[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sell[k];<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意，股票问题在迭代时考虑两个问题：</p><ul><li>可以考虑将卖出和买入作为两个数组（或变量）来维护，结果更显而易见。</li><li>是否可以当成每天可以进行多次交易，若是，则可以节省dp空间</li></ul>          </div><p><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></p><ul><li>状态：1.今日偷取 2.今日未偷，每日结束时最大价值取决于前一日是否偷和对应金额，因为环形问题分两种情况考虑即可</li><li>状态：记录每日结束时最大即可，每日结束时最大价值取决于前两日。</li></ul><p><a href="https://leetcode.cn/problems/pizza-with-3n-slices/">1388. 3n 块披萨</a><br>类似打家劫舍，但由于取每块批萨时，不仅取决于前一块，还会影响后一块。由于取走的总数是恒定的，所以根据取走的块数来进行dp。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSizeSlices</span><span class="hljs-params">(<span class="hljs-type">int</span>[] slices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> slices.length;<br>        <span class="hljs-type">int</span>[] slices1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[] slices2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n-<span class="hljs-number">1</span>];<br>        System.arraycopy(slices,<span class="hljs-number">1</span>,slices1,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        System.arraycopy(slices,<span class="hljs-number">0</span>,slices2,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans1</span> <span class="hljs-operator">=</span> pick(slices1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans2</span> <span class="hljs-operator">=</span> pick(slices2);<br>        <span class="hljs-keyword">return</span> Math.max(ans1,ans2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pick</span><span class="hljs-params">(<span class="hljs-type">int</span>[] slices)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> slices.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">choose</span> <span class="hljs-operator">=</span> (n+<span class="hljs-number">1</span>)/<span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][choose+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">maxPick</span> <span class="hljs-operator">=</span> Math.min(i,choose);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=maxPick;j++)&#123;<br>                dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],(i-<span class="hljs-number">2</span>&gt;=<span class="hljs-number">0</span>?dp[i-<span class="hljs-number">2</span>][j-<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>)+slices[i-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][choose];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由打家结舍2和批萨问题可知，状态转移的前驱状态不仅只能是前一天。</p></blockquote><p><a href="https://leetcode.cn/problems/frog-jump/">403. 青蛙过河</a><br>注意记忆化搜索，以当前位置和上一次跳跃距离为状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Boolean[][] can;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCross</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[n][n];<br>        <span class="hljs-keyword">return</span> canCross(stones,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCross</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> step)</span>&#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(start == stones.length-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(can[start][step] != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> can[start][step];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start+<span class="hljs-number">1</span>;i&lt;stones.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextStep</span> <span class="hljs-operator">=</span> stones[i]-stones[start];<br>            <span class="hljs-keyword">if</span>(nextStep &lt; step-<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(nextStep &gt; step+<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(canCross(stones,i,nextStep))&#123;<br>                <span class="hljs-keyword">return</span> can[start][step] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> can[start][step] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以动态规划，题目有隐含条件，到达索引index时，其上一步绝对不会超过index。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canCross</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//可以提前判断不可能到达的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (stones[i] - stones[i - <span class="hljs-number">1</span>] &gt; i) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//固定i,列举i的前一次石头，查看是否可能到达。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> stones[i] - stones[j];<br>                <span class="hljs-keyword">if</span> (k &gt; j + <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                dp[i][k] = dp[j][k - <span class="hljs-number">1</span>] || dp[j][k] || dp[j][k + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span> &amp;&amp; dp[i][k]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/dungeon-game/">174. 地下城游戏</a><br>盲目的dfs会弄错题目的意思，本题要求骑士血量永远在0以上，所以先扣血后补血并不是等价的，可以直接假设到达终点后骑士剩余血量为1，然后倒推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] dungeon)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> dungeon.length, m = dungeon[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//预处理</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            Arrays.fill(dp[i], Integer.MAX_VALUE);<br>        &#125;<br>        <span class="hljs-comment">//终点时骑士血量为1</span><br>        dp[n][m - <span class="hljs-number">1</span>] = dp[n - <span class="hljs-number">1</span>][m] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//骑士站在(i,j)往右边或下面走时至少需要minn的血量，因此走到(i,j)则至少需要（minn-dungeon[i][j]）的血量或1血量。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">minn</span> <span class="hljs-operator">=</span> Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i][j + <span class="hljs-number">1</span>]);<br>                dp[i][j] = Math.max(minn - dungeon[i][j], <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/paint-fence/">276. 栅栏涂色</a><br>正常三维dp必然会超时，应该意识到所有颜色都是相同的，可以使用递推公式来解决：</p><ul><li>第i个栏栅与第i-1个栏栅颜色不同，则<code>dp[i] += dp[i-1] * (k-1)</code></li><li>这点的思路与打家劫舍2和3n披萨相似，临近排斥问题可以考虑前若干天&#x2F;若干份的情况。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//可以只考虑某种颜色情况</span><br>        <span class="hljs-comment">//第一天可选方案数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//第二天可选方案数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> k;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> d1*k;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> d2*k;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> d2;<br>            d2 = (k-<span class="hljs-number">1</span>)*(d1+d2);<br>            d1 = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> d2*k;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//第1天选择某颜色，且不限制后面选择的方案数为1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//第1天选择某颜色，且限制后面选择的可能方案为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从第2天开始求某颜色的方案数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempX</span> <span class="hljs-operator">=</span> x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tempY</span> <span class="hljs-operator">=</span> y;<br>            <span class="hljs-comment">//第2天有(k-1)(tempX+tempY)种方案不限制后面选择</span><br>            x = (k-<span class="hljs-number">1</span>)*(tempX+tempY);<br>            <span class="hljs-comment">//第2天有tempX种方案限制后面的选择</span><br>            y = tempX;<br>        &#125;<br>        <span class="hljs-comment">//最后求不限制后面的方案总数</span><br>        <span class="hljs-keyword">return</span> k*(x+y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a><br>本体与其他对状态转义的处理方式不细微的不同：</p><ul><li>对于打家劫舍，其只需要以前一天是否偷取的<strong>行为</strong>作为依据（即行为就是一个维度），判断今天不同行为得到的结果即可。</li><li>对于本题，记录的不是行为，而是行为的结果（迟到次数，缺勤次数），所以根据今天的3种不同行为，需要分别考虑并汇总。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkRecord</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//影响后续dp的只有，之前已经缺勤的次数和连续迟到的次数</span><br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//如果今日到场,缺勤次数不变</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-comment">//过去的所有迟到清零</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                    dp[i][j][<span class="hljs-number">0</span>] = (dp[i][j][<span class="hljs-number">0</span>]+dp[i-<span class="hljs-number">1</span>][j][k])%MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果今日迟到，缺勤次数不变</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                    dp[i][j][k] = (dp[i][j][k] + dp[i-<span class="hljs-number">1</span>][j][k-<span class="hljs-number">1</span>])%MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果今日缺勤，迟到次数归零</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">2</span>;k++)&#123;<br>                dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k])%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">2</span>;j++)&#123;<br>                ans = (ans+dp[n][i][j])%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>特殊的状态转移方程，原理是矩阵运算。<br><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//转移参数</span><br>        <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[][] res = pow(a,n);<br>        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><span class="hljs-comment">// 矩阵a的n次方</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] pow(<span class="hljs-type">int</span>[][] a,<span class="hljs-type">int</span> n)&#123;<br>    <span class="hljs-comment">//初始状态为单位矩阵</span><br>        <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-comment">//每次循环做一次平方，或在平方上再乘一个矩阵a</span><br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//存在奇数次时，乘一次a</span><br>            <span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)&#123;<br>                res = multiply(res,a);<br>            &#125;<br>            <span class="hljs-comment">//迭代a</span><br>            a = multiply(a,a);<br>            <span class="hljs-comment">//右移</span><br>            n = n&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-comment">//矩阵相乘</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] multiply(<span class="hljs-type">int</span>[][] a, <span class="hljs-type">int</span>[][] b) &#123;<br>        <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>                c[i][j] = a[i][<span class="hljs-number">0</span>] * b[<span class="hljs-number">0</span>][j] + a[i][<span class="hljs-number">1</span>] * b[<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、数值序列规划"><a href="#三、数值序列规划" class="headerlink" title="三、数值序列规划"></a>三、数值序列规划</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a><br>通过处理缩小枚举左指针范围。<br><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a><br>记录各索引元素前递增个数。<br><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a><br>把信封按宽度递增、高度递减排序。实现了每个信封宽度都比前面大或相同，且相同宽度的信封不会装起来。</p><ul><li>直接dp，判断高度，超时！</li><li>直接dp超时的原因在于寻找前一个可以装的信封时是枚举算法，改进：使用一个数组记录 套了i个信封的 的最小信封高度，这是一个递增数组。在判断一个新信封能装多少信封时，搜索刚好低于该高度的最长序列即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二分dp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] es)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> es.length;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-comment">// 由于我们使用了 g 记录高度，因此这里只需将 w 从小到达排序即可</span><br>        Arrays.sort(es, (a, b)-&gt;a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// f(i) 为考虑前 i 个物品，并以第 i 个物品为结尾的最大值</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>        <span class="hljs-comment">// g(i) 记录的是长度为 i 的最长上升子序列的最小「信封高度」</span><br>        <span class="hljs-type">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>        <span class="hljs-comment">// 因为要取 min，用一个足够大（不可能）的高度初始化</span><br>        Arrays.fill(g, Integer.MAX_VALUE); <br>        g[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, len = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">// 对于 w 相同的数据，不更新 g 数组</span><br>            <span class="hljs-keyword">if</span> (es[i][<span class="hljs-number">0</span>] != es[j][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-comment">// 限制 j 不能越过 i，确保 g 数组中只会出现第 i 个信封前的「历史信封」</span><br>                <span class="hljs-keyword">while</span> (j &lt; i) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> f[j], cur = es[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (prev == len) &#123;<br>                        <span class="hljs-comment">// 与当前长度一致了，说明上升序列多增加一位</span><br>                        g[len++] = cur;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 始终保留最小的「信封高度」，这样可以确保有更多的信封可以与其行程上升序列</span><br>                        <span class="hljs-comment">// 举例：同样是上升长度为 5 的序列，保留最小高度为 5 记录（而不是保留任意的，比如 10），这样之后高度为 7 8 9 的信封都能形成序列；</span><br>                        g[prev] = Math.min(g[prev], cur);<br>                    &#125;<br>                    j++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 二分过程</span><br>            <span class="hljs-comment">// g[i] 代表的是上升子序列长度为 i 的「最小信封高度」</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 令 check 条件为 es[i][1] &lt;= g[mid]（代表 w 和 h 都严格小于当前信封）</span><br>                <span class="hljs-comment">// 这样我们找到的就是满足条件，最靠近数组中心点的数据（也就是满足 check 条件的最大下标）</span><br>                <span class="hljs-comment">// 对应回 g[] 数组的含义，其实就是找到 w 和 h 都满足条件的最大上升长度</span><br>                <span class="hljs-keyword">if</span> (es[i][<span class="hljs-number">1</span>] &lt;= g[mid]) &#123;<br>                    r = mid;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新 f[i] 与答案</span><br>            f[i] = r;<br>            ans = Math.max(ans, f[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量</a><br>按攻击力升序，按防御力降序即可判断是否有角色比本角色弱。<br>本题求的是弱角色的数量，而不是求比各个角色弱的角色数量，计算时需要去重。<br>可以使用队列记录防御力，若当前角色防御力高于队尾角色，则应该将尾部不断出队，然后将当前角色入队。每出队一个角色即有一个弱角色。</p><p><a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度</a><br>本质就是遍历dp，但可以剪枝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Map求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length,ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            map.put(arr[i], i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ivalue</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">//剪枝</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">2</span>*arr[j]&gt;arr[i];j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> map.getOrDefault(arr[i] - arr[j], -<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(k == -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[j][i] = Math.max(dp[k][j] + <span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>                ans = Math.max(ans,dp[j][i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//OOM</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lenLongestFibSubseq</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length,ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> arr[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxValue+<span class="hljs-number">1</span>][maxValue+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">iValue</span> <span class="hljs-operator">=</span> arr[i];<br>            dp[<span class="hljs-number">0</span>][iValue] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]&gt;iValue/<span class="hljs-number">2</span>;j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">jValue</span> <span class="hljs-operator">=</span> arr[j];<br>                <span class="hljs-keyword">if</span>(dp[<span class="hljs-number">0</span>][iValue-jValue] != <span class="hljs-number">0</span>)&#123;<br>                    dp[jValue][iValue] = Math.max(<span class="hljs-number">3</span>,dp[iValue-jValue][jValue]+<span class="hljs-number">1</span>);<br>                    ans = Math.max(ans,dp[jValue][iValue]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/largest-divisible-subset/">368. 最大整除子集</a><br>排序后，只有后面数是前面数的倍数，就可以连接成子集，因此只需要找到并记录最长子集的长度和最大数。然后倒序推理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">largestDivisibleSubset</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxVal</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]%nums[j] == <span class="hljs-number">0</span>)&#123;<br>                    dp[i] = Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i]&gt;maxSize)&#123;<br>                maxSize = dp[i];<br>                maxVal = nums[i];<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(maxVal%nums[i] == <span class="hljs-number">0</span> &amp;&amp; dp[i] == maxSize)&#123;<br>                list.add(nums[i]);<br>                maxVal = nums[i];<br>                maxSize--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a><br>使用lowbit方法dp</p><p><a href="https://leetcode.cn/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//最后的i一定是j的倍数，枚举j，实现状态转移复制可以视为 第一次”粘贴“（原文本）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//f[i]为复制得到i个A需要的操作次数</span><br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//f[1] = 0; 可省略，表示得到1个A需要0次操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            f[i] = Integer.MAX_VALUE;<br>            <span class="hljs-comment">//枚举i的因数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j * j &lt;= i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">//如果上次是j复制得到，可能是得到一个j后复制粘贴i/j次：f[j]+i/j</span><br>                    f[i] = Math.min(f[i], f[j] + i / j);<br>                    <span class="hljs-comment">//也可能是i/j复制得到，可能是得到一个i/j后复制粘贴j次：f[i/j]+j</span><br>                    f[i] = Math.min(f[i], f[i / j] + j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a></p><ol><li>使用优先队列，每取出一个最小元素就将其可能新增的三个元素添加到队列中，并利用set去重。</li><li>使用三指针，分别记录<code>*2</code>、<code>*3</code>、<code>*5</code>的数字指针（由于结果是递增的，所以指针总是右移，每次取乘对于倍数最小的数即可，然后移动该指针）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] ugly = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        ugly[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,p2 = <span class="hljs-number">1</span>,p3 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> Math.min(ugly[p1]*<span class="hljs-number">2</span>,Math.min(ugly[p2]*<span class="hljs-number">3</span>,ugly[p3]*<span class="hljs-number">5</span>));<br>            ugly[i] = next;<br>            <span class="hljs-keyword">if</span>(next == ugly[p1] *<span class="hljs-number">2</span>)&#123;<br>                p1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(next == ugly[p2] *<span class="hljs-number">3</span>)&#123;<br>                p2++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(next == ugly[p3] *<span class="hljs-number">5</span>)&#123;<br>                p3++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ugly[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//dp[i]表示数字i任意拆分再相乘后能得到的最大值</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">curMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                curMax = Math.max(curMax,Math.max((i-j)*j,j*dp[i-j]));<br>            &#125;<br>            dp[i] = curMax;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、区间dp"><a href="#四、区间dp" class="headerlink" title="四、区间dp"></a>四、区间dp</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球</a><br><a href="https://leetcode.cn/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a><br>可以分析，我们对数进行k次分组，递推公式为：<br><code>dp[k][i] = dp[k-1][j]+avg[j,i];</code><br>此时可以判断每次只利用上一次循环比i小的索引，所以只要更新索引时从大到小更新，就可以只使用一个数组判断：<br><code>dp[i] = dp[j] + avg[j,i]</code></p><p>临界条件的判断：<br>当k &#x3D;&#x3D; 1时，<code>dp[1][i] = pre[i]/i</code>，所以预先处理dp函数后，循环的次数应该减少一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">largestSumOfAverages</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-type">double</span>[] P = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[N+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)<br>            P[i+<span class="hljs-number">1</span>] = P[i] + A[i];<br><br>        <span class="hljs-type">double</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        <span class="hljs-comment">//dp[i]中依然包含i的值，注意P[i]的定义是，小标i前面的前缀和，所以后面的递推中，i和j都要+1。</span><br>            dp[i] = P[i+<span class="hljs-number">1</span>] / (i+<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//因为k == 1时已经处理，这里少一次循环。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; k &lt;= K; ++k)<br>            <span class="hljs-comment">//i表示i坐标及之前的数分成k份（i+1&gt;=k）时，能够得到的最大数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> N-<span class="hljs-number">1</span>; i &gt;= k-<span class="hljs-number">1</span> ; i--)<br>                <span class="hljs-comment">//j表示j坐标及之前的数分成k-1份(j+1&gt;=k-1)，能够得到的最大平均数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i-<span class="hljs-number">1</span>; j &gt;=k-<span class="hljs-number">2</span>; j--)<br>                <span class="hljs-comment">//i和j的终止条件为&gt;=0</span><br>                    dp[i] = Math.max(dp[i], (P[i+<span class="hljs-number">1</span>]-P[j+<span class="hljs-number">1</span>]) / (i-j) + dp[j]);<br>        <span class="hljs-keyword">return</span> dp[N-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            preSum[i] = preSum[i-<span class="hljs-number">1</span>] + nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i] = preSum[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;m&lt;=k;m++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=m-<span class="hljs-number">1</span>;i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=m-<span class="hljs-number">2</span>;j--)&#123;<br>                    dp[i] = Math.min(dp[i],Math.max(dp[j],preSum[i+<span class="hljs-number">1</span>]-preSum[j+<span class="hljs-number">1</span>]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以使用贪心二分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贪心二分，很巧妙</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">splitArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            right += nums[i];<br>            <span class="hljs-keyword">if</span> (left &lt; nums[i]) &#123;<br>                left = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) / <span class="hljs-number">2</span> + left;<br>            <span class="hljs-comment">//以mid为每片上限，可以分成m片</span><br>            <span class="hljs-keyword">if</span> (check(nums, mid, m)) &#123;<br>                <span class="hljs-comment">//令right = mid</span><br>                right = mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//mid为上线无法分成m片，所以每片上限必须增加</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><span class="hljs-comment">//检查以x为上限，可以分成m片吗？</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> m)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (sum + nums[i] &gt; x) &#123;<br>                cnt++;<br>                sum = nums[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum += nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &lt;= m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/">1444. 切披萨的方案数</a><br>看下思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//正向dp，dp[i][j][k]，表示当以i,j为左上角时，已经切了k刀了（相当于分了k+1份）时，剩下的能满足要求的切法数量。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][][] dp;<br>    <span class="hljs-type">char</span>[][] pz;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> need;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways</span><span class="hljs-params">(String[] pizza, <span class="hljs-type">int</span> k)</span> &#123;<br>        m = pizza.length;<br>        n = pizza[<span class="hljs-number">0</span>].length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][k];<br>        pz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[m][n];<br>        need = k;<br>        <span class="hljs-comment">//初始化，-1为尚未计算过的dp。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                pz[i][j] = pizza[i].charAt(j);<br>                Arrays.fill(dp[i][j],-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ways(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ways</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> cuted)</span>&#123;<br>        <span class="hljs-comment">//超出边界，为0；</span><br>        <span class="hljs-keyword">if</span>(x&gt;=m || y&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//已经计算过，直接返回</span><br>        <span class="hljs-keyword">if</span>(dp[x][y][cuted] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> dp[x][y][cuted];<br>        <span class="hljs-comment">//如果已经切了k-1刀，则已经分成了k份，检查最后一份是否合格即可</span><br>        <span class="hljs-keyword">if</span>(cuted == need-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;m;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(pz[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">return</span>  dp[x][y][cuted] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span>  dp[x][y][cuted] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//否则，要考虑怎么切这一块披萨</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[x][y][cuted] = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> row=m-<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> col=n-<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//首先计算有披萨存在的行和列，我们的切法应该在该行、列的下一行、列。</span><br>            a:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;m;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(pz[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                        row = i;<br>                        <span class="hljs-keyword">break</span> a;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            b:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=y;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;m;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(pz[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                        col = j;<br>                        <span class="hljs-keyword">break</span> b;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//横着切，注意防止超过范围</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row+<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            dp[x][y][cuted] = (dp[x][y][cuted]+ways(i,col,cuted+<span class="hljs-number">1</span>))%mod;<br>        &#125;<br>            <span class="hljs-comment">//竖着切</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=col+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[x][y][cuted] = (dp[x][y][cuted]+ways(row,j,cuted+<span class="hljs-number">1</span>))%mod;<br>            &#125;<br>            <span class="hljs-comment">//返回值。</span><br>            <span class="hljs-keyword">return</span> dp[x][y][cuted]%mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/allocate-mailboxes/">1478. 安排邮筒</a><br>写出递推公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前i个房子安排k个邮筒 = 前j个房子安排k-1个邮筒 + j个房子到i个房子安排1个邮筒。</span><br>dp[i][k] = min(j=i-<span class="hljs-number">1</span>-&gt;<span class="hljs-number">0</span>)(dp[j][k-<span class="hljs-number">1</span>] + getSum[j][i])<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自己写的，getSum重复计算较多，可以预处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(houses);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> houses.length;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">//初始化1个邮箱的情况</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i] = getInstance(houses,-<span class="hljs-number">1</span>,i);<br>        &#125;<br>        <span class="hljs-comment">//从2个邮箱开始考虑</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> m=<span class="hljs-number">2</span>;m&lt;=k;m++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                    dp[i] = Math.min(dp[i],dp[j]+getSum(houses,j,i));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//不包括start索引邮箱</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;<br>        <span class="hljs-keyword">if</span>(start + <span class="hljs-number">1</span> == end)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> start+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> end;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                ans += houses[right--]-houses[left++];<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">int</span>[] houses, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> houses.length;<br>        Arrays.sort(houses);<br><span class="hljs-comment">//表示从第i个到第j个邮箱的和</span><br>        <span class="hljs-type">int</span>[][] midSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                midSum[i][j] = midSum[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+houses[j]-houses[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][k+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            Arrays.fill(dp[i],Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i][<span class="hljs-number">1</span>] = midSum[<span class="hljs-number">0</span>][i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=k &amp;&amp; j&lt;=i+<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;q&lt;i;q++)&#123;<br>                    dp[i][j] = Math.min(dp[i][j],dp[q][j-<span class="hljs-number">1</span>]+midSum[q+<span class="hljs-number">1</span>][i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」</a></p><ol><li>统计不同奇数个数的前缀子数组个数</li><li>统计不同奇数个数的前缀子数组的开始坐标，两个开始坐标只差即为对应前缀子数组个数。<br><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组</a><br>通过取模，模相等即说明可整除，避免了枚举前缀和。<blockquote><p>java的%是取余，向零取整，<strong>结果符号随被除数</strong>。<br>取模为<code>Math.floorMod(a,b)</code>，向下取整，<strong>结果符号随除数</strong>。</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysDivByK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        record.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> elem : nums) &#123;<br>            sum += elem;<br>            <span class="hljs-comment">// 注意 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">modulus</span> <span class="hljs-operator">=</span> (sum % k + k) % k;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">same</span> <span class="hljs-operator">=</span> record.getOrDefault(modulus, <span class="hljs-number">0</span>);<br>            ans += same;<br>            record.put(modulus, same + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/">1477. 找两个和为目标值且不重叠的子数组</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSumOfLengths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-comment">//dp[i]表示索引i前出现的等于target的数组的最小长度。</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(;right&lt;=n;right++)&#123;<br>            sum += arr[right-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span>(sum &gt; target)&#123;<br>                sum -= arr[left++];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum == target)&#123;<br>                dp[right] = Math.min(dp[right-<span class="hljs-number">1</span>],right-left);<br>                ans = Math.min(ans,dp[left]+right-left);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[right] = dp[right-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans == Integer.MAX_VALUE/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a><br>相当于找异或和为0的的片段长度 之和，可以通过维护各异或值的 出现次数 和 出现的索引之和，来快速求每次出现重复异或值时可以贡献的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countTriplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        Map&lt;Integer,Integer&gt; bitCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer,Integer&gt; bitPreSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preBit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        bitCount.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        bitPreSum.put(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            preBit ^= arr[i];<br>            <span class="hljs-keyword">if</span>(bitCount.containsKey(preBit))&#123;<br>                ans += bitCount.get(preBit)*i-bitPreSum.get(preBit);<br>            &#125;<br>            bitCount.put(preBit,bitCount.getOrDefault(preBit,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>            bitPreSum.put(preBit,bitPreSum.getOrDefault(preBit,<span class="hljs-number">0</span>)+i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/remove-boxes/">546. 移除盒子</a><br>状态为区间<code>[i,j]</code>且j后面有k个与j颜色相同的盒子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][][] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeBoxes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] boxes)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> boxes.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length][length][length];<br>        <span class="hljs-keyword">return</span> calculatePoints(boxes, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculatePoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[] boxes, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//越界或已经记忆时直接返回</span><br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp[l][r][k] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[l][r][k];<br>        <span class="hljs-comment">//查看相同的右端元素数量，简化计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> r, k1 = k;<br>        <span class="hljs-keyword">while</span> (r1 &gt; l &amp;&amp; boxes[r1 - <span class="hljs-number">1</span>] == boxes[r1]) &#123;<br>            r1--;<br>            k1++;<br>        &#125;<br>        <span class="hljs-comment">//先取最右侧元素</span><br>        dp[l][r][k] = calculatePoints(boxes, l, r1-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + (k1 + <span class="hljs-number">1</span>) * (k1 + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//取中间元素，让最右侧元素和前面相同的元素相遇</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l; i &lt; r1; i++) &#123;<br>            <span class="hljs-keyword">if</span> (boxes[i] == boxes[r1]) &#123;<br>                dp[l][r][k] = Math.max(dp[l][r][k], calculatePoints(boxes, l, i, k1 + <span class="hljs-number">1</span>) + calculatePoints(boxes, i + <span class="hljs-number">1</span>, r1-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[l][r][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">1000. 合并石头的最低成本</a><br><code>dp[i][j]</code>表示把<code>[i,j]</code>区间尽可能的合并消耗的最低成本。</p><ul><li>j-i&lt;k-1时，成本为0</li><li>j-i&#x3D;k-1时，必须进行一次合并，出现一个唯一成本</li><li>j-i&gt;k-1时，必须尽可能地合并，出现一个最低成本并剩余若干元素（不超过k个）</li></ul><p>递推时：</p><ul><li>j-i&lt;k-1时不需要处理</li><li>j-i&#x3D;k-1时，进行合并</li><li>j-i&gt;k-1时，将区间分成两个部分，为了保证尽可能地合并，需要左侧或右侧至少有一侧发生了合并，即长度&gt;&#x3D;k。所以划分界线时，采取了左侧为一个堆，右侧尽可能合并地的策略。<ul><li>当左侧只有左端一个元素时，右侧必然发生了尽可能地合并，此时对应左侧元素最后才参与合并的情形。</li><li>当左侧有n*(k-1)+1个元素时，表示左侧提前参与了合并的情形。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//取不同分界点，左右分别合并，保证左边为1堆</span><br>dp[i][j] = min(dp[i][p] + dp[p + <span class="hljs-number">1</span>][j])<br><span class="hljs-comment">//如果左右</span><br>dp[i][j] += sum(i, j)<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;两个都多余元素的区间合并时，会自动将多余元素并入到最后一次大区间的分数计算中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeStones</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones, <span class="hljs-type">int</span> k)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;  <br>    <span class="hljs-comment">//每次合并消耗k-1个石头，最后剩1个石头  </span><br>    <span class="hljs-keyword">if</span>((n-<span class="hljs-number">1</span>)% (k-<span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">// 下面这个条件不行，因为k = 2时不成立：if (n % (k - 1) != 1) return -1;  </span><br>    <span class="hljs-comment">//指针左侧和  </span><br>    <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;  <br>        preSum[i] = preSum[i-<span class="hljs-number">1</span>] + stones[i-<span class="hljs-number">1</span>];  <br>    &#125;  <br>    <span class="hljs-comment">//dp[i][j]表示区间[i,j]内元素尽可能合并的最小成本  </span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];  <br>    <span class="hljs-comment">//从k开始枚举长度，而不是从1  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> k;len&lt;=n;len++)&#123;  <br>        <span class="hljs-comment">//枚举区间起点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n-len;i++)&#123;  <br>            <span class="hljs-comment">//区间终点  </span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+len-<span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">//初始化  </span><br>            dp[i][j] = Integer.MAX_VALUE;  <br>            <span class="hljs-comment">//分界点，步长为k-1，左边合并成1堆，右边尽可能的合并  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=i;p&lt;j;p += k-<span class="hljs-number">1</span>)&#123;  <br>                dp[i][j] = Math.min(dp[i][j],dp[i][p] + dp[p+<span class="hljs-number">1</span>][j]);  <br>            &#125;  <br>            <span class="hljs-comment">//如果左右两侧可以继续合并  </span><br>            <span class="hljs-keyword">if</span>((j-i)%(k-<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) dp[i][j] += preSum[j+<span class="hljs-number">1</span>]-preSum[i];  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];  <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/encode-string-with-shortest-length/">471. 编码最短长度的字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    String[][] dp;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[n][n];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; len &lt;= n; len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + len - <span class="hljs-number">1</span>;<br>                dp[i][j] = lc459(s, i, j);<br>                <span class="hljs-comment">//长度大于4时，考虑分割</span><br>                <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">4</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; j; k++)&#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">split</span> <span class="hljs-operator">=</span> dp[i][k] + dp[k + <span class="hljs-number">1</span>][j];<br>                        <span class="hljs-keyword">if</span>(dp[i][j].length() &gt; split.length()) dp[i][j] = split;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 另 t = s + s, 从下标 1 的字符开始查找字符串s， 找到下标p，</span><br><span class="hljs-comment">     * 如果p != n, 存在连续重复的子字符串ps = s.substring(0, p), 个数为 n / p</span><br><span class="hljs-comment">     * 否则， 不存在连续重复子字符串， 无法进行编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">lc459</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        s = s.substring(i, j + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//长度不超过4时，不用考虑编码</span><br>        <span class="hljs-keyword">if</span>(s.length() &lt;= <span class="hljs-number">4</span>)  <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (s + s).indexOf(s, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(p != s.length())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> s.length() / p;<br>            <span class="hljs-keyword">return</span> cnt + <span class="hljs-string">&quot;[&quot;</span> + dp[i][i + p - <span class="hljs-number">1</span>] + <span class="hljs-string">&quot;]&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//否则， 无法进行编码</span><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/stone-game-vii/">1690. 石子游戏 VII</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">stoneGameVII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-comment">//由于得分特殊计算方式，预处理前缀和,这里包括不包括对应索引数值，即preSum[1]不包括stone[1]</span><br>        <span class="hljs-type">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            preSum[i+<span class="hljs-number">1</span>] = preSum[i]+stones[i];<br>        &#125;<br>        <span class="hljs-comment">//取区间[i,j]可以得到的最大优势</span><br>        <span class="hljs-comment">//int[][] dp = new int[n][n];</span><br>        <span class="hljs-comment">//dp[i][j] = Math.max(value[i+1,j]-dp[i+1][j],value[i,j-1]-dp[i][j-1]),i-&gt;0,j-&gt;n</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 以下初始化是错误的，其建立在一个人拿一个石头可以得分，实际上一个人拿只能得0分</span><br>        <span class="hljs-comment">// for(int i=0;i&lt;n;i++)&#123;</span><br>        <span class="hljs-comment">//     dp[i] = stones[i];</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[j] = Math.max(preSum[j+<span class="hljs-number">1</span>]-preSum[i+<span class="hljs-number">1</span>]-dp[j],preSum[j]-preSum[i]-dp[j-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a><br>先将字符串处理成离散的元素，然后区间dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ADDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SUBTRACTION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MULTIPLICATION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">diffWaysToCompute</span><span class="hljs-params">(String expression)</span> &#123;<br>    <span class="hljs-comment">//先将字符串处理成离散的元素。</span><br>        List&lt;Integer&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; expression.length();) &#123;<br>            <span class="hljs-keyword">if</span> (!Character.isDigit(expression.charAt(i))) &#123;<br>                <span class="hljs-keyword">if</span> (expression.charAt(i) == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    ops.add(ADDITION);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression.charAt(i) == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    ops.add(SUBTRACTION);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ops.add(MULTIPLICATION);<br>                &#125;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//对于数字，考虑其长度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; expression.length() &amp;&amp; Character.isDigit(expression.charAt(i))) &#123;<br>                    t = t * <span class="hljs-number">10</span> + expression.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    i++;<br>                &#125;<br>                ops.add(t);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//初始化dp，dp[i][j]表示某区间下可能得到得所有值（可重复）。</span><br>        List&lt;Integer&gt;[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[ops.size()][ops.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ops.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; ops.size(); j++) &#123;<br>                dp[i][j] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//初始化所有区间大小为1得情况，即单独数字，所以这里i的步长为2，略过符号</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ops.size(); i += <span class="hljs-number">2</span>) &#123;<br>            dp[i][i].add(ops.get(i));<br>        &#125;<br>        <span class="hljs-comment">//枚举总字符长度，必然为奇数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= ops.size(); i++) &#123;<br>        <span class="hljs-comment">//枚举开头字符的索引，必然为偶数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j + i &lt;= ops.size(); j += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> j + i - <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//枚举中间的断开点，即符号点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>; k &lt; r; k += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">//获取符号左右可以得到的值的集合</span><br>                    List&lt;Integer&gt; left = dp[l][k - <span class="hljs-number">1</span>];<br>                    List&lt;Integer&gt; right = dp[k + <span class="hljs-number">1</span>][r];<br>                    <span class="hljs-comment">//批量处理，根据符号判断两数的运算方式</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num1 : left) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num2 : right) &#123;<br>                            <span class="hljs-keyword">if</span> (ops.get(k) == ADDITION) &#123;<br>                                dp[l][r].add(num1 + num2);<br>                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ops.get(k) == SUBTRACTION) &#123;<br>                                dp[l][r].add(num1 - num2);<br>                            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ops.get(k) == MULTIPLICATION) &#123;<br>                                dp[l][r].add(num1 * num2);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后返回</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][ops.size() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="五、矩阵区域问题"><a href="#五、矩阵区域问题" class="headerlink" title="五、矩阵区域问题"></a>五、矩阵区域问题</h1><p>一般求矩阵和等情况，需要通过预处理，避免大量计算。<br><em>例题</em><br><a href="https://leetcode.cn/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵</a><br>暴力解：</p><ul><li>固定上边<ul><li>扩大下边，利用上一轮dp情况减少计算量。<ul><li>上下边中间的各列和都计算出来后，转化为求一维数组的最大数值。</li></ul></li></ul></li></ul><p><a href="https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值</a><br>与最大子矩阵类似，使用treeset记录前缀和数值，实现计算最大数值不超过K的逻辑。</p><p><a href="https://leetcode.cn/problems/matrix-block-sum/">1314. 矩阵区域和</a><br><code>pre[i][j]</code>表示坐标（i,j）左上角的区域和，这样，每个矩阵区域都可以由4个角的坐标来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrixBlockSum(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                pre[i][j] = pre[i-<span class="hljs-number">1</span>][j]+pre[i][j-<span class="hljs-number">1</span>]-pre[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+mat[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point1i</span> <span class="hljs-operator">=</span> i-k&gt;=<span class="hljs-number">0</span>?i-k:<span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point1j</span> <span class="hljs-operator">=</span> j-k&gt;=<span class="hljs-number">0</span>?j-k:<span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point2i</span> <span class="hljs-operator">=</span> i+k+<span class="hljs-number">1</span>&lt;=m?i+k+<span class="hljs-number">1</span>:m;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">point2j</span> <span class="hljs-operator">=</span> j+k+<span class="hljs-number">1</span>&lt;=n?j+k+<span class="hljs-number">1</span>:n;<br>                ans[i][j] = pre[point2i][point2j]+pre[point1i][point1j]-pre[point1i][point2j]-pre[point2i][point1j];<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、背包问题"><a href="#六、背包问题" class="headerlink" title="六、背包问题"></a>六、背包问题</h1><p><em>基本场景</em>：有<code>N</code>件物品，背包容量为<code>V</code>，每件物品消耗空间<code>c[i]</code>，价值<code>w[i]</code>。<br><em>基本问题</em>：可以得到的最大价值&#x2F;背包恰好装满时可以得到的最大价值<br>    - 可以通过初始化的方式解决，最大价值可以将f初始化为0，恰好装满可以初始化为-∞，表示不可达。</p><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">CSDN</a></li><li><a href="https://zhuanlan.zhihu.com/p/139368825">知乎</a></li></ul></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><em>限定条件</em>：每件物品只有一件。<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225231137.png"><br>优化</p><ul><li>空间复杂度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> V; j &gt;= <span class="hljs-number">0</span>; j--)<br>        f[j] = max(f[j], f[j - c[i]] + w[i]);<br></code></pre></td></tr></table></figure></li><li>常数空间：<ul><li>j循环的最小边界可以限定在<code>max(c[i]，V-sum&#123;c[i+1]+c[i+2]+...+c[n]&#125;)</code>：前面是因为只有<code>j&gt;=c[i]</code>时才可以放置物品<code>i</code>;后面是因为如果此时<code>V</code>在放入i后面所有物品后仍能大于<code>c[i]</code>，说明当背包空间为V时，i及后面的物品可以全部放进背包，没有必要再枚举更小的背包空间了查看i物品是否应该放入了。</li></ul></li></ul><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><em>限定条件</em>：每件物品有无数个。<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225232603.png"><br>优化</p><ul><li>逻辑：可以直接忽略费用高但价值低的物品。</li><li>简化：转化为01背包问题，但每次递推时是建立在当前物品可能已经被选择过的情形。</li><li>空间复杂度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> c[i]; j &lt;= V; j++)<br>        f[j] = max(f[j], f[j - c[i]] + w[i]);<br></code></pre></td></tr></table></figure></li></ul><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><em>限定条件</em>：每件物品有若干个。<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225232946.png"><br>优化</p><ul><li>简化：<ul><li>转化为01背包问题。</li><li>拆分，将物品拆分为1，2，4份原物品的数量。</li></ul></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//物品</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-comment">//空间</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> V; j &gt;= c[i]; j--)<br><span class="hljs-comment">//数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt;= p[i] and k * c[i] &lt;= j; k++)<br>f[j] = max(f[j], f[j - c[i] * k] + w[i] * k);<br></code></pre></td></tr></table></figure><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p><em>限定条件</em>：物品数有多种情况<br>结合01背包和完全背包，分别顺序，逆序，指定循环次数</p><h3 id="二维费用"><a href="#二维费用" class="headerlink" title="二维费用"></a>二维费用</h3><p><em>限定条件</em>：每个物品有两个纬度的cost<br>多建立一个费用纬度矩阵即可，其他类似。</p><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p><em>限定条件</em>：物品分组，每组只能取一个<br>基本状态转移方程：<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230225233434.png"></p><h3 id="依赖背包"><a href="#依赖背包" class="headerlink" title="依赖背包"></a>依赖背包</h3><p><em>限定条件</em>：某个物品依赖于某个主物品<br>等效于将物品按主物品分多个组，每个组内不同的搭配策略为一种物品。</p><h3 id="泛化物品"><a href="#泛化物品" class="headerlink" title="泛化物品"></a>泛化物品</h3><p><em>限定条件</em>：物品的价值取决于消耗</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a><br>分析：完全背包问题，恰好装满背包，求最小花费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//完全背包问题经典解法（完全背包）</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-comment">//硬币种类（物品种类）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br><span class="hljs-comment">//选择到第n个物品，容量为amount时最少硬币数。</span><br><span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>][amount+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//初始化，恰好装满背包的问题</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>Arrays.fill(dp[i],Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//外循环物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//物品cost</span><br><span class="hljs-type">int</span> <span class="hljs-variable">coin</span> <span class="hljs-operator">=</span> coins[i-<span class="hljs-number">1</span>];<br><span class="hljs-comment">//内循环容量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=amount;j++)&#123;<br><span class="hljs-comment">//这里二维数组的定义是，选择完i时（无论有没有选择i物品），背包容量为j时的最小花费。所以即便这里出现j&lt;coin时无法选择i物品的情况，也需要对所有容量j进行赋值，便于下一轮的计算，所以j从1开始遍历</span><br>dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">if</span>(j&gt;=coin)&#123;<br>dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-coin]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> dp[n][amount] == Integer.MAX_VALUE/<span class="hljs-number">2</span>?-<span class="hljs-number">1</span>:dp[n][amount];<br>&#125;<br><br><span class="hljs-comment">//压缩空间，省略物品纬度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-comment">//硬币种类（物品种类）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br><span class="hljs-comment">//容量为amount时最少硬币数。</span><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//初始化，恰好装满背包的问题</span><br>Arrays.fill(dp,Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//开始取物品</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-comment">//物品cost</span><br><span class="hljs-type">int</span> <span class="hljs-variable">coin</span> <span class="hljs-operator">=</span> coins[i-<span class="hljs-number">1</span>];<br><span class="hljs-comment">//枚举背包大小，只更新可能取到coin的情况</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=coin;j&lt;=amount;j++)&#123;<br>dp[j] = Math.min(dp[j],dp[j-coin]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE/<span class="hljs-number">2</span>?-<span class="hljs-number">1</span>:dp[amount];<br>&#125;<br><br><span class="hljs-comment">//切换循环顺序</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//初始化，默认不可达</span><br>Arrays.fill(dp,Integer.MAX_VALUE/<span class="hljs-number">2</span>);<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//外循环背包容量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=amount;i++)&#123;<br><span class="hljs-comment">//内循环最后一次添加的硬币</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;coins.length;j++)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">coin</span> <span class="hljs-operator">=</span> coins[j];<br><span class="hljs-keyword">if</span>(i-coin&gt;=<span class="hljs-number">0</span> &amp;&amp; dp[i-coin] != Integer.MAX_VALUE/<span class="hljs-number">2</span>)&#123;<br>dp[i] = Math.min(dp[i],dp[i-coin]+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dp[amount] == Integer.MAX_VALUE/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <ol><li>可以发现使用二维数组时，即使容量无法装下当前物品，也要完成状态转移。</li><li>内外循环的先后可以互换：外循环容量（降序），内循环物品（升序）。</li><li><strong>为何往往先循环物品，后循环容量：对于01背包或多重背包，物品的数量是有限的，先循环物品便于后续选择新物品时不需要担心数量问题。</strong></li><li>当化简递推公式为一维时：<ul><li><strong>对于01、多重背包问题，只能外循环物品、内循环容量。因为外循环物品时，选择一个新物品时不会收到旧物品的数量限制。</strong></li><li>对于完全背包问题，可以只考虑在一个容量下背包的最大&#x2F;装满时最小价值。所以外循环容量时，可以放心的使用之前得到的背包在某容量下的状态。即<strong>完全背包问题可以外循环容量。</strong></li></ul></li><li>由于本题是恰好问题，因此也可以使用DFS处理，本质上dp和dfs不过是自底向上和自顶向下的区别。</li></ol>          </div><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a><br>问题转化：</p><ul><li>两个石头a,b相互抵消，从数字上的体现是a-b&#x3D;c，即得到c石头</li><li>最后剩下的石头 ans &#x3D; Σ(±)a，有一个隐含条件是必须大石头减小石头（可以两个小石头加起来减大石头，因为可以先用一个石头取消耗大石头使其变小），而最后ans必须为正。</li><li>问题变成将原石头分成两份，小的那部分尽可能与大的那部分相等，即尽可能接近sum&#x2F;2：至此，问题转化为了在石头中的01背包问题，背包大小为sum&#x2F;2，要尽可能的装更多块的石头，石头的价值和消耗都为本身大小。</li></ul><p><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a><br>问题转化：<br>无限背包问题，求恰好达到某利润的方案数：</p><ul><li>外循环容量并压缩维度。</li></ul><p><a href="https://leetcode.cn/problems/profitable-schemes/">879. 盈利计划</a><br>问题转化：<br>01背包问题，求超过某利润的方案数：</p><ul><li>外循环物品，内循环容量（一般可以压缩到只有容量维度，维护最大利润，且容量要倒叙遍历）</li><li>与恰好问题不同，这里要求超过利润，且求的是方案数，因此需要各个容量情况下至少达到某利润的方案数，增加了一个维度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>    <span class="hljs-comment">//表示使用了n个容量时，至少达到minProfit的方案数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][minProfit + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> group.length, MOD = (<span class="hljs-type">int</span>)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">members</span> <span class="hljs-operator">=</span> group[i - <span class="hljs-number">1</span>], earn = profit[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= members; j--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> minProfit; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    dp[j][k] = (dp[j][k] + dp[j - members][Math.max(<span class="hljs-number">0</span>, k - earn)]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][minProfit];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shopping-offers/">638. 大礼包</a><br>每件物品&#x2F;套餐的价格和数量都是已知的，剩下的就只需要遍历容量了，这里采用了记忆化+dfs的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    List&lt;Integer&gt; price;<br>    List&lt;List&lt;Integer&gt;&gt; special;<br>    HashMap&lt;List&lt;Integer&gt;,Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shoppingOffers</span><span class="hljs-params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> &#123;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-built_in">this</span>.n = price.size();<br>        <span class="hljs-built_in">this</span>.price = price;<br>        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.special = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-comment">//先处理掉不需要的礼包</span><br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; spe:special)&#123;<br>            <span class="hljs-comment">//m = 礼包的物品种类+1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> spe.size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">spePrice</span> <span class="hljs-operator">=</span> spe.get(m-<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//计算单价总和</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">singlePrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m-<span class="hljs-number">1</span>;i++)&#123;<br>                singlePrice += spe.get(i)*price.get(i);<br>            &#125;<br>            <span class="hljs-comment">//不需要该礼包</span><br>            <span class="hljs-keyword">if</span>(singlePrice&lt;spePrice)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">this</span>.special.add(spe);<br>        &#125;<br>        <span class="hljs-comment">//无限背包问题，背包容量的维度为物品的种类，need为容量，由于维度较高，故不采用dp数组维护状态，而是通过HashMap做记忆，并使用dfs。</span><br>        <span class="hljs-keyword">return</span> dfs(needs);<br>    &#125;<br>    <span class="hljs-comment">//当前还需要的物品数量，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; needs)</span>&#123;<br>        <span class="hljs-keyword">if</span>(map.get(needs) != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> map.get(needs);<br>        <span class="hljs-keyword">if</span>(needs.stream().mapToInt(Integer::valueOf).sum() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//统计需要的最少价格(单价购买)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            minPrice += needs.get(i)*price.get(i);<br>        &#125;<br>        <span class="hljs-comment">//枚举套餐</span><br>        a:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;special.size();i++)&#123;<br>            List&lt;Integer&gt; spe = special.get(i);<br>            List&lt;Integer&gt; nextNeed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">//枚举套餐内物品</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//如果无法装下，进入下一轮</span><br>                <span class="hljs-keyword">if</span>(needs.get(j)&lt;spe.get(j)) <span class="hljs-keyword">continue</span> a;<br>                nextNeed.add(needs.get(j)-spe.get(j));<br>            &#125;<br>            minPrice = Math.min(minPrice,dfs(nextNeed)+spe.get(n));<br>        &#125;<br>        map.put(needs,minPrice);<br>        <span class="hljs-keyword">return</span> minPrice;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七、状态压缩dp"><a href="#七、状态压缩dp" class="headerlink" title="七、状态压缩dp"></a>七、状态压缩dp</h1><p>遇到需要准确维护已选择&#x2F;已经过（待选择&#x2F;待经过）等状态时，使用状态压缩dp。<br>常用技巧：</p><ul><li><p>元素操作</p><ul><li>c 插入 A ：<code>A |= (1 &lt;&lt; c)</code></li><li>A 删除 c ：<code>A &amp;= ~(1 &lt;&lt; c)</code>或<code>A ^= (1&lt;&lt;c)</code></li></ul></li><li><p>集合间操作</p><ul><li>A 置空 ：<code>A = 0</code></li><li>AB并集 ：<code>A | B</code></li><li>AB交集 ：<code>A &amp; B</code></li><li>AB子集?：<code>(A &amp; B) == B</code></li></ul></li><li><p>集合自身操作</p><ul><li>全集 ：<code>(1 &lt;&lt; n) - 1</code></li><li>补集 ：<code>((1 &lt;&lt; n) - 1) ^ A</code></li><li>子集 ：<code>(A &amp; B) == B</code></li></ul></li><li><p>枚举A的子集，假设A为set,每轮循环可以得到一个set的子集，加速了枚举的过程：<br>  <code>for(int s = set;s;s=(s-1)&amp;set)</code></p></li><li><p>补集，s2为set相对s的补集<br>  <code>s2 = s^set</code></p></li><li><p>其他操作</p><ul><li>是否为2的幂：<code>A&amp;(A-1) == 0</code></li><li>将A最低位1置0：&#96;A &#x3D; A&amp;(A-1)&#96;&#96;</li><li>求A最低位1：&#96;A &#x3D; A&amp;(-A)&#96;&#96;，这种操作也叫做lowbit</li><li>求A最高位1：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> lowbit(A)<br><span class="hljs-keyword">while</span>(p != A)<br>&#123;<br>    A -= p;<br>    p = lowbit(A);<br>&#125;<br><span class="hljs-keyword">return</span> p;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><a href="https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/">1371. 每个元音包含偶数次的最长子字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTheLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">switch</span>(c)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>: status ^= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(status == <span class="hljs-number">0</span>)&#123;<br>                ans = Math.max(ans,i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(dp[status] == <span class="hljs-number">0</span>)&#123;<br>                    dp[status] = i;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    ans = Math.max(ans,i-dp[status]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/can-i-win/">464. 我能赢吗</a><br>当前已经选择了的数字就是dp的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    Boolean[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canIWin</span><span class="hljs-params">(<span class="hljs-type">int</span> maxChoosableInteger, <span class="hljs-type">int</span> desiredTotal)</span> &#123;<br>        n = maxChoosableInteger;<br>        <span class="hljs-comment">//提前判断无法到达的情况</span><br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span> &lt; desiredTotal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[<span class="hljs-number">1</span>&lt;&lt;n];<br>        <span class="hljs-keyword">return</span> canWin(<span class="hljs-number">0</span>,desiredTotal);<br>    &#125;<br><span class="hljs-comment">//state情况下，还需要need个数才能赢</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWin</span><span class="hljs-params">(<span class="hljs-type">int</span> state,<span class="hljs-type">int</span> need)</span>&#123;<br>    <span class="hljs-comment">//记忆化返回</span><br>        <span class="hljs-keyword">if</span>(dp[state] != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> dp[state];<br>        <span class="hljs-comment">//从大到小枚举数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-comment">//如果某数字还没被选择过</span><br>            <span class="hljs-keyword">if</span>((state &amp; (<span class="hljs-number">1</span>&lt;&lt;i)) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//检查选择该数字后能否直接胜利</span><br>                <span class="hljs-keyword">if</span>(need&lt;=i+<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">//检查选择该数字后能否间接胜利</span><br>                <span class="hljs-keyword">if</span>(!canWin(state|(<span class="hljs-number">1</span>&lt;&lt;i),need-i-<span class="hljs-number">1</span>))&#123;<br>                    <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//无论选择什么数字都无法胜利时，返回失败</span><br>        <span class="hljs-keyword">return</span> dp[state] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>状态压缩dp本质上就是将状态以bitmap的形式存储的一种手段。<br>这类题常常可以结合记忆化搜索，回溯算法，dfs来解决；</p>          </div><p><a href="https://leetcode.cn/problems/android-unlock-patterns/">351. 安卓系统手势解锁</a><br>需要写一个函数来根据（last,state,next）判断是否是可连接状态。</p><ol><li>使用回溯算法+dfs时，只需要维护一个全局状态<code>boolean[]</code>，dfs的参数为need(即还需要连接多少个元素)，last(上一个连接的元素)，对n-&gt;m都要做一次回溯。</li><li>使用循环做dp时，最后将n-&gt;m的加起来。</li></ol><p><a href="https://leetcode.cn/problems/unique-paths-iii/">980. 不同路径 III</a><br>首先扫描grid，寻找起点和终点，统计需要走的路径数量。</p><ol><li>从起点开始回溯+记忆化搜索+dfs，回溯需要将已经走过的路径标记为3，回溯时标记回0。</li><li>二维状态也可以压缩为一维，此时将所有起点、路径、终点标记为待遍历的点，此时不需要维护全局变量，且可以判断路径是否可走。</li></ol><p><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a><br>状态为当前已经选择的数字，当状态确定时，当前已经得到的组数和当前组已经有的数字数量都可以被确定下来。</p><ol><li>可以先将数组排序，当目前无论选择什么数组都会超出组容量时，快速失败。</li><li>可以使用记忆化，记录state的结果</li><li>不需要维护当前组数，因为可以通过最后所有数字都被获取，即(state &#x3D;&#x3D; (1&lt;&lt;n)-1)来判断到达终点，在这种情况下应该保证每次迭代是合法的，即1中提到的快速失败。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> per, n;<br>    <span class="hljs-type">boolean</span>[] dp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartitionKSubsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">all</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (all % k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        per = all / k;<br>        Arrays.sort(nums);<br>        n = nums.length;<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &gt; per) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span> &lt;&lt; n];<br>        Arrays.fill(dp, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> dfs((<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!dp[s]) &#123;<br>            <span class="hljs-keyword">return</span> dp[s];<br>        &#125;<br>        dp[s] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + p &gt; per) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (((s &gt;&gt; i) &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (dfs(s ^ (<span class="hljs-number">1</span> &lt;&lt; i), (p + nums[i]) % per)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a><br>最短的遍历问题，记得使用广度优先解决，同时使用数组记录防止重复入列带来的消耗，也避免无限循环的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//状态为已经遍历过的节点和当前节点，两个维度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestPathLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        <span class="hljs-keyword">if</span>(graph.length == <span class="hljs-number">0</span> || graph[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-comment">//表示某个状态时，达到了某个节点的情况是否被遍历过，避免重复</span><br>        <span class="hljs-type">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>&lt;&lt;n][n];<br>        <span class="hljs-comment">//因为是寻找最短路径，所以使用了队列，发现走的通的路径时直接返回</span><br>        <span class="hljs-comment">//queue中元素维护了节点状态和当前节点</span><br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>&lt;&lt;i,i&#125;);<br>            visited[<span class="hljs-number">1</span>&lt;&lt;i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size();<br>            <span class="hljs-comment">//level表示路径上已经有level个节点，再加一个节点时，路径长度为level</span><br>            level++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-comment">//取出状态</span><br>                <span class="hljs-type">int</span>[] temp = deque.poll();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> temp[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//遍历节点的临近节点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;graph[last].length;j++)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> graph[last][j];<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">nextState</span> <span class="hljs-operator">=</span> state|(<span class="hljs-number">1</span>&lt;&lt;next);<br>                    <span class="hljs-keyword">if</span>(nextState == ((<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> level;<br>                    <span class="hljs-comment">//如果临近节点和状态已经被遍历过，则继续；</span><br>                    <span class="hljs-keyword">if</span>(visited[nextState][next] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">//否则，添加该情况</span><br>                    deque.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextState,next&#125;);<br>                    visited[nextState][next] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> level;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-the-shortest-superstring/">943. 最短超级串</a><br>分析：</p><ul><li>因为题目保证了不会有一个字符串是另一个字符串的子字符串，所以两个字符串拼接时，长度一定大于原字符串（即两个字符串肯定时交叉关系）。</li><li>可以利用一个函数求出每对字符串s1,s2，拼接后得到的字符串，注意下面API：</li></ul><blockquote><p>API：string1.endWith(string2)，可以看string1是否以string2为结尾。</p></blockquote><ul><li>对于拼接中的字符串，状态只取决于，之前已经选择过了的单词和最后一个选择的单词，这是一个二维数组。</li><li>使用两个二维数组同时维护，某状态下的长度和字符串，因为最后需要返回string。</li></ul><p><a href="https://leetcode.cn/problems/beautiful-arrangement/">526. 优美的排列</a><br>模拟填充过程，从所有数字中选择若干数，一个个放入对应位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countArrangement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>&lt;&lt;n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//枚举状态i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;<br>            <span class="hljs-comment">//枚举最后一个字母j</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-comment">//如果状态i下最后一个字母可以为j</span><br>                <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;(j-<span class="hljs-number">1</span>))) != <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//最后一个字母的索引</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Integer.bitCount(i);<br>                    <span class="hljs-keyword">if</span>(can(index,j))&#123;<br>                        dp[i] += dp[i^(<span class="hljs-number">1</span>&lt;&lt;(j-<span class="hljs-number">1</span>))];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//can函数表示数字j可以放置在坐标i上。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">can</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i%j == <span class="hljs-number">0</span> || j%i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>遇到这种题，多思考状态的转化，随意拿出一个状态，通过枚举其最后一个结尾数即可往前推。</p>          </div><blockquote><p>Integer.bitCount(i); &#x2F;&#x2F;计算i中比特1的数量</p></blockquote><p><a href="https://leetcode.cn/problems/maximum-students-taking-exam/">1349. 参加考试的最大学生数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxStudents</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] seats)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> seats.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> seats[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-comment">//处理禁止坐的地方</span><br>        <span class="hljs-type">int</span>[] bans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ban</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(seats[i-<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>                    ban |= (<span class="hljs-number">1</span>&lt;&lt;j);<br>                &#125;<br>            &#125;<br>            bans[i] = ban;<br>        &#125;<br>        <span class="hljs-comment">//第m排，且最后一排状况为n时的情形数量</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>&lt;&lt;n];<br>        <span class="hljs-comment">//从第一排开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-comment">//遍历本排所有的情形</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)&#123;<br>                <span class="hljs-comment">//如果j本身合法</span><br>                <span class="hljs-keyword">if</span>((j&amp;(j&lt;&lt;<span class="hljs-number">1</span>)) ==<span class="hljs-number">0</span> &amp;&amp; (bans[i]&amp;j) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//遍历上一排的情形</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;n);k++)&#123;<br>                        <span class="hljs-comment">//如果k上一排满足</span><br>                        <span class="hljs-keyword">if</span>(((k&amp;(j&lt;&lt;<span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) &amp;&amp; ((k&amp;(j&gt;&gt;<span class="hljs-number">1</span>))==<span class="hljs-number">0</span>))&#123;<br>                            dp[i][j] = Math.max(dp[i][j],dp[i-<span class="hljs-number">1</span>][k]+Integer.bitCount(j));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp[m]).max().getAsInt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/prison-cells-after-n-days/">957. N 天后的牢房</a><br>注意左右移动位运算时，考虑左端和右端牢房始终不会被占用，因此需要使用掩码。<br>本题使用了两个map记录循环中状态和索引的对应关系，也可以只记录状态对应的索引，遇到循环后压缩循环直接到最后一次循环即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] prisonAfterNDays(<span class="hljs-type">int</span>[] cells, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">//掩码,异或相当于减去</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mask</span> <span class="hljs-operator">=</span> ((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>)-<span class="hljs-number">1</span>)^<span class="hljs-number">1</span>^(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<br>        <span class="hljs-comment">//记忆，《状态，索引》，《索引，状态》</span><br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        Map&lt;Integer,Integer&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> cells.length;<br>        <span class="hljs-comment">//初始化状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(cells[i] == <span class="hljs-number">1</span>)&#123;<br>                state |= <span class="hljs-number">1</span>&lt;&lt;i;<br>            &#125;<br>        &#125;<br>        map.put(state,<span class="hljs-number">0</span>);<br>        map2.put(<span class="hljs-number">0</span>,state);<br>        <span class="hljs-comment">//循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            state = (~((state&lt;&lt;<span class="hljs-number">1</span>) ^ (state&gt;&gt;<span class="hljs-number">1</span>))&amp;mask);<br>            <span class="hljs-keyword">if</span>(map.containsKey(state))&#123;<br>                <span class="hljs-comment">//循环日</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> map.get(state);<br>                <span class="hljs-comment">//循环周期</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> i-j;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> (n-i)%circle+j;<br>                state = map2.get(next);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            map.put(state,i);<br>            map2.put(i,state);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">8</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>            ans[i] = (state&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Integer.toBinaryString(); 将int打印成二进制</p></blockquote><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a><br>一开始打算贪心并使用二分查找的方法，找到刚好可以分给k个孩子的不公平程度。但是孩子们的饼干分配方案是无法贪心的，无法求解。<br>考虑子问题：<br>所有零食中，已经有i个孩子分到了零食s集合，则第i个孩子一定分到的是s集合的子集s1，则前（i-1）个孩子的状态为s2（s-s1)。定义<code>dp[i][s]</code>为i个孩子拿到状态s的最小不公平程度：<br><code>dp[i][s] = Math.min(dp[i-1][s-s1],sum(s1))</code><br>i这个维度可以省略，此时s应该从大到小遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCookies</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cookies, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cookies.length;<br>        <span class="hljs-comment">//初始化sum数组，所有选取状态下饼干的数量之和</span><br>        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[(<span class="hljs-number">1</span>&lt;&lt;n)];<br>        <span class="hljs-comment">//为单一零食包赋值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum[<span class="hljs-number">1</span>&lt;&lt;i] = cookies[i];<br>        &#125;<br>        <span class="hljs-comment">//枚举所有状态</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;<br>            sum[i] = sum[i&amp;(i-<span class="hljs-number">1</span>)] + sum[i&amp;(-i)];<br>        &#125;<br><br>        <span class="hljs-comment">//初始化，只有一个孩子时的不公平程度</span><br>        <span class="hljs-type">int</span>[] dp = sum.clone();<br>        <span class="hljs-comment">//从2开始枚举孩子数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;i++)&#123;<br>            <span class="hljs-comment">//枚举零食包状态</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>;s&gt;<span class="hljs-number">0</span>;s--)&#123;<br>                <span class="hljs-comment">//枚举第i个孩子获得的零食集合s1，相当于求s所有子集</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> s;s1&gt;<span class="hljs-number">0</span>;s1=(s1-<span class="hljs-number">1</span>)&amp;s)&#123;<br>                    dp[s] = Math.min(dp[s],Math.max(dp[s^s1],sum[s1]));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span>&lt;&lt;n)-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/divide-chocolate/">1231. 分享巧克力</a><br>相比上一题，这题则可以贪心，因为巧克力是连续的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximizeSweetness</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sweetness, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(sweetness).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left+right+<span class="hljs-number">1</span>)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//如果可以分成K+1块以上</span><br>            <span class="hljs-keyword">if</span>(divide(sweetness,mid,k+<span class="hljs-number">1</span>))&#123;<br>                left = mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//如果无法分成k块，则需要降低临界值</span><br>                right = mid-<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sweetness,<span class="hljs-type">int</span> maxSweet,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">piece</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sweetness.length;i++)&#123;<br>            sum += sweetness[i];<br>            <span class="hljs-keyword">if</span>(sum&gt;=maxSweet)&#123;<br>                piece++;<br>                sum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> piece&gt;=k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></p><ol><li>dfs，记录当前状态，枚举下一个可选择的火柴，并携带当前边已经有的长度便于计算。</li><li>dp，从1开始枚举状态，每个状态都可以由上一个状态转移，dp则记录当前行长度，最后监测<code>dp[(1&lt;&lt;n)-1]</code>是否为0。</li></ol><h1 id="八、计数dp"><a href="#八、计数dp" class="headerlink" title="八、计数dp"></a>八、计数dp</h1><p>计数dp一般维度不是很高，外循环到题目条件上限即可，难点在于找到递推方程。</p><p><a href="https://leetcode.cn/problems/handshakes-that-dont-cross/">1259. 不相交的握手</a><br>第一个人枚举与其握手的人，将人群切割成两部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> numPeople)</span> &#123;<br>        <span class="hljs-comment">//canChoose</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> numPeople/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[pair+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//0对时，有1种情况</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//1对时，有1种情况</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//开始枚举2对</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=pair;i++)&#123;<br>            <span class="hljs-comment">//第一个节点与其他节点连线包括了2*j个节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                <span class="hljs-comment">//一侧为2*(j-1)个节点，另一侧为2*(i-j)个节点</span><br>                dp[i] = (dp[i] + (dp[j-<span class="hljs-number">1</span>]*dp[i-j])%MOD)%MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)dp[pair];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/sentence-screen-fitting/">418. 屏幕可显示句子的数量</a></p><ul><li>技巧1：可以假设每个单词长度延申一个空格，列数也加1来容纳多出来的空格。</li><li>技巧2：每行的开头必然是一个单词，通过统计（预处理）以每个单词开头时，本行可以得到的句子数（可能为0），以及下一行开始的单词的索引。最后统计行为rows时可以得到答案。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">wordsTyping</span><span class="hljs-params">(String[] sentence, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> &#123;<br>        <span class="hljs-comment">//单词数量为n</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sentence.length;<br>        <span class="hljs-comment">//每个单词占用len[i]个字符,预处理，每个单词可能占用的字符数(包括了空格键);</span><br>        <span class="hljs-type">int</span>[] len = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            len[i] = sentence[i].length() + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//以next[i]作为状态，同时记录下一个单词的索引和该行的句子数量。</span><br>        <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//枚举单词</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-comment">//index为当前单词,cur为当前列索引，假设每行都有col+1列，cnt为当前行结束的句子数量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i, cur = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//再加一个Index时没有达到末尾：</span><br>            <span class="hljs-keyword">while</span>((cur + len[index])&lt;=cols+<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//可以加上index单词</span><br>                cur += len[index];<br>                <span class="hljs-comment">//如果没有到达句子末尾</span><br>                <span class="hljs-keyword">if</span>(index == n-<span class="hljs-number">1</span>)&#123;<br>                    index = <span class="hljs-number">0</span>;<br>                    cnt++;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    index++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//记录该单词开头时该行的状态</span><br>            next[i] = cnt * <span class="hljs-number">100</span> + index;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)&#123;<br>            ans += next[index]/<span class="hljs-number">100</span>;<br>            index = next[index]%<span class="hljs-number">100</span>;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="九、数位dp"><a href="#九、数位dp" class="headerlink" title="九、数位dp"></a>九、数位dp</h1><p>数位dp一般都是求在1~n之间求满足要求的数的个数。<br>我们可以从最高位开始考虑，每位可选择哪些数，以及该选择可能会给后面的选择带来的影响。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><em>灵神模板</em><br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230227154845.png"><br>一般需要记忆化可能会重复使用的情况，而上界情况则不需要记忆，因为只出现一次。因此在判断是否直接利用记忆返回时也需要先判断这一点。<br><img src="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/Pasted-image-20230227154815.png"></p><div class="note note-primary">            <p>该模只遍历<code>[1,n]</code>，对于0和n的边界条件需要额外考虑，下面是经典例题。</p>          </div><p><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSpecialNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        s = Integer.toString(n).toCharArray();<br>        len = s.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            Arrays.fill(dp[i],-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == len) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] &gt;=<span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> dp[i][mask];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isNum) res += dfs(i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=isNum?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,up=isLimit?s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;j&lt;=up;j++)&#123;<br>            <span class="hljs-keyword">if</span>(((mask&gt;&gt;j)&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                res += dfs(i+<span class="hljs-number">1</span>,mask|(<span class="hljs-number">1</span>&lt;&lt;j),isLimit&amp;&amp;(s[i]-<span class="hljs-string">&#x27;0&#x27;</span> == j),<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum)&#123;<br>            dp[i][mask] = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[] s;<br>    String[] digits;<br>    <span class="hljs-type">int</span>[] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostNGivenDigitSet</span><span class="hljs-params">(String[] digits, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//s为target的字符串</span><br>        s = Integer.toString(n).toCharArray();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length];<br>        <span class="hljs-comment">//dp预填充</span><br>        Arrays.fill(dp,-<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.digits = digits;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == s.length) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//只记忆非limit和以及有数字的情况</span><br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果之前没有填入，本处也可以不填入数字</span><br>        <span class="hljs-keyword">if</span>(!isNum) ans = dfs(i+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//枚举数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;digits.length;j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> digits[j].charAt(<span class="hljs-number">0</span>)-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-comment">//如果受限制且超过上界，直接返回</span><br>            <span class="hljs-keyword">if</span>(isLimit &amp;&amp; (cur&gt;s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-keyword">break</span>;<br>            ans += dfs(i+<span class="hljs-number">1</span>,isLimit&amp;&amp;(cur== s[i]-<span class="hljs-string">&#x27;0&#x27;</span>),<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//只记忆非limit和以及有数字的情况</span><br>        <span class="hljs-keyword">if</span>(isNum &amp;&amp; !isLimit) dp[i] = ans;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a><br>可以使用数学的方法写，这里不做介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">char</span>[] s;<br>    <span class="hljs-type">int</span>[][] dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNumbersWithUniqueDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//0,1特殊处理，因为n=1时，10是可以取到数字，但答案不允许数字等于上界。</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            up *= <span class="hljs-number">10</span>;<br>        &#125;<br>        s = Integer.toString(up).toCharArray();<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)&#123;<br>            Arrays.fill(dp[i],-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//加上0</span><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>)+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> mask,<span class="hljs-type">boolean</span> isLimit,<span class="hljs-type">boolean</span> isNum)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i == s.length) <span class="hljs-keyword">return</span> isNum?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum &amp;&amp; dp[i][mask] &gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i][mask];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(!isNum) res += dfs(i+<span class="hljs-number">1</span>,mask,<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=isNum?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,up=isLimit?s[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">9</span>;j&lt;=up;j++)&#123;<br>            <span class="hljs-keyword">if</span>((mask&gt;&gt;j&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;<br>                res += dfs(i+<span class="hljs-number">1</span>,(mask|(<span class="hljs-number">1</span>&lt;&lt;j)),isLimit&amp;&amp;(j==s[i]-<span class="hljs-string">&#x27;0&#x27;</span>),<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!isLimit &amp;&amp; isNum) dp[i][mask] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></p><div class="note note-primary">            <p><code>dp[i]</code>定义为前i个二进制位，所能产生的合法数字的个数。不出现连续的“1”就是合法数字。<br>发现有：<code>dp[n] = dp[n-1]+dp[n-2]</code><br>即：f(xxxx) &#x3D; f(0xxx) + f(10xx) &#x3D;&gt; dp(4)&#x3D;dp(3)+dp(2)</p><p>对于小于n的情形，可以拆解n：<br><code>f(10100) = f(0xxxx) + f(100xx) = dp(4) + dp(2)</code><br>对于连续1情形，处理完该批次即可直接返回：<br><code>f(11010) = f(0xxxx) + f(10xxx) = f(11000)</code>，最后面的1在处理第二个1时已经完全考虑。</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-comment">//预处理dp数组</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">32</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">numStr</span> <span class="hljs-operator">=</span> getBinary(num);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历num各个位置，若为0则继续</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numStr.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (numStr.charAt(i) == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//为1则统计</span><br>            res += dp[numStr.length() - i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; numStr.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">//最后加0</span><br>        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将非负整数转为二进制字符串</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getBinary</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            sb.insert(<span class="hljs-number">0</span>, num &amp; <span class="hljs-number">1</span>);<br>            num &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/confusing-number-ii/">1088. 易混淆数 II</a><br>本题其实不是数位dp，但这种遍历并逐步添加数字的方式可以学习一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//原始字符</span><br>    <span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-comment">//翻转后字符</span><br>    <span class="hljs-type">int</span>[] revs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-comment">//上限n</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">//答案</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">confusingNumberII</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> &#123;<br>        n = m;<br>        <span class="hljs-comment">//遍历字符</span><br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-comment">//curr表示当前枚举数字和其反转对应的数字，digit表示数字长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> curr, <span class="hljs-type">int</span> rev, <span class="hljs-type">int</span> digit)</span> &#123;<br>        <span class="hljs-comment">// 当前枚举的数字&gt;n结束</span><br>        <span class="hljs-keyword">if</span> (curr &gt; n) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果是易混淆数，答案+1;</span><br>        <span class="hljs-keyword">if</span>(curr != rev) &#123;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-comment">// 枚举下一个要加上的数 比如9 假设当前curr是16</span><br>        <span class="hljs-comment">// curr     16  </span><br>        <span class="hljs-comment">// nextCurr 16*10 + 9         =169</span><br>        <span class="hljs-comment">// nextRev  9*100 + rev(61)   =961</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5</span>; k++) &#123;<br>            <span class="hljs-comment">//如果当前没有数字，则不能将0作为第一个数字，即不会去遍历0xxx这样的数字。</span><br>            <span class="hljs-keyword">if</span> (digit == <span class="hljs-number">0</span> &amp;&amp; k == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果当前字符串再添加字符时超出限制，返回</span><br>            <span class="hljs-keyword">if</span> (curr &gt; n/<span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//下一个数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextCurr</span> <span class="hljs-operator">=</span> curr * <span class="hljs-number">10</span> + nums[k];<br>            <span class="hljs-comment">//下一个数的反转</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextRev</span> <span class="hljs-operator">=</span>  revs[k]*(<span class="hljs-type">int</span>)(Math.pow(<span class="hljs-number">10</span>, digit)) + rev;<br>            <span class="hljs-comment">//递归</span><br>            dfs(nextCurr, nextRev, digit+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="X、其他"><a href="#X、其他" class="headerlink" title="X、其他"></a>X、其他</h1><p><em>例题</em><br><a href="https://leetcode.cn/problems/super-egg-drop/">887. 鸡蛋掉落</a></p><ol><li>第一种方法：在某一层x扔下一枚鸡蛋，破碎和不破碎无法干预，所以取最糟糕情况（max），而在哪一层丢下，则是可以计算的，所以取外层取min。</li></ol><ul><li>**<code>dp[i][n]</code>的定义是：使用i个鸡蛋，在n层楼中，确定刚好不破碎点发生在几楼(也可能全排除，此时说明发生在0层)需要的操作数。</li><li>显然在x层扔一次消耗一次操作，后续需要在<code>n-x</code>层楼中找刚好不破碎点（或全排除，此时发生在x层）或者在<code>x-1</code>层楼中寻找刚好不破碎点（或全排除，此时发生在0层）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][n] = <span class="hljs-number">1</span>+min(x=<span class="hljs-number">0</span>-&gt;n)(max(dp[i-<span class="hljs-number">1</span>][x-<span class="hljs-number">1</span>],dp[i][n-x]))<br></code></pre></td></tr></table></figure><p>通过递推公式，可以遍历x求出结果，但应该加速这个过程：<br><code>dp[i-1][x-1]和dp[i][n-x]</code>，分别是随x变化而递增&#x2F;递减的，要使两者的最大值最小，则要求两者的交点（或交点两侧的整数点，这个过程可以通过二分方法加速）</p><ol start="2"><li>第二种方法：转化问题为已知鸡蛋数量和操作次数，求最高可以求得的楼层。</li></ol><p>初始状态下：已知在0层丢不破碎，未知在1层丢是否破碎。</p><ul><li><code>dp[t][k]</code>的含义是，通过t次操作扔k个鸡蛋，可以确定多少楼层丢鸡蛋是否破碎。</li><li>显然，在x层扔一次消耗一次操作（并确定在x层丢鸡蛋是否破碎），若不破碎，则可以向上搜索，将x层作为已知的楼层（如0）进行处理；若未破碎，则可以向下搜索，将x层作为已知的必然破碎楼层，搜索下面的楼层是否破碎即可。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设操作t次，使用k个鸡蛋，那么扔下一次鸡蛋后，若没破，我们可以利用k个鸡蛋和t-1次操作继续向上寻找，如果鸡蛋破了，我们可以利用k-1个鸡蛋和t-1次操作在当前楼层下面进行寻找破碎点。</span><br>dp(t,k)=<span class="hljs-number">1</span>+dp(t−<span class="hljs-number">1</span>,k−<span class="hljs-number">1</span>)+dp(t−<span class="hljs-number">1</span>,k);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">superEggDrop</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//如果只有一层，则一次就可以判断（从1楼丢下）</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//操作i次，使用j个鸡蛋</span><br>        <span class="hljs-type">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>        <span class="hljs-comment">//操作1次，使用n个鸡蛋，可以确定的楼层都只有1层</span><br>            f[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//已知递推公式后：</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>                f[i][j] = <span class="hljs-number">1</span> + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f[i][k] &gt;= n) &#123;<br>                ans = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><ol><li>考虑每列可以接多少水</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划，整体思维，理出各点积水计算公式为  min(leftMax,rightMax)-curHeight</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span>[] leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        <span class="hljs-type">int</span>[] rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        rightMax[m-<span class="hljs-number">1</span>] = height[m-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            leftMax[i] = Math.max(leftMax[i-<span class="hljs-number">1</span>],height[i]);<br>            rightMax[m-i-<span class="hljs-number">1</span>] = Math.max(rightMax[m-i],height[m-i-<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m-<span class="hljs-number">1</span>;i++)&#123;<br>            sum += Math.min(leftMax[i],rightMax[i])-height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//可优化，求左右Max的同时求积，使用双指针解决</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> m-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> height[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> height[m-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//对于一个位置，该位置水量由其左侧最高点，右侧最高点中的较低值决定的，所以如果能确定这个其中一侧的最高点，肯定低于另一侧的最高点即可。</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(leftMax&lt;rightMax)&#123;<br>                sum += leftMax-height[left];<br>                left++;<br>                leftMax = Math.max(leftMax,height[left]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum += rightMax-height[right];<br>                right--;<br>                rightMax = Math.max(rightMax,height[right]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意只需要加到left&lt;right，left=right时不用再加，因为这个点为最高点</span><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>模拟过程，维护递减序列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单调栈，面向过程，对每个整体水沟一行一行的清除，即填入将高度填入递减栈，当遇到比当前值高的则计算依次积水量并把槽填平。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;height.length;i++)&#123;<br>            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; height[i]&gt;height[stack.peek()])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">if</span>(stack.isEmpty())&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> height[top];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> Math.min(height[i],height[stack.peek()]);<br>                ans += (high-low)*(i-stack.peek()-<span class="hljs-number">1</span>);<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/the-skyline-problem/">218. 天际线问题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">getSkyline</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] buildings)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//保存坐标和高度（上升的使用负数，便于排序：坐标位置相同时，优先处理上升，且处理上升最多的元素）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] a:buildings)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a[<span class="hljs-number">0</span>],-a[<span class="hljs-number">2</span>]&#125;);<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        Collections.sort(list,(a,b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//当前高度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//高度的优先队列，当前的图像肯定是最高高度</span><br>        PriorityQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);<br>        queue.add(pre);<br>        <span class="hljs-comment">//逐个增加List</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] a:list)&#123;<br>            <span class="hljs-comment">//发送一次高度变化（可能）</span><br>            <span class="hljs-comment">//如果是负数，变为正数，添加到高度队列中</span><br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">0</span>)&#123;<br>                queue.add(-a[<span class="hljs-number">1</span>]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                queue.remove(a[<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//当前高度</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> queue.peek();<br>            <span class="hljs-comment">//与上一个高度不相等，生成新的点</span><br>            <span class="hljs-keyword">if</span>(temp != pre)&#123;<br>                List&lt;Integer&gt; now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>                now.add(a[<span class="hljs-number">0</span>]);<br>                now.add(temp);<br>                ans.add(now);<br>                pre = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><ul><li>维护单调递增序列</li><li>遇到更低的序列时，对前面比该值低的高度做一次结算</li><li>记录的是不同高度的坐标，因此对于等高的，可以不加入队列。</li></ul><p><a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a><br>逐行遍历，每行都是一个柱状图中最大的矩形为题，且可以继承前一行的留存结果。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域算法（分布式算法）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、一致性Hash算法"><a href="#一、一致性Hash算法" class="headerlink" title="一、一致性Hash算法"></a>一、一致性Hash算法</h1><h1 id="二、Paxos算法"><a href="#二、Paxos算法" class="headerlink" title="二、Paxos算法"></a>二、Paxos算法</h1><h1 id="三、Raft算法"><a href="#三、Raft算法" class="headerlink" title="三、Raft算法"></a>三、Raft算法</h1><p>Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题: Leader选举(Leader election)、日志同步(Log replication)、安全性(Safety)、日志压缩(Log compaction)、成员变更(Membership change)等。</p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>概念：</p><ul><li>Raft定义了三种角色：<strong>领导者（Leader）</strong>、<strong>跟随者（Follower）</strong> 和 <strong>候选人（Candidate）</strong>。跟随者发现领导者掉线时（收不到leader的心跳）成为候选人。</li><li>节点属性：<ul><li>任期：相当于版本号，过期的任期请求是无用的</li><li>跟随节点ID：即给谁投票或现在跟随谁</li></ul></li><li>超时计时器：<ul><li>选举超时时间：发现leader掉线时随机延迟一段时间选举，防止多节点同时候选</li><li>投票超时时间：收集投票时间的倒计时，结束时统计票数</li><li>竞选等待超时时间：选举失败后且没有其他领导者诞生时，等待一段时间再次选举</li></ul></li></ul><p>实现：</p><ul><li>RPC通讯，只有数据追加请求（心跳）和投票请求（投票）</li><li>任期保证了节点不会使用受到的过期消息，并会跟随最新的任期</li><li>多领导人同时选举时，每个节点只会对一个版本号的投票请求投出一次票。</li></ul><h2 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h2><p>步骤：</p><ul><li>每个node维护一个Log日志（类似于数组，有索引，可以理解为复制进度）。</li><li>leader收到客户端请求后，将消息同步到日志中，并复制给所有follows：<ul><li>当大多数follows接受时，leader会提交该日志。</li><li>leader仍需要保证所有flollows都接受了所有日志保证同步。</li></ul></li><li>该日志会按顺序记录命令与任期，且每条记录会对应一个索引。loader同步日志时，会指定索引，follow通过检查log index可以得知自己是否同步。</li></ul><p><em>新leader同步尚未完成时</em><br>旧leader把某条记录同步给部分follows后掉线，新follows不持有这个记录，则新follows的产生的新记录会覆盖这条丢失的记录。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>拥有最新的已提交的log entry的Follower才有资格成为Leader，为此各节点投票时：</p><ul><li>对于比自己所在任期小的不投票。</li><li>对于比自己复制进度小的不投票。</li></ul><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>日志不能无限增长，各节点可对已经提交的日志进行snapshot（类似做一次RDB代替AOF日志），包括：</p><ul><li>最后一条日子的index和term</li><li>系统当前状态</li></ul><h2 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h2><p>一般指：增加&#x2F;减少副本数、节点替换等。</p><p><em>解决方案</em><br>两阶段变更：旧成员配置Cold -&gt; 共同一致（新旧组合配置） -&gt; 新成员配置Cnew。</p><p><em>步骤</em><br>一阶段：</p><ul><li>Leader收到请求，发起成员变更，<strong>进入共同一致状态</strong>并记录Cold U Cnew log。</li><li>Leader复制Cold U Cnew log到所有共同一致状态的节点（包括新旧节点）。</li><li>如果Cold和Cnew两个多数派确认了这条日志，Leader提交该log。</li></ul><p>二阶段：</p><ul><li>Leader记录Cnew log。</li><li>Leader复制Cnew log到所有共同一致状态的节点（包括新旧节点）。</li><li>Follow收到Cnew log后，若发现自己不在其中则退出，否则进入Cnew状态并返回。</li><li>Leader收到Cnew的多数派确认后，Leader提交该log。</li></ul><p><em>约定</em><br>每次只允许增加或删除一名成员。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>领域算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分布式算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域算法（安全算法）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一、摘要算法"><a href="#一、摘要算法" class="headerlink" title="一、摘要算法"></a>一、摘要算法</h1><p><em>摘要算法特点</em></p><ul><li>长度固定</li><li>相同信息求摘要结果相同</li><li>不可逆</li></ul><p><em>摘要算法应用</em></p><ul><li>数字签名和密码加密</li></ul><p><em>常见算法</em></p><ul><li>MD5</li><li>SHA</li></ul><h1 id="二、加密算法"><a href="#二、加密算法" class="headerlink" title="二、加密算法"></a>二、加密算法</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p><em>常见算法</em></p><ul><li>DES，过时。</li><li>IDEA，128位，很少用到。</li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p><em>常见算法</em></p><ul><li>RSA，常用。</li><li>ECDHE，ECC族，椭圆加密，HTTPS使用。</li></ul><h1 id="三、国密算法"><a href="#三、国密算法" class="headerlink" title="三、国密算法"></a>三、国密算法</h1><p>国家密码局认定的国产密码算法。主要有SM1，SM2，SM3，SM4，SM7, SM9。</p>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>领域算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>安全算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法专题（数组）</title>
    <link href="/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <url>/2023/02/08/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%EF%BC%88%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="数组本身性质"><a href="#数组本身性质" class="headerlink" title="数组本身性质"></a>数组本身性质</h2><p>数组本身的索引的具有信息量，对于很多数组类题目要求时间复杂度O(n)，常量空间复杂度的问题，可以考虑把遍历信息保存在数组内部：</p><ul><li>对数组指定索引做标记：加负号；</li><li>将数组元素与指定索引元素做交换；</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a><br><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></p><ol><li>标记出现了的数的正负号</li><li>将出现了的数交换到对于索引上</li></ol><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>数组中的排序有以下功能：</p><ul><li>相同的数字在一起，实现去重</li><li>连续的数字在一起，可以查看连续序列</li><li>两个排序数组对比可以快速比较重合数（使用双指针）</li><li>利用排序可以快速筛选结果</li></ul><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a><br><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a><br>本质是硬解，但通过排序保证第一个元素永远不重复，还可以通过一些手段减枝。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><em>例题</em><br><a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a><br>建立绝对值和索引的映射，根据绝对值排序，根据索引取真实值。<br><a href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/">2171. 拿出最少数目的魔法豆</a><br>拿出最少的数目 &#x3D; 留下最多的数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumRemoval</span><span class="hljs-params">(<span class="hljs-type">int</span>[] beans)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> beans.length;<br>        Arrays.sort(beans);<br>        <span class="hljs-comment">//max表示最多留下的豆子的数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//sum表示所有豆子数量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum += beans[i];<br>            max = Math.max(max,(<span class="hljs-type">long</span>)beans[i] * (n-i));<br>        &#125;<br>        <span class="hljs-comment">//最少拿走的豆子 = 总豆子数 - 最多留下的豆子数。</span><br>        <span class="hljs-keyword">return</span> sum-max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-distance-in-arrays/">624. 数组列表中的最大距离</a><br>对于这种<strong>不需要按先后顺序的排他匹配</strong>问题，可以考虑直接顺序遍历，与已遍历部分比较即可。</p><h3 id="禁止排序"><a href="#禁止排序" class="headerlink" title="禁止排序"></a>禁止排序</h3><p>对于要求n时间复杂度的数组，优先考虑能否利用数组性质保存遍历结果，否则可以通过set等集合保存遍历结果<br><em>例题</em><br><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>对于数组中的滑动窗口首先要注意问题的转化：</p><ul><li>对于<strong>从数组左右两端操作的问题能否转化为对数组中的一个滑动窗口</strong>的问题，如《将x减到0的最小操作数》</li><li>对于窗口内信息的计算能否转化为对窗口两端存储数据的相减，如使用<strong>预处理</strong>方式处理每个元素左边&#x2F;右边的状态，如《爱生气的书店老板》</li><li>差分数组常用于区域<strong>翻转</strong>问题：如将某个数组的一部分翻转（修改正负号或1&#x2F;0变换），判断相邻数的情况。</li></ul><h3 id="静态滑动窗口"><a href="#静态滑动窗口" class="headerlink" title="静态滑动窗口"></a>静态滑动窗口</h3><p>窗口大小不变。<br>每次滑动伴随元素的新增和删除，一般需要维护窗口的性质：</p><ul><li>维护窗口内字符数量等统计信息的：使用如hash，数组等的数据结构维护；</li><li>维护窗口内最大值，最小值的：使用单调队列（LinkedList结构）。</li></ul><blockquote><p>使用数组维护数量时注意：<br>全大&#x2F;小写字符计数：使用<code>int[26]</code>，char-‘a’或-‘A’<br>大小写都有：使用<code>int[58]</code>，char-‘A’<br>全字符：使用<code>int[128]</code></p></blockquote><h4 id="维护窗口统计信息"><a href="#维护窗口统计信息" class="headerlink" title="维护窗口统计信息"></a>维护窗口统计信息</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/">1100. 长度为 K 的无重复字符子串</a><br>可以使用一个数维护重复值，一个Hash&#x2F;数组维护字符的数量<br><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a><br>使用预处理数组记录可能获得的顾客<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><ol><li>使用计数法，并且不收缩滑动窗口。</li><li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li></ol><h4 id="维护窗口最大值"><a href="#维护窗口最大值" class="headerlink" title="维护窗口最大值"></a>维护窗口最大值</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a><br>右指针元素比队列尾部大则先循环pollLast再OfferLast，即将移出的左指针元素刚好等于队头时pollFirst<br><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将x减到0的最小操作数</a><br><a href="https://leetcode.cn/problems/contains-duplicate-iii/">220. 存在重复元素 III</a><br>使用有序集合维护窗口的最大值和最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        TreeSet&lt;Long&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;Long&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">ceiling</span> <span class="hljs-operator">=</span> set.ceiling((<span class="hljs-type">long</span>) nums[i] - (<span class="hljs-type">long</span>) t);<br>            <span class="hljs-keyword">if</span> (ceiling != <span class="hljs-literal">null</span> &amp;&amp; ceiling &lt;= (<span class="hljs-type">long</span>) nums[i] + (<span class="hljs-type">long</span>) t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            set.add((<span class="hljs-type">long</span>) nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                set.remove((<span class="hljs-type">long</span>) nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>回顾TreeMap的API<br>map.ceilingEntry(key)&#x2F;&#x2F;刚好或大于该key的Entry<br>map.floorEntry(key)&#x2F;&#x2F;刚好或小于该key的Entry<br>map.firstEntry(key)&#x2F;&#x2F;最小的Entry<br>map.lastEntry(key)&#x2F;&#x2F;最大的Entry<br>HashSet同理。</p></blockquote><p><a href="https://leetcode.cn/problems/sliding-window-median/">480. 滑动窗口中位数</a><br>通过大堆+小堆的堆顶实现取中位数，然后维护有效元素的平衡<br>移出元素时：</p><ul><li>直接使用remove(Priority提供了这个方法)</li><li>用HashMap记录过期元素，延迟删除堆顶元素</li></ul><h4 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h4><p><em>例题</em><br><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/">995. K连续位的最小翻转次数</a></p><blockquote><p>假设从index&#x3D;0开始判断，每次翻转只翻转index之后长度为k的区域</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minKBitFlips</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>    <span class="hljs-comment">//d[x]记录了A[x]相对A[x-1]翻转了多少次，即d[i] = re[i]-re[i-1]</span><br>    <span class="hljs-comment">//那么第i个数的旋转次数为re[i] = d[0]+d[1]+...+d[i]</span><br>    <span class="hljs-comment">//只需要维护re[i]，即可直到每个位置是否还需要翻转</span><br>        <span class="hljs-type">int</span>[] d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[A.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> count= <span class="hljs-number">0</span> ,sumReA= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;<br>        <span class="hljs-comment">//sumReA表示当前i位旋转的次数</span><br>            sumReA +=d[i];<br>            <span class="hljs-comment">//若当前旋转结果为0，则需要以当前索引为窗口头部进行一次旋转</span><br>            <span class="hljs-keyword">if</span>(((sumReA&amp;<span class="hljs-number">1</span>)^A[i]) ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//若后续已经不能旋转了，说明无法实现</span><br>                <span class="hljs-keyword">if</span>(i+K&gt;A.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//当前位旋转。</span><br>                <span class="hljs-comment">//d[i]+=1; 可省略，后续用不到</span><br>                <span class="hljs-comment">//i+K相对i+K-1少旋转一次</span><br>                d[i+K]-=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//由于d[i]+=1，修正sumReA</span><br>                sumReA+=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//结果++</span><br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态滑动窗口"><a href="#动态滑动窗口" class="headerlink" title="动态滑动窗口"></a>动态滑动窗口</h3><p>动态滑动窗口会在合适的时候扩张：</p><ul><li>使用双指针做窗口条件判断，每循环一次右指针向右扩展一单位，然后考虑左边界的情况。</li><li>使用动态规划的方法维护窗口性质，本质就是用数组保存右指针在某处时的窗口状态。</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a><br>不满足要求后，不根据奇偶判断状态，而是根据上一个序列顺序判断，省去一次遍历，不符合要求时，左指针 &#x3D;&#x3D; 右指针<br><a href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/">1358. 包含所有三种字符的子字符串数目</a><br>先找到区间，该区间的右扩展全部满足条件，然后收缩左端，每收缩一次计算一次以当前左指针为子数组左端能够得到的子数组数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> answer=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//abc 的计数</span><br>        <span class="hljs-type">int</span>[] count=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-comment">//窗口左沿</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//窗口右沿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;end&lt;s.length();end++)&#123;<br>            <span class="hljs-type">char</span> charAtEnd=s.charAt(end);<br>            count[charAtEnd-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            <span class="hljs-keyword">while</span>(count[<span class="hljs-number">0</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">1</span> &amp;&amp; count[<span class="hljs-number">2</span>]&gt;=<span class="hljs-number">1</span>)&#123;<br>                answer+=s.length()-end;<br>                <span class="hljs-type">char</span> charAtStart=s.charAt(start);<br>                count[charAtStart-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>                start++;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> answer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a><br>动态滑动窗口+有序集合</p><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a><br>自己做时总想记录特殊字符的位置，实现快速搜索，实际上直接遍历过去速度更快。另外，数组总是比hash更方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-comment">//t中出现字符记录</span><br>    <span class="hljs-type">int</span>[] time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">boolean</span>[] mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">need</span> <span class="hljs-operator">=</span> t.length();<br><br>    <span class="hljs-comment">//结果记录</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length()+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;need;i++)&#123;<br>        mark[t.charAt(i)] = <span class="hljs-literal">true</span>;<br>        time[t.charAt(i)]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>        time[s.charAt(i)]--;<br>        <span class="hljs-keyword">if</span>(mark[s.charAt(i)]&amp;&amp;time[s.charAt(i)]&gt;=<span class="hljs-number">0</span>)&#123;<br>            need--;<br>        &#125;<br>        <span class="hljs-comment">//若满足条件，收缩左侧到刚好不满足条件，并计算值</span><br>        <span class="hljs-keyword">if</span>(need == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(need == <span class="hljs-number">0</span>)&#123;<br>                time[s.charAt(start)]++;<br>                <span class="hljs-keyword">if</span>(mark[s.charAt(start)]&amp;&amp;time[s.charAt(start)]&gt;<span class="hljs-number">0</span>)&#123;<br>                    need++;<br>                &#125;<br>                start++;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i-start+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(l&lt;length)&#123;<br>                left = start-<span class="hljs-number">1</span>;<br>                right = i+<span class="hljs-number">1</span>;<br>                length = l;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(length == s.length()+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(left,right);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a><br>动态规划：由于每个状态只依赖前一个状态，所以也可以使用变量代替。<br>同时计算最小、最大和的情况即可，主要排除计算最小和时选择了所有数字的情况。</p><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/">845. 数组中的最长山脉</a><br>类似接雨水题，通过左右指针获取各索引元素左右侧元素状态</p><h3 id="子数组与问题转化"><a href="#子数组与问题转化" class="headerlink" title="子数组与问题转化"></a>子数组与问题转化</h3><p>一般我们有如下定义：<br><strong>子数组</strong>：连续的子数组。<br><strong>子序列</strong>：不连续的子数组。</p><p>求满足要求子数组的问题一般分两类解决方案：</p><ul><li>滑动窗口</li><li>问题转化<ul><li><strong>恰好问题转化为最大-最大</strong></li><li><strong>求最长满足条件的子数组长度问题可以不缩小窗口</strong></li><li><strong>元素抵消</strong></li></ul></li><li>动态规划（见动态规划章节）</li></ul><p><em>例题</em><br><a href="https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/">795. 区间子数组个数</a><br>问题转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSubarrayBoundedMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>        <span class="hljs-keyword">return</span> count(A, R) - count(A, L-<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//计算最大值小于bound的子数组个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> bound)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: A) &#123;<br>            cur = x &lt;= bound ? cur + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            ans += cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a><br>问题转化 + 动态滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//把恰好问题转化为最大-最大</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysWithKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//子数组中存在不同整数数量最大为k的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atMostKDistinct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A, <span class="hljs-type">int</span> K)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> A.length;<br>        <span class="hljs-comment">//记录窗口中元素数量</span><br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 里不同整数的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>        <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>        <span class="hljs-comment">//添加right元素</span><br>            <span class="hljs-keyword">if</span> (freq[A[right]] == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>            &#125;<br>            freq[A[right]]++;<br>            right++;<br>            <span class="hljs-comment">//若不再满足条件，收缩左端</span><br>            <span class="hljs-keyword">while</span> (count &gt; K) &#123;<br>                freq[A[left]]--;<br>                <span class="hljs-keyword">if</span> (freq[A[left]] == <span class="hljs-number">0</span>) &#123;<br>                    count--;<br>                &#125;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献，解释一下，相当于[left,right-1]区间满足count == K，此时以right-1为右节点，向左延申到left，有right-left个数（right-1是因为本轮的right加过1了）</span><br>            res += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a><br>以右指针为目标字符，只需要考虑维护这个最大长度，不用缩短区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">characterReplacement</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> len;<br>        &#125;<br>        <span class="hljs-type">char</span>[] array = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//maxCount表示在满足条件的区间内出现过的最多的相同字符数量，即maxCount+k 一般等于 当前窗口大小。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] freq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">while</span>(right&lt;len)&#123;<br>        <span class="hljs-comment">//右端字符数量更新</span><br>            freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            <span class="hljs-comment">//看右端字符数量是否超过了历史最多相同字符数量，</span><br>            maxCount = Math.max(maxCount,freq[array[right]-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>            right++;<br>            <span class="hljs-comment">//如果区间内右端字符数量+可修改的字符数量比区间小，说明这个区间无法满足条件，左端需要移动来满足条件，这里没有使用where。</span><br>            <span class="hljs-keyword">if</span>(maxCount+k&lt;right-left)&#123;<br>                freq[array[left]-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//确认当前区间的大小</span><br>            res = Math.max(right-left,res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/A1NYOS/">剑指 Offer II 011. 0 和 1 个数相同的子数组</a><br>使用状态量表示1和0数量的差别，通过预处理可以找到匹配的字符串，这里使用HashMap记录相同状态出现的最左索引更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        map.put(counter, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;<br>                counter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                counter--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (map.containsKey(counter)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> map.get(counter);<br>                maxLength = Math.max(maxLength, i - prevIndex);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(counter, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLength;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/find-all-good-indices/">2420. 找到所有好下标</a><br>双指针左右遍历，使用两个数组分别记录连续递增&#x2F;减数量。</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><ol><li>使用计数法，并且不收缩滑动窗口。</li><li>由于只允许数字出现一次除了计数外也可以用hash表记录最后一次位置，快速收缩滑动窗口。</li></ol><h2 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h2><p>一般为事件在指定时间&#x2F;坐标必然发生&#x2F;结束，需要计算重合情况。<br><em>例题</em><br><a href="https://leetcode.cn/problems/meeting-rooms-ii/">253. 会议室 II</a></p><ol><li>可以使用<strong>优先队列</strong>，将所有会议的开始，结束按时间发送顺序排列，然后遍历处理。</li><li>由于题目只要求最多同时需要多少间，因此可以只用<strong>最小堆</strong>记录结束时间，然后采用延迟删除策略。</li><li>创建会议开始，结束时间的有序数组，使用双指针。</li></ol><p><a href="https://leetcode.cn/problems/insert-interval/">57. 插入区间</a></p><ul><li>在插入区间的左侧且无交集的区间可以直接添加。</li><li>在插入区间的右侧且无交集的区间也可以直接添加。</li><li>其他情况表示有交集，合并方式是取最左和最右侧。<ul><li>合并可能多次发生，在多次合并后应该确保合并区间被添加。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] insert(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span>[] newInterval) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> newInterval[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//表示是否</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">placed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; ansList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval : intervals) &#123;<br>        <span class="hljs-comment">// 在插入区间的右侧且无交集</span><br>            <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; right) &#123;<br>                <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>                <span class="hljs-keyword">if</span> (!placed) &#123;<br>                    ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>                    placed = <span class="hljs-literal">true</span>;                    <br>                &#125;<br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; left) &#123;<br>                <span class="hljs-comment">// 在插入区间的左侧且无交集</span><br>                ansList.add(interval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 与插入区间有交集，计算它们的并集</span><br>                left = Math.min(left, interval[<span class="hljs-number">0</span>]);<br>                right = Math.max(right, interval[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果合并区间没添加，则添加</span><br>        <span class="hljs-keyword">if</span> (!placed) &#123;<br>            ansList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left, right&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ansList.size()][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ansList.size(); ++i) &#123;<br>            ans[i] = ansList.get(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">LeetCode讲解</a></p><blockquote><p>线段树出现的目的是为了实现区间更新，常用于<strong>区间统计</strong>和<strong>区间更新</strong>问题，可以实现log复杂度的查询和更新。</p></blockquote><p><img src="/Pasted-image-20230421233107.png"></p><h4 id="普通初始化"><a href="#普通初始化" class="headerlink" title="普通初始化"></a>普通初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span>&#123;  <br>    <span class="hljs-type">int</span>[] tree;  <br>    <span class="hljs-type">int</span> n;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SegmentTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.n = arr.length;  <br>        <span class="hljs-built_in">this</span>.tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>*n];  <br>        buildTree(arr,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    &#125;  <br>  <br>    <span class="hljs-comment">//将arr[]中的&#123;l,r,index&#125;节点上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> index)</span>&#123;  <br>        <span class="hljs-keyword">if</span>(start == end)&#123;  <br>            tree[index] = arr[start];  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>;  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;  <br>            buildTree(arr,l,mid,leftNode);  <br>            buildTree(arr,mid+<span class="hljs-number">1</span>,r,rightNode);  <br>            tree[index] = tree[leftNode]+tree[rightNode];  <br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询arr[]的start-&gt;end区间和，&#123;l,r,index为考察对象&#125;  </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> index)</span>&#123;  <br><span class="hljs-keyword">if</span>(start&gt;r || end&lt;l) &#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(start&lt;=l &amp;&amp; r &lt;= end)&#123;<br><span class="hljs-keyword">return</span> tree[index];  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> query(start,end,l,mid,leftNode);  <br><span class="hljs-type">int</span> <span class="hljs-variable">rightSum</span> <span class="hljs-operator">=</span> query(start,end,mid+<span class="hljs-number">1</span>,end,rightNode);  <br><span class="hljs-keyword">return</span> leftSum+rightSum;  <br>&#125;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span>&#123;  <br><span class="hljs-keyword">return</span> query(start,end,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//更新update_index下的值为val，需要递归更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> update_index,<span class="hljs-type">int</span> val,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> index)</span>&#123;  <br><span class="hljs-keyword">if</span>(l == r)&#123;  <br>tree[index] = val;  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br><span class="hljs-type">int</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;  <br><span class="hljs-keyword">if</span>(update_index&lt;=mid)&#123;  <br>update(update_index,val,l,mid,leftNode);  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br>update(update_index,val,mid+<span class="hljs-number">1</span>,r,rightNode);  <br>&#125;  <br>tree[index] = tree[leftNode]+tree[rightNode];  <br>&#125;  <br>&#125;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> update_index,<span class="hljs-type">int</span> val)</span>&#123;  <br>update(update_index,val,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="利用单点更新初始化"><a href="#利用单点更新初始化" class="headerlink" title="利用单点更新初始化"></a>利用单点更新初始化</h4><p>也可以利用更新逐步初始化线段树，但反复的节点修改会导致效率较低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>update(i,arr[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>例题</em><br><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a><br>思路为线段树，但维护整个数组会导致空间占用过高，因此考虑使用Hashmap维护节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalendarThree</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; tree;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; lazy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCalendarThree</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//节点所在区间的最大值</span><br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>        <span class="hljs-comment">//节点所在区间被+1的次数，不会递归更新到子节点</span><br>        lazy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">book</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">//在start~end区间更新，从（0，1000000000，1）节点，即根节点开始更新</span><br>        update(start, end - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000000000</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//获取根节点数值，即区间内最大值</span><br>        <span class="hljs-keyword">return</span> tree.getOrDefault(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> idx)</span> &#123;<br>    <span class="hljs-comment">//无需要更新的区间，直接返回</span><br>        <span class="hljs-keyword">if</span> (r &lt; start || end &lt; l) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//该节点代表的区间被更新区间覆盖</span><br>        <span class="hljs-keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;<br>        <span class="hljs-comment">//更新节点代表区间的最大值，即此时tree[idx]肯定为正确的</span><br>            tree.put(idx, tree.getOrDefault(idx, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//更新该区间被+1的次数，注意，这里没有进行递归的更新子节点，所以tree[idx_left]、tree[idx_right]并没有被更新，但题目求得是整体最大值，所以不关心子节点的实时正确性</span><br>            lazy.put(idx, lazy.getOrDefault(idx, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//只更新该区间的部分片段，分别更新左右两子树。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            update(start, end, l, mid, <span class="hljs-number">2</span> * idx);<br>            update(start, end, mid + <span class="hljs-number">1</span>, r, <span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//子树更新后，得到的tree[idx_left]和tree[id_right]肯定为正确的，此时需要找到区间最大值，lazy[idx]的值之前没有被更新到子节点，所以在求区间最大值时需要＋回来</span><br>            tree.put(idx, lazy.getOrDefault(idx, <span class="hljs-number">0</span>) + Math.max(tree.getOrDefault(<span class="hljs-number">2</span> * idx, <span class="hljs-number">0</span>), tree.getOrDefault(<span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/">LeetCode讲解</a></p><blockquote><p>树状数组是一种很巧妙的数据结构，通过树状数组可以很方便的解决<strong>前缀和</strong>问题和<strong>单点更新</strong>。</p></blockquote><p><img src="/Pasted-image-20230209172457.png"><br>树状数组的本质是一种通过 树状组织 数组区间和 的数据结构 可以在更新数组节点时依次更新树结构，方便前缀和的查询。</p><h4 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h4><p>得到二进制数x的最低位1的值。相当于计算出了该数在二进制下的粒度&#x2F;最小单位。</p><ul><li>节点依次减去其最小二进制单位即得到求和所需的节点</li><li>节点加上其最小二进制单位即可得到其父节点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> x &amp; (-x); &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="前缀和查询"><a href="#前缀和查询" class="headerlink" title="前缀和查询"></a>前缀和查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从右到左查询</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//从节点开始逐一加上前面的节点</span><br>        sum += tree[i];<br>        i -= lowbit(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在要求前6项的和，6的二进制为0110，可分解为0010+0100，对应的是2+4，可以使用C4+C6来表达这个前6项的和。</p><h4 id="单点更新-1"><a href="#单点更新-1" class="headerlink" title="单点更新"></a>单点更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-comment">// 从节点本身开始更新父节点</span><br>    <span class="hljs-keyword">while</span> (i &lt;= len) &#123;<br>    tree[i] += delta;<br>    i += lowbit(i);<br>&#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>树状数组最小索引为1</strong>，所以创建时长度要+1。然后为每个索引初始化数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FenwickTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-built_in">this</span>.len = nums.length + <span class="hljs-number">1</span>;<br>    tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.len + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>        update(i, nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>例题</em><br><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a><br>本题很容易想到从右到左遍历，但如何维护右边所有数字的值的大小和数量是一个问题。</p><ul><li>先使用有序集合，对所有元素进行排序，得到每个元素大小对应的树状数组索引排名并使用Hash记录。(树状数组的索引是连续的，但索引所代表的值大小不需要连续，只需要保持大小关系即可。)</li><li>从右到左遍历，通过元素大小获取在树状数组下的索引后，获取值，并更新。</li></ul><p><a href="https://leetcode.cn/problems/queries-on-a-permutation-with-key/">1409. 查询带键的排列</a></p><ul><li>扩充数组长度并使用树状数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] processQueries(<span class="hljs-type">int</span>[] queries, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> queries.length;<br>        <span class="hljs-type">BIT</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BIT</span>(m + n);<br>        <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            pos[i] = n + i;<br>            bit.update(n + i, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pos[queries[i]];<br>            bit.update(cur, -<span class="hljs-number">1</span>);<br>            ans[i] = bit.query(cur);<br>            cur = n - i;<br>            pos[queries[i]] = cur;<br>            bit.update(cur, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br>  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br>    <span class="hljs-type">int</span>[] a;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BIT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            ret += a[x];<br>            x -= lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> dt)</span> &#123;<br>        <span class="hljs-keyword">while</span> (x &lt;= n) &#123;<br>            a[x] += dt;<br>            x += lowbit(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> x &amp; (-x);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a><br>以<code>num[i]/2</code>查找翻转对，以<code>nums[i]</code>添加结果。</p><h3 id="线段树和树状数组的区别"><a href="#线段树和树状数组的区别" class="headerlink" title="线段树和树状数组的区别"></a>线段树和树状数组的区别</h3><ul><li>线段树不断进行二分来划分子序列，而树状数组利用索引的二进制表示来划分子序列。</li><li>线段树是一棵二叉树，每个结点可以保存一个区间范围以及对应区间和、最大值、最小值、异或值等等。树状数组易于实现且效率高，但是不支持区间修改和区间询问。</li><li>上一条区别的底层原因是，二叉树的叶子节点仍保留了原始数组的性质，树状数组通过二进制提高了效率，但没有维护原始数组，因此无法实现任意区间的询问和修改，只能针对单点，逐步确认其影响的元素。</li><li>使用上，线段树能实现树状数组实现不了的功能，解决各式区间问题，而树状数组则用于高效的解决前缀和问题。此外，两者都以1为初始索引。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/ways-to-make-a-fair-array/">1664. 生成平衡数组的方案数</a><br>预处理奇数和偶数之和数组，然后枚举删除点。</p><p><a href="https://leetcode.cn/problems/count-good-meals/">1711. 大餐计数</a><br>Hash记录数量，简单遍历即可，每道餐品与前面餐品匹配，不会出现重复情况。</p><blockquote><p>int MOD &#x3D; (int)1e9+7;</p></blockquote><p><a href="https://leetcode.cn/problems/number-of-subarrays-having-even-product/">2495. 乘积为偶数的子数组数</a><br>只要子数组中有偶数，乘积就为偶数，计算以偶数作为结尾的数组即可。</p><p><a href="https://leetcode.cn/problems/candy-crush/">723. 粉碎糖果</a><br>当前场面上所有满足条件的糖果时同时消除的，所以不用考虑粉碎糖果后导致其他糖果从可消除变成不可消除状态。因此每次扫描标记所有可粉碎糖果，然后逐列使用双指针实现迭代。</p><p><a href="https://leetcode.cn/problems/find-permutation/">484. 寻找排列</a><br>无限制下<code>1234...n</code>为最优解，若存在一个递减，则搜索连续递减长度后逆转该片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findPermutation(String s) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            ans[i] = i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(j) == <span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(reverse)&#123;<br>                    reverse(ans,i,j);<br>                    reverse = <span class="hljs-literal">false</span>;<br>                    j++;<br>                    i = j;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    i++;<br>                    j++;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                reverse = <span class="hljs-literal">true</span>;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(reverse)&#123;<br>            reverse(ans,i,j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ans,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> ans[l];<br>            ans[l] = ans[r];<br>            ans[r] = temp;<br>            l++;<br>            r--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>总结：</p><ol><li>看排序能不能改善计算！</li><li>看问题能不能转化<ul><li>如最多与最少的转化</li><li>两侧与中间区间的转化</li><li><strong>恰好</strong>与<strong>最大-最大</strong>的转化</li><li>是否能使用预处理数组</li></ul></li><li>对于滑动窗口<ul><li>是否一定要缩小窗口</li><li>统计满足条件的子数组时，以左&#x2F;右端点作为开始&#x2F;结束点。</li></ul></li></ol>          </div><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><p>字符串的很多题目与数组的处理方式类似，因为字符串本身就是一个字符数组。</p><div class="note note-success">            <p>本篇主要为利用双指针移动判定条件解决问题。<br>对于子序列、回文等问题见动态规划篇。</p>          </div><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p><em>例题</em><br><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a><br>将具有相同元素的单词分类，对各个字符串分别使用字符数组排序，将排序后的单词作为key做对比。</p><h2 id="语义解释"><a href="#语义解释" class="headerlink" title="语义解释"></a>语义解释</h2><p>一般使用双指针，对于计算类需要灵活应用栈，滑动窗口等方法解决。<br><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a><br>类似于操作数栈，但带有正负号，且记录上一次的符号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将遇到的数压栈，碰到乘除时出栈计算再压栈，记录每个数前面的符号。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-comment">//第一个数前符号为正</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">preSign</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">//若是数字，则当前数变化</span><br>            <span class="hljs-keyword">if</span> (Character.isDigit(s.charAt(i))) &#123;<br>                num = num * <span class="hljs-number">10</span> + s.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-comment">//若是符号，说明当前数字可以入栈了</span><br>            <span class="hljs-keyword">if</span> (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//根据符号选择入栈的真实值</span><br>                <span class="hljs-keyword">switch</span> (preSign) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                        stack.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                        stack.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        stack.push(stack.pop() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        stack.push(stack.pop() / num);<br>                &#125;<br>                preSign = s.charAt(i);<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            ans += stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a><br>可以正向使用栈遍历，然后对比栈；<br>也可以逆向遍历，双指针一次完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> S.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> T.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">skipS</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//从右往左移动到第一个有效字符，注意，若没有有效字符了，会变成负数，从而终止。</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipS++;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipS--;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (T.charAt(j) == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipT++;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipT--;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//两者都有有效字符，则比较</span><br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            <span class="hljs-comment">//至少有一个已经没有字符了，如果另外一个还有字符，则返回false，当然如果都小于0，可以返回true，但不用写这个逻辑了。</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="比较问题"><a href="#比较问题" class="headerlink" title="比较问题"></a>比较问题</h3><p>一般是双指针，但可以注意循环策略。<br><a href="https://leetcode.cn/problems/long-pressed-name/">925. 长按键入</a><br>判断对比结束是比较难的，这里以i指针作为考察，如果遍历完成后，i指针指向了字符串末尾就算对比成功。<br>此外，return false包含了很多失败情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLongPressedName</span><span class="hljs-params">(String name, String typed)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; typed.length()) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; name.length() &amp;&amp; name.charAt(i) == typed.charAt(j)) &#123;<br>                i++;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; typed.charAt(j) == typed.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i == name.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>到这种双指针对比的问题，很容易遇到很多边界条件，如一个结束了另外一个没结束要接着判断边界等情况：<br>1）<code>while(index1&lt;n1 &amp;&amp; index2&lt;n2)</code>，常规思路，还需要额外判断两者是否到达结束点。<br>2）在一个指针的循环体内判断另一个指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1)&#123;<br><span class="hljs-keyword">if</span>(index2&lt;n2)&#123;<br><span class="hljs-comment">//代码</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）通过if处理都在界内的情况，然后处理有指针不在界内的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(index1&lt;n1 || index2&lt;n2)&#123;<br><span class="hljs-keyword">if</span>(index1&lt;n1 &amp;&amp; index2&lt;n2)&#123;<br><span class="hljs-comment">//代码，</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>          </div><h3 id="轮转问题"><a href="#轮转问题" class="headerlink" title="轮转问题"></a>轮转问题</h3><p><a href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findSubstringInWraproundString</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (p.charAt(i) - p.charAt(i - <span class="hljs-number">1</span>) + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 字符之差为 1 或 -25</span><br>                ++k;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k = <span class="hljs-number">1</span>;<br>            &#125;<br>            dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = Math.max(dp[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>], k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).sum();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了去重，求以每个字符为结尾的数组长度最大为多少，最后求和。</p><blockquote><p>z-a相连问题，即两字符之间的差为1或-25，可以将其转化为以下式子：<br>（p.charAt(i) - p.charAt(i - 1) + 26) % 26 &#x3D;&#x3D; 1<br>因为25与-1相差26，将符号修正后对26求余时结果肯定一样。</p></blockquote><p><a href="https://leetcode.cn/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></p><blockquote><p>轮转问题一般可以考虑扩充原<strong>数组&#x2F;字符</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFlipedString</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-keyword">if</span>(s2.length() != n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1+s1;<br>        <span class="hljs-keyword">return</span> s3.contains(s2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串替换-x2F-编码"><a href="#字符串替换-x2F-编码" class="headerlink" title="字符串替换&#x2F;编码"></a>字符串替换&#x2F;编码</h2><p>一般题目为允许&#x2F;必须替换字符串中的某些字符，以达到某种条件。<br>滑动窗口类题型可见上文，下面为<strong>规律题</strong>：<br><a href="https://leetcode.cn/problems/1-bit-and-2-bit-characters/">717. 1 比特与 2 比特字符</a></p><ol><li>正向推理：遇到0走一格，遇到1走两格，判断最后一次走的是几格。</li><li>反向推理：<ul><li>如果结尾前为0，则必然为true</li><li>如果结尾前是1，则必然为11<ul><li>这个11的前面只能接着放11或0结尾的字符，所以判断结尾0到倒数第二个0中间1的个数是否为偶数。</li></ul></li></ul></li></ol><p><a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/">777. 在LR字符串中交换相邻字符</a><br>由题可知：<br>L可以与右侧的X交换，R可以与左侧的X交换，但L不可以跨越R。<br>即L可以右移，R可以左移，L和R的顺序不能改变。<br>那么可以忽略X，如果找到对应的L，原始L应该在变化后的L的左侧，原始R应该在变化后的R的右侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canTransform</span><span class="hljs-params">(String start, String end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> start.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; start.charAt(i) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; end.charAt(j) == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; j &lt; n) &#123;<br>                <span class="hljs-keyword">if</span> (start.charAt(i) != end.charAt(j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> start.charAt(i);<br>                <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;L&#x27;</span> &amp;&amp; i &lt; j) || (c == <span class="hljs-string">&#x27;R&#x27;</span> &amp;&amp; i &gt; j)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                i++;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (start.charAt(i) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (end.charAt(j) != <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p><a href="https://leetcode.cn/problems/ternary-expression-parser/">439. 三元表达式解析器</a><br>分析：所有<code>?</code>前的一定是’T’或’F’。</p><ul><li>顺序处理，递归、剪枝</li><li>倒序处理，堆栈<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 递归，每次找到当前层次表达式的?和:，然后递归处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">parseTernary</span><span class="hljs-params">(String expression)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> expression.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">checkLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (expression.charAt(j) == <span class="hljs-string">&#x27;?&#x27;</span>) checkLevel++;<br>            <span class="hljs-keyword">if</span> (expression.charAt(j) == <span class="hljs-string">&#x27;:&#x27;</span>) checkLevel--;<br>            <span class="hljs-keyword">if</span> (checkLevel == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (expression.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;T&#x27;</span>) ? parseTernary(expression.substring(<span class="hljs-number">2</span>, j)) : parseTernary(expression.substring(j+<span class="hljs-number">1</span>, n));<br>        &#125;<br>        <span class="hljs-keyword">return</span> expression;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 栈式处理，倒序处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">parseTernary</span><span class="hljs-params">(String expression)</span> &#123;<br>        Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;Character&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> expression.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> expression.charAt(index);<br>            index--;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> expression.charAt(index);<br>                index--;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">if</span> (condition == <span class="hljs-string">&#x27;T&#x27;</span>) &#123;<br>                    stack.push(c1);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stack.push(c2);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.push(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(stack.pop());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://leetcode.cn/problems/basic-calculator-iii/">772. 基本计算器 III</a></p><ul><li>符号优先级：记录符号，乘除当场处理，后续再使用栈处理加减。</li><li>括号问题：记录同层次括号的始末，迭代计算。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(String s)</span> &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-comment">//遇到所有非符号的字符应该视为一个对现有数字的处理</span><br>            <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                num = num*<span class="hljs-number">10</span>+temp-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-comment">//处理括号,记录括号层数</span><br>                <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>                i++;<br>                StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-comment">//不同层次 或 非括号 时继续</span><br>                <span class="hljs-keyword">while</span>(count != <span class="hljs-number">1</span> || s.charAt(i) != <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<span class="hljs-comment">// 处理多重括号</span><br>                    sb.append(s.charAt(i));<br>                    <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;(&#x27;</span>) count++;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;)&#x27;</span>) count--;<br>                    i++;<br>                &#125;<br>                num=calculate(sb.toString());<span class="hljs-comment">//括号中的表达式的值</span><br>            &#125;<br>            <span class="hljs-comment">//遇到符号的字符应该处理该数字，并记录当前符号下次使用</span><br>            <span class="hljs-keyword">if</span>(temp &lt;<span class="hljs-string">&#x27;0&#x27;</span> || i==s.length()-<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">switch</span>(op)&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:&#123;<br>                        deque.push(num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:&#123;<br>                        deque.push(-num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:&#123;<br>                        deque.push(deque.poll() * num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:&#123;<br>                        deque.push(deque.poll() / num);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                op = temp;<br>                num = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty())&#123;<br>            res+=deque.pop();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><p><a href="https://leetcode.cn/problems/add-bold-tag-in-string/">616. 给字符串添加加粗标签</a><br>合并区间问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addBoldTag</span><span class="hljs-params">(String S, String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> S.length();<br>        <span class="hljs-type">boolean</span>[] mask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i)&#123;<br>            loop:<br>            <span class="hljs-keyword">for</span> (String word:words)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; word.length(); ++k)&#123;<br>                    <span class="hljs-keyword">if</span> (k+i &gt;= S.length() || S.charAt(k+i) != word.charAt(k)) <span class="hljs-keyword">continue</span> loop;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; i+word.length(); ++j) mask[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">anchor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (mask[i] &amp;&amp; (i == <span class="hljs-number">0</span> || !mask[i-<span class="hljs-number">1</span>]))<br>                ans.append(<span class="hljs-string">&quot;&lt;b&gt;&quot;</span>);<br>            ans.append(S.charAt(i));<br>            <span class="hljs-keyword">if</span> (mask[i] &amp;&amp; (i == N-<span class="hljs-number">1</span> || !mask[i+<span class="hljs-number">1</span>]))<br>                ans.append(<span class="hljs-string">&quot;&lt;/b&gt;&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法整理</category>
      
      <category>算法专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数组</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-IP</title>
    <link href="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/"/>
    <url>/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、IP概念"><a href="#一、IP概念" class="headerlink" title="一、IP概念"></a>一、IP概念</h1><p>网络层的主要作用是：<strong>实现主机与主机之间的通信，也叫点对点（end to end）通信。</strong><br><strong>MAC 的作用是实现「直连」的两个设备之间通信，而 IP 负责在「没有直连」的两个网络之间进行通信传输。</strong><br>在网络中数据包传输中：<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><h1 id="二、IP基础概念"><a href="#二、IP基础概念" class="headerlink" title="二、IP基础概念"></a>二、IP基础概念</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/4.webp"><br>IP最大值为：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5.webp"></p><h2 id="分类地址"><a href="#分类地址" class="headerlink" title="分类地址"></a>分类地址</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7.webp"><br><strong>主机号全为 1 表示广播 和 全为 0 表示网络。</strong></p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><div class="note note-primary">            <p>广播地址用于在<strong>同一个链路中相互连接的主机之间发送数据包</strong>。</p>          </div><blockquote><ul><li><strong>在本网络内广播的叫做本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0&#x2F;24 以外的其他链路上。</li><li><strong>在不同网络之间的广播叫做直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0&#x2F;24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（<strong>由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。</strong>）。</li></ul></blockquote><h4 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h4><p>而D类和E类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于<strong>多播</strong>，E 类是预留的分类，暂时未使用。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/12.webp"></p><blockquote><p>多播用于<strong>将包发送给特定组内的所有主机。</strong></p></blockquote><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13.webp"></p><p><strong>多播中，后面的28位是多播的组编号。</strong></p><p><em>缺点一</em><br><strong>同一网络下没有地址层次</strong></p><p><em>缺点二</em><br><strong>不能很好的与现实网络匹配</strong>。</p><h2 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h2><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是<strong>网络号</strong>，后面是<strong>主机号</strong>。</p><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18.webp"></p><h2 id="公有IP地址与私有IP地址"><a href="#公有IP地址与私有IP地址" class="headerlink" title="公有IP地址与私有IP地址"></a>公有IP地址与私有IP地址</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/22.webp"></p><blockquote><p>公有 IP 地址由谁管理呢？<br>公有 IP 地址是由 <code>ICANN</code> 组织管理，中文叫「互联网名称与数字地址分配机构」。</p></blockquote><h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><p>IP地址的<strong>网络地址</strong>这一部分是用于进行路由控制。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/25.webp"></p><blockquote><p><strong>127.0.0.1 作为环回地址</strong>，这是不会流向网络。</p></blockquote><h2 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h2><p>每种数据链路的最大传输单元 <code>MTU</code> 都是不相同的，如FDDI数据链路 MTU 4352、以太网的MTU是1500字节等。<br>那么当IP数据包大小大于MTU时，IP数据包就会被分片。</p><p>在分片传输中，一旦某个分片丢失，则会造成整个IP数据报作废，所以 TCP 引入了<code>MSS</code>也就是在TCP层进行分片不由IP层分片，那么对于UDP我们尽量不要发送一个大于<code>MTU</code>的数据报文。</p><h2 id="IPv6-基本认识"><a href="#IPv6-基本认识" class="headerlink" title="IPv6 基本认识"></a>IPv6 基本认识</h2><p>IPv6 的地址是 <code>128</code> 位的，每 16 位作为一组，每组用冒号 「:」 隔开。</p><blockquote><p>IPv4 和 IPv6 不能相互兼容</p></blockquote><p>IPv6 的地址主要有以下类型地址：</p><ul><li>单播地址，用于一对一的通信</li><li>组播地址，用于一对多的通信</li><li>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</li><li>没有广播地址</li></ul><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/29.webp"><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/30.webp"></p><ul><li>在同一链路单播通信，不经过路由器，可以使用<strong>链路本地单播地址</strong>，IPv4没有此类型。</li><li>在内网里单播通信，可以使用<strong>唯一本地地址</strong>，相当于IPv4的私有 IP</li><li>在互联网通信，可以使用<strong>全局单播地址</strong>，相当于IPv4的公有IP</li></ul><h3 id="IPv6首部"><a href="#IPv6首部" class="headerlink" title="IPv6首部"></a>IPv6首部</h3><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/31.webp"></p><ul><li><strong>取消了首部校验和字段。</strong>（数据链路和传输层都校验，这里就省略了）</li><li><strong>取消了分片&#x2F;重新组装相关字段。</strong>（路由器不再可以分片，只允许源与目标主机分片重组）</li><li><strong>取消选项字段。</strong>（变成了下一个首部）。</li></ul><h1 id="三、IP协议相关技术"><a href="#三、IP协议相关技术" class="headerlink" title="三、IP协议相关技术"></a>三、IP协议相关技术</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>那么实现这一技术的就是 <strong>DNS 域名解析</strong>，DNS 可以将域名网址自动转换为具体的 IP 地址。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/33.webp"><br>DNS的域名解析方式是迭代而不是递归（<strong>只指路不带路</strong>）。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>已知 IP 求 MAC 地址。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/34.webp">两ARP是借助<strong>ARP请求与ARP响应</strong>种类型的包确定 MAC 地址的。</p><ul><li>主机会通过<strong>广播发送ARP请求</strong>，这个包中包含了想要知道的 MAC 地址的主机IP地址。</li><li>当同个链路中的所有设备收到ARP请求时，会去拆开ARP请求包里的内容，如果ARP请求包中的目标IP地址与自己的IP地址一致，那么这个设备就将自己的 MAC 地址塞入<strong>ARP响应包</strong>返回给主机。</li></ul><h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>与 ARP 协议正好相反，它是<strong>已知 MAC 地址求 IP 地址</strong>。</p><p>通常这需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p><ul><li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li><li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li><li>然后设备根据该回复设置自己的IP地址。</li></ul><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/36.webp"></p><ul><li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong>，<strong>UDP广播</strong>。</li><li>服务器<strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应，<strong>UDP广播</strong>。</li><li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数，<strong>UDP广播</strong>。</li><li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数，<strong>UDP广播</strong>。</li></ul><p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p><ul><li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li><li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li></ul><div class="note note-primary">            <ol><li>DHCP交互都是UDP报文</li><li>首次交互根据事务ID维持沟通独立性</li><li>各DHCP发送自己准备分配的相关信息（提供的地址等），客户端选择后，服务端再确认。</li></ol>          </div><p>如何实现大网段的IP地址分发：</p><blockquote><p><strong>DHCP 中继代理</strong>。有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</strong></p></blockquote><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/37.webp"></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p><strong>网络地址转换 NAT</strong>，对外部通信时，把私有 IP 地址转换成公有 IP 地址，缓解了IP地址不够的问题。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/38.webp"><br>而把 IP 地址 + 端口号一起进行转换的技术叫<strong>网络地址与端口转换 NAPT。</strong><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/39.webp"><br><strong>两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</strong></p><p>这种转换表在 NAT 路由器上自动生成。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li><li>转换表的生成与转换操作都会产生性能开销。</li><li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>IPv6</li><li>NAT穿透技术：网络应用程序主动发现自己位于NAT设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目。</li></ul><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。<br><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/40.webp"></p><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul><h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><blockquote><p>IGMP与ICMP毫无关系</p></blockquote><p>既然是组播，那就说明是只有一组的主机能收到数据包，不在一组的主机不能收到数组包，怎么管理是否是在一组呢？那么，就需要 <code>IGMP</code> 协议了。</p><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/42.webp"><br><strong>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间</strong>，如上图中的蓝色部分。</p><ul><li>主机可以使用IGMP报文向路由器申请加入和退出组播组。</li><li>IGMP 报文采用 IP 封装，IP 头部的协议号为 2，而且 TTL 字段值通常为 1，因为 IGMP 是工作在主机与连接的路由器之间。</li></ul><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><em>常规查询与响应和离开组播组</em><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/43.webp"></p><ol><li>路由器会周期性发送目的地址为 <code>224.0.0.1</code>（表示同一网段内所有主机和路由器） <strong>IGMP 常规查询报文</strong>。</li><li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 <strong>IGMP 成员关系报告报文</strong>（源 IP 地址为自己主机的 IP 地址，目的 IP 地址为组播地址）<ul><li>如果在定时器超时之前，收到同一个组内的其他主机发送的成员关系报告报文，则自己不再发送，这样可以减少网络中多余的 IGMP 报文数量。</li></ul></li><li>路由器收到主机的成员关系报文后，就会在 IGMP 路由表中加入该组播组，后续网络中一旦该组播地址的数据到达路由器，它会把数据包转发出去。</li></ol><div class="note note-primary">            <p>简而言之，主机向路由器发送成员关系报告报文后，表示该路由器的直连主机中有某个组播的成员，此后路由器就会转发这个组播。</p>          </div><p><em>离开组播组工作机制</em><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/44.webp"></p><ol><li>主机1要离开组播组，发送给网段内所有路由器</li><li>路由器询问是否还有该组播成员</li><li>若有，则之后会继续转发该组播消息；否则，不再转发。</li></ol><h1 id="四、PING的原理"><a href="#四、PING的原理" class="headerlink" title="四、PING的原理"></a>四、PING的原理</h1><p>ping 是基于 <code>ICMP</code> 协议工作的。<br>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/5-1.webp"></p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/6.webp"></li></ul><h2 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h2><p>回送消息 —— 类型 <code>0</code>（回送响应）和 <code>8</code>（回送请求）<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/7-1.webp"><br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/8.webp"><br>相比原生的 ICMP，这里多了两个字段：</p><ul><li><strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li><strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><h2 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h2><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>目标不可达消息 —— 类型 为 <code>3</code></li><li>原点抑制消息 —— 类型 <code>4</code></li><li>重定向消息 —— 类型 <code>5</code></li><li>超时消息 —— 类型 <code>11</code></li></ul><h3 id="不可达分类"><a href="#不可达分类" class="headerlink" title="不可达分类"></a>不可达分类</h3><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/9.webp"><br><em>网络不可达</em><br>路由表匹配不到</p><p><em>主机不可达</em><br>找得到网络，但找不到主机</p><p><em>协议不可达</em><br>对端主机的防火墙已经禁止TCP协议访问等情况</p><p><em>端口不可达</em><br>通过防火墙，但没有进程监听目标端口</p><p><em>需要进行分片但设置了不分片</em><br>组件路由器由于不分片政策直接丢弃IP分组</p><h4 id="原点抑制"><a href="#原点抑制" class="headerlink" title="原点抑制"></a>原点抑制</h4><p>原点抑制消息（ICMP Source Quench Message）—— 类型 <code>4</code><br>通知主机线路拥堵，需要增大IP包传输间隔</p><blockquote><p>由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p></blockquote><h4 id="重定向消息"><a href="#重定向消息" class="headerlink" title="重定向消息"></a>重定向消息</h4><p>重定向消息（ICMP Redirect Message） —— 类型 <code>5</code><br>路由器发现不是最优路径，则返回重定向消息给主机。</p><h4 id="超时消息"><a href="#超时消息" class="headerlink" title="超时消息"></a>超时消息</h4><p>超时消息（ICMP Time Exceeded Message） —— 类型 <code>11</code><br>IP 包中有一个字段叫做 <code>TTL</code> （<code>Time To Live</code>，生存周期），它的<strong>值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</strong></p><h2 id="Ping-请求报文的应用"><a href="#Ping-请求报文的应用" class="headerlink" title="Ping-请求报文的应用"></a>Ping-请求报文的应用</h2><p>每发出一个请求数据包，序号会自动加 <code>1</code>。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/13-1.webp"></p><p>整体流程：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/17.webp"></p><h2 id="traceroute—差错报文类型的使用"><a href="#traceroute—差错报文类型的使用" class="headerlink" title="traceroute—差错报文类型的使用"></a>traceroute—差错报文类型的使用</h2><p><em>1. traceroute 作用一</em><br>traceroute 的第一个作用就是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</strong><br>将TTL从1开始递增，强制接受ICMP超时消息。</p><p><em>2. traceroute 作用二</em><br>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/18-1.webp"></p><h1 id="五、ping-127-0-0-1"><a href="#五、ping-127-0-0-1" class="headerlink" title="五、ping 127.0.0.1"></a>五、ping 127.0.0.1</h1><h2 id="ping流程"><a href="#ping流程" class="headerlink" title="ping流程"></a>ping流程</h2><p>ping与TCP的区别（_右边的ping数据应该为TCP数据_）：<br><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/Pasted-image-20230208113935.png"></p><ul><li>ping是应用层协议</li><li>创建socket时的使用的参数不同</li><li>其他与普通TCP发送消息相同，所以可以通过ping测试能否到达访问</li></ul><h2 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h2><p><img src="/2023/02/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-IP/Pasted-image-20230208114527.png"><br>回环地址，<strong>软中断</strong>会直接返回，不走网卡。</p><h2 id="ping回环地址与ping本机IP"><a href="#ping回环地址与ping本机IP" class="headerlink" title="ping回环地址与ping本机IP"></a>ping回环地址与ping本机IP</h2><p><strong>没有区别！</strong><br>即使填写真IP，也会通过本地回环，不走网卡。</p><h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2><ul><li><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</li><li><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</li><li>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP</title>
    <link href="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/"/>
    <url>/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP基本认识"><a href="#一、TCP基本认识" class="headerlink" title="一、TCP基本认识"></a>一、TCP基本认识</h1><p>TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h2 id="头格式"><a href="#头格式" class="headerlink" title="头格式"></a>头格式</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207114528.png"><br>不常见的：<br>URG：紧急标志位，优先处理紧急数据。<br>PSH：催促标志位，发送方立即发送，接受方立即接受。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文。</li></ul><h2 id="什么是TCP连接"><a href="#什么是TCP连接" class="headerlink" title="什么是TCP连接"></a>什么是TCP连接</h2><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115025.png"><br>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><h3 id="唯一确定一个-TCP-连接呢？"><a href="#唯一确定一个-TCP-连接呢？" class="headerlink" title="唯一确定一个 TCP 连接呢？"></a>唯一确定一个 TCP 连接呢？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115107.png"></p><ul><li><strong>文件描述符限制</strong>，每个TCP连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<ul><li><strong>系统级</strong>：当前系统可打开的最大数量，通过 <code>cat /proc/sys/fs/file-max</code> 查看；</li><li><strong>用户级</strong>：指定用户可打开的最大数量，通过 <code>cat /etc/security/limits.conf</code> 查看；</li><li><strong>进程级</strong>：单个进程可打开的最大数量，通过 <code>cat /proc/sys/fs/nr_open</code> 查看；</li></ul></li><li><strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li></ul><h3 id="IP层会分片，为什么TCP层还需要MSS？"><a href="#IP层会分片，为什么TCP层还需要MSS？" class="headerlink" title="IP层会分片，为什么TCP层还需要MSS？"></a>IP层会分片，为什么TCP层还需要MSS？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207131104.png"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>如果把TCP报文整个交给IP分层，则一个IP分片丢失就会造成整个IP报文重传，因为IP报文没有分片重传机制，效率很低。</p><p>为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值。</strong></p><div class="note note-primary">            <p>TCP分片后保证其数据包大小MSS+TCP头部+IP头部&lt;MTU，因此不需要IP分片，这样重发时也是以MSS为单位，效率更高。</p>          </div><div class="note note-success">            <p>注意：MSS不包括TCP头部，但MTU包括IP头部，不包括MAC头部。</p>          </div><h3 id="如何理解TCP基于字节流"><a href="#如何理解TCP基于字节流" class="headerlink" title="如何理解TCP基于字节流"></a>如何理解TCP基于字节流</h3><p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。</p><p>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。</p><h4 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h4><p>一般交给应用层解决。</p><ul><li>固定长度的消息；</li><li>特殊字符作为边界，如HTTP；</li><li>自定义消息结构；</li></ul><h2 id="UDP-和-TCP-有什么区别呢"><a href="#UDP-和-TCP-有什么区别呢" class="headerlink" title="UDP 和 TCP 有什么区别呢"></a>UDP 和 TCP 有什么区别呢</h2><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115326.png"><br><strong>TCP 和 UDP 区别：</strong><br><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 <strong>MSS</strong> 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 <strong>MTU</strong> 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong><br>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP &#x2F; HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><p><strong>为什么UDP头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207115616.png"><br>UDP的头部理论上也可这样省略，保留的原因可能有：</p><ul><li>保持4的整数倍。</li><li>当年UDP协议可能不是基于IP发展的。</li></ul><p><strong>TCP和UDP可以使用同一个端口吗？</strong><br>可以，两者是不同的模块。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.webp"></p><h1 id="二、TCP连接建立"><a href="#二、TCP连接建立" class="headerlink" title="二、TCP连接建立"></a>二、TCP连接建立</h1><h2 id="TCP-三次握手过程"><a href="#TCP-三次握手过程" class="headerlink" title="TCP 三次握手过程"></a>TCP 三次握手过程</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp"></p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120323.png"></p><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120334.png"></p><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120342.png"><br><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</strong></p><blockquote><p>第三次握手如果丢了可以建立连接吗？<br>可以，因为之后的普通数据报文也有ACK标志符和ack号。</p></blockquote><blockquote><p>Linux查看TCP连接状态：<code>netstat -napt</code>查看</p></blockquote><h2 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h2><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p><em>原因一：避免历史连接</em><br><strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207120725.png"></p><blockquote><p>如果新SYN在RST前到达，则回 <a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。</p><ul><li>客户端第一次握手后收到不正确的ACK会发送RST</li><li>服务端收到新的SYN报文时会要求对方传输正确的SYN，即回复上一次ACK报文。</li></ul></blockquote><p><em>原因二：同步双方初始序列号</em><br><strong>要确保双方的初始序列号能被可靠的同步。</strong> 在两次握手的情况下，只能保证客户端的SYN被接受。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207121527.png"><br>TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以<strong>去除重复</strong>的数据；</li><li>接收方可以根据数据包的序列号<strong>按序</strong>接收；</li><li>可以<strong>标识</strong>发送出去的数据包中，哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p><em>原因三：避免资源浪费</em><br>在两次握手的情况下，服务器无法判断客户端是否接受到了第二次握手，所以服务端每接受到一个SYN都要建立连接，如果SYN阻塞，则会产生很多冗余链接，造成不必要的资源浪费。</p><p><em>小结</em><br>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。<br>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><div class="note note-primary">            <p>原因一、三有点类似，但角度不同，一个是历史连接建立造成的连接混乱，一个是历史连接建立造成的资源消耗。</p>          </div><h2 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h2><h3 id="初始化序列号为何不同？"><a href="#初始化序列号为何不同？" class="headerlink" title="初始化序列号为何不同？"></a>初始化序列号为何不同？</h3><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li><li>为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收；</li></ul><p>如果每次都是相同的初始化序列号，历史的滞留信息可能被下一次相同四元组的连接接受：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/isn%E7%9B%B8%E5%90%8C.webp"></p><h3 id="如何随机初始化序列号？"><a href="#如何随机初始化序列号？" class="headerlink" title="如何随机初始化序列号？"></a>如何随机初始化序列号？</h3><p>起始<code>ISN</code>是基于时钟的，每4微秒+1，转一圈要4.55个小时。<br>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><div class="note note-primary">            <p>可见不同四元组的ISN几乎不可能相同，同一个四元组中可能产生计时器回绕，因此有时需要时间戳判断历史报文。</p>          </div><h2 id="握手丢失"><a href="#握手丢失" class="headerlink" title="握手丢失"></a>握手丢失</h2><h3 id="第一次握手丢失"><a href="#第一次握手丢失" class="headerlink" title="第一次握手丢失"></a>第一次握手丢失</h3><p>客户端以相同的syn序列号重传。</p><h4 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>第一次超时重传是在<strong>1秒</strong>后。</li><li>默认总共超时<strong>重传5次</strong>（<code>tcp_syn_retries</code>设置）。</li><li><strong>每次超时的时间是上一次的2倍</strong>。</li><li>第五次重传后等待32秒然后断开连接。</li><li>总共耗时63秒，大约1分钟。</li></ul><h3 id="第二次握手丢失"><a href="#第二次握手丢失" class="headerlink" title="第二次握手丢失"></a>第二次握手丢失</h3><ul><li>客户端以相同的序列号<strong>重传</strong>，类似第一次握手丢失。</li><li>服务器也以相同的序列号<strong>重传</strong>SYN-ACK报文。</li></ul><h4 id="超时机制-1"><a href="#超时机制-1" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>默认总共超时<strong>重传5次</strong>（<code>tcp_synack_retries</code>设置）。</li></ul><h3 id="第三次握手丢失"><a href="#第三次握手丢失" class="headerlink" title="第三次握手丢失"></a>第三次握手丢失</h3><p><strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。即服务器超时重传。</p><h3 id="客户端二次握手后超时重传"><a href="#客户端二次握手后超时重传" class="headerlink" title="客户端二次握手后超时重传"></a>客户端二次握手后超时重传</h3><p>TCP 建立连接后的<strong>数据包传输</strong>，最大超时重传次数是由 <code>tcp_retries2</code> 指定，默认值是 15 次。</p><h2 id="TCP快速连接"><a href="#TCP快速连接" class="headerlink" title="TCP快速连接"></a>TCP快速连接</h2><p>Linux 3.7内核版本中，提供了<strong>TCP Fast Open</strong>功能。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/45.webp"></p><ul><li>第一次连接：第二次握手时服务器给客户端传<code>Cookie</code>（加密）</li><li>第二次连接：第一次握手时客户端直接发送<code>Cookie</code>，省去了一次握手。</li></ul><p>net.ipv4.tcp_fastopen 各个值的意义:</p><ul><li>0 关闭</li><li>1 作为客户端使用 Fast Open 功能</li><li>2 作为服务端使用 Fast Open 功能</li><li>3 无论作为客户端还是服务器，都可以使用 Fast Open 功能</li></ul><h1 id="三、TCP连接断开"><a href="#三、TCP连接断开" class="headerlink" title="三、TCP连接断开"></a>三、TCP连接断开</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207141651.png"><br><strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h2 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h2><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p><strong>在特定情况下，四次挥手是可以变成三次挥手的。</strong></p><h2 id="粗暴关闭-vs-优雅关闭"><a href="#粗暴关闭-vs-优雅关闭" class="headerlink" title="粗暴关闭 vs 优雅关闭"></a>粗暴关闭 vs 优雅关闭</h2><p>关闭的连接的函数有两种函数：</p><ul><li><code>close</code> 函数，同时 socket 关闭发送方向和读取方向。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让socket 引用计数 -1，并不会导致 socket 不可用，同时也<strong>不会发出 FIN 报文</strong>，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li><li><code>shutdown</code> 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。（如果有多进程&#x2F;多线程共享同一个 socket，<strong>shutdown则不管引用计数，直接使得该socket不可用，然后发出 FIN 报文</strong>，如果有别的进程企图使用该 socket，将会受到影响。）</li></ul><div class="note note-primary">            <p>CLOSE只关闭SOCKET对本身的引用，不发FIN；<br>SHUTDOWN关闭写方向时，直接关闭SOCKET，发FIN；</p>          </div><ul><li>如果客户端调用<code>close</code>使Socket引用计数为0时，关闭连接，客户端发送FIN后若再接收到服务器的数据消息，会发送RST给服务端，从而不会经历四次握手。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230208001214.png"></li><li>如果客户端调用shutdown关闭写方向，正常4次挥手，关闭读方向的话，不会发送FIN，因为FIN的语义是我方不再发送信息。</li></ul><h2 id="TCP四次握手变三次"><a href="#TCP四次握手变三次" class="headerlink" title="TCP四次握手变三次"></a>TCP四次握手变三次</h2><p>服务端 <strong>「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><h4 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul><li>当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方。</li><li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ul><p>延迟等待的时间是在Linux内核中定义。</p><h2 id="挥手丢失"><a href="#挥手丢失" class="headerlink" title="挥手丢失"></a>挥手丢失</h2><h3 id="第一次挥手丢失"><a href="#第一次挥手丢失" class="headerlink" title="第一次挥手丢失"></a>第一次挥手丢失</h3><p>当客户端向服务端重传 FIN 报文。</p><h4 id="超时机制-2"><a href="#超时机制-2" class="headerlink" title="超时机制"></a>超时机制</h4><ul><li>默认总共超时<strong>重传8次</strong>（<code>tcp_orphan_retries</code>设置）。</li><li><strong>每次超时的时间是上一次的2倍</strong>。</li><li>超时仍未收到则close。</li></ul><h3 id="第二次挥手丢失"><a href="#第二次挥手丢失" class="headerlink" title="第二次挥手丢失"></a>第二次挥手丢失</h3><ul><li>客户端重传FIN报文，类似第一次挥手丢失。</li><li>服务端不会主动重传ACK，接收到重传的FIN会再次进行二次挥手。</li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.webp"></p><h3 id="第三次挥手丢失"><a href="#第三次挥手丢失" class="headerlink" title="第三次挥手丢失"></a>第三次挥手丢失</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.webp"></p><ul><li>服务端重传，机制类似第一次握手（<code>tcp_orphan_retries</code>）</li><li>客户端超过<code>tcp_fin_timeout</code>（默认60s）后关闭</li></ul><h3 id="第四次挥手丢失"><a href="#第四次挥手丢失" class="headerlink" title="第四次挥手丢失"></a>第四次挥手丢失</h3><ul><li>服务端重传第三次握手，机制类似第一次握手</li><li>客户端进入time_wait状态（2MSL），并会不断回复第四次握手。</li></ul><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>。<br>目的是保证这次连接中所有报文已经死亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p>如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p><strong>为什么是2倍MSL？</strong><br>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>2MSL表示允许第四次挥手报文至少丢失一次。</p><h3 id="TIME-WAIT的目的"><a href="#TIME-WAIT的目的" class="headerlink" title="TIME_WAIT的目的"></a>TIME_WAIT的目的</h3><p><em>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p><ul><li>序列号：为32位，即达到4G数据后会循环回0；</li><li>初始序列号：受时间影响，4.55小时一次循环；</li></ul><p>如果不保证连接中所有报文都死亡，则可能在相同四元组的情况下被下一个连接错误的接受。</p><p><em>原因二：保证「被动关闭连接」的一方，能被正确的关闭</em><br>第四次挥手可能丢失，此时服务端会重传第三次挥手，TW状态可以回复第四次挥手ACK。<br>否则，重传的第三次握手遇到CLOSE状态会收到RST回复来关闭连接，这部是一个优雅的终止方式。</p><h3 id="TIME-WAIT不能过多"><a href="#TIME-WAIT不能过多" class="headerlink" title="TIME_WAIT不能过多"></a>TIME_WAIT不能过多</h3><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；</li><li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code>参数指定范围。</li></ul><p>对客户端、服务端的影响：</p><ul><li>客户端：对相同IP，PORT的TCP连接是有上线的，即占用端口资源，且占用系统资源。</li><li>服务端：服务器只监听一个端口，理论上不会收到端口资源影响，但仍然占用系统资源。</li></ul><h3 id="优化TIME-WAIT"><a href="#优化TIME-WAIT" class="headerlink" title="优化TIME_WAIT"></a>优化TIME_WAIT</h3><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em><br><strong>tcp_tw_reuse 功能只能用客户端（连接发起方），开启了该功能后，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong><br>前提：打开对 TCP 时间戳的支持，即打开了tcp_timestamps</p><p>结果：时间戳避免了2MSL问题。</p><p><em>方式二：net.ipv4.tcp_max_tw_buckets</em><br>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p><p><em>方式三：程序中使用 SO_LINGER</em><br>设置 socket 选项，来设置调用 close 关闭连接行为。<br>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><h2 id="服务端出现大量TIME-WAIT"><a href="#服务端出现大量TIME-WAIT" class="headerlink" title="服务端出现大量TIME_WAIT"></a>服务端出现大量TIME_WAIT</h2><p><em>第一个场景：HTTP 没有使用长连接</em><br><strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong>。</p><p>请求和响应的双方都可以主动关闭 TCP 连接。<strong>但根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接。</strong></p><p><em>第二个场景：HTTP 长连接超时</em><br>web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如nginx提供的keepalive_timeout参数。<br><strong>这种时候也是服务端主动关闭连接。</strong></p><p><em>第三个场景：HTTP 长连接的请求数量达到上限</em><br>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。<br>调大nginx的配置数量即可。</p><h2 id="服务端大量CLOSE-WAIT"><a href="#服务端大量CLOSE-WAIT" class="headerlink" title="服务端大量CLOSE_WAIT"></a>服务端大量CLOSE_WAIT</h2><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><p>分析一个普通的 TCP 服务端的流程：</p><ol><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll</li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ol><p>导致不会调用close的可能：</p><ol><li>第2步没有注册epoll，代码问题</li><li>第3步没有accept</li><li>第4步没有注册epoll</li><li>第6步没有执行close，代码问题</li></ol><p><strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close</strong>。</p><div class="note note-primary">            <p>不好记，记下流程和结论就行。</p>          </div><h2 id="客户端突然故障"><a href="#客户端突然故障" class="headerlink" title="客户端突然故障"></a>客户端突然故障</h2><h3 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h3><blockquote><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p></blockquote><p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_keepalive_time</span>=<span class="hljs-number">7200</span><br><span class="hljs-attr">net.ipv4.tcp_keepalive_intvl</span>=<span class="hljs-number">75</span>  <br><span class="hljs-attr">net.ipv4.tcp_keepalive_probes</span>=<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>即一般2小时无信息就开始发送探测报文，9次无响应则断开，共2小时11分15秒。TCP 保活的这个机制检测的时间有点长，我们可以自己在应用层实现一个心跳机制。比如Web应用设置定时器，定时器一到如果没有请求就主动释放连接。</p><p>应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，客户端程序正常工作的。会响应探测信息，重置保活。</li><li>第二种，客户端程序崩溃，不会触发保活，操作系统会回收资源完成挥手。</li><li>第三种，客户端主机宕机并重启。回复RST，直接触发关闭。</li><li>第四种，客户端主机宕机或报文不可达。多次探测后关闭连接。</li></ul><blockquote><p>客户端也有保活机制！</p></blockquote><h2 id="服务端进程突然崩溃"><a href="#服务端进程突然崩溃" class="headerlink" title="服务端进程突然崩溃"></a>服务端进程突然崩溃</h2><p>主机操作系统自动完成挥手释放连接。</p><h1 id="四、Socket编程"><a href="#四、Socket编程" class="headerlink" title="四、Socket编程"></a>四、Socket编程</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207155558.png"><br>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个<strong>已完成连接的 socket</strong>，后续用来传输数据。<br>所以，监听的socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听socket</strong>，一个叫作<strong>已完成连接socket</strong>。</p><p>过程：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207155715.png"></p><ul><li>半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li><li>全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li></ul><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><p><strong>但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 &#x3D; min(backlog, somaxconn)，详情见下面的全连接，半连接章节。</strong></p><h3 id="accept-发生在三次握手的哪一步？"><a href="#accept-发生在三次握手的哪一步？" class="headerlink" title="accept 发生在三次握手的哪一步？"></a>accept 发生在三次握手的哪一步？</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.webp"><br><strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><h3 id="close-断开流程"><a href="#close-断开流程" class="headerlink" title="close 断开流程"></a>close 断开流程</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207160043.png"></p><p>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</p><h3 id="没有-accept，能建立-TCP-连接吗？"><a href="#没有-accept，能建立-TCP-连接吗？" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>可以</strong>，accept的作用就是从全连接队列中取出连接，然后对其进行读写，但其不参与连接的建立。</p><h3 id="没有-listen，能建立-TCP-连接吗？"><a href="#没有-listen，能建立-TCP-连接吗？" class="headerlink" title="没有 listen，能建立 TCP 连接吗？"></a>没有 listen，能建立 TCP 连接吗？</h3><p><strong>可以</strong>：</p><ol><li>客户端可以自连接。</li><li>两个客户端同时发起SYN可以互连。</li></ol><h1 id="五、TCP重传、滑动窗口、流量控制、拥塞控制"><a href="#五、TCP重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="五、TCP重传、滑动窗口、流量控制、拥塞控制"></a>五、TCP重传、滑动窗口、流量控制、拥塞控制</h1><h2 id="重传控制"><a href="#重传控制" class="headerlink" title="重传控制"></a>重传控制</h2><p>常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p><code>RTT</code>（往返时延）：指的是<strong>数据发送时刻到接收到确认的时刻的差值</strong><br><code>RTO</code>（超时重传时间）：<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><ul><li>RTO过小导致不必要的重传</li><li>过大导致传输效率低下</li></ul><p>每次超时重传时将下次超时时间时间设置为先前的2倍。</p><h4 id="RTO计算"><a href="#RTO计算" class="headerlink" title="RTO计算"></a>RTO计算</h4><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/9.webp"><br>在 Linux 下，<strong>α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4</strong>。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>慢</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>客户端回复ACK中携带确认收到的报文，连续3个相同ACK表示通知系统重传。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>无法确定重传一条还是重传一批</p><h3 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h3><p><strong>选择性确认</strong>。<br>它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/11.webp"></p><p>要支持<code>SACK</code>需要双方都开启该功能。</p><h3 id="DSACK方法"><a href="#DSACK方法" class="headerlink" title="DSACK方法"></a>DSACK方法</h3><p>Duplicate SACK 又称 <code>D-SACK</code>。<strong>将接受到的重复消息发送给「发送方」</strong>。</p><p>可以配合超时重传或快传，指出哪些数据重复了：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/12.webp"></p><p><code>D-SACK</code> 有这么几个好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>在滑动窗口模式下，不用逐一等待ACK，实现批量发送、<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>TCP 头里有一个字段叫 <code>Window</code>：这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。</p><h3 id="发送方滑动窗口"><a href="#发送方滑动窗口" class="headerlink" title="发送方滑动窗口"></a>发送方滑动窗口</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/19.webp"><br>通过一个窗口大小，两个绝对指针可以得到可用窗口大小。</p><h3 id="接受方滑动窗口"><a href="#接受方滑动窗口" class="headerlink" title="接受方滑动窗口"></a>接受方滑动窗口</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/20.webp"><br>通过一个窗口大小，一个绝对指针表示窗口。每个小窗口内部记录了是否接受到了数据。</p><div class="note note-primary">            <p>接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>          </div><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul><li>发送方接受到ACK后移动并调整窗口大小</li><li>接受方接受到Seq后移动窗口并调整窗口大小。</li></ul><h3 id="操作系统缓冲区"><a href="#操作系统缓冲区" class="headerlink" title="操作系统缓冲区"></a>操作系统缓冲区</h3><p>发送窗口和接收窗口中所存放的字节数，都放在<strong>操作系统内存缓冲区</strong>中。<br><em>情况一：应用程序读取慢</em><br>当接受方的应用程序没有及时获取已经送达的消息时：<br>接受方滑动窗口的右端不变，左端移动应用程序取走的比特数量，实现窗口缩小。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/22.webp"></p><p><em>情况二：服务器资源紧张</em><br>操作系统可能会直接减少了接收缓冲区大小：<br>这种情况下，可能另发送方调整后的右端比之前的右端还前面。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/23.webp"><br>即发送方发送了接受方不在窗口内的消息，导致数据包丢失。</p><p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p><div class="note note-primary">            <p>即保证右端不会左移动。</p>          </div><h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><h1 id="窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。-lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。-lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>窗口大小为0时，发送端会停止发送，等到有空间了又会回复通知可以扩大发送窗口，但若报文丢失，双方会无限等待。<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/24.webp"></h1><p><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/24.webp"></p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>b4ec10f785adda690225747930324e4cddd2ece6</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h4 id="零窗口探测报文"><a href="#零窗口探测报文" class="headerlink" title="零窗口探测报文"></a>零窗口探测报文</h4><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong><br><strong>窗口探测 (Window probe) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><blockquote><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p></blockquote><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。<br>也就是为了几字节而发送一个TCP包，不值得。</p><p>发生：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据</li></ul><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>解决：</p><ul><li>让接收方不通告小窗口给发送方：<ul><li>当窗口大小小于<code>min(MSS，缓存空间/2）</code>时，通知发送方窗口为0。</li></ul></li><li>让发送方避免发送小数据：<ul><li><strong>Nagle算法</strong>：满足条件之一时才发送<ul><li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 并且 数据大小 &gt;&#x3D; <code>MSS</code>；</li><li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li></ul></li></ul></li></ul><p>Nagle：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/55.webp"></p><p><strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p><h4 id="延迟确认-1"><a href="#延迟确认-1" class="headerlink" title="延迟确认"></a>延迟确认</h4><ul><li>当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方。</li><li>当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据可以一起发送。</li><li>如果在延迟等待发送ACK期间，对方的第二个数据报文又到达了，这时就会立刻发送ACK。</li></ul><p><strong>与窗口无关但也可以提高效率，避免小报文，同时其可能导致四次挥手变成三次。</strong></p><h4 id="Nagle算法和延迟确认混合使用"><a href="#Nagle算法和延迟确认混合使用" class="headerlink" title="Nagle算法和延迟确认混合使用"></a>Nagle算法和延迟确认混合使用</h4><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/61.webp"></p><ul><li>接受方因为延迟确认算法不回复。</li><li>发送方因为Nagle算法，不发送后续数据。</li><li>导致接收方等到延迟算法达到时间后（延迟算法：只在有新数据发送 或 达到延迟时间 或 接收到新数据后才回复）才回复，整体时延增加。</li></ul><p>解决：</p><ul><li>发送方关闭Nagle算法</li><li>接收方关闭TCP延迟确认</li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>流量控制主要考虑避免接受方接受得了。<br>拥塞控制主要考虑网络是否承担得了。</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><blockquote><p>发送窗口 swnd &#x3D; min(拥塞窗口cwnd，接受窗口rwnd)</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p><strong>当发送方每收到一个ACK，拥塞窗口 cwnd 的大小就会加 1。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/27.webp"></p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。<br><strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong><br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/28.webp"></p><h3 id="拥塞发送"><a href="#拥塞发送" class="headerlink" title="拥塞发送"></a>拥塞发送</h3><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><ul><li>超时重传：<ul><li><code>ssthresh</code> &#x3D; <code>cwnd/2</code>，即慢启动门限为当前的一半</li><li><code>cwnd</code> &#x3D; <code>1</code>，重置拥塞窗口。</li></ul></li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/29.webp"></p><ul><li>快速重传：<ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入<strong>快速恢复算法</strong>；</li></ul></li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>一般认为如果快速重传，网络问题应该不大，会进入快速恢复算法：<br>快速恢复算法：</p><ul><li><code>cwnd = ssthresh + 3</code></li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1，当收到新的ACK后，说明丢失数据包已经完成发送，恢复拥塞避免状态。</li><li><code>cwnd = ssthresh</code></li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.webp"></p><div class="note note-primary">            <p>快速恢复的观点是，丢失包是意外情况，想要尽快恢复正常，因此：</p><ol><li>更新门限和窗口（快速重传）。</li><li>紧急加大3个门限希望多发一些数据包。</li><li>当接受到新ACK后说明状态恢复，此时门限再回归拥塞避免状态。</li></ol>          </div><h1 id="六、TCP半连接队列和全连接队列"><a href="#六、TCP半连接队列和全连接队列" class="headerlink" title="六、TCP半连接队列和全连接队列"></a>六、TCP半连接队列和全连接队列</h1><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列，是一个Hash表，便于常数时间取出连接；</li><li>全连接队列，也称 accept 队列，是一个链表，只需取出头节点；</li></ul><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230208000041.png"></p><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/3.webp"><br>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，<strong>内核会直接丢弃，或返回 <code>RST</code> 包</strong>。</p><h2 id="TCP全连接溢出"><a href="#TCP全连接溢出" class="headerlink" title="TCP全连接溢出"></a>TCP全连接溢出</h2><p><strong>当超过了 TCP 最大全连接队列，服务端则会丢掉后续进来的 TCP 连接。</strong><br>丢掉的 TCP 连接的个数会被统计起来。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h4><p>丢弃连接是默认行为，可以通过调整策略修改行为。<br>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：</p><ul><li>0：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；</li><li>1：如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接；</li></ul><div class="note note-primary">            <p>即判断是否要回复RST，设置为0更好，因为一般全连接队列只是短暂的满了，不回复RST便于客户端重连。</p>          </div><h4 id="调大区间"><a href="#调大区间" class="headerlink" title="调大区间"></a>调大区间</h4><p>队列大小为<code>min(somaxconn, backlog)</code>，两者都要调大。</p><h2 id="TCP半连接溢出"><a href="#TCP半连接溢出" class="headerlink" title="TCP半连接溢出"></a>TCP半连接溢出</h2><h3 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h3><p><strong>半连接队列最大值</strong>不是单单由 max_syn_backlog 决定，还跟 somaxconn 和 backlog 有关系，即与全连接队列最大值有关。</p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li></ul><p><strong>其长度为max_syn_backlog和全连接队列长度中较小者的两倍</strong>。</p><p>溢出时，看是否开启了tcp_syncookies设置判断是否丢弃。</p><h3 id="舍弃行为"><a href="#舍弃行为" class="headerlink" title="舍弃行为"></a>舍弃行为</h3><p>对消息的舍弃行为行为如下：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/28-1.webp"></p><ol><li>半连接队列满了，没开tcp_syncookies，丢弃</li><li>全连接队列满了，且存在尚未重传第二次握手的连接（说明全连接队列还有有效连接），丢弃</li><li>没开tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)<strong>（即超过了配置数值&lt;不是理论最大值&gt;的3&#x2F;4）</strong>，则丢弃。</li></ol><h3 id="处于SYN-RECV状态的连接数量"><a href="#处于SYN-RECV状态的连接数量" class="headerlink" title="处于SYN_RECV状态的连接数量"></a>处于SYN_RECV状态的连接数量</h3><p>由于丢弃策略的第3点，半连接最大值依然只是一个理论最大值。</p><blockquote><p>Linux5.0后，理论最大值就是全连接最大值。</p></blockquote><h4 id="Syncookies"><a href="#Syncookies" class="headerlink" title="Syncookies"></a>Syncookies</h4><p><strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong><br>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h3 id="SYN攻击方式"><a href="#SYN攻击方式" class="headerlink" title="SYN攻击方式"></a>SYN攻击方式</h3><p>把TCP半连接队列打满。</p><h3 id="SYN攻击避免"><a href="#SYN攻击避免" class="headerlink" title="SYN攻击避免"></a>SYN攻击避免</h3><ul><li>调大 netdev_max_backlog；</li><li>增大 TCP 半连接队列；</li><li>开启 tcp_syncookies；</li><li>减少 SYN+ACK 重传次数</li></ul><p><em>方式一：调大 netdev_max_backlog</em><br>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。扩大这个队列(默认为1000)。</p><p><em>方式二：增大半连接队列</em><br>同时增大下面这三个参数：</p><ul><li>增大 net.ipv4.<code>tcp_max_syn_backlog</code></li><li>增大 listen() 函数中的 <code>backlog</code></li><li>增大 net.core.<code>somaxconn</code></li></ul><p><em>方式三：开启 net.ipv4.tcp_syncookies</em><br>不再保存半连接，而是给客户端发cookie，收到客户端ACK后再验证cookie。</p><p><em>方式四：减少 SYN+ACK 重传次数</em><br>此时会出现大量的二次握手重传，应该减少重传次数。</p><h1 id="七、TCP优化"><a href="#七、TCP优化" class="headerlink" title="七、TCP优化"></a>七、TCP优化</h1><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/4.webp"></p><h2 id="握手优化"><a href="#握手优化" class="headerlink" title="握手优化"></a>握手优化</h2><h3 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h3><p>适当调低重传次数<strong>tcp_syn_retries</strong></p><h3 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h3><h4 id="半连接"><a href="#半连接" class="headerlink" title="半连接"></a>半连接</h4><ul><li>扩大半连接队列大小：<strong>tcp_max_syn_backlog</strong>、<strong>somaxconn</strong>、<strong>backlog</strong></li><li>开启<strong>syncookies</strong>功能</li><li>修改第二次握手的重传次数<strong>tcp_synack_retries</strong></li></ul><h4 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h4><ul><li>扩大全连接队列大小：<strong>somaxconn</strong>、<strong>backlog</strong></li></ul><h3 id="如何绕开三次握手"><a href="#如何绕开三次握手" class="headerlink" title="如何绕开三次握手"></a>如何绕开三次握手</h3><p>TCP Fast Open，第一次派发一个cookie（不同于syncookies，那个是用于绕开全连接和半连接队列的）<br>开启方式：<strong>tcp_fastopn</strong></p><h2 id="挥手优化"><a href="#挥手优化" class="headerlink" title="挥手优化"></a>挥手优化</h2><h3 id="主动方"><a href="#主动方" class="headerlink" title="主动方"></a>主动方</h3><p>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）。</p><ul><li>close(int sock)：函数意味着完全断开连接。</li><li>shutdown(int sock,int howto)：控制只关闭 读&#x2F;写&#x2F;双向 方向的连接。</li></ul><h4 id="FIN-WAIT1优化"><a href="#FIN-WAIT1优化" class="headerlink" title="FIN_WAIT1优化"></a>FIN_WAIT1优化</h4><ul><li>调低<strong>tcp_orphan_retries参数（默认8次）控制</strong></li><li>调低<strong>tcp_max_orphans 参数，它定义了「孤儿连接」的最大数量</strong>，新的孤儿连接直接发送RST强制关闭。</li><li>设置close关闭行为，即客户端可以强行关闭。</li></ul><h4 id="FIN-WAIT2优化"><a href="#FIN-WAIT2优化" class="headerlink" title="FIN_WAIT2优化"></a>FIN_WAIT2优化</h4><ul><li>shutdown关闭时，可一直维持该状态</li><li>close关闭时，<strong>tcp_fin_timeout</strong>标出了最大持续时长，目的与TIME_WAIT类似。</li></ul><h4 id="TIME-WAIT优化"><a href="#TIME-WAIT优化" class="headerlink" title="TIME_WAIT优化"></a>TIME_WAIT优化</h4><ul><li><strong>tcp_max_tw_buckets参数</strong>限制TIME_WAIT数量。</li><li><strong>tcp_tw_reuse</strong>复用TIME_WAIT连接，同时还要双方开启时间戳。</li></ul><p>时间戳作用：</p><ul><li>防止过期数据</li><li>防止序列号绕回</li></ul><p>PAWS坑：<br>老版本的 Linux 还提供了 <code>tcp_tw_recycle</code> 参数，但是当开启了它，允许处于 TIME_WAIT 状态的连接被快速回收，但是有个<strong>大坑</strong>，现在已经关掉这个参数了。</p><p>开启了 recycle 和 timestamps 选项，就会开启一种叫 per-host 的 PAWS（判断TCP 报文中时间戳是否是历史报文） 机制，<strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>，而非对「IP + 端口」四元组做 PAWS 检查。因此如果客户端通过NAT与服务器建立连接，另一个客户端可能与其复用IP，但两者时间戳可能不一样，导致错误丢弃。</p><div class="note note-primary">            <p>SHUTDOWN比CLOSE优雅，但CLOSE仍然是主流的断开连接方式，并且可以指定CLOSE行为（挥手或直接RST）</p>          </div><h3 id="被动方"><a href="#被动方" class="headerlink" title="被动方"></a>被动方</h3><h4 id="CLOSE-WAIT优化"><a href="#CLOSE-WAIT优化" class="headerlink" title="CLOSE_WAIT优化"></a>CLOSE_WAIT优化</h4><p>调低tcp_orphan_retries 参数</p><blockquote><p>另外，close如果被迅速调用，四次挥手可能变成三次。<br>也可以理解成延时响应。</p></blockquote><p><strong>如果双方同时关闭连接？</strong><br>同时关闭，出现了一个新状态（CLOSING）<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/38.webp"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>滑动窗口大小：TCP可选字段中指明窗口扩大因子。</li><li>最大传输速度：发送缓冲区大小最好与带宽时延积靠近。</li><li>缓冲区：<ul><li>发送缓冲区是自行调节的。</li><li>接受缓冲区可以配置开启，根据系统空闲来接受窗口。</li></ul></li><li>TCP内存范围：<strong>调大 tcp_mem 的上限</strong>扩大TCP内存。</li></ul><h1 id="八、如何确定序列号和确认号"><a href="#八、如何确定序列号和确认号" class="headerlink" title="八、如何确定序列号和确认号"></a>八、如何确定序列号和确认号</h1><ul><li>序列号 &#x3D; <strong>上一次发送</strong>的序列号 + len（数据长度）。<ul><li>特殊情况，如果<strong>上次发送</strong>的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。</li></ul></li><li>确认号 &#x3D; <strong>上一次收到</strong>的报文中的序列号 + len（数据长度）。<ul><li>特殊情况，如果<strong>上次收到</strong>的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li></ul></li></ul><div class="note note-primary">            <p>总结就是上次序列号+数据长度，但SYN和FIN作为主动发出的控制，都需要占用1个syn。<br>ack表示期待的下一个收到的syn报文。</p>          </div><h1 id="九、QUIC"><a href="#九、QUIC" class="headerlink" title="九、QUIC"></a>九、QUIC</h1><h2 id="TCP协议的缺点"><a href="#TCP协议的缺点" class="headerlink" title="TCP协议的缺点"></a>TCP协议的缺点</h2><ul><li>升级 TCP 的工作很困难：内核实现</li><li>TCP 建立连接的延迟：3次握手</li><li>TCP 存在队头阻塞问题：滑动窗口队头阻塞</li><li>网络迁移需要重新建立 TCP 连接：四元组发生变化</li></ul><h2 id="UDP可靠传输QUIC"><a href="#UDP可靠传输QUIC" class="headerlink" title="UDP可靠传输QUIC"></a>UDP可靠传输QUIC</h2><p>解决了TCP的缺点</p><ul><li>升级容易（随浏览器升级，应用层实现）</li><li>快速连接（配合TLS1.3，1RTT即可实现首次连接，0RTT实现二次连接）</li><li>只存在单个Stream对队头阻塞</li><li>无感迁移（靠连接ID识别）</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/ab3283383013b707d1420b6b4cb8517c.webp"></p><h3 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207231330.jpg"><br>Packet Header 细分这两种：</p><ul><li>Long Packet Header 用于首次建立连接。</li><li>Short Packet Header 用于日常传输数据。</li></ul><p><em>握手次数</em><br><strong>QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。</strong></p><p>Short Packet Header 中的 <code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>。</p><blockquote><p>TCP无法区分ACK是对原始报文还是重传报文的响应，因为ack值相同，但SYN重传时Packet Number也不一样，从而便于计算RTT和RTO。</p></blockquote><p>此外，QUIC 使用的Packet Number单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持<strong>乱序确认</strong>，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动。</p><p><em>重传问题</em><br>重传时编号比原始编号大。与乱序确认一起解决了队头阻塞问题。</p><h3 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h3><p>一个 Packet 报文中可以存放多个 QUIC Frame。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207232037.png"></p><h3 id="Fream结构"><a href="#Fream结构" class="headerlink" title="Fream结构"></a>Fream结构</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207232139.jpg"></p><ul><li>Stream ID：区别真正的消息ID，便于组装</li><li>Offset：指出负载数据在消息体中的偏移，保证顺序和可靠性。</li></ul><blockquote><p>如何确定两个Packet相同，即是重传的：<br>通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="如何解决队头阻塞问题？"><a href="#如何解决队头阻塞问题？" class="headerlink" title="如何解决队头阻塞问题？"></a>如何解决队头阻塞问题？</h3><p>HTTP&#x2F;2通过Stream解决了HTTP消息阻塞（不同Stream可以乱序），但无法避免TCP阻塞。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/http2%E9%98%BB%E5%A1%9E.webp"><br><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/quic%E6%97%A0%E9%98%BB%E5%A1%9E.webp"><br>即如果Stream2丢了UDP包，只影响Stream2的处理。</p><h3 id="如何实现流量控制"><a href="#如何实现流量控制" class="headerlink" title="如何实现流量控制"></a>如何实现流量控制</h3><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><h4 id="Stream-级别的流量控制"><a href="#Stream-级别的流量控制" class="headerlink" title="Stream 级别的流量控制"></a>Stream 级别的流量控制</h4><p>Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p><p>**接收窗口的流控：接收窗口 &#x3D; 最大窗口数 - 接收到的最大偏移数。</p><p><strong>接收窗口的滑动</strong>：当已经上交给应用的数据达到最大接受窗口的一半时进行滑动。</p><h4 id="Connection-流量控制"><a href="#Connection-流量控制" class="headerlink" title="Connection 流量控制"></a>Connection 流量控制</h4><p>限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</p><h1 id="X：列举问题"><a href="#X：列举问题" class="headerlink" title="X：列举问题"></a>X：列举问题</h1><h3 id="SYN报文什么时候情况下会被丢弃？"><a href="#SYN报文什么时候情况下会被丢弃？" class="headerlink" title="SYN报文什么时候情况下会被丢弃？"></a>SYN报文什么时候情况下会被丢弃？</h3><ul><li>半连接、全连接队列数量限制且没开syncookies设置。</li><li>为了复用TIME_WAIT开启tcp_tw_recycle，开启了时间戳，在NAT网络下消息过期被丢弃。</li></ul><h3 id="已建立连接的TCP，收到SYN会发生什么？"><a href="#已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="已建立连接的TCP，收到SYN会发生什么？"></a>已建立连接的TCP，收到SYN会发生什么？</h3><ol><li>客户端的SYN报文里的端口号与历史连接不相同：建立新连接。</li><li>客户端的SYN报文里的端口号与历史连接相同：<ul><li>服务端回复ACK（Challenge ACK：包含正确的序列号和确认号）。</li><li>客户端回复RST（即这个ACK处理不了）</li></ul></li></ol><h3 id="收到乱序的FIN包如何处理"><a href="#收到乱序的FIN包如何处理" class="headerlink" title="收到乱序的FIN包如何处理"></a>收到乱序的FIN包如何处理</h3><p><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/Pasted-image-20230207222312.png"><br><strong>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</strong></p><p>等收到延迟的数据包后检查乱序队列，若该队列中有可用数据，且数据有FIN标志，则进入TIME_WAIT状态。</p><h3 id="在TIME-WAIT状态的TCP连接，收到-SYN-后会发生什么？"><a href="#在TIME-WAIT状态的TCP连接，收到-SYN-后会发生什么？" class="headerlink" title="在TIME_WAIT状态的TCP连接，收到 SYN 后会发生什么？"></a>在TIME_WAIT状态的TCP连接，收到 SYN 后会发生什么？</h3><p><strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong></p><ul><li>序列号比期望的大</li><li>时间戳要比上次收到的要大</li></ul><p>处理：</p><ul><li>合法则重用四元组连接。</li><li>非法<ul><li>主动端回复第四次ACK</li><li>被动端发现不是自己期待的就发送RST</li><li>主动方接受RST：看<code>net.ipv4.tcp_rfc1337</code> 这个内核参数<ul><li>参数设置为 0，则提前结束TIME_WAIT</li><li>参数设置为 1，则丢掉RST</li></ul></li></ul></li></ul><div class="note note-primary">            <p>接收方发现非法SYN会回复正确（Challenge）的ACK。<br>发送方发现非法ACK会回复RST。</p>          </div><h3 id="TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="TCP 连接，一端断电和进程崩溃有什么区别？"></a>TCP 连接，一端断电和进程崩溃有什么区别？</h3><h4 id="无数据传输"><a href="#无数据传输" class="headerlink" title="无数据传输"></a>无数据传输</h4><p><strong>断电</strong>：过一段时间进入保活，然后关闭<br><strong>进程崩溃</strong>：直接释放，进行挥手</p><h4 id="有数据传输"><a href="#有数据传输" class="headerlink" title="有数据传输"></a>有数据传输</h4><p><strong>客户端主机宕机，又迅速重启</strong>：</p><ol><li>服务端超时重传。</li><li>客户端重启后若无论端口是否被绑定，都会回复RST。</li></ol><p><strong>客户端主机宕机，一直没有重启</strong>：</p><ol><li>服务器超时重传（<code> tcp_retries2</code>，默认15次），然后断开连接。</li></ol><h3 id="拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗？"></a>拔掉网线后， 原本的 TCP 连接还存在吗？</h3><p>本质和数据丢包一样，若有数据则超时重传，没有则等保活。</p><h3 id="tcp-tw-reuse-为什么默认是关闭的？"><a href="#tcp-tw-reuse-为什么默认是关闭的？" class="headerlink" title="tcp_tw_reuse 为什么默认是关闭的？"></a>tcp_tw_reuse 为什么默认是关闭的？</h3><p>以下两种方式都默认关闭：</p><ul><li>net.ipv4.tcp_tw_reuse，连接时发现<strong>相同四元组</strong>的连接在TIME_WAIT状态则复用。</li><li>net.ipv4.tcp_tw_recycle，由于PWSA机制，NAT网络下不安全。</li></ul><p>tw的2MSL是很重要的：</p><ul><li>RST报文即使时间戳过期也会被处理，关闭正常连接。</li><li>服务端无法正确关闭，不优雅。</li></ul><h3 id="TLS和TCP可以同时握手吗"><a href="#TLS和TCP可以同时握手吗" class="headerlink" title="TLS和TCP可以同时握手吗"></a>TLS和TCP可以同时握手吗</h3><p>只有以下两点同时满足：</p><ul><li><strong>客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；</strong></li><li><strong>客户端和服务端已经完成过一次通信。</strong></li></ul><p>利用TCP Fast Open第二次连接时只需要发送cookie，可以同时携带TLS1.3的第二次连接时的会话恢复机制，1RTT即可完成握手。</p><h3 id="TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？"><a href="#TCP-Keepalive-和-HTTP-Keep-Alive-是一个东西吗？" class="headerlink" title="TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？"></a>TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h3><h4 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h4><p>应用层不主动释放TCP连接，而是复用该TCP连接。</p><h4 id="TCP-Keep-Alive"><a href="#TCP-Keep-Alive" class="headerlink" title="TCP Keep-Alive"></a>TCP Keep-Alive</h4><p>在没有数据交互的情况下，探测目标是否存活的保活机制。</p><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p>可以，两套独立模块<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97-1.webp"></p><h3 id="多个TCP服务进程可以bind同一个端口吗？"><a href="#多个TCP服务进程可以bind同一个端口吗？" class="headerlink" title="多个TCP服务进程可以bind同一个端口吗？"></a>多个TCP服务进程可以bind同一个端口吗？</h3><p>不行，绑定相同IP和Port时不行。</p><h4 id="同一个TCP服务进程如何复用TCP连接"><a href="#同一个TCP服务进程如何复用TCP连接" class="headerlink" title="同一个TCP服务进程如何复用TCP连接"></a>同一个TCP服务进程如何复用TCP连接</h4><blockquote><p>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？<br>因为有TIME_WAIT状态，服务器进程可以bind前开启<strong>SO_REUSEADDR</strong>，即仅针对自己这个进程的TW复用。</p></blockquote><h4 id="绑定不同IP相同Port可行吗"><a href="#绑定不同IP相同Port可行吗" class="headerlink" title="绑定不同IP相同Port可行吗"></a>绑定不同IP相同Port可行吗</h4><p>一般可行，但有特例：</p><blockquote><p>注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。</p><p>这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。</p></blockquote><p>开启<strong>SO_REUSEADDR</strong>后，只要求IP和端口不完全一样即可，所以这个特例也变成可行的。</p><h3 id="多个客户端可以bind同一个端口吗"><a href="#多个客户端可以bind同一个端口吗" class="headerlink" title="多个客户端可以bind同一个端口吗"></a>多个客户端可以bind同一个端口吗</h3><blockquote><p>客户端是在调用 connect 函数的时候，由内核随机选取一个端口作为连接的端口。<br>而如果我们想自己指定连接的端口，就可以用 bind 函数来实现：客户端先通过 bind 函数绑定一个端口，然后调用 connect 函数就会跳过端口选择的过程了，转而使用 bind 时确定的端口。</p></blockquote><p>其他同上一个问题。</p><h3 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h3><p>TCP由四元组做区分，在所有IP相同情况下：</p><ul><li>访问不同的服务器（目标IP和目标端口不同），总是可以复用。</li><li>访问同一个服务器，则端口有冲突，但很少不够用导致重复。</li></ul><blockquote><p>客户端TCP连接TIME_WAIT状态过多，会导致端口资源耗尽而无法建立新的连接吗？<br>与上个问题类似。</p></blockquote><blockquote><p>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？<br>开启tw_reuse，若TIME_WAIT超过1s，则可以复用。</p></blockquote><p>客户端端口选择：<br><img src="/2023/02/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP/%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9.webp"></p><h3 id="服务端没有listen，可以建立连接吗"><a href="#服务端没有listen，可以建立连接吗" class="headerlink" title="服务端没有listen，可以建立连接吗"></a>服务端没有listen，可以建立连接吗</h3><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><div class="note note-primary">            <p>bind只是表示进程会占用该端口发送消息，只有listen后才会创建全连接队列，半连接队列。</p>          </div><p><strong>不使用listen，可以建立连接吗？</strong><br>与服务端必须开启listen不同，主机内核有个全局 hash 表，可以用于存放 sock 连接的信息。<br>当<strong>客户端</strong>调用connect函数时，会将该sock信息放入表中，因此可以实现连接一般有两种情况：</p><ul><li>客户端自连接</li><li>两个客户端互相连接</li></ul><div class="note note-primary">            <p>服务端listen后，创建队列接受处理连接。<br>客户端connect后，自己的连接信息放入内核hash处理连接。</p>          </div><h3 id="没有-accept，能建立-TCP-连接吗？-1"><a href="#没有-accept，能建立-TCP-连接吗？-1" class="headerlink" title="没有 accept，能建立 TCP 连接吗？"></a>没有 accept，能建立 TCP 连接吗？</h3><p><strong>执行accept()只是为了从全连接队列里取出一条连接。</strong><br>不干涉TCP握手的建立。</p><h3 id="队列满了的行为"><a href="#队列满了的行为" class="headerlink" title="队列满了的行为"></a>队列满了的行为</h3><ul><li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li><li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li></ul><h3 id="四次挥手可以变成三次吗"><a href="#四次挥手可以变成三次吗" class="headerlink" title="四次挥手可以变成三次吗"></a>四次挥手可以变成三次吗</h3><p>可以，「<strong>没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</strong></p><h3 id="TCP一定可靠吗？"><a href="#TCP一定可靠吗？" class="headerlink" title="TCP一定可靠吗？"></a>TCP一定可靠吗？</h3><p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong><br>如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTP</title>
    <link href="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/"/>
    <url>/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>超文本传输协议，<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><ul><li>协议：HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</li><li>传输：HTTP 协议是一个<strong>双向协议</strong>。</li><li>超文本：<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li></ul><p>总结：<br><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.webp"><br><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。<br><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 </li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h2><ul><li>Accept: 可接受的数据格式</li><li>Host 字段：服务器域名</li><li>Connection 字段：使用长连接<br>  即复用同一个TCP连接，HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</li><li>Content-Length 字段：数据长度，为了解决粘包</li><li>Content-Type：本次数据格式</li><li>Content-Encoding：数据的压缩方法</li></ul><h2 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h2><p>get：语义是获取资源（可放入body也可放入url）<br>post：语义是操作资源（请求参数放入body）</p><h3 id="GET和POST方法都是安全和幂等的吗？"><a href="#GET和POST方法都是安全和幂等的吗？" class="headerlink" title="GET和POST方法都是安全和幂等的吗？"></a>GET和POST方法都是安全和幂等的吗？</h3><p>安全：不破坏服务器资源<br>幂等：多次执行结果不变</p><ul><li><strong>GET 方法就是安全且幂等的</strong>（可做缓存）。</li><li><strong>POST</strong> <strong>方法不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。（<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>）。</li></ul><blockquote><p>实际上开发者也可以不遵守这个规定。</p></blockquote><h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><p>本地缓存的方式有：<strong>强制缓存和协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>HTTP响应头可以表示资源的缓存时间：</p><ul><li><code>Cache-Control</code>，是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>其中，<strong>Cache-Control 的优先级高于 Expires</strong>。<br>强制缓存：只要不过期，肯定直接返回。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%BC%93%E5%AD%98etag.webp"><br>协商缓存：<strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><p>实现方法：<br>方法一：时间戳</p><ul><li>响应头中的<code>Last-Modified</code>：资源最后的修改时间</li><li>请求头中的<code>If-Modified-Since</code>：告诉服务器上次接受资源的时间</li></ul><p>即客户端接受到第一次访问的数据中发现有<code>Last-Modified</code>字段，再次请求时会携带<code>If-Modified-Since</code>字段（值为<code>Last-Modified</code>），服务器通过判断<code>Last-Modified</code>是否过期判断回复最新结果200还是无修改304。</p><p>方法二：E-tag</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：告诉服务器上次接受资源的ID。</li></ul><p>原理相同。<br>由于方法一的时间戳可能背篡改导致不可靠，主要使用方法二，且<strong>Etag的优先级更高</strong>。</p><p><strong>Etag的优点</strong>：</p><ol><li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li><li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li><li>有些服务器不能精确获取文件的最后修改时间。</li></ol><div class="note note-primary">            <p>这些Last-Modified的缺点与TCP连接的TW-REUSE开启之后使用时间戳的缺点类似。</p>          </div><p>注意，<strong>协商缓存这两个字段都需要配合强制缓存中Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><h1 id="二、HTTP特性"><a href="#二、HTTP特性" class="headerlink" title="二、HTTP特性"></a>二、HTTP特性</h1><p>到目前为止，HTTP 常见到版本有 <code>HTTP/1.1</code>，<code>HTTP/2.0</code>，<code>HTTP/3.0</code>，不同版本的 HTTP 特性是不一样的。</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>HTTP 最突出的优点是「简单(格式简单)、灵活和易于扩展（在应用层请求头和响应头可扩展）、应用广泛和跨平台」。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>长连接</li><li>管道网络传输，解决了请求的队头阻塞。</li></ul><h5 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h5><p>HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><h5 id="管道网络传输"><a href="#管道网络传输" class="headerlink" title="管道网络传输"></a>管道网络传输</h5><p>在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.webp"></p><p><strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。<br>如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。<br><strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h4 id="传输上"><a href="#传输上" class="headerlink" title="传输上"></a>传输上</h4><ul><li>数据量大</li><li>响应阻塞</li></ul><h4 id="安全性上"><a href="#安全性上" class="headerlink" title="安全性上"></a>安全性上</h4><ul><li>无状态：无状态使服务器不用记忆http状态，但关联性操作会比较麻烦。可使用cookie技术解决。</li><li>明文传输：信息容易被爬</li><li>不安全：<ul><li>明文导致密码泄露</li><li>假网站</li><li>无法证明报文完整性</li></ul></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="与HTTP的区别"><a href="#与HTTP的区别" class="headerlink" title="与HTTP的区别"></a>与HTTP的区别</h3><ul><li>HTTPS 则解决 <strong>HTTP 不安全</strong>的缺陷，在TCP和HTTP网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h3><p>窃听、篡改、冒充</p><h3 id="HTTPS解决的方法"><a href="#HTTPS解决的方法" class="headerlink" title="HTTPS解决的方法"></a>HTTPS解决的方法</h3><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li></ul><div class="note note-primary">            <p>对称加密：就是一个密钥加密，并使用同一个密钥解密。<br>非对称加密：一个密钥加密，必须由另一个密钥解密。</p><p>其中非对称加密一般分公钥和私钥，这两个钥匙可以双向加解密。</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；（防窃听）</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。（防冒充）</li></ul>          </div><h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法 + 数字签名"></a>摘要算法 + 数字签名</h3><p><strong>用摘要算法（哈希函数）来计算出内容的哈希值</strong>。（防修改）</p><p><strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。</p><div class="note note-primary">            <p>摘要只保证正文未被修改，不保证正文真伪。</p>          </div><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p><strong>数字签名算法</strong>，使用<strong>非对称加密算法</strong>加密哈希值（摘要）。</p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.webp"></p><p>由于中间人无法将数据使用私钥加密，其伪造的hash无法被公钥解密，所以可以得知数据被人替换过了。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>摘要和签名算法已经保证了数据不会被篡改和不被冒充。<br>但实现过程中存在漏洞：公钥的获取，客户端需要根据公钥来识别数字签名。</p><p><strong>数字证书认证机构</strong>CA：</p><ul><li>服务器可以将自己的公钥注册到CA机构，CA使用私钥将其加密后颁发数字证书。</li><li>客户端根据服务器发送的证书和公钥，将其使用CA公钥解开对比即可得知其是否得到了CA的信任。</li></ul><p>验证流程：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp"></p><h3 id="TLS握手阶段"><a href="#TLS握手阶段" class="headerlink" title="TLS握手阶段"></a>TLS握手阶段</h3><p>SSL&#x2F;TLS 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<a href="https://xiaolincoding.com/network/2_http/https_rsa.html">RSA 算法</a>和 <a href="https://xiaolincoding.com/network/2_http/https_ecdhe.html">ECDHE 算法</a>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.webp"></p><p>TLS 协议建立的详细流程：<br><em>1. ClientHello</em><br>客户端向服务器发送以下信息（明文）：<br>（1）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。<br>（2）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em><br>服务器回应的内容有如下内容（明文）：<br>（1）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。<br>（2）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。</p><p><em>3.客户端回应</em><br>验证CA证书，取出公钥，并使用公钥加密（服务器公钥加密）：<br>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><blockquote><p>由于使用服务器公钥加密，所以只有服务器可以解密得知pre-master-key，即第三个随机数中间人无法获取。</p></blockquote><p><em>4. 服务器的最后回应</em><br>计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：<br>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><blockquote><p>第三、四次握手只有第三次握手传了第三个随机数，剩下的两个内容类似TCP握手协议中的FIN，ACK确认。</p></blockquote><h3 id="TLS握手算法"><a href="#TLS握手算法" class="headerlink" title="TLS握手算法"></a>TLS握手算法</h3><p>不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的。<br>过程：与上面的过程相同。<br><strong>使用 RSA 密钥协商算法的最大问题是不支持前向保密</strong>。一旦服务端的私钥泄漏了，过去被第三方截获的所有TLS通讯密文都会被破解。</p><h4 id="ECDHE"><a href="#ECDHE" class="headerlink" title="ECDHE"></a>ECDHE</h4><p>ECDHE 密钥协商算法是 DH 算法演进过来的。</p><h5 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h5><p>DH算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是<strong>离散对数</strong>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.webp"></p><ul><li>底数a和模数p是离散对数的公共参数，也就说是公开的。</li><li>b是真数（私钥），i是对数（公钥）。</li><li>知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</li></ul><h5 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h5><p>通讯双方各自根据自己的私钥，使用固定算法得到自己的公钥并交换。<br>根据得到的对方公钥，和自己的私钥计算，双方此时得到相同的密钥。<br>（这个算法具有交换律）</p><h5 id="DHE"><a href="#DHE" class="headerlink" title="DHE"></a>DHE</h5><p>根据私钥生成的方式，DH 算法分为两种实现：</p><ul><li>static DH 算法，这个是已经被废弃了；</li><li>DHE 算法，现在常用的；</li></ul><p>static DH不具有前向安全性，后者表示每次动态生成密钥。</p><h5 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h5><p>为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— <strong>ECDHE 算法</strong>。利用了ECC 椭圆曲线特性。</p><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p><strong>在TLS第四次握手前，客户端就已经发送了加密的 HTTP 数据，即ECDHE相比RSA握手过程省去了一个消息往返的时间</strong>。</p><ul><li>第一次握手与RSA类似</li><li>第二次握手新增了选择椭圆曲线和基点，动态生成了私钥和公钥，同时使用<strong>RSA签名算法</strong>给公钥签名并发送。</li><li>第三次握手验证CA后根据椭圆信息也生成私钥和公钥，并回复公钥。</li><li>第四次握手类似，回复确认过程没问题即可。</li></ul><div class="note note-primary">            <ul><li>ECDHE每次动态生成密钥和公钥，支持前向保密。</li><li>客户端可以在三次握手后就开始传输数据</li><li>在 TLS 第2次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li><li>依然使用了RSA算法，服务端使用了static私钥签名曲线公钥，用于保证发送的公钥不被篡改。</li></ul>          </div><h4 id="证书校核"><a href="#证书校核" class="headerlink" title="证书校核"></a>证书校核</h4><p>颁发和校核流程：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.webp"><br>信任链：<br>我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E7%94%A8%E6%88%B7%E4%BF%A1%E4%BB%BB.webp"><br>验证链：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AF%81%E4%B9%A6%E9%93%BE.webp"></p><p>为何不直接由Root CA验证：<br><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p><h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p><em>SSL&#x2F;TLS</em>：SSL 是 “_Secure Sockets Layer_” 的缩写，中文叫做「安全套接层」。其标准化之后的名称改为 TLS（ “_Transport Layer Security_” ），即「传输层安全协议」。</p><p>_TLS1.3_：TLS1.3相对TLS1.2做了优化，其只需要<strong>3次</strong>握手：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/tls1.2and1.3-1.webp"></p><ul><li><strong>对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法</strong>。</li><li>由于省去算法协商，直接互相交换使用相同算法计算过的公钥即完成了交换和计算，从而只需要3次握手（1RTT）。</li><li>重连时，使用Ticket技术优化的话可以在0RTT内完成重连(<strong>会话恢复机制</strong>)。</li></ul><h3 id="HTTPS的应用数据是如何保证完整性的？"><a href="#HTTPS的应用数据是如何保证完整性的？" class="headerlink" title="HTTPS的应用数据是如何保证完整性的？"></a>HTTPS的应用数据是如何保证完整性的？</h3><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.webp"></p><p>具体过程如下：</p><ul><li>切割消息并压缩。</li><li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>通过对称密码进行加密。</li><li>加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><h3 id="HTTPS一定可靠吗？"><a href="#HTTPS一定可靠吗？" class="headerlink" title="HTTPS一定可靠吗？"></a>HTTPS一定可靠吗？</h3><p>如前面说的，HTTPS中CA部分是为了防止冒充，但这里中间人自己有证书，从而实现了服务代理。但这种证书其实是非法的，只要用户不主动接受非法证书，否则是不会出现问题的。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.webp"></p><p><strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong>。</p><h3 id="如何避免被抓包"><a href="#如何避免被抓包" class="headerlink" title="如何避免被抓包"></a>如何避免被抓包</h3><ol><li>不点击允许非法证书（中间人攻击）</li><li>HTTPS双向认证，即服务端也要验证客户端信息。</li></ol><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p><strong>HTTP&#x2F;2协议是基于HTTPS的。</strong><br>其兼容了老版本的HTTP&#x2F;1.1，即其仍使用http表示明文，https表示加密，而浏览器和服务器可以在背后实现协议升级。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/25-HTTP2.webp"></p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>主动推送</li></ul><div class="note note-primary">            <p>2个特点压缩信息，2个特点加强传输。</p>          </div><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>使用<code>HPACK</code>算法，维护一张头信息表，为每个头信息生成一个id号，以后就可以只传id。</p><h4 id="HPACK算法"><a href="#HPACK算法" class="headerlink" title="HPACK算法"></a>HPACK算法</h4><ul><li>静态字典：有61种固定id和对应含义；</li><li>动态字典：自行构建动态表，发送一次后，双方都会更新自己的动态表（一个id保存本次所有Header字段），下次可以只发id；<ul><li>动态表生效前提：<strong>必须同一个连接上，重复传输完全相同的 HTTP 头部</strong>。因此会造成内存占用过大，服务器一般会配置参数限制动态表大小，达到数量后关闭HTTP&#x2F;2连接来释放内存。</li></ul></li><li>Huffman 编码（压缩算法）；</li></ul><p>另外由于使用二进制表达，也不需要冒号空格和末尾的<code>\r\n</code>作为分隔符了，改用表示字符串长度（Value Length）来分割 Index 和 Value，一个Header字段：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224430.png"></p><h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>头信息和数据体都直接为二进制格式，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp"><br>这样解析数据时，可以直接解析二进制文件。</p><h4 id="二进制帧结构"><a href="#二进制帧结构" class="headerlink" title="二进制帧结构"></a>二进制帧结构</h4><h1 id="帧长度后面的一个字节是表示帧的类型，HTTP-x2F-2-总共定义了-10-种类型的帧，一般分为数据帧和控制帧两类。-帧类型后面的一个字节是标志位，可以保存-8-个标志位，用于携带简单的控制信息。-lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#帧长度后面的一个字节是表示帧的类型，HTTP-x2F-2-总共定义了-10-种类型的帧，一般分为数据帧和控制帧两类。-帧类型后面的一个字节是标志位，可以保存-8-个标志位，用于携带简单的控制信息。-lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="- 帧长度后面的一个字节是表示帧的类型，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为数据帧和控制帧两类。- 帧类型后面的一个字节是标志位，可以保存 8 个标志位，用于携带简单的控制信息。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206224926.png"><br>- 帧长度后面的一个字节是表示<strong>帧的类型</strong>，HTTP&#x2F;2 总共定义了 10 种类型的帧，一般分为<strong>数据帧</strong>和<strong>控制帧</strong>两类。<br>- 帧类型后面的一个字节是<strong>标志位</strong>，可以保存 8 个标志位，用于携带简单的控制信息。<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>b4ec10f785adda690225747930324e4cddd2ece6</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h3 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h3><p>HTTP&#x2F;1.1使用<strong>请求-响应</strong>模型，因此会产生对头阻塞。<br>HTTP&#x2F;2引入了Stream概念，使多个stream复用一个TCP连接：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/stream.webp"></p><blockquote><p>1 个 TCP 连接包含多个 Stream。<br>1 个 Stream 里可以包含多个 Message。<br>1 个 Message 对应 HTTP&#x2F;1 中的1个请求或响应，可以包含多个Frame</p></blockquote><p>每个HTTP请求（Message）都有独一无二的<strong>SteamID</strong>，这样接受端可以通过StreamID将多个Frame有序组装成一个HTTP消息。</p><ul><li>不同StreamID是可以乱序发送的。</li><li>相同Stream的frame必须有序发送。</li></ul><p>HTTP&#x2F;2 还可以对每个 Stream 设置不同<strong>优先级</strong>，在枕头中的标志位展示。</p><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.webp"></p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>客户端和服务器<strong>双方都可以建立Stream</strong>， Stream ID也是有区别的：</p><ul><li>客户端建立的Stream必须是奇数号。</li><li>服务器建立的Stream必须是偶数号。</li></ul><p>如下：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206191054.png"><br>应用有：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/push.webp"><br>主动推送css文件。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器在推送资源时，会通过 <code>PUSH_PROMISE</code> 帧传输 HTTP 头部，并通过帧中的 <code>Promised Stream ID</code> 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>还是存在队头阻塞问题，问题出在TCP层面。</li></ul><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><ul><li><strong>使用UDP，解决了TCP的阻塞问题。</strong></li><li>然后使用<strong>QUIC协议</strong>实现UDP可靠传输。</li></ul><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>特点：</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><p><em>1、无队头阻塞</em><br>多路复用，类似HTTP&#x2F;2的stream，但不受限于TCP了。<br><strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。<br>这与 HTTP&#x2F;2 不同，HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响（TCP）。</p><p><em>2、更快的连接建立</em><br>HTTP&#x2F;3 在传输数据前需要 QUIC 协议3次握手，需要 1 RTT。握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，其内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 <strong>TLS&#x2F;1.3</strong>，因此仅需 <strong>1 个 RTT</strong> 就可以「同时」完成建立连接与密钥协商，如下图：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.webp"><br>对于第二次连接，应用数据包+QUIC(TLS+连接信息)，可以实现0-RTT。</p><p>以下是TCP+TLS1.2，TCL+TLS1.3，QUIC三种情况在首次和再次需要的RTT时间：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206210341.png"></p><div class="note note-primary">            <p><strong>RTT是针对客户端建立连接耗时。</strong><br>TCP+TLS1.2：</p><ul><li>首次：TCP三次握手+TLS四次握手（TCP第三次握手合并TLS第一次握手，最后合并为6个）：3RTT</li><li>再次：TCP三次握手+TLS两次握手（TCP第三次握手合并TLS第一次握手，TLS使用Session技术，合并为4个）：2RTT<br>TCP+TLS1.3:</li><li>首次：TCP三次握手+TLS三次握手（TCP第三次握手合并TLS第一次握手，合并为5个）：2RTT</li><li>再次：TCP三次握手+TLS零次握手（TCP第三次握手合并TLS第一次握手，TLS使用Ticket技术，合并为3个）：1RTT<br>QUIC+TLC1.3：</li><li>首次：QUIC三次握手+TLS三次握手（全程合并，为3个）：1RTT</li><li>再次：QUIC一次握手+TLS零次握手（QUIC连接迁移，TLS使用Ticket技术，合并为1个）：0RTT</li></ul><p>RTT记忆：32,21,10。</p>          </div><p><em>3、连接迁移</em><br>四元组确定一个独立的<strong>TCP</strong>连接。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206211242.png"><br><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。</p><p>QUIC 协议没通过<strong>连接 ID</strong> 来标记通信的两个端点。只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，达到了<strong>连接迁移</strong>的功能。</p><blockquote><p>QUIC 比较新，而又是基于 UDP 实现的，如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p></blockquote><h4 id="帧格式对比"><a href="#帧格式对比" class="headerlink" title="帧格式对比"></a>帧格式对比</h4><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230206225705.png"></p><ul><li>类型：大体上分为数据帧和控制帧两大类，Headers 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</li><li>压缩：头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。</li><li>相比HTTP&#x2F;2，HTTP&#x2F;3的静态扩大了，动态表的解码方式不同，QPACK解决了该问题：使用两个特殊的单向流，实现字典的请求同步和响应。</li></ul><blockquote><p>动态表具有时序性，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来。</p></blockquote><h1 id="三、HTTP1-1优化"><a href="#三、HTTP1-1优化" class="headerlink" title="三、HTTP1.1优化"></a>三、HTTP1.1优化</h1><p>我们可以从下面这三种优化思路来优化 HTTP&#x2F;1.1 协议：</p><ul><li>_尽量避免发送 HTTP 请求_；</li><li>_在需要发送 HTTP 请求时，考虑如何减少请求次数_；</li><li>_减少服务器的 HTTP 响应的数据大小_；</li></ul><h2 id="避免发送HTTP请求"><a href="#避免发送HTTP请求" class="headerlink" title="避免发送HTTP请求"></a>避免发送HTTP请求</h2><p>本地缓存：将请求url作为key，响应作为value保存到本地磁盘上。</p><ul><li>根据<code>Cache-Control</code>或<code>Expires</code>请求头实现强制缓存。</li><li>根据<code>Last_Modified</code>或<code>Ttag</code>请求头实现协商缓存。</li></ul><h2 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h2><ul><li>减少重定向请求次数；</li><li>合并请求；</li><li>延迟发送请求；</li></ul><h3 id="减少重定向请求次数"><a href="#减少重定向请求次数" class="headerlink" title="减少重定向请求次数"></a>减少重定向请求次数</h3><p><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.webp"><br><strong>重定向的工作交由代理服务器完成，就能减少HTTP请求次数了</strong><br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.webp"><br>代理服务器已知重定向规则后，直接实现代理访问：<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.webp"></p><h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>多个小请求合并成大请求，body一样但避免了header重复。</p><p>另外，HTTP&#x2F;1.1的管道模式默认不开启，即存在请求队头阻塞问题，浏览器的处理方式是多开几个TCP连接一起访问，所以合并请求也可以减少TCP连接的数量。</p><h3 id="延迟发送请求"><a href="#延迟发送请求" class="headerlink" title="延迟发送请求"></a>延迟发送请求</h3><p>即懒加载。</p><h2 id="减少HTTP响应的数据大小"><a href="#减少HTTP响应的数据大小" class="headerlink" title="减少HTTP响应的数据大小"></a>减少HTTP响应的数据大小</h2><p><strong>压缩</strong>的方式一般分为 2 种，分别是：</p><ul><li>_无损压缩_；</li><li>_有损压缩_；</li></ul><h3 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Encoding: gzip, deflate, br<br></code></pre></td></tr></table></figure><h3 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h3><p>q表示质量引子。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>: audio/*; q=<span class="hljs-number">0</span>.<span class="hljs-number">2</span>, audio/basic<br></code></pre></td></tr></table></figure><h3 id="增量数据"><a href="#增量数据" class="headerlink" title="增量数据"></a>增量数据</h3><p>对于视频和声音等，可以使用增量数据的方式表示后续帧。<br>对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。</p><div class="note note-primary">            <p>记忆总结：</p><ul><li>数量上不发</li><li>数量上少发</li><li>大小上减少</li></ul>          </div><h1 id="四、HTTPS优化"><a href="#四、HTTPS优化" class="headerlink" title="四、HTTPS优化"></a>四、HTTPS优化</h1><h2 id="性能消耗"><a href="#性能消耗" class="headerlink" title="性能消耗"></a>性能消耗</h2><p>产生性能消耗的两个环节：</p><ul><li>第一个环节， TLS 协议握手过程；</li><li>第二个环节，握手后的对称加密报文传输。</li></ul><h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><h3 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h3><p><strong>HTTPS 协议是计算密集型，而不是 I&#x2F;O 密集型</strong>，可以选择对应指令优化的CPU。</p><h3 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h3><ul><li>软件升级：Linux系统内核升级</li><li>协议优化：<ul><li>ECDHE密钥交换，客户端不用等第四次握手就可以发送消息。</li><li>TLS升级1.3，1RTT即完成握手。</li></ul></li></ul><h3 id="证书优化"><a href="#证书优化" class="headerlink" title="证书优化"></a>证书优化</h3><h4 id="证书传输优化"><a href="#证书传输优化" class="headerlink" title="证书传输优化"></a>证书传输优化</h4><p>相同强度下，椭圆曲线（ECDSA）证书比RSA证书密钥长度更短</p><h4 id="证书验证优化"><a href="#证书验证优化" class="headerlink" title="证书验证优化"></a>证书验证优化</h4><p>减少验证链的过程。</p><p>CRL：证书吊销列表（_Certificate Revocation List_）<br>即快速失败策略，会越来越大，也不好维护，已经不再使用。<br>OCSP：在线证书状态协议（_Online Certificate Status Protocol_），<strong>向CA发送请求查询，返回有效状态</strong>。</p><h5 id="OCSP-Stapling"><a href="#OCSP-Stapling" class="headerlink" title="OCSP Stapling"></a>OCSP Stapling</h5><p>服务器向CA周期性查询证书状态，并缓存经过<strong>签名</strong>结果。<br>客户端发起连接请求时，服务器把响应结果回复给客户端。<br>由于<strong>签名</strong>的存在，服务器无法篡改。</p><div class="note note-primary">            <p>即把客户端CA验证变成了服务端统一验证。</p>          </div><h2 id="会话复用"><a href="#会话复用" class="headerlink" title="会话复用"></a>会话复用</h2><ul><li>第一种叫 Session ID，1RTT；</li><li>第二种叫 Session Ticket，1RTT；</li><li>第三种叫 Pre-shared Key，0RTT；</li></ul><h3 id="Session-ID"><a href="#Session-ID" class="headerlink" title="Session ID"></a>Session ID</h3><p><strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>。</p><p>缺点是占用内存（空间换时间），且不一定会命中上次访问过地服务器。</p><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p><strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。<br>客户端缓存Ticket，下次连接时发送，服务器直接解密校验。</p><p>缺点是要确保每台服务器的加解密方式一样，且不具有前向安全性。</p><h3 id="Pre-shared-Key"><a href="#Pre-shared-Key" class="headerlink" title="Pre-shared Key"></a>Pre-shared Key</h3><p>对于<strong>重连 TLS1.3</strong>只需要 0 RTT，原理与Ticket类似，但其重连时会直接把Ticket和HTTP一起发送给服务端。</p><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>中间人获取Session ID&#x2F;Ticket后模拟客户端不断请求。因此，要对<strong>对会话密钥设定一个合理的过期时间</strong>，并只对安全请求使用会话重用。</p><h1 id="五、RPC协议"><a href="#五、RPC协议" class="headerlink" title="五、RPC协议"></a>五、RPC协议</h1><h2 id="TCP存在的问题"><a href="#TCP存在的问题" class="headerlink" title="TCP存在的问题"></a>TCP存在的问题</h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。<br>由于TCP是<strong>基于字节流</strong>的，字节之间没有边界，会造成<strong>粘包问题</strong>。因此，一般使用TCP时，还需要自定义一些信息，如消息头中标记长度，从而取出正确的数据。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。<br>主要思想是像调用本地方法一样调用远程方法。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230207112106.png"><br>有非常多款式的 RPC 思想的实现，比如比较有名的<code>gRPC</code>，<code>thrift</code>。虽然大部分 RPC 协议底层使用 TCP，但实际上<strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><h2 id="HTTP与RPC"><a href="#HTTP与RPC" class="headerlink" title="HTTP与RPC"></a>HTTP与RPC</h2><h3 id="存在"><a href="#存在" class="headerlink" title="存在"></a>存在</h3><ul><li>为什么有了HTTP还要RPC：RPC在HTTP前诞生</li><li>为什么有了RPC还要HTTP：B&#x2F;S架构的诞生，需要统一协议。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><ul><li>HTTP访问需要<strong>IP</strong>和<strong>端口</strong>。</li><li>RPC访问时，可以找中间服务获取IP等信息。</li></ul><p>本质上区别不大。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><ul><li>RPC和HTTP1.1一样，有长连接</li><li>RPC和HTTP一样，可以存在连接池</li></ul><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>RPC定制化程度更高，序列化协议的体积更小，因此<strong>性能</strong>也更好。</p><blockquote><p>当然上面说的 HTTP，其实<strong>特指的是现在主流使用的 HTTP&#x2F;1.1</strong>，<code>HTTP/2</code> 在前者的基础上做了很多改进，所以<strong>性能可能比很多 RPC 协议还要好</strong>，甚至连 <code>gRPC</code> 底层都直接用的 <code>HTTP/2</code>。</p></blockquote><h1 id="六、WebSocket"><a href="#六、WebSocket" class="headerlink" title="六、WebSocket"></a>六、WebSocket</h1><h2 id="服务器主动推送消息的方式"><a href="#服务器主动推送消息的方式" class="headerlink" title="服务器主动推送消息的方式"></a>服务器主动推送消息的方式</h2><ul><li>HTTP不断轮询：轮询存在间隔，有卡顿，浪费资源。</li><li>长轮询:即将超时时间设置的很长，出现响应后才回复（扫码）</li><li>WebSocket</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>HTTP&#x2F;1.1，使用了半双工的方式（请求-响应）。</p><h3 id="建立WebSocket连接"><a href="#建立WebSocket连接" class="headerlink" title="建立WebSocket连接"></a>建立WebSocket连接</h3><p>1）浏览器在 <strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p><ul><li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是继续用普通 HTTP 协议进行交互。</li><li>如果这时候是<strong>想建立 WebSocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的header 头</strong>，如下：即浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 WebSocket 协议（Upgrade: WebSocket）</strong>。同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<br><span class="hljs-symbol">Upgrade:</span> WebSocket<br><span class="hljs-keyword">Sec</span>-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n<br></code></pre></td></tr></table></figure></li></ul><p>2）服务器接受到消息后，如果也想升级成WebSocket协议，则走WebSocket 握手流程，同时根据客户端生成的base64码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。HTTP 的响应如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols\r\n<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>WebSocket\r\n<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade\r\n<br></code></pre></td></tr></table></figure><p>3）浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p><h3 id="WebSocket消息格式"><a href="#WebSocket消息格式" class="headerlink" title="WebSocket消息格式"></a>WebSocket消息格式</h3><p>数据包在WebSocket中被叫做<strong>帧</strong>，我们来看下它的数据格式长什么样子。<br><img src="/2023/02/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTP/Pasted-image-20230207113622.png"><br><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p><ul><li>等于 1 ，是指text类型（<code>string</code>）的数据包</li><li>等于 2 ，是二进制数据类型（<code>[]byte</code>）的数据包</li><li>等于 8 ，是关闭连接的信号</li></ul><p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p><ul><li>既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit 或 7+64bit。</code></li><li>根据最前面7bit的数值绝对，若为126则实际上为<code>16bit</code>，127则实际上为<code>64bit</code>。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>WebSocket完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。</p><p>它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景，比如网页&#x2F;小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第5章（线程池）</title>
    <link href="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/"/>
    <url>/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程池工作原理"><a href="#一、线程池工作原理" class="headerlink" title="一、线程池工作原理"></a>一、线程池工作原理</h1><h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：系统的资源是有限的，所以线程作为一个消耗系统资源的东西，就不可能无限制的创建。这样，我们通过引入线程池，对线程进行进行统一地分配和监控，降低手动管理每个线程的复杂度。</li></ul><blockquote><p>阿里巴巴的《Java 开发手册》中也强制规定了：<strong>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong>。</p></blockquote><h2 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h2><p>线程池的组成：</p><ul><li>核心线程池（存储线程）</li><li>工作队列（存储任务）</li></ul><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203232839.png"><br>当提交一个新任务到线程池时，线程池的处理流程分如下三步走：</p><ol><li>判断核心线程池里的线程是否都在执行任务（<strong>核心线程池是否已满</strong>）：<ul><li>如果不是，则创建一个新的工作线程来执行任务。</li><li>如果核心线程池里的线程都在执行任务，则进入下一步。</li></ul></li><li>判断<strong>工作队列是否已满</strong>：<ul><li>如果工作队列没有满，则将新提交的任务存储在这个工作队列里。</li><li>如果工作队列满了，则进入下一步。</li></ul></li><li>判断线程池中的所有线程是否都处于工作状态（<strong>线程池是否已满</strong>）：<ul><li>如果没有，则创建一个新的工作线程来执行任务。</li><li>如果已经满了，则交给<strong>饱和策略</strong>来处理这个任务。</li></ul></li><li>饱和策略有以下几种：<ul><li>AbortPolicy（默认）：无法处理新任务时直接抛出异常</li><li>CallerRunsPolicy：使用调用者所在的线程来运行新任务（这个很好理解，一般我们都是主线程提交任务，然后扔进线程池执行，对吧。当线程池满了后，如果使用这个策略，就会调用主线程来执行新任务）</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并将新任务加入队列</li><li>DiscardPolicy：不做任何处理，直接将新任务丢弃掉，粗暴！</li></ul></li></ol><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203233411.png"></p><div class="note note-primary">            <p>总的思路是<strong>尽量使用核心线程池的线程执行任务</strong>，实在不行再请求新线程，还不行就走饱和策略。</p>          </div><p><strong>工作队列何时出列？</strong><br>线程在执行完任务后，就会主动从工作队列中获取任务来执行。</p><p><strong>为什么这样设计？</strong><br>创建新线程永远不是最优先的选择，而是尽可能地复用已存在的线程。</p><h1 id="二、创建线程池"><a href="#二、创建线程池" class="headerlink" title="二、创建线程池"></a>二、创建线程池</h1><p>线程池的创建方法总体来说可分为 2 大类：</p><ul><li>一种是通过 <code>Executors</code> 创建的线程池</li><li>另一种是通过 <code>ThreadPoolExecutor</code> 创建的线程池</li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors 封装了6种方法，对应创建6种不同的线程池：</p><ul><li>FixedThreadPool</li><li>CachedThreadPool</li><li>SingleThreadExecutor</li><li>WorkStealingPool</li><li>ScheduledThreadPool</li><li>SingleThreadScheduledExecutor</li></ul><h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><p>创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234231.png"><br>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建包含 2 个线程的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 创建任务</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行任务&quot;</span>);<br>    &#125;<br>&#125;;<br>fixedThreadPool.submit(runnable);<br>fixedThreadPool.execute(runnable);<br></code></pre></td></tr></table></figure><p>execute和submit </p><ul><li>execute用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li><li>submit用于提交需要返回值的任务，线程池会返回一个 Future 类型的对象。</li></ul><h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><p>创建一个可缓存的线程池，若线程数超过处理任务所需（供 &gt; 求），多出来的线程缓存一段时间后会被回收掉；而如果线程数不够（供 &lt; 求），则线程池会新建一些线程出来。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234225.png"></p><h3 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h3><p>创建只包含一个线程的线程池，它可以保证任务先进先出的执行顺序。也就说，先被扔进线程池的任务，就会被先执行<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234321.png"></p><h3 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234401.png"><br>和 SingleThreadExecutor相反，WorkStealingPool创建的是一个抢占式执行的线程池，也即任务执行顺序不确定。</p><h3 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h3><p>创建一个可以执行延迟&#x2F;定时任务的线程池。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234413.png"><br>这时就不再使用<code>execute/submit</code>了，而是<code>schedule</code>。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234500.png"></p><h3 id="SingleThreadScheduledExecutor"><a href="#SingleThreadScheduledExecutor" class="headerlink" title="SingleThreadScheduledExecutor"></a>SingleThreadScheduledExecutor</h3><p>这个方法创建的是仅包含 1 个线程线程池，并且它可以执行延迟任务。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>上述Executors的6种方法，其底层最终调用的都是ThreadPoolExecutor的构造函数，只不过参数不同。可以简单理解为，<code>ThreadPoolExecutor</code>是最基本的创建线程池的方式，<code>Executors</code>对其做了一定的封装。</p><blockquote><p>在阿里巴巴的《Java 开发手册》上，明确规定了：<br>【强制要求】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203234656.png"></p><ol><li>corePoolSize：核心线程数</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</li><li>unit：即keepAliveTime的单位</li><li>workQueue：阻塞队列</li><li>threadFactory：线程工厂，主要用来创建线程，默认为正常优先级、非守护线程。</li><li>handler：拒绝策略，即饱和策略<ul><li>AbortPolicy (默认策略)：拒绝执行并抛出异常</li><li>CallerRunsPolicy：使用当前调用的线程来执行此任务</li><li>DiscardOldestPolicy：抛弃阻塞队列头部（最旧）的一个任务，并执行当前任务</li><li>DiscardPolicy：忽略并抛弃当前任务</li></ul></li></ol><div class="note note-primary">            <p><strong>核心线程数</strong>、<strong>最大线程数</strong>、<strong>阻塞队列</strong>是限制大小的。<br><strong>存活时间</strong>和<strong>单位</strong>是管理非核心线程的。<br><strong>工厂</strong>管理生成线程策略。<br><strong>处理器</strong>决定饱和策略。</p>          </div><p>后两个参数一般默认，常用的是5参数版本：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203235208.png"></p><h3 id="为什么不要使用Executors创建线程池"><a href="#为什么不要使用Executors创建线程池" class="headerlink" title="为什么不要使用Executors创建线程池"></a>为什么不要使用Executors创建线程池</h3><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</li><li>CachedThreadPool：允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li></ul><h1 id="三、Executor"><a href="#三、Executor" class="headerlink" title="三、Executor"></a>三、Executor</h1><p>Executor是一个接口，更是一个框架！<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230203235700.png"></p><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204002439.png"></p><ul><li>任务：包括被执行任务需要实现的接口：<code>Runnable/Callable</code>接口</li><li>任务的执行：包括任务执行机制的核心接口<code>Executor</code>，以及继承自 <code>Executor</code>的<code>ExecutorService</code>接口。<ul><li><code>Executor</code>框架有两个关键类实现了<code>ExecutorService</code>接口，分别为<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code></li></ul></li><li>任务执行的结果：包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204002726.png"></p><ol><li>创建Runnable&#x2F;Callable</li><li>提交给ExecutorService，ExecutorService根据具体实现来处理任务。</li><li>返回Future&#x2F;FutureTask(FutureTask是Future的实现类)</li></ol><h2 id="Executors、Executor、ExecutorService"><a href="#Executors、Executor、ExecutorService" class="headerlink" title="Executors、Executor、ExecutorService"></a>Executors、Executor、ExecutorService</h2><p>区别：</p><ul><li><code>ExecutorService</code>接口继承了<code>Executor</code>接口<ul><li><code>execute()</code>方法在<code>Executor</code>中定义，而<code>submit()</code>在<code>ExecutorService</code>中定义。</li><li><code>ExecutorService</code>提供了很多控制线程池的方法，如<code>shutdown</code>。</li></ul></li><li><code>Executors</code>只是一个工具类，快速生成<code>ExecutorService</code>的子类，如<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>。</li></ul><h1 id="四、配置线程池"><a href="#四、配置线程池" class="headerlink" title="四、配置线程池"></a>四、配置线程池</h1><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC5%E7%AB%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89/Pasted-image-20230204003341.png"><br>三个参数：<code>corePoolSize</code>核心线程数、<code>maximumPoolSize</code>最大线程数和 <code>workQueue</code>阻塞队列，就是我们在创建线程池时应该关注的重点。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="线上与线下"><a href="#线上与线下" class="headerlink" title="线上与线下"></a>线上与线下</h3><p><strong>线上 - 响应速度优先</strong>：需要快速响应用户的请求，应该不设置阻塞队列去缓冲并发任务，调高 <code>corePoolSize</code> 和 <code>maxPoolSize</code> 去创造尽可能多的线程快速执行任务。<br><strong>线下 - 吞吐量优先</strong>：需要尽可能快地批量处理任务，应该设置阻塞队列去缓冲并发任务，调整合适的<code>corePoolSize</code>去设置处理任务的核心线程数。</p><h3 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h3><p><strong>CPU密集型任务</strong>：充分利用CPU，设置corePoolSize为CPU数+1（备用，防止其他线程暂停不工作）。<br><strong>IO密集型任务</strong>：尽可能多配置核心线程，IO等待时让其他线程占用CPU。<br>主要还是看实际生产情况灵活调整。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第4章（并发集合与工具类）</title>
    <link href="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/"/>
    <url>/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、并发集合"><a href="#一、并发集合" class="headerlink" title="一、并发集合"></a>一、并发集合</h1><p>J.U.C 为每一类集合都提供了线程安全的实现，且大多都是以 <code>Concurrent</code> 或者 <code>CopyOnWrite</code> 开头的。</p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>1)List</p><ul><li><code>Vector</code>（这个没啥好说的，它就是把 ArrayList 中所有的方法统统加上 <code>synchronized</code> ）</li><li><code>CopyOnWriteArrayList</code></li></ul><p>2)Set</p><ul><li><code>CopyOnWriteArraySet</code></li><li><code>ConcurrentSkipListSet</code></li></ul><p>3)Queue</p><ul><li>BlockingQueue 接口<ul><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>ConcurrentLinkedQueue</li></ul></li><li>TransferQueue 接口<ul><li>LinkedTransferQueue</li></ul></li><li>BlockingDeque 接口<ul><li>LinkedBlockingDeque</li><li>ConcurrentLinkedDeque</li></ul></li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li>HashTable（就是把 HashMap 中所有的方法统统加上 synchronized ）</li><li>ConcurrentMap 接口<ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><ul><li>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</li><li>Segment 继承自 ReentrantLock，是一种可重入锁；HashEntry 是用于真正存储数据的地方</li><li>一个 ConcurrentHashMap 包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，当对某个 HashEntry 数组中的元素进行修改时，必须首先获得该元素所属 HashEntry 数组对应的 Segment 锁</li></ul><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203174438.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">// 真正存放数据的地方</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;<br>    <span class="hljs-comment">// 键值对数量</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-comment">// 阈值</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><br>    Segment(<span class="hljs-type">float</span> lf, <span class="hljs-type">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;<br>        <span class="hljs-built_in">this</span>.loadFactor = lf;<br>        <span class="hljs-built_in">this</span>.threshold = threshold;<br>        <span class="hljs-built_in">this</span>.table = tab;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简而言之，将HashCode分片，每片持有一个锁（ReentrantLock），多个桶（HashEntry数组）</p><p><strong>每个 <code>HashEntry</code> 是一个链表结构的元素</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V value;<br>    <span class="hljs-keyword">volatile</span> HashEntry&lt;K,V&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><p>HashEntry维护了一个next指针，并注意value被<code>volatile</code>修饰，保证了可见性。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    <span class="hljs-comment">// 1. 通过 key 定位到具体的 Segment</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;<br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject<br>         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-literal">null</span>)<br>        s = ensureSegment(j);<br>    <span class="hljs-comment">// 在对应的 Segment 中进行真正的 put</span><br>    <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>对key做hash处理（1次hash）</li><li>对key做掩码等处理（2次hash）</li><li>获取对应segment，如果为空则创建。</li><li>在对应segment上执行put操作（使用1次hash的值）</li><li>获取segment的锁，失败则自旋直到成功</li><li>成功后判断是否需要扩容HashEntry数组，然定位、插入。</li></ol><p>注意这里获取segment时，对key做了两次hash处理，目的是尽可能将将数据打散到各个segment。</p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><ol><li>通过二次hash定位到具体segment</li><li>通过一次hash定位到具体元素</li></ol><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>不同于 JDK 1.7 版本的 Segment 数组 + HashEntry 链表。</p><ul><li>JDK 1.8 版本中的 ConcurrentHashMap 直接抛弃了 Segment 锁，一个 ConcurrentHashMap 包含一个 Node 数组（和 HashEntry 实现差不多）</li><li>每个 Node 是一个链表结构，并且在链表长度大于一定值（大于8且node数组长度大于64）时会转换为红黑树结构（TreeBin）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br><br>    Node(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.next = next;<br>&#125;<br></code></pre></td></tr></table></figure><p>TreeBin继承了Node，当Node链表长度过长时，会升级为TreeBin。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203175817.png"><br>结构图：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203175855.png"></p><p>使用<strong>synchronized+CAS</strong>保证并发安全性。</p><p>Node 数组其实就是一个哈希桶数组，每个 Node 头节点及其所有的 next 节点组成的链表就是一个桶，只要锁住这个桶的<strong>头结点</strong>，就不会影响其他哈希桶数组元素的读写。</p><blockquote><p>JDK 1.8 没有使用 ReentrantLock 而是改用 synchronized，足以说明新版 JDK 对 synchronized 的优化确有成效。</p></blockquote><h4 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h4><ol><li>根据key计算hash</li><li>根据hash定位Node<ul><li>若Node为空，则CAS写入（失败则自旋，重新判断Node是否为空）；</li><li>若不为空但hashcode &#x3D;&#x3D; MOVED &#x3D;&#x3D; -1，需要扩容</li><li>若不为空且不需要扩容，则利用synchronized写入数据。</li></ul></li></ol><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p><a href="https://blog.csdn.net/ZOKEKAI/article/details/90051567">扩容细节</a></p><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><ol><li>根据key计算hash</li><li>根据hash定位Node</li><li>判断节点类型并搜索</li></ol><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列含义：</p><ul><li><strong>当队列满时，队列会阻塞向其中插入元素的线程，直到队列不满</strong></li><li><strong>当队列为空时，获取队列中元素的线程会一直等待，直到队列变为非空</strong><br>应用场景：生产者-消费者<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181313.png"><br>模式：<strong>当队列满时，生产者阻塞，当队列空时，消费者阻塞</strong>。</li></ul><h3 id="Java中的BlockingQueue"><a href="#Java中的BlockingQueue" class="headerlink" title="Java中的BlockingQueue"></a>Java中的BlockingQueue</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181429.png"><br>Java 中提供了一个阻塞队列的接口 BlockingQueue 以及 7 个具体的实现（6 个单向队列和 1 个双端队列）：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue：一个使用 PriorityBlockingQueue 实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储任何元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><h4 id="有界队列与无界队列"><a href="#有界队列与无界队列" class="headerlink" title="有界队列与无界队列"></a>有界队列与无界队列</h4><p>以LinkedBlockingQueue为例：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181546.png"></p><ul><li>带参构造函数需要指定队列的长度，并且当<strong>队列满了之后也不会对其进行扩容</strong>，这就是有界队列</li><li>而<strong>无参构造函数赋给队列的长度是 Integer.MAX_VALUE</strong>，显然现实几乎不会有这么大的容量超过 Integer.MAX_VALUE，所以从使用者的体验上，可以无限入队，相当于无界队列</li></ul><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>主要方法：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181646.png"><br>方法区别：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181641.png"></p><p>主要研究：”阻塞进” <code>put()</code> 和 “阻塞出” <code>take()</code></p><p>阻塞队列利用<code>Lock</code>中的<code>Condition</code>使用<strong>通知模式</strong>，实现对生产者，消费者的通知。</p><p>以<code>ArrayBlockingQueue</code>为例，其拥有两个condition成员变量：<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203181939.png"></p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 获取可中断锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果当前元素个数等于队列的最大长度，则调用 notFull.await() 进行等待</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br>        <span class="hljs-comment">// 向队列中插入元素</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 入队成功，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取可中断锁</li><li>判断队列空间<ul><li>如果队列空间不足，则在notFull队列中等待，被唤醒后继续尝试入列（<code>enqueue</code>，该方法中调用了notEmpty.signal()，提醒消费者）。</li><li>如果队列空间足够，入列（<code>enqueue</code>）</li></ul></li><li>释放锁</li></ol><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    <span class="hljs-comment">// 获取可中断锁</span><br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果队列中没有元素，则调用 notEmpty.await() 进行等待</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-comment">// 从队列中取出元素</span><br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 出队成功，释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>获取可中断锁</li><li>判断队列是否为空<ul><li>若为空，则在在notEmpty队列中等待，被唤醒后再尝试获取</li><li>若不为空，则获取元素(<code>dequeue</code>，notFull.signal()，提醒生产者)</li></ul></li><li>释放锁</li></ol><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203182814.png"></p><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p>ConcurrentLinkedQueue，使用CAS保证线程安全。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203182841.png"></p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>Vector</code> 其实是非常粗暴的给ArrayList所有方法都加上了锁，导致并发度不高。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>ArrayList迭代时，不允许集合被修改。因此需要避免多线程下ArrayList线程不安全的问题。<br>可以通过读写锁避免读时写，但如果我们希望无论合适都可以读取到数据，则需要COW的思想。</p><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><p>COW放弃了这种数据实时性，通过满足数据的最终一致性从而提升并发度。顾名思义，写时复制，Redis的主从复制就是使用的这种思想。<br>写操作时，先创建目标对象的拷贝，对拷贝对象写完成后替换原对象。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>CopyOnWriteArrayList维护一个底层数组，其可以被替换。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203183841.png"></p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203183612.png"></p><ol><li>加重入锁</li><li>复制数组</li><li>改写数组元素并替换原数组对象</li><li>释放锁</li></ol><h3 id="延时感知"><a href="#延时感知" class="headerlink" title="延时感知"></a>延时感知</h3><p>读线程读取数组元素时，可能读到的是旧数组。</p><h3 id="COW缺点"><a href="#COW缺点" class="headerlink" title="COW缺点"></a>COW缺点</h3><ul><li>复制严重消耗<strong>性能</strong>。</li><li>会产生大量数组垃圾，容易造成GC（<strong>内存</strong>）。</li><li>对实时性要求高的化也不建议使用。</li></ul><h1 id="二、并发工具类"><a href="#二、并发工具类" class="headerlink" title="二、并发工具类"></a>二、并发工具类</h1><p>J.U.C 为我们封装了一些有用的控制并发流程的工具，CountDownLatch、CyclicBarrier、Semaphore 以及 Exchanger。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒计时器，一个线程执行一定的时间后另一个线程才可以开始（继续）执行。</p><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>join方法也可以提供类似的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>System.out.println(<span class="hljs-string">&quot;first thing finish&quot;</span>);   <br>    &#125;        <br>&#125;);          <br><br>threadA.start();     <br>threadA.join();   <br>System.out.println(<span class="hljs-string">&quot;FINISH&quot;</span>);    <br></code></pre></td></tr></table></figure><p>主线程会等待A线程完成后再执行FINISH打印。<br>join()方法还提供了<code>join(long millis)</code> 和 <code>join(long millis,int nanos)</code>，可以设置超时时间和时间单位。</p><p>join的底层原理：<strong>wait&#x2F;notify</strong> 等待通知机制。</p><h3 id="CountDownLatch-1"><a href="#CountDownLatch-1" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203184730.png"><br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203184732.png"></p><ul><li>CountDownLatch 的构造函数接收一个 int 类型的参数（count）作为计数器。</li><li>每调用一次 countDown 方法，这个 count 就会减 1。</li><li>当 count 不为 0 的时候，我们可以调用 CountDownLatch 的 await 方法阻塞当前线程，直到 count 变为 0，当前线程才可以继续往下执行。</li></ul><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>        System.out.println(<span class="hljs-string">&quot;first thing finish&quot;</span>);   <br>        countDownLatch.countDown(); <span class="hljs-comment">// count --</span><br>        System.out.println(<span class="hljs-string">&quot;second thing finish&quot;</span>);        <br>        countDownLatch.countDown(); <span class="hljs-comment">// count --</span><br>    &#125;        <br>&#125;).start();<br>countDownLatch.await(); <span class="hljs-comment">// 主线程被阻塞住，直到 count = 0</span><br>System.out.println(<span class="hljs-string">&quot;FINISH&quot;</span>);    <br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>join是必须等待其他线程执行完或超时才继续执行，这里则通过信号量的方式实现对主线程的通知。</p>          </div><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，<strong>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;            <br>    <span class="hljs-meta">@Override</span>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;    <br>        cyclicBarrier.await(); <span class="hljs-comment">// 子线程已达到屏障</span><br>        System.out.println(<span class="hljs-string">&quot;child Thread&quot;</span>);   <br>    &#125;        <br>&#125;).start();<br><br>cyclicBarrier.await(); <span class="hljs-comment">// 主线程已到达屏障</span><br>System.out.println(<span class="hljs-string">&quot;main Thread&quot;</span>);  <br></code></pre></td></tr></table></figure><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203185034.png"></p><p><code>CyclicBarrier</code>还提供一个更高级的构造函数<code>CyclicBarrier(int parties，Runnable barrier-Action)</code>，就是说，当抵达屏障的线程数量满足parties后，在所有被阻塞的线程继续执行之前（即屏障打开之前），率先执行<code>barrier-Action</code>方法。</p><div class="note note-primary">            <p>都是通过调用工具类对象的<code>await</code>方法实现线程阻塞，然后工具类在合适的时候会唤醒线程。</p>          </div><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用许可证来理解更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">20</span>);<br><span class="hljs-comment">//申请许可证</span><br>s.acquire();<br><span class="hljs-comment">//释放许可证</span><br>s.release();<br></code></pre></td></tr></table></figure><p>就像餐厅的座位有限一样，需要排队恰饭一样。<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203185405.png"><br>其最大的作用就是限流，和阻塞队列的原理有些相似，只不过阻塞队列限制的是排队的长度，这里限制的是恰饭的人数。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>两个线程想要互相阻塞式地交换信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;aaa&quot;</span>);  <br>                System.out.println(<span class="hljs-string">&quot;B发生的消息：&quot;</span>+A);  <br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123; <br>            &#125;   <br>        &#125;  <br>    &#125;);  <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>        <span class="hljs-keyword">try</span>&#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> exgr.exchange(<span class="hljs-string">&quot;bbb&quot;</span>);  <br>            System.out.println(<span class="hljs-string">&quot;A发生的消息：&quot;</span>+B);  <br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123; <br>        &#125;<br>    &#125;);  <br>    t1.start();  <br>    t2.start();  <br>&#125;<br></code></pre></td></tr></table></figure><p>交换到信息后，两个线程各自继续执行。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal称不上是一个工具类，但其能起到隔离线程之间数据的效果。<br>线程在ThreadLocal中设置的值是线程私有的。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();  <br>threadLocal.set(<span class="hljs-string">&quot;aa&quot;</span>);  <br>threadLocal.get();  <br>System.out.println(threadLocal.get());  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191027.png"></p><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191043.png"></p><ol><li>通过线程t获取ThreadLocalMap</li><li>通过ThreadLocalMap设置（this，value）</li></ol><p>解释：<br>1）ThreadLocalMap<br><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191419.png"><br>ThreadLocalMap是ThreadLocal的内部类，其中，Entry是map中的节点，从来存储真正的k-v数据。所以当向ThreadLocal中set值时，实际上是在给ThreadLocalMap赋值，即，在ThreadLocalMap中创建新的Entry节点。<br>2）<code>map.set(this,value)</code><br>ThreadLocal是一个公共对象，且可以有多个ThreadLocal存在。</p><ul><li>同一个ThreadLocal在不同的线程下代表不同的值。</li><li>使用一个线程查看不同的ThreadLocal也具有不同的意义。</li></ul><p>因此，实际上只有<code>ThreadLocalMap</code>是线程私有的，<code>ThreadLocalMap</code>中的Entry存储着真正的值，通过这个map，以不同的<code>ThreadLocal</code>为键，即可存储本线程中不同<code>ThreadLocal</code>的值。</p><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191609.png"></p><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203191704.png"><br>可以看出来，一个 ThreadLocal 只能保存一个 “key : value” 键值对，并且各个线程的数据互不干扰。</p><h3 id="ThreadLocal经典之内存泄漏"><a href="#ThreadLocal经典之内存泄漏" class="headerlink" title="ThreadLocal经典之内存泄漏"></a>ThreadLocal经典之内存泄漏</h3><p><img src="/2023/02/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E4%B8%8E%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89/Pasted-image-20230203192458.png"></p><p><strong>Entry结构</strong><br>ThreadLocalMap，底层保存了Entry数组，作为存储的桶。</p><p>Entry结构持有：</p><ul><li>虚引用ThreadLocal</li><li>实引用Value</li></ul><p>在构造Entry（继承了<code>WeakReference&lt;ThreadLocal&gt;</code>，因此其可以虚引用一个<code>ThreadLocal</code>字段）的时候，会顺便把对应的<code>ThreadLocal</code>设置它的一个弱引用，空间不足且满足条件时可以将其释放。</p><p><strong>如何判断Entry的Index</strong><br>使用<code>(threadLocal.threadLocalHashCode &amp; capacity-1)</code>作为entry在数组中存放的地址。<br>这种设计是基于不会发生hash冲突的预期而实现的，数组中一个桶只放一个entry。</p><p><strong>为什么要使用弱引用保存key？</strong><br><code>ThreadLocalMap</code>的生命与<code>Thread</code>一样长，若使用了<code>ThreadLocal</code>作为键保存值而不进行回收，则会造成内存泄漏。</p><p><strong>存在的问题</strong><br>虽然key被设计成弱应用了，可以从某种程度上避免内存泄漏，但是，value仍然是强引用！需要<strong>显式地调用<code>remove</code>方法</strong>。</p><p><strong>为什么value不设置成弱引用</strong><br>因为不清楚这个value是否存在其他引用，如果value是弱引用对象，但存在其他引用，则GC时可能直接将value回收了。但ThreadLocal还在使用期间，导致get获取到null。</p><p><strong>要保证value的生命周期比key的生命周期长。</strong></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第3章（Lock接口）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、CAS"><a href="#一、CAS" class="headerlink" title="一、CAS"></a>一、CAS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>乐观锁的目的就是在不使用锁（悲观锁）的情况下保证线程安全</strong>。<br>乐观锁在 Java 中是采用 CAS 算法实现的，J.U.C 包中的原子类就是通过 CAS 算法来实现了乐观锁。<br>使用这种 CAS 算法的代码也常被称为 <strong>无锁</strong> 编程（Lock-Free）。<br>**现代处理器基本都已经内置了实现 CAS 的指令，比如 x86 指令集上的 <code>CAMPXCHG</code>。<br>当多个线程尝试使用 CAS 同时更新主内存中的同一个变量时，只有一个线程可以成功更新变量的值，其他的线程都会失败，失败的线程并不会挂起，而是会自旋重试。</p><p><strong>CAS</strong>（Compare And Set）的步骤为：</p><ul><li>读取主内存值</li><li>将读取到的值再与主内存值比较</li><li>将新值交换到该变量</li></ul><h2 id="CAS三大问题"><a href="#CAS三大问题" class="headerlink" title="CAS三大问题"></a>CAS三大问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203125031.png"></p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p><strong>在变量值前面追加上版本号，每次变量更新的时候把版本号加 1，那么 A→B→A 就会变成 1A→2B→3A</strong>。<br>从 Java 1.5 开始，JDK 的 Atomic 包里提供了一个类 <code>AtomicStampedReference</code> 来解决 ABA 问题，把变量放在 <code>AtomicStampedReference</code> 类中即可。</p><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h3><p>x86 指令集上使用 CAMPCHG 来实现 CAS 操作，我们在一些源码里看到的 CAS 操作其实都是对这条底层指令的封装罢了，而<strong>这条指令的功能就是一次只原子地修改一个变量</strong>。</p><h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><ol><li>使用锁</li><li>将变量合并，操作后再拆解</li></ol><p>从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，这样我们就可以把多个变量封装在一个对象里来进行 CAS 操作。</p><h3 id="循环时间开销"><a href="#循环时间开销" class="headerlink" title="循环时间开销"></a>循环时间开销</h3><p>失败时一直重试，开销过大，CPU空转</p><h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>使 JVM 支持底层指令 pause，这个指令的功能就是当自旋失败时让 CPU 睡眠一小段时间再继续自旋，其有两个作用：<br>1）降低读操作的频率；<br>2）避免在退出循环的时候因 内存顺序冲突（Memory OrderViolation） 而引起 CPU 流水线被清空（CPU PipelineFlush）。</p><blockquote><p>内存顺序就是CPU访问内存的顺序，持锁线程store后，其他线程load才可以获取锁，但如果重排序，会导致load到的数据无效，此时会清空流水线再重排序，而pause可以减少重排序所耗费的时间。</p></blockquote><h1 id="二、Unsafe与原子类"><a href="#二、Unsafe与原子类" class="headerlink" title="二、Unsafe与原子类"></a>二、Unsafe与原子类</h1><h2 id="Unsafe-类浅析"><a href="#Unsafe-类浅析" class="headerlink" title="Unsafe 类浅析"></a>Unsafe 类浅析</h2><p>Unsafe 类存在于 sun.misc 包中，单从名称看来就可以知道该类是非安全的，因为其内部方法操作可以像 C 的指针一样直接操作内存（全是本地方法）。</p><p>所以事实上 Java 官方也不建议我们直接去使用 Unsafe 类。J.U.C 中 CAS 操作的执行依赖于 Unsafe 类的方法。</p><p>CAS相关方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203125836.png"><br>将参数重命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapXxx</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object expected, Object update)</span><br></code></pre></td></tr></table></figure><ul><li>第一个参数 o 为给定对象，即包含要修改字段的对象</li><li>第二个参数 offset 为对象内存的偏移量，通过这个偏移量可以迅速定位字段并设置或获取该字段的值</li><li>第三个参数 expected 表示期望值</li><li>第四个参数 update 表示要设置的值</li></ul><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>在 Atomic 包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新属性（字段）</li></ul><h3 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h3><ul><li><code>AtomicBoolean</code>：原子更新布尔类型</li><li><code>AtomicInteger</code>：原子更新整型</li><li><code>AtomicLong</code>：原子更新长整型</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203134452.png"><br>常用方法：</p><ul><li><code>addAndGet</code></li><li><code>compareAndSet</code></li><li><code>getAndIncrement</code>、<code>getAndDecrement</code></li><li><code>getAndSet</code></li></ul><p>这些方法底层都是调用Unsafe类的方法进行CAS操作。<br>对于其他基本类型如char，float，double等，会先把其他类信息转换成int&#x2F;long类型再进行操作。</p><h3 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h3><ul><li><code>AtomicIntegerArray</code>：原子更新整型数组里的元素</li><li><code>AtomicLongArray</code>：原子更新长整型数组里的元素</li><li><code>AtomicReferenceArray</code>：原子更新引用类型数组里的元素</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203134948.png"><br>常用方法略，就是多一个数组索引。</p><h3 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h3><ul><li><code>AtomicReference</code>：原子更新引用类型</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li><li><code>AtomicMarkableReference</code>：原子更新带有标记位的引用类型</li></ul><p>构造函数：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203135105.png"><br>基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReference&lt;User&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">16</span>);                <br>reference.set(user1);            <br><br><span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user2&quot;</span>, <span class="hljs-number">18</span>);<br>reference.compareAndSet(user1, user2);<br><br>System.out.println(reference.get().getName()); <span class="hljs-comment">// &quot;user2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原子更新字段"><a href="#原子更新字段" class="headerlink" title="原子更新字段"></a>原子更新字段</h3><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段</li><li>AtomicLongFieldUpdater：原子更新长整型字段</li><li>AtomicStampedReference：原子更新带有版本号的引用类型</li></ul><p>这三个方法不同于前面的简单封装，而是被称为原子更新器，构造函数如下：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203135443.png"><br>即都是通过抽象类的静态方法获取更新器实例，基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="hljs-string">&quot;age&quot;</span>); <span class="hljs-comment">// 原子更新 User 类的 age 字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 旧值是 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> updater.getAndAdd(user, <span class="hljs-number">5</span>); <span class="hljs-comment">// 原子更新为 5</span><br>        System.out.println(oldValue); <span class="hljs-comment">// 1</span><br>        System.out.println(updater.get(user)); <span class="hljs-comment">// 6</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="三、Lock接口"><a href="#三、Lock接口" class="headerlink" title="三、Lock接口"></a>三、Lock接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>为什么需要Lock？</strong></p><ul><li>synchronized锁隐式的限定了锁的获取和释放位置，导致某线程获取锁的顺序总是先获取先释放（栈式），满足不了更多的需要，而lock手动获取释放。</li><li>synchronized只实现了互斥锁，且无法被中断（而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。）</li><li>lock可以选择是否公平</li></ul><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>         <span class="hljs-comment">// 加锁</span><br>reentrantLock.lock();<br>        <br><span class="hljs-comment">// do something ....</span><br>        <br>         <span class="hljs-comment">// 解锁</span><br>        reentrantLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br><br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>lock()：尝试获取锁，获取锁成功后返回</li><li>lockInterruptibly()：可中断的获取锁。所谓可中断的意思就是，在锁的获取过程中可以中断当前线程</li><li>tryLock()：尝试非阻塞的获取锁。不同于 lock() 方法在锁获取成功后再返回，该方法被调用后就会立即返回。如果最终获取锁成功返回 true，否则返回 false</li><li>tryLock(long time, TimeUnit unit)：超时的获取锁。如果在指定时间内未获取到锁，则返回 false</li><li>unlock()：释放锁</li><li>newCondition()：当前线程只有获得了锁，才能调用 Condition 接口的 await 方法。Condition 接口本文就先不做详细赘述了</li></ul><p>Lock是一个<strong>接口</strong>，它规定所有的锁要实现这6个方法(调用层)从而实现锁的功能。</p><h2 id="Lock底层：AQS"><a href="#Lock底层：AQS" class="headerlink" title="Lock底层：AQS"></a>Lock底层：AQS</h2><p>Lock 接口的实现基本都是通过聚合了一个队列同步器（AbstractQueuedSynchronizer，AQS）的<strong>子类</strong>来完成线程访问控制的。<br>比如 ReentrantLock：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203140146.png"><br>而AbstractQueuedSynchronizer：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203140222.png"><br>总结：</p><ul><li><code>Lock</code>的实现类（如<code>ReentrantLock</code>）基本都是通过使用它的一个<code>内部队列</code>（sync）来实现线程的控制访问的。</li><li><code>ReentrantLock</code>有一个内部抽象类<code>Sync</code>，该类继承另一个抽象类<code>AbstractQueuedSynchronizer</code>，并完成部分方法重写。</li><li><code>ReentrantLock</code>还有一些非抽象类，继承<code>Sync</code>，并对其部分方法进行重写，实现不同的队列控制，所谓的内部队列，就是某个非抽象类的实例。</li><li><code>AbstractQueuedSynchronizer</code>被称作同步器，其将一些方法开放给子类写，实现了不同需求的锁控制。</li></ul><h3 id="AQS方法"><a href="#AQS方法" class="headerlink" title="AQS方法"></a>AQS方法</h3><blockquote><p>理解 模板方法设计模式 是理解 AQS 的关键，所谓模板方法可以简单理解为不可被子类重写的方法，模板方法相当于一个骨架，也就是说整体骨架不能被改变，里面具体实现细节可以开放给子类进行重写。</p></blockquote><ul><li>AQS 中的模板方法 <code>acquire()</code>，可以看到被 <code>final</code> 关键字标识了，不可被继承重写。</li><li>但是这个模板方法中调用的 <code>tryAcquire</code> 就是开放给子类进行重写的。</li></ul><blockquote><p>谈谈对AQS的理解：<br>AQS 是一个抽象类，是用来构建锁或者其他同步组件的<strong>基础框架</strong>，它使用了一个 <strong>volaitle 修饰的 int 成员变量 state 表示同步状态</strong>，通过内置的 FIFO 双向队列（源码注释上写的 CLH（Craig，Landin，and Hagersten） 队列（三个人名的简称），其实就是一个先进先出的双向队列）来完成线程们获取资源的时候的排队工作。<br>具体来说，如果某个线程请求锁（共享资源）失败，则该线程就会被加入到 CLH 队列的末端。当持有锁的线程释放锁之后，会唤醒其后继节点，这个后继节点就可以开始尝试获取锁。</p></blockquote><h3 id="成员变量state"><a href="#成员变量state" class="headerlink" title="成员变量state"></a>成员变量state</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>    state = newState;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加锁时，通过CAS，state+1</li><li>释放时，通过CAS，state-1</li></ul><h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><h4 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h4><p><code>addWaiter</code>，通过CAS创建一个node并添加到队列尾部。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203143108.png"><br>这里注意有一个添加Waiter时还需要指定一个Node对象<code>mode</code>，这是Node类的静态字段，主要其标记作用，用来指定是共享锁还是排他锁（可以看后面的Node节点中源码和AQS两套模式）。</p><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142026.png"><br>首节点的线程 A 在释放同步资源时，将会唤醒器其后继节点 B，而后继节点 B 被唤醒后，就会重新尝试加锁，同样还是 CAS 操作给 state 变量加 1，如果成功，就<strong>将自己CAS设置为首节点</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142115.png"></p><p>设置首节点是不需要CAS的，因为当线程能否设置首节点时，说明已经获取到了同步资源，只有一个线程能做到（只有一个线程可以将state状态从0 CAS到 1）。</p><h4 id="enq方法"><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h4><p>addWaiter方法中调用了enq方法，这个方法通过死循环的方式使用CAS将节点设置成尾节点，即enq方法将<strong>并发添加节点的请求变成“串行化”了</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203142655.png"></p><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();  <br><span class="hljs-comment">/** Marker to indicate a node is waiting in exclusive mode */</span>  <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br><br>    <span class="hljs-keyword">volatile</span> Node prev; <span class="hljs-comment">// 前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node next; <span class="hljs-comment">// 后继节点</span><br><br>    <span class="hljs-keyword">volatile</span> Thread thread; <span class="hljs-comment">// 当前线程的引用</span><br><br>    Node nextWaiter; <span class="hljs-comment">//标记节点是共享锁还是排他锁</span><br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head; <span class="hljs-comment">// 头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail; <span class="hljs-comment">// 最后一个节点</span><br></code></pre></td></tr></table></figure><p>每个Node拥有其<strong>线程的引用</strong>和一个<strong>状态</strong>，主要关注下面两个状态：</p><ul><li><code>CANCELLED</code>：表示取消状态，就是说我不要这个锁了，请你把我从队列中移出去。</li><li><code>SINGAL</code>：表示<strong>当前节点的后继节点</strong>正在等待，注意是后继节点，不是当前节点。</li></ul><h3 id="AQS两套模式"><a href="#AQS两套模式" class="headerlink" title="AQS两套模式"></a>AQS两套模式</h3><p>AQS的模板方法有：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203143651.png"><br>主要分三类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>独占Exclusive（排它锁模式）和共享 Share（共享锁模式）就是 AQS 提供的两种模式。事实上，在 AQS 的所有子类中，只会使用这两种模式的其中之一，要么实现并使用了独占锁的 API，要么使用了共享锁的 API，<strong>不会一个子类同时使用两套不同的模式。</strong><br>独占锁与共享锁在创建自己的节点时（<code>addWaiter</code> 方法）会通过 <code>nextWaiter</code> 变量来表明身份。</p><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="锁获取"><a href="#锁获取" class="headerlink" title="锁获取"></a>锁获取</h5><p>独占锁就是在同一时刻只能有一个线程获取到锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="hljs-comment">// 此方法会尝试去获取锁</span><br>        <span class="hljs-comment">// 将当前线程加入 CLH 队列中，这里可见添加了独占节点</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>tryAcquire是开放给子类重写的，所以子类可以自定义这个方法是否实现公平竞争。即共享&#x2F;排他是AQS内部实现的，公平&#x2F;非公平是子类实现的。</p>          </div><p>acquireQueued方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 当前节点的前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果当前节点的前驱节点是头节点并且成功获取锁，则当前线程获取到独占锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 获取独占锁失败，则当前线程进入等待态</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意三点：<br>1)<code>if (p == head &amp;&amp; tryAcquire(arg))</code><br>如果当前节点的前驱节点是<strong>头节点</strong>并且成功获取锁，则当前线程获取到独占锁。<br>此时当前节点被称为<strong>首节点</strong>（与头节点做区分）。</p><p>2）<code>for(;;)</code><br>会通过死循环（<strong>自旋</strong>）获取锁，如果失败了就阻塞该线程，直到被唤醒。</p><p>3）<code>setHead(node)</code><br>将当前节点作为头节点</p><div class="note note-danger">            <p>重点解释一下，如果某个线程节点是<strong>头节点</strong>，意味着该线程可能<br>1.持有锁<br>2.之前持有锁，但已经释放了（该节点此时是空节点）</p><p>释放节点的时候，并不会像链表一样由头节点线程操作链表将自己弹出，而是释放锁（state &#x3D; 0），然后唤醒后继节点，后继节点发现自己已经是头节点的后继节点，且成功的获取同步（state &#x3D; 1），则将之前的头节点弹出，自己做新的头节点。</p>          </div><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203144926.png"></p><div class="note note-primary">            <ol><li>先看能否直接获取同步状态，有则直接获取return</li><li>若不能，则说明其他线程持有锁</li><li>在通过CAS添加节点的时候，再对前驱节点做一次判断，因为此时锁可能已经被释放，若前驱节点为头节点，则尝试获取同步状态，成功则return</li><li>若前驱节点不是头节点，或前驱节点是头节点，但同步状态获取失败，则线程进入等待状态park(waitStatus变成)。</li></ol>          </div><h5 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unparkSuccessor</code>用于CAS操作唤醒头节点的后继节点：</p><ul><li>改变头节点的waitStatus</li><li>校验后续节点的waitStatus查看是否已经放弃</li><li>若通过了则唤醒后继节点</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>在获取同步状态（锁）时，AQS 维护一个 CLH 双向队列，获取锁失败的线程都会通过 CAS 操作被加入到队列尾端，并且在队列中<strong>尝试获取锁，失败则中断，等待唤醒再循环获取过程</strong>；</li><li>停止自旋（或者说被移除 CLH 队列）的条件是其<strong>前驱节点为头节点并且成功获取了独占锁</strong>；</li><li>当前节点（线程）成功释放掉独占锁后，AQS 就会紧接着<strong>唤醒该节点的后继节点</strong>，这样，这个后继节点又会开始去尝试获取锁。循此往复。</li></ul><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="锁获取-1"><a href="#锁获取-1" class="headerlink" title="锁获取"></a>锁获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取失败则执行<code>doAcquireShared</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样会无限自旋直到获取锁：</p><ul><li>头节点的后继节点</li><li>成功获取锁，即拿到需要的资源量arg</li></ul><p><code>setHeadAndPropagate</code>：自己拿到资源后，如果条件满足还会唤醒后继节点，因为这里是共享模式。</p><h5 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>doReleaseShared</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>独占锁的释放直接就调用了 unparkSuccessor 方法唤醒后继节点，而共享锁这里，在 unparkSuccessor 之前还加了一个循环和 CAS 的操作来确保共享锁成功释放，因为可能同时存在多个线程释放锁（共享）。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>共享锁与排他锁方法的区别：<br>这里的共享模式不同于读写锁，而是一种资源限制策略，一次只允许若干线程获取锁资源，前面的线程在释放锁之后，后面的线程就可以使用该线程释放的资源。</p><blockquote><ul><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul></blockquote><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><strong>重入锁</strong>，是Lock接口的实现，聚合了AQS。</p><h3 id="重入锁原理"><a href="#重入锁原理" class="headerlink" title="重入锁原理"></a>重入锁原理</h3><h4 id="锁获取-2"><a href="#锁获取-2" class="headerlink" title="锁获取"></a>锁获取</h4><p>对于公平锁和非公平锁来说，它们获取锁的方式是不同的。</p><blockquote><p>ReentrantLock 的 tryLock 方法调用的也就是非公平锁的方法，也就是说，即使该锁是公平锁，使用 tryLock() 方法的话也会使用非公平的方式去获取锁。</p></blockquote><p>这里以获取非公平锁为例：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203163610.png"><br>该方法只定义如何获取锁，失败后策略在AQS中已经实现：</p><ul><li>若锁不被占有则获取return true</li><li>若被占有则检查持有者是否为本线程，是则获取+1，return true</li><li>否则return false</li></ul><h4 id="锁释放-2"><a href="#锁释放-2" class="headerlink" title="锁释放"></a>锁释放</h4><p>通过CAS令state–，如果state &#x3D; 0，则释放锁。</p><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>红线表示内部类，蓝线表示继承，绿色虚线表示实现接口：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164710.png"><br>ReentrantLock 的无参构造使用的就是非公平锁：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164756.png"><br>当然也可以传入一个 boolean 值，true 时为公平锁，false 时为非公平锁：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164805.png"><br>重写方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203164823.png"><br>都只重写了加锁方法，公平锁和非公平锁的释放方法相同。</p><p>调用链：<br>ReentrantLock.lock -&gt; Sync.lock -&gt; NonfairSync&#x2F;FairSync.lock -&gt; AQS.acquire -&gt; NonfairSync&#x2F;FairSync.tryAcquire()</p><ul><li>lock是根据具体实现决定执行方式</li><li>tryLock永远通过非公平方式，所以其实现放在了Sync中</li></ul><h4 id="底层区别"><a href="#底层区别" class="headerlink" title="底层区别"></a>底层区别</h4><p>公平锁的 <code>tryAcquire</code> 方法：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203165544.png"><br>公平锁多了<code>hasQueuedPredecessors</code>，快速判断当前节点是否有前驱节点。</p><ul><li>公平锁：先判断队列，再尝试CAS操作state</li><li>非公平锁：先CAS，失败再看队列，对于非公平锁，可能存在一个线程刚被唤醒与另一个外部线程同时尝试CAS。</li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>非公平锁的效率最高，所以<code>tryLock</code>的默认实现是非公平的。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>读写锁中的读锁和写锁也都是<strong>可重入</strong>的。通过分离读锁和写锁，使得读写锁的并发性能相比一般的排他锁有了很大提升。</p><h3 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170043.png"><br>这个接口只有两个方法，<code>readLock</code> 用来获取读锁，<code>writeLock</code> 用来获取写锁。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>ReentrantReadWriteLock</li><li>StampedLock，是对前者的增强</li></ul><h3 id="ReentrantReadWriteLock-1"><a href="#ReentrantReadWriteLock-1" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170223.png"><br>读写锁拥有读锁和写锁两个实体。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;    <br>    <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();  <br>    <span class="hljs-comment">// 读写锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();    <br>    <span class="hljs-comment">// 读锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> rwl.readLock();    <br>    <span class="hljs-comment">// 写锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> rwl.writeLock();    <br>    <span class="hljs-comment">// 获取一个 key 对应的 value    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String key)</span> &#123; <br>        <span class="hljs-comment">// 加读锁</span><br>        readLock.lock();            <br>        <span class="hljs-keyword">try</span> &#123;                    <br>            <span class="hljs-keyword">return</span> map.get(key);            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放读锁</span><br>            readLock.unlock();            <br>        &#125;    <br>    &#125;    <br>    <span class="hljs-comment">// 设置 key 对应的 value，并返回旧的 value    </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">put</span><span class="hljs-params">(String key, Object value)</span> &#123;    <br>        <span class="hljs-comment">// 加写锁</span><br>        writeLock.lock();            <br>        <span class="hljs-keyword">try</span> &#123;                    <br>            <span class="hljs-keyword">return</span> map.put(key, value);            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放写锁</span><br>            writeLock.unlock();            <br>        &#125;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果不使用读写锁，就需要使用java的等待通知机制（wait,notify）。使用读写锁比等待通知方式简单的多。</p></blockquote><h4 id="ReentrantWriteLock"><a href="#ReentrantWriteLock" class="headerlink" title="ReentrantWriteLock"></a>ReentrantWriteLock</h4><p>使用一个state同时维护读、写状态，将 32 位的整型变量 state 切分成两个部分，高 16 位表示读，低 16 位表示写：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203170539.png"><br>通过位运算即可获取、修改状态。</p><h5 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h5><ul><li>如果当前有锁（state !&#x3D; 0）<ul><li>如果读锁（高16位）已经被获取过，则无法获取写锁。</li><li>如果没有读锁（高16位），且写锁持有者是自己，则可以重入。</li></ul></li><li>如果没锁<ul><li>尝试CAS获取</li></ul></li></ul><h5 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h5><ul><li>如果当前线程持有写锁，可重入</li><li>如果当前线程没有写锁<ul><li>如果其他线程有写锁，失败</li><li>如果其他线程没有写锁，查看本线程是否有读锁<ul><li>有则state++</li><li>没有则CAS获取</li></ul></li></ul></li></ul><p><strong>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在 <code>ThreadLocal</code> 中，由每个线程自己来维护</strong>，这使获取读锁的实现变得复杂。</p><h5 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h5><p>读写锁中的锁降级指的是，<strong>写锁降级成为读锁</strong>。<br>把持住当前线程所拥有的写锁，然后获取到读锁，随后释放先前拥有的写锁。</p><p>主要应用在于：<br>某线程的加锁写操作对其后续的读操作必然是<strong>可见</strong>的，中间不会被其他线程修改。</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>Lock中，通过Condition中实现等待通知功能。<br>lock有一个方法是<code>newCondition()</code>，其可以生成一个Condition对象并返回。</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><code>Condition</code>接口的实现类为<code>ConditionObject</code>，其存在于AQS内部。</p><p>Condition也是通过队列的方式实现阻塞和唤醒的，与AQS中的CLH不同在于，Condition队列叫做<strong>等待队列</strong>，CLH队列叫做<strong>同步队列</strong>。</p><p>Condition等待队列是一个FIFO的<strong>单向队列</strong>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203172742.png"></p><p><strong>一个 Lock 对象可以拥有一个同步队列和多个等待队列</strong>：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203172822.png"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>当前线程调用<code>Condition.await()</code> 方法，<strong>将会以当前线程构造节点，并将节点从尾部加入等待队列。</strong></p><p>不同于 CLH 同步队列在尾部添加节点时需要使用 CAS 操作，<strong>Condition 等待队列不需要 CAS 的保证</strong>，因为调用 <code>await</code> 方法的线程必定是获取了 Lock的线程，不会有其他线程来争夺这个添加尾部节点的操作。<br>从逻辑上看，这与设置头节点不需要CAS相同。<br>从语义上看，这与<code>wait()</code>方法只在<code>synchronized</code>块中调用相同。</p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p><strong>将 Condition 等待队列的首节点移动到 CLH 同步队列的尾部</strong><br>同样，<code>signal</code> 这个方法，一定是当前占据锁的线程调用的。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC3%E7%AB%A0%EF%BC%88Lock%E6%8E%A5%E5%8F%A3%EF%BC%89/Pasted-image-20230203173352.png"></p><h4 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h4><p>将等待队列中所有节点全部移动到同步队列中。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第2章（三大关键字）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1）根据线程要不要锁住共享资源，可以分为：</p><ul><li>悲观锁：锁住共享资源</li><li>乐观锁：不锁住共享资源</li></ul><p>2）如果试图锁住共享资源失败，那么线程要不要阻塞？如果不想要阻塞线程，可以通过以下两种锁实现：</p><ul><li>自旋锁</li><li>适应性自旋锁</li></ul><p>3）根据多个线程竞争锁时是否需要排队，可以分为：</p><ul><li>公平锁：需要排队</li><li>非公平锁：先尝试插队，插队失败再排队</li></ul><p>4）根据一个线程是否能够重复获取同一把锁，可以分为：</p><ul><li>可重入锁：能被同一个线程重复获取</li><li>不可重入锁：不能被同一个线程重复获取</li></ul><p>5）根据锁只能被单个线程持有还是能被多个线程共同持有，可以分为：</p><ul><li>排他锁：锁只能被单个线程持有</li><li>共享锁：锁能被多个线程共同持有</li></ul><p>6）以下这 4 种锁都是专门针对 synchronized 关键字的，是上面介绍的锁的组合实现：</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><h2 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁 | 乐观锁"></a>悲观锁 | 乐观锁</h2><blockquote><p><strong>悲观锁是一种悲观思想</strong>，认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>乐观锁是一种乐观思想</strong>，认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在提交修改的时候去判断一下，在此之前有没有其他的线程也修改了这个数据：</p><ul><li>如果其他的线程还没有提交修改，那么当前线程就将自己修改的数据成功写入；</li><li>如果其他的线程已经提交了修改，则当前线程会根据不同的实现方式执行不同的操作（例如报错或者自动重试）</li></ul></blockquote><p>乐观锁的算法是CAS算法实现的，这种算法一般也被称为无锁编程（Lock-Free），这是一种算法思想。</p><p><strong>两者判断是否能拥有锁的时点不一样（先判断；先操作然后在提交时判断），判断的方式不一样（直接判断是否能获取；CAS算法）。</strong></p><div class="note note-primary">            <p>实用区别：</p><ul><li>悲观锁一般性能差，但修改量太大的话性能会好。</li><li>乐观锁一般性能好，但一直失败的话不如悲观，防止空转。<br>实现：</li><li><code>synchronized</code>和<code>Lock接口</code>的实现类都是悲观锁</li><li><code>JUC</code>的原子类是乐观锁。</li></ul>          </div><h2 id="自旋锁-自旋适应锁"><a href="#自旋锁-自旋适应锁" class="headerlink" title="自旋锁 | 自旋适应锁"></a>自旋锁 | 自旋适应锁</h2><blockquote><p><strong>自旋锁</strong>就是“稍等一下”，其实就是个 do-while 循环。更底层来说自旋操作就是<strong>空转 CPU</strong>，执行一些无意义的指令，目的就是不让出 CPU 等待锁的释放。如果这个线程自旋完成后，前面锁定共享资源的线程已经释放了锁，那么这个线程就可以不必被阻塞而是直接获取共享资源，从而<strong>避免切换操作系统状态的开销</strong>。</p><p><strong>自旋适应锁</strong>：如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源，空转，死等，还不如被阻塞住。自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。默认是 10 次，可以使用参数<code>-XX:PreBlockSpin</code>来更改。而在 JDK 1.6 中，对于自选等待的次数这个问题，做出了一次优化，即引入了<strong>适应性自旋锁</strong>（自适应的自旋锁）。</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么 JVM 就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；</li><li>如果对于某个锁，很少有线程通过自旋等待成功获得过，那么当以后有线程尝试获取这个锁时， JVM 可能省略掉自旋过程，直接阻塞住线程，避免空转浪费处理器资源。</li></ul></blockquote><p><strong>两者是判断当获取锁失败时策略，是直接阻塞还是稍作等待（实现是CAS算法）,并规定稍作等待的时长。</strong></p><div class="note note-primary">            <p>实用性：</p><ul><li>避免阻塞，阻塞后唤醒需要切换到内核态，对系统性能消耗大。<br>实现：</li><li>JUC的原子类是自旋锁，这也是一种乐观锁，可以说自旋锁的原理就是CAS算法。<br>乐观锁与自旋锁，CAS算法的关系：</li><li>CAS是一种实现自旋的算法</li><li>乐观锁和自旋锁都是期待可以获取同步资源并执行，因此在实现上总是同时出现，一个定义如何获取，一个定义失败行为。</li></ul>          </div><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 | 非公平锁"></a>公平锁 | 非公平锁</h2><blockquote><p><strong>公平锁</strong>：多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果该锁的等待队列为空，则直接占有锁；如果该锁的等待队列不为空，则该线程加入到等待队列的末尾，按照 FIFO 的原则从队列中取出线程，然后占有锁。</p><p><strong>非公平锁</strong>：线程会先尝试获取锁，如果获取不到，则再采用公平锁的方式也就是进入等待队列。也就是说，多个线程获取锁的顺序，不是按照 FIFO 的顺序，有可能后申请锁的线程比先申请的线程优先获取到锁。</p></blockquote><p>从源码上看，唯一区别就是公平锁在获取锁前多一个判断条件：<code>hasQueuedPredecessors</code>判断当前线程是否是等待队列中的第一个。</p><p><strong>两者决定多线程争夺时锁的归属策略</strong></p><div class="note note-primary">            <p>实用性：</p><ul><li>根据不同场景需要使用不同策略。</li><li>公平锁效率低，频繁阻塞造成进入内核态的开销。</li><li>非公平锁效率高，但可能饿死线程。</li></ul><p>实现：</p><ul><li>synchronized是非公平的</li><li>Lock接口的实现类ReentrantLock可以指定是否公平（默认非公平）。</li></ul>          </div><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 | 不可重入锁"></a>可重入锁 | 不可重入锁</h2><blockquote><p><strong>可重入锁</strong>：也称为递归锁，同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。</p><p><strong>不可重入锁</strong>：同一个线程不能获得同一个对象的锁两次。</p></blockquote><p>原理：如ReentrantLock，通过判断state字段，若为0则直接占用锁，不为0则判断主人是不是自己，若是，则锁上加一个记号。</p><p><strong>决定其在被一个线程重复获取时是否成功</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>防止同一个线程获取同一个锁失败<br>实现：</li><li>synchronized，ReentrantLock都是可重入锁。</li></ul>          </div><h2 id="共享锁-排他锁"><a href="#共享锁-排他锁" class="headerlink" title="共享锁 | 排他锁"></a>共享锁 | 排他锁</h2><blockquote><p><strong>共享锁</strong>：该锁可被多个线程所持有。如果线程 A 对数据 B 加上共享锁后，则其他线程只能对 B 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p><strong>排他锁</strong>：也称互斥锁、独享锁，该锁一次只能被一个线程所持有。如果线程 A 对数据 B 加上排它锁后，则其他线程不能再对 B 加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</p></blockquote><p>排他锁是一种悲观锁，共享锁是一种乐观锁。</p><p><strong>决定锁是否私有</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>根据场景，保证性能、准确性。<br>实现：</li><li>排他锁：synchronized 和 ReentrantLock、ReentrantReadWriteLock中的写锁。</li><li>共享锁：ReentrantReadWriteLock中的读锁。</li></ul>          </div><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 | 偏向锁 | 轻量级锁 | 重量级锁"></a>无锁 | 偏向锁 | 轻量级锁 | 重量级锁</h2><blockquote><p><strong>无锁（Lock-Free）</strong>,具体指的是没有使用悲观锁，如使用CAS算法的JUC原子类。</p><p><strong>偏向锁</strong>，锁会偏向于第一个获得它的<strong>线程</strong>，接下来如果没有其他线程竞争该锁，则该线程不需要进行CAS操作。偏向锁使用了一种<strong>等到竞争出现才释放锁</strong>的机制。</p><p><strong>轻量级锁</strong>，偏向锁时出现两个线程交替竞争则变成轻量级锁。（不会自旋）</p><p><strong>重量级锁</strong>，升级成重量级锁之后，线程如果没有争抢到锁，会进行一段自旋等待锁的释放。那么上文说过，自旋等待是需要有一定限度的，如果自旋等待超过了一定的次数（时间），那么这个线程就要被阻塞住了。因为涉及到操作系统所以重量。</p></blockquote><p>抛开无锁这个状态不谈，Java 中的<code>synchronized</code>有偏向锁、轻量级锁、重量级锁，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁就会按照顺序进行升级。</p><p>一般认为，<strong>锁只能升级不能降级</strong>，但实际上是有降级的，不过条件苛刻，可以忽略。</p><p><strong>定义了synchronized的状态，决定其在被一个或多个线程争夺时的线程的获取锁策略</strong></p><div class="note note-primary">            <p>实用：</p><ul><li>无锁，写操作比较少时使用，使用CAS算法实现，效率高。</li><li>偏向锁，只有一个线程获取该锁时的策略，不会频繁的释放锁。</li><li>轻量级锁，两个线程交替拥有锁，但无实际竞争避免阻塞（<strong>信号量</strong>），像一个过渡状态，一旦竞争就变成重量级。</li><li>重量级锁，短暂自旋后会阻塞，安全性能好。<br>实现：</li><li><code>synchronized</code></li></ul>          </div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>悲|乐观锁决定线程获取锁的行为时点和方式（先获取|先操作再校验）</li><li>自旋锁决定获取锁失败后的行为（阻塞|等待）</li><li>公平锁|非公平锁决定多线程竞争时的优先级（顺序|插队）</li><li>可重入锁|不可重入锁决定单线程能否重复获取锁</li><li>共享锁|排他锁决定锁能否被多个线程共有（读锁|写锁）</li></ol><p>无锁|偏向锁|轻量级锁|重量级锁是锁的状态，其是针对synchronized具体实现的分类，其他锁指的是思想。</p><div class="note note-primary">            <ul><li>synchronized 关键词是悲观锁、排他锁、可重入锁、(某些状态下可自旋)、非公平锁。</li><li>Lock接口的实现是悲观锁、可重入锁<ul><li>ReentrantLock是排他锁、有公平和非公平两种实现。</li><li>ReentrantReadWriteLock读锁是共享的，写锁是排他的。</li></ul></li><li>JUC原子类是乐观锁，自旋锁（可以认为，自旋操作的实现就是CAS，但乐观锁的实现不只CAS）。</li></ul>          </div><h1 id="二、synchronized关键字"><a href="#二、synchronized关键字" class="headerlink" title="二、synchronized关键字"></a>二、synchronized关键字</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1）对于普通同步方法（synchronized 修饰的普通方法），锁是<strong>当前实例对象</strong>。<br>2）对于静态同步方法（synchronized 修饰的静态方法），锁是<strong>当前类的 Class 对象</strong>。<br>3）对于同步方法块（synchronized 修饰的块），锁是<strong>Synchonized括号里配置的对象</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>monitorenter 和 monitorexit 来隐式地使用这两个操作。</p><h3 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h3><p>所有 Lock 实现都必须强制执行与内置监视器锁 synchronization 提供的相同的内存同步语义。<br>1）锁释放的内存语义：<strong>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong><br>2）锁获取的内存语义：<strong>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被锁保护的临界区代码必须从主内存中读取共享变量。</strong></p><blockquote><p>线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了消息，比如说告知对方我对某个共享变量做了修改；<br>线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的消息，比如说接收了线程 A 在释放这个锁之前对共享变量所做的修改；</p></blockquote><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="字节码层面"><a href="#字节码层面" class="headerlink" title="字节码层面"></a>字节码层面</h3><ol><li>普通同步方法：加上<code>ACC_SYNCHRONIZED</code>标识</li><li>静态同步方法：加上<code>ACC_SYNCHRONIZED</code>标识</li><li>同步方法块：方法的code属性中，多了<code>monitorenter</code>和<code>monitorexit</code>字节码。</li></ol><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="Monitor介绍"><a href="#Monitor介绍" class="headerlink" title="Monitor介绍"></a>Monitor介绍</h4><p>任何一个对象都与一个监视器（monitor）对象相关联。当一个监视器有拥有者（owner）的时候，这个监视器就会被锁定（locked）。</p><p>每个监视器都维护着一个自己被持有次数（或者说被锁住 locked）的计数器（count），具体如下：</p><ul><li>如果与对象关联的监视器的计数器为零，则线程进入监视器成为该监视器的拥有者，并将计数器设置为 1。</li><li>当同一个线程再次进入该对象的监视器的时候，计数器会再次自增</li><li>当其他线程想获得该对象关联的监视器的时候，就会被阻塞住，直到该监视器的计数器为 0 才会再次尝试获得其所有权。</li><li>因为计数器和owner的存在，被 <code>synchronized</code> 修饰的同步方法块对同一条线程来说是<strong>可重入</strong>的。所谓可重入就是说即使同一个线程反复进入一个同步方法块也不会出现自己把自己锁死的情况。</li></ul><div class="note note-primary">            <p>可见synchronized也是通过<strong>计数器信号量</strong>快速判断能否获取和重入次数的。</p>          </div><h4 id="ACC-SYNCHRONIZED"><a href="#ACC-SYNCHRONIZED" class="headerlink" title="ACC_SYNCHRONIZED"></a>ACC_SYNCHRONIZED</h4><p>方法级别的同步是隐式执行的，调用方法时，线程会进入对应对象的监视器，然后执行方法。<strong>在执行线程拥有监视器期间，没有其他线程可以进入这个方法</strong>。<br>另外，如果在调用同步方法过程中抛出异常并且同步方法没有处理该异常，则在异常重新抛出同步方法之前，该方法的监视器会自动退出。</p><h4 id="monitorenter、monitorexit"><a href="#monitorenter、monitorexit" class="headerlink" title="monitorenter、monitorexit"></a>monitorenter、monitorexit</h4><p>同步代码块是显示执行的。</p><h4 id="Monitor详解"><a href="#Monitor详解" class="headerlink" title="Monitor详解"></a>Monitor详解</h4><p>常见的进程同步与互斥机制是<strong>信号量</strong>和<strong>管程</strong>。</p><p>相比起信号量，管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。也就是说管程天生支持进程互斥。（排他锁）</p><p>Java中<strong>管程</strong>（monitor）的具体实现是<code>ObjectMonitor</code> 类。这是一个C++实现的类。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202192413.png"><br>补充：</p><ul><li>monitor还持有计数器count</li><li>WAITING列表中保存着：<strong>获得过锁但使用wait()方法等方式放弃锁的线程</strong>，它们等待被唤醒后进入RUNNABLE状态，此时无法获取锁则BLOCKED。</li></ul><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。<br>针对普通对象和数组对象：</p><ul><li>如果对象是数组类型，则虚拟机用3个字宽（Word，在32位系统中，一个word占4字节，32bit）存储对象头（Mard Word、类型指针、数组长度）</li><li>如果对象是非数组类型，则用2字宽存储对象头（Mard Word、类型指针）。</li></ul><p>在32位虚拟机中，1字宽等于4字节，即32bit，如表所示：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64 bit</td><td>Mark Word</td><td>存储对象的 hashCode 和锁信息等</td></tr><tr><td>32&#x2F;64 bit</td><td>Class Metadata（类型指针）</td><td>对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例</td></tr><tr><td>32&#x2F;64 bit</td><td>Array Length（数组长度）</td><td>数组的长度</td></tr></tbody></table><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202231421.png"><br>其中MarkWord部分是对象与monitor关联的重点，其有多种状态：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232949.png"><br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232952.png"></p><p>在64位下，MarkWord是64bit大小的，hashCode变成了31bit，原先的25bit则空了出来，且新增了1bit字段cms_free（CMS回收器GC时使用）<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202232955.png"></p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>JDK1.6前，<strong>synchronized在1.6之前是一个重量级锁</strong>。</li><li>JDK1.6后，出现了各种锁优化技术，如自旋转，轻量级锁，锁消除和锁粗化等。</li></ul><h3 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h3><p><strong>自旋锁可以使线程免于阻塞但并不能代替阻塞</strong>，等待的时间必须有一定的限度，默认自旋等待次数是 10 次，用户也可以使用参数 <code>-XX：PreBlockSpin</code> 来自行更改，而在 JDK 1.6 中，对于自旋等待的次数这个问题，做出了一次优化，即引入了<strong>适应性自旋</strong>（也称为自旋适应锁）：</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么 JVM 就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间；</li><li>如果对于某个锁，很少有线程通过自旋等待成功获得过，那么当以后有线程尝试获取这个锁时， JVM 可能省略掉自旋过程，直接阻塞住线程，避免空转浪费处理器资源。</li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能再降级回偏向锁（其实可以，要求很严格）</strong>。<br>Mark Word内容：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202233831.png"><br>初始状态和偏向锁下锁的标志位是<code>01</code>，轻量锁为<code>00</code>，重量锁为<code>10</code>，GC标记为<code>11</code>。<strong>01 -&gt; 00 -&gt; 10 -&gt; 11</strong></p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>1）<strong>检查Mark Word初始状态</strong>：需要保证对象无锁，即锁标志位为<code>01</code>，偏向锁标志位为<code>0</code>。<br>2）<strong>在当前线程的栈帧上建立锁记录</strong>：java虚拟机会将当前线程的<strong>栈帧</strong>中建立一个名为<strong>锁记录</strong>（Lock Record）的空间，Lock Record 中有一个字段 displaced_header，用于后续存储锁对象的 Mark Word 的拷贝。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202234727.png"><br>3）<strong>复制锁对象的 Mark Word 到锁记录中</strong>：把锁对象的 Mark Word 复制到锁记录中，更具体来讲，是将 Mark Word 放到锁记录的 <code>displaced_header</code>属性中。官方给这个复制过来的记录起名 <code>Displaced Mark Word</code>。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202234855.png"><br>4）使用 <strong>CAS 操作更新锁对象的 Mark Word</strong>。Java 虚拟机使用 CAS 操作尝试把锁对象的 Mark Word 更新为指向锁记录的指针，并将锁记录里的 owner 指针指向对象的 Mark Word。</p><ul><li>如果这个更新操作成功了，就表明获取轻量级锁成功，也就是说该线程拥有了这个对象的锁！并且该对象 Mark Word 的锁标志位会被改为 00，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，那有两种可能性：<ul><li>当前线程已经拥有了这个对象锁（直接进入同步块继续执行）</li><li>存在其他的线程竞争获取这个对象锁（膨胀成重量级锁，锁标志的状态值变为 10，Mark Word 中存储的就是指向重量级锁（互斥量）的指针）</li></ul></li></ul><h5 id="当前线程已经拥有该锁"><a href="#当前线程已经拥有该锁" class="headerlink" title="当前线程已经拥有该锁"></a>当前线程已经拥有该锁</h5><p>虚拟机首先会检查该对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行（synchronized 是可重入锁）。</p><p>假设锁的状态是轻量级锁，下图反应了对象的 Mark word 和线程栈中锁记录的状态，可以看到左边线程栈中包含3个指向当前锁对象的 Lock Record。其中栈中最高位的锁记录为第一次获取轻量级锁时分配的，其 Displaced Mark word 的值为锁对象 obj 加锁之前的 Mark word，之后的每次锁重入都会在线程栈中分配一个 Displaced Mark word 为 <code>null</code>的锁记录。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230202235425.png"></p><blockquote><p>为什么 synchronized 重入的时候 Java 虚拟机要在线程栈中添加 Displaced Mark word 为 null 的锁记录呢？</p><ul><li>首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，只有解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁的重入次数。</li><li>最简单的记录锁重入次数的方案就是将其记录在对象头的 Mark word 中，但 Mark word 大小有限，没有多出来的地方存放该信息了。</li><li>另一个方案就是在锁纪录中记录重入次数，但这样做的话，每次重入获得锁的时候都需要遍历该线程的栈找到对应的锁纪录，然后去修改重入次数的值，显然这样效率不是很高。</li></ul><p>所以最终 Hotspot 选择了每次重入获得锁都添加一个锁记录来表示锁的重入，这样有几个 Displaced Mark word 为 null 的锁记录就表示发生了几次锁重入，非常简单。</p></blockquote><h5 id="存在其他线程竞争该锁"><a href="#存在其他线程竞争该锁" class="headerlink" title="存在其他线程竞争该锁"></a>存在其他线程竞争该锁</h5><p><strong>轻量级锁 CAS 失败并不会自旋而是直接膨胀成重量级锁</strong>。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁的时候 Java 虚拟机会用 CAS 操作把对象当前的 Mark Word 和线程中复制的 Displaced Mark Word 替换回来：</p><ul><li>如果替换成功，那整个同步过程就顺利完成了</li><li>如果替换失败，则说明有其他线程尝试过获取该锁，轻量级锁会先膨胀成重量级锁然后再解锁（调用重量级锁的 exit 方法）</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>synchronized关键字会尝试加锁：将<strong>锁对象的对象头</strong>中的<strong>mark word</strong>(包括hashCode,age,lock信息)复制到<strong>当前线程的栈帧</strong>当中，叫做<strong>displaced mark word</strong>。然后尝试通过<strong>CAS</strong>算法替换<strong>对象头的markword</strong>为指向栈帧中<strong>displaced mark word</strong>的指针，并将栈帧中的<strong>owner</strong>指向对象。</p><ul><li>若当前对象的mark word没有被替换过，替换成功，获得锁。</li><li>若当前对象的mark word被替换过，考虑：<ul><li>之前是被本线程替换的，经过检查后，会再到本线程的栈帧中插入新的lock record(displaced header和owner的集合)，其中header为空，owner与之前的一样</li><li>若是其他线程的竞争，则膨胀成重量级锁。获取该重量级锁时会进行失败自旋。</li></ul></li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢</strong>。但大多数情况下无竞争，为了避免CAS的开销，引入了偏向锁。</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>1）查看对象头的 Mark Word 中偏向锁的标识以及锁标志位，若<strong>偏向锁</strong>标识为1 且 <strong>锁标志位</strong> 为 01，则该锁为<strong>可偏向状态</strong>；<br>2）若为可偏向状态，则测试 Mark Word 中的线程 ID 是否与当前线程相同，若相同，则不用执行 CAS 操作，直接进入同步块执行，否则进入下一步。<br>3）当前线程通过 CAS 操作竞争锁，若竞争成功，则使用 CAS 操作将 Mark Word 中线程 ID 设置为当前线程 ID（重新偏向），然后执行同步块；若竞争失败，则进入偏向锁撤销的流程。</p><p>轻量级锁重入：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000535.png"><br>偏向锁重入：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000550.png"></p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>偏向锁的撤销采用了 <strong>一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争</strong>。</p><p>如果当前线程通过 CAS 竞争偏向锁失败，说明存在锁竞争，则进入偏向锁撤销的流程，偏向锁的撤销需要等待 全局安全点 safe point（这个时间点上没有正在执行的代码），其具体步骤如下：<br>1）JVM 会先暂停拥有偏向锁的线程，判断持有偏向锁的线程是否还存活；<br>2）根据判断结果执行</p><ul><li>如果持有偏向锁的线程存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到轻量级锁竞争的逻辑里。</li><li>如果持有偏向锁的线程已经不存活或者不在同步块中，则将对象头的 Mark Word 改为无锁状态（01），以允许其他线程竞争锁，之后再升级为轻量级锁；<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203000458.png"></li></ul><h4 id="批量重偏向和批量撤销"><a href="#批量重偏向和批量撤销" class="headerlink" title="批量重偏向和批量撤销"></a>批量重偏向和批量撤销</h4><p>批量指的是某个类的大量对象，是<strong>针对类的优化</strong>。<br><strong>批量重偏向</strong>（bulk rebias）：当某个类的对象的偏向锁的<strong>撤销次数</strong>超过重偏向阈值（默认 20 次）后，JVM 会这样觉得，我是不是偏向错了呢，于是在给这些对象加锁时会重新偏向至试图加锁的线程。</p><p><strong>批量撤销</strong>（bulk revoke）：当某个类的对象的偏向锁的<strong>撤销次数</strong>超过批量撤销阈值（默认40 次）后，JVM 会这样觉得，自己确实偏向错了，根本就不该偏向，于是整个类的所有对象 都会变为<strong>不可偏向</strong>的，新建的对象也是不可偏向的。通俗来说，JVM 会认为这个类的所有对象的使用场景都存在多线程竞争，会标记该类为不可偏向，之后，对于该类的对象的锁，都会直接走轻量级锁的逻辑。</p><h4 id="废弃"><a href="#废弃" class="headerlink" title="废弃"></a>废弃</h4><p>JDK 15废弃了偏向锁，其带来的作用已经不大。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>偏向锁其实就是为了避免一直获取，释放锁带来的消耗（CAS）,采用确认mark word中的线程id来判断是否属于自己，若不属于则升级为轻锁（尝试CAS），再不行就变成重锁（先自旋再堵塞）</p><p>一个对象有<strong>可偏向</strong>和<strong>不可偏向</strong>两种状态（取决于偏向锁标志位是否为1），且初始时是可偏向的。若是对象可偏向,则会尝试加偏向锁，否则直接走轻量级锁逻辑。</p><p><strong>撤销</strong>是等Save Point时，判断持有线程是否仍在同步块中：</p><ul><li>若在，则升级锁为轻量级锁（发生竞争）。</li><li>若不在，则将其变成无锁状态（此时<strong>不可偏向</strong>，此后该线程获取该对象锁时会直接获取轻量级锁）。<br>但是，若大量同类对象偏向锁的被撤销，则给与该类的对象重新偏向其他线程的机会（标记为<strong>可偏向</strong>），但是若再被撤销太多次，则变成<strong>不可偏向</strong>。</li></ul><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>Lock Elimination:锁消除的概念比较容易理解，就是<strong>如果编译器认定一个锁只会被单个线程访问，那么这个锁就可以被消除</strong>。</p><p>锁消除需要进行逃逸分析：</p><ul><li>方法逃逸</li><li><strong>线程逃逸</strong></li></ul><p>针对是否逃逸，JVM的优化有：</p><ul><li><strong>同步省略</strong></li><li>标量替换</li><li>栈上分配</li></ul><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>Lock Coarsening:如果虚拟机检查到有这样一串连续的操作都是对同一个对象进行加锁，就会把加锁同步的范围粗化（扩大）到整个操作序列的外部。<br>简单来说，锁粗化就是把多次加锁请求合并成一次。如<code>sb.append()</code>连续调用。</p><h2 id="wait和synchronized"><a href="#wait和synchronized" class="headerlink" title="wait和synchronized"></a>wait和synchronized</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>wait方法必须在 synchronized 同步块中调用</li><li>wait方法是Object实现的native方法</li></ul><p>某线程A调用对象a的<code>wait</code>方法，会让线程处于WAITING状态，直到另一个线程调用对象a的<code>notify</code>（随机）或<code>notifyAll</code>（所有）方法。可以看出，对象a基本上是信号的传递者的角色。</p><p><strong>调用 <code>wait</code> 方法的线程必须拥有此对象的监视器</strong>，否则报异常。该方法将当前线程（称为 T）置于此对象的 WaitSet 中，然后放弃该对对象的锁。直到被唤醒或中断、超时。</p><p>总结：调用 wait 方法就是对象通知持有自己锁的线程释放该锁并等待；而 notify 和 notifyAll 方法就是对象通知在等待的线程又可以来竞争我的锁了。</p><h3 id="无效唤醒-Lost-Wakeup"><a href="#无效唤醒-Lost-Wakeup" class="headerlink" title="无效唤醒 Lost Wakeup"></a>无效唤醒 Lost Wakeup</h3><p>为什么必须在同步块中调用wait？<br>wait要在notify前发生，即编程时希望先让某线程wait，再由其他线程唤醒它，但是多线程下不能保证wait发生在notify后，所以需要用锁来保证只有wait成功之后，其他线程才能notify这个对象。</p><h3 id="虚假唤醒-Spurious-Wakeup"><a href="#虚假唤醒-Spurious-Wakeup" class="headerlink" title="虚假唤醒 Spurious Wakeup"></a>虚假唤醒 Spurious Wakeup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(某条件)&#123;<br><span class="hljs-comment">//等待</span><br><span class="hljs-built_in">this</span>.wait();<br>&#125;<br><span class="hljs-comment">//执行某事件</span><br><span class="hljs-keyword">do</span>();<br><span class="hljs-comment">//通知其他线程</span><br><span class="hljs-built_in">this</span>.notifyAll();<br></code></pre></td></tr></table></figure><p>在if条件语句不满足条件时，线程进入wait，被唤醒时其if条件仍不满足，因此需要把if改成while。</p><h1 id="三、Volatile"><a href="#三、Volatile" class="headerlink" title="三、Volatile"></a>三、Volatile</h1><p>当一个变量被定义成 volatile 之后，它将具备两项特性：</p><ol><li>保证此变量对所有线程的<strong>可见性</strong>。所谓 “可见性” 就是指当一条线程修改了这个变量的值，其他线程可以立即得知这个修改。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。</li><li><strong>禁止指令重排序</strong>。事实上，普通的变量是无法保证变量赋值操作的顺序与程序代码的执行顺序是一致的，在某些情况下，可能会出现意想不到的结果。</li></ol><h2 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a>volatile保证可见性</h2><ol><li><strong>volatile 写的内存语义</strong>：当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li><strong>volatile 读的内存语义</strong>：当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ol><p>事实上，更底层来讲，有 volatile 变量修饰的共享变量进行写操作的时候会多出一条Lock前缀的指令，根据 IA-32 架构软件开发者手册，这条指令会引发两件事情：<br>1）将当前处理器缓存行的数据写回到系统内存<br>2）这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效<br>即<strong>无效其他线程本地内存的操作实际上是在写时就发生了</strong>。</p><h2 id="volatile禁止指令重排"><a href="#volatile禁止指令重排" class="headerlink" title="volatile禁止指令重排"></a>volatile禁止指令重排</h2><p>绿色表示可以重排序，红色则不能：<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203010905.png"><br>简而言之：</p><ul><li>volatile写之前的不许被排序在其后(写之后不被修改)</li><li>volatile读之后的不许排序在其前（读之前不被修改）</li><li>volatile写和读不可以重排序</li></ul><p>更底层的，禁止指令重排的底层原理是插入内存屏障：编译器在生成字节码的时候，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序：</p><p>1）在每个 volatile 写操作的前面插入一个 StoreStore 屏障；在每个 volatile 写操作的后面插入一个 StoreLoad 屏障<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011123.png"></p><p>2）在每个 volatile 读操作的后面插入一个 LoadLoad 屏障和一个 LoadStore 屏障（图中volatile读前有一个Load屏障）<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011141.png"></p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p><strong>内存屏障是一种指令，无论是在JAVA内存模型还是CPU层次，都是有具体的指令对应的，是一种特殊的指令，作用为禁止指令</strong><br>重排序的内存屏障有四种，分别叫做**LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</p><p>例子：LoadLoad屏障<br>序列：load1指令 <strong>LoadLoad屏障</strong> load2指令<br>作用：在load1指令和load2指令之间加上 LoadLoad屏障，<strong>强制先执行load1指令再执行load2指令</strong>；load1指令和load2指令不能进行重排序。</p><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC2%E7%AB%A0%EF%BC%88%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89/Pasted-image-20230203011315.png"></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li>volatile读需要保证，其后面的写操作不会重排序到其前面影响读结果（loadstore），同时保证其后的读的结果和本次读的结果一致（loadload）。</li><li>volatile写需要保证，其前面的写操作不会重排序到其后面（storestore），同时要保证可见性（storeload）。</li></ul><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p><strong>双重校验锁（Double Checked Locking，DCL）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span> &#123;<br><span class="hljs-comment">// 私有化构造方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span>&#123;&#125;; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">// 第一次校验</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;     <br>            <span class="hljs-keyword">synchronized</span> (SingleTon.class) &#123;<br>                <span class="hljs-comment">// 第二次校验</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;     <br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>                &#125;<br>        &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么 <code>instance</code> 一定要用 <code>volatile</code> 这个关键字来修饰？</p><h3 id="可见性应用"><a href="#可见性应用" class="headerlink" title="可见性应用"></a>可见性应用</h3><ul><li>第一次校验：直接返回已经创建的实例，且不通过同步方法，速度快。</li><li>第二次校验：防止两线程同时getIntance并通过第一次校验，导致创建两个对象。</li></ul><p>即只同步新建对象的过程，不影响直接返回对象的过程，且创建后对另一个线程<strong>可见</strong>。</p><h3 id="禁止指令重排序的应用"><a href="#禁止指令重排序的应用" class="headerlink" title="禁止指令重排序的应用"></a>禁止指令重排序的应用</h3><p>在 Java 语言层面上，创建对象仅仅是一个 new 关键字而已，而在 JVM 中，对象的创建其实并不是一蹴而就的，忽略掉一些 JVM 底层的细节比如设置对象头啥的，对象的创建可以大致分三个步骤：</p><ol><li>在堆中为对象分配内存空间</li><li>调用构造函数，初始化实例</li><li>将栈中的对象引用指向刚分配的内存空间</li></ol><p>为了防止2-&gt;3步发生重排序，使用volatile保证先创建完对象再给出引用。</p><h1 id="四、Final"><a href="#四、Final" class="headerlink" title="四、Final"></a>四、Final</h1><blockquote><p>引言：在旧的 Java 内存模型（JDK 1.5 以前）中，一个最严重的缺陷就是线程可能看到 final 域的值会改变。比如一个线程看到一个 int 类型 final 值为 0，此时该值是未初始化前的零值，一段时间后该值被某线程初始化，再去读这个 final 值会发现值变为 1。</p><p>为了修补这个漏洞，新的 Java 内存模型并增强了 final 的语义，通过为 final 域增加写和读重排序规则，为 Java 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（lock、volatile）就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p></blockquote><p>简单来说：只要一个不可变对象被正确地构建出来（即没有发生 this 引用逃逸的情况，这是一种例外），那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。</p><p>甚至我们可以下结论：<strong>不可变对象永远是线程安全的。</strong></p><h2 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h2><p>构造对象时会初始化final域，此时：</p><ol><li>JMM <strong>禁止编译器</strong>把对 final 域的写指令重排序到构造函数之外。</li><li>编译器会在对 final 域的写指令之后，构造函数 return 之前，插入一个 StoreStore 屏障（这个屏障的作用就是<strong>禁止处理器</strong>把对 final 域的写指令重排序到构造函数之外）</li></ol><p>解释：<strong>编译器</strong>不做重排序，并通过storestore防止<strong>处理器</strong>重排序。<br>目的：保证先赋值对象的final属性，后完成初始化给出该对象引用。</p><h2 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h2><ol><li><strong>编译器不会</strong>把对final域的读重排序到对对象的读之前</li><li>但部分处理器可能会这么做，所以编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障<strong>禁止处理器</strong>重排序。</li></ol><blockquote><p>对于编译器和大部分处理器来说，肯定是不会对初次读对象引用与初次读该对象包含的 final 域这两个操作进行重排序的，因为这两个操作之间存在间接依赖关系。<br>但有少数处理器是允许对存在间接依赖关系的操作做重排序的，所以这个规则就是专门用来针对这种处理器的。</p></blockquote><p>解释：<strong>编译器</strong>一般不会重排序final读，同时通过loadload保证<strong>处理器不会</strong>把读final域的操作放在读其所属对象前。<br>目的：保证先获取到对象本身，然后再读final值。</p><h2 id="this引用逃逸"><a href="#this引用逃逸" class="headerlink" title="this引用逃逸"></a>this引用逃逸</h2><p>final保证了final属性在对象构造完成return前赋值，但若return前将this引用给到外部，此时对象尚未初始化完成，这就是一种线程逃逸。</p><p>避免：为了避免这种逃逸现象，最好不要这样编写代码，保证”只要一个不可变对象被正确地构建出来（即没有发生 this 引用逃逸的情况），那其外部的可见状态永远都不会改变”。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC第1章（基础知识）</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h1><h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>在操作系统中，内存通常会被分成用户空间（User space）与内核空间（Kernel space）这两个部分。当进程&#x2F;线程运行在用户空间时就处于用户态，运行在内核空间时就处于内核态：</p><ul><li>运行在内核态的程序可以访问用户空间和内核空间，或者说它可以访问计算机的任何资源，不受限制，为所欲为，例如协调 CPU 资源，分配内存资源，提供稳定的环境供应用程序运行等。</li><li>而应用程序基本都是运行在用户态的，或者说用户态就是提供应用程序运行的空间。运行在用户态的程序只能访问用户空间。</li></ul><p>区分的目的：<br>用户态的程序不能随意操作内核地址空间，这样有效地防止了操作系统程序受到应用程序的侵害。</p><p>那如果处于用户态的程序想要访问内核空间的话怎么办呢？<strong>就需要进行系统调用从用户态切换到内核态。</strong></p><h2 id="操作系统线程"><a href="#操作系统线程" class="headerlink" title="操作系统线程"></a>操作系统线程</h2><h3 id="用户空间实现线程"><a href="#用户空间实现线程" class="headerlink" title="用户空间实现线程"></a>用户空间实现线程</h3><p><strong>早期</strong>的操作系统<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202153716.png"><br>优点：</p><ul><li>第一点，就是即使操作系统原生不支持线程，我们也可以通过库函数来支持线程；</li><li>第二点，线程的调度只发生在用户态，<strong>避免</strong>了操作系统从内核态到用户态的<strong>转换开销</strong>。</li></ul><p>缺点：</p><ul><li>CPU 的时间片切换是以进程为维度的，所以如果进程中某个线程进行了耗时比较长的操作，那么由于<strong>用户空间中没有时钟中断机制</strong>，就会导致此进程中的其它线程因为得不到 CPU 资源而长时间的持续等待；</li><li>另外，如果某个线程进行系统调用时比如缺页中断而导致了线程阻塞，此时操作系统也会阻塞住整个进程，即使这个进程中其它线程还在工作。</li></ul><h3 id="内核空间实现线程"><a href="#内核空间实现线程" class="headerlink" title="内核空间实现线程"></a>内核空间实现线程</h3><p><strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS X 和 Solaris 等，都支持内核线程。<strong>支持多线程的内核就叫做多线程内核</strong>（Multi-Threads Kernel）。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202154001.png"><br>我们可以直接使用操作系统中已经内置好的线程，线程的创建、销毁、调度和维护等，都是直接由操作系统的内核来实现，不需要像用户级线程那样自己设计线程调度等。</p><p>这种方式又分一对多、一对一、多对多三种，<a href="https://leetcode.cn/leetbook/read/concurrency/atqmpr/">参考</a></p><ul><li>一对多，特点同用户空间实现多线程</li><li>一对一，管理线程开销大，<strong>Windows (从 Win95 开始) 和 Linux 都实现了线程的一对一模型</strong>。</li><li>多对多，复用线程（线程池）</li></ul><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p><strong>线程库就是为开发人员提供创建和管理线程的一套 API</strong>。</p><p>下面简单介绍下三个主要的线程库：<br>1）POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展<br>2）Win32 线程：用于 Window 操作系统的内核级线程库<br>3）Java 线程：<strong>Java 线程 API 通常采用宿主系统的线程库来实现</strong>，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p><p><strong>现今 Java 中线程的本质，其实就是操作系统中的线程。</strong></p><p>其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Win32 线程库来管理线程，且 Windows 采用的是一对一的线程模型。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>线程私有一个虚拟机栈空间。</p><p>当然，使用多线程就不可避免的会遇到一个问题，那就是线程的上下文切换（Thread Context Switch），就是说因为某些原因导致 CPU 不再执行当前的线程，转而执行另一个线程。</p><p>导致线程上下文切换的原因大概有以下几种：<br>1）线程的 CPU 时间片用完<br>2）发生了垃圾回收<br>3）有更高优先级的线程需要运行<br>4）线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p><p>当线程的上下文切换发生时，也就是从一个线程 A 转而执行另一个线程 B 时，需要由操作系统保存当前线程 A 的状态（为了以后还能顺利回来接着执行），并恢复另一个线程 B 的状态。</p><p>这个状态就包括每个线程私有的程序计数器和虚拟机栈中每个栈帧的信息等，显然，每次操作系统都需要存储这么多的信息，频繁的线程上下文切换势必会影响程序的性能。</p><h1 id="二、JAVA内存模型与原子性、可见性、有序性"><a href="#二、JAVA内存模型与原子性、可见性、有序性" class="headerlink" title="二、JAVA内存模型与原子性、可见性、有序性"></a>二、JAVA内存模型与原子性、可见性、有序性</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202154822.png"></p><blockquote><p>JMM(Java Memory Model) 规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory）。</p><p>线程的工作内存中保存了被该线程使用的变量的<strong>主内存副本</strong>，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。</p></blockquote><p><strong>这就是并发时内存不一致的元凶！</strong></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>JMM 中定义了以下 8 种操作规范来完成一个变量从主内存拷贝到工作内存、以及从工作内存同步回主内存这一类的实现细节。Java 虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li></ul><div class="note note-primary">            <ul><li>lock，unlock执行锁，操作主内存</li><li>read，write操作主内存</li><li>load，store操作工作内存</li><li>assign，use操作执行引擎<br>java的实现，保证以上8种类型的操作一定是原子操作。</li></ul>          </div><p><strong>如何保证原子性？</strong><br>处理器提供了总线锁和缓存锁，<strong>Java提供了锁和循环CAS的方式</strong></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><strong>何为可见性</strong>？就是指当一个线程修改了共享变量的值时，其他线程能够<strong>立即</strong>得知这个修改。<br>所谓可见性就是要把工作内存内容立即写入主内存。</p><h3 id="如何保证可见性？"><a href="#如何保证可见性？" class="headerlink" title="如何保证可见性？"></a>如何保证可见性？</h3><ul><li><strong>volatile</strong>：volatile修饰的变量。</li><li><strong>synchronized</strong>：对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）</li><li><strong>final</strong>：被 <code>final</code> 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看见 <code>final</code> 字段的值。</li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>Java的编译器也有这样的一种优化手段：<strong>指令重排序</strong>（Instruction Reorder）。<br>但都需要遵守一个规定：<br><strong>as-if-serial 语义</strong>：不管怎么重排序，<strong>单线程</strong>环境下程序的执行结果不能被改变。即CPU和编译器不会对存在<strong>数据依赖关系</strong>（1.读后写2.写后读3.写后写）的操作做重排序。</p><p><strong>不同 CPU 之间和不同线程之间的数据依赖性是不被 CPU 和编译器考虑的</strong>。所以as-if-serial的约束在多线程下是无效的。</p><p>结论：<strong>CPU 和 Java 编译器为了优化程序性能，会自发地对指令序列进行重新排序。在多线程的环境下，由于重排序的存在，就可能导致程序运行结果出现错误</strong>。</p><h3 id="如何保证有序性？"><a href="#如何保证有序性？" class="headerlink" title="如何保证有序性？"></a>如何保证有序性？</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>as-if-serial规定</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ul><li><code>volatile</code> 本身除了保证可见性的语义外，还包含了禁止指令重排序的语义，所以天生就具有保证有序性的功能。</li><li><code>synchronized</code>保证有序性的理论支撑，仍然是 JMM 规定在执行 8 种基本原子操作时必须满足的一系列规则中的某一个提供的：<strong>一个变量在同一个时刻只允许一条线程对其进行 lock 操作</strong></li><li><code>Happens-before</code> 原则</li></ul><div class="note note-primary">            <p>volatile和synchronized都可以保证可见性和有序性。<br>final可以保证可见性。<br>as-if-serial原则保证单线程有序性。<br>happens-before原则保证多线程有序性。</p>          </div><h2 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>可见性和有序性是矛盾的：我们希望内容足够可见，但又希望提高性能（重排序）。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>如果一个操作 Happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作<strong>可见</strong>，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 Happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 Happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 Happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）</li></ol><div class="note note-primary">            <p>如果A happens before B</p><ul><li>一般来说，A需要在<strong>先于</strong>B执行并保证结果<strong>可见</strong>。</li><li>但如果<strong>重排序</strong>不影响执行结果，也可以改变执行顺序。</li></ul>          </div><p>JMM 其实是在遵循一个基本原则：<strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行</strong>。</p><h3 id="8条Happens-before规则"><a href="#8条Happens-before规则" class="headerlink" title="8条Happens-before规则"></a>8条Happens-before规则</h3><p>1）程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生（Happens-before）于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// A  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// B  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;  <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure><p>有A happens-before B，B happens-before C</p><div class="note note-primary">            <p>类似于单线程下的as-if-serial</p>          </div><p>2）管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是 “同一个锁”，而 “后面” 是指时间上的先后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 此处自动加锁</span><br><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">1</span>) &#123;<br>        x = <span class="hljs-number">1</span>;<br>    &#125;      <br>&#125; <span class="hljs-comment">// 此处自动解锁</span><br></code></pre></td></tr></table></figure><p>3）volatile 变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的 “后面” 同样是指时间上的先后。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202164431.png"></p><blockquote><p>以下将happens before简写为hb<br>程序次序规则：1hb2，3hb4<br> volatile规则：2hb3<br>此时线程A执行writer()，线程B执行reader()<br>如果flag &#x3D;&#x3D; true，则i &#x3D; a &#x3D; 42；</p></blockquote><div class="note note-primary">            <p>因为变量flag被violate修饰，所以它不会发生重排序，写变量a一定在写变量flag前执行。同时，因为flag被violate修饰，所以它在写后会强制同步到主内存，即，该操作完成时即同步（<strong>可见性</strong>），在其后执行读变量的话读到的一定是最新值。</p>          </div><p>4）线程启动原则（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</p><p>5）线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread 对象的 join() 方法是否结束、Thread 对象的 isAlive() 的返回值等手段检测线程是否已经终止执行。</p><p>6）线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread 对象的 interrupted() 方法检测到是否有中断发生。</p><p>7）对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p>8）传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</p><div class="note note-primary">            <p>程管V启中终对传</p>          </div><h3 id="“时间上先后发生”和“先行发生”"><a href="#“时间上先后发生”和“先行发生”" class="headerlink" title="“时间上先后发生”和“先行发生”"></a>“时间上先后发生”和“先行发生”</h3><p><strong>两者并无必然关系</strong><br>时间上先后发生：指事件A在事件B之前执行<br>先行发生：指事件A的执行结果对事件B可见</p><ul><li>符合先行发生关系如果对结果没影响也可能被重排序，导致两者矛盾。</li><li>时间上先后发生的不一定先行发生，如两个线程，先后调用set，get方法，这样set在get前调用，但不一定先行发生，无法保证set的结果对get可见。</li></ul><h3 id="Happens-before-与-as-if-serial"><a href="#Happens-before-与-as-if-serial" class="headerlink" title="Happens-before 与 as-if-serial"></a>Happens-before 与 as-if-serial</h3><ul><li>as-if-serial 语义保证单线程内程序的执行结果不被改变，Happens-before 关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。Happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 Happens-before 指定的顺序来执行的。</li></ul><h1 id="三、Java线程"><a href="#三、Java线程" class="headerlink" title="三、Java线程"></a>三、Java线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Thread实现了Runnable接口。<br><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202170026.png"></p><h3 id="1-线程与任务合并"><a href="#1-线程与任务合并" class="headerlink" title="1.线程与任务合并"></a>1.线程与任务合并</h3><p>直接继承Thread+重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义线程对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 线程需要执行的任务</span><br>......<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread1</span>();<br><br><span class="hljs-comment">// 一般使用匿名内部类</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-comment">// run 方法内实现了要执行的任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 线程需要执行的任务</span><br>    ......<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-线程与任务分离-Runnable"><a href="#2-线程与任务分离-Runnable" class="headerlink" title="2.线程与任务分离(Runnable)"></a>2.线程与任务分离(Runnable)</h3><p>Thread + 实现 Runnable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程需要执行的任务</span><br>    ......<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建任务类对象</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br><br><span class="hljs-comment">// 匿名内部类</span><br><span class="hljs-comment">// 创建任务类对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        ......<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br></code></pre></td></tr></table></figure><h3 id="3-线程与任务分离-Callable"><a href="#3-线程与任务分离-Callable" class="headerlink" title="3.线程与任务分离(Callable)"></a>3.线程与任务分离(Callable)</h3><p>Thread + 实现 Callable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>        ......<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 将 Callable 包装成 FutureTask，FutureTask也是一种Runnable</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">callable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>Thread只实现了runnable，所以需要将callable包装成一个runnable，通常使用FutureTask进行包装，其是一个Runnable。</p>          </div><div class="note note-success">            <p>start会异步执行，run会同步执行（<strong>使用当前线程执行，没有真正创建新线程</strong>）。</p>          </div><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><h3 id="操作系统线程五态模型"><a href="#操作系统线程五态模型" class="headerlink" title="操作系统线程五态模型"></a>操作系统线程五态模型</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202170624.png"></p><h3 id="Java线程六态模型"><a href="#Java线程六态模型" class="headerlink" title="Java线程六态模型"></a>Java线程六态模型</h3><p><img src="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JUC/JUC%E7%AC%AC1%E7%AB%A0%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/Pasted-image-20230202173309.png"></p><ul><li>Java线程模型将操作系统中就绪态（READY）和运行态（RUNNING）两种状态统称为 “RUNNABLE”。</li><li>Java线程新增了WAITING状态和TIMED_WAITING状态，是为了实现线程的手动唤醒。</li></ul><blockquote><p>LockSupport提供类似sleep的作用，其与锁无关：</p><ul><li>线程睡眠：</li><li>LockSupport.park();</li><li>LockSupport.parkNano(long time);</li><li>唤醒线程：</li><li>LockSupport.unpark(Thread t);</li></ul></blockquote><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><p>刚创建，还没start</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><p>调用start后</p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h4><p>阻塞于锁，即同步资源获取失败，指<code>synchronized</code>。</p><blockquote><p>LOCK接口下，线程会进入WAITING状态</p></blockquote><h5 id="何时进入BLOCKED状态"><a href="#何时进入BLOCKED状态" class="headerlink" title="何时进入BLOCKED状态"></a>何时进入BLOCKED状态</h5><ol><li>首次竞争锁失败 RUNNABLE -&gt; BLOCKED</li><li>目标锁被其他线程释放，本线程被唤醒后再次竞争 BLOCKED -&gt; BLOCKED</li><li>处于等待状态的线程被唤醒然后竞争进入<code>synchronized</code>块 WAITING -&gt; RUNNABLE -&gt; BLOCKED</li></ol><div class="note note-primary">            <p>即WAITING状态的线程被唤醒后会先进入RUNNABLE状态，等待系统分配运行资源再竞争锁。</p>          </div><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><h5 id="RUNNABLE到WAITING"><a href="#RUNNABLE到WAITING" class="headerlink" title="RUNNABLE到WAITING"></a>RUNNABLE到WAITING</h5><ol><li>调用<code>Object.wait</code></li><li>调用<code>Thread.join</code>：当前线程调用t.join()，则当前线程需要等t执行完毕后才继续执行</li><li>调用<code>LockSupport.park</code></li></ol><h5 id="WAITING到RUNNABLE"><a href="#WAITING到RUNNABLE" class="headerlink" title="WAITING到RUNNABLE"></a>WAITING到RUNNABLE</h5><ol><li>调用了 <code>Object.notify</code></li><li>调用了 <code>Object.notifyAll</code></li><li>调用了 <code>LockSupport.unpark</code> 恢复某个线程的运行</li></ol><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>不同于WAITING，指定时间后返回到Runnable状态。</p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>终止状态，表示当前线程已经执行完毕。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM下篇:性能监控与调优</title>
    <link href="/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8B%E7%AF%87-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <url>/2023/02/02/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8B%E7%AF%87-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p><strong>生产环境中的问题</strong></p><ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境CPU负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加log，如何确定请求是否执行了某一行代码？</li><li>不加log，如何实时查看某个方法的入参与返回值？</li></ul><p><strong>为什么要调优</strong></p><ul><li>防止出现OOM</li><li>解决OOM</li><li>减少Full GC出现的频率</li></ul><p><strong>不同阶段的考虑</strong></p><ul><li>上线前</li><li>项目运行阶段</li><li>线上出现OOM<div class="note note-primary">            <p>上面这些浏览一下，看个大概就行。</p>          </div></li></ul><h2 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h2><p><strong>监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>调优的大方向</strong></p><ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行JVM调优</li></ul><p><strong>性能优化的步骤</strong><br><strong>第1步：性能监控</strong></p><ul><li>GC频繁</li><li>cpu load过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul><p><strong>第2步：性能分析</strong></p><ul><li>打印GC日志来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo等</li><li>dump出堆文件，使用内存分析工具分析文件</li><li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li><li>jstack查看堆栈信息</li></ul><p><strong>第3步：性能调优</strong></p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li></ul><p><strong>吞吐量</strong></p><ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li>吞吐量为1-1&#x2F;(1+n)，其中-XX::GCTimeRatio&#x3D;n</li></ul><p><strong>并发数</strong></p><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul><p><strong>内存占用</strong></p><ul><li>Java堆区所占的内存大小</li></ul><h1 id="二、监控-命令行"><a href="#二、监控-命令行" class="headerlink" title="二、监控-命令行"></a>二、监控-命令行</h1><ul><li>jps：查看正在运行的Java进程</li><li>jstat：查看JVM统计信息<ul><li>跟随 -class查看类加载情况</li><li>跟随 -compiler查看编译情况</li><li>跟随 -gc查看垃圾回收情况</li></ul></li><li>jinfo：实时查看和修改JVM配置参数</li><li>jmap：导出内存映像文件&amp;内存使用情况（<strong>dump文件</strong>）</li><li>jhat：JDK自带堆分析工具（已经删除）</li><li>jstack：打印JVM中线程快照</li><li>jcmd：多功能命令行（执行上面的命令）</li><li>jstatd：远程主机信息收集</li></ul><h1 id="三、监控-GUI"><a href="#三、监控-GUI" class="headerlink" title="三、监控-GUI"></a>三、监控-GUI</h1><ul><li>JConsole，java自带</li><li>Visual VM，java自带</li><li>Eclipse MAT，堆分析器，分析dump文件</li><li>JProfiler，好用全面，但收费</li><li>Arthas，阿里开源，远程监控</li><li>Java Misssion Control，Oracle JDK中提供，官方出品，使用采样技术，开销很小<ul><li>Java Flight Record，JMC的组件</li></ul></li></ul><h1 id="四、JVM运行时参数"><a href="#四、JVM运行时参数" class="headerlink" title="四、JVM运行时参数"></a>四、JVM运行时参数</h1><h2 id="JVM参数选项"><a href="#JVM参数选项" class="headerlink" title="JVM参数选项"></a>JVM参数选项</h2><h3 id="类型一：标准参数选项"><a href="#类型一：标准参数选项" class="headerlink" title="类型一：标准参数选项"></a>类型一：标准参数选项</h3><p>java -help出的内容，一般为常规参数</p><h4 id="Server模式与Client模式"><a href="#Server模式与Client模式" class="headerlink" title="Server模式与Client模式"></a>Server模式与Client模式</h4><p>Hotspot JVM有两种模式，分别是server和client，分别通过-server和-client模式设置。</p><ul><li><strong>32位系统</strong>上，默认使用Client类型的JVM。要想使用Server模式，机器配置至少有2个以上的CPU和2G以上的物理内存。<strong>client模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</strong>。</li><li><strong>64位系统</strong>上，<strong>只支持server模式的JVM</strong>，适用于需要大内存的应用程序，<strong>默认使用并行垃圾收集器</strong>。</li></ul><h3 id="类型二：-X参数选项"><a href="#类型二：-X参数选项" class="headerlink" title="类型二：-X参数选项"></a>类型二：-X参数选项</h3><p>java -X 出的内容，相当于一些高级选项<br>熟悉的有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-Xms&lt;size&gt;        设置初始 Java 堆大小<br>-Xmx&lt;size&gt;        设置最大 Java 堆大小<br>-Xss&lt;size&gt;        设置 Java 线程堆栈大小<br></code></pre></td></tr></table></figure><h3 id="类型三：-XX参数选项"><a href="#类型三：-XX参数选项" class="headerlink" title="类型三：-XX参数选项"></a>类型三：-XX参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+&lt;option&gt;  启用option属性<br>-XX:-&lt;option&gt;  禁用option属性<br><br>-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G<br>-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值<br></code></pre></td></tr></table></figure><p>一些开关类，设置类</p><h2 id="常用的JVM选项"><a href="#常用的JVM选项" class="headerlink" title="常用的JVM选项"></a>常用的JVM选项</h2><h3 id="打印XX选项"><a href="#打印XX选项" class="headerlink" title="打印XX选项"></a>打印XX选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项<br>-XX:+PrintFlagsInitial 打印所有XX选项的默认值<br>-XX:+PrintFlagsFinal 打印所有XX选项的实际值<br>-XX:+PrintVMOptions 打印JVM的参数<br></code></pre></td></tr></table></figure><h3 id="内存大小设置"><a href="#内存大小设置" class="headerlink" title="内存大小设置"></a>内存大小设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">栈</span><br>-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">堆</span><br>-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M<br>-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M<br>-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8<br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br>-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启<br>-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效<br>-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15<br>-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法区</span><br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M<br>-XX:+UseCompressedOops 使用压缩对象<br>-XX:+UseCompressedClassPointers 使用压缩类指针<br>-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接内存</span><br>-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>可见对内存使用的配置基本都是使用<code>-XX：</code>形式，其中设置堆、栈大小给出了<code>-X</code>的形式。</p>          </div><h3 id="OutOfMemory相关的选项"><a href="#OutOfMemory相关的选项" class="headerlink" title="OutOfMemory相关的选项"></a>OutOfMemory相关的选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥<br>-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录<br>-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本<br></code></pre></td></tr></table></figure><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Serial回收器</span><br>-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ParNew回收器</span><br>-XX:+UseParNewGC  年轻代使用ParNew GC<br>-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Parallel回收器</span><br>-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活<br>-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活<br>-XX:ParallelGCThreads<br>-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。<br>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。<br>所以服务器端适合Parallel，进行控制。该参数使用需谨慎。<br>-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小<br>取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。<br>与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。<br>-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。<br>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">CMS回收器</span><br>-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。<br>开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合<br>-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。<br>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。<br>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<br>因此通过该选项便可以有效降低Fu1l GC的执行次数。<br>-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动<br>-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理<br>以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。<br>-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。<br>-XX:ParallelCMSThreads  设置CMS的线程数量。<br>CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。<br>当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。<br>-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的<br>-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度<br>-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）<br>-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记<br>用于提高标记速度，在Java8开始已经默认开启<br>-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启<br>-XX:+ExplicitGCInvokesConcurrent<br>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses<br>这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期<br>-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">G1回收器</span><br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。<br>-XX:G1HeapRegionSize 设置每个Region的大小。<br>值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。<br>-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms<br>-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8<br>-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。<br>-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。<br>-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）<br>-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）<br>-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出<br></code></pre></td></tr></table></figure><h4 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h4><ul><li>优先让JVM自适应，调整堆的大小</li><li><strong>串行</strong>收集器：内存小于100M；<strong>单核、单机程序</strong>，并且没有停顿时间的要求</li><li><strong>并行</strong>收集器：<strong>多CPU、高吞吐量</strong>、允许停顿时间超过1秒</li><li><strong>并发</strong>收集器：多CPU、追求低停顿时间、<strong>快速响应</strong>（比如延迟不能超过1秒，如互联网应用）</li><li><strong>官方推荐G1</strong>，性能高。现在互联网的项目，基本都是使用G1。</li></ul><h1 id="五、GC相关日志"><a href="#五、GC相关日志" class="headerlink" title="五、GC相关日志"></a>五、GC相关日志</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息<br>-XX:+PrintGCDetails            打印详细日志信息<br>-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图<br>-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中<br><br>-XX:+TraceClassLoading  监控类的加载<br>-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间<br>-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间<br>-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用<br>-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布<br>-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储<br>-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目<br>-XX:GCLogFileSize=1M  设置GC日志文件的大小<br></code></pre></td></tr></table></figure><h2 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用<br>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小<br>-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况<br>-XX:+DoEscapeAnalysis  开启逃逸分析<br>-XX:+UseBiasedLocking  开启偏向锁<br>-XX:+UseLargePages  开启使用大页面<br>-XX:+PrintTLAB  打印TLAB的使用情况<br>-XX:TLABSize  设置TLAB大小<br></code></pre></td></tr></table></figure><h2 id="Java获取运行参数"><a href="#Java获取运行参数" class="headerlink" title="Java获取运行参数"></a>Java获取运行参数</h2><p>Java提供了<code>java.lang.management</code>包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地或远程监控和管理运行的Java虚拟机。<br>其中<strong>ManagementFactory</strong>类较为常用，另外<strong>Runtime</strong>类可获取内存、CPU核数等相关的数据。通过使用这些api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryMonitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MemoryMXBean</span> <span class="hljs-variable">memorymbean</span> <span class="hljs-operator">=</span> ManagementFactory.getMemoryMXBean();<br>        <span class="hljs-type">MemoryUsage</span> <span class="hljs-variable">usage</span> <span class="hljs-operator">=</span> memorymbean.getHeapMemoryUsage();<br>        System.out.println(<span class="hljs-string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;\nFull Information:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());<br>        System.out.println(<span class="hljs-string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());<br><br>        System.out.println(<span class="hljs-string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 当前堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 空闲堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 最大可用总堆内存大小</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析GC日志"><a href="#分析GC日志" class="headerlink" title="分析GC日志"></a>分析GC日志</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden &#x2F; S0, S1）的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br></code></pre></td></tr></table></figure><p><strong>GC原因</strong></p><ul><li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace区不够用了</li><li>FErgonomics：JVM自适应调整导致的GC</li><li>System：调用了System.gc()方法</li></ul><p><strong>垃圾收集器</strong></p><ul><li>Serial收集器：新生代显示 <code>&quot;[DefNew&quot;</code>，即 Default New Generation</li><li>ParNew收集器：新生代显示 <code>&quot;[ParNew&quot;</code>，即 Parallel New Generation</li><li>Parallel Scavenge收集器：新生代显示<code>&quot;[PSYoungGen&quot;</code>，JDK1.7使用的即PSYoungGen</li><li>Parallel Old收集器：老年代显示<code>&quot;[ParoldGen&quot;</code></li><li>G1收集器：显示<code>&quot;garbage-first heap&quot;</code></li></ul><p><strong>GC前后</strong><br>形式：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p><ul><li>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul><p><strong>GC时间</strong></p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核，一般而言：real time &lt; sys time＋user time<br>如果real＞sys＋user的话，则可能存在下列问题：IO负载非常重或CPU不够用。</p><h1 id="六、浅堆深堆与内存泄漏"><a href="#六、浅堆深堆与内存泄漏" class="headerlink" title="六、浅堆深堆与内存泄漏"></a>六、浅堆深堆与内存泄漏</h1><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><h3 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h3><p><strong>浅堆是指一个对象所消耗的内存</strong>。<br>在32位系统中，一个对象引用会占据4个字节，一个int类型会占据4个字节，long型变量会占据8个字节，每个对象头需要占用8个字节。根据堆快照格式不同，对象的大小可能会同8字节进行对齐。</p><h3 id="保留集（Retained-Set）"><a href="#保留集（Retained-Set）" class="headerlink" title="保留集（Retained Set）"></a>保留集（Retained Set）</h3><p>对象A的保留集指当对象A被垃圾回收后，可以被释放的所有的对象集合（包括对象A本身），即对象A的保留集可以被认为是只能通过对象A被直接或间接访问到的所有对象的集合。<br>通俗地说，就是指<strong>仅被对象A所持有的对象的集合，包括A自身</strong>。</p><h3 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h3><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p><p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p><h3 id="对象的实际大小"><a href="#对象的实际大小" class="headerlink" title="对象的实际大小"></a>对象的实际大小</h3><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，<strong>但实际上，这个概念和垃圾回收无关</strong>。</p><div class="note note-primary">            <p>浅堆：对象本身的大小<br>深堆：对象及其<strong>独有</strong>所有直接，间接引用的大小<br>对象大小：对象及其所有直接，间接引用的大小</p>          </div><h3 id="支配树（Dominator-Tree）"><a href="#支配树（Dominator-Tree）" class="headerlink" title="支配树（Dominator Tree）"></a>支配树（Dominator Tree）</h3><p>支配树的概念源自图论。体现对象实例之间的支配关系：</p><ul><li>如果指向B的所有路径都经过A，则认为A是B的<strong>支配者</strong>。</li><li>如果A是离B最近的支配者，则A是B的<strong>直接支配者</strong>。</li></ul><h3 id="内存泄漏（memory-leak）"><a href="#内存泄漏（memory-leak）" class="headerlink" title="内存泄漏（memory leak）"></a>内存泄漏（memory leak）</h3><p>严格上说：对象不会再被程序用到了，但是GC又不能回收他们的情况（永生），才叫内存泄漏。<br>宽泛的说：由于对象的生命周期过长（存活过久，如某对象不再使用，但其支配者仍需要存活一段时间的情况）。</p><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>内存泄漏的增多，最终会导致内存溢出。</p><h2 id="Java中内存泄漏的8种情况"><a href="#Java中内存泄漏的8种情况" class="headerlink" title="Java中内存泄漏的8种情况"></a>Java中内存泄漏的8种情况</h2><ul><li>静态集合类（方法区）</li><li>单例模式（方法区）</li><li>内部类持有外部类（一个内部类总是保存着外部类的引用）</li><li>数据库，IO连接等（没有关闭连接，无法回收）</li><li>不合理的作用域（变量作用范围大于其使用范围）</li><li>改变哈希值<ul><li>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则再也无法检索到该对象</li></ul></li><li>缓存泄漏（可以使用WeakHashMap）</li><li>监听器和其他回调<ul><li>回调函数：一个通过<strong>函数指针</strong>调用的函数。如果你把函数的<strong>指针地址</strong>作为<strong>参数传递</strong>给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</li><li>如果客户端向应用注册了一个回调函数，使用后没有取消，则会造成内存泄漏，解决办法是使用WeakHashMap。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM中篇:字节码与类加载</title>
    <link href="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <url>/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Class文件结构"><a href="#一、Class文件结构" class="headerlink" title="一、Class文件结构"></a>一、Class文件结构</h1><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td></tr></tbody></table><blockquote><p>其中un表示有n个字节。</p></blockquote><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>u4<br><code>0xCAFEBABE</code></p><h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><p>u2+u2<br>主版本号和副版本号一起构成版本号：M.m<br>不同编译器的class文件不同，目前JVM可以向下兼容。</p><h2 id="常量池集合"><a href="#常量池集合" class="headerlink" title="常量池集合"></a>常量池集合</h2><p>u2(常量数量)+ cp_info（常量表大小）</p><h3 id="constant-pool-count"><a href="#constant-pool-count" class="headerlink" title="constant_pool_count"></a>constant_pool_count</h3><p>u2，从1开始计数，所以constant_pool_count&#x3D;1时说明有0个常量。</p><div class="note note-primary">            <p>因为0索引被空出来作为“空常量”</p>          </div><h3 id="constant-pool"><a href="#constant-pool" class="headerlink" title="constant_pool"></a>constant_pool</h3><p>1 ~ constant_pool_count - 1为索引<br>主要存放<strong>字面量Literal</strong>和<strong>符号引用Symbolic References</strong>，其包含该class文件中如下内容：</p><ul><li>字面量<ul><li>字符串</li><li>final常量</li></ul></li><li>符号引用<ul><li>类，接口名</li><li>方法名</li><li>字段名</li></ul></li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>使用1byte表示该常量的类型：如字符串、符号引用等，即下表中的tag，剩余的部分根据类型不同而不同。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201163645.png"><br>其中：只有CONSTANT_utf8_info的长度是不固定的，其本身也代表字符串，其他常量项的属性可以指向CONSTANT_utf8_info。</p><h2 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的，即bitmap，这样只使用<strong>2byte</strong>即可表达所有访问标志。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。</li><li>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。JDK8后，默认每个class文件都设置了ACC_SUPER标志，目的是向后兼容。</li></ul><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><h3 id="this-class（类索引）"><a href="#this-class（类索引）" class="headerlink" title="this_class（类索引）"></a>this_class（类索引）</h3><p>2byte，指向常量池</p><h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>2byte，指向常量池</p><h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3><p>指向常量池索引集合。</p><h4 id="interfaces-count（接口计数器）"><a href="#interfaces-count（接口计数器）" class="headerlink" title="interfaces_count（接口计数器）"></a>interfaces_count（接口计数器）</h4><p>2byte，interfaces_count项的值表示当前类或接口的直接超接口数量。</p><h4 id="interfaces（接口索引集合）"><a href="#interfaces（接口索引集合）" class="headerlink" title="interfaces（接口索引集合）"></a>interfaces（接口索引集合）</h4><p><code>interfaces_count*2byte</code><br>每个成员的值必须是对常量池表中某项的有效索引值，长度为interfaces_count</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><h3 id="fields-count"><a href="#fields-count" class="headerlink" title="fields_count"></a>fields_count</h3><p>fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><h3 id="fields-table"><a href="#fields-table" class="headerlink" title="fields_table"></a>fields_table</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识符"><a href="#访问标识符" class="headerlink" title="访问标识符"></a>访问标识符</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h4 id="描述符索引"><a href="#描述符索引" class="headerlink" title="描述符索引"></a>描述符索引</h4><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object</code>;</td></tr><tr><td><code>[</code></td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D </code></td></tr></tbody></table><h4 id="属性集合"><a href="#属性集合" class="headerlink" title="属性集合"></a>属性集合</h4><p>每个字段还可以拥有不同的属性，如初始值，注释信息。这些属性的数量放在属性计数器attribute_count中，内容放在属性集合attributes中。</p><p>比如某常量字段拥有下面三个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><h3 id="methods-count"><a href="#methods-count" class="headerlink" title="methods_count"></a>methods_count</h3><p>methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>methods表中的每个成员都必须是一个method_info结构：</p><table><thead><tr><th>类型</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="访问标识-1"><a href="#访问标识-1" class="headerlink" title="访问标识"></a>访问标识</h4><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>这里与字段&#x2F;方法表中的属性集合要分开，字段&#x2F;方法中属性集合是描述字段&#x2F;方法属性的，本处的属性表集合用来描述class文件的附加信息。</p><h3 id="attributes-count"><a href="#attributes-count" class="headerlink" title="attributes_count"></a>attributes_count</h3><p>attributes_count的值表示当前class文件属性表的成员个数。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>属性表中每一项都是一个attribute_info结构。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><p>各种属性的含义见官网，具体问题具体分析。</p><h1 id="二、字节码指令集"><a href="#二、字节码指令集" class="headerlink" title="二、字节码指令集"></a>二、字节码指令集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p><ul><li>i代表对int类型的数据操作，</li><li>l代表long</li><li>s代表short</li><li>b代表byte</li><li>c代表char</li><li>f代表float</li><li>d代表double</li></ul><div class="note note-primary">            <p>注意，编译器会将boolean,byte,char,short作为int使用i开头的指令处理。</p>          </div><h2 id="加载与存储"><a href="#加载与存储" class="headerlink" title="加载与存储"></a>加载与存储</h2><ul><li>xload，将<strong>局部变量</strong>加载到操作数栈。</li><li>iconst、bipush等，<strong>常量入操作数栈</strong></li><li>xstore，<strong>出栈装入局部变量表</strong></li></ul><div class="note note-primary">            <ul><li>x为a表示对象操作，如aload，即加载一个对象到操作数栈。</li><li>在x后加a表示从数组中操作，如iaload，即从<code>int[]</code>数组中取数。</li></ul>          </div><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><h3 id="类型说明"><a href="#类型说明" class="headerlink" title="类型说明"></a>类型说明</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201172429.png"></p><h3 id="运算模式"><a href="#运算模式" class="headerlink" title="运算模式"></a>运算模式</h3><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；<br><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p><h3 id="NaN值使用"><a href="#NaN值使用" class="headerlink" title="NaN值使用"></a>NaN值使用</h3><p>对于浮点数，有特殊的表达式：<br>1&#x2F;0.0 &#x3D; Infinity<br>0.0&#x2F;0.0 &#x3D; NaN</p><h3 id="算数指令-1"><a href="#算数指令-1" class="headerlink" title="算数指令"></a>算数指令</h3><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位与指令</td><td>iand</td><td>land</td><td></td></tr><tr><td></td><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td></tr><tr><td>比较指令</td><td></td><td>lcmp</td><td>fcmpg &#x2F; fcmpl</td><td>dcmpg &#x2F; dcmpl</td></tr></tbody></table><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table><thead><tr><th>转化</th><th>byte</th><th>char</th><th>short</th><th>int</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>int</td><td>i2b</td><td>i2c</td><td>i2s</td><td>○</td><td>i2l</td><td>i2f</td><td>i2d</td></tr><tr><td>long</td><td>l2i i2b</td><td>l2i i2c</td><td>l2i i2s</td><td>l2i</td><td>○</td><td>l2f</td><td>l2d</td></tr><tr><td>float</td><td>f2i i2b</td><td>f2i i2c</td><td>f2i i2s</td><td>f2i</td><td>f2l</td><td>○</td><td>f2d</td></tr><tr><td>double</td><td>d2i i2b</td><td>d2i i2c</td><td>d2i i2s</td><td>d2i</td><td>d2l</td><td>d2f</td><td>○</td></tr></tbody></table><p><strong>宽化类型转换</strong>，可能有精度损失，如long-&gt;double，但结果不会偏离太远。<br><strong>窄化类型转换</strong>，可能造成数据溢出导致结果不正确，并有下面的规律：</p><ul><li>浮点-&gt;整数<ul><li>NaN -&gt; 0</li><li>其他 -&gt; 向0取整 或 转换为整数能表示的最大值</li></ul></li><li>浮点-&gt;浮点(d2f)<ul><li>过小 -&gt; 0</li><li>过大 -&gt; 正负无穷大</li><li>NaN -&gt; NaN</li></ul></li></ul><h2 id="对象创建与访问"><a href="#对象创建与访问" class="headerlink" title="对象创建与访问"></a>对象创建与访问</h2><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><table><thead><tr><th>创建指令</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>创建类实例</td></tr><tr><td>newarray</td><td>创建基本类型数组</td></tr><tr><td>anewarray</td><td>创建引用类型数组</td></tr><tr><td>multilanewarra</td><td>创建多维数组</td></tr></tbody></table><h3 id="字段访问"><a href="#字段访问" class="headerlink" title="字段访问"></a>字段访问</h3><table><thead><tr><th>字段访问指令</th><th>含义</th></tr></thead><tbody><tr><td>getstatic、putstatic</td><td>访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td>getfield、 putfield</td><td>访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th></tr></thead><tbody><tr><td>xaload</td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td></tr><tr><td>xastore</td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td></tr></tbody></table><h3 id="类型检查指令"><a href="#类型检查指令" class="headerlink" title="类型检查指令"></a>类型检查指令</h3><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>判断给定对象是否是某一个类的实例</td></tr><tr><td>checkcast</td><td>检查类型强制转换是否可以进行</td></tr></tbody></table><ul><li>指令instanceof用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li><li>指令checkcast用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li></ul><h2 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h2><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><ul><li>invokevirtual，调用对象的实例方法，<strong>支持多态</strong>。</li><li>invokespecial，调用特殊方法，静态绑定。</li><li>invokestatic，静态绑定。</li><li>invokedynamic，动态解析方法，并执行。该指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。</li></ul><div class="note note-primary">            <p>invokedynamic是lambda表达式的具体底层实现，使用较少，类似于通过方法句柄调用方法，与反射不同，有点难理解，不要过度关注。</p>          </div><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td>xreturn</td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p><h3 id="操作数栈管理"><a href="#操作数栈管理" class="headerlink" title="操作数栈管理"></a>操作数栈管理</h3><ul><li>pop，出栈</li><li>dup，复制栈顶<ul><li>dupm表示复制m个slot并压入栈顶</li><li>dupm_xn表示复制m个slot，并插入到栈顶下的（m+n）slot的位置。</li></ul></li><li>swap，交换栈顶两个slot数值，long,double不可用（占用两个slot）</li><li>nop，占位</li></ul><h2 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h2><ol><li>比较指令</li><li>条件跳转指令</li><li>比较条件跳转指令</li><li>多条件分支跳转指令。</li><li>无条件跳转指令等。</li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>athrow 抛出异常或错误。将栈顶异常抛出<br>jsr 跳转到子例程<br>jsr_w 跳转到子例程（宽索引）<br>ret 从子例程返回</p><h3 id="athrow"><a href="#athrow" class="headerlink" title="athrow"></a>athrow</h3><p>即throw语句<br>在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</p><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>异常表保存了每个异常处理信息。比如：</p><ul><li>起始位置</li><li>结束位置</li><li>程序计数器记录的代码处理的偏移地址</li><li>被捕获的异常类在常量池中的索引</li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。<br>如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p><p>如果有finally块，则finally块必然执行，finally块在return前执行，但不影响return的结果，因此最好不要在非finally块中使用return。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法；不需要显式的用字节码表示。</p><h4 id="锁释放"><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h4><ul><li>如果设置了同步，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</li><li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</li><li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个<strong>同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</strong></li></ul><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>jvm的指令集有monitorenter和monitorexit 两条指令来支持synchronized关键字的语义。</p><h4 id="锁释放-1"><a href="#锁释放-1" class="headerlink" title="锁释放"></a>锁释放</h4><p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><h1 id="三、类的加载过程"><a href="#三、类的加载过程" class="headerlink" title="三、类的加载过程"></a>三、类的加载过程</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201180946.png"></p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182105.png"></p><ol><li>通过类的全名，获取类的二进制数据流，来源有：<ul><li>本地文件</li><li>压缩包</li><li>网络</li><li>数据库</li><li>实时生成</li></ul></li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型）：<ul><li>JDK8前：永久代</li><li>JDK8后：元空间</li></ul></li><li>创建java.lang.Class类的实例（堆中），表示该类型。作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>此时Class类中的成员还没有初始化。</p>          </div><h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p><strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的。</p><ul><li>因此，若数组元素是引用类型，则先加载引用类型，然后JVM自动创建其数组类型。</li><li>数组的访问权限由其元素类型的访问权限决定。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230201182705.png"></p><h4 id="整体说明"><a href="#整体说明" class="headerlink" title="整体说明"></a>整体说明</h4><ul><li><strong>加载过程中，只进行格式检查</strong></li><li>把class文件加载到方法区后，再进行后续的检查</li></ul><h4 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h4><ol><li>格式验证：是否以魔数0XCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</li><li>语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的。如父类不存在，接口未实现等。</li><li>字节码验证：主要检查是否有不合理的跳转，赋值，调用。（检查手段是有限的，即使通过了这阶段检查也不代表没问题。）</li><li>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的，并有访问权限</strong>。</li></ol><div class="note note-primary">            <p>验证行为贯穿整个类的加载过程</p><ul><li>在加载阶段进行格式检查。</li><li>在链接阶段的验证环节进行语义和字节码验证。</li><li>在链接阶段的解析环节继续拿符号引用验证。</li></ul>          </div><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类分配内存空间，并设置初始值0值。</p><div class="note note-primary">            <p>不包含<strong>基本数据类型的字段</strong>用<strong>static final</strong>修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。<br>此外，类变量(static)存放在<strong>堆</strong>中class对象中。</p>          </div><div class="note note-success">            <p><strong>static与static final</strong><br>根据虚拟机规范定义，类变量（static）应该被放入方法区，而java中方法区的具体实践是：</p><ul><li>类元信息放入元空间</li><li>字符串常量池和静态变量放入堆中，其中静态变量是伴随着Class对象分配空间的。<ul><li>如果静态变量是final且是基本数据类型（包括字符串），那么其值会在类加载过程中的<strong>链接环节的准备过程</strong>中初始化赋值，否则在这里赋0值。</li><li>如果静态变量不是final且是基本数据类型（包括字符串），那么其在类加载过程中的<strong>初始化环节</strong>中会初始化赋值。</li><li>所以，无论是否final，基本类型的static成员变量都在堆中（伴随Class对象）</li></ul></li></ul>          </div><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。<br>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h3><ul><li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值</li><li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行，即<code>String a = &quot;12&quot;</code>形式。</li><li>在初始化阶段<code>&lt;clinit&gt;()</code>中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</li></ul><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit"></a>clinit</h3><p>该方法是带锁，线程安全的。只会被执行一次。</p><h3 id="类的初始化情况"><a href="#类的初始化情况" class="headerlink" title="类的初始化情况"></a>类的初始化情况</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p>总之是需要使用到类的字段或方法的情况。</p><ul><li>实例化</li><li>调用静态方法</li><li>获取静态字段</li><li>使用反射（包括<strong>forName</strong>）</li><li>继承该类</li><li>default方法</li><li>包含main方法</li><li>被指定调用MethodHandler</li></ul><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了以上情况都是被动使用，比如：</p><ul><li>通过子类引用父类的静态变量，子类不会初始化。</li><li>数组定义，定义某种类型的数组</li><li>引用某个的常量static final（常量在链接的准备阶段就已经完成赋值）</li><li><code>loadClass()</code>也不会主动初始化。</li></ul><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>类加载器</strong>与<strong>被该加载器加载的类</strong>的内部实现中，存在着双向引用。因此根据GC的原理，当某一个类的Class对象不再被引用时，即可回收，因此回收类的前提是回收其加载器。</p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li><strong>启动类加载器</strong>加载的类型在整个运行期间是<strong>不可能被卸载的。</strong></li><li><strong>系统类加载器和扩展类加载器</strong>加载的类型在运行期间<strong>不太可能被卸载</strong>。</li><li>被开发者<strong>自定义的类加载器</strong>实例加载的类型<strong>只有在很简单的上下文环境中才能被卸载</strong>，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。</li></ul><h3 id="卸载前提"><a href="#卸载前提" class="headerlink" title="卸载前提"></a>卸载前提</h3><ul><li>所有类实例被回收</li><li>所有对该类的引用被回收</li><li>该类的加载器被回收</li></ul><h1 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。</p><p>ClassLoader在整个装载阶段，<strong>只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为</strong>。至于它是否可以运行，则由Execution Engine决定。</p><div class="note note-primary">            <p>ClassLoader只定义类加载中的<strong>加载环节的细节</strong>。</p>          </div><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="加载方式分类"><a href="#加载方式分类" class="headerlink" title="加载方式分类"></a>加载方式分类</h3><ul><li>显式加载：反射</li><li>隐式加载：JVM加载</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成。</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p><strong>类的唯一性：由加载器和该类共同决定其唯一性。</strong></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>可见性，子加载器可以看见父加载器加载的类型，反之则不行。</li><li>单一性，由于可见性，父加载器加载的类不会被子加载器重复加载。</li></ul><h2 id="加载器分类"><a href="#加载器分类" class="headerlink" title="加载器分类"></a>加载器分类</h2><ul><li>引导类加载器（Bootstrap ClassLoader）</li><li>自定义类加载器（User-Defined ClassLoader）</li></ul><p>加载器之间不是继承关系，而是<strong>包含关系</strong>，子加载器包含父加载器的引用，因此其可以看见父加载器加载的内容（可见性），以及调用父加载器（实现双亲委派机制）。</p><h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><h4 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h4><ul><li>C&#x2F;C++实现，在JVM内部实现</li><li>加载核心库</li><li>没有父加载器</li></ul><h3 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h3><h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>加载ext.dirs目录下的类库</li><li>父类加载器为启动类加载器</li><li>直接继承于URLClassLoader，最终继承于ClassLoader类（一个抽象类）</li></ul><h4 id="系统类加载器（AppClassLoader）"><a href="#系统类加载器（AppClassLoader）" class="headerlink" title="系统类加载器（AppClassLoader）"></a>系统类加载器（AppClassLoader）</h4><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li>父类加载器为扩展类加载器</li><li>直接继承于URLClassLoader，最终继承于ClassLoader类（一个抽象类）</li></ul><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><p>可以通过自定义实现插件机制，此外加载器可以实现应用隔离。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="ClassLoader主要方法"><a href="#ClassLoader主要方法" class="headerlink" title="ClassLoader主要方法"></a>ClassLoader主要方法</h3><p>ClassLoader是一个抽象类，基本java实现的加载器都继承自它。<br>其有以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span><br><span class="hljs-comment">//加载</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br><span class="hljs-comment">//链接</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span><br></code></pre></td></tr></table></figure><ul><li>其中，<code>loadClass()</code>会调用<code>findClass()</code>，而loadClass中实现了双亲委派机制，因此自定义加载器时，尽量只重写findClass()及其调用的方法。</li><li><code>findClass()</code>会调用<code>defineClass()</code>，其指明如何将byte流解析成Class对象。</li></ul><h3 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h3><ul><li>SecureClassLoader继承并扩展了ClassLoader功能，添加了权限认证。</li><li>URLClassLoader继承并扩展了SecureClassLoader，其对ClassLoader中的许多抽象方法做了具体的实现。</li><li>一般自定义加载类直接继承URLClassLoader非常方便。</li></ul><h3 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h3><ul><li>JDK8中，这两个类都继承自URLClassLoader</li><li>JDK9中，这两个类都继承自BuiltinClassLoader</li></ul><h3 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h3><ul><li>前者会初始化，后者不会。</li><li>后者需要指定一个具体的加载器加载。</li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先交给父类加载器加载，加载失败再由子类加载。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202001557.png"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>搜索类，有则返回</li><li>有父类则委托加载</li><li>无父类则使用引导类加载器加载（必须委托一次引导类，实现保护的核心API的功能）</li><li>都失败则主动加载</li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>避免重复加载</li><li>保护核心类库</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>顶层无法访问底层加载器，系统类无法访问应用类，无法在系统类的方法中调用应用类。</li></ul><div class="note note-primary">            <p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</p>          </div><h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><h4 id="第一次：覆盖loadClass"><a href="#第一次：覆盖loadClass" class="headerlink" title="第一次：覆盖loadClass"></a>第一次：覆盖loadClass</h4><p>双亲委派机制推出前就有ClassLoader存在，loadClass方法已经被用户使用自定义加载器覆盖（没有双亲委派），后来才推荐用户改写findClass。</p><h4 id="第二次：线程上下文类加载器"><a href="#第二次：线程上下文类加载器" class="headerlink" title="第二次：线程上下文类加载器"></a>第二次：线程上下文类加载器</h4><p>解决系统类无法调用用户类的缺点，如JNDI服务就需要调用，管理用户类。</p><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202002835.png"><br>父类加载器可以通过线程上下文类加载器委托给子类加载器完成类的加载。这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h4 id="第三次：用户的要求"><a href="#第三次：用户的要求" class="headerlink" title="第三次：用户的要求"></a>第三次：用户的要求</h4><p>第三次破坏源于用户需求：代码热替换(Hot Swap)、模块热部署(Hot Deployment)等。</p><p>背景：IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>搜索顺序：</p><ol><li>java.开头，委托父类（双亲）</li><li>若在委派列表名单中，委托父类（双亲）</li><li>在各种列表中寻找类加载器进行加载（平行）</li></ol><p>PS：了解一下就行。</p><h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003613.png"></p><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><p>Java安全模型的核心就是Java沙箱。即将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源（CPU、内存、文件系统、网络）访问。</p><h3 id="JDK1-0"><a href="#JDK1-0" class="headerlink" title="JDK1.0"></a>JDK1.0</h3><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003843.png"></p><h3 id="JDK1-1"><a href="#JDK1-1" class="headerlink" title="JDK1.1"></a>JDK1.1</h3><p>增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003849.png"></p><h3 id="JDK1-2"><a href="#JDK1-2" class="headerlink" title="JDK1.2"></a>JDK1.2</h3><p>改进了安全机制，增加了<strong>代码签名</strong>。由<strong>类加载器</strong>加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。<br><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003938.png"></p><h3 id="JDK1-6"><a href="#JDK1-6" class="headerlink" title="JDK1.6"></a>JDK1.6</h3><p>虚拟机会把所有代码加载到不同的系统域和应用域。</p><p>系统域专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。</p><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202003950.png"></p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>隔离加载类（容器隔离）</li><li>修改类的加载方式（动态加载）</li><li>扩展加载源（数据库，网络）</li><li>防止源码泄漏（加密）</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>方式</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法，推荐<br>说明</li><li>其父类加载器是系统类加载器</li></ul><h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</li><li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/323cfcda53f98034ed15372c0ea43685.png"></p><ol start="3"><li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li><li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li><li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ol><p><img src="/2023/02/01/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%AD%E7%AF%87-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/Pasted-image-20230202004846.png"></p><div class="note note-primary">            <p>总结就是：</p><ol><li>ext改名plat</li><li>新增getName()方法</li><li>plat和app不再继承url，而是builtin</li><li>引导类由java实现</li><li>双亲委托前可直接判断所属系统并交付</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM上篇:内存与垃圾回收</title>
    <link href="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JVM与Java体系"><a href="#一、JVM与Java体系" class="headerlink" title="一、JVM与Java体系"></a>一、JVM与Java体系</h1><ul><li>JVM只关心字节码文件</li><li>虚拟机是对物理计算机的模仿</li><li>JVM是运行在操作系统之上的，不直接与硬件交互<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140012.png"></li></ul><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140104.png"></p><h2 id="Java代码执行顺序"><a href="#Java代码执行顺序" class="headerlink" title="Java代码执行顺序"></a>Java代码执行顺序</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140118.png"></p><h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><ul><li>栈式架构<br>实现更简单，不需要硬件支持，指令集更小，跨平台</li><li>寄存器架构<br>指令集架构则完全依赖硬件，可移植性差</li></ul><h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</strong></p><h3 id="虚拟机退出的情况"><a href="#虚拟机退出的情况" class="headerlink" title="虚拟机退出的情况"></a>虚拟机退出的情况</h3><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。<br>总结：一个正常执行完毕，两个错误终止，两个手动终止。</li></ul><h1 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h1><h2 id="类加载器与类加载过程"><a href="#类加载器与类加载过程" class="headerlink" title="类加载器与类加载过程"></a>类加载器与类加载过程</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123140856.png"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li><li><strong>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</strong></li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</li></ul><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ol><li>通过类的全限定名定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><div class="note note-primary">            <p>这里注意，加载阶段就完成了方法区数据结构的装载和Class对象的生成，但此时还没有进行类初始化，即此时类中的字段还没有初始化。</p>          </div><h4 id="补充：class文件来源"><a href="#补充：class文件来源" class="headerlink" title="补充：class文件来源"></a>补充：class文件来源</h4><ul><li>本地</li><li>网络</li><li>动态代理，动态生成</li><li>压缩包</li><li>JSP</li><li>数据库</li><li>加密文件</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<strong>文件格式验证(文件格式、魔数、长度等)，元数据验证（继承关系是否合法等），字节码验证（方法体是否合法等），符号引用验证（引用类型是否存在等）</strong>。</li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li><strong>这里不包含用final修饰的static，因为final static在编译的时候就会分配了，准备阶段会显式初始化；</strong></li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<strong>符号引用转换为直接引用</strong>的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。符号引用就是一组符号来描述所引用的目标。</li><li>符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><strong>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。</strong></li><li>该阶段是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和<strong>静态代码</strong>块中的语句合并而来。</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</li></ul><div class="note note-primary">            <ul><li>加载阶段负责把字节码的二进制文件加载到方法区，并根据字节码在堆中生成class对象</li><li>链接阶段负责检验class文件的正确性、为类的变量分配内存并设置默认值（0值）、解析时将符号应用转换为直接引用。</li><li>初始化负责对类变量、static块执行赋值。</li></ul>          </div><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><ul><li>分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li><li>Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144137.png"></li></ul><h3 id="自带的加载器"><a href="#自带的加载器" class="headerlink" title="自带的加载器"></a>自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li><strong>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</strong></li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li><strong>并不继承自ava.lang.ClassLoader，没有父加载器。</strong></li><li><strong>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</strong></li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ul><div class="note note-primary">            <ul><li>引导类加载器不继承ClassLoader；其他类都继承该抽象类，被称为自定义类加载器。</li></ul>          </div><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>启动类加载器</strong></li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为<strong>扩展类加载器</strong></li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过ClassLoader.getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><div class="note note-primary">            <p>具体到类加载过程中的步骤，其可以加密（防止源码泄漏），可以扩展加载的源（如网络），可以修改类的加载方式并隔离加载类（热部署）。</p>          </div><p>实现步骤：</p><ul><li>JDK1.2之前，继承ClassLoader，覆盖loadClass方法。</li><li>JDK1.2之后，继承ClassLoader，覆盖findClass方法（其被loadClass方法调用）。</li><li>没有复杂需求时，直接继承URLClassLoader，避免自己编写findClass。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123144950.png"></li></ul><h3 id="获取ClassLoader方法"><a href="#获取ClassLoader方法" class="headerlink" title="获取ClassLoader方法"></a>获取ClassLoader方法</h3><ul><li>clazz.getClassLoader()</li><li>Thread.currentThread().getContextClassLoader() &#x2F;&#x2F;上下文线程的加载器</li><li>ClassLoader.getSystemClassLoader() &#x2F;&#x2F;系统类加载器</li><li>DriverManager.getCallerClassLoader() &#x2F;&#x2F;调用者的加载器</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><ul><li>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式</li><li>加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</li></ul><p><strong>原理</strong><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145155.png"><br>具体实现在loadClass()方法中。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>如何判断两个class对象是否相同</strong><br>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。</li></ul><p><strong>对类加载器的引用</strong></p><ul><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</li><li>如果一个类型是由用户类加载器加载的，那么<strong>JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li></ul><div class="note note-primary">            <p>不同类加载器加载的对象解析需要其在同一个域。</p>          </div><p><strong>主动使用与被动使用</strong><br>对类的成员的调用：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>初始化一个类的子类</li></ul><p>规范：</p><ul><li>反射（比如：Class.forName（”com.atguigu.Test”））</li><li>Java虚拟机启动时被标明为<strong>启动类</strong>的类</li><li>JDK 7 开始提供的动态语言支持：<br>  java.lang.invoke.MethodHandle实例的解析结果<br>  REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ul><p>除了以上七种情况，其他使用Java类的方式都被看作是对<strong>类的被动使用</strong>，都不会导致<strong>类的初始化</strong>。</p><h1 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h1><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123145718.png"></p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p>PS：JVM允许一个应用有多个线程并行的执行。在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><h2 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h2><ul><li>虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。</li></ul><div class="note note-primary">            <p>可以理解为JVM后台运行的线程，其中虚拟机线程是管理其他线程的线程，其令JVM达到安全点才调用执行一些操作，如Stop-the-world，线程栈收集，线程挂起，偏向锁撤销。</p>          </div><h2 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h2><p>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123150208.png"><br>作用：<br>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是<strong>运行速度最快的存储区域</strong>。</li><li>在JVM规范中，<strong>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</strong></li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；<strong>或者，如果是在执行native方法，则是未指定值（undefined）</strong>。</li></ul><div class="note note-primary">            <p>每个线程都拥有一个PC计数器，相互隔离（私有），标识当前线程的执行点，这样执行引擎就会执行该地址代码。</p>          </div><p><strong>为什么使用PC寄存器记录当前线程的执行地址呢？</strong><br>CPU可能会分片执行，切换线程后需要知道从哪里开始执行。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。</p><ul><li><strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，是线程私有的。</li><li>生命周期和线程一致</li><li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</li><li>JVM对栈的操作仅有，出栈，入栈。</li></ul><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><code>StackOverflowError</code>，超过设定的栈容量</li><li><code>OutOfMemoryError</code>，整体内存空间不足。</li></ul><p>**设置大小方法:</p><ul><li>**<code>-Xss</code></li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><ul><li>栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong>。</li><li>栈帧<strong>先进后出</strong>，一个线程只有一个活动栈帧，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong>。</li></ul><p>Java方法有两种返回函数的方式：</p><ul><li>一种是正常的函数返回，使用return指令；</li><li>另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><h3 id="栈帧中的内容"><a href="#栈帧中的内容" class="headerlink" title="栈帧中的内容"></a>栈帧中的内容</h3><ul><li><strong>局部变量表（Local Variables）</strong></li><li><strong>操作数栈（operand Stack）（或表达式栈）</strong></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul><li>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li></ul><h5 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h5><ul><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li><li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</li><li><strong>byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</strong></li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li><strong>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。</strong>（比如：访问long或doub1e类型变量）</li><li>如果当前帧是由<strong>构造方法或者实例方法</strong>创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li></ul><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123151728.png"><br>另外，Slot空间可以被复用，如某些局部变量超出作用域后，新的局部变量可以复用该位置。</p><h5 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h5><p>Static：类变量表有两次初始化的机会：</p><ul><li>第一次是在“链接阶段中的准备阶段”，执行系统初始化，对类变量设置零值。</li><li>另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li></ul><p>局部变量表：不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 操作数栈，也可以称之为表达式栈（Expression Stack）</p><div class="note note-primary">            <p>虚拟机栈指的就是整个线程栈，线程栈分若干个栈帧，栈帧中又有操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p>          </div><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123152330.png"></p><p>PS：每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</strong>，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>我们说Java虚拟机的<strong>解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈。</p><h5 id="栈顶缓存-Top-Of-Stack-Caching-技术"><a href="#栈顶缓存-Top-Of-Stack-Caching-技术" class="headerlink" title="栈顶缓存(Top Of Stack Caching)技术"></a>栈顶缓存(Top Of Stack Caching)技术</h5><p>操作数是存储在内存中的，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接、方法返回地址、附加信息有时被一起称为帧数据区。</p><p>每一个栈帧内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。通过这个引用，可以实现动态链接。</p><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230123154403.png"></p><div class="note note-primary">            <p>现有动态链接，再有栈帧！<br>比如，现在某对象A在方法A0中调用对象B的一个方法B0，字节码文件如下：<br>invokeVirtual B0</p><p>此时虚拟机会根据操作数栈顶的对象类型，根据<strong>字符串</strong>查找其方法中类元信息中的<strong>方法入口</strong>。<br>但是每次调用方法都扫描查找一次类信息是很繁琐的，在方法区的运行时常量池中，直接保存了字符串与方法入口地址的对应关系（直接引用），这个对应关系也叫类B的Vtable。</p>          </div><p>比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，<strong>动态链接的作用就是为了将这些符号引用转换位调用方法的直接引用</strong>。</p><div class="note note-primary">            <p>个人理解：某个方法A可能会调用其他方法B，在执行引擎遇到调用其方法的语句如invokeVirtual时，需要找到方法B的入口。<br>而栈帧中保存了一个指针，指向了方法B符号在运行时常量池中的位置，再通过运行时常量池，实现将符号引用转化为直接引用。</p>          </div><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置</strong>。</p><ul><li>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</li><li>通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。<br>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>目标方法在编译期可知，且运行期保持不变时。对应<strong>早期绑定</strong>，调用非虚方法。</p><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用。对应<strong>晚期绑定</strong>，调用虚方法。</p><h4 id="方法绑定"><a href="#方法绑定" class="headerlink" title="方法绑定"></a>方法绑定</h4><p>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><ul><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通方法调用</span><br>invokestatic：调用静态方法，解析阶段确定唯一方法版本<br>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本<br>invokevirtual：调用所有虚方法<br>invokeinterface：调用接口方法<br><br><span class="hljs-comment">//动态方法调用</span><br>invokedynamic：动态解析出需要调用的方法，然后执行<br></code></pre></td></tr></table></figure><p><strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><p><code>invokedynamic</code>在JAVA7中才出现，但没有直接生成该指令，在JAVA8中的Lambda表达式可以生成<code>invokedynamic</code></p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>也就是前面动态链接中提到的Vtable，每个类都有一个这样的虚方法表存在于方法区，便于查找方法的真实入口。</p><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>根据操作数栈顶元素的实际对象类型寻找方法</li><li>找到后使用权限校验，通过则调用，不通过则报异常</li><li>找不到则根据继承关系循环进行1，2步</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsrror异常。</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>方法中定义的局部变量是否线程安全？<br>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><h2 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>native修饰的方法<br>主要用于与外部环境、操作系统交互，调用C语言实现的方法等。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>实现本地方法的管理调用，也是每个线程持有一个。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129213758.png"></p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>这个图有点问题</p><ul><li>本地方法入栈后，执行引擎会调用本地方法库执行本地方法。</li><li><strong>本地方法接口</strong>则是<strong>本地方法访问虚拟机内部数据</strong>的接口。</li></ul><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。</p><p>并不是所有JVM都支持本地方法。<br><strong>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆空间结构"><a href="#堆空间结构" class="headerlink" title="堆空间结构"></a>堆空间结构</h3><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214614.png"><br>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129214618.png"></p><p><strong>堆空间大小设置</strong></p><ul><li>“-Xms”用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li>“-Xmx”则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code><br>默认Xms:电脑内存&#x2F;64<br>默认Xmx:电脑内存&#x2F;4</li></ul><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129215125.png"></p><ul><li>可以设置新生代&#x2F;老年代占比：默认<code>-XX:NewRatio=2</code></li><li>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1，可以使用<code>-XX:SurvivorRatio</code></li><li>可以使用<code>-Xmn</code>设置新生代最大内存大小。</li></ul><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><h4 id="小对象分配原则"><a href="#小对象分配原则" class="headerlink" title="小对象分配原则"></a>小对象分配原则</h4><ul><li><code>Eden</code>出生，一次MinorGC后进入<code>Survivor</code></li><li>15次（使用-XX:MaxTenuringThreshold&#x3D;N调整）Survivor移动后进入<code>Old</code>。</li><li><code>Old</code>若被MajorGC可能会清理，若无法保存则报OOM。</li></ul><h4 id="其他分配原则"><a href="#其他分配原则" class="headerlink" title="其他分配原则"></a>其他分配原则</h4><ul><li>大对象直接分配到老年代（尽量避免程序中出现过多的大对象）</li><li>动态对象年龄判断：如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</li><li>空间分配担保（-XX:HandlerPromotionFailure），开启时：<ul><li>MinorGC前检查老年代是否有连续空间容纳新生代的对象空间。<ul><li>若有，则可以执行MinorGC</li><li>若无，检查是否开启空间分配担保<code>-XX:HandlePromotionFailure</code><ul><li>若开启，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。<ul><li>若大于，则进行一次MinorGC（有风险）</li><li>若小于，FullGC</li></ul></li><li>否则，FullGC</li></ul></li></ul></li></ul></li></ul><div class="note note-primary">            <p>为什么需要空间担保：<br>minorGC时可能直接将大量Survivor区对象直接放入Old区，此时需要Old区保证能接受这些对象，若老年代剩余空间&gt;新生代所有对象大小，则肯定可以接受。若空间&lt;对象大小，则可以根据之前的回收情况预估实际进入老年代的对象大小，判断是否需要据此进行冒险的MinorGC，以避免盲目的FullGC。<br><strong>JDK7及以后已经弃用。此后，默认会进行冒险行为，否则FullGC。</strong></p>          </div><h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>Thread Local Allocation Buffer，堆是所有线程共享的，因此也是线程不安全的。TLAB表示JVM为每个线程提供一个私有缓存空间供其为对象分配内存，大小默认为1%的Eden区大小。<br>可以通过<code>-XX:UseTLAB</code>决定是否开启TLAB，通过<code>-XX:TLABWasteTargetPercent</code>决定TLAB占用Eden空间的大小。</p><h3 id="Minor-GC，MajorGC、Full-GC"><a href="#Minor-GC，MajorGC、Full-GC" class="headerlink" title="Minor GC，MajorGC、Full GC"></a>Minor GC，MajorGC、Full GC</h3><p>GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）。</p><ul><li>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><h4 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h4><p>Eden满，需要清理Eden，STW。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230129220927.png"></p><h4 id="MajorGC-x2F-FullGC"><a href="#MajorGC-x2F-FullGC" class="headerlink" title="MajorGC&#x2F;FullGC"></a>MajorGC&#x2F;FullGC</h4><p>Old区不够用时发生，Major发生总是伴随着MinorGC，但不绝对，STW。</p><h4 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h4><ol><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。</li></ol><p>要尽量避免FullGC，其耗时太长。</p><h3 id="堆是分配对象的唯一选择吗？"><a href="#堆是分配对象的唯一选择吗？" class="headerlink" title="堆是分配对象的唯一选择吗？"></a>堆是分配对象的唯一选择吗？</h3><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。</p><p>JDK6u23后默认开启逃逸分析，此前需要：</p><ul><li>选项”<code>-XX:+DoEscapeAnalysis</code>“显式开启逃逸分析</li><li>通过选项”<code>-XX:+PrintEscapeAnalysis</code>“查看逃逸分析的筛选结果</li></ul><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><ul><li>栈上分配：对象不发生方法逃逸。</li><li>同步省略：对象不发生线程逃逸（其他线程不访问该对象），也叫<strong>锁消除</strong>。</li><li>标量替换：将对象结构体（聚合量）替换为一个个属性（标量，基本类型）。使用<code>-XX:EliminateAllocations</code>开启。</li></ul><p>逃逸分析不成熟，因为分析性能不一定优于优化性能。<br><strong>Hotspot中的所有对象都建立在堆上。</strong></p><div class="note note-primary">            <p>JDK7前，字符串常量池在永久代上，后来永久代被元空间取代，而字符串常量池迁移到堆中，符合了所有对象都建立在堆上的结论。</p>          </div><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>方法区是一个独立于java堆的内存空间。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131114507.png"><br>前面的概念中有提到，方法区只是一个逻辑上的概念。在JDK8之前，方法区由永久代实现，JDK8之后，方法区由元空间实现，其独立于java堆空间，直接使用本地内存（但是也可能报OOM，本地内存的大小也是有限的）。</p><h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3><h4 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h4><ul><li>初始：<code>-XX:Permsize</code></li><li>最大：<code>-XX:MaxPermsize</code></li></ul><h4 id="jdk8之后"><a href="#jdk8之后" class="headerlink" title="jdk8之后"></a>jdk8之后</h4><ul><li>初始：<code>-XX:MetaspaceSize</code></li><li>最大：<code>-XX:MaxMetaspaceSize</code>(设置为-1则不受限制)</li></ul><h3 id="存储什么"><a href="#存储什么" class="headerlink" title="存储什么"></a>存储什么</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><ol><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型直接接口的一个有序列表</li></ol><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ol><li>域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li><li>域类型</li><li>域名称</li></ol><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><ol><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的返回类型（或void）</li><li>方法名称</li><li>方法参数的数量和类型（按顺序）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）。每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><div class="note note-primary">            <p>简而言之，我们java文件中写的内容基本都会保存到方法区中。</p>          </div><h4 id="对于static-x2F-final"><a href="#对于static-x2F-final" class="headerlink" title="对于static&#x2F;final"></a>对于static&#x2F;final</h4><ul><li>若符号由static修饰，说明是类变量，在类的加载过程中生成。</li><li>若符号由static final修饰，说明是常量，在编译时即完成分配。</li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131120156.png"></p><h5 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h5><p>常量池也称静态常量池，每个类的字节码文件（.class）中都具有一个常量池表，其描述了各种<strong>字面量</strong>与<strong>类、域、方法</strong>的<strong>符号引用</strong>。<br>而常量池中一般存储有：</p><ul><li>字段复用<ul><li>数量值</li><li>字符串值</li></ul></li><li>类及成员<ul><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li></ul><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用。<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>，<strong>一个类加载到 JVM 中后对应一个运行时常量池</strong>。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</li></ul><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池是全局</strong>的，里面存储的是字符串对象，而不是字面量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据常量池的字面量在准备阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span><br><span class="hljs-comment">//属于引用类型，在初始化阶段赋值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li>常量池存在于Class文件中，表现为 序号（”#1”） 到 字面量（”java&#x2F;lang&#x2F;Object”）的映射</li><li>运行时常量池存在于方法区，表现为 序号（”#1”）到 字面量（基本类型） 或 真实地址的映射。</li><li>常量池在类的加载过程的<strong>链接阶段</strong>的<strong>解析阶段</strong>，会将常量池中的字面量解析为真实地址。</li></ul>          </div><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><table><thead><tr><th>JDK1.6及之前</th><th>有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><div class="note note-primary">            <ul><li>字符串常量池移动到了堆中，但运行时常量池依然在元空间。</li><li>元空间中可能持有字符串的引用。</li></ul>          </div><h4 id="为什么要使用元空间"><a href="#为什么要使用元空间" class="headerlink" title="为什么要使用元空间"></a>为什么要使用元空间</h4><ul><li>永久代大小不应限制，使用元空间使用本地内存</li><li>永久代很难调优，GC起来很困难，类的卸载条件很苛刻。</li></ul><h4 id="StringTable为何换位置"><a href="#StringTable为何换位置" class="headerlink" title="StringTable为何换位置"></a>StringTable为何换位置</h4><p>字符串的创建和回收是很频繁的，放在永久代不宜回收（只有FullGC），而放在堆中可以及时回收。</p><h4 id="静态变量存放在哪"><a href="#静态变量存放在哪" class="headerlink" title="静态变量存放在哪"></a>静态变量存放在哪</h4><p>虚拟机规范要求将class相关信息放置于方法区中，但没有限制方法区的实现，所以HotSpot选择将静态变量随着class对象一起放在堆中。</p><h4 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h4><p>方法区主要回收常量池中废弃的常量和不再使用的类型。</p><ul><li>常量：不再被使用即可回收。</li><li>类型：<ul><li>所有对象已经回收</li><li>所有对该类的引用已经被回收</li><li>对于的类加载器已经被回收</li></ul></li></ul><p>满足类型的回收条件也只是允许回收，并不是必然的。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>元空间使用直接内存，NIO（Native IO）时也可以使用直接内存</p><h4 id="非直接内存"><a href="#非直接内存" class="headerlink" title="非直接内存"></a>非直接内存</h4><p>使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><h4 id="直接内存-1"><a href="#直接内存-1" class="headerlink" title="直接内存"></a>直接内存</h4><p>使用NIO时，操作系统划出的直接缓存区可以被java代码直接访问，只有一份。NIO适合对大文件的读写操作。<br>直接内存可以通过<code>MaxDirectMemorySize</code>设置，不指定时与-Xmx参数一致。</p><h1 id="四、对象的实例化过程"><a href="#四、对象的实例化过程" class="headerlink" title="四、对象的实例化过程"></a>四、对象的实例化过程</h1><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><ul><li>new：最常见的方式、Xxx的静态方法，XxxBuilder&#x2F;XxxFactory的静态方法</li><li>Class的newInstance方法：反射的方式，只能调用空参的构造器，权限必须是public</li><li>Constructor的newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口，实现clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis</li></ul><div class="note note-primary">            <ul><li>new，类，构造器的构造方法是一般的生成新对象方法。</li><li>clone和序列化是复制对象的方法。</li><li>第三方库</li></ul>          </div><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol><li>判断对象对应的类是否加载、链接、初始化<ul><li>元空间查找</li><li>失败，双亲委派加载（classloader+包名+类名）</li><li>失败，抛出异常</li></ul></li><li>为对象分配内存（具体如何分配取决于java堆的GC功能）<ul><li>有规整的内存（使用指针碰撞法时）</li><li>内存不规整（需要维护一个空闲列表）</li></ul></li><li>处理并发问题：保证更新的原子性</li><li>初始化分配到的内存（所有对象赋默认值，0值）</li><li>设置对象的对象头</li><li>init方法初始化（显示、代码块，构造器）</li></ol><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130349.png"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包含了两部分，分别是运行时元数据（Mark Word）和类型指针。如果是数组，还需要记录数组的长度。</p><h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><p>详情见JUC</p><ul><li>哈希值（HashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据InstanceKlass，确定该对象所属的类型。</p><h3 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h3><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><h2 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h2><p>有以下两种模式</p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130511.png"><br>优点在于，若对象被移动只需要修改句柄池</p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130542.png"><br>HotSpot采用这种方式，访问快速。</p><h1 id="五、执行引擎"><a href="#五、执行引擎" class="headerlink" title="五、执行引擎"></a>五、执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎属于JVM的下层，里面包括<strong>解释器、及时编译器、垃圾回收器</strong><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131130915.png"><br>执行引擎的任务就是将字节码指令解释&#x2F;编译成本地平台上的本地机器指令。</p><p>工作流程：执行引擎执行PC寄存器指向的指令，PC寄存器指向下一条指令。</p><h2 id="编译与执行过程"><a href="#编译与执行过程" class="headerlink" title="编译与执行过程"></a>编译与执行过程</h2><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131115.png"></p><ol><li>Java代码编译是由Java源码编译器（前端编译器）来完成，流程图如下所示：<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131132.png"></li><li>Java字节码的执行是由JVM执行引擎（后端编译器）来完成，流程图 如下所示<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131131139.png"></li></ol><h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器：对字节码逐行解释成机器码并执行。<br>编译器：</p><ul><li>前端编译器：将java代码编译成class字节码文件</li><li>后端编译器（JIT编译器）：将源代码直接编译成机器语言。</li></ul><p>java是一门半解释半编译的语言。</p><h2 id="指令基本概念"><a href="#指令基本概念" class="headerlink" title="指令基本概念"></a>指令基本概念</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><p>二进制指令，与CPU相关</p><h3 id="指令与指令集"><a href="#指令与指令集" class="headerlink" title="指令与指令集"></a>指令与指令集</h3><p>将二进制指令使用mov,inc等人类可读的方式表示。不同机器上指令对应的机器码可能不同。每个平台所支持的所有指令，称之为对应平台的指令集。即指令的集合。如-86，ARM</p><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><p>用助记符代替机器指令的操作码，使用汇编语言编写的程序需要翻译成机器指令码才能被识别、执行。</p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>高级语言比机器语言、汇编语言更接近人的语言。当计算机执行高级语言编写的程序时，仍然<strong>需要把程序解释和编译成机器的指令码</strong>。<br>一般都是高级指令翻译成汇编语言，然后翻译成机器指令才能被执行。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>为了实现跨平台，没有采用静态编译生成机器指令，而是生成class文件，由解释器实现跨平台。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><ol><li>字节码解释器：纯软件代码模拟字节码执行。</li><li>模板解释器：每一条字节码和一个模板函数相关联。</li></ol><p>HotSpotVM中，解释器由Interpreter模块和Code模块构成。</p><ul><li>Interpreter模块：实现了解释器的核心功能，将字节码翻译为机器码</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>基于解释器执行已经沦落为低效的代名词<br>为了解决该问题，JVM平台支持一种叫作即时编译的技术（JIT），将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可。</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>JIT编译器属于后端编译器，将字节码翻译为机器码，是一种即时编译器。<br>HopSpot VM使用了<strong>解释器和即时编译器并存的架构</strong>。</p><p>有了JIT，为什么还要解释器？</p><ul><li>快启动</li><li>编译器无法优化程序时，解释器是逃生门</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JIT的编译器还分为了两种，分别是C1和C2。<br>开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li><li><code>-server</code>：指定Java虚拟机运行在server模式下，并使用C2编译器。C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。</li><li><strong>分层编译（Tiered Compilation）策略</strong>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。<br>Java7后，就算开启-server模式也会默认使用分层编译。</li></ul><h4 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h4><p>C1编译器上主要有方法内联、去虚拟化、冗余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><h4 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h4><p>C2的优化主要是在全局层面，做逃逸分析</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul><h2 id="HopSpotJVM执行方式"><a href="#HopSpotJVM执行方式" class="headerlink" title="HopSpotJVM执行方式"></a>HopSpotJVM执行方式</h2><p>解释器先发生作用，即时编译器根据热点探测将有价值的字节码编译为本地机器指令。</p><ul><li>JIT编译器是<strong>后端运行时编译器</strong>（Just In Time Compiler）,将字节码编译成本地机器指令。</li><li>AOT编译器是<strong>静态提前编译器</strong>（Ahead Of Time），将java文件编译成本地机器指令。</li></ul><h3 id="热点代码及探测"><a href="#热点代码及探测" class="headerlink" title="热点代码及探测"></a>热点代码及探测</h3><h4 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h4><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”。因而可以通过JIT编译器编译为本地机器指令，这种方式叫做栈上替换，或称为OSR（On Stack Replacement）编译。</p><h4 id="热点探测功能"><a href="#热点探测功能" class="headerlink" title="热点探测功能"></a>热点探测功能</h4><p>HotSpot使用的热点探测方式是<strong>基于计数器</strong>的热点探测。</p><p>HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器</strong>（Invocation Counter）和<strong>回边计数器</strong>（Back Edge Counter）。</p><ul><li>方法调用计数器用于统计方法的调用次数。</li><li>回边计数器则用于统计方法内循环体执行的循环次数。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>Client模式下默认1500次，Server模式下默认10000次。<br>可以通过<code>-XX:CompileThreshold</code>来人为设定阈值。</p><p>如果发现<strong>方法调用计数器和回边计数器之和</strong>超过了阈值，则会提交JIT即时编译请求。</p><h4 id="热点衰退"><a href="#热点衰退" class="headerlink" title="热点衰退"></a>热点衰退</h4><p>方法调用计数器统计的并<strong>不是方法被调用的绝对次数</strong>，而是一个相对的执行频率，即一段时间之内方法被调用的次数。<br>当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减（Counter Decay）</strong>，而这段时间就称为此方法统计的<strong>半衰周期（Counter Half Life Time）</strong><br>热点衰退在GC时顺便进行，可以使用<code>-XX:-UseCounterDecay</code>设置关闭热点衰减，使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h3 id="HotSpotVM-可以设置程序执行方法"><a href="#HotSpotVM-可以设置程序执行方法" class="headerlink" title="HotSpotVM 可以设置程序执行方法"></a>HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li><code>-Xint</code>：完全采用解释器模式执行程序；</li><li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h1 id="六、StringTable"><a href="#六、StringTable" class="headerlink" title="六、StringTable"></a>六、StringTable</h1><h2 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h2><ul><li>字符串</li><li>final，不可继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。</li><li>String实现了Comparable接口：表示string可以比较大小</li><li>String在jdk8及以前内部定义了<code>final char[] value</code>用于存储字符串数据。JDK9时改为<code>byte[]</code>。</li></ul><h2 id="为什么修改String底层"><a href="#为什么修改String底层" class="headerlink" title="为什么修改String底层"></a>为什么修改String底层</h2><p>原因：<code>char[]</code>数组中大多数char属于Latin-1字符，使用1byte即可表示，但char需要2byte，空间浪费。</p><p>改进：为String提供两种字符集使用（Latin-1或UTF-16）。</p><h2 id="StringPool"><a href="#StringPool" class="headerlink" title="StringPool"></a>StringPool</h2><p>String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。</p><p>使用<code>-XX:StringTablesize</code>可设置StringTable的长度</p><ul><li>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize设置没有要求</li><li>在jdk7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，设置StringTable长度的话，1009是可以设置的最小值</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul><li>直接使用双引号声明出来的String对象会直接存储在<strong>常量池</strong>中。</li><li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</li><li>使用new，生成的对象在堆中，不入池。</li></ul><h3 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>Java 6及以前，字符串常量池存放在永久代<br>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内<br>Java 8元空间，字符串常量池在堆内。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><code>String str =&quot;ab&quot; + &quot;cd&quot;</code>创建了1个对象，因为”ab”+”cd”会被编译器优化，只在常量池创建一个”abcd”并返回。</li><li><code>String str = new String(&quot;123&quot;)</code>创建了2个对象，一个”123”在字符串常量池，一个new String在堆中，返回堆中对象。</li></ul><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><ul><li><strong>常量(final)与常量(final)</strong> 的拼接结果在常量池，原理是编译期优化</li><li><strong>只要其中有一个是变量</strong>，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</li></ul><h4 id="优化拼接"><a href="#优化拼接" class="headerlink" title="优化拼接"></a>优化拼接</h4><ul><li>尽量使用<strong>StringBuilder.append()</strong></li><li>可以在初始化时，指定StringBuilder的capacity，减少扩容次数。</li></ul><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>语义是：返回常量池中的相同字符串。</p><ul><li>如果池中本身存在该String对象，则直接返回池中对象。</li><li>否则，将该对象添加到池中，并返回该String对象。</li></ul><h4 id="JDK6-gt-JDK7-x2F-8"><a href="#JDK6-gt-JDK7-x2F-8" class="headerlink" title="JDK6-&gt;JDK7&#x2F;8"></a>JDK6-&gt;JDK7&#x2F;8</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s.intern();<br><span class="hljs-built_in">String</span> s2 = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-built_in">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>s3.intern();<br><span class="hljs-built_in">String</span> s4 = <span class="hljs-string">&quot;11&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224322.png"><br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131224329.png"></p><p>JDK1.6中，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象<strong>复制一份</strong>，放入池中，返回池中对象。</li></ul><p>JDK1.7后，放入池时：</p><ul><li>若池中有，则不放入，返回已有的池中对象。</li><li>若没有，则将对象的<strong>引用地址复制一份</strong>，放入池中，返回引用地址对象。</li></ul><p>简单讲，JDK7后的方式，省去了复制对象的开销。</p><h2 id="G1垃圾处理器去重String"><a href="#G1垃圾处理器去重String" class="headerlink" title="G1垃圾处理器去重String"></a>G1垃圾处理器去重String</h2><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。然后对队列中的元素进行去重处理。</li><li>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li></ol><h1 id="七、垃圾回收"><a href="#七、垃圾回收" class="headerlink" title="七、垃圾回收"></a>七、垃圾回收</h1><h2 id="垃圾回收概念"><a href="#垃圾回收概念" class="headerlink" title="垃圾回收概念"></a>垃圾回收概念</h2><h3 id="早期"><a href="#早期" class="headerlink" title="早期"></a>早期</h3><p><strong>垃圾</strong>：垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>早期C&#x2F;C++，需要开发人员手动释放内存，若存在疏忽则会永久产生内存泄漏。</p><h3 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h3><p>Java堆是垃圾收集器的工作重点</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h3 id="对象finalization机制"><a href="#对象finalization机制" class="headerlink" title="对象finalization机制"></a>对象finalization机制</h3><ul><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。</li><li>不要手动调用，应该由垃圾处理器调用<ul><li>调用可能使对象复活</li><li>执行时间无保证，取决于GC线程</li></ul></li><li>finalize()只能被调用一次，也就是说一个对象最多复活一次。</li></ul><h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。<br>优点：</p><ul><li>实现简单，判断效率高。<br>缺点：</li><li>增加了对象的字段</li><li>加减法时间开销</li><li><strong>无法处理循环引用</strong><br>Python使用引用计数算法，通过弱引用解决循环引用的问题。</li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul><li>可达性分析算法是以<strong>根对象集合</strong>（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li></ul><h5 id="GCRoot"><a href="#GCRoot" class="headerlink" title="GCRoot"></a>GCRoot</h5><p>栈上引用</p><ul><li>虚拟机栈上引用对象</li><li>本地方法栈上引用对象</li></ul><p>方法区引用</p><ul><li>类静态属性</li><li>常量引用（String Table等）</li></ul><p>其他引用</p><ul><li>同步锁对象</li><li>虚拟机内部对象（class对象）</li><li>本地代码缓存等</li></ul><p>当然还要考虑GC的作用空间：对于young空间的某对象A，存在着被old空间的对象B引用的情况，因此old空间的对象也需要考虑到GCRoots集合中。</p><h4 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h4><p>由于finalize的存在，对象有三种状态。</p><ul><li>可触及</li><li>可复活</li><li>不可触及</li></ul><p>标记过程：</p><ol><li>若无引用，进行一次标记</li><li>若无finalize或finalize已经被执行过，进行二次标记，为不可触及。</li><li>若有finalize，加入F-Queue队列等待Finalizer线程执行finalize方法。</li><li>随后GC对F-Queue进行标记，看是否可触及，可触及则移出队列，否则移出并标记为不可触及。</li></ol><h3 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231730.png"></p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p>缺点</p><ul><li>效率不高</li><li>STW</li><li>碎片</li></ul><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131231822.png"><br>优点</p><ul><li>不需要标记清除，直接复制可达对象，高效</li><li>无碎片<br>缺点</li><li>空间消耗大</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>Survivor区</li></ul><h4 id="标记-压缩（整理）算法"><a href="#标记-压缩（整理）算法" class="headerlink" title="标记-压缩（整理）算法"></a>标记-压缩（整理）算法</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131232037.png"><br>优化了复制算法，使用原本的内存进行移动。</p><p><strong>指针碰撞</strong><br>指这种通过指针记录空闲空间的起始点，为新对象分配内存时可以直接分配。</p><p>优点</p><ul><li>相对标记清除，使用了指针碰撞</li><li>相对复制算法，不耗多余内存</li></ul><p>缺点</p><ul><li>效率比复制低（时间换空间）</li><li>移动对象时，若对象被其他对象引用，需要调整引用地址（与复制算法相同）</li><li>STW</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>对不同生命周期的对象采取不同的收集方式，以便提高回收效率。即，实际上的GC采用的是分代收集，其根据收集区域使用不同的收集方式。</p><ul><li>年轻代（Young Gen），空间不大，复制算法效率最高。</li><li>老年代（Tenured Gen），不同GC的处理方式不同。</li></ul><h3 id="增量收集算法与分区算法"><a href="#增量收集算法与分区算法" class="headerlink" title="增量收集算法与分区算法"></a>增量收集算法与分区算法</h3><h4 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h4><p>为了避免STW，GC线程与用户线程交替进行，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><p>缺点：线程上下文切换造成总吞吐量下降。</p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230131233426.png"></p><h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>提醒JVM进行FullGC,不保证立刻生效。</p><h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><ul><li>内存溢出：内存超了<ul><li>超出设置，可以调整</li><li>超出机器内存上限</li></ul></li><li>内存泄漏：存在不再使用的对象无法被回收<ul><li>例子：单例模式，资源未close<br>可以说内存泄漏是内存溢出的元凶之一。</li></ul></li></ul><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>标记过程（枚举GC Roots）需要STW，因为分析工作必须在一个快照中进行，否则准确性无法保证。</p><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上同时发生了，只在多核CPU存在。</li></ul><h4 id="对于垃圾回收"><a href="#对于垃圾回收" class="headerlink" title="对于垃圾回收"></a>对于垃圾回收</h4><p>并行（<em>Parallel</em>）：<strong>多条GC线程</strong>同时执行GC。<br>串行（<em>Serial</em>）：<strong>单GC线程</strong>执行GC。<br>并发（<em>Concurrent</em>）：<strong>用户线程与GC线程</strong>交替执行。</p><p>一次GC可能同时具有并行、并发的特性。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>只有在特定的位置才能STW，这些位置称为安全点。如果安全点过少，GC频率会很低。</p><p>中断方式：</p><ul><li>抢先式中断（已经不再使用），让所有线程在安全点中断。</li><li>主动式中断，线程运行到安全点后主动询问是否需要中断。</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点具有盲区，如果线程无法走到安全点（如Sleep或Block），也应该有中断的机会。<br>安全区域：<strong>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。</strong><br>因此，也可以把Safe Region看做是被扩展了的Safepoint。</p><p>执行时，若线程处于SaveRegion，则可以忽略该线程。当线程走出SaveRegion时，需要判断GC是否结束，若未结束则需要等待。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这4种引用强度依次逐渐减弱。<br>除强引用外，其他3种引用均可以在java.lang.ref包中找到它们<br>分类：</p><ul><li>强引用（StrongReference）：引用赋值，不回收。</li><li>软引用（SoftReference）：内存不够（将要溢出前）时进行回收</li><li>弱引用（WeakReference）：GC时后回收</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><ul><li>不回收，内存泄漏的主要原因之一。</li><li>可以直接访问目标对象。</li></ul><h4 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h4><ul><li>内存不足即回收。</li><li>主要用于高速缓存。<br>软引用回收时，GC会选择性的将软引用放进一个<strong>引用队列</strong>。</li></ul><h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><ul><li>发现即回收。</li><li>GC时发现弱引用即回收。</li><li>也可用于缓存<br>比软引用回收更容易，更快。</li></ul><p><strong>会被回收的是WeakReference对象持有的对象，WeakReference本身并不会被回收。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value&quot;</span>);<br>WeakReference&lt;String&gt; WeakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(hello);<br><span class="hljs-comment">//此时不会回收，因为该String被hello强引用持有。</span><br>System.gc();<br>hello = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;value2&quot;</span>);<br><span class="hljs-comment">//此时，new String(&quot;value&quot;)被回收。</span><br>System.gc();<br></code></pre></td></tr></table></figure><h4 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h4><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。<br>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><div class="note note-primary">            <p>简而言之，将对象放入虚引用后得到的引用sf没有任何作用。<br>但当Object被回收时，phantomQueue会被添加一个虚引用，表示对象已被回收。</p>          </div><h4 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h4><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象。</p><div class="note note-primary">            <p>由此可见，引用总是伴随着引用队列，JVM根据队列依次对引用进行处理。</p>          </div><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>按线程数分，可以分为<strong>串行垃圾回收器</strong>和<strong>并行垃圾回收器</strong>。<br>按照工作模式分，可以分为<strong>并发式垃圾回收器</strong>和<strong>独占式垃圾回收器</strong>。<br>按碎片处理方式分，可分为<strong>压缩式垃圾回收器</strong>和<strong>非压缩式垃圾回收器</strong>。<br>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p><h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><ul><li>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li>内存占用：Java堆区所占的内存大小。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul><p>主要抓住两点：<strong>吞吐量（总效率）、暂停时间（用户体验）</strong><br>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h3 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h3><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143734.png"><br>按线程和工作模式分：</p><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1<br>按内存区分：</li><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201143826.png"></p><ul><li>红色虚线是JDK8已经被移除的GC</li><li>绿色虚线是JDK14中弃用的组合</li><li>蓝色框CMS GC已被删除</li></ul><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>我们选择的只是对具体应用最合适的收集器。<br><code>-XX:+PrintCommandLineFlags</code>可以查看默认参数。</p><h4 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h4><p><strong>Serial GC</strong>：STW，单线程，复制算法<br><strong>Serial Old GC</strong>：STW，单线程，标记-压缩算法。</p><div class="note note-primary">            <p>根据新老年代需求给出的最土味的算法。</p>          </div><h5 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h5><p>Serial Old是Client模式下的默认回收器。<br>简单高效，但单线程不太行，对于web应用不可接受，已经不用了。</p><h4 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h4><p>只回收新生代<br><strong>ParNew</strong>：STW，多线程，复制算法</p><div class="note note-primary">            <p>相对Serial回收器的多线程版本</p>          </div><h5 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h5><p>单CPU下不如串行，可以设置线程数。</p><h4 id="Parallel回收器"><a href="#Parallel回收器" class="headerlink" title="Parallel回收器"></a>Parallel回收器</h4><p><strong>Parallel Scavenge</strong>：STW，多线程，复制算法<br><strong>Parallel Old</strong>：STW，多线程，标记压缩</p><div class="note note-primary">            <p>Parallel Scavenge相比于ParNew，回收的目标是<strong>最大的吞吐量</strong>，因此其可控制吞吐量，自适应调节。比较适合<strong>批处理</strong>。</p>          </div><h5 id="评价-2"><a href="#评价-2" class="headerlink" title="评价"></a>评价</h5><p>JDK8的Server模式下的默认回收器，可以设置线程数和垃圾收集器最大停顿时间，吞吐量，以及设置自适应调节策略。</p><h4 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h4><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201145934.png"><br>只回收老年代，是第一款并发收集器，用户线程与GC线程同时工作。<br><strong>CMS（Concurrent Mark Sweep）</strong>：STW，单&#x2F;多线程，标记-清除算法</p><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><ul><li>初始标记：STW，标记GCRoots以及其直接关联到的对象。</li><li>并发标记：根据GCRoots直接关联对象遍历对象图。</li><li>重新标记：STW，修正由于并发标记期间用户线程造成的变化。</li><li>并发清理：清除标记删除的对象，释放内存。<br>由于并发标记和并发清理最耗费时间，采用并发的方式，整体回收停顿很低。</li></ul><p>另外，由于并发标记，清理中用户线程仍在跑，需要提前进行CMS回收才能防止OOM，一般是当堆内存使用率达到某一阈值时，便开始进行回收。<br>由于标记清除，会产生内存碎片，只能通过<strong>空闲列表</strong>分配内存。</p><h5 id="评价-3"><a href="#评价-3" class="headerlink" title="评价"></a>评价</h5><ul><li>并发收集，低延迟</li><li>会产生内存碎片，低延迟但吞吐量不行。</li><li>无法处理浮动垃圾（并发标记期间产生的新垃圾）</li></ul><blockquote><p><strong>重新标记</strong>（三色标记法<a href="https://baijiahao.baidu.com/sid=1719715247743913571&wfr=spider&for=pc%EF%BC%89">https://baijiahao.baidu.com/sid=1719715247743913571&amp;wfr=spider&amp;for=pc）</a><br>由于标记阶段是从GC Roots开始标记可达对象，那么在并发标记阶段可能产生两种变动:<br>1．本来可达的对象，变得不可达了<br>2．本来不可达的内存，变得可达了<br> 第一种变动会产生所谓的浮动垃圾，第二种变动怎么回事呢?重点在于miss。如果并发标记阶段用户线程里new了一个对象，而它在初始标记和并发标记中是不会能够从GC Roots 可达的，也就是were missed。如果没有重新标记阶段来将这个对象标记为可达，那么它会在清理阶段被回收，这是严重的错误，是必须要在重新标记阶段来处理的，所以这就是重新标记阶段实际上的任务。<br> 相比之下，浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢?也许是由可达变为不可达这样的变化需要重新从GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。<br> CMS通过增量更新：扫描已经完成的对象A指向新对象B，将A标灰。<br> G1通过原始快照STAB：某个新对象B被取消引用时，将其标记为灰。</p></blockquote><p>可以设置触发阈值，JDK9中标记过时，JDK14中已经删除。</p><h4 id="G1（Garbage-First）回收器"><a href="#G1（Garbage-First）回收器" class="headerlink" title="G1（Garbage First）回收器"></a>G1（Garbage First）回收器</h4><p>官方给G1设定的目标是在<strong>延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“全功能收集器”的重任与期望。只所以叫G1回收器是因为其优先回收垃圾最多的空间。<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151459.png"></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>并行性：STW，多线程回收</li><li>并发性：部分工作可以与应用程序交替进行</li><li>分代：依然保持分代，但不要求连续空间，同时回收年轻代和老年代。</li><li>空间整合：Region之间复制算法，整体使用标记压缩，都避免内存碎片。</li><li>延迟：可以只回收一个Region，优先回收价值最大的Region。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>不能碾压CMS，运行负担更大，小内存应用上CMS更好，大内存引用上G1更好。（6-8G左右）</li></ul><h5 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h5><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li><li>当然也可以设置并发标记线程数和触发阈值。<br>提供三种垃圾回收模式：Young GC，Mixed GC，Full GC。</li></ul><h5 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201151944.png"></p><ul><li>Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了找连续H区有时必须FullGC。</li><li>对每个Region内部使用指针碰撞方式分配空间（标记压缩）</li></ul><h5 id="回收过程"><a href="#回收过程" class="headerlink" title="回收过程"></a>回收过程</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152200.png"></p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC） </li><li>全局GC（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><p>一个对象可能被不同区域引用，<strong>Remembered Set是所有分代收集器避免全局扫描的关键</strong>。</p><p>G1的实现细节：<br>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作，然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象），如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；<br><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201152820.png"></p><blockquote><ul><li>RememberSet是一种思想，其记录了待收集region中的对象被哪些其他非待收集region所引用，那么在回收该region时还需要将其他region加入到root中。</li><li>只向其他区域时有不同的粒度：</li><li>字长</li><li>对象</li><li>卡</li><li>Card Table则是一种rset的具体实现，其实现是基于卡精度，其将内存以512Byte作为一个单元分成很多entry，以entry为单位记录卡的状态，如：region1和region3中的两个entry就被region2的rset标记为脏卡。然后把Card存入Dirty Card Queue，这是因为RSet存在多线程竞争写入问题。</li></ul></blockquote><div class="note note-primary">            <p>即，将对象赋予给一个引用时，检查引用与对象是否在同一个region，若不在，则在对象所在region的remember set上记录对象被引用信息，最后在回收该区域时，将remember set上的对象也加入GCRoots。</p>          </div><h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p><img src="/2023/01/23/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java-JVM/JVM%E4%B8%8A%E7%AF%87-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Pasted-image-20230201153244.png"><br>触发：当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。<br>回收范围：Eden区和Survivor区。<br>执行原理：STW，多线程，复制算法<br>过程：</p><ol><li>扫描root</li><li>更新rset（将Dirty Card Queue中的Card全部处理）</li><li>处理rset</li><li>复制对象</li><li>处理引用（存活对象的地址发送变化）</li></ol><h5 id="Conconrrent-Mark"><a href="#Conconrrent-Mark" class="headerlink" title="Conconrrent Mark"></a>Conconrrent Mark</h5><p>触发：堆内存达到45%时触发。<br>回收范围：Eden和Survivor区（触发一次Young GC）<br>过程：</p><ol><li>初始标记阶段：STW，扫描GCRoots，并触发一次Young GC（不一定立即执行）。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。<strong>这一过程必须在YoungGC之前完成。</strong></li><li>并发标记（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：STW，修正并发标记的问题。</li><li>独占清理（cleanup）：STW，计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h5 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h5><p>触发：并发标记结束后<br>回收范围：整个Young Region（Eden，Survivor），部分的Old Region(默认为1&#x2F;8，但分段执行8次)。<br>过程：<br>并发标记结束后，全垃圾的region已经被回收，部分垃圾的region已经被计算。使用和年轻代一样的方法GC即可。<br>备注：</p><ul><li>可以设置垃圾阈值，默认一个region只有垃圾占65%时才回收。</li><li>可以设置允许的垃圾阈值，当整堆中垃圾小于其时，不进行MixedGC。</li></ul><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>触发：以上方式无法正常工作（并发处理过程完成前空间耗尽）。<br>回收范围：整堆<br>特点：STW</p><h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</li><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。<br>回收器选择：官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><div class="note note-primary">            <p>G1回收器，三种清理模式：</p><ul><li>YoungGC：全程STW，根据GCRoots直接处理Young Region，注意rset的处理，region间复制算法。</li><li>MixedGC：<ul><li>STW扫描全局GCRoots，进行根区域扫描，根据Survivor区找Old区的对象，也压入扫描栈。</li><li>YoungGC</li><li>并发标记，STW，可能被YGC打断，根据扫描栈扫描对象。</li><li>STW修正标记，处理没处理的write barrier，即新出现的引用变化，但与CMS不同，这里的扫描范围只扫描SATB（snapshot-at-the-beginning），比CMS快。</li><li>STW计算区域属性</li><li>并发清理完全为空的区域</li><li>分段（默认8段）清理各区域。</li></ul></li><li>FullGC</li></ul>          </div>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第5章（集合）</title>
    <link href="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/"/>
    <url>/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="集合知识体系"><a href="#集合知识体系" class="headerlink" title="集合知识体系"></a>集合知识体系</h1><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109204736.png"><br>集合主要分Map和Collection两个体系:</p><ul><li>Map<ul><li>SortedMap<ul><li>NavigableMap</li></ul></li></ul></li><li>Collection<ul><li>List</li><li>Queue<ul><li>Deque</li></ul></li><li>Set<ul><li>SortedSet<ul><li>NavigableSet</li></ul></li></ul></li></ul></li></ul><div class="note note-primary">            <p>以上都是接口，从功能角度上对集合进行了分类。</p><ul><li>Map作为字典，重要的是其搜索能力，所以其有sorted-&gt;navigable的继承接口。</li><li>Collection中<ul><li>List体现的是对数组的封装，可以随机获取。</li><li>Queue体现单端的进出（堆）<ul><li>Deque实现双端的任意出入</li></ul></li><li>Set需要去重，重要的同样是其搜索能力，所以与map类似，有sorted-&gt;navigable的继承。</li></ul></li></ul>          </div><div class="note note-success">            <p>从基本的实现来看:</p><ul><li>Map<ul><li>map的朴素实现是HashMap<ul><li>HashMap有时需要保留先后顺序，LinkedHashMap继承自HashMap</li></ul></li><li>map搜索增强的实现是TreeMap</li><li>还有一些功能性Map(不做重点)，直接继承Map<ul><li>WeakHashMap，软引用，处于缓存角度，键值可以被回收</li><li>IdentifyHashMap，判断两值相等，只看其引用地址的16位hash（强相等）</li><li>EnumMap，只允许key为指定枚举值，底层其实是array实现。</li></ul></li></ul></li><li>Collection<ul><li>list的朴素实现是ArrayList<ul><li>vector还继承了list，是线程安全的，但已不推荐使用。<ul><li>stack继承了vector，先入先出</li></ul></li></ul></li><li>queue的实现是PriorityQueue(堆)<ul><li>deque的朴素实现是<strong>LinkedList</strong>，这个类也继承了List和Queue，三姓家奴</li><li>deque的另一个实现是ArrayDeque</li></ul></li><li>set与map类似，有HashSet-&gt;LinkedHashSet,TreeSet等实现。</li></ul></li></ul>          </div><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>继承：ArrayList实现了List接口<br>null：允许放入null<br>底层实现：array<br>同步：同步类为vector</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ul><li>当数组capacity &#x3D;&#x3D; size时添加新元素</li><li>数组扩容通过一个公开的方法<code>ensureCapacity(int minCapacity)</code>来实现。</li><li>每次大约扩容1.5倍。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109213925.png"></li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li>每次add前通过<code>ensureCapacity()</code>确保容量足够</li><li><code>add(int index,E e)</code>，需要先对元素进行移动<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109214209.png"></li><li><code>addAll()</code>，注意addAll不会调用add，其需要保证modCount只+1次。</li></ul><h3 id="set-x2F-get"><a href="#set-x2F-get" class="headerlink" title="set()&#x2F;get()"></a>set()&#x2F;get()</h3><p>直接操作数组即可，不过要检查参数索引是否越界。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><ul><li><code>remove(int index)</code>移除指定坐标，原地copy数组完成</li><li><code>remove(Object o)</code>移除指定对象，底层通过equals判断</li></ul><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>将底层数组的容量调整为当前列表保存的实际元素的大小。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素的第一次出现的index，也通过equals判断。</p><h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>快速失败，modCount标记操作数，避免并发带来的不确定风险。</p><div class="note note-primary">            <p>注意，除了扩容，其他的remove操作只会在原数组上进行copy，通过size维护有效数组大小即可。</p>          </div><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>注意不存在哑节点。</p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>LinkedList同时实现了List接口和Deque接口。<br>不过现在的首选是ArrayDeque，其底层通过数组实现，性能更好。</p><h2 id="机制-1"><a href="#机制-1" class="headerlink" title="机制"></a>机制</h2><h3 id="底层-1"><a href="#底层-1" class="headerlink" title="底层"></a>底层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br></code></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><ul><li><code>getFirst()</code>, <code>getLast()</code>直接获取即可。</li><li><code>get(int index)</code>，通过<code>node(index)</code>获取节点并修改。</li></ul><h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h3><p>底层调用unlink方法释放节点。</p><ul><li><code>removeFirst()</code>, <code>removeLast()</code>直接删除，调整指针即可。</li><li><code>remove(e)</code>需要迭代equals判断</li><li><code>remove(index)</code>同理（调用<code>node(index)</code>）<br>ps:</li><li>注意，以上方法都会先对操作的可行性进行判断。</li><li>查找指定索引节点的方法为<code>node(index)</code>，其会根据index判断从前开始找还是从后开始找速度快。</li></ul><h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><ul><li><code>add(E e)</code>直接加到尾部</li><li><code>add(int index,E e)</code>需要线性查找(也会先找<code>node(index)</code>)</li></ul><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h3><p>同arraylist，不会调用add()。</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>会迭代将node之间引用清空，加快清理速度。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>通过equals迭代判断。</p><h3 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h3><p>上面都是一些list方法的实现，linkedlist还实现了queue和deque，以下是对这些类的实现。<br>peek(),element(),poll(),remove(),offer()</p><ul><li>peek,element,poll,remove都是操作头元素，offer操作尾元素</li><li>element调用<code>getFirst()</code>会抛出空异常，peek()返回null。</li></ul><h3 id="Deque方法"><a href="#Deque方法" class="headerlink" title="Deque方法"></a>Deque方法</h3><p>offerFirst,offerLast,peekFirst,peekLast,pollFirst,pollLast,push,pop</p><ul><li>push，pop都操作头元素。</li></ul><div class="note note-primary">            <p>记忆，</p><ul><li><code>peek,push,pop</code>属于栈方法，操作头元素</li><li><code>peek,offer,poll</code>属于队列方法，默认操作头元素，不会异常，且有双端方法可以使用</li><li><code>add,remove</code>属于list方法，操作尾部元素</li></ul>          </div><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack是一个具体的实现类，而Queue却没有，这是一个反常理的事情，不过现在Java已经不推荐使用Stack了，<code>ArrayDeque</code>往往更高效。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>Queue是一个接口，实现了Collection接口，其队列特殊方法不会抛出异常。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>deque是一个接口，实现了Queue接口，表示双向队列，支持双向的队列操作。<br>deque常见的实现是LinkedList和ArrayDeque</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>底层通过数组实现，且数组为循环数组，即任一点都可以是起点或终点，如下图。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109232400.png"></p><h3 id="机制-2"><a href="#机制-2" class="headerlink" title="机制"></a>机制</h3><p>ArrayDeque不允许放入null</p><h4 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h4><p><code>elements[head = (head - 1) &amp; (elements.length - 1)] = e</code><br>会对head-1取模，如果<code>head-1==-1</code>,则得到的head&#x3D;<code>elements.length - 1</code>，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><div class="note note-primary">            <p>elements.length总为偶数，-1后为全1。<br><code>(head - 1) &amp; (elements.length - 1)</code>相当于对<code>head-1</code>对<code>elements.length-1</code>做取模处理。</p><ul><li>head值若超过length-1，则相当于取余</li><li>head-1若为负数，相当于取对element.length的补码。</li><li>实际上head-1最小为-1，取补码后等于element.length-1。</li></ul>          </div><h4 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h4><p>容量满了就需要扩容，方法是<code>doubleCapacity()</code>。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230109233801.png"></p><ul><li>第一次复制<code>head</code>右边的元素。</li><li>第二次复制<code>head</code>左边的元素。</li></ul><h4 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h4><p><code>(tail = (tail + 1) &amp; (elements.length - 1)) == head</code><br>tail+1取模，若<code>tail+1==elements.length-1</code>，则得到的tail &#x3D; 0，通过判断head &#x3D;&#x3D; tail即可判断其容量满了。</p><h3 id="pollFirst-pollFirst-peekLast-，pollLast"><a href="#pollFirst-pollFirst-peekLast-，pollLast" class="headerlink" title="pollFirst(),pollFirst(),peekLast()，pollLast()"></a>pollFirst(),pollFirst(),peekLast()，pollLast()</h3><p>返回对应值，为空则返回Null。</p><div class="note note-primary">            <p>注意，ArrayList扩容是1.5倍，ArrayDeque扩容是2倍。</p>          </div><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。</p><ul><li>优先队列不允许放入<code>null</code>元素。</li><li>其通过完全二叉树的小顶堆实现。</li></ul><h3 id="机制-3"><a href="#机制-3" class="headerlink" title="机制"></a>机制</h3><h4 id="底层-2"><a href="#底层-2" class="headerlink" title="底层"></a>底层</h4><p>PriorityQueue底层通过数组维护堆结构<br><code>leftNode = parentNode*2+1</code><br><code>rightNo = parentNo*2+2</code><br><code>parentNo = (nodeNo-1)/2</code></p><h4 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h4><p>使用<code>grow()</code>函数，会复制原数组元素到新数组</p><h4 id="element-peek"><a href="#element-peek" class="headerlink" title="element(),peek()"></a>element(),peek()</h4><p>一个会抛异常，一个不会。都返回下标为0的元素。</p><h4 id="add-offer"><a href="#add-offer" class="headerlink" title="add(),offer()"></a>add(),offer()</h4><p>add、offer，添加在数组末尾，然后逐步向上调节。<br>会调用<code>siftUp(int k, E x)</code>，用于在指定位置插入节点并进行调整。</p><h4 id="remove-poll"><a href="#remove-poll" class="headerlink" title="remove(),poll()"></a>remove(),poll()</h4><p>一个会抛异常，一个不会，都移除下标为0的元素，然后进行堆调整。<br>会调用<code>siftDown(int k, E x)</code>，用于在指定位置删除节点并进行调整。</p><div class="note note-primary">            <p>siftUp，siftDown会根据指定元素x，不断对该位置及其上&#x2F;下的节点进行比较并移动，直到满足找到x小于&#x2F;大于目标节点的时候截至。</p>          </div><h4 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h4><p>遍历数组删除第一个equals的元素。</p><h1 id="HashSet-amp-HashMap"><a href="#HashSet-amp-HashMap" class="headerlink" title="HashSet&amp;HashMap"></a>HashSet&amp;HashMap</h1><p>二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，即默认value &#x3D;&#x3D; null。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashTable是同步的HashMap。该map不保证元素顺序。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。</p><h3 id="Java7"><a href="#Java7" class="headerlink" title="Java7"></a>Java7</h3><p>HashMap采用的是冲突链表方式。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110203318.png"></p><p>可见put，get方法可以在常数时间完成，但若table过大，对map进行遍历就会很耗时。</p><p>有<strong>两个参数</strong>可以影响HashMap的性能: 初始容量(<em>inital capacity</em>)和负载系数(<em>load factor</em>)。</p><ul><li>初始容量指定了初始<code>table</code>的大小，默认为16。</li><li>负载系数用来指定自动扩容的临界值，默认为0.75<br>当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容（2倍）并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</li></ul><p>将对象放入到HashMap或HashSet中时，有<strong>两个方法</strong>需要特别关心：<code>hashCode()</code>和<code>equals()</code>。</p><ul><li><strong><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”</strong>。</li><li>所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要@Override <code>hashCode()</code>和<code>equals()</code>方法。</li></ul><h4 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h4><p>先<code>getEntry</code>，然后<code>getValue</code><br>其中getEntry先通过hashCode判断bucket，然后通过equals遍历判断。</p><p>求bucket的过程：<br><code>hash(k)&amp;(table.length-1)</code>，与list扩容类似，取模。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>先<code>getEntry</code>，如果没有则<code>addEntry</code>。在链表中使用<strong>头插法</strong>。</p><h4 id="remove-2"><a href="#remove-2" class="headerlink" title="remove()"></a>remove()</h4><p>先<code>getEntry</code>，然后remove。</p><h3 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h3><p>由 <strong>数组+链表+红黑树</strong> 组成。<br>当链表中的元素达到了<strong>8</strong>个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89/Pasted-image-20230110204320.png"><br>链表的元素为<code>Node</code>，红黑树的元素为<code>TreeNode</code>，通过头节点的类型判断是链表还是红黑树。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize()方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 <strong>2倍</strong>，并进行数据迁移（元素在数组中的位置取决于hashCode%length，扩充为2倍时，有一半的桶的位置不会发生迁移，另一半索引增加原本数组的长度，1.8中通过这种处理避免了重新hash）。</p><p><strong>ps:java7是先扩容再插值，java8是先插值再扩容（避免不必要的扩容）。</strong></p><h4 id="get-2"><a href="#get-2" class="headerlink" title="get()"></a>get()</h4><p>判断是红黑树还是链表，采用不同方法取值。</p><p>具体红黑树讲解见TreeMap</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>就是对HashMap的一层包装。</p><h1 id="LinkedHashMap-amp-LinkedHashSet"><a href="#LinkedHashMap-amp-LinkedHashSet" class="headerlink" title="LinkedHashMap&amp;LinkedHashSet"></a>LinkedHashMap&amp;LinkedHashSet</h1><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>实现了map接口，<strong>允许放入key或value为null的元素</strong>，也是HashMap的子类。其使用双向链表将所有entry相连接。并多了header和tail指向<code>头部</code>和<code>尾部</code>。</p><p>优点：遍历时不用遍历所有bucket，只用遍历entrylist即可。</p><p>有<strong>两个参数</strong>可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。<br>将对象放入到LinkedHashMap或LinkedHashSet中时，有<strong>两个方法</strong>需要特别关心: <code>hashCode()</code>和<code>equals()</code>。</p><p>这点与HashMap相同。<br>其没有同步化实现，若需要同步，可使用：<br><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p><h3 id="get-3"><a href="#get-3" class="headerlink" title="get()"></a>get()</h3><p>同HashMap</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><p>也是先getEntry，然后再addEntry<br>add时，既要使用头插法插入bucket链表头部，也要将其插入linkedlist的尾部。</p><h3 id="remove-3"><a href="#remove-3" class="headerlink" title="remove()"></a>remove()</h3><p>同样先get，然后remove，同时维护两个链表。</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>是LinkedHashMap的简单包装。</p><h1 id="TreeSet-amp-TreeMap"><a href="#TreeSet-amp-TreeMap" class="headerlink" title="TreeSet&amp;TreeMap"></a>TreeSet&amp;TreeMap</h1><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeSet是对TreeMap的一层包装。</p><p>底层通过红黑树实现。意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。</p><p>TreeSet是非同步的，若需要同步，可以使用：<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>参考视频：<a href="https://www.bilibili.com/video/BV1d64y1z7Uk?p=20&vd_source=7324e975d0c1b4b4719d1194e3649ff8">bilibili</a><br>参考blog：<a href="https://www.bilibili.com/read/cv17486236">bilibili</a><br><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍</strong>。</p><p>性质：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。</li><li>对于每个节点，从该点至<code>null</code>(树尾端)的任何路径，都含有相同个数的黑色节点。<br>树结构改变时，任意破坏3，4，因此需要调整。</li></ol><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="234树"><a href="#234树" class="headerlink" title="234树"></a>234树</h4><p>一种特殊的搜索树。</p><ul><li>2节点表示1个key组成的一个节点</li><li>3节点表示2个key组成的一个节点</li><li>4节点表示3个key组成的一个节点</li></ul><p>当给234树添加节点时</p><ul><li>通过搜索找到应该插入的节点。</li><li>如果该节点位置已经有不超过3个节点，则可以进行合并。</li><li>如果已经为4节点，则需要拆解出节点并向上移动。</li></ul><p>因为这样自底向上的插入性质，其所有根节点的高度总是相等的。</p><h4 id="红黑树-1"><a href="#红黑树-1" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是可以和234树等价的。</p><ul><li>2节点表示一个黑节点</li><li>3节点表示一个红节点和其一个黑子节点</li><li>4节点表示一个红节点和其两个黑子节点</li></ul><p>另外红黑树每个叶子节点都是黑节点（一般是隐藏的，其不会影响红黑树的3，4性质）</p><h4 id="左旋-x2F-右旋"><a href="#左旋-x2F-右旋" class="headerlink" title="左旋&#x2F;右旋"></a>左旋&#x2F;右旋</h4><p>以x节点为中心左旋，其右子节点r会成为x节点的父节点。右子节点r的左节点rl会称为x的右节点。<br>右旋同理，左右旋主要是为了调整树的节点构造，在不影响整体高度的情况下达到我们想要构造。</p><h4 id="节点后继"><a href="#节点后继" class="headerlink" title="节点后继"></a>节点后继</h4><p>搜索树中某节点x有前继pre（比x小的最大节点）和后继post（比x大的最小节点）节点。这两个节点可以完美替换节点x。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="get-4"><a href="#get-4" class="headerlink" title="get()"></a>get()</h4><p>按照常规二叉搜索树寻找即可。<br>底层根据compareTo()的返回值判断进行迭代。</p><h4 id="put-2"><a href="#put-2" class="headerlink" title="put()"></a>put()</h4><p>先查找，若没有，则add。<br>其可能破坏红黑树约束条件，因此需要调整。<br>1.默认插入RED节点。<br>2.1.若其父节点也为BLACK节点，不影响高度（return）。<br>2.2.若其父节点也为RED，需要调整父节点及其叔叔节点为BLACK(+1)，并让爷爷节点为RED(-1)。<br>3.迭代至根节点。</p><h4 id="remove-4"><a href="#remove-4" class="headerlink" title="remove()"></a>remove()</h4><p>先查找，若有，则remove。<br>其可能破坏红黑树约束条件，因此需要调整。</p><p>1.可能移除树中任意位置的节点，可以通过<strong>值替换</strong>的方式转化为移除其前继或<strong>后继</strong>节点，最终只会删除叶子节点或有单侧叶子节点的节点</p><p>2.1.若移除的是RED节点，不影响高度(return)。<br>2.1.1如果该节点是叶子节点，直接(return)<br>2.1.2如果该节点有单侧叶子节点，由叶子节点替代该节点（return）。</p><p>2.2.若移除的是BALCK节点L，需要调整。<br>2.2.1如果该节点是叶子节点，需要先调整，再移除<br>2.2.2如果该节点有单侧子节点，由子节点替代该节点后，再调整。</p><div class="note note-primary">            <p>所谓调整，本质上是一个方法 f(Node node)，其能让node节点这一侧补充一个黑色节点高度。核心思想是，由于移除了黑色节点L，该侧高度（-1），需要找一个节点（且为黑色）补充回来。</p><ul><li>如果L有红色子节点，将其提升后染黑即可。</li><li>如果L没有红色子节点，需要将其父节点P的左&#x2F;右旋，将P移到该侧填补黑色节点。然后由其兄弟节点提升多余节点（兄弟节点有红色子节点）代替父节点并进行调整。</li><li>如果兄弟节点R没有多余红色节点，则将兄弟节点一起染红，然后迭代其父节点P作为L。</li></ul>          </div><p>2.3.1.如果替代上来的节点是红色节点，将其染黑即可(return)<br>2.3.2.如果原节点(2.2.1)或替代上来的节点是黑色节点(2.2.2)，需要进行旋转调整。<br>2.3.3.事实上这不会容易，父节点P左旋时，其右节点R会成为新的父节点，这会导致右侧减去一个节点R，因此，右旋时要保证右侧的高度也不变，需要满足以下几种条件之一：<br>2.4.1.如果兄弟节点为红色，说明其不是真正的兄弟节点（因为234树中3节点和4节点都应该是黑色节点为根），此时应该<strong>调整兄弟节点成黑色节点为根的形态</strong>(通过左&#x2F;右旋并调整颜色实现，达到2.4.2)。<br>2.4.2.如果兄弟节点为黑色，考虑其子节点是否有红色节点可以借用。<br>2.4.2.1.兄弟节点有红色子节点：</p><ul><li>将父节点左旋，并染黑，补充L侧的黑节点个数</li><li>原兄弟节点成为新的父节点，将其调整为原父节点P的颜色</li><li>原兄弟节点的子节点成为新父节点的右节点，将其染黑补充R侧的黑节点个数</li><li>return</li></ul><p>2.4.2.2.兄弟节点没有红色子节点:</p><ul><li>将兄弟节点染红，则导致父节点到叶子的路径总体-1，以父节点为新的L迭代2.2.1步，可以将其视为一个整体。</li></ul><p>2.5最终达到root时，return。</p><h1 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h1><p>具体实现类似HashMap，弱引用可以访问对象，但这不是有效引用，即被引用的对象可以被GC回收。<br>WeakHashMap内部通过弱引用管理entry。<br>想要获取HashSet，需要使用：<br><code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>，其可以将任意map转化为set。</p><h1 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h1><p>PriorityQueue，TreeSet不允许传入空值，因为其需要比较，<br>ArrayDeque不能传入null值，而LinkedList可以，<br>其他集合都可以传入Null。</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><table><thead><tr><th>不安全</th><th>安全实现</th><th>ConCurrent</th></tr></thead><tbody><tr><td>ArrayList</td><td>Vector&#x2F;Stack</td><td>暂无</td></tr><tr><td>LinkedList</td><td>Collections.synchronizedList(List)</td><td>暂无</td></tr><tr><td>PriorityQueue</td><td>无</td><td>暂无</td></tr><tr><td>HashMap</td><td>Hashtable</td><td>暂无</td></tr><tr><td>LinkedHashMap</td><td>Collections.synchronizedMap(Map)</td><td>暂无</td></tr><tr><td>TreeMap</td><td>Collections.synchronizedSortedMap(SortedMap);</td><td>暂无</td></tr><tr><td>NavigableMap</td><td>Collections.synchronizedNavigableMap(NavigableMap)</td><td>暂无</td></tr></tbody></table><p>Set的Collections包装方法类似map。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第4章（注解、异常、反射）</title>
    <link href="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/"/>
    <url>/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、注解"><a href="#一、注解" class="headerlink" title="一、注解"></a>一、注解</h1><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><ul><li><strong>生成文档</strong>，通过代码里标识的元数据生成javadoc文档。</li><li><strong>编译检查</strong>，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li><strong>编译时动态处理</strong>，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li><strong>运行时动态处理</strong>，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解就是注解的注解，一般用于标识注解的属性</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>描述注解的使用范围，即可以在哪些对象上使用注解（常见的有TYPE,FILED,METHOD）等等。</p><h3 id="Retention-amp-RetentionTarget"><a href="#Retention-amp-RetentionTarget" class="headerlink" title="@Retention &amp; @RetentionTarget"></a>@Retention &amp; @RetentionTarget</h3><p>描述注解的保留时间（注意这里是指被保留到什么时候）有（SOURCE,CLASS,RUNTIME）三种策略。</p><h3 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h3><p>被其修饰的注解在标记在 其他对象上后，使用 javadoc 工具为类生成帮助文档时<strong>会保留其注解信息</strong>。</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>被其修饰的注解是否有继承性，如某类使用注解A，其子类也会继承注解A</p><h3 id="Reaptable"><a href="#Reaptable" class="headerlink" title="@Reaptable"></a>@Reaptable</h3><p>描述注解是否可以重复使用，即在一个对象上多次标注（但使用不同的参数）</p><h3 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h3><p>被其修饰的<strong>成员变量</strong>可以被本地方法引用，使用较少。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：<strong>编译检查</strong>，会检查是否按规范重写了父类方法。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Deprecated &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用：表示这个对象已经过时。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SuppressWarnings &#123;<br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭编译器警告,可传入<code>String[]</code>著名需要抑制的警告类型。</p><div class="note note-primary">            <p>元注解与内置注解：<br>目持文继重原，重过抑。</p>          </div><h2 id="注解与反射接口"><a href="#注解与反射接口" class="headerlink" title="注解与反射接口"></a>注解与反射接口</h2><p>如何获取注解信息？<br>通过反射即可获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; T <span class="hljs-title function_">getAnnotation</span><span class="hljs-params">(Class&lt;T&gt; annotationClass)</span><br><br>Annotation[] getAnnotations()<br></code></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyMethodAnnotation &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">title</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解注解"><a href="#深入理解注解" class="headerlink" title="深入理解注解"></a>深入理解注解</h2><h3 id="JDK8新注解"><a href="#JDK8新注解" class="headerlink" title="JDK8新注解"></a>JDK8新注解</h3><ul><li>@Repeatable</li><li>新的Target参数<code>ElementType.TYPE_PARAMETER</code>，包括type和parameter。</li></ul><h3 id="注解不支持继承"><a href="#注解不支持继承" class="headerlink" title="注解不支持继承"></a>注解不支持继承</h3><p><strong>注解之间无法继承</strong>，但编译后统一继承<code>java.lang.annotation.Annotation</code></p><h3 id="注解实现原理"><a href="#注解实现原理" class="headerlink" title="注解实现原理"></a>注解实现原理</h3><ul><li>注解是一个继承自Annotation的接口，里面每一个属性其实是一个接口的抽象方法。</li><li>使用注解时，会创建一个注解实例对象，该对象是通过jdk动态代理生成的（在<code>AnnotationInvocationHandler()</code>方法中就封装了代理的逻辑）</li></ul><h3 id="注解应用场景"><a href="#注解应用场景" class="headerlink" title="注解应用场景"></a>注解应用场景</h3><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>框架从配置化 -&gt; 注解化</p><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP实现统一日志管理，实现模块的解偶。<br>具体就是以@Log为切点，然后对方法进行增强。</p><h1 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h1><h2 id="异常基础"><a href="#异常基础" class="headerlink" title="异常基础"></a>异常基础</h2><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109184839.png"></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error是JVM无法处理的错误。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>Exception是可以被捕获，处理的异常。分为两类：运行时异常和编译时异常。</p><ul><li>运行时异常（不会检查的）：NullPointerException,IndexOutOfBoundsException。</li><li>非运行时异常（必须处理的）：IOException、SQLException。</li></ul><h3 id="可检查异常和不可检查异常"><a href="#可检查异常和不可检查异常" class="headerlink" title="可检查异常和不可检查异常"></a>可检查异常和不可检查异常</h3><p>除了Error，RuntimeException及其子类，其他都是可检查异常，需要在编写程序时对其进行解决。</p><h3 id="异常使用"><a href="#异常使用" class="headerlink" title="异常使用"></a>异常使用</h3><ul><li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。如果try,catch中有return或throw，会先执行完finally再回去执行返回行为（return&#x2F;throw），如果finally中有返回行为，则不会再回去执行。finally可以脱离catch使用。</li><li><strong>throw</strong> – 用于<strong>抛出</strong>异常。</li><li><strong>throws</strong> – 用在方法签名中，用于声明该方法<strong>可能抛出</strong>的异常。</li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p>必须声明方法可抛出的任何可查异常（checked exception）。</p><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时会在catch中抛出另一个异常，主要是为了封闭异常细节。</p><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>继承Exception即可，习惯上要定义无参和具有描述信息的构造函数。</p><h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><p>JAVA7中引入，会自动关闭资源。需要该资源实现了AutoCloseable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;c:/abc&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>))&#123;<br><span class="hljs-comment">// code</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br><span class="hljs-comment">// handle exception</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>JVM处理异常的机制涉及Exception Table，以下称为异常表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatch</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: goto          <span class="hljs-number">11</span><br>       <span class="hljs-number">6</span>: astore_0<br>       <span class="hljs-number">7</span>: aload_0<br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>     <span class="hljs-number">6</span>   Class java/lang/Exception<br></code></pre></td></tr></table></figure><p>异常表按<strong>catch顺序</strong>记录的异常捕获信息，包括：</p><ul><li><strong>from</strong> 可能发生异常的起始点</li><li><strong>to</strong> 可能发生异常的结束点</li><li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li><li><strong>type</strong> 异常处理者处理的异常的类信息</li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTryCatchFinally</span><span class="hljs-params">()</span>;<br>    Code:<br>       <span class="hljs-number">0</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method testNPE:()V</span><br>       <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>       <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>       <span class="hljs-number">8</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">11</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">14</span>: astore_0<br>      <span class="hljs-number">15</span>: aload_0<br>      <span class="hljs-number">16</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>      <span class="hljs-number">19</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">22</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">27</span>: goto          <span class="hljs-number">41</span><br>      <span class="hljs-number">30</span>: astore_1<br>      <span class="hljs-number">31</span>: getstatic     #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-number">34</span>: ldc           #<span class="hljs-number">7</span>                  <span class="hljs-comment">// String Finally</span><br>      <span class="hljs-number">36</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>      <span class="hljs-number">39</span>: aload_1<br>      <span class="hljs-number">40</span>: athrow<br>      <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">14</span>   Class java/lang/Exception<br>           <span class="hljs-number">0</span>     <span class="hljs-number">3</span>    <span class="hljs-number">30</span>   any<br>          <span class="hljs-number">14</span>    <span class="hljs-number">19</span>    <span class="hljs-number">30</span>   any<br></code></pre></td></tr></table></figure><p>一个finally会产生两个捕获表条目，表示try或catch中发送任何异常其都可以捕获并跳转到30执行。<br>如果方法有返回值，为了保证finally执行，会在编译时将finally中内容编译在return语句前。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Class类也是一个类，不同的类都有一个Class类的实体存在于堆中。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191903.png"><br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109191923.png"></p><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><h4 id="Class对象获取"><a href="#Class对象获取" class="headerlink" title="Class对象获取"></a>Class对象获取</h4><ul><li>根据类名：类名.class</li><li>根据对象：对象.getClass()</li><li>根据全限定类名：Class.forName(全限定类名)</li><li>类加载器：xxxClassLoader.loadClass(全限定类名)</li></ul><div class="note note-primary">            <p>其中，通过类名.class，类加载器.loadClass获取class对象，不会进行类加载的初始化，此时静态代码块和静态对象不会执行。</p>          </div><h4 id="Constructor类及其用法"><a href="#Constructor类及其用法" class="headerlink" title="Constructor类及其用法"></a>Constructor类及其用法</h4><p>可以通过class对象获取该类的构造器。</p><ul><li>getConstructors() 获取所有public构造器</li><li>getDeclaredConstructors() 获取所有声明的构造器<br>以上两个方法不构成覆盖关系，getDeclaredConstructors能获取私有构造器，却无法获取继承到的public构造器。</li></ul><div class="note note-primary">            <p>Field&#x2F;Method的获取中的declared也类似。</p>          </div><h4 id="Method类及其用法"><a href="#Method类及其用法" class="headerlink" title="Method类及其用法"></a>Method类及其用法</h4><p><code>method.invoke(Object obj, Object... args)</code><br>可以使用arg作为参数，执行obj的method方法</p><h2 id="深入反射"><a href="#深入反射" class="headerlink" title="深入反射"></a>深入反射</h2><p><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109192732.png"></p><div class="note note-primary">            <p>获取类对象时，只会对类进行加载、链接。<br>只有通过<strong>forName获取类对象</strong>或<strong>创建该类的对象</strong>或<strong>使用该类的静态变量</strong>时才会进行初始化，详情见JVM。</p>          </div><blockquote><p>这里做一下区分，有具体实现的是java程序，没有具体实现的我们认为是交给JVM的(native)。</p></blockquote><ul><li>类加载<ul><li>forName会加载类，其会调用本地方法加载类（交给JVM）</li><li>JVM回调类加载其对类进行加载</li></ul></li><li>实例生成<ul><li>查找构造器，若没有则从JVM获取，有则直接从缓存中取出。缓存的结构名为ReflectionData，Class对象对该缓存使用了软引用，通过reflection()方法获取缓存。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>反射也是考虑了线程安全的，放心使用；</li><li><strong>反射使用软引用relectionData缓存class信息</strong>，避免每次重新从jvm获取带来的开销；</li><li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证<strong>数据隔离；</strong></li><li>调度反射方法，最终是由jvm执行invoke0()执行；</li></ul><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>SPI（Service Provider Interface）服务发现机制，主要用于框架开发。核心思想就是解偶。<br><img src="/2023/01/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC4%E7%AB%A0%EF%BC%88%E6%B3%A8%E8%A7%A3%E3%80%81%E5%BC%82%E5%B8%B8%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%89/Pasted-image-20230109194225.png"><br>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。<br>当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><p>例子：<br>java定义了java.sql.Driver接口。<br>mysql提供了mysql-connector-java-6.0.6.jar，其META-INF&#x2F;services下有文件<code>java.sql.Driver</code>，其内容为<code>com.mysql.cj.jdbc.Driver</code>，表示使用<code>com.mysql.cj.jdbc.Driver</code>实现<code>java.sql.Driver</code>。</p><h3 id="SPI和API区别"><a href="#SPI和API区别" class="headerlink" title="SPI和API区别"></a>SPI和API区别</h3><ul><li>SPI - “接口”位于“调用方”所在的“包”中，由外部实现该接口。</li><li>API - “接口”位于“实现方”所在的“包”中，服务自身实现该接口。</li></ul><h3 id="SPI缺点"><a href="#SPI缺点" class="headerlink" title="SPI缺点"></a>SPI缺点</h3><ul><li>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第3章（泛型）</title>
    <link href="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/"/>
    <url>/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是泛型"><a href="#一、什么是泛型" class="headerlink" title="一、什么是泛型"></a>一、什么是泛型</h1><h2 id="泛型的功能"><a href="#泛型的功能" class="headerlink" title="泛型的功能"></a>泛型的功能</h2><p>代码复用，使用一个代码流程适配多个类型。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a + b));<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T a, T b)</span> &#123;<br>    System.out.println(a + <span class="hljs-string">&quot;+&quot;</span> + b + <span class="hljs-string">&quot;=&quot;</span> + (a.doubleValue() + b.doubleValue()));<br>    <span class="hljs-keyword">return</span> a.doubleValue() + b.doubleValue();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型的特性"><a href="#泛型的特性" class="headerlink" title="泛型的特性"></a>泛型的特性</h2><p>使用泛型时，我们可以具体制定此时需要适配的类型，然后<strong>编译器</strong>会根据此进行类型检查，约束编码。</p><h1 id="二、泛型的基本使用"><a href="#二、泛型的基本使用" class="headerlink" title="二、泛型的基本使用"></a>二、泛型的基本使用</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>创建该类的对象的时候可以制定泛型的具体类型，其方法也会适配。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&lt;T&gt;&#123;         <span class="hljs-comment">// 此处可以随便写标识符号，T是type的简称  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;     <span class="hljs-comment">// var的类型由T指定，即：由外部指定  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <span class="hljs-comment">// 返回值的类型由外部决定  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <span class="hljs-comment">// 设置的类型也由外部决定  </span><br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericsDemo01</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;  <br>        Point&lt;String&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>&lt;String&gt;() ;     <span class="hljs-comment">// 里面的var类型为String类型  </span><br>        p.setVar(<span class="hljs-string">&quot;it&quot;</span>) ;                            <span class="hljs-comment">// 设置字符串  </span><br>        System.out.println(p.getVar().length()) ;   <span class="hljs-comment">// 取得字符串的长度  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用多元泛型&lt;A,B&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notepad</span>&lt;K,V&gt;&#123;       <span class="hljs-comment">// 此处指定了两个泛型类型  </span><br>    <span class="hljs-keyword">private</span> K key ;     <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">private</span> V value ;   <span class="hljs-comment">// 此变量的类型由外部决定  </span><br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(K key)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.key = key ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.value = value ;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>不要惧怕<code>&lt;&gt;</code>，其就是一个用来传参的窗口，类似与方法中在<code>()</code>写入多个参数，泛型则是在<strong>类&#x2F;接口的创建</strong>或<strong>方法的使用</strong>时，传入类型的参数<code>&lt;type1,type2&gt;</code>，从而令类型、方法等具体化。</p>          </div><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>可见定义接口和定义类类似，在实现该接口时，也应该使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;        <span class="hljs-comment">// 在接口上定义泛型  </span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span> ; <span class="hljs-comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Info</span>&lt;T&gt;&#123;   <span class="hljs-comment">// 定义泛型接口的子类  </span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;             <span class="hljs-comment">// 定义属性  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InfoImpl</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;     <span class="hljs-comment">// 通过构造方法设置属性内容  </span><br>        <span class="hljs-built_in">this</span>.setVar(<span class="hljs-keyword">var</span>) ;    <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>一个非泛型类里面也可以有泛型方法，泛型方法的目的也是可以对一个泛型方法传入多种类型的参数，而不需要new很多泛型类来实现。<br>同时，泛型方法就是为了适配不同类型的参数，所以一般在声明方法时，型参的类型也是一个泛型类，如下面的<code>Class&lt;T&gt;</code>。</p><p>此时泛型的类别应该在调用该方法时，通过参数？或其他方式，指明类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getObject</span><span class="hljs-params">(Class&lt;T&gt; c)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> c.newInstance();<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-type">Clazz</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Clazz</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz1.getObject(Class.forName(<span class="hljs-string">&quot;com.cnblogs.test.User&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>泛型方法需要在修饰符后面加上<code>&lt;T&gt;</code>来标识这是一个泛型方法。</li><li>泛型方法需要使用泛型类型的型参来，使用时传入具体的泛型类型来适配。</li></ul><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>普通方法使用泛型，该方法不属于泛型方法，参数是泛型类，且已经制定了具体的泛型类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;Integer&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h2><p>泛型有一个问题，即</p><ul><li>Even <code>A extends B</code> but <code>List&lt;A&gt;  not extends List&lt;B&gt;</code><br>假如，现在有一个普通方法，参数是一个泛型类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;B&gt; list)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>如果传入一个<code>List&lt;A&gt;</code>则会出现报错。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用上下边界机制解决,如：</p><h4 id="泛型方法-1"><a href="#泛型方法-1" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max <span class="hljs-title function_">getSum</span><span class="hljs-params">(List&lt;? extends B&gt; list)</span>&#123;&#125;;<br><span class="hljs-comment">//下限</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(Info&lt;? <span class="hljs-built_in">super</span> String&gt; temp)</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="泛型类-1"><a href="#泛型类-1" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//上限</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;&#123;    <span class="hljs-comment">// 此处泛型只能是数字类型</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-keyword">var</span> ;        <span class="hljs-comment">// 定义泛型变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVar</span><span class="hljs-params">(T <span class="hljs-keyword">var</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> = <span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getVar</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span> ;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">// 直接打印</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-keyword">var</span>.toString() ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>泛型上下限使用上下限 限制了 泛型的<strong>具体类型</strong>，此时注意<code>？</code>才是真正的泛型类型。<br>具体使用时，</p><ul><li>如果该 类&#x2F;方法 是对 界限类型T的生产者，则使用<code>&lt;? extends T&gt;</code>，即在类&#x2F;方法中有类似T t &#x3D; new B(实际传入的类型)，这类<strong>生产T</strong>的操作。即可以创造一个<code>List&lt;? extends Fruit&gt;</code>，然后我们可以通过getNode()，来确保我们能获取一个Fruit。</li><li>如果该 类&#x2F;方法 是对 界限类型T的消费者，则使用<code>&lt;? super T&gt;</code>，即在类&#x2F;方法中有类似 addNode(T t)，这类<strong>消费T</strong>的操作。一般用于泛型类当中，即可以创造一个<code>List&lt;? super Apple&gt;</code>，这样就知道往这个集合里add Apple或其子类肯定是可行的，因为Apple及其子类肯定也是<code>？</code>具体类型的子类。</li></ul><p>所以，上限确保我们可以得到一个具体类型<strong>T</strong>的引用（生产，将其作为返回值获取），下限确保我们可以往类型&#x2F;方法中消耗<strong>T</strong>(消费，将其作为参数传入)。</p>          </div><div class="note note-primary">            <ul><li>在具体的泛型类&#x2F;泛型方法的<strong>声明</strong>中，一般使用<code>T</code>或<code>T extends Clazz</code>声明泛型，然后使用<strong>T</strong>进行操作。</li><li>在具体的普通引用&#x2F;普通方法的参数<strong>声明</strong>中，一般使用<code>List&lt;?&gt;</code>或<code>List&lt;? extends Clazz&gt;</code>，对传入的泛型对象的具体类型的限制。</li></ul>          </div><h4 id="多限制"><a href="#多限制" class="headerlink" title="多限制"></a>多限制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Staff</span> &amp; Passenger&gt;<br></code></pre></td></tr></table></figure><h4 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">List&lt;<span class="hljs-keyword">String</span>&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;<span class="hljs-keyword">String</span>&gt;[] list13 = (List&lt;<span class="hljs-keyword">String</span>&gt;[]) <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK，但是会有警告 </span><br>List&lt;?&gt;[] list14 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-keyword">String</span>&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//编译错误</span><br>List&lt;?&gt;[] list15 = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//OK</span><br></code></pre></td></tr></table></figure><p>泛型的语义包含类型检查的功能，如果创建<strong>具体泛型类</strong>的数组，会导致无法实现对泛型类的检查。</p><h1 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h1><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure）。</p><div class="note note-primary">            <p>回到本质，java泛型本质是为了复用代码，泛型则用于在编码时限制，编译时会对其进行擦除。</p>          </div><p>具体操作：</p><ul><li>T和？和? super Clazz都替换为Object<br><img src="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011238.png"></li><li>T extends Clazz&#x2F;? extends Clazz替换为Clazz<br><img src="/2023/01/08/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%B3%9B%E5%9E%8B%EF%BC%89/Pasted-image-20230109011241.png"></li></ul><h3 id="泛型方法-2"><a href="#泛型方法-2" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//这两个参数都是Integer，所以T为Integer类型  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> Test.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;asd&quot;</span>); <span class="hljs-comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span><br></code></pre></td></tr></table></figure><ul><li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//指定了Integer，所以只能为Integer类型或者其子类  </span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Test.&lt;Integer&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//编译错误，指定了Integer，不能为Float  </span><br><span class="hljs-type">Number</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Test.&lt;Number&gt;add(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>); <span class="hljs-comment">//指定为Number，所以可以为Integer和Float </span><br></code></pre></td></tr></table></figure><h3 id="编译期检查"><a href="#编译期检查" class="headerlink" title="编译期检查"></a>编译期检查</h3><p>Java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，再进行编译。</p><p>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>list1.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list1.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译错误  </span><br><br><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();  <br>list2.add(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//编译通过  </span><br>list2.add(<span class="hljs-number">1</span>); <span class="hljs-comment">//编译通过</span><br></code></pre></td></tr></table></figure><h3 id="泛型多态"><a href="#泛型多态" class="headerlink" title="泛型多态"></a>泛型多态</h3><p>类型擦除会导致多态冲突，如继承一个具体泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;Date&gt; &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Date value)</span> &#123;  <br>        <span class="hljs-built_in">super</span>.setValue(value);  <br>    &#125;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getValue();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如我们希望通过继承<strong>具体泛型</strong>来重写具有<strong>具体参数</strong>和<strong>具体返回值</strong>的方法，但父类由于类型擦除，参数会变成Object。导致与重写发生定义冲突。</p><p>此时，JVM会使用桥方法解决问题，以下为字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.tao.test.DateInter <span class="hljs-keyword">extends</span> <span class="hljs-title class_">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  <br>  com.tao.test.DateInter();  <br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.util.Date)</span>;  <span class="hljs-comment">//我们重写的setValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: invokespecial #<span class="hljs-number">16</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br>       <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span>  <br><br>  <span class="hljs-keyword">public</span> java.util.Date <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//我们重写的getValue方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">23</span>                 <span class="hljs-comment">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br>       <span class="hljs-number">4</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">7</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> java.lang.Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;     <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: invokevirtual #<span class="hljs-number">28</span>                 <span class="hljs-comment">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br>       <span class="hljs-number">4</span>: areturn  <br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(java.lang.Object)</span>;   <span class="hljs-comment">//编译时由编译器生成的桥方法  </span><br>    Code:  <br>       <span class="hljs-number">0</span>: aload_0  <br>       <span class="hljs-number">1</span>: aload_1  <br>       <span class="hljs-number">2</span>: checkcast     #<span class="hljs-number">26</span>                 <span class="hljs-comment">// class java/util/Date  </span><br>       <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">30</span>                 <span class="hljs-comment">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>编译器通过生成桥方法（Object作为参数和返回值等），实现对父类方法的重写，然后在其中调用我们真正重写的方法。<br>另外，桥方法getValue()看似和我们重写的getValue()冲突，但实际上JVM允许自己通过参数类型和返回类型共同确定一个方法。</p><h3 id="基本类型不能作为泛型类型"><a href="#基本类型不能作为泛型类型" class="headerlink" title="基本类型不能作为泛型类型"></a>基本类型不能作为泛型类型</h3><p>ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p><h3 id="泛型类型不能实例化"><a href="#泛型类型不能实例化" class="headerlink" title="泛型类型不能实例化"></a>泛型类型不能实例化</h3><p>编译期找不到对应的类字节码文件，无法确认具体泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(); <span class="hljs-comment">// ERROR</span><br><br><span class="hljs-comment">//解决，利用反射</span><br><span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">newTclass</span> <span class="hljs-params">(Class &lt; T &gt; clazz)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型数组不能初始化"><a href="#泛型数组不能初始化" class="headerlink" title="泛型数组不能初始化"></a>泛型数组不能初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// Error，Class</span><br><br><span class="hljs-comment">//如果对lsa进行强转Object[]，就可以对其添加其他list，导致Class错误，因此要避免这样的情况发生：</span><br><br>List&lt;?&gt;[] lsa = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// OK, array of unbounded wildcard type.</span><br>Object[] oa = (Object[]) lsa;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>li.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>));<br>oa[<span class="hljs-number">1</span>] = li; <span class="hljs-comment">// Correct.</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (Integer) lsa[<span class="hljs-number">1</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">//因为使用？来创建类型，所以array本身的定位就是可以放入不同的list，最后取出时强转，符合逻辑</span><br></code></pre></td></tr></table></figure><h3 id="PS数组类型"><a href="#PS数组类型" class="headerlink" title="PS数组类型"></a>PS数组类型</h3><p><strong>数组类可以分类可以分成两类：</strong></p><ul><li>基本类型的数组类；</li><li>引用类型的数组类；</li></ul><p>基本类型的数组类的父类是Object，即<code>int[]</code>可以强转<code>Object</code><br>引用类型的数组类的父类有<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>，即如果A extends B，A可以强转<code>Object</code>，<code>Object[]</code>，<code>Parent[]</code>。</p><h3 id="泛型数组如何正确初始化"><a href="#泛型数组如何正确初始化" class="headerlink" title="泛型数组如何正确初始化"></a>泛型数组如何正确初始化</h3><p>最好使用列表集合对其替换。或者通过反射建立，因为反射时，类型已经被确认。</p><h3 id="如何理解泛型类中的静态方法和静态变量"><a href="#如何理解泛型类中的静态方法和静态变量" class="headerlink" title="如何理解泛型类中的静态方法和静态变量"></a>如何理解泛型类中的静态方法和静态变量</h3><p>泛型类中的静态方法和静态变量<strong>不可以</strong>使用泛型类所声明的泛型类型参数，显然当静态变量建立时，具体类型还未确认。</p><h3 id="如何理解异常中使用泛型"><a href="#如何理解异常中使用泛型" class="headerlink" title="如何理解异常中使用泛型"></a>如何理解异常中使用泛型</h3><ul><li>不能<strong>捕获</strong>泛型类型的异常。（编译器禁止）<ul><li>由于类型抹去，捕获泛型类型会失效，也可能导致多个catch句子中的父子类顺序混淆</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(Class&lt;T&gt; t)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(T e) &#123; <span class="hljs-comment">//编译错误</span><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123; <span class="hljs-comment">//Integer会抹去，无法捕获</span><br>    ...<br>    &#125; <span class="hljs-keyword">catch</span>(IndexOutOfBounds e) &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>但可以在方法声明中使用泛型并抛出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> T &#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Throwable realCause) &#123;<br>        t.initCause(realCause);<br>        <span class="hljs-keyword">throw</span> t; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>由于泛型本质上是为了简化类型转换问题和约束编程，在编译时会进行类型抹去。而catch操作是一个运行时发生的事件，<strong>需要catch具体的类型</strong>，其抹去类型后，与catch的捕获异常的<strong>范围和先后顺序</strong>产生矛盾。<br>但通过限制泛型异常上界，并<strong>捕获其上界</strong>，对其进行抛出是可行的。</p>          </div><h3 id="如何获取泛型参数"><a href="#如何获取泛型参数" class="headerlink" title="如何获取泛型参数"></a>如何获取泛型参数</h3><p><strong>Type</strong>是Java所有类型实现的<strong>公共接口</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">GenericType&lt;String&gt; genericType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericType</span>&lt;String&gt;() &#123;&#125;;<br><span class="hljs-type">Type</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> genericType.getClass().getGenericSuperclass();<br><span class="hljs-comment">//getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span><br><span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> ((ParameterizedType)superclass).getActualTypeArguments()[<span class="hljs-number">0</span>]; <br>System.out.println(type);<span class="hljs-comment">//class java.lang.String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第2章（知识点）</title>
    <link href="/2023/01/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/"/>
    <url>/2023/01/07/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型有<br>boolean(1),byte(8),char(16),short(16);<br>int(32),long(64),float(32),double(64);</p><p>括号表示类型占的bit数，其中，char,byte,short不会互相转换，其计算时首先转换为int。</p><div class="note note-primary">            <p>java分内码和外码，内码指运行时内存中编码方式。除了内码的都是外码（如class文件，序列化等）。</p><ul><li>boolean：实际上JVM规范将boolean当作int来处理，也就是都占用4个字节。true为1，false为0。</li><li>char：内码中使用UTF16编码，一个字符占2个或4个字节(相当于用两个char表示一个字符)。外码中char使用UTF8编码，一个字符占1-6个字节。</li></ul>          </div><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="String-x2F-Integer-x2F-int"><a href="#String-x2F-Integer-x2F-int" class="headerlink" title="String&#x2F;Integer&#x2F;int"></a>String&#x2F;Integer&#x2F;int</h3><p>基本类型之间，char,byte,short可以转化为int,int-&gt;long-&gt;float-&gt;double可以链式转换，反向转换需要强制类型转换，可能造成数据精度损失。</p><p>String与Integer互相转化：</p><ul><li>String.valueOf(Integer)</li><li>Integer.valueOf(String)</li></ul><p>String与int互相转化：</p><ul><li>String.valueOf(int) &#x2F; int + “”</li><li>Integer.parseInt(“int”)</li></ul><p>Integer与int互相转化：</p><ul><li>Integer.valueOf()</li><li>integer.intValue()</li></ul><div class="note note-primary">            <p>可见，对于具体类（String,Integer）,valueOf是一个将其他类型转化为本类型的通用方法。涉及到其他类型转化为基本类型时，需要使用<code>Integer.parseInt(string)</code>和<code>integer.intValue()</code>这种特殊方法。</p>          </div><h3 id="隐式类型"><a href="#隐式类型" class="headerlink" title="隐式类型"></a>隐式类型</h3><h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>1.1字面量是double类型的。<br><code>float f = 1.1f</code></p><h4 id="short"><a href="#short" class="headerlink" title="short"></a>short</h4><p>1字面量是int类型的<br><code>short s1 = 1</code>不可行，而<code>+=</code>可以实现隐式转换<br><code>s1 += 1</code>;<br>相当于s1 &#x3D; (short)(s1 + 1)</p><h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li><li>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</li></ul><p><strong>自动装箱</strong>的过程，默认调用的是<strong>valueOf</strong>,因此会先判断对象是否在缓存池。</p><blockquote><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul></blockquote><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 被声明为 final，因此它不可被继承。其内部使用一个final的char数组存储字符。</p><blockquote><p>JDK9时改为<code>byte[]</code>，因为一个char为2或4字节（UTF16），但大多数情况下char只需要1字节标识，所以使用Latin-1字符集表示即可。当遇到无法表示的字符时，String在转化字符集。</p></blockquote><h3 id="不可变的原因"><a href="#不可变的原因" class="headerlink" title="不可变的原因"></a>不可变的原因</h3><ul><li>String常作为hashKey，不可变时，每个String对象只需要计算一次hash；</li><li>StringPool，不可变才可重复利用；</li><li>安全性，其常作为网络连接参数，不可变保证其正常运行。</li><li>String天生线程安全。</li></ul><h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><ul><li>String不可变，StringBuffer和StringBuilder可变</li><li>String线程安全，StringBuilder线程不安全，<strong>StringBuffer线程安全</strong>，内部synchronized进行同步。</li></ul><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><ul><li>String s1 &#x3D; new String(“aaa”)不会将对象放入线程池</li><li>String s2 &#x3D; “bbb”会自动将对象放入线程池</li><li>String s3 &#x3D; s1.intern()会将s1放入线程池<br>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>HotSpot字符串常量池放在哪里？</p><ul><li>JVM虚拟机规范中：规定<strong>运行时常量池</strong>在方法区（<strong>方法区只是一个逻辑概念</strong>）内。</li><li>方法区在不同的虚拟机中有不同的实现，HotSpot才有永久代的概念。但随着时间发展，HotSpot也放弃了永久代的概念。</li></ul><table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table><div class="note note-primary">            <ul><li>1.6前，方法区由永久代（ALL）实现。</li><li>1.7时，方法区由永久代（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量）共同实现。</li><li>1.8时，方法区由元空间（类型信息、字段、方法、常量static final）和堆（字符串常量池、静态变量static）共同实现。</li></ul>          </div><h1 id="二、运算"><a href="#二、运算" class="headerlink" title="二、运算"></a>二、运算</h1><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>减去一个正数 &#x3D; 加上一个负数 &#x3D; 加上一个进位值再减去该数的绝对值 &#x3D; 对原正数求补码并加一（这与我们对负数的补码的定义是相同的）</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="Mod与"><a href="#Mod与" class="headerlink" title="Mod与%"></a>Mod与%</h3><h4 id="求余"><a href="#求余" class="headerlink" title="%求余"></a>%求余</h4><p>a % b &#x3D; c…<code>d</code><br>余数的正负取决于被除数，顾名思义，求余，是指被除数 除以 除数 之后<strong>剩下</strong>的值（求余时，得到的c是<strong>向0取整</strong>的），因此肯定余被除数的符号相同。<br>eg:<br>9%4 &#x3D; 2…<code>1</code><br>9%-4 &#x3D; -2…<code>1</code><br>-9%4 &#x3D; -2…<code>-1</code><br>-9%-4 &#x3D; -2…<code>-1</code></p><h4 id="mod取模"><a href="#mod取模" class="headerlink" title="mod取模"></a>mod取模</h4><p>a mod b &#x3D; c…<code>d</code><br>mod时，结果与除数相同，（得到的c是<strong>向下取整</strong>的）<br>eg:<br>9mod4 &#x3D; 2…<code>1</code><br>9mod-4 &#x3D; -3…<code>-3</code><br>-9mod4 &#x3D; -3…<code>3</code><br>-9mod-4 &#x3D; 2…<code>-1</code></p><div class="note note-primary">            <p>java中%表示求余，但python中%表示求模。且java中的取模操作为<code>Math.floorMod(a,b)</code></p>          </div><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><div class="note note-primary">            <p>所有位运算都是针对补码而言的</p>          </div><h4 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h4><p>相当于 <code>*2</code></p><h4 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移&gt;&gt;"></a>右移&gt;&gt;</h4><p>相当于 <code>/2</code>,向下取整eg:<code>5&gt;&gt;1 = 2</code>,<code>-5&gt;&gt;1 = -3</code><br>(负数的高位补1)</p><h4 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移&gt;&gt;&gt;"></a>无符号右移&gt;&gt;&gt;</h4><ul><li>对于正数相当于<code>/2</code>，向下取整。</li><li>对于负数，结果需要具体计算(负数的高位补0)</li></ul><h4 id="取反"><a href="#取反" class="headerlink" title="取反~"></a>取反~</h4><p>~n &#x3D; -(n+1)<br>eg:</p><ul><li>正数：<br>~ 3 &#x3D; -(3+1) &#x3D; -4<br>~0011 &#x3D; -(0011+0001) &#x3D; -0100 &#x3D; 1100</li><li>负数：<br>~ (-3) &#x3D; -(-3+1) &#x3D; 2<br>~1101 &#x3D; -(1101+0001) &#x3D; -1110 &#x3D; 0010</li></ul><div class="note note-primary">            <p>由上可见，在二进制上，取反相当于把1置0，把0置1。<br>在具体值上，我们是对原值的补码进行求反，得到的是答案的补码。<br>如果是正数，符号变负，且绝对值+1。<br>如果是负数，符号变正，且绝对值-1。<br>注意到这个过程是可以相互抵消的，即<del>(</del>n) &#x3D; n，从二进制角度来看，也很符合常理。</p><p>如何求-n的补码：<br>~n+1 &#x3D; -(n+1)+1 &#x3D; -n</p>          </div><div class="note note-success">            <p>取反可以理解成以-0.5为轴旋转！</p>          </div><h4 id="自增"><a href="#自增" class="headerlink" title="自增++"></a>自增++</h4><p>自增++线程不安全<br>i++：先将变量从局部变量表拷贝到操作数栈顶，再对局部变量表中变量执行自增。<br>++i：先对局部变量表中变量执行自增，再将变量从局部变量表拷贝到操作数栈顶。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>java只有值传递，对于对象，传递的是对象的引用指针。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch条件判断语句中可以使用<br>byte,short,char,int,枚举(jdk5.0)，String对象(jdk7.0)，但不能使用long类。<br><strong>PS</strong>：实际上能string对象也只是一个语法糖，底层通过string对象的hash值处理。</p><div class="note note-primary">            <p>本质就是指能处理int相关的类型和枚举，对String提供了额外支持。</p>          </div><h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h3 id="Java-中的编译期常量是什么-使用它有什么风险"><a href="#Java-中的编译期常量是什么-使用它有什么风险" class="headerlink" title="Java 中的编译期常量是什么? 使用它有什么风险?"></a>Java 中的编译期常量是什么? 使用它有什么风险?</h3><p>这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。<br>这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h3 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别?"></a>Java 中，Serializable 与 Externalizable 的区别?</h3><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。<br>Externalizable 接口要求重写 writeExternal 和 readExternal 方法，允许手动控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>声明为static和transient类型的数据不能被序列化，反序列化需要一个无参构造函数。<br>transient的内存语义就是其只存在于内存而不会被写入磁盘，可以将一些不希望被序列化的字段加上该关键字。</p><blockquote><p>当使用Externalizable手动实现序列化时不受该限制。</p></blockquote><h3 id="Object有哪些公用方法"><a href="#Object有哪些公用方法" class="headerlink" title="Object有哪些公用方法?"></a>Object有哪些公用方法?</h3><p>clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。</p><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>继承角度：</p><ul><li>一个子类只能继承一个抽象类, 但能实现多个接口</li></ul><p>构造角度：</p><ul><li>抽象类可以有构造方法, 接口没有构造方法</li></ul><p>成员变量角度：</p><ul><li>抽象类可以有普通成员变量, 接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能<strong>public static final</strong>(默认)</li></ul><p>成员方法角度：</p><ul><li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default和static方法，在JDK9中允许有private方法</li><li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li></ul><div class="note note-primary">            <p>注意，接口不能拥有成员变量，但可以拥有静态变量。<br>抽象类可以有具体方法（代码复用），但具体类不能有抽象方法。<br>抽象类可以有静态方法，接口在JDK8之前没有，JDK8之后有。<br>接口：JDK8前只有public abstract，JDK8允许default和static，JDK9允许private。</p>          </div><h3 id="关于finally"><a href="#关于finally" class="headerlink" title="关于finally"></a>关于finally</h3><ul><li>finally不管有没有异常都要处理</li><li><strong>当try和catch中有return时，finally仍然会执行，finally比return先执行</strong>，finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以<strong>函数返回值是在finally执行前确定</strong>的</li><li><strong>finally中最好不要包含return</strong>，这样返回值不是try或catch中保存的返回值，而是finally中的return值。</li></ul><p>finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电。</p><h3 id="局部变量为什么要手动初始化赋值"><a href="#局部变量为什么要手动初始化赋值" class="headerlink" title="局部变量为什么要手动初始化赋值"></a>局部变量为什么要手动初始化赋值</h3><p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，<strong>如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销</strong>，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，<strong>解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java第1章（面向对象）</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>属性和操作分离，即通过get,set方法操作属性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，子类可以获得父类非 private的属性和方法。</p><div class="note note-primary">            <p>继承应该遵循<strong>里氏替换</strong>原则，子类对象必须能够替换掉所有父类对象。</p>          </div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>:</p><ul><li>编译时多态主要指方法的<strong>重载</strong></li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件:</p><ul><li>继承</li><li>覆盖(重写)</li><li>向上转型</li></ul><blockquote><p>即子类要继承父类，覆盖父类的方法，并使用了父类的指针。</p></blockquote><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 (Generalization)"></a>泛化关系 (Generalization)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191817.png"><br>即继承父类</p><h3 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 (Realization)"></a>实现关系 (Realization)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191831.png"><br>即实现接口</p><h3 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 (Aggregation)"></a>聚合关系 (Aggregation)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191859.png"><br>弱依赖，整体不存在了部分也还是存在。</p><h3 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 (Composition)"></a>组合关系 (Composition)</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106191919.png"><br>强依赖，整体不存在了部分也不存在了。</p><h3 id="关联关系（Association）"><a href="#关联关系（Association）" class="headerlink" title="关联关系（Association）"></a>关联关系（Association）</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192246.png"><br>1对1，1对n，n对1。</p><h3 id="依赖关系（Dependency）"><a href="#依赖关系（Dependency）" class="headerlink" title="依赖关系（Dependency）"></a>依赖关系（Dependency）</h3><p><img src="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/Java/Java%E5%9F%BA%E7%A1%80/Java%E7%AC%AC1%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/Pasted-image-20230106192243.png"><br>A是B类的局部变量、参数，或A向B发送信息。</p><h2 id="面向对象的规则"><a href="#面向对象的规则" class="headerlink" title="面向对象的规则"></a>面向对象的规则</h2><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>Java 中有三个访问权限修饰符（四个访问权限等级）: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>对<strong>类</strong>或类中的成员(<strong>字段</strong>以及<strong>方法</strong>)加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>对于<strong>类</strong>：只有public和defualt修饰符<br>对于<strong>成员</strong>：4种访问等级都有，protected表示<strong>本包和子类</strong>可见</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>1.修饰数据<br>表示数据为不可改变，其只针对编译期检查，运行时会抹去。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变。</li></ul><p>2.修饰类<br>表示类不可继承</p><p>3.修饰方法<br>表示不可重写</p><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>1.静态变量<br>静态变量就是类变量<br>2.静态方法<br>类加载时就存在，必须实现，不可为抽象方法，也只能访问所属类的静态变量和静态方法<br>3.静态代码块<br>见代码块，类初始化时运行<br>4.静态内部类<br>不依赖外部实例的静态类（内部类本质上是一个单独的class文件）</p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>一个类至少有一个构造器，如果显式定义了构造器，系统默认的无参构造器会失效。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块分：</p><ul><li>普通代码块：类的方法体</li><li>构造代码块：即类中的{}</li><li>静态代码块：即类中的static {}</li></ul><div class="note note-primary">            <p>静态代码块是类加载时执行的，只会在第一次new时执行一次，是类的初始化<br>构造代码块是每新建一个实例都会执行一次，是对象的初始化</p>          </div><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>新建对象调用顺序：<br>静态代码块（只会调用一次）-&gt; 构造代码块 -&gt; 构造器</p><p>因此属性的赋值：</p><ul><li>静态初始化（静态赋值和静态代码块按照执行顺序）</li><li>默认初始化（0,false）</li><li>构造初始化（普通赋值和构造代码块按执行顺序）</li><li>构造函数</li></ul><div class="note note-primary">            <p>注意，构造初始化在构造函数前执行！</p>          </div><p>存在继承时：</p><ol><li>父类静态、子类静态</li><li>父类构造初始化、父类构造函数</li><li>子类构造初始化、子类构造函数</li></ol><div class="note note-primary">            <p>静态变量是可以不赋初值的，当其被声明时，会先赋予默认值，可以后续再赋予初值。</p>          </div><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类和抽象方法一定使用 abstract 关键字进行声明。<br>很容易理解：</p><ul><li>抽象类不能被实例化</li><li>抽象方法不能出现在非抽象类中</li></ul><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口在Java 8之前是纯抽象类，在JAVA8之后其允许默认的方法实现。</p><ul><li>接口的成员，字段都默认（且必须）是Public的</li><li>接口的字段默认是static final的</li></ul><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p>抽象类是IS-A关系，接口是LIKE-A关系</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>接口：多重继承，主要用于表示实现类拥有具体方法。<br>抽象类：主要用于在相关类中共享代码。<br>优先使用接口</p><h4 id="super字段"><a href="#super字段" class="headerlink" title="super字段"></a>super字段</h4><ul><li>super()<br>父类的构造函数，如果子类使用必须放在子类构造函数的第一排</li></ul><h4 id="this字段"><a href="#this字段" class="headerlink" title="this字段"></a>this字段</h4><p>在方法中，this指方法所属对象（static方法里不能有this）<br>在构造函数中，this指正在初始化的对象</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写限制（里氏原则）：</p><ul><li>子类方法访问权限大于父类</li><li>子类方法返回值为父类返回值或其子类</li></ul><p>@Override会对以上限制进行检查。</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>同一个方法的参数：个数，类型，顺序至少一个不同</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类也都是独立的类，均有单独的class文件，但前面会有外部类的类名和$符<br>分类：</p><ul><li>成员内部类<ul><li>静态内部类</li><li>非静态内部类</li></ul></li><li>局部内部类、匿名内部类</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>作为成员：</p><ul><li>成员内部类可以声明为private或protected，可以调用外部内的结构</li><li>如果是static的成员内部类，可以脱离父类实例存在，因此也只能使用父类静态成员。</li></ul><p>作为类：<br>可以声明为abstract被其他内部类继承，也可以声明为final禁止继承</p><div class="note note-primary">            <p>不存在静态的外部类，因为这没有意义，外部类的成员只要标注为static就能任意使用。<br>而内部类可以标注为静态，表示其可以脱离父实例而存在，因此若内部类需要再使用static成员，其类本身也必须为static，才可以任意使用。</p>          </div><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>即在方法中声明一个内部类，声明后在只能在方法体内使用。<br>（但可以在方法最后返回这个内部类实例，不过返回值应该设置为该内部类的父类或父接口，毕竟外部不认识该局部内部类）</p><p>其可以使用外部类的成员（包括私有的）、外部方法的局部变量，但必须是final修饰的</p><p>因为是一个局部的，短暂的类，所以其与局部变量类似，不存在修饰符，也不能为静态类或拥有静态成员。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类必须继承父类或实现接口，其只有一个对象，只能多态引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentClass</span>|ParentInterface()&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>局部内部类是主要用于在一个方法中，我们短暂的需要一个结构体来处理问题时使用；而如果我们明确只需要一个具体的函数，但不想为此创造一个新类，且这个函数已经有明确的父类或接口，我们则可以让局部内部类退化为匿名内部类实现这个方法即可。<br>同样，匿名内部类的方法也可以使用外部的变量，但外部的变量必须是final修饰的：<br>匿名内部类，之所以能够使用外部变量，是因为其底层将外部变量作为构造参数传入了匿名内部类，问题的核心在于，如果不声明外部变量为final，当外部变量变化时，匿名内部类无法感知这个变化，可能会导致数据的不一致问题。实际上，JDK8中我们不再需要显示的将外部变量声明为final，其实底层还是为我们加上了final（语法糖）。<br>不过回到final的知识点，读写final字段对于JVM而言，主要是在编译期起限制重排序的作用，详情见JUC。</p>          </div><div class="note note-primary">            <p>匿名内部类是lambda表达式的原型，因此也很好理解为声明lambda表达式只能使用final变量</p>          </div><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><ul><li>equals()<br>默认为比较对象是否等价，需要满足对称等性质。<br><code>==</code>则判断值（基本类型或指针）是否相等。 </li><li>hashCode()<br>默认：是一个native方法，返回int，使用的是对象的地址（引用地址）进行计算。<br>其可以被覆盖（String,Integer等都覆盖了这个方法）。对于两个对象，如果equals返回true,其hashCode()必须相等，因此覆盖equals时总是应该覆盖hashCode方法。</li><li>toString()<br>默认返回对象类型+@+16进制的hashCode()</li><li>clone()<br>clone()是一个native,protected方法<blockquote><p>因为clone修饰符为protected，其只对本包和其子类可见，对于自定义类1，2<br>在类1中调用类2的clone()，Object的默认clone只对类2可见，对类1不可见，所以要重写，一般重写为 return (T)super.clone()</p></blockquote></li></ul><p>另外，一个类要使用clone()方法，必须先继承Cloneable接口，并重写clone()，且要抛出CloneNotSupportedException异常。</p><p>另外，克隆也有浅拷贝和深拷贝，native的clone()只能获得一个对象的<strong>浅拷贝</strong>，对象的属性（引用类型）仍相同。想要获得<strong>深拷贝</strong>，需要在重写中实现。</p><p>替代方案，clone()既复杂又危险，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CloneConstructorExample</span><span class="hljs-params">(CloneConstructorExample original)</span> &#123;<br>        arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[original.arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; original.arr.length; i++) &#123;<br>            arr[i] = original.arr[i];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>类的对象有限且确定时可以使用枚举。</p><ul><li>enum定义的枚举类默认继承了java.lang.Enum类。</li><li>枚举类的构造器只能使用 private 权限修饰符。</li><li>必须在枚举类的第一行声明枚举类对象</li></ul><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> <br>&#123; <br>    RED, GREEN, BLUE; <br>&#125;<br><span class="hljs-comment">//实际使用中，有一种获取静态变量的感觉</span><br>Color.RED<br><br><span class="hljs-comment">//通用方法和字段</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    RED(<span class="hljs-string">&quot;红色&quot;</span>, <span class="hljs-number">1</span>), GREEN(<span class="hljs-string">&quot;绿色&quot;</span>, <span class="hljs-number">2</span>), BLANK(<span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-number">3</span>), YELLO(<span class="hljs-string">&quot;黄色&quot;</span>, <span class="hljs-number">4</span>);  <br>    <span class="hljs-comment">// 成员变量  </span><br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;  <br>    <span class="hljs-comment">// 构造方法  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Color</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>        <span class="hljs-built_in">this</span>.index = index;  <br>    &#125;  <br>    <span class="hljs-comment">// 普通方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Color c : Color.values()) &#123;  <br>            <span class="hljs-keyword">if</span> (c.getIndex() == index) &#123;  <br>                <span class="hljs-keyword">return</span> c.name;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;<br>get,set...<br>&#125;<br><br><span class="hljs-comment">//也可以声明抽象方法并在所有枚举中实现</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;红色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    GREEN&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;绿色&quot;</span>;<br>        &#125;<br>    &#125;,<br>    BLUE&#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//枚举对象实现抽象方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;蓝色&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>;<span class="hljs-comment">//定义抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>枚举更像是在创建父类后，在父类中直接构造子类。</p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>指一个公共的，有无参公共构造器，有对应的set，get方法的，即一个标准的实体类。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><strong>私有化构造器</strong>（外部不能new）</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>类自己持有自己的实例</strong>，通过static方法取得该实例，饿汉式表示会预加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>只有调用时才加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton single;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(single == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-type">return</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> single;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里省略了线程安全的部分。</p></blockquote><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>顾名思义，一个类A为另一个类做B代理，通过操作A来操作B<br>作用：</p><ul><li>屏蔽真实角色</li><li>增强功能，如添加权限，访问控制和申计</li><li>延迟加载</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>定义一个接口和实现类</li><li>定义一个代理类，实现该接口</li><li>将实现类注入代理类，实现代理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代理类AdminServiceProxy与真实类AdminService继承相同的接口，即实现相同的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdminService</span> &#123;<br><span class="hljs-comment">//以字段的形式持有真实对象</span><br>    <span class="hljs-keyword">private</span> AdminService adminService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceProxy</span><span class="hljs-params">(AdminService adminService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adminService = adminService;<br>    &#125;<br><span class="hljs-comment">//代理方法，可以在前后进行增强</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre&quot;</span>);<br>        adminService.update();<br>        System.out.println(<span class="hljs-string">&quot;post&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;pre1&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;pre2&quot;</span>);<br>        <span class="hljs-keyword">return</span> adminService.find();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>静态代理有<strong>适配器模式</strong>中对象适配器（聚合原类，继承接口）的影子，区别在于这里的原类也继承了该接口。静态代理编写代码时就明确了被代理类和方法。</p></blockquote><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>又名JDK动态代理，使用反射实现动态代理<br>优点：<strong>Proxy对象不需要实现接口，即不用实现接口所有的方法。</strong></p><ul><li>定义一个接口和一个实现类</li><li>定义一个服务类实现<code>InvocationHandler</code>接口，并重写invoke方法。</li><li>通过<code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code>创建代理对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//reflect包中的静态方法，使用类加载器（不管）、接口列表（即生成的代理对象要实现哪些方法）、和事件处理器（代理对象在原目标上要做哪些加强）生成一个新的代理对象</span><br><span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler invocationHandler )</span>;<br><br><span class="hljs-comment">//事件处理器，主要用来写增强的内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceInvocation</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceInvocation</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理类，通过传入 增强器 和 代理目标，生成代理对象,后续可根据这个该代理类实体获取代理对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServiceDynamicProxy</span> extends &#123;<br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-keyword">private</span> InvocationHandler invocationHandler;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServiceDynamicProxy</span><span class="hljs-params">(Object target,InvocationHandler invocationHandler)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.invocationHandler = invocationHandler;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getPersonProxy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), invocationHandler);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>即通过反射的invoke方法，执行目标对象的目标方法。增强器会聚合被代理对象，但不需实现所有接口，invoke最终只会增强指定接口对应的方法。<br>被代理的对象类型没有被限定，因此可以复用增强器。</p></blockquote><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>优点：<strong>代理目标对象没有实现接口时可使用</strong>，其会实现一个子类，实现对target对象的代理，因此target类不能为final。</p><blockquote><p>Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。（Cglib代理可能是为了弥补无接口的方法的代理问题而出现的。）</p></blockquote><ul><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object object, Method method, Object[] arg2, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;判断用户是否有权限进行操作&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(target);<br>        System.out.println(<span class="hljs-string">&quot;记录用户执行操作的用户信息、更改内容和时间等&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//使用</span><br><span class="hljs-type">AliSmsService</span> <span class="hljs-variable">aliSmsService</span> <span class="hljs-operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br></code></pre></td></tr></table></figure><blockquote><p>这里的增强器没有聚合被代理类，只将其作为拦截方法参数。然后通过代理类工厂将增强器和被代理类聚合在一起生成新类。</p></blockquote><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><h4 id="静态代理与动态代理"><a href="#静态代理与动态代理" class="headerlink" title="静态代理与动态代理"></a>静态代理与动态代理</h4><ul><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ul><li><strong>JDK动态代理只能代理实现了接口的类或者直接代理接口，而CGLIB可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第7章（性能监控）</title>
    <link href="/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <url>/2023/01/06/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC7%E7%AB%A0%EF%BC%88%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="状态命令"><a href="#状态命令" class="headerlink" title="状态命令"></a>状态命令</h1><ul><li>状态信息 - <code>info</code><br>通过<code>info</code>命令查看实时吞吐量（ops&#x2F;sec）。</li><li>监控执行命令 - <code>monitor</code><br>监控接受到的命令</li><li>监控延迟 - <code>latency</code><br>测量响应延迟<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli --latency -h 127.0.0.1<br></code></pre></td></tr></table></figure></li><li>内部机制监控<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CONFIG SET latency-monitor-threshold 100 <span class="hljs-comment">#100是阈值，只有慢于100ms的才记录</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">latency latest <span class="hljs-comment">#查看最后一条消息的延迟</span></span><br><br></code></pre></td></tr></table></figure></li></ul><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="避免使用过于复杂的命令"><a href="#避免使用过于复杂的命令" class="headerlink" title="避免使用过于复杂的命令"></a>避免使用过于复杂的命令</h2><p>可以查看slowlog，查看执行慢的命令。</p><h2 id="操作BigKey"><a href="#操作BigKey" class="headerlink" title="操作BigKey"></a>操作BigKey</h2><p>如果value过大，分配内存会比较耗时。<br>可以通过<code>--bigkeys</code>命令扫描</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>避免使用bigkey</li><li>4.0版本以下，使用unlink代替del</li><li>6.0版本以上，开启lazy-free机制<div class="note note-primary">            <p>unlink和lazy-free都可以把释放内存放在后台线程中执行。</p>          </div></li></ul><h2 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h2><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>随机过期时间</li><li>lazy-free</li></ul><h2 id="内存达到上限（max-memory）"><a href="#内存达到上限（max-memory）" class="headerlink" title="内存达到上限（max-memory）"></a>内存达到上限（max-memory）</h2><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>改成allkeys随机淘汰</li><li>拆分实例</li></ul><h2 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h2><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><ul><li>控制内存大小（fork与实例大小有关）</li><li>合理配置持久化策略</li></ul><h2 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h2><p>我们都知道，应用程序向操作系统申请内存时，是按内存页进行申请的，而常规的内存页大小是 4KB。<br>Linux 内核从 2.6.38 开始，支持了内存大页机制，该机制允许应用程序以 2MB 大小为单位，向操作系统申请内存。<br>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p><h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>关闭内存大页机制</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul><li>写磁盘的瓶颈</li><li>子线程将aof刷入盘中的过程如果阻塞也会影响主线程写aof</li></ul><p>一般下面一种情况发生在：</p><ul><li>正在重写aof</li><li>其他应用程序大量占用磁盘IO</li></ul><h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>配置中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-literal">no</span>-appendfsync-<span class="hljs-literal">on</span>-rewrite <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>禁止了重写时的同步磁盘</p><h2 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h2><p>避免了上下文切换，但Redis有子进程，子进程若大量占用被绑定的CPU，会导致主进程受阻。</p><h3 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h3><p>若一定要绑定，可绑定到多个CPU上，Redis6.0已经支持各线程分别绑定CPU</p><h2 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h2><p>如果你对操作系统有些了解，就会知道操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是 Swap。</p><h3 id="解决-7"><a href="#解决-7" class="headerlink" title="解决"></a>解决</h3><ul><li>增加内存</li><li>整理内存</li></ul><h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>碎片内存会降低使用效率</p><h3 id="解决-8"><a href="#解决-8" class="headerlink" title="解决"></a>解决</h3><p>整理内存也CPU资源，需要谨慎</p><h2 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h2><h3 id="解决-9"><a href="#解决-9" class="headerlink" title="解决"></a>解决</h3><p>网络IO瓶颈，需要及时扩容。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第6章（缓存问题）</title>
    <link href="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <url>/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><ul><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩</li><li>缓存污染（或者满了）</li><li>缓存和数据库一致性</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>缓存穿透是指<strong>缓存和数据库中都没有的数据</strong>。<br>缓存不命中则会一直请求数据库，数据库查不到，又无法写入缓存。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>禁止非法请求，如校验参数合法性</li><li>数据库取不到的数据，在redis中置为key-null，防止大量数据库请求</li><li>bloomfilter，判断key是否在容器中</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>缓存击穿是指<strong>缓存中没有但数据库中有的数据</strong>（单一过期）<br>缓存过期导致大量针对该过期数据的请求段时间发生。</p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>设置数据永不过期</li><li>接口限流、熔断</li><li>互斥锁</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>缓存雪崩是指缓存中<strong>数据大批量到过期时间，而查询数据量巨大</strong>（大量同时过期）</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li><li>设置热点数据永远不过期。</li></ul><h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><p>部分数据缓存后<strong>使用率低</strong>，占用内存。</p><h3 id="最大缓存设置"><a href="#最大缓存设置" class="headerlink" title="最大缓存设置"></a>最大缓存设置</h3><p><strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销</strong>。</p><h3 id="新数据进入redis"><a href="#新数据进入redis" class="headerlink" title="新数据进入redis"></a>新数据进入redis</h3><p>当新数据进入redis时，如果内存不足怎么办？</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemorylfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li></ul><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>通过<code>max-memory</code>配置设置淘汰策略<br>Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。</p><p><strong>怎么理解呢</strong>？主要看分三类看：</p><ul><li>不淘汰<ul><li>noeviction （v4.0后默认的）</li></ul></li><li>对设置了过期时间的数据中进行淘汰<ul><li>随机：volatile-random</li><li>ttl：volatile-ttl</li><li>lru：volatile-lru</li><li>lfu：volatile-lfu</li></ul></li><li>全部数据进行淘汰<ul><li>随机：allkeys-random</li><li>lru：allkeys-lru</li><li>lfu：allkeys-lfu</li></ul></li></ul><p>具体而言：</p><ol><li>noeviction<br>写满了就停止服务。</li><li>volatile-random<br>对会过期的键随机删除</li><li>volatile-ttl<br>对即将过期的时间进行排序，删除</li><li>volatile-lru(last-recently-used)<br>对最后使用时间进行排序，删除最后一次使用较早的数据</li><li>volatile-lfu（4.0后新增）<br>对使用次数进行排序，删除最少使用的数据</li><li>allkeys-random</li><li>allkeys-lru</li><li>allkeys-lfu</li></ol><div class="note note-primary">            <p>淘汰策略 不是 过期清理策略，其不太关心键是否已经过期，只将是否设置了过期、过期时间作为筛选的范围。<br>volatile的挑选范围是<code>所有可能过期的数据</code>。<br>allkeys的挑选范围是<code>所有数据</code>。</p>          </div><h4 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h4><ul><li>redis每个数据都会记录最后访问的时间戳（redisObject的lru字段，24位时间戳）和最近使用次数（只有开启LFU时才记录，字段变成lfu，16位时间戳+8位访问次数）。</li><li>LRU淘汰时：<ul><li>随机选N个数据（可以通过maxmemory-samples设置）</li><li>排序lru字段</li><li>淘汰lru最小的数据</li></ul></li><li>LFU淘汰时：<ul><li>根据访问次数筛选（lru字段后8bit）</li><li>淘汰访问次数最低的数据（次数相同则比较最后使用时间，前16bit）</li></ul></li></ul><blockquote><p>8bit只能记录255次使用，到达后LFU会退化为LRU，因此有策略控制lfu的增长。</p></blockquote><p><code>lfu-log-factor</code>，有新访问时，只有满足一定算法条件时才count++<br><code>lfu-decay-time</code>，有新访问时，会按照算法对count进行衰减。</p><h2 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h2><p>一般流程：<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105015406.jpg"></p><p>修改数据库数据时，缓存与数据库必然存在不一致情况：<br>1.先写数据库，再删除redis，后者的删除可能未执行<br>2.先删除redis，再写数据库，后者还未执行redis可能就又刷新了。</p><h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h4><p><strong>写后失效缓存</strong><br>读时：</p><ul><li><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</li><li><strong>命中</strong>：应用程序从cache中取数据，取到后返回。<br>写时：</li><li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li></ul><h4 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h4><p>应用程序不直接接触数据库，由缓存代理该过程。<br>相比Cache Aside模式：<br>读时：</p><ul><li><strong>失效</strong>：都会查找数据库然后同步到缓存，但Read Pattern会先缓存再返回。<br>写时：</li><li><strong>更新</strong>：Write Pattern会先<strong>更新</strong>缓存再写数据库，最后返回。<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105020042.png"></li></ul><h4 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h4><p>更新时只更新缓存，定期异步批量更新数据库。<br><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105023335.png"><br>性能高，但数据一致性弱，实现较复杂，要判断哪些需要持久化。</p><h3 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h3><h4 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h4><p>以Cache Aside Pattern为例：<br>读操作（失效时）：1.查找数据库 2.更新缓存<br>写操作：1.修改数据库 2.失效缓存</p><p>同步进行读、写时，若读写先后完成了对数据库的查询、修改，此时写操作先失效缓存导致读操作将旧信息更新到了缓存。<br>即 读1-&gt;写1-&gt;写2-&gt;读2</p><p>该事件这个概率较低，其只发生在读时失效且刚好有并发写操作，且写操作较慢且需要锁表，读操作一般肯定已经完成，所以这个概率会很低。当然最好还是为缓存设置过期时间。</p><h4 id="缓存更新失效"><a href="#缓存更新失效" class="headerlink" title="缓存更新失效"></a>缓存更新失效</h4><p>解决写操作第二步：失效缓存因为异常导致没有执行的问题</p><h5 id="方案1：队列-重试"><a href="#方案1：队列-重试" class="headerlink" title="方案1：队列+重试"></a>方案1：队列+重试</h5><p><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105024206.png"><br>优点：队列解决了缓存更新失败的问题<br>缺点：对代码的侵入量大，影响服务速度</p><h5 id="方案2：队列-重试-非业务代码做异步更新缓存"><a href="#方案2：队列-重试-非业务代码做异步更新缓存" class="headerlink" title="方案2：队列+重试+非业务代码做异步更新缓存"></a>方案2：队列+重试+非业务代码做异步更新缓存</h5><p><img src="/2023/01/05/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC6%E7%AB%A0%EF%BC%88%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%89/Pasted-image-20230105181554.png"><br>由非业务代码读取mysql的操作，然后更新缓存。<br>优点：不侵入业务<br>缺点：同步速度慢<br>例子：canal</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第5章（高可用）</title>
    <link href="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/"/>
    <url>/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><blockquote><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p></blockquote><p><strong>主从复制的作用</strong>主要包括：<br>性能上：</p><ul><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>读写分离</strong>：<ul><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li></ul></li></ul><p>稳定性上：</p><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>1.从节点 发送指令replicaof ip port，主节点接受并响应<br>2.从节点 连接master的socket<br>3.从节点 发送指令auth password<br>4.主节点 验证授权<br>5.从节点 发送自身信息，主节点保存slave</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li>全量复制</li><li>增量复制</li></ul><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104040638.jpg"><br><strong>第一阶段</strong>：主从库间建立连接、协商同步的过程。</p><ul><li>从节点发送psync命令，其应该包含主库的runId和offset，但这是初次复制，所以发送的runId&#x3D;?,offset&#x3D;-1。</li><li>主节点回复FULLRESYNC，并携带runId和offset，告诉从节点自身信息。</li></ul><p><strong>第二阶段</strong>：主库将所有数据同步给从库。</p><ul><li>主库执行bgsave，将其发送给从库。</li><li>从库接受到RDB时，先清空数据库，再加载RDB。</li><li>主库在这一阶段会把新的写命令记录在repl buffer中。</li></ul><p><strong>第三阶段</strong>：主库发送期间同步期间产生的新的写命令。</p><div class="note note-primary">            <p>注意这里的repl buffer，前面讲AOF持久化时，也有一个aof_buffer，用于记录<strong>重写</strong>时的新写入命令。</p>          </div><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><blockquote><p>每次都全量复制的开销过大。</p></blockquote><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104041537.jpg"></p><p><code>repl_backlog_buffer</code>：环形缓冲区，用于记录写命令（会覆盖）。repl_baklog文件记录了命令偏移，<strong>主节点的offset</strong>和<strong>从节点的offset</strong>（但还是会以从节点ask发来的offset为准）。</p><p><code>replication buffer</code>：每个client连上Redis后，<strong>Redis都会分配一个client buffer</strong>，所有数据交互都是通过这个buffer进行的。Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。repl buffer的默认大小为1M。</p><h4 id="全量复制还是增量复制？"><a href="#全量复制还是增量复制？" class="headerlink" title="全量复制还是增量复制？"></a>全量复制还是增量复制？</h4><p>从库会记录自己的<code>slave_repl_offset</code>，恢复连接时，从库会通过<code>psync</code>发送自己的offset，主库根据这个offset判断进行增量还是全量复制。（如果<code>repl_backlog_buffer</code>的<code>slave_repl_offset</code>已经被覆盖，进全量复制）。</p><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741726.png"></p><div class="note note-primary">            <p>run id是属于主机的唯一的id。</p>          </div><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741728.png"></p><div class="note note-primary">            <p>主从节点都会发心跳，目的都有判断对方是否在线，此外从节点还会汇报自己的复制进度。</p>          </div><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741729.png"></p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/202207221741730.png"></p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="主服务器持久化与安全性"><a href="#主服务器持久化与安全性" class="headerlink" title="主服务器持久化与安全性"></a>主服务器持久化与安全性</h3><ul><li>主从复制时，主服务器强烈建议开启持久化。</li><li>若主节点没有开启持久化，又开启了自动重启，重启后主节点数据库为空，而从节点对其进行全量复制，会导致从节点数据也被删除。</li><li>所以，若主节点没有开启持久化，应该禁止自动重启。</li></ul><h3 id="为什么主从全量复制使用RDB而不使用AOF"><a href="#为什么主从全量复制使用RDB而不使用AOF" class="headerlink" title="为什么主从全量复制使用RDB而不使用AOF"></a>为什么主从全量复制使用RDB而不使用AOF</h3><ul><li>RDB文件很小，适合传输</li><li>RDB加载很快，适合恢复</li><li>AOF使用不当，会严重影响Redis性能</li></ul><h3 id="无磁盘复制模式"><a href="#无磁盘复制模式" class="headerlink" title="无磁盘复制模式"></a>无磁盘复制模式</h3><p>主服务器磁盘速度较低时，RDB会带来一些负担，<strong>无磁盘复制模式</strong>是指：master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。<br>使用<code>repl-diskless-sync</code>配置参数来启动无磁盘复制。</p><h3 id="从库的从库"><a href="#从库的从库" class="headerlink" title="从库的从库"></a>从库的从库</h3><p>对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。<br>通过“主 - 从 - 从”模式可以<strong>将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104045116.jpg"><br>后续的写同步也可以级联传播。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h4 id="延迟与不一致问题"><a href="#延迟与不一致问题" class="headerlink" title="延迟与不一致问题"></a>延迟与不一致问题</h4><p><strong>优化</strong>：优化网络环境、舍弃大延迟从节点，使用集群扩展读负载能力。</p><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><p>单机redis的删除策略</p><ul><li><strong>惰性删除</strong>：客户端查询数据时才判断是否过期，过期则删除</li><li><strong>定期删除</strong>：服务器定时任务删除过期数据</li></ul><p>主从复制时，从节点不主动删除，而是由主节点控制从节点删除（保证数据一致性），但由于主节点不会立即删除过期数据，客户端在从节点上容易读到过期数据。<br><strong>解决</strong>：Redis3.2中，从节点也会判断数据过期。</p><h4 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h4><p>主&#x2F;从节点发生故障时，要及时切换客户端的Redis连接。</p><ul><li>手动：响应慢，容易出错</li><li>监控程序：实现复杂</li></ul><div class="note note-primary">            <p>使用哨兵即可解决这个问题。</p>          </div><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p><h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><blockquote><p>哨兵Redis Sentinel的核心功能是协助完成自动故障转移。</p></blockquote><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>监控：监听主从节点运作</li><li>自动故障转移：更改主节点</li><li>配置提供：向客户端提供节点信息</li><li>通知：通知客户端故障转移的结果</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="集群组建"><a href="#集群组建" class="headerlink" title="集群组建"></a>集群组建</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223227.jpg"></p><ul><li>主节点上有一个<code>_sentinel_:hello</code>频道，哨兵们通过该频道实现互相发现。</li><li>互相发现后哨兵之间建立连接。</li></ul><h3 id="监控Redis库"><a href="#监控Redis库" class="headerlink" title="监控Redis库"></a>监控Redis库</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223410.jpg"></p><ul><li>哨兵向主节点发送<code>INFO</code>命令，根据接受到的Slave列表与各从库建立连接</li></ul><h3 id="主库下线判断"><a href="#主库下线判断" class="headerlink" title="主库下线判断"></a>主库下线判断</h3><p>下线概念：</p><ul><li><strong>主观下线</strong>：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</li><li><strong>客观下线</strong>：有哨兵集群共同决定Redis节点是否下线；<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104223530.jpg"></li><li>哨兵判断主库下线后，向其他哨兵发送<code>is-master-down-by-addr</code>命令，其他哨兵作出Y或N响应。</li><li>如果赞成票大于配置项<code>quorum</code>，判定主库客观下线。</li></ul><h3 id="哨兵集群的选举"><a href="#哨兵集群的选举" class="headerlink" title="哨兵集群的选举"></a>哨兵集群的选举</h3><p>客观下线后，需要选举一个主哨兵执行最终调整命令</p><ul><li>选举算法：<ul><li>Raft选举算法： 选举的票数大于等于num(sentinels)&#x2F;2+1时，将成为领导者，如果没有超过，继续选举。</li></ul></li><li>成为Leader的前提：<ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <code>quorum</code> 值。</li></ul></li></ul><div class="note note-primary">            <p>这里注意，判断客观下线需要得到大于<code>quorum</code>的赞成票，选举leader需要半数以上<strong>且</strong>大于<code>quorum</code>值的赞成票。<br>即，若有哨兵掉线导致无法超过半数，也无法实现Leader选举</p>          </div><h3 id="新主库选择"><a href="#新主库选择" class="headerlink" title="新主库选择"></a>新主库选择</h3><ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择<code>salve-priority</code>从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul><div class="note note-primary">            <p>先选活的，再选关系户，最后选有实力的，都没法就选runID小的。</p>          </div><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104224208.png"></p><ul><li>让新主库脱离原主库（replicaof no one）</li><li>让其他从库成为新主库的从节点</li><li>通知应用程序新redis主节点</li><li>原主库上线后变成新主节点的从节点</li></ul><h1 id="分片技术"><a href="#分片技术" class="headerlink" title="分片技术"></a>分片技术</h1><blockquote><p>主从复制解决了主节点崩溃的备份问题，并通过读写分离提高了性能。<br>哨兵机制解决了主节点崩溃时的崩溃转移问题。<br>但这都没有扩展Redis的写能力和存储能力，因此Redis引入了集群的功能。</p></blockquote><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="哈希槽-Hash-Slot"><a href="#哈希槽-Hash-Slot" class="headerlink" title="哈希槽(Hash Slot)"></a>哈希槽(Hash Slot)</h3><p>Redis-cluster没有使用一致性hash，而是引入了<strong>哈希槽</strong>的概念。Redis-cluster中有<strong>16384(即2的14次方)个哈希槽</strong>，每个key通过CRC16校验后对16383取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。</p><h3 id="Keys-hash-tags"><a href="#Keys-hash-tags" class="headerlink" title="Keys hash tags"></a>Keys hash tags</h3><p>Hash tags提供了一种途径，<strong>用来将多个(相关的)key分配到相同的hash slot中</strong>。这时Redis Cluster中实现multi-key操作的基础。<br>hash tag规则如下，如果满足如下规则，<code>&#123;</code>和<code>&#125;</code>之间的字符将用来计算HASH_SLOT，以保证这样的key保存在同一个slot中。</p><p>例如：hash(“{user1}.name”) &#x3D;&#x3D; hash(“{user1}.age”)</p><h3 id="Cluster-nodes属性"><a href="#Cluster-nodes属性" class="headerlink" title="Cluster nodes属性"></a>Cluster nodes属性</h3><p>每个<strong>节点在cluster中有一个唯一的名字</strong>。<br>这个名字由160bit随机十六进制数字表示，并在节点启动时第一次获得(通常通过&#x2F;dev&#x2F;urandom)。节点在配置文件中保留它的ID，并永远地使用这个ID，直到被管理员使用CLUSTER RESET HARD命令hard reset这个节点。<br>这样节点可以实现IP的变化而不影响其在集群中的定位。</p><p>每个节点维护集群内其他节点的以下信息：</p><ul><li><code>node id</code>，<code>节点的IP和port</code>，<code>节点标签</code>，<code>master node id</code>（如果这是一个slave节点）</li><li><code>最后被挂起的ping的发送时间</code>(如果没有挂起的ping则为0)，<code>最后一次收到pong的时间</code></li><li><code>当前的节点configuration epoch</code>（配置版本号） ，<code>链接状态</code>，以及该节点服务的<code>hash slots</code>。</li></ul><div class="note note-primary">            <p>即维护基本身份（node id,ip port,从属）,存活信息（ping pong），服务信息（版本号、连接、slots）</p>          </div><h3 id="Cluster总线"><a href="#Cluster总线" class="headerlink" title="Cluster总线"></a>Cluster总线</h3><p>每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接。</p><p>这个端口与用来接收client命令的普通TCP端口有一个固定的offset。如该端口等于普通命令端口加上10000.例如，一个Redis街道口在端口6379坚挺客户端连接，那么它的集群总线端口16379也会被打开。</p><blockquote><p>节点到节点的通讯只使用集群总线，同时使用集群总线协议：有不同的类型和大小的帧组成的二进制协议。</p></blockquote><h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点总是接受集群总线端口的链接，并且总是会回复ping请求，即使ping来自一个不可信节点。然而，如果发送节点被认为不是当前集群的一部分，所有其他包将被抛弃。</p><p>节点认定其他节点是当前集群的一部分有两种方式（阶段）：</p><ul><li>节点接受到一条meet消息，其会将meet消息的发送节点视为集群内节点。</li><li>节点接受到其信任的节点的gossip信息，其会将gossip信息中提到的新节点标记为集群内节点。</li></ul><h3 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h3><p>Redis Cluster是一张全网拓扑，节点与其他每个节点之间都保持着TCP连接。<br>节点之间使用gossip协议更新避免过多的消息交换。</p><div class="note note-danger">            <p>上面主要是cluster的主要模块，涉及到以下几个方面：</p><ul><li>分片：使用了<strong>哈希槽</strong>的方法对键进行分片，同时使用<strong>keys hash tags</strong>技术实现了定向的分片。</li><li>通讯：节点会开启<strong>cluster总线</strong>监听、返回消息，其会记录各个<strong>cluster nodes</strong>的基本信息。</li><li><strong>握手</strong>：节点监听到meet消息或信任节点的gossip消息会将目标节点加入到集群内。</li></ul>          </div><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><ul><li>检查当前key是否存在当前NODE？<ul><li>通过crc16（key）&#x2F;16384计算出slot</li><li>查询负责该slot负责的节点，得到节点指针</li><li>该指针与自身节点比较</li></ul></li><li>若slot不是由自身负责，则返回MOVED重定向</li><li>若slot由自身负责，且key在slot中，则返回该key对应结果<ul><li>若key不存在此slot中，检查该slot是否正在迁出（MIGRATING）？<ul><li>若slot正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若slot未迁出，检查Slot是否导入中？<ul><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则返回MOVED重定向</li></ul></li></ul></li></ul></li></ul><h4 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233215.png"></p><h4 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h4><p><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233422.png"></p><h4 id="SMART客户端"><a href="#SMART客户端" class="headerlink" title="SMART客户端"></a>SMART客户端</h4><p>上述两种重定向的机制使得客户端的实现更加复杂，提供了smart客户端（JedisCluster）来<strong>减低复杂性，追求更好的性能</strong>。<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104233615.png"></p><p>客户端通过cluster slots命令获取集群信息，依据其自主计算目标key所在的节点，直接对目标节点进行访问。</p><blockquote><p>失败时，进行随机访问节点、更新自身映射表并重新访问，若失败过多则放弃。</p></blockquote><div class="note note-warning">            <p>简而言之，客户端请求后，节点判断是否由自己处理，不由自己处理则MOVED，由自己处理但发现slot已经迁移则ASK。<br>SMART客户端则自身计算slots的工作，映射失效时则随机访问节点刷新映射。</p>          </div><h3 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h3><p>Cluster中的每个节点都维护一份在自己看来当前整个集群的状态，主要包括：</p><ul><li>当前集群状态</li><li>集群中各节点所负责的slots信息，及其migrate状态</li><li>集群中各节点的master-slave状态</li><li>集群中各节点的存活状态及不可达投票</li></ul><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>gossip 协议（gossip protocol）又称 epidemic 协议（epidemic protocol）是一种P2P2协议，Gossip协议的最大的好处是，<strong>即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。这就允许Consul管理的集群规模能横向扩展到数千个节点</strong>。</p><p>Redis 集群是去中心化的，彼此之间状态同步靠 gossip 协议通信，集群的消息有以下几种类型：</p><ul><li><code>Meet</code> 通过「cluster meet ip port」命令，已有集群的节点会向新的节点发送邀请，加入现有集群。</li><li><code>Ping</code> 节点每秒会向集群中其他节点发送 ping 消息，消息中带有自己已知的两个节点的地址、槽、状态信息、最后一次通信时间等。</li><li><code>Pong</code> 节点收到 ping 消息后会回复 pong 消息，消息中同样带有自己已知的两个节点信息。</li><li><code>Fail</code> 节点 ping 不通某节点后，会向集群所有节点广播该节点挂掉的消息。其他节点收到消息后标记已下线。</li></ul><div class="note note-primary">            <p>meet用于新增节点，ping&#x2F;pong维护，fail用于下线节点</p>          </div><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>在某节点看来，其他节点的状态有<strong>在线状态</strong>、<strong>疑似下线状态PFAIL</strong>、<strong>已下线状态FAIL</strong>。</p><ul><li>节点A发现某节点B下线时，将其标记为PFAIL，并通知附近节点C。</li><li>节点C接受到消息后，确认真假，将该状态记录并继续传播PFAIL消息。</li><li>最后节点判断其是否客观下线（<strong>自己认为</strong> 且 <strong>发现过半节点认为其疑似下线PFIAL</strong>），若客观下线，其会发送FAIL消息让所有节点接受节点A客观下线。</li></ul><h3 id="通讯维护"><a href="#通讯维护" class="headerlink" title="通讯维护"></a>通讯维护</h3><h4 id="什么时候进行心跳？"><a href="#什么时候进行心跳？" class="headerlink" title="什么时候进行心跳？"></a>什么时候进行心跳？</h4><p>Redis节点会记录其向每一个节点上一次发出ping和收到pong的时间，心跳发送时机与这两个值有关。通过下面的方式既能保证及时更新集群状态，又不至于使心跳数过多：</p><ul><li>每次Cron向所有未建立链接的节点发送ping或meet</li><li>每1秒从所有已知节点中随机选取5个，向其中上次收到pong最久远的一个发送ping</li><li>每次Cron向收到pong超过timeout&#x2F;2的节点发送ping</li><li>收到ping或meet，立即回复pong</li></ul><h4 id="发送哪些心跳数据？"><a href="#发送哪些心跳数据？" class="headerlink" title="发送哪些心跳数据？"></a>发送哪些心跳数据？</h4><ul><li>Header，发送者自己的信息<ul><li>所负责slots的信息</li><li>主从信息</li><li>ip port信息</li><li>状态信息</li></ul></li><li>Gossip，发送者所了解的部分其他节点的信息<ul><li>ping_sent, pong_received</li><li>ip, port信息</li><li>状态信息，比如发送者认为该节点已经不可达，会在状态信息中标记其为PFAIL或FAIL</li></ul></li></ul><h4 id="如何处理心跳？"><a href="#如何处理心跳？" class="headerlink" title="如何处理心跳？"></a>如何处理心跳？</h4><h5 id="新节点加入"><a href="#新节点加入" class="headerlink" title="新节点加入"></a>新节点加入</h5><ul><li>发送meet包加入集群</li><li>从pong包中的gossip得到未知的其他节点</li><li>循环上述过程，直到最终加入集群<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230104235107.png"></li></ul><h5 id="Slots消息"><a href="#Slots消息" class="headerlink" title="Slots消息"></a>Slots消息</h5><ul><li>判断发送者声明的slots信息，跟本地记录的是否有不同</li><li>如果不同，且发送者epoch较大，更新本地记录</li><li>如果不同，且发送者epoch小，发送Update信息通知发送者</li></ul><h5 id="Master-slave信息"><a href="#Master-slave信息" class="headerlink" title="Master slave信息"></a>Master slave信息</h5><p>发现发送者的master、slave信息变化，更新本地状态</p><h5 id="节点Fail探测-故障发现"><a href="#节点Fail探测-故障发现" class="headerlink" title="节点Fail探测(故障发现)"></a>节点Fail探测(故障发现)</h5><p>超时没有收到某节点pong包，标记其PFAIL，并在pong时传播这个标记。</p><blockquote><p>注：Gossip的存在使得集群状态的改变可以更快的达到整个集群。每个心跳包中会包含多个Gossip包，那么多少个才是合适的呢，redis的选择是N&#x2F;10，其中N是节点数，这样可以保证在PFAIL投票的过期时间内，节点可以收到80%机器关于失败节点的gossip，从而使其顺利进入FAIL状态。</p></blockquote><h3 id="故障恢复（Failover）"><a href="#故障恢复（Failover）" class="headerlink" title="故障恢复（Failover）"></a>故障恢复（Failover）</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>通过某个slave执行cluster failover命令，手动让某个master宕机，并将本slave作为master节点。<br>此时命令还包括一些流程处理，如校验offset，查看master状态和询问其他master意见等。</p><h4 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h4><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave。Failover的过程需要经过类Raft协议的过程在整个集群内达到一致，其过程如下：</p><ul><li>slave发现自己的master变为FAIL</li><li>将自己记录的集群currentEpoch加1，并广播Failover Request信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新Master</li><li>广播Pong通知其他集群节点<br><img src="/2023/01/04/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC5%E7%AB%A0%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89/Pasted-image-20230105001028.png"></li></ul><h3 id="扩容-amp-缩容"><a href="#扩容-amp-缩容" class="headerlink" title="扩容&amp;缩容"></a>扩容&amp;缩容</h3><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><ol><li>首先将新节点加入到集群中，可以通过在集群中任何一个客户端执行cluster meet 新节点ip:端口，或者通过redis-trib add node添加，新添加的节点默认在集群中都是主节点。</li><li>迁移数据 迁移数据的大致流程是，首先需要确定哪些槽需要被迁移到目标节点，然后获取槽中key，将槽中的key全部迁移到目标节点，然后向集群所有主节点广播槽（数据）全部迁移到了目标节点。</li></ol><h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>缩容的大致过程与扩容一致，需要判断下线的节点是否是主节点，以及主节点上是否有槽，若主节点上有槽，需要将槽迁移到集群中其他主节点，槽迁移完成之后，需要向其他节点广播该节点准备下线（cluster forget nodeId）。最后需要将该下线主节点的从节点指向其他主节点，当然最好是先将从节点下线。</p><h2 id="更深入理解"><a href="#更深入理解" class="headerlink" title="更深入理解"></a>更深入理解</h2><h3 id="为什么Redis-Cluster的Hash-Slot是16384？"><a href="#为什么Redis-Cluster的Hash-Slot是16384？" class="headerlink" title="为什么Redis Cluster的Hash Slot是16384？"></a>为什么Redis Cluster的Hash Slot是16384？</h3><p>我们知道一致性hash算法是2的16次方（65535），为什么hash slot是2的14次方（16384）呢？</p><p>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，使用bitmap压缩，16384bit &#x3D; 16kb &#x3D; 2kB，也就是说使用2kB的空间创建了16k的槽数。如果使用CRC16分配65535个槽位，需要使用8kB才行，作者认为没有必要。</p><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢？"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢？" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢？"></a>为什么Redis Cluster中不建议使用发布订阅呢？</h3><p>在集群模式下，所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会<strong>严重消耗带宽</strong>，不建议使用。（虽然官网上讲有时候可以使用Bloom过滤器或其他算法进行优化的。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第4章（事件与事物）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><blockquote><p>所谓事件机制，指的是Redis 接受客户端的请求并响应（文件事件） 和 执行定时任务（时间事件） 的机制。</p></blockquote><p>该事件库处理下面两类事件：</p><ul><li><strong>文件事件</strong>(file event)：用于处理 Redis 服务器和客户端之间的网络IO。</li><li><strong>时间事件</strong>(time eveat)：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的。</li></ul><div class="note note-primary">            <p>文件事件指交互性事件，时间事件指定时类执行事件。</p>          </div><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104015729.png"></p><p><code>aeEventLoop</code>是整个事件驱动的核心，它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件处理器使用<strong>IO多路复用技术</strong>，同时监听多个套接字，并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发时，就会调用相应的事件处理函数。</p><p>Redis 是单线程主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的</strong>。采用了多路复用机制使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个IO多路复用函数库在 Redis 源码中都对应一个单独的文件，比如<code>ae_select.c</code>，<code>ae_epoll.c</code>， <code>ae_kqueue.c</code>等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。</p><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020000.png"></p><div class="note note-primary">            <p>这里还没学，暂时理解为netty、ae_event(Redis使用的)等是异步处理IO复用的应用框架，底层的实现库是与操作系统的具体实现有关。</p>          </div><h3 id="文件事件处理器"><a href="#文件事件处理器" class="headerlink" title="文件事件处理器"></a>文件事件处理器</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020123.png"><br>I&#x2F;O多路复用程序监听多个套接字（客户端），当需要套接字IO时，产生一个文件事件，Redis将这些就绪的文件事件放在一个队列中（fired就绪事件表），然后文件事件处理器会有序、同步、单个的执行一个个文件事件。</p><p>某客户端请求流程如下：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020550.png"></p><h3 id="Redis-IO多路复用模型"><a href="#Redis-IO多路复用模型" class="headerlink" title="Redis IO多路复用模型"></a>Redis IO多路复用模型</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104020629.jpg"></p><div class="note note-primary">            <p>这里理解为epoll是一个操作系统内核机制，其监听了3个FD（套接字），当发生事件时，事件入列，然后逐个出列调用函数。</p>          </div><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>Redis 的时间事件分为以下两类：</p><ul><li><strong>定时事件</strong>：让一段程序在指定的时间之后执行一次。</li><li><strong>周期性事件</strong>：让一段程序每隔指定时间就执行一次。</li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：也就是说时间处理器处理某个事件后，判断其需不需要过一段时间再次执行。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104022102.png"><br>所有事件时间放在一个无序链表中，时间事件执行器运行时，遍历整个链表，查找已经到达的时间事件并调用相应事件处理器。</p><blockquote><p>一般Redis服务器只使用serverCron一个时间事件，这个事件用于更新服务器各类统计数据，清理键值，整理客户端连接，尝试AOF或RDB，同步数据，心跳检测等。总之，Redis会周期性的执行这个函数。</p></blockquote><h2 id="aeEventLoop实现"><a href="#aeEventLoop实现" class="headerlink" title="aeEventLoop实现"></a>aeEventLoop实现</h2><p>Redis 服务端在其初始化函数 initServer中，会创建事件管理器aeEventLoop对象。具体过程是其会调用aeCreateEventLoop函数：</p><ul><li>创建该aeEventLoop对象。</li><li>初始化文件事件表内容</li><li>初始化时间事件表</li><li>调用aeApiCreate函数创建epoll实例，初始化apidata<br>具体实现不细看了，逻辑图如下<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104024156.png"></li></ul><h1 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h1><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li><code>MULTI</code> ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li><code>EXEC</code>：执行事务中的所有操作命令。</li><li><code>DISCARD</code>：取消事务，放弃执行事务块中的所有命令。</li><li><code>WATCH</code>：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li><code>UNWATCH</code>：取消WATCH对所有key的监视。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ul><li>语法错误：若存在语法错误，整个事务不会被执行。</li><li>类型错误：若在执行时发送Redis类型错误，该条命令失败，但其他命令正常执行。</li></ul><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><p>WATCH命令为Redis事务提供了CAS的行为：<br>当执行了WATCH命令监视某键后，在执行时发现与WATCH时相比，键值发生了变化，则回滚事务。最后会取消监控。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025042.png"></p><h3 id="事物执行步骤"><a href="#事物执行步骤" class="headerlink" title="事物执行步骤"></a>事物执行步骤</h3><ul><li>MULTI开始</li><li>入队</li><li>执行<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230104025058.png"></li></ul><h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>redis悲观锁又称为分布式锁，主要是为了防止数据被其他客户改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">setnx lock-key value<br></code></pre></td></tr></table></figure><p>通过以上命令可以设置分布式锁(key&#x3D;lock-key)：</p><ul><li>若设置成功，会返回值，拥有控制权。</li><li>若设置失败，无返回值，需要排队等待。<br>期间其他客户无法操作lock-key。<br>操作完毕后通过<strong>del操作释放锁</strong>。</li></ul><h3 id="分布式锁改良"><a href="#分布式锁改良" class="headerlink" title="分布式锁改良"></a>分布式锁改良</h3><p>使用expire为lock-key设置过期时间，防止忘记或程序中断导致忘记释放锁</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><h3 id="Redis不支持回滚？"><a href="#Redis不支持回滚？" class="headerlink" title="Redis不支持回滚？"></a>Redis不支持回滚？</h3><p>redis只会因命令编写错误（主要指类型错误这种无法提前检测的命令）而失败，这个错误是在编程时应该避免的。</p><h3 id="ACID？"><a href="#ACID？" class="headerlink" title="ACID？"></a>ACID？</h3><ul><li>原子性<em>atomicity</em><br>有观点认为Redis没有原子性，因为其不支持运行期回滚，但Redis官方的理解如下：<br><strong>Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。</strong>这个过程并不保证执行成功。</li><li>一致性<em>consistency</em><br>Redis能保证命令失败的情况下不执行（普通语法错误、WATCH锁），能保证一致性。**<code>WATCH</code>监视并不是在事务中某一条使用了被监视键的命令执行前检查，而是在整个事务开始前就检查所有被监视的键是否被修改**。</li><li>隔离性<em>Isolation</em><br><strong>单线程</strong>的本质保证了隔离性（不会被其他客户端打断）</li><li>持久性<em>Durability</em><br><strong>redis事务是不保证持久性的</strong>，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑。</li></ul><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><ul><li><strong>基于Lua脚本</strong>，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li><strong>基于中间标记变量</strong>，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h1 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h1><blockquote><p>删除作为一个redis事件，也放在本章一起阐述。</p></blockquote><p>使用<code>TTL</code>可以查看键的生命状态：</p><ul><li>xx为时效数据</li><li>1为永久有效数据</li><li>2为已经过期或不存在的数据</li></ul><h2 id="常见的删除策略"><a href="#常见的删除策略" class="headerlink" title="常见的删除策略"></a>常见的删除策略</h2><ol><li>定时删除：定时任务，到时即删除</li><li>定期删除：定期清理，serverCron()中会执行删除。</li><li>惰性删除：访问时删除，调用expireIfNeeded函数</li></ol><div class="note note-success">            <p>redis使用的是<strong>惰性删除</strong>和<strong>定期删除</strong></p>          </div><div class="note note-primary">            <p>对于RDB，其不会记录已经删除的键<br>对于AOF，键过期后会在文件后面加上DEL key的命令。</p>          </div><h3 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105004950.png"></p><p>这个格式不是redisObject的格式，而是redis数据库的一个格式。<br>redisDB结构中expires保存了所有的键过期信息。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC4%E7%AB%A0%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%EF%BC%89/Pasted-image-20230105010244.png"></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第3章（持久化）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="持久化：RDB和AOF机制详解"><a href="#持久化：RDB和AOF机制详解" class="headerlink" title="持久化：RDB和AOF机制详解"></a>持久化：RDB和AOF机制详解</h2><h3 id="RDB-Redis-DataBase-持久化"><a href="#RDB-Redis-DataBase-持久化" class="headerlink" title="RDB(Redis DataBase)持久化"></a>RDB(<em>Redis DataBase</em>)持久化</h3><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><blockquote><p><strong>手动触发</strong> 和 <strong>自动触发</strong></p></blockquote><h5 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h5><ul><li><code>save</code>命令：由主线程执行，会造成长时间阻塞。</li><li><code>bgsave</code>命令：fork子线程执行，阻塞只发生在fork阶段。</li></ul><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103211303.png"></p><p>具体流程如下：</p><ul><li>redis客户端执行bgsave命令或者自动触发bgsave命令；</li><li>主进程判断当前是否已经存在正在执行的子进程，如果存在，<strong>那么主进程直接返回</strong>；</li><li>如果不存在正在执行的子进程，那么就fork一个新的子进程进行持久化数据，fork过程是阻塞的，fork操作完成后主进程即可执行其他操作；</li><li>子进程先将数据写入到临时的rdb文件中，待快照数据写入完成后再原子<strong>替换</strong>旧的rdb文件；</li><li>同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_相关选项）。</li></ul><h5 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h5><p>由以下4种触发情况</p><ul><li>定时触发：<code>save m n</code>，m秒有n条发生变化</li><li>主从复制</li><li>执行debug reload重新加载redis，bgsave操作</li><li>shutdown命令</li></ul><p><strong>相关配置</strong><br><code>stop-writes-on-bgsave-error</code>：bgsave错误时暂停主线程，主要目的是让运维人员排查问题<br><code>rdbcompression</code>：启用LZF压缩算法<br><code>rdbchecksum</code>：64位CRC冗余校验编码，可以验证RDB的完整性。</p><h4 id="深入RDB"><a href="#深入RDB" class="headerlink" title="深入RDB"></a>深入RDB</h4><ul><li><p><strong>并发问题？</strong><br><a href="https://zhuanlan.zhihu.com/p/339437815#:~:text=%20Redis%E4%B8%AD%E6%89%A7%E8%A1%8CBGSAVE%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90RDB%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%9C%AC%E8%B4%A8%E5%B0%B1%E6%98%AF%E8%B0%83%E7%94%A8Linux%E4%B8%AD%E7%9A%84fork%20%28%29%E5%91%BD%E4%BB%A4%EF%BC%8CLinux%E4%B8%8B%E7%9A%84fork,%28%29%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E4%BA%86copy-on-write%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9B%20fork%20%28%29%E4%B9%8B%E5%90%8E%EF%BC%8Ckernel%E6%8A%8A%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E6%9D%83%E9%99%90%E9%83%BD%E8%AE%BE%E4%B8%BAread-only%EF%BC%8C%E7%84%B6%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%8C%87%E5%90%91%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%82%20%E5%BD%93%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%83%BD%E5%8F%AA%E8%AF%BB%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E7%9B%B8%E5%AE%89%E6%97%A0%E4%BA%8B%E3%80%82">Copy-on-Write</a><br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103215527.jpg"><br>如果主线程需要进行写操作，则将写操作部分的数据块复制，对新的副本进行修改，这样保证了bgsave子进程可见的数据的一致性（即bgsave开始时的快照）</p></li><li><p><strong>若服务崩溃怎么办？</strong><br>bgsave的temp文件在生成之前不会覆盖旧的dump。</p></li><li><p><strong>能否尽可能快的RDB</strong>?<br>快照过快会导致fork大量阻塞主线程，且磁盘空间是有限的。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点<ul><li><strong>LZF压缩算法，文件体积远小于内存</strong></li><li>加载速度比AOF快</li></ul></li><li>缺点<ul><li><strong>实时性不够</strong></li><li><strong>开销大</strong></li><li>版本兼容</li><li>RDB文件无法手动修改</li></ul></li></ul><h3 id="AOF-append-only-file-持久化"><a href="#AOF-append-only-file-持久化" class="headerlink" title="AOF(append only file)持久化"></a>AOF(<em>append only file</em>)持久化</h3><p>执行写命令时，<strong>先写内存，后写日志</strong>。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220350.jpg"></p><blockquote><p>目的：</p><ol><li>避免额外检查，执行成功才写日志</li><li>不阻塞当前写操作</li></ol><p>风险：</p><ol><li>完成写内存后中断，日志缺失</li><li>主线程写磁盘压力过大</li></ol></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li><strong>命令追加</strong> 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li><li><strong>文件写入和同步</strong> 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103220620.jpg"></li><li><strong>AOF重写</strong> Redis通过创建一个新的AOF文件来替换现有的AOF。</li></ul><div class="note note-primary">            <p>aof_buf缓存写命令，触发写回时将aof_buf中命令一次写入磁盘</p>          </div><p><strong>相关配置</strong><br><code>appendfsync</code>：主要用于设置“真正执行”操作命令向AOF文件中同步的策略，支持always、everysec、no，默认为everysec。<br><code>no-appendfsync-on-rewrite</code>：<strong>重写</strong>时不再记录新命令<br><code>auto-aof-rewrite-percentage</code>：当前AOF文件超过上次重写AOF文件大小的百分之多少后开始重写。<br><code>auto-aof-rewrite-min-size</code>：当前AOF文件超过设置大小时开始重写</p><h4 id="深入AOF重写"><a href="#深入AOF重写" class="headerlink" title="深入AOF重写"></a>深入AOF重写</h4><ul><li><strong>AOF重写会阻塞吗</strong>？</li></ul><p>重写时会fork主线程，由后台进程bgrewriteaof完成，fork时会阻塞主线程。</p><ul><li><strong>何时重写</strong>？</li></ul><p>auto-aof-rewrite-percentage和auto-aof-rewrite-min-size</p><ul><li><strong>并发问题</strong>？</li></ul><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103221653.jpg"></p><p>重写时:<br>    - redis原始数据会通过copy on write机制拷贝<br>    - 服务器写入新数据时，会将新数据同时写入两个aof_buf缓存区（当持久化策略为always时，则是写入磁盘和一个aof_buf缓冲），<strong>子线程</strong>完成重写后通知主线程，<strong>主线程</strong>会把aof重写缓冲区的命令追加到aof文件中。最后文件改名，保证原子性。</p><blockquote><p>fork采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork子进程时，子进程时会<strong>拷贝父进程的页表</strong>，即<strong>虚实映射关系</strong>（虚拟内存和物理内存的映射索引表），而<strong>不会拷贝物理内存</strong>。这个拷贝会消耗大量cpu资源，并且<strong>拷贝完成前会阻塞主线程</strong>，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。</p></blockquote><ul><li><p><strong>重写时有哪些阻塞</strong>？</p><ul><li>fork</li><li>主线程bigkey写入，操作系统需要创建页面副本并拷贝原有数据。</li><li>主线程追加写入aof</li></ul></li><li><p><strong>为什么AOF不复用原AOF文件</strong>？</p><ul><li>父子同时写一个文件产生竞争，影响父进程性能</li><li>若重写失败会造成污染</li></ul></li></ul><h3 id="RDB和AOF混合方式"><a href="#RDB和AOF混合方式" class="headerlink" title="RDB和AOF混合方式"></a>RDB和AOF混合方式</h3><p>在Redis4.0提出，简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志<strong>记录这期间</strong>的所有命令操作。<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222843.jpg"></p><ul><li>RDB不用过快执行，同时AOF也不会过大</li></ul><h3 id="持久化恢复"><a href="#持久化恢复" class="headerlink" title="持久化恢复"></a>持久化恢复</h3><p>重启redis即可恢复<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%89/Pasted-image-20230103222858.png"><br>AOF优先级更高，因为其数据更完整。</p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第2章（对象机制）</title>
    <link href="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <url>/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><blockquote><p>前面介绍了Redis的基本数据类型，针对这些数据类型有着不同的底层实现。</p></blockquote><p>对象模型：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190013.png"></p><blockquote><p>Redis对象有不同的数据类型，而一个数据类型可能有多种实现方式（编码类型），根据value的情况灵活变化。<br>编码类型作为一种类型标识，告诉了Redis应该如何解析这个对象，不同编码类型也有不同的底层数据结构实现。</p></blockquote><p>Redis对象机制作用：<br><strong>Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式</strong>.<br><strong>操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理</strong>.</p><h1 id="redisObject数据结构"><a href="#redisObject数据结构" class="headerlink" title="redisObject数据结构"></a>redisObject数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-comment">// 类型</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// LRU_BITS: 24</span><br>    <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-comment">// 指向底层数据结构实例</span><br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103190705.png"></p><ul><li>type标识了数据所属的基本类型</li><li>encoding标识了数据类型对于的编码</li><li>LRU记录了数据的最后访问时间（LFU还记录访问次数）</li><li>refcount记录了对象被引计数</li><li>ptr指向真实的底层数据结构</li></ul><div class="note note-primary">            <p>redisObject保存了Redis服务器需要维护的对象信息，包括数据结构类型和编码（用于多态解析），LRU（LFU）和refcount（淘汰机制），ptr指向底层数据结构。</p>          </div><h2 id="命令检查与多态"><a href="#命令检查与多态" class="headerlink" title="命令检查与多态"></a>命令检查与多态</h2><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103191229.png"></p><div class="note note-success">            <p>type判断命令是否正确，encoding判断如何执行命令</p>          </div><h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>redis一般会把一些常见值放入共享对象中：</p><ul><li>各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等</li><li>包括0在内，小于REDIS_SHARED_INTEGERS的所有整数（REDIS_SHARED_INTEGERS的默认值是10000）<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192218.png"></li></ul><blockquote><p>注意：共享对象只能被字典和双向链表这类能带有指针的数据结构使用。<br>像整数集合和压缩列表这些将数据保存在数据结构内的则无法使用。</p></blockquote><blockquote><p>为什么不共享其他数据结构：<br>复杂度较高，消耗CPU，用其换取内存不划算。</p></blockquote><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><blockquote><p>redisObject中有refcount属性，是对象的引用计数，显然计数0那么就是可以回收。</p></blockquote><ul><li>当对象的refcount降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。</li></ul><h1 id="底层数据对象"><a href="#底层数据对象" class="headerlink" title="底层数据对象"></a>底层数据对象</h1><h2 id="简单动态字符串-sds"><a href="#简单动态字符串-sds" class="headerlink" title="简单动态字符串 - sds"></a>简单动态字符串 - sds</h2><p><strong>简单动态字符串（simple dynamic string,SDS</strong>）的存在是为了尽可能的节省存储可见，只为对象分配其需要的空间大小。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192512.png"></p><p>SDS有五种不同的头部. 其中sdshdr5实际并未使用到. 所以实际上有四种不同的<strong>头部</strong>, 分别如下:<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103192821.png"><br>其中：</p><ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8, uint16, uint32, uint64表示整个SDS, 除过头部与末尾的<code>\0</code>, 剩余的字节数。</li><li><code>flags</code> 始终为一字节, 以低三位标示着头部的类型, 高5位未使用</li></ul><div class="note note-primary">            <p>实际SDS的长度为 头部+alloc+尾部。<br>len为<code>buf[]</code>中的有效长度，即有效字符串长度。</p>          </div><h3 id="为何使用SDS"><a href="#为何使用SDS" class="headerlink" title="为何使用SDS"></a>为何使用SDS</h3><ul><li><strong>常数复杂度获取字符串长度</strong>：只需要读取len属性即可了解SDS字符串长度，时间复杂度为O(1)。</li><li><strong>杜绝缓冲区溢出</strong>：修改字符串时，首先看len是否满足需求，不满足则进行可见扩展</li><li><strong>减少修改字符串的内存重新分配次数</strong>：对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：<ul><li><code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><code>惰性空间释放</code>：缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。</li></ul></li><li><strong>二进制安全</strong>：SDS不以空字符串判断结束，而是以len属性判断。</li></ul><blockquote><p>在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p></blockquote><h2 id="压缩列表-ZipList"><a href="#压缩列表-ZipList" class="headerlink" title="压缩列表 - ZipList"></a>压缩列表 - ZipList</h2><p>ziplist是一个特殊编码的双向列表，其可以存储字符串或整数，操作的时间复杂度为O(1)，每次操作都需要重新分配ziplist的内存。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103194043.png"></p><ul><li><code>zlbytes</code>字段的类型是uint32_t, 这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t, 它指的是ziplist中最后一个entry的偏移量. 用于快速定位最后一个entry, 以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t, 它指的是整个ziplit中entry的数量. 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方), 那么该字段中存储的就是实际entry的值. 若等于或超过65535, 那么该字段的值固定为65535, 但实际数量需要一个个entry的去遍历所有entry才能得到.</li><li><code>zlend</code>是一个终止字节, 其值为全F, 即0xff. ziplist保证任何情况下, 一个entry的首字节都不会是255</li></ul><h3 id="Entry结构"><a href="#Entry结构" class="headerlink" title="Entry结构"></a>Entry结构</h3><p>一般</p><ul><li><code>prevlen</code>：前一个entry的大小</li><li><code>encoding</code>：表示当前entry类型和长度</li><li><code>entry-data</code>:存储entry标识的数据<br>特殊<br>类型为int时，<code>encoding</code>和<code>entry-data</code>合并在一起表示，没有<code>entry-data</code>。</li></ul><p><strong>prevlen</strong><br>前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度。<br>如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p><p><strong>encoding编码</strong><br>encoding的长度和值根据保存的是int还是string，还有数据的长度而定；<br>前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</p><h3 id="为什么ZipList省内存"><a href="#为什么ZipList省内存" class="headerlink" title="为什么ZipList省内存"></a>为什么ZipList省内存</h3><p>根据数据类型灵活变化编码规则，使用encoding标识entry类型和大小，是。<br>因为是双端列表，为了解决遍历问题，使用prevlen字段方便倒序遍历。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不预留空间，每次写操作都需要重新分配内存。<br>节点扩容可能导致后续所有prevlen字段扩容。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>是一个以ziplist为节点的双端链表结构。</p><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><ul><li><code>quicklistNode</code>, 宏观上, quicklist是一个链表, 这个结构描述的就是链表中的结点. 它通过zl字段持有底层的ziplist. 简单来讲, 它描述了一个ziplist实例。</li><li><code>quicklistLZF</code>, ziplist是一段连续的内存, 用LZ4算法压缩后, 就可以包装成一个quicklistLZF结构. 是否压缩quicklist中的每个ziplist实例是一个可配置项. 若这个配置项是开启的, 那么quicklistNode.zl字段指向的就不是一个ziplist实例, 而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>, 在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>. 这就是一个双链表的定义. head, tail分别指向头尾指针. len代表链表中的结点. count指的是整个quicklist中的所有ziplist中的entry的数目. fill字段影响着每个链表结点中ziplist的最大占用空间, compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间.</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装. quicklist作为一个封装良好的数据结构, 不希望使用者感知到其内部的实现, 所以需要把ziplist.entry的概念重新包装一下</li></ul><h3 id="主体结构"><a href="#主体结构" class="headerlink" title="主体结构"></a>主体结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103200220.png"></p><ul><li><p><code>quicklist.fill</code>影响ziplist的长度，数值为负数时限制ziplist最大长度，为正数时限制ziplist的entry数量。</p></li><li><p><code>quicklist.compress</code>影响zl字段指向的对象的类型，0标识指向ziplist，1表示链表的头尾节点不压缩，2标识头尾各2各节点不压缩，其他为压缩后的quicklistLZF。</p></li><li><p><code>quicklistNode.encoding</code>，标识本链表节点是否压缩，1表示没压缩，2表示压缩了。</p></li><li><p><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么. 默认的实现是ziplist, 对应的该字段的值是2, 目前Redis没有提供其它实现. 所以实际上, 该字段的值恒为2</p></li><li><p><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压。如果该字段为1即代表之前被解压过, 且需要在下一次操作时重新压缩.</p></li></ul><h2 id="字典-x2F-哈希表-Dict"><a href="#字典-x2F-哈希表-Dict" class="headerlink" title="字典&#x2F;哈希表 - Dict"></a>字典&#x2F;哈希表 - Dict</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103201159.png"></p><h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul><li>哈希算法：使用hash函数计算key的哈希值，使用sizemask与第一步得到的hash值，计算索引。</li><li>哈希冲突：链地址法</li><li>扩容&#x2F;缩容：<ul><li>rehash，扩展时创建两倍大小的hash表，缩小时则创建缩小一倍的新哈希表。</li><li>重新计算索引</li><li>迁移所有键值对，然后释放内存</li></ul></li><li>扩容条件：<ol><li>服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。</li><li>ps：负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小。</li></ol></li><li>渐进式rehash<br>  分多次完成rehash迁移，此时查找会在新旧两个哈希表上找，但是新增只会在新哈希表上新增。</li></ul><h2 id="整数集-IntSet"><a href="#整数集-IntSet" class="headerlink" title="整数集 - IntSet"></a>整数集 - IntSet</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202006.png"></p><ul><li><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li><li><code>length</code> 代表其中存储的整数的个数</li><li><code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小<strong>从小到大有序排序</strong>，且数组中不包含任何重复项。</li></ul><div class="note note-primary">            <p>可见intset就是一个排序的数组。</p>          </div><p>contents中每个元素的数据类型由encoding决定，当有数字的值超出范围时，集合需要升级，其会：</p><ul><li>扩展整数集合底层数组的可见大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上。（需要继续维持底层数组的有序性质不变）。</li><li>最后改变encoding的值，length+1。</li></ul><p>但intset不会降级，这是没必要的开销。</p><h2 id="跳表-ZSkipList"><a href="#跳表-ZSkipList" class="headerlink" title="跳表 - ZSkipList"></a>跳表 - ZSkipList</h2><p>跳表在redis中只用在zset数据类型中，其保证查找删除添加等操作在对数的期望时间内完成。</p><p>原理示例：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202637.png"></p><p>内存布局：<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103202658.png"></p><p><strong>zskiplist的核心设计要点</strong></p><ul><li><strong>头节点</strong>不持有任何数据, 且其<code>level[]</code>的长度为32。</li><li><strong>每个结点</strong><ul><li><code>ele</code>字段，持有数据，是sds类型</li><li><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li><code>level</code>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段<ul><li><code>forward</code>字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在<code>level[]</code>中的索引为X, 则其forward字段指向的结点, 其<code>level[]</code>字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li><code>span</code>字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1</li></ul></li></ul></li></ul><h3 id="为什么不用平衡树或者哈希表"><a href="#为什么不用平衡树或者哈希表" class="headerlink" title="为什么不用平衡树或者哈希表"></a>为什么不用平衡树或者哈希表</h3><p>hash无序，无法进行范围查找，平衡数的范围搜索也很复杂，子树的调整也很复杂。</p><h1 id="redis对象与编码-底层结构-对应关系"><a href="#redis对象与编码-底层结构-对应关系" class="headerlink" title="redis对象与编码(底层结构)对应关系"></a>redis对象与编码(底层结构)对应关系</h1><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203244.png"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>字符串长度不能超过512M。</strong></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul><li><code>int 编码</code>：保存的是可以用 long 类型表示的整数值。</li><li><code>embstr 编码</code>：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li><li><code>raw 编码</code>：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</li></ul><h3 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203355.png"><br>embstr少一次分配空间，但其为只读,修改时要重新分配一次raw空间。</p><p>ps:<strong>Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型</strong>。</p><ul><li><strong>编码的转换</strong></li></ul><blockquote><p>当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。<br>对于embstr编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>按<strong>数值进行操作的数据</strong>，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>quicklist</p><h3 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103203823.png"></p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 hashtable</p><h3 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h3><ul><li>ziplist</li><li>dict<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204020.png"></li></ul><p>使用ziplist时，新的键值对作为entry插入list尾部。<br>使用hashtable编码时，使用dict。</p><p><strong>编码转换</strong><br>和上面列表对象使用 ziplist 编码一样，当<strong>同时满足下面两个条件</strong>时，使用ziplist（压缩列表）编码：</p><ol><li>列表保存元素个数小于512个</li><li>每个元素长度小于64字节<br>不能满足这两个条件的时候使用 hashtable 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>hash类型下的value只能存储字符串</li><li>每个hash可以存储2^32-1个键值对</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="编码-3"><a href="#编码-3" class="headerlink" title="编码"></a>编码</h3><p>intset或hashtable</p><h3 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h3><p><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103204842.png"></p><p><strong>编码转换</strong><br>当集合同时满足以下两个条件时，使用intset编码：</p><ol><li>集合对象中所有元素都是整数</li><li>集合对象所有元素数量不超过512<br>不能满足这两个条件的就使用hashtable编码。第二个条件可以通过配置文件的 <code>set-max-intset-entries</code> 进行配置。</li></ol><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><h3 id="编码-4"><a href="#编码-4" class="headerlink" title="编码"></a>编码</h3><p>ziplist 或 skiplist(ziplist+dict)</p><h3 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h3><p>ziplist<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205150.png"></p><p>skiplist(ziplist+dict)<br><img src="/2023/01/03/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC2%E7%AB%A0%EF%BC%88%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%89/Pasted-image-20230103205236.png"><br>字典可以快速查找成员，但无序，跳表可以快速执行范围查找，将两者结合共同实现有序集合。</p><p><strong>编码转换</strong><br>当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><ol><li>保存的元素数量小于128；</li><li>保存的所有元素长度都小于64字节。<br>不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件<code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 进行修改。</li></ol><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis第1章（数据类型与结构）</title>
    <link href="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <url>/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Redis知识体系"><a href="#一、Redis知识体系" class="headerlink" title="一、Redis知识体系"></a>一、Redis知识体系</h1><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230191017.png"></p><h1 id="二、Redis概念与基础"><a href="#二、Redis概念与基础" class="headerlink" title="二、Redis概念与基础"></a>二、Redis概念与基础</h1><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>读写性能优异：Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s。</li><li>数据类型丰富：Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>持久化：AOF&#x2F;RDB</li><li>发布订阅：Subscribe</li><li>分布式：RedisCluster</li><li>redis为每个服务提供有16个数据库，编号从0到15，默认为0号数据库</li></ul><h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul><li>热点数据的缓存</li><li>限时任务的运用</li><li>计数器</li><li>分布式锁</li><li>延时操作</li><li>排行榜</li><li>点赞</li></ul><h1 id="三、Redis基础数据类型"><a href="#三、Redis基础数据类型" class="headerlink" title="三、Redis基础数据类型"></a>三、Redis基础数据类型</h1><blockquote><p>Redis所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash</p></blockquote><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230200246.jpg"></p><div class="note note-primary">            <p><strong>String</strong>也可以是整数和浮点数，支持自增和自减操作。<br><strong>Zset</strong>说是set，实际上结构类似hash，其保存了<strong>字符串成员</strong>和<strong>浮点分数</strong>之间的映射关系。</p>          </div><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>GET,SET,INCR,DECR,INCRBY,DECRBY</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>缓存常用信息，计数器，session.</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis用双端链表实现List。</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>LPUSH,LPOP,<strong>LRANGE</strong>(获取范围内元素),LINDEX(获取索引元素)</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>时间轴微博，消息队列（按照时间先后排序的场景）</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序集合，成员唯一。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p>SADD,<strong>SCARD</strong>(获取成员数),SMEMERS(返回所有成员),SISMEMBER(判断是否为成员)</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><p>文章标签，不需要时间排序的点赞、收藏等。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>field -&gt; value，适合存储对象</p><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><p>HSET,HGET,HGETALL,HDEL</p><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><p>缓存查询信息，适合存储结构体。</p><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>成员唯一。通过了压缩列表和跳跃表两种数据结构实现。<br>压缩列表：提高了存储效率，特殊编码的双向链表。<br>跳跃表：快速查找，删除，添加（对数时间内）</p><div class="note note-primary">            <p>操作时按照跳跃表找到指定位置对数据进行修改，存储时以压缩列表形式存储。</p>          </div><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><p>ZADD,ZRANGE,ZREM</p><h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><p>排行榜</p><h1 id="四、Redis特殊类型结构"><a href="#四、Redis特殊类型结构" class="headerlink" title="四、Redis特殊类型结构"></a>四、Redis特殊类型结构</h1><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote><p>Redis 2.8.9 版本更新了 Hyperloglog 数据结构</p></blockquote><p>基数统计，可以理解为高性能的set，但精确度有限（0.81% 标准误差）。<br>基数指的是set中每一个不重复的元素，其可以解决海量数据统计的问题，其优势在于存储消耗的空间很小。</p><h3 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pfadd key1 a b c  #创建第一组元素<br>pfcount key1 #统计元素个数<br>pfmerge key3 key1 key2 #合并key1,key2到key3<br></code></pre></td></tr></table></figure><h3 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h3><p>每日访问IP数，在线用户数等</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>位存储，使用位记录 0，1两个状态。</p><h3 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">setbit key 0 1  #设置第0位为1<br>getbit key 0 #获取第0位<br>bitcount key #求1的数量<br></code></pre></td></tr></table></figure><h3 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h3><p>记录每条的打卡情况</p><h2 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h2><blockquote><p>Redis 的 Geo 在 Redis 3.2 版本就推出了!</p></blockquote><h3 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">geoadd china:city(相当于key) 118 32 beijing(相当于value对象)#即可以为一个区域添加多个点<br>geopos china:city beijing<br>geodist china:city beijing shenyang m #以M为单位求两地距离<br>georadius china:city 110 30 1000 km #求中国城市中，以110，30为中心，1000km为半径范围内所有城市。<br>geohash china:city beijing #较少使用,返回hash字符串<br></code></pre></td></tr></table></figure><h3 id="应用-7"><a href="#应用-7" class="headerlink" title="应用"></a>应用</h3><p>附近的人code</p><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>底层实现是Zset，其将经纬度转换为一个分数保存在其中。</p><h1 id="五、消息队列Steam"><a href="#五、消息队列Steam" class="headerlink" title="五、消息队列Steam"></a>五、消息队列Steam</h1><p>借鉴了Kafka，是一种消息队列的实现。</p><blockquote><p>Redis的消息队列实现很多：</p><ul><li>Pub&#x2F;Sub，缺点：丢失的消息无法持久化。</li><li>List，缺点：不支持多播，持久化。</li></ul></blockquote><p>消息队列设计<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230213704.png"></p><h2 id="Stream结构"><a href="#Stream结构" class="headerlink" title="Stream结构"></a>Stream结构</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230214054.png"></p><ul><li><code>Stream</code>：一种数据结构，每个Stream有一个唯一的名称，也就是key。</li><li><code>Comsumer Group</code>消费组：一个消费组有多个消费者，他们之间是<strong>竞争关系</strong></li><li><code>pending_ids</code>消费者状态变量：维护了消费者尚未确认的id。</li></ul><div class="note note-primary">            <p>对于每一条消息都要确保其被消费，或者确定这是一个投递不出去的坏消息（死信）。所以需要对<strong>每个消费者</strong>维护一个<strong>pending_ids</strong>，表示这个消息已经交给它处理，但它还没有完成对该消息的确认（ack）。</p><p>而对于<strong>每个消费组</strong>，则需要一个指针维护其最后一次读取到的消息id（<strong>Last_dilivered_id</strong>）。</p>          </div><p>另外，每个消息都有独一无二的ID，默认为时间戳，格式为1527846880572-5，当毫秒不够用时，使用<code>-</code>后面的数标注该消息是本毫秒的第几个消息。</p><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><ul><li>XADD - 添加消息到末尾</li><li>XTRIM - 对流进行修剪，限制长度</li><li>XDEL - 删除消息</li><li>XLEN - 获取流包含的元素数量，即消息长度</li><li>XRANGE - 获取消息列表，会自动过滤已经删除的消息</li><li>XREVRANGE - 反向获取消息列表，ID 从大到小</li><li>XREAD - 以阻塞或非阻塞方式获取消息列表</li></ul><h2 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h2><p>即不使用消费组的情况下进行消费。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">xread count 2 streams key 0-0 #读取两条消息<br>xread block 0 count 1 streams key $ #阻塞读取队列最后的消息<br></code></pre></td></tr></table></figure><p>block 0表示永远阻塞，直到消息到，block 1000表示阻塞1s，如果1s内没有任何消息到来，就返回nil。</p><blockquote><p>独立消费不会自动维护last_read指针，需要用户自己记住最后消息ID，下次将其作为参数传递即可继续消费。</p></blockquote><h2 id="消费组消费"><a href="#消费组消费" class="headerlink" title="消费组消费"></a>消费组消费</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/Pastedimage20221230231440.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>XGROUP CREATE - 创建消费者组</li><li>XREADGROUP GROUP - 读取消费者组中的消息</li><li>XACK - 将消息标记为”已处理”</li><li>XGROUP SETID - 为消费者组设置新的最后递送消息ID</li><li>XGROUP DELCONSUMER - 删除消费者</li><li>XGROUP DESTROY - 删除消费者组</li><li>XPENDING - 显示待处理消息的相关信息</li><li>XCLAIM - 转移消息的归属权</li><li>XINFO - 查看流和消费者组的相关信息；</li><li>XINFO GROUPS - 打印消费者组的信息；</li><li>XINFO STREAM - 打印流信息<br>具体使用见<a href="https://www.pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html">消费组命令使用</a></li></ul><p>xreadgroup也可以阻塞等待，读取后，消息进入消费者的pending_ids，当消费者回复xack时，将这个消息从其pending_ids消除。</p><div class="note note-primary">            <p>消费时，需要传入流名称、消费组名称、消费者名称3个参数。<br>ACK时，需要传入流名称、消费组名称、消息id。<br>可见回复时，不需要具体定位到消费者，因为redis本身就知道某个消息id属于消费组中的哪个消费者。</p>          </div><h2 id="信息监控"><a href="#信息监控" class="headerlink" title="信息监控"></a>信息监控</h2><p><code>Xinfo</code>命令可以查看stream的基本信息，如：</p><ul><li>XINFO STREAM keyName</li><li>XINFO GROUPS keyName</li><li>XINFO CONSUMERS keyName groupName</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>实时通讯、大数据分析、异地数据备份。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><p>XADD生成的1553439850328-0，就是Redis生成的消息ID，由两部分组成:<strong>时间戳-序号</strong>。时间戳是毫秒级单位，是生成消息的Redis服务器时间，它是个<strong>64位整型</strong>（int64）。序号是在这个毫秒时间点内的消息序号，它也是个64位整型。</p><p>Redis生成的ID是单调递增有序的。若服务器时间错误，Redis的每个Stream类型数据都维护一个latest_generated_id属性，用于记录最后一个消息的ID。<strong>若发现当前时间戳退后（小于latest_generated_id所记录的），则采用时间戳不变而序号递增的方案来作为新消息ID</strong>（这也是序号为什么使用int64的原因，保证有足够多的的序号）。</p><h3 id="消费者崩溃带来的会不会消息丢失问题"><a href="#消费者崩溃带来的会不会消息丢失问题" class="headerlink" title="消费者崩溃带来的会不会消息丢失问题?"></a>消费者崩溃带来的会不会消息丢失问题?</h3><p>Pending列表可以记录已读取但未ack的消息。<br>命令<code>XPENDIING</code>用来获消费组或消费内消费者的未处理完毕的消息。</p><p>每个Pending的消息有4个属性：</p><ul><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>delivery counter，消息被读取次数</li></ul><p>其保证消费者恢复时，可重新从pending列表中取消息处理。</p><h3 id="消费者彻底宕机后如何转移给其它消费者处理？"><a href="#消费者彻底宕机后如何转移给其它消费者处理？" class="headerlink" title="消费者彻底宕机后如何转移给其它消费者处理？"></a>消费者彻底宕机后如何转移给其它消费者处理？</h3><p>使用<code>XCLAIM</code>将目标消费者和消息ID转移到自己的pending列表中，同时需要提供<strong>IDLE（已被读取时长）</strong>，只有超过这个时长，才能被转移。</p><h3 id="坏消息问题，Dead-Letter，死信问题"><a href="#坏消息问题，Dead-Letter，死信问题" class="headerlink" title="坏消息问题，Dead Letter，死信问题"></a>坏消息问题，Dead Letter，死信问题</h3><p>delivery counter，反复转给各个消费者时会累加，当到达临界值时将该消息视为死信，此时可以处理该消息，一般删除即可，XDEL。</p><h1 id="六、发布订阅详解"><a href="#六、发布订阅详解" class="headerlink" title="六、发布订阅详解"></a>六、发布订阅详解</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis有两种发布&#x2F;订阅模式：</p><ul><li>基于频道(Channel)的发布&#x2F;订阅</li><li>基于模式(pattern)的发布&#x2F;订阅</li></ul><h2 id="基于频道的发布和订阅"><a href="#基于频道的发布和订阅" class="headerlink" title="基于频道的发布和订阅"></a>基于频道的发布和订阅</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">publish channel:1 hi #发布消息<br><br>subscribe channel:1 #订阅频道，随后进入订阅状态<br></code></pre></td></tr></table></figure><p>处于订阅状态下客户端不能使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>和<code>punsubscribe</code>这四个属于”发布&#x2F;订阅”之外的命令，否则会报错。</p><h2 id="基于模式-pattern-的发布-x2F-订阅"><a href="#基于模式-pattern-的发布-x2F-订阅" class="headerlink" title="基于模式(pattern)的发布&#x2F;订阅"></a>基于模式(pattern)的发布&#x2F;订阅</h2><p>如果有某个&#x2F;某些模式和这个频道匹配的话，那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-6.svg"><br>通配符中<code>?</code>表示1个占位符，<code>*</code>表示任意个占位符(包括0)，<code>?*</code>表示1个以上占位符。</p><ul><li>psubscribe可以重复订阅一个频道，会收到多条消息。</li><li>subscribe和psubscribe是相互独立的，接受到消息时也会有区别。</li><li>使用punsubscribe只能退订通过psubscribe命令订阅的规则。</li></ul><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="基于频道"><a href="#基于频道" class="headerlink" title="基于频道"></a>基于频道</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-4.svg"></p><ul><li>订阅时，将客户端添加到对应channel的list中。</li><li>发布时，订阅到channel，发送给List中所有客户端。</li></ul><h3 id="基于模式"><a href="#基于模式" class="headerlink" title="基于模式"></a>基于模式</h3><ul><li>订阅时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code> 链表中。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93DB/Redis/Redis%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84%EF%BC%89/db-redis-sub-10.svg"></li><li>发布时，遍历pubsubPattern，逐一对比看是否要发送。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>Redis</category>
      
      <category>Redis基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第6章（应用层）</title>
    <link href="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-968c1bcea54ea1f4.webp"><br>例子：<br><strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong>，该应用还涉及到域名到IP地址的转换，由属于<strong>应用层范畴的域名系统DNS</strong>完成。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4e9858624d4835ae.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c1c3868fb5e127b1.webp"></p><h1 id="二、两种组织方式"><a href="#二、两种组织方式" class="headerlink" title="二、两种组织方式"></a>二、两种组织方式</h1><h2 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-bbfb139bb8ffd796.webp"></p><h2 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-598b1158f5c33a11.webp"></p><div class="note note-primary">            <p>www,email,ftp为C&#x2F;S架构。</p>          </div><h1 id="三、动态主机配置协议DHCP"><a href="#三、动态主机配置协议DHCP" class="headerlink" title="三、动态主机配置协议DHCP"></a>三、动态主机配置协议DHCP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>DHCP</strong>使用了C&#x2F;S方式：</p><ul><li>主机在启动时向DHCP服务器广播发送发现报文 （DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li><li>基于UDP工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h3><h4 id="发现报文"><a href="#发现报文" class="headerlink" title="发现报文"></a>发现报文</h4><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong>，其中包含<strong>事务ID</strong>，<strong>DHCP客户端的MAC地址</strong></p><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-6f9a9715f8b1c74a.webp"></p><blockquote><p>报文包括：</p><ul><li><strong>源IP地址</strong>：0.0.0.0，这是因为主机目前还未分配到IP地址。</li><li><strong>目的地址</strong>：广播地址255.255.255.255。</li><li><strong>MAC地址</strong>：主机MAC地址。</li></ul></blockquote><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送。</p><h4 id="提供报文"><a href="#提供报文" class="headerlink" title="提供报文"></a>提供报文</h4><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03ecd6d2838d4274.webp"></p><blockquote><p>报文包括</p><ul><li><strong>事务ID</strong>：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的。</li><li><strong>配置信息</strong>：IP地址、子网掩码、地址租期、默认网关、DNS服务器</li><li><strong>源IP地址</strong>：发送DHCP提供报文的DHCP服务器的IP</li><li><strong>目的地址</strong>：因为目的主机还没分配到IP，所以使用广播地址</li></ul></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-009b1e9a88976880.webp"></p><blockquote><p>报文包括<br><strong>事务ID</strong><br><strong>MAC地址</strong><br><strong>接受的IP地址</strong><br><strong>提供此租约的DHCP服务器端的IP地址</strong><br><strong>源IP地址</strong>：0.0.0.0<br><strong>目的地址</strong>：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们作为自己的DHCP服务器。</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文。</p><h4 id="确认报文"><a href="#确认报文" class="headerlink" title="确认报文"></a>确认报文</h4><p><strong>DHCP服务端将广播发送DHCP确认报文（DHCP ACK）</strong><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-35c9002bba766476.webp"></p><blockquote><p>报文包括：<br>源地址：DHCP服务器1的IP地址<br>目的地址：广播地址</p></blockquote><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong>，<strong>在使用前还会进行ARP检测</strong>。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-044fb99d76bd279c.webp"></p><h4 id="剩余流程"><a href="#剩余流程" class="headerlink" title="剩余流程"></a>剩余流程</h4><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a01eacfba40e9098.webp"></p><div class="note note-primary">            <p>由于确认客户端的IP地址前，其都没有IP地址，所以DHCP借用IP的过程中报文的目的IP都是广播，服务器的源IP地址都是自身IP地址，客户端IP地址为默认0.0.0.0。</p><p>客户端请求IP是一个4握手过程。前2个握手用于服务端和客户端明确对方的存在并给客户端一个Offer。后2个握手就是客户端确定这个Offer的过程。</p><p>第三个握手，虽然是广播，但其他的DHCP服务器是不会接受的，因为事物ID不符。</p><p>到达0.5倍租用期时，客户端会主动续租，若超过了租用期，则停止使用这个IP地址。</p>          </div><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-33c64efac75f0ad2.webp"></p><p>由于网络之间存在广播域，主机的广播消息可能无法送达DHCP服务器，可为路由器配置DHCP中继代理服务，路由器会将接受到的DHCP报文转发到DHCP服务器。</p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-37d8836f5ed85036.webp"></p><h1 id="四、域名系统DNS"><a href="#四、域名系统DNS" class="headerlink" title="四、域名系统DNS"></a>四、域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8dc45fb61122f775.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-31a3076fe8055379.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-4655232a57435f63.webp"></p><blockquote><p>名称相同的域名等级未必相同。</p></blockquote><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c2350ce866abf74e.webp"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-aae45d426ec7fa49.webp"></p><div class="note note-primary">            <p>递归查询的过程是链式调用，最后将域名对应的IP地址返回给主机。<br>迭代查询的过程是由本地域名服务器作为请求主体，迭代查询各级服务器IP。</p>          </div><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-d2652511b6f2280d.webp"></p><div class="note note-primary">            <p>本地域名服务器使用高速缓存减少DNS查询次数，但需要保证正确性，所以对于每一项缓存都有倒计时，超时的记录会被删除。<br>同时，主机也需要做缓存（多级缓存），启动时便向本地域名服务器获取域名和IP的数据库信息，必要时再询问服务器。</p>          </div><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-93d3fbaa54195112.webp"></p><h1 id="五、文件传送协议FTP"><a href="#五、文件传送协议FTP" class="headerlink" title="五、文件传送协议FTP"></a>五、文件传送协议FTP</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-df91fe396712c633.webp"></p><h2 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h2><p>FTP采用了C&#x2F;S方式，监听熟知端口（21）。</p><h3 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-885981a43745ae55.webp"></p><div class="note note-primary">            <p>主动、被动指的是数据通道的建立发起者是否是服务器，主动模式服务器会使用固定的端口号连接客户端的临时端口号，被动模式服务器会开启某个临时端口号等待客户端连接。<br>注意，两种方式最后都会建立两个连接通道，控制连接在整个会话期间保持打开状态，数据连接传输完毕后就关闭。</p>          </div><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/Pasted-image-20221230015319.png"></p><h1 id="六、电子邮件"><a href="#六、电子邮件" class="headerlink" title="六、电子邮件"></a>六、电子邮件</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-905f080fde0331a5.webp"></p><blockquote><p>注意：SMTP是发送协议，POP3&#x2F;IMAP是读取协议。</p></blockquote><h2 id="邮件发送和接受过程"><a href="#邮件发送和接受过程" class="headerlink" title="邮件发送和接受过程"></a>邮件发送和接受过程</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-a55537e03d980133.webp"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）"></a>简单邮件传送协议SMTP（<em>Simple Mail Transfer Protocol</em>）</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-03f4877d2621c261.webp"></p><h3 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-fb16b5ace5466b25.webp"></p><div class="note note-primary">            <p><strong>MIME</strong>是一层非ASCII和ASCII码之间的扩展转换器，其可以协助非ASCII码邮件以SMTP的形式发送。</p>          </div><h3 id="邮件接受"><a href="#邮件接受" class="headerlink" title="邮件接受"></a>邮件接受</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-c825d1ad122bd41c.webp"></p><blockquote><p><strong>POP3</strong>是正式标准，客户只读。<br><strong>IMAP4</strong>是建议标准，客户可以操作服务器中的邮件，需要联机。</p></blockquote><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-46b15b10a17604fa.webp"></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-b400e3f6c0a87238.webp"></p><div class="note note-primary">            <p>POP3使用110端口，IMAP4使用143端口</p>          </div><h1 id="七、万维网WWW"><a href="#七、万维网WWW" class="headerlink" title="七、万维网WWW"></a>七、万维网WWW</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>基本概念</p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络，而是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网以<strong>客户 - 服务器</strong>方式工作。<strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-8646898df7461ca3.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-05ae15f55de2ba0a.webp"></p><h2 id="HTTP（Hyper-Transfer-Protocol）"><a href="#HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="HTTP（Hyper Transfer Protocol）"></a>HTTP（<em>Hyper Transfer Protocol</em>）</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP是一个应用层协议，它使用 <strong>TCP 连接</strong>进行可靠的传送。</li><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-614d1960b2b805d9.webp"></li></ul><div class="note note-primary">            <p>可以注意到第三次握手的时候就发出了HTTP请求报文。</p>          </div><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-22dfb8a34acf459c.webp"><br>响应报文<br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-0409ca153701fbb4.webp"></p><h3 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-969dc15b42399e98.webp"></p><h3 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h3><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-abf0fcf785757c26.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-e7f4b696946ffafa.webp"><br><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-14ec3f45c4af32f9.webp"></p><div class="note note-primary">            <p>为了保证缓存的正确性，设置有过期时间，若没有过期，则直接返回，若过期了，则询问服务器文档内容是否有变化：</p><ul><li>若没有则直接返回一个普通响应，缓存服务器接受后直接刷新倒计时。</li><li>若有则返回新的文档内容，缓存服务器接收并更新内容。</li></ul>          </div><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/30/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC6%E7%AB%A0%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/24878825-dab94fae0e969502.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/3b490c10d129">计算机网络第6章（应用层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第5章（运输层）</title>
    <link href="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程之间通讯<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-86df51cb4523e3bf.webp"></p><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><div class="note note-primary">            <p>NAT虽然实现上涉及到了端口，但在规范中我们仍将其只视为网络层的协议。</p>          </div><p>之前介绍的物理层、数据链路层、网络层解决了主机到主机的通讯。但通讯的真正实体是位于通讯两端主机的进程，如何为这两个进程提供通讯服务是运输层的任务，运输层协议也被称为端到端协议。</p><h2 id="端口号与复用"><a href="#端口号与复用" class="headerlink" title="端口号与复用"></a>端口号与复用</h2><p>端口号的使用<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-de597eda77aa6acd.webp"></p><h3 id="发送方与接受方的复用"><a href="#发送方与接受方的复用" class="headerlink" title="发送方与接受方的复用"></a>发送方与接受方的复用</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2a4ec3f5d5c11433.webp"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong><br><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做 <strong>分用</strong>。</p></blockquote><h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2117fa99a7f2a89c.webp"></p><h1 id="二、运输层传输流程（DNS）"><a href="#二、运输层传输流程（DNS）" class="headerlink" title="二、运输层传输流程（DNS）"></a>二、运输层传输流程（DNS）</h1><ul><li>DNS客户端（端口为短暂端口号）发送一个<strong>DNS请求报文</strong>（UDP）到DNS服务器（端口号为53）。</li><li>DNS服务器将接受到的信息上传给DNS服务器端进程（端口号为53），随后给用户回复<strong>DNS响应报文</strong>（UDP），目的端口为客户端的短暂端口号。</li><li>DNS客户端将接受到的信息上传给DNS客户端进程（端口号为短暂端口号），随后解析DNS响应报文，即可直到Web域名对应的IP地址。</li><li>向Web域名对应的IP发送http请求。</li></ul><h1 id="三、UDP与TCP对比"><a href="#三、UDP与TCP对比" class="headerlink" title="三、UDP与TCP对比"></a>三、UDP与TCP对比</h1><h2 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h2><ul><li>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>；当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。；UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</li><li>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接；UDP的通信是无连接的，不需要套接字（Socket）。</li></ul><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-58c94f043969af9a.webp"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>结构<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-624005a24bc5bfcd.webp"><br>实现</p><ul><li>UDP可以<strong>广播、多播和单播</strong></li><li>UDP对应用进程交下来的报文<strong>既不合并也不拆分</strong>，而是保留这些报文的边界</li><li>UDP向上层提供<strong>无连接不可靠传输服务</strong></li></ul><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP(Transmission Control Protocol)"></a>TCP(Transmission Control Protocol)</h2><p>结构<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-db48b70af7fb7884.webp"><br>实现</p><ul><li>TCP只支持单播，端对端通讯</li><li>需要先通过3次握手建立连接</li><li>TCP是面向字节流的，即其<strong>可能会拆分上层交付的报文</strong>。</li><li>TCP向上层提供<strong>面向连接的可靠传输服务</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-b0c1d4146735458a.webp"></p><h1 id="四、TCP流量控制"><a href="#四、TCP流量控制" class="headerlink" title="四、TCP流量控制"></a>四、TCP流量控制</h1><p>目的：发送的速率尽可能快，但需要接受方来得及接受。<br>实现：滑动窗口。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=60">具体流程视频</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>累计确认+选择重传（只重传超时的，即每个窗口独立持有一个计时器）</p><ol><li>发送端和接受端分别具有发送窗口和接受窗口。发送端会将发送窗口内的字节数据依次发出。</li><li>接受方通过累计确认提示发送端应该<strong>如何调整发送窗口的大小</strong>（流量控制）以及<strong>已经接受到了n字节之前的数据</strong>。</li><li>发送方接受到累计确认后<strong>调整发送窗口大小</strong>并<strong>移动发送窗口</strong>。</li><li>移动发送窗口后：<ul><li>将刚进入窗口的窗口信息发送出去</li><li>同时等待看是否有窗口触发超时重传，若有则重传旧数据。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f73e94f75e94ea4c.webp"></li></ul></li><li>接受端将发送窗口调整为了0，说明暂时不接受数据，其恢复后给发送方的提示是可能丢失的。因此，<strong>当发送窗口为0（接受到0窗口通知）时，</strong>发送方<strong>持有持续计时器，超时时会发送</strong>零窗口探测报文**，确认接受端处理能力情况。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-5bd53b8a5a5ac400.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ea9dc3589e6c6bd1.webp"></li></ol><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d8221e9dda7919f9.webp"></p><h1 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-9d4b410b2a44c125.webp"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><div class="note note-primary">            <p>理解拥塞原因：<br>1.传输时，链路容量不足；2.接受时，容量太小；3.处理时，速率太慢；4.负反馈。</p>          </div><p><strong>拥塞控制的一般原理</strong></p><ol><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ol><p><strong>开环控制和闭环控制</strong><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2740d71c5e1d6aac.webp"></p><p><strong>监测网络的拥塞</strong><br>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><h2 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-67852fc13fc0e263.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c7682fe29ebcb6fd.webp"></p><blockquote><p>发送窗口大小 &#x3D; min(接受方窗口大小，拥塞窗口大小)</p></blockquote><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><ul><li><p>目的：用来确定网络的负载能力或拥塞程度。</p></li><li><p>算法的思路：由小到大逐渐增大拥塞窗口数值。</p></li><li><p>两个变量：</p><ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值有2 种设置方法。窗口值逐渐增大。第一种是1 至 2 个最大报文段 （旧标准）；第二种是2 至 4 个最大报文段 （RFC 5681）</li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li><li><p>实现：</p><ul><li>起初拥塞窗口按指数增加，当达到慢开始门限后，为了避免出现拥塞，每经过一个传输伦次，cwnd++</li><li>如果出现超时重传，则重新回到慢开始<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f5db7ea25d8aca73.webp"></li></ul></li></ul><div class="note note-primary">            <p>慢开始是为了从小到大且尽快的达到门限，门限后则缓慢的扩大拥塞窗口来试探网络情况，两者一起使用以实现动态调整拥塞窗口。</p>          </div><div class="note note-warning">            <p>注意：这里是拥塞窗口的变化，而不是发送窗口的变化，发送窗口的大小还受限于接受端的接受窗口。</p>          </div><h3 id="快重传（fast-retrasmit）与快恢复（fast-recovery）"><a href="#快重传（fast-retrasmit）与快恢复（fast-recovery）" class="headerlink" title="快重传（fast retrasmit）与快恢复（fast recovery）"></a>快重传（<em>fast retrasmit</em>）与快恢复（<em>fast recovery</em>）</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-a57c7cc819aa4bae.webp"></p><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ab5a63efbd586eb8.webp"></p><div class="note note-primary">            <p>一般接受方对接受到的报文段的确定都是捎带的，和窗口控制报文一起发送给发送端，导致重传开启较慢。<br><strong>快重传</strong>：需要接受端尽快的回复接受到的报文信息，然后发送端实现快重出传（接受到连续3个重复的确认报文）</p><p>发送端发生重传时，直接进入慢开始，这对于仅丢失个别报文的传输的效率较大，而快重传刚好可以确定这类情况。<br><strong>快恢复</strong>：当发送快重传时不进入慢开始，而是调节ssthresh值和cwnd值为一半后直接开始执行拥塞避免算法。</p><p>快恢复要和快重传结合使用，快恢复的具体调整依赖于发送端具体的实现。</p>          </div><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-8f61b8eddb5b2624.webp"></p><h1 id="六、TCP超时重传时间的选择"><a href="#六、TCP超时重传时间的选择" class="headerlink" title="六、TCP超时重传时间的选择"></a>六、TCP超时重传时间的选择</h1><p>不必要的重传会导致网络负荷的增大，但重传推迟的太久也会导致传输效率的降低。因此需要合理的设置超时重传时间<em>RTO</em>，其应该略大于往返时间<em>RTT</em>，具体计算：</p><h2 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-20d1cf6bb211fe7e.webp"></p><h2 id="RTO"><a href="#RTO" class="headerlink" title="RTO"></a>RTO</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-39ab62874e65b623.webp"></p><div class="note note-primary">            <p>RTT计算：越近的RTT样本权重越大。<br>RTO计算：在RTT的基础上加上了RTT的偏差。(相当于加上了RTTs与新样本的差异，β只是一个权重参数，RTT（D1） &#x3D; RTT（1）&#x2F;2只是数据的初始化）。</p>          </div><h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-dbc63525eab966e1.webp"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-c94fa8a3ad6b277f.webp"></p><h1 id="七、TCP可靠传输的实现"><a href="#七、TCP可靠传输的实现" class="headerlink" title="七、TCP可靠传输的实现"></a>七、TCP可靠传输的实现</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-6d10ea76a1ea032b.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-92d975bc880db892.webp"><br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-35bff0a8cc5b0d71.webp"></p><div class="note note-primary">            <p>发送方接收到确认消息后，需要1.前移2.调整窗口大小。<br>调整窗口大小时，原则上窗口的前沿是不推荐后移的，所以最好是通过 后沿前移+前沿不动 来实现窗口缩小。</p>          </div><div class="note note-primary">            <p>接收方对数据的确认有累计确认和捎带确认：</p><ul><li>累计确认要求接收方不要过迟的发送确认。</li><li>捎带确认使用较少。</li></ul>          </div><h1 id="八、TCP的运输连接管理"><a href="#八、TCP的运输连接管理" class="headerlink" title="八、TCP的运输连接管理"></a>八、TCP的运输连接管理</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e7d2329746de8e6a.webp"></p><h2 id="TCP连接建立（握手）"><a href="#TCP连接建立（握手）" class="headerlink" title="TCP连接建立（握手）"></a>TCP连接建立（握手）</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-84c2b6dbb20379bd.webp"></p><div class="note note-primary">            <p><strong>双报文握手</strong>保证双方得知对方的存在，随后可以直接发送数据。<br><strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误，导致服务器资源浪费。</p>          </div><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-0a5773a600817c41.webp" alt="两报文握手"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-e69d0e450b080e1f.webp" alt="服务器打开传输控制块"></li></ul><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。<br>之后，就准备接受TCP客户端进程的连接请求。<br>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求。<br>而TCP客户端在主动打开前也是要先创建传输控制块。</p></blockquote><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-3205fd7d7d75b62e.webp"></p><div class="note note-primary">            <p><strong>SYN</strong>，<strong>ACK</strong>是TCP报文头中的一个bit，其标识了当前TCP报文的属性：<br>SYN（同步标志位）表示请求同步，ACK（确认标识位）表示是对某报文的回复。<br><strong>seq</strong>，<strong>ack</strong>是TCP报文头中的两个字段，都占4个字节，其标识了端消息的id和确认收到的消息id+1。</p><p>TCP规定SYN&#x3D;1的报文段即使不携带数据，也要消耗掉一个序号。<br>普通的确认报文可以不消耗序号。</p>          </div><h2 id="TCP连接释放（挥手）"><a href="#TCP连接释放（挥手）" class="headerlink" title="TCP连接释放（挥手）"></a>TCP连接释放（挥手）</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-1c5e0c6357d039ed.webp"></p><ul><li>前两次握手是确认服务器接受到了释放连接的请求，此后服务器对剩余数据进行传输，客户端进入终止等待2状态。</li><li>后两次握手是确认客户端接受到了释放连接的命令，此后服务器关闭，客户端则继续等待2MSL，这是为了防止第四次握手丢失导致服务器资源浪费。若直接关闭：<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-ef85470fe120f146.webp"></li><li>若服务器没有收到第四次握手，则会重传第三次握手，以确保收到第四次握手。</li></ul><div class="note note-warning">            <p>第二次握手和第三次握手的ack序号相同，说明这个消息是对同一个消息（第一次握手）的回应，分别表示服务器收到释放连接请求和服务器运行释放连接请求。</p>          </div><div class="note note-warning">            <p>可见握手和挥手，都需要客户端保证对服务器连接的最终确认以防止服务器的资源浪费。<br>在握手中体现在服务器之后接收到第三次握手确认在进入连接状态。<br>在挥手中体现在客户端会保持等待，服务器主动重传第三次握手以收到第四次握手。</p>          </div><div class="note note-primary">            <p><strong>FIN</strong>是TCP报文头中的一个bit，表示请求释放连接。在挥手中其会出现两次，一次是客户端主动请求释放连接，一次是服务器回复可以释放连接了。</p><p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>          </div><h2 id="TCP保活计时器"><a href="#TCP保活计时器" class="headerlink" title="TCP保活计时器"></a>TCP保活计时器</h2><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障，TCP服务器进程以后就不能再收到TCP客户进程发来的数据，因此，应当有措施使TCP服务器进程不要再白白等待下去<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-2dc97e06fe1d82ed.webp"></p><h1 id="九、TCP报文段的首部格式"><a href="#九、TCP报文段的首部格式" class="headerlink" title="九、TCP报文段的首部格式"></a>九、TCP报文段的首部格式</h1><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-df9263a14e1da2c1.webp"></p><h2 id="固定首部"><a href="#固定首部" class="headerlink" title="固定首部"></a>固定首部</h2><p>源端口和目的端口<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-27e4bd51d5db2f8e.webp"><br>序号、确认号和确认标志位<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-fd0e64d8be3f598b.webp"><br>数据偏移、保留、窗口和校验和<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d3d4c61af68fdb6d.webp"><br>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针。<br><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-f09bdaba863c4ca3.webp"></p><h2 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h2><p><img src="/2022/12/28/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89/24878825-d1a8d3ca5ac7f39d.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/ff5c1089a985">计算机网络第5章（运输层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第4章（网际层）</title>
    <link href="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li><li>为了实现这个任务，有以下问题：<ul><li>网络层提供可靠传输还是不可靠传输</li><li>网络层怎么寻址(IP地址做导航)</li><li>网络层路由选择(路由器根据路由表转发，为了记录路由需要人工配置或实现各种路由选择协议)</li></ul></li></ul><blockquote><p>网络层（网际层）,除了<strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><blockquote><p>由于TCP&#x2F;IP协议栈的网络层使用网际协议IP，因此在TCP&#x2F;IP协议中网络层常称为网际层。</p></blockquote><div class="note note-primary">            <ul><li>数据链路层能通过MAC地址与交换机实现数据的定向传输，但是对于庞大的因特网，这显然是不合理的，相比起MAC地址的无序序列，我们需要一个具有明显层级关系的地址（如湖北省武汉市洪山区）方便快速定位，统一管理，因此有了IP地址。</li><li>网络层需要实现数据在局域网和局域网之间的传递（不同于之前的局域网通过交换机互联，这样会扩大广播域，VLAN虽然能实现类似的功能，但依赖于用户设置，无法达到全网统一）。</li></ul>          </div><h1 id="二、网络层提供的服务"><a href="#二、网络层提供的服务" class="headerlink" title="二、网络层提供的服务"></a>二、网络层提供的服务</h1><p>网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”），实质就是<strong>在计算机通信中，可靠交付应当由网络还是端系统来负责</strong>？</p><ul><li>第一种观点是<strong>网络提供虚电路连接</strong>（一种使用<strong>面向连接</strong>的通信方式，通信之前先建立<strong>虚电路</strong>，保证所有网络资源，分组即可按顺序无差错的到达），由网络本身负责可靠交付。</li><li>另一种观点是<strong>网络只提供数据报服务</strong>，向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong>。</li></ul><blockquote><p>显然后者是我们现在使用的，其运行灵活，造价低，适应性强。</p><p><strong>区别</strong><br>终点地址：<br>1.仅在连接建立阶段使用，每个分组使用短的虚电路号<br>2.每个分组都有终点的完整地址</p><p>当结点出故障时：<br>1.所有通过出故障的结点的虚电路均不能工作<br>2.出故障的结点可能会丢失分组，一些路由可能会发生变化</p><p>端到端的差错处理和流量控制：<br>1.可以由网络负责，也可以由用户主机负责<br>2.由用户主机负责</p></blockquote><div class="note note-primary">            <p>当前网络层的服务实现是：<strong>尽最大努力交付</strong>。</p>          </div><h1 id="三、IPv4"><a href="#三、IPv4" class="headerlink" title="三、IPv4"></a>三、IPv4</h1><p><strong>IPv4地址</strong>是因特网（<em>Internet</em>）上每一个主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32bit（4个字节）的标识符。</p><div class="note note-warning">            <p>只有<strong>公网IP</strong>是全世界独一无二的，<strong>私网IP</strong>是在不同局域网中可以重复使用的：<br>RFC1918定义了私有IP的地址范围：<br>A:10.0.0.0 ~ 10.255.255.255即10.0.0.0&#x2F;8<br>B:172.16.0.0 ~ 172.31.255.255即172.16.0.0&#x2F;12<br>C:192.168.0.0 ~ 192.168.255.255 即192.168.0.0&#x2F;16</p>          </div><div class="note note-success">            <p><strong>私有IP是无法随意定义的</strong>，只有以上范围内的IP会被路由器视为内网IP，以这些IP为源IP的数据包只会在局域网内传递，不会在因特网上传递。</p><p>私有IP设备<strong>发送</strong>与<strong>接受</strong>外网数据包：<br>首先内网中的客户端将数据包传送给路由器，路由器解析数据包后发现，这个数据包是来自与私网、发送给外网的。例如某个数据包的源IP:192.168.1.2，当路由器检测到这个数据包的目标IP是外网IP的时候，路由器中会生成一个唯一端口号对应192.168.1.2，再生成一个随机端口号对应这个唯一端口号。然后路由器会将数据包的源IP改成公网IP，发送到互联网上。接收数据时，数据包会被发送到路由器的随机端口号上，这时和原来生成的映射表进行匹配，再把数据包传送到内网客户端，其实就是一个端口映射表。<br><a href="https://blog.csdn.net/weixin_39661353/article/details/110806482">路由器修改报文端口号</a></p>          </div><p>IPv4的编址方法经历了3个阶段：<br><strong>分类编址 -&gt; 划分子网 -&gt; 无分类编址</strong></p><h2 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h2><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-617a75508f564e07.webp"><br>其中有2个网络号无法分配，即A类地址：</p><ul><li><strong>最小网络号为0，保留不做指派</strong></li><li><strong>最大网络号为127，是本地回环测试地址，保留不做指派</strong></li></ul><p>有2类主机号无法分配：</p><ul><li>全0的主机号，其表示该网络的标识地址</li><li>全1的主机号，其表示该网络的广播地址</li></ul><div class="note note-primary">            <p>网络号，主机号都为0，即<code>0.0.0.0</code>，表示本网络上的本主机（见DHCP协议）</p>          </div><blockquote><ul><li><strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</li><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li><li><strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong></li></ul></blockquote><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p>两级的IP地址会导致IP地址空间的利用率很低。<br>子网即从主机号借一部分作为子网号，从而将一个网络号分为多个子网。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5006c8be601f1a11.webp"><br>划分子网的工具即<strong>子网掩码</strong>。<br>其将<strong>两级的IP地址</strong>变成了<strong>三级的IP地址</strong>。</p><p><strong>默认子网掩码</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5e9d1b71bd598e62.webp"></p><p>IPv4地址与子网掩码相与即得到所在子网的网络地址。</p><blockquote><p>对于在因特网上传输的数据报，仍然是根据<strong>目的网络号</strong>net-id寻找下一跳路由器。到了该网络号的路由器时，路由器再根据<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</p></blockquote><div class="note note-primary">            <p><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。<br>这里所谈论的<strong>划分子网</strong>针对的仍然是因特网上的IP地址，其并没有造成IP地址重复（<code>相同的ip/不同的子网掩码</code>指的仍是同一个主机），只是单位内部对于可分配的主机号进行的一种再划分，即：</p><ul><li>子网掩码对于外网路由器没有作用。</li><li>内网路由器根据接受到的IP匹配对于的子网，能实现对该子网更精准的路由。<br>（最长前缀匹配）</li></ul>          </div><blockquote><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个记录，除了要记载目的网络地址外，还必须同时记载该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><div class="note note-primary">            <p>以上路由器行为是为了保证在传递IP数据报时，能够选择最符合的端口转发数据</p>          </div><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><p><strong>无分类域间路由选择 CIDR</strong> (<em>Classless Inter-Domain Routing</em>)。</p><ul><li>CIDR消除了A、B、C类地址和划分子网的概念。</li><li>CIDR能更有效的分配IPv4的地址空间。</li></ul><p><strong>特点</strong></p><ul><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li><li>IP 地址的形式为：<code>a.b.c.d/x</code>，其中地址的 <code>x</code> 最高比特构成了 IP 地址的<strong>网络部分（即网络前缀）</strong>，所以 <strong>CIDR 中 IP 地址由前缀和主机号构成</strong>，<code>x</code> 为前缀长度，<code>/x</code> 的记法也称为<strong>子网掩码</strong>。</li></ul><div class="note note-primary">            <p><strong>CIDR</strong>只是在网络实现层面消除了这些概念，并不代表A、B、C类地址和划分子网的协议行为不存在了。具体而言，总服务商分配到的公网IP地址基本仍为A、B、C类地址（如130.67.0.0&#x2F;16），不过服务商可以把这些地址再划分下去给子服务商(如130.67.0.0&#x2F;17和130.67.128.0&#x2F;17)使用，我们也不再把这样的关系称为总网、子网关系。</p><p>问题：130.67.0.0&#x2F;16 和130.67.0.0&#x2F;17还是同一个目标IP地址吗？<br>答：这个问题本身就是错误的。</p><ol><li><strong>IP地址仍然为一个全网唯一的IP地址</strong>，并没有后面的网络前缀的区分。</li><li>对于一个目标IP地址，<strong>不会也不可能在数据传递时携带网络前缀</strong>。</li><li>在数据的传输中，<strong>网络前缀只保存在路由器表中</strong>，用于记录与路由器相连接的网络的所在的网络号。</li></ol><p>问题：如果两个服务商，一个分到了<code>130.67.0.0/16</code>的公网IP，一个分到了<code>130.67.128.0/17</code>的公网IP，此时服务商1内部划分出子网<code>130.67.128.0/17</code>，其是否会与服务商2的IP在公网上重复？<br>答：不会。如上面所说，IP地址在分配时仍有等级之分，服务商一般只会分到<code>/8</code>，<code>/16</code>，<code>/24</code>这样的网络前缀，像<code>/17</code>这样的IP和网络前缀，本身就是由服务商1分发出来的，不可能由服务商2获得。</p>          </div><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p><strong>超网（路由聚合）技术是为了解决路由表的内容冗余问题，使用路由聚合能够缩小路由表的规模，减少路由表的内存。</strong></p><p>即路由器发现其某个端口与多个具有相同前缀的网络对应，会将这些记录合并。</p><blockquote><p>举个例子，如果路由器1与路由器2连接，路由器2的各个端口连接了不同的网络（本质上是多个子网）。<br>经过路由器交换学习，路由器1会得知路由器2所在网络号和网络前缀，而路由器2的不同接口在不同的网络号中，因此路由器1学习到了路由器2的多个网络。（如<code>67.67.0.0/18</code>，<code>67.67.64/18</code>, <code>67.67.128.0/18</code>,<code>67.67.192.0/18</code>)<br>此时，路由器1发现虽然有多个网络，但他们都对应着同一个端口，并且具有相同前缀（<code>67.67.0.0/16</code>）。此时路由器1会将这些记录合并，这种行为叫做路由聚合，也叫构造超网。</p></blockquote><h3 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h3><p>最长匹配 是指存在多条目的网段相同的路由时，匹配掩码最长的那一条。因为掩码越长，表示的网段就越小，匹配也就越精确。</p><div class="note note-primary">            <p>条件：</p><ul><li>路由器1：外部路由器。</li><li>路由器2：连接多个网段（子网）路由器。</li><li>路由器3：连接路由器2的一个子网路由器。</li><li>网段3：路由器3所在的网络。</li><li>3个路由器两两相连。<br>对于划分子网的IPv4地址，同一网络号的不同子网的记录只保存在该网络的中转的路由器2中。对于路由器1，其只需要知道路由器2的总网络号即可，其子网的划分对路由器1是<strong>屏蔽的</strong>。</li></ul><p>但CIDR不再区分子网，路由器1会学习与之相连接的路由器2的所有网络号（IP和网络前缀）。这导致路由器2所在的子网对路由器1也是<strong>可见的</strong>，因此需要将这些网络号在本路由器的路由表中聚合起来，避免路由表内存浪费。</p><p>至于最长匹配原则，则可以当某个数据包要从路由器1要发往子网3。此时路由器1会优先匹配到最长的网段3，并将数据转发到路由器3。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/routeUnion.png"></p><h2 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h2><ul><li>定长的子网掩码FLSM（<em>Fixed Length Subnet Mask</em>）</li><li>变长的子网掩码VLSM（<em>Variable Length Subnet Mask</em>）</li></ul><blockquote><p>前者就是分类IP，后者就是无分类IP<br>定长的子网掩码只能划分出2^n个子网，而变长的子网掩码可以按需分配，减少对IP地址的浪费。</p></blockquote><h1 id="四、IP数据包的发送和转发过程"><a href="#四、IP数据包的发送和转发过程" class="headerlink" title="四、IP数据包的发送和转发过程"></a>四、IP数据包的发送和转发过程</h1><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>,由默认网关帮忙转发</li><li>为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，所指定的路由器，也被称为<strong>默认网关</strong>。（具体地，默认网关指的是与本机网络直接相连的路由器<strong>接口</strong>，即下图中的0。通俗的讲，默认网关就是本网络与外网的默认接口）</li></ul></blockquote><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0351946f5505b37a.webp"></p><div class="note note-primary">            <p>前提：</p><ul><li>本机IP ＆ 本机掩码 &#x3D; 本机网络</li><li>目的IP ＆ 目的掩码 &#x3D; 目的网络</li></ul><p>正向来看：<br>如果：目的网络 &#x3D;&#x3D; 本机网络（即目的掩码 &#x3D; 本机掩码）<br>那么：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络（目的网络）</p><p>反向来看：<br>条件：目的IP ＆ 本机掩码 &#x3D;&#x3D; 本机网络<br>问题：目的网络是否为本机网络呢？<br>答案：<strong>是</strong>。考虑这个问题的时候主要在想以下情形：<br>”如果目的网络（<code>190.68.16.128/25</code>）是本机网络（<code>190.68.16.0/24</code>）的子网，那么上面条件是成立的，但该子网和该网络并不能划等号。“<br>但实际上这个想法本质就是错误的，在<strong>CIDR和变长的子网掩码</strong>中：</p><ol><li>IP网络之间的关系已经没有了父子关系，</li><li>对于变长子网掩码，不同的子网之间的关系依然是并列的。也就是说，如果本机IP的网络会被划分成（<code>190.68.16.0/24</code>），就说明已经有一个网段包含了<code>190.68.16.xxx</code>的所有主机，<code>190.68.16.128/25</code>网络根本就不可能存在，即若有某主机IP为<code>190.68.16.129</code>，其子网掩码也一定是<code>/24</code>。</li></ol><p>以上证明了可以根据本机掩码和目的IP判断目的网络是否为本机网络，但如果不是本机网络，则不能直接判断目的网络的具体掩码长度，不过对于本机而言，只需要操心一个IP是由自己直接交付（本机网络）还是交给路由器（外网网络）处理即可。</p>          </div><h2 id="路由器行为"><a href="#路由器行为" class="headerlink" title="路由器行为"></a>路由器行为</h2><ol><li>检查IP数据报首部是否出错<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ol><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>静态路由配置指用户或网络管理员使用路由器的相关命令给路由<strong>人工配置路由表</strong>。</p><p><strong>默认路由</strong><br>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是<strong>优先级最低</strong>的。一般为0.0.0.0&#x2F;0(可以匹配所有地址)</p><p><strong>特定主机路由</strong><br>给路由器添加的针对某个主机的特定主机路由条目，可以指定其下一条目的。一般用于网络管理人员对网络的管理和测试。</p><div class="note note-primary">            <p>当多条路由可选时，使用最长匹配原则。</p>          </div><p><strong>静态路由配置</strong>其可能出现以下导致产生<strong>路由环路</strong>的错误。</p><ul><li><strong>配置错误</strong>（手动配置错误）</li><li><strong>聚合了不存在的网络</strong>（解决办法：黑洞路由）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-caeddc52bde20f9c.webp"></li><li><strong>网络故障</strong>（解决方法：为故障网路添加黑洞路由，故障恢复后使该黑洞路由失效）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d8107f8fc71dd1f4.webp"></li></ul><h2 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>动态路由选择</strong>相比<strong>静态路由选择</strong>能更好适应网络状态的变化，且适用于大规模网络。其路由器通过路由选择协议自动获取路由信息。</p><blockquote><p><strong>因特网采用分层次的路由选择协议</strong></p></blockquote><p><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器。自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-9e37d1229ec7836e.webp"></p><p><strong>路由选择协议</strong>：域间路由选择使用外部网关协议<strong>EGP</strong>这个类别的路由选择协议，域内路由选择使用内部网关协议<strong>IGP</strong>这个类别的路由选择协议。<strong>网关协议</strong>的名称可称为<strong>路由协议</strong>。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8729bdd2bd367edf.webp"></p><div class="note note-primary">            <p><strong>路由选择协议</strong>的本质是路由器之间交换信息、判断某网络是否可达并进行路径选择的规则。由于路由器之间交换信息需要进行广播行为，由于路由表容量有限和避免广播的泛滥，需要使用<strong>自治系统</strong>来隔离网络中的路由器，并保证<strong>同一个自治系统中使用同一种内部网关协议。自治系统之间则使用外部网关协议。</strong></p>          </div><h3 id="常见的路由选择协议"><a href="#常见的路由选择协议" class="headerlink" title="常见的路由选择协议"></a>常见的路由选择协议</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b1876963d6d9de0.webp"></p><h3 id="路由器基本结构和功能"><a href="#路由器基本结构和功能" class="headerlink" title="路由器基本结构和功能"></a>路由器基本结构和功能</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e6b69c1f176e24c5.webp"></p><p><strong>分组转发部分</strong><br>转发时需要注意的行为：</p><ul><li>若在转发表中找不到匹配条目则<strong>丢弃分组</strong></li><li>转发时会<strong>更新分组首部的某些字段</strong>，如分组生存时间</li><li>各端口都有缓冲区，每个端口一般都具有输入、输出功能</li></ul><p><strong>路由选择部分</strong><br>路由选择处理器根据所使用的路由选择协议周期性的与其他路由器进行路由信息交互来更新路由表。<br>如果路由器接受到的分组是路由器之间交换路由信息的<strong>路由报文</strong>，则会把这种分组送交给<strong>路由选择处理器</strong>进行处理。</p><p>路由选择处理器的行为：</p><ul><li>路由表一般只包含从目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表生成的</li><li>转发表的结构应当使查找过程最优化</li></ul><div class="note note-primary">            <p>路由表（RIB）和转发表（FIB）的联系和区别：</p><ul><li><p>联系<br>转发表是路由器使用一个特定的进程通过路由表中的信息和自身的网卡等信息综合得到的。转发表类似于交换机的地址信息表。</p></li><li><p>区别<br>首先，”转发”和”路由选择”是有区别的，”转发”时，路由器只需要把接受到的信息从合适的端口发送出去即可，只涉及到一个路由器。”路由选择”则是许多路由器协同工作的结果。<br>其次，路由表只存储三元素：目标，掩码，下一跳；而转发表存储更详细的信息：比如输出端口信息，某些MAC地址，比如标记信息等。</p></li></ul><p>这里的描述都屏蔽了MAC地址的问题，这里在汇总对比一下：</p><ul><li>MAC表：记录MAC地址和端口之间的映射关系</li><li>ARP表：记录IP地址和MAC地址之间的映射关系</li><li>路由表：记录IP地址与IP地址之间的关系和路径代价。</li></ul><p>举例：<br>局域网：使用MAC表和ARP表即可实现局域网内主机通讯（使用交换机，虽然现在不会这么使用）<br>主机流程：目的IP地址 -&gt; 目的MAC地址 -&gt;端口<br>路由器流程同上。</p><p>因特网：但不同网段之间的通讯，要涉及到网络路线选择问题。<br>主机流程：目的IP地址(非本网段) -&gt; 目的MAC地址（默认网关）-&gt;端口<br>路由器流程：目的IP地址 -&gt; 下一跳IP地址（路由选择） -&gt;MAC地址 -&gt; 端口</p>          </div><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p>路由信息协议RIP(<em>Routing Information Protocol</em>)<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-850c29aaf1e744d6.webp"></p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><strong>思路</strong></p><ul><li>距离最短为最好路由</li><li>相同距离则负载均衡</li><li><strong>只和相邻的路由器周期性的交换自己的路由表</strong></li></ul><h5 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6bf4e045a90846e0.webp"></p><p><strong>路由更新细节</strong><br>接受到更新报文后和自己的路由器对比：</p><ul><li>未知的Net，插入新信息。</li><li>相同Net和相同下一跳，<strong>覆盖距离信息</strong>。</li><li>相同Net和不同下一跳，距离不同则使用，若<strong>相等则都保留并负载均衡</strong>。</li></ul><h4 id="RIP存在的问题"><a href="#RIP存在的问题" class="headerlink" title="RIP存在的问题"></a>RIP存在的问题</h4><p>如果网络出现故障，由于远处的路由器获知这个消息慢，先发出了自己的更新报文，则可能造成路由器之间互相认为对方可以到达一个不可达的网络，形成<strong>网络环路</strong>。</p><p>解决方法<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-3a055002b79a9cda.webp"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><h4 id="RIP的优缺点"><a href="#RIP的优缺点" class="headerlink" title="RIP的优缺点"></a>RIP的优缺点</h4><blockquote><p>RIP 协议的优缺点<br>优点：</p><ol><li>实现简单，开销较小。<br>缺点：</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li><li>坏消息传播得慢”，使更新过程的收敛时间过长。</li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p>开放最短路径优先 OSPF (<em>Open Shortest Path First</em>)。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f5dc77f36b5b1047.webp"></p><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="OSPF五种分组类型"><a href="#OSPF五种分组类型" class="headerlink" title="OSPF五种分组类型"></a>OSPF五种分组类型</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a2a83ab2654e270f.webp"></p><h5 id="基本工作过程-1"><a href="#基本工作过程-1" class="headerlink" title="基本工作过程"></a>基本工作过程</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-339786779f0e1a82.webp"></p><p>部分细节：<br><strong>Hello分组</strong><br>建立并维护路由器关系的分组。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-f9c642e76e871651.webp"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong><br>包含具体的路由信息，被封装在<strong>LSU分组</strong>中<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bbed8a0d31bf19c3.webp"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6b8e10e2d82cfa6f.webp"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-4239eee0b6040f52.webp"></p><div class="note note-primary">            <p>总结，OSPF是一个路由器通过获取AS内所有路由器之间边信息，然后建立一个以自己为根节点的无环图的过程。<br>具体地，相邻路由器会通过Hello分组维护关系，并互相简单介绍自己已知的路由信息，然后各自通过路由信息请求、路由信息返回、路由信息确认等过程逐步获得整个AS内的路由信息，最后构建各自的路由表。</p>          </div><h4 id="OSPF存在的问题"><a href="#OSPF存在的问题" class="headerlink" title="OSPF存在的问题"></a>OSPF存在的问题</h4><h5 id="大量多播分组"><a href="#大量多播分组" class="headerlink" title="大量多播分组"></a>大量多播分组</h5><p>多点接入（较多路由器互联）时，会产生大量的多播分组，通讯量过大。<br><strong>解决方法</strong><br>1）屏蔽部分路径，因此只与部分路由器进行数据交换。DR出现问题后使用BDR替换。</p><p> 2）路由分区，<strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-725b3aab5aa350b1.webp"></p><blockquote><p>实现细节：</p><ul><li>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域，每个区域都有一个32比特的区域标识符，主干区域的区域标识符必须为0，主干区域用于连通其他区域，其他区域的区域标识符不能为0且不相同。</li><li>每个区域一般不应包含路由器超过200个。</li><li>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量。</li></ul></blockquote><h4 id="OSPF的优缺点"><a href="#OSPF的优缺点" class="headerlink" title="OSPF的优缺点"></a>OSPF的优缺点</h4><div class="note note-primary">            <p>优点：</p><ul><li>从算法上避免了环路的产生。</li><li>基于链路状态，相比RIP考虑了更多对链路代价的影响因素。</li><li>不限制网络规模（没有最长距离限制）</li></ul><p>缺点：</p><ul><li>实现较复杂。</li><li>路由器需要获取AS内所有路由器信息，通信量大，可以通过<strong>指定路由器</strong>和<strong>划分区域</strong>的手段解决。</li></ul>          </div><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（<em>Border Gateway Protocol</em>） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><strong>为何需要BGP？</strong><br>AS之间没有统一度量，且需要一个网关去解决AS之间通讯时的相关策略问题（政治、经纪、安全等），因此需要一个外部网关协议。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5aae9c53795e17a7.webp"></p><h4 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-04fe6f98036db57c.webp"><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-bc71c2ee5976ac53.webp"><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-b472dd1a51f30666.webp"></p><h5 id="BGP-4四种分组类型"><a href="#BGP-4四种分组类型" class="headerlink" title="BGP-4四种分组类型"></a>BGP-4四种分组类型</h5><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-67b837e6c27d5e9c.webp"></p><div class="note note-primary">            <p>总结，BGP协议要求每个AS有一个发言人，发言人之间建立TCP连接建立会话，交换路由信息。类似于OSPF协议，发言人也会构造一个无环路的AS连通图。<br>注意，<strong>BGP不保证最好路由，只选择较好路由</strong>。</p>          </div><h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-40cf22cbd65e9ed8.webp"></p><h1 id="五、IPv4数据包格式"><a href="#五、IPv4数据包格式" class="headerlink" title="五、IPv4数据包格式"></a>五、IPv4数据包格式</h1><h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><blockquote><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li></ul></blockquote><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-73800cce52c3a91e.webp"></p><h3 id="固定部分"><a href="#固定部分" class="headerlink" title="固定部分"></a>固定部分</h3><p><strong>基本信息</strong><br>主要记录一些版本，服务约定，和后续数据长度。</p><ul><li>版本：占4比特，目前最广泛的是4（IPv4）</li><li>首部长度：占4比特，该字段的取单位为<strong>4个字节</strong>（即上图的一行）。<ul><li>最小十进制取值为5，即20字节固定部分</li><li>最大十进制取值为15，即20字节固定部分和40字节可变部分</li></ul></li><li>区分服务：占8比特，需要区分服务（不同等级的服务质量）时才起作用，一般不适用该字段。</li><li>总长度：占16比特，表示<strong>单位为字节</strong>的IP数据报总长度（包括首部长度）。最大值为65535，即2^16-1</li></ul><p><strong>分片信息</strong><br>主要用于IP数据报分片<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a014cde6b0ff9691.webp"></p><ul><li>标识：占16比特，同一个IP数据包的分片应该有同一个标识，类似ID</li><li>标志：占3比特：<ul><li>DF位：1个比特，1表示不允许分片；0表示允许分片。</li><li>MF位：1个比特，1表示不是最后一个分片，0表示是最后一个分片。</li><li>保留位：1个比特。</li></ul></li><li>片偏移：占13比特，表示分片数据包的“数据载荷部分”相比原数据报中的“数据载荷部分”偏移了多少。（<strong>单位为8字节</strong>，注意，由于这里的偏移量比特位小于总长比特位，为了完成表达必须使用更大的单位。）<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-5d538557f988dc41.webp"></li></ul><p><strong>解析信息</strong></p><ul><li>生存时间TTL：占8比特，以“跳数”为单位，每次路由器转发该IP数据包，TTL-1，若为0则丢弃。</li><li>协议：占8比特，指明IPv4数据包的数据部分向上交付给什么协议。<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-94a3b7c0b1f01488.webp"></li><li>首部检验和：占16比特，检测首部在传输过程中是否出现差错。比CRC检验码简单，被称为因特网检验和。（由于TTL、片偏移、标志等可能发生变化，每次路由器转发时都要重新计算该值，耗时太大，在IPv6中已经不再计算首部校验和）</li></ul><p><strong>地址信息</strong><br>目的IP和源IP地址：各占32比特。</p><h3 id="可变部分"><a href="#可变部分" class="headerlink" title="可变部分"></a>可变部分</h3><ul><li>可选字段：长度从1到40字节不等</li><li>填充字段：确保<strong>首部长度为4字节</strong>（呼应首部长度的单位是4个字节）的整数倍，使用全0填充。</li></ul><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h3><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><div class="note note-primary">            <p>简而言之，需要一个与路由器之间的协议来<strong>监测数据的转发情况</strong>。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-8739d970a0300acc.webp"></p><blockquote><p><strong>ICMP报文会被封装到IP数据报中，但其不是高层协议，而是IP层的特殊协议（起控制作用，所以也叫网际控制报文协议ICMP）。</strong></p></blockquote><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6a02675fccdc2958.webp"></p><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><p><strong>终点不可达</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-855edabd9c1e6298.webp"><br><strong>源点抑制</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e7f27ef6c93c9621.webp"><br><strong>时间超过</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-49d82185c88813fe.webp"><br><strong>参数问题</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-e2457fe1291c9bca.webp"><br><strong>改变路由（重定向）</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-0ef50227f921ca79.webp"></p><p><strong>另外，不应发送ICMP差错报告报文情况</strong><br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-a0c3a21bb04ede42.webp"></p><h3 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（<em>Packet InterNet Groper</em>）</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-75d7bc12ca942415.webp"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（<em>traceroute</em>）</h4><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-185af899d5e5a922.webp"><br>实现原理：<br>使用从1开始递增的TTL发送多个报文，报文在路由器超时时会返回给源主机ICMP差错报告，从而得到各跳的信息。</p><h1 id="六、虚拟专用网VPN与网络地址转换NAT"><a href="#六、虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="六、虚拟专用网VPN与网络地址转换NAT"></a>六、虚拟专用网VPN与网络地址转换NAT</h1><h2 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（<em>Virtual Private Network</em>）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>虚拟专用网络</strong>VPN的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p><div class="note note-primary">            <p>顾名思义，指一种利用公网实现专用网访问的技术。</p><p>简单的说就是两个专用网络之间通过公网IP进行加密通讯。VPN属于远程访问技术，简单地说就是利用公用网络架设专用网络。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>          </div><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ad9e5dcca8c0a1c9.webp"></p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此也被称为IP隧道技术。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-6731dbc8b1ee1abc.webp"></p><h2 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（<em>Network Address Translation</em>）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>目的：大量的办公室网络和家庭网络导致IP地址仍然不够，需要实现IP复用。NAT能使大量<strong>使用内部专用地址的用户共享少量外部全球地址来访问因特网上的主机和资源。</strong></p><p>专有NAT软件的路由器叫做NAT路由器，其有至少一个公网IP地址。</p><p>以上只解决了发送信息的问题，为了实现接受消息后的对内网用户的分发需要使用NAPT技术，具体见以下实现。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-05d3e1e3fd4b1998.webp"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>外网无法直接访问内网<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-d2fd109d060e4853.webp"></li><li>NAT对内网主机提供了一定的安全保护<br><img src="/2022/12/14/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC4%E7%AB%A0%EF%BC%88%E7%BD%91%E9%99%85%E5%B1%82%EF%BC%89/24878825-ff43ea52e61da271.webp"></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/0f6de444f46c">计算机网络第4章（网络层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第3章（数据链路层）</title>
    <link href="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>物理层已经保证了数据在物理层面上的传输功能，但无法避免传输中发生的错误。数据链路层作为网络层、物理层之间的桥梁，<strong>主要的职责则是保证数据传输过程的差错控制和可靠传输</strong>，即识别、纠正传输中发生的错误。</p><p>网络中的主机、路由器、交换机等都必须实现数据链路层。</p><p>术语：</p><ul><li><strong>链路</strong>（<em>Link</em>）表示一段没有交换节点<strong>物理</strong>线路</li><li><strong>数据链路</strong>（<em>Data Link</em>）表示具有通讯协议的软硬件实现的<strong>链路</strong></li></ul><div class="note note-primary">            <p>数据链路层的协议是多样的，两个主机之间的数据传输，可能会经过多个不同协议数据链路，他们只需要保证实现数据链路层的功能和对网络层的服务相同即可。</p>          </div><p>使用的信道类型分类：</p><ul><li>点对点信道</li><li>广播信道</li></ul><blockquote><p><strong>局域网属于数据链路层</strong><br>局域网虽然也是个互联网，但我们不将其放在网络层考虑，因为网络层的主要职责是将分组从一个网络通过路由器发送到另一个网络。而局域网的功能，使用交换机即可实现。<br>PS：路由器也可以称为三级交换机，我们平时说的交换机就是二级交换机。</p></blockquote><h2 id="主要职责"><a href="#主要职责" class="headerlink" title="主要职责"></a>主要职责</h2><p>数据链路层传送的协议数据单元是<strong>帧</strong><br><strong>封装成帧</strong>：将数据加上帧头和帧尾，用于<strong>帧定界</strong><br><strong>差错控制</strong>：识别传输中的错误。<br><strong>可靠传输</strong>：识别错误后确保重传。</p><blockquote><p>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决，如帧识别（确认是发给自己的帧）、数据碰撞问题（共享信道的问题）。下面我们只讲PPP的例子。</p></blockquote><blockquote><p>目前，在有线（局域网）领域使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>已经取代了<del>共享式局域网</del><br>而在无线局域网中仍然使用的是共享信道技术</p></blockquote><h1 id="二、主要职责"><a href="#二、主要职责" class="headerlink" title="二、主要职责"></a>二、主要职责</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-bf6fe42eeea3f376.webp"><br>封装成帧的目的是识别帧分界，不同数据链路层协议对此的实现是不同的：</p><ul><li>PPP，帧头和帧尾有1字节的标识符</li><li>EtherNet的V2的MAC帧，使用一个前导码，例如：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f1441c531b4d740e.webp"></li></ul><blockquote><p>为了实现定界，需要一个开始和结尾符，以太网规定开始符为前导码，结尾符的功能通过保持帧的间距（以太网还规定了帧间间隔为96比特时间）实现（说明PPP的帧是连续的？也合理，点对点连着传）</p><p>前导码包括前同步码和帧开始定界符</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧（这里是从右往左看）</li></ul></blockquote><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，因此我们要避免上层数据中也出现帧定界符导致的解析混淆。</p><p><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (<em>byte stuffing</em>) 或<strong>字符填充</strong> (<em>character stuffing</em>)，面向比特的物理链路使用比特填充的方法实现透明传输。</p><p>具体的:</p><ul><li>发送端对于上层交付数据中出现的与定界符相同的字符，在其前插入转义字符“ESC”（十六进制编码是1B），若上层数据本身有该转义字符，则再其前插入一个转义字符。</li><li>接受端将内容中的转义字符剔除即可。</li></ul><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-9d3f61fdd96b7dee.webp"></p><p>最大传送单元MTU 规定了帧的<strong>数据部分</strong>的长度上限。</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><strong>比特差错</strong>：1变0，0变1<br><strong>误码率BER</strong>(<em>Bit Error Rate</em>)：错误bit占总bit的比率。</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>使用1位bit来标记 数据中“1”个数的奇偶性，只要出现两个相同类型误码就会漏检。</p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(<em>Cyclic Redundancy Check</em>)</h3><p>约定好一个生成多项式G(x)，其实就是一段bit串，如：10111<br>将这个bit串作为除数，原数据作为被除数，得到余数，这个数称为<strong>检错码</strong>，也称为<strong>帧校验序列 FCS</strong></p><blockquote><p>检错码只有检查错误的能力，<strong>不知道错误发送的位置</strong><br><strong>纠错码</strong>可以进行前向纠错，但成本高，使用少<br>CRC非常易于硬件实现，被<strong>广泛应用于数据链路层</strong><br>检查出错误后，是丢弃还是重传，往往取决于数据链路层向上层提供的是<strong>可靠传输服务</strong>还是<strong>不可靠传输服务</strong>。</p></blockquote><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><strong>比特差错</strong></p><ul><li>对于可靠传输要求实现重传，对于不可靠传输，交给上层协议处理。</li><li><strong>一般而言</strong>，有限链路不要求可靠，无线链路要求可靠（误码率高）。</li></ul><p><strong>分组丢失、分组失序、分组重复</strong><br>一般不发生在数据链路层，而是发送在上层。</p><div class="note note-primary">            <p>理解：在单条数据链路上，数据一般不会丢失。失序、重复，这些问题往往发生在网络层。</p>          </div><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/Pic0.png"></p><p>为了解决以上错误，有以下三种可靠协议，这三种协议更多体现的是一种事件确认思想，因此可以应用到各层的协议中。</p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><h4 id="停止-等待协议SW"><a href="#停止-等待协议SW" class="headerlink" title="停止-等待协议SW"></a>停止-等待协议SW</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li>发送端发送数据DATA0后，等待接受方返回一个确认信息ACK0后，再发送下一条数据DATA1。</li><li>为了防止数据的丢失、错误，需要设置<strong>重传时间</strong></li><li>为了防止数据重传造成的重复发送、接受，需要设置一个<strong>Bit位标识数据</strong>区别</li></ul><div class="note note-primary">            <p>这部分的各种特殊情况比较复杂，我们按照事件的发生进行梳理。<br>在数据传输过程中有三个基本问题需要解决：<br><strong>数据丢失</strong>（没传到）、<strong>数据错误</strong>（传错了）、<strong>数据延迟</strong>（传慢了）。</p><p>为了解决<strong>数据丢失</strong>和<strong>数据错误</strong>的问题，发送端需要重发数据，所以设置了一个超时时间，超过时间就会进行<strong>重传</strong>。（实际上对于<strong>数据错误</strong>，接受端也可以主动回复NAK提醒发送端尽快重发，但有线网内这种情况较少，一般只在误码率较高的时候进行）。</p><p>对于<strong>数据延迟</strong>的问题，理想情况其实是等待数据达到，即不需要我们解决。但实际上无法确定是数据是延迟还是丢失，也会导致触发重传，这里就衍生出了一个新问题，即<strong>发送端和接受端都可能接受到两条甚至更多相同的数据</strong>（因为接受端对每条信息都会回复确认，所以发送端也会收到两条确认ACK信息），显然我们要对后面的数据进行忽略，因此需要一个数据标识符做区分，在这里体现为一个bit。</p><p>至此，我们解决了3个基本问题和1个衍生问题。</p>          </div><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-8dbdfdbac8087fd21.webp"></p><h5 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3b4b0d81e5dd78eb.webp"></li></ul><blockquote><p>停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><div class="note note-warning">            <p>为了解决RTT过长的问题，有以下两种协议。</p>          </div><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h5><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cc9d42f63bd259cc.webp"></p><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-2a7141766ab1aa80.webp"></p><ul><li>发送方可以一次性<strong>连续发送</strong>多个数据分组，接受方每接受到一个数据就移动一次窗口，且不需要对每个分组逐个确认，一般设置在接受到若干个数据分组，对接受到的最后一个数据分组进行一次<strong>累计确认</strong>即可。</li><li>传递发生错误时，例如5号分组出现错误则丢弃，此后接收方每接受到一个不是5号的信息都会<strong>主动回复</strong>一个ACK4，请求发送端尽快发送DATA5（发送端在收到多少个ACK4后会提前发送DATA5，由具体实现决定，实际上就算收不到，也会超时重发。）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-215e8704b22ef7f2.webp"></li><li><strong>使用n位bit标识分组</strong>，则编号范围为0~2^n-1，发送窗口大小必须小于2^n-1，否则接收方会出现误判。</li></ul><div class="note note-primary">            <p>相对SW协议，GBN协议为了提高信道利用率，采用了<strong>连续发送与累计确认、主动回复</strong>等方式，在具体的实现上出现了新的问题和解决：</p><ul><li>针对<strong>连续发送与累计确认</strong>，为了识别正确接受顺序，需要使用多bit位标识数据，bit的位数也限制了发送窗口大小。</li><li>针对<strong>主动回复</strong>，客户端之前接受到错误信息和重复分组时会直接舍弃。现在客户端只舍弃错误信息，也因此会接收到许多错误分组信息（不是当前需要的分组），对这些都要进行重复确认ACK。</li></ul><p>当然，超时重传的性质依然存在，这是避免信息丢失的必要手段，主动回复只是一种加速，不是一种保证。</p>          </div><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><h5 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h5><ul><li><strong>扩大接受窗口的尺寸</strong>，接收方可以不用按照顺序接受分组，避免浪费。发送方也可以只重传错误分组。</li><li>由于不再按顺序接受分组，所以需要<strong>逐条确认</strong>，累计确认不再有效。发送，接受方都需要逐个确认。<br><a href="https://www.bilibili.com/video/BV1c4411d7jb/?p=27&vd_source=7324e975d0c1b4b4719d1194e3649ff8">视频参考</a></li></ul><div class="note note-primary">            <p>相当于对分组进行批量的发送接受，只重传错误分组，重传机制仍是超时判断。接收方根据接受到的分组DATA滑动窗口，发送方根据接受到的ACK滑动窗口。</p>          </div><h1 id="三、点对点协议PPP"><a href="#三、点对点协议PPP" class="headerlink" title="三、点对点协议PPP"></a>三、点对点协议PPP</h1><ul><li>点对点协议PPP（<em>Point-to-Point Protocol</em>）是目前使用最广泛的点对点数据链路层协议。</li></ul><div class="note note-primary">            <p>端对端是P2P(Peer-to-Peer)。</p>          </div><h2 id="职责实现"><a href="#职责实现" class="headerlink" title="职责实现"></a>职责实现</h2><p>上文介绍了数据链路层的主要职责和方法，具体协议则需要对各功能做具体实现。</p><h3 id="封装成帧-1"><a href="#封装成帧-1" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>使用了帧头帧尾和对应的转义字符。<br><img src="/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-b384615e861000f3.webp"></p><h4 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h4><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d40da4575c590f5c.webp"></li><li>面向比特的同步链路：比特填充法（插入“比特0”）<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6290c73d8957ee8d.webp"></li></ul><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>使用FCS计算帧部分，立即丢弃错误帧。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-501e6b9dd2afcee3.webp"></p><h1 id="四、媒体接入控制——广播信道"><a href="#四、媒体接入控制——广播信道" class="headerlink" title="四、媒体接入控制——广播信道"></a>四、媒体接入控制——广播信道</h1><blockquote><p><em>Medium Access Control</em>翻译成媒体接入控制，有些翻译成<strong>介质访问控制</strong>，是一种主要用于局域网的数据链路层的广播通信方式。</p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>网络拓扑结构：星形、总线、环形</p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。 <strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><div class="note note-primary">            <p>PPP协议是目前使用最广泛的点对点数据链路层协议，但数据链路层需要解决局域网问题，局域网常常会有共享信道，广播等需求。对于不同类型的局域网，这些需求的解决方式也不尽相同，因此又将数据链路层分为两层，一层解决类似PPP（PPP基本没有第二层问题，其独占信道）的问题，另一层解决传输媒体（主要是信道冲突）上的问题。</p>          </div><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-3d6792f6b442b459.webp"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><div class="note note-primary">            <p>PPP协议对应的交换机技术可以很好的解决共享信道问题，但是无线网络仍需要共享媒体。信道复用问题之前在物理层也提过，但由于物理层主要只解决01传递的问题，这种与传媒相关的问题则交给了数据链路层的MAC子层解决。</p>          </div><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><p><strong>频分复用FDM</strong> (<em>Frequency Division Multiplexing</em>)</p><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。<br><strong>时分复用TDM</strong> (<em>Time Division Multiplexing</em>)</li><li><strong>时分复用</strong>则是将时间划分为一段段<strong>等长</strong>的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。  </li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong><br><strong>波分复用 WDM</strong>(<em>Wavelength Division Multiplexing</em>)</li><li>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。<br><strong>码分复用 CDM</strong> (<em>Code Division Multiplexing</em>)<blockquote><p>复用：信道分为多个子信道，用户使用子信道。<br>多址：动态分配信道给用户，用户暂时占用信道。<br>因此码分复用更多的被称为码分多址。</p></blockquote></li></ul><p>具体实现：使用多个bit位表示1个bit位，解释如下：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-91ed6f416ae8fad6.webp"><br>这样，接受方通过向量计算即可从叠加信号中解析中指定发送方发出的信息。</p><h2 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h2><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>总线局域网</strong>使用CSMA&#x2F;CD（<em>Carrier Sense Multiple Access&#x2F;Collision Detection</em>）协议，即载波监听多址接入&#x2F;碰撞检测。<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-00eb7fba113030d2.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-574d77a51611a634.webp"></p><div class="note note-primary">            <p>CD的硬件实现：判断总线电压摆动值变大超过门限。<br>为什么需要CD：CS具有传播延迟。</p>          </div><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>1.准备发送-&gt;2.载波监听（信道忙则回到1）-&gt;3.发送并碰撞检测（碰撞则停止并等待一段时间回到1）-&gt;4.发送直到完毕</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a77d88a950995527.webp"></p><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-423fe21ffdbacb81.webp"></p><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-fa63a8f164fb9191.webp"></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-93f832e4b0a569ae.webp"></p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dc35877bb4bead1a.webp"></p><h4 id="帧接受过程"><a href="#帧接受过程" class="headerlink" title="帧接受过程"></a>帧接受过程</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-cf2d95546ecf2664.webp"></p><div class="note note-primary">            <p>以上特性、限制都是为了在保证<strong>数据不碰撞</strong>的情况下保证<strong>合理性</strong>。<br><strong>保证不碰撞</strong>：<strong>争用期</strong>，<strong>最小帧长</strong>都是为了保证能检测信道是否有碰撞。<br><strong>合理性</strong>：<strong>最大帧长</strong>，单帧不能过长占用信道，<strong>截断二进制指数退避算法</strong>，灵活延迟避让时间，防止多次重传。</p>          </div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。<br><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong><br><strong>主要的无线网标准：802.11标准</strong><br>为什么无线局域网要使用CSMA&#x2F;CA协议：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-dd01f296832d017a.webp"></p><div class="note note-primary">            <p>分布式协调功能DCF是各站点争用的方式。<br>点协调功能PCF则有一个中心站做协调，但使用较少。</p>          </div><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6c9fe4ae6927eb02.webp"><br>相比载波监听，有信道空闲持续时间限制，其控制了帧的发送间隔。</p><blockquote><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul></blockquote><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a756ebbd569e600a.webp"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><ul><li>防止多个站点同时发送数据而产生碰撞</li></ul></blockquote><p><strong>使用退避算法的时机</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-f0d70f0b26645fb4.webp"></p><p><strong>CSMA&#x2F;CA协议的退避算法</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-1de197cb6f859f3c.webp"></p><p>示例：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-12262e66fc986d52.webp"></p><div class="note note-primary">            <p><strong>碰撞检测CD</strong>的思想类似于<strong>乐观锁</strong>，即先发送，发送后碰撞则进行退避处理。<br><strong>碰撞避免CA</strong>的思想类似于<strong>悲观锁</strong>，需要尽可能的保证信道通畅（通过退避的方式）然后再发送。<br>载波监听则是一种判断是否有锁的工具。</p><p>在CD中，如果当前信道空闲则直接发送信号，失败后则停止发送并等待，随后尝试重新发送。<br>在CA中，如果当前信道空闲，<strong>首先要等待一个DIFS时间</strong>，等待<strong>优先级</strong>更高的站点先尝试获取信道，这个时间之后，<strong>再根据信道的状况判断是否需要进行退避。</strong></p><ul><li><strong>DIFS时间是DCF模式（分布式协调功能）下的退避时间的基本单位。</strong></li><li><strong>默认的DIFS间隔时间并不在退避算法中</strong>。其是整个共享信道的处理完一个帧之后的间隙时间，各个站点以通过信道的这个间隙时间来判断信道进入了空闲状态（空闲了一个DIFS时间），然后解冻倒计时，进行<strong>优先级</strong>争夺。</li></ul>          </div><h4 id="信道预约和虚拟载波监听"><a href="#信道预约和虚拟载波监听" class="headerlink" title="信道预约和虚拟载波监听"></a>信道预约和虚拟载波监听</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-98353d62c0ef033f.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ac35b15f5f22bf7d.webp"></p><div class="note note-primary">            <p>以上为可选功能，通过向目的站发送“要发送数据帧”的请求（<strong>信道预约</strong>），目的站同意这个请求后发出“允许发送数据帧”的广播，此时其他站点就不能使用该信道了。由于RTS、CTS都携带了下次传递的大数据帧信息，因此其他站点知道本次信道会被占用的时间，实现了<strong>虚拟载波</strong>。<br>此时，如果其他站只能监听到目的站信息，监听不到源站信息，其也可以收到CTS从而避免在这个时间段内发送信息，减少了隐蔽站的问题。</p>          </div><h1 id="五、MAC地址、IP地址、ARP地址"><a href="#五、MAC地址、IP地址、ARP地址" class="headerlink" title="五、MAC地址、IP地址、ARP地址"></a>五、MAC地址、IP地址、ARP地址</h1><p>三者的关系：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-ede2c92a0c809e6c.webp"></p><h2 id="MAC-Media-Access-Control-地址"><a href="#MAC-Media-Access-Control-地址" class="headerlink" title="MAC(Media Access Control)地址"></a>MAC(<em>Media Access Control</em>)地址</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><div class="note note-primary">            <p>注意：MAC地址的主要作用标记目的物理地址和源物理地址，在<strong>广播信道</strong>中，所有站点都会接受到MAC帧（也可以由交换机进行调度），然后根据目的物理地址是自身而决定是否舍弃该帧，但对于<strong>点对点的信道（不是协议）</strong> 则不需要MAC帧。</p>          </div><blockquote><ul><li><strong>MAC地址又称为硬件地址或物理地址</strong>。但其属于数据链路层而不是物理层。</li><li>MAC地址是对网络上各接口的唯一标识。</li></ul></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-70ee74506eca1df4.webp"></p><p>有效的 MAC 帧长度为 64 ~ 1518 字节之间。<br>无效MAC帧：</p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；<br>（防止bit丢失）</li><li>用收到的帧检验序列 FCS 查出有差错；<br>（防止bit错误）</li><li>数据字段的长度不在 46 ~ 1500 字节之间。<br> (防止bit增加)<br>以太网检测到无效MAC帧直接丢弃。</li></ul><p>MAC帧发送顺序</p><ul><li>从第一字节发到第六字节</li><li>每字节从b0发到b7</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>单播（单选）：根据站点根据目标地址与自己是否相符决定是否舍弃。</li><li>广播（全选）：<strong>广播MAC地址为全F</strong>，所有站点都接受该帧</li><li>多播（多选）：只发送给指定的若干目的站点。<strong>多播MAC帧的目的地址的第一个bit为1</strong>，即第一个字节的b0位为1。其他站点是否接受则根据自身多播组列表设置。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址属于网络层的范畴，不属于数据链路层的范畴。</p><ul><li>对于局域网而言MAC地址即可区分设备（但现在实际上还是会使用IP地址而不是MAC地址）。</li><li>对于因特网而言MAC地址无法区分一个网络，需要使用IP地址加MAC地址。</li><li>例子：<br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-77c204bc8181b3ed.webp"></li></ul><div class="note note-primary">            <p>参考现实中根据地图导航。<br><strong>IP地址</strong>用来标记起点和终点，从起点到终点需要经过很多交通工具。<br><strong>MAC地址</strong>根据目的IP地址选择当前交通应该在哪站下车然后换乘。<br>这个根据IP地址选择下车站的方法就是<strong>ARP协议</strong></p>          </div><h2 id="ARP协议（地址解析协议Address）"><a href="#ARP协议（地址解析协议Address）" class="headerlink" title="ARP协议（地址解析协议Address）"></a>ARP协议（地址解析协议Address）</h2><p>主机都有一个ARP高速缓存表，其中记录了IP地址和MAC地址的映射。</p><ul><li>如果表中记录了IP地址对应的MAC地址，则可以直接填写目的MAC地址发送MAC帧。</li><li>如果不知道，则发送<strong>ARP请求报文</strong>（广播）。目的IP地址的主机接受到该请求后会给源主机回复自己的MAC地址。</li></ul><p><strong>ARP高速缓存表</strong><br>有动态记录和静态记录。</p><ul><li>动态记录为自动获取，有持续时间、过期作废（默认两分钟）</li><li>静态记录为手工设置，始终保存（实际上依赖于操作系统的实现）。</li></ul><blockquote><p>ARP是逐段链路进行的。即主机只记录和自己直接连接主机的MAC地址，跨网络的地址则不管。</p></blockquote><div class="note note-primary">            <p>这里的ARP的作用主要是让机器通过广播形式学习和自己直连的设备的IP-MAC映射关系，<strong>方便其填入MAC帧的目的地址</strong>，并不能告知他应该如何把数据准确的发送到哪个主机。</p><p>ARP没有安全验证机制，可能<strong>存在ARP欺骗（攻击）问题</strong>。</p><p>ARP表中记录<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>          </div><h1 id="六、集线器和交换机"><a href="#六、集线器和交换机" class="headerlink" title="六、集线器和交换机"></a>六、集线器和交换机</h1><h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul><li>在总线型网络中，所有站点共享一个信道。但总线的拓扑结构在<strong>物理层</strong>实现很不方便，所以可以使用集线器作为中点，网络结构则变成了<strong>星型结构</strong>。</li><li>但实际上其在以太网上仍是一个<strong>总线型网络</strong>。集线器也只工作在物理层，并没有网络管理作用。</li><li>集线器是也可以看做多口<strong>中继器</strong>，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>扩展网络（<strong>扩大广播域</strong>），两个集线器直接连接即构成了更大的总线网络。但<strong>碰撞域</strong>却增大了。</p><blockquote><p><strong>碰撞域</strong>（<em>collision domain</em>）又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p></blockquote><div class="note note-primary">            <p>集线器工作在物理层，而下文中的交换机工作在数据链路层。</p>          </div><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是网桥的替代品，是一个多接口的网桥。<br><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃（<strong>具有管理作用</strong>）。<br><strong>交换机</strong></li><li>1990 年问世的交换式集线器 (<em>switching hub</em>) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (<em>switch</em>) 或<strong>第二层交换机</strong> (<em>L2 switch</em>)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul><p>相对于集线器，其可以进行ARP自学习，并将数据帧定向转发。</p><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度</li><li>不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-d5c429a2f92149ff.webp"></p><p><strong>扩大广播域</strong>的同时，<strong>隔离碰撞域</strong></p><blockquote><p><strong>广播域</strong>（<em>broadcast domain</em>）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。注意要与前面的碰撞域做区分。</p></blockquote><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-25db1be3ca96bc2f.webp"></p><h3 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h3><p>以太网交换机通过<strong>自学习算法</strong>建立<strong>帧交换表</strong></p><h4 id="自学习算法"><a href="#自学习算法" class="headerlink" title="自学习算法"></a>自学习算法</h4><ul><li>交换机接受到一个数据帧后就会记录这个帧的<strong>源地址</strong>和对应的交换机<strong>端口</strong>（没有则插入，有则更新）</li></ul><h4 id="转发行为"><a href="#转发行为" class="headerlink" title="转发行为"></a>转发行为</h4><ul><li>交换接的帧交换表中如果有该帧<strong>目标地址</strong>对应的端口，则直接将消息转发到该端口，否则发送<strong>广播</strong>（但不对源地址发送）。</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>每条记录都有有效时间，有效时间到期后删除。（主机可能换网卡，交换机可能改接另一台主机）</li></ul><div class="note note-primary">            <p>注意本处的自学习和前面提到的ARP的异同：<br>异：</p><ul><li>ARP记录的是IP和MAC地址之间的映射关系，记录在ARP高速缓存表中。交换机的自学习记录的是MAC地址与自己的端口的关系，记录在帧交换表中。</li><li>ARP高速缓存表主要用于根据上层的目的IP地址填入目的MAC地址。交换机帧纪录表则用于根据目的MAC地址选择往哪个端口发送。</li><li>实现在不同层面，ARP的实现在逻辑上，依赖于非目标主机会自行舍弃帧；交换机实现在物理上，依赖于只发送给目标机。可以认为交换机是对ARP的总线结构下的一种信道层面优化，减少了各个客户端识别帧的负担并解决碰撞问题。<br>同：</li><li>有已知记录时都会直接发送，没有时都会进行广播学习。</li></ul>          </div><h1 id="七、生成树协议STP"><a href="#七、生成树协议STP" class="headerlink" title="七、生成树协议STP"></a>七、生成树协议STP</h1><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><p>想要提高以太网的<strong>可靠性</strong>，可以尽可能多的添加交换机之间的连线（<strong>冗余链路</strong>）。这样两个交换机之间就不会因为一条链路出现故障而无法通讯。但这样会造成重复广播等问题，因此需要避免<strong>逻辑上的环路</strong>（保留物理上的环路以备用）。</p><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a65d811129786ec6.webp"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><blockquote><p>STP的工作过程如下：首先进行根网桥的选举，其依据是网桥优先级（bridge priority）和MAC地址组合生成的桥ID，桥ID最小的网桥将成为网络中的根桥（bridge root）。在此基础上，计算每个节点到根桥的距离，并由这些路径得到各冗余链路的代价，选择最小的成为通信路径（相应的端口状态变为forwarding），其它的就成为备份路径(相应的端口状态变为blocking)。STP生成过程中的通信任务由BPDU完成，这种数据包又分为包含配置信息的配置BPDU（其大小不超过35B）和包含拓扑变化信息的通知BPDU（其长度不超过4B）。</p></blockquote><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong> (<em>Spanning Tree Protocol</em>)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><h1 id="八、虚拟局域网VLAN"><a href="#八、虚拟局域网VLAN" class="headerlink" title="八、虚拟局域网VLAN"></a>八、虚拟局域网VLAN</h1><h2 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h2><p>集线器和交换机扩大了广播域，但是广播域过于又会造成广播风暴，我们希望能够实现局部广播功能。</p><p><strong>广播风暴</strong><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a2a78b40ae5307db.webp"></p><h2 id="分割局域网的方法"><a href="#分割局域网的方法" class="headerlink" title="分割局域网的方法"></a>分割局域网的方法</h2><ol><li>使用路由器</li><li>VLAN(<em>Virtual LAN</em>)虚拟局域网</li></ol><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><blockquote><ul><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>： <strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li></ul></blockquote><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>本质上是要求使用<strong>交换机</strong>实现逻辑上将一个局域网划分成几个虚拟局域网（将一个交换机分成多个交换机），即判断一条广播消息属于哪一个组，因此这种MAC帧需要多一个明确的标识符以供交换机判断。</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li></ul><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-5d3549cc02f9a3b4.webp"><br><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-6af352f81b800a98.webp"></p><h3 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h3><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-44a2e259c33ecfd3.webp"></p><h4 id="Truck端口"><a href="#Truck端口" class="headerlink" title="Truck端口"></a>Truck端口</h4><p><img src="/2022/12/11/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC3%E7%AB%A0%EF%BC%88%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%89/24878825-a93996aae716c6aa.webp"></p><h4 id="Hybrid端口"><a href="#Hybrid端口" class="headerlink" title="Hybrid端口"></a>Hybrid端口</h4><p>是华为私有的端口类型，既可以用于交换机之间或交换机与路由器之间互连，也可以用于交换机与计算机之间互联。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><div class="note note-primary">            <p>数据链路层主要要负责将数据正确的送到目的地。</p><p>其需要在逻辑上实现其职责(逻辑链路控制LLC)：封装帧、差错检测和可靠重传。典型实现是PPP。</p><p>也需要与物理层的交界处实现对共享媒体控制(媒体接入控制MAC)：控制共享媒介的使用策略。典型实现是CSMA&#x2F;CA协议。</p><p>以上内容保证了数据的完整性，但我们还需要保证数据能正确送到指定主机或进行广播。因此需要ARP表来指明目的主机的MAC地址。</p><p>集线器与普通总线结构网络没有区别，而交换机则在可以根据目标MAC地址定向转发MAC帧，避免了碰撞问题，扩大了广播域。</p><p>最后，由于广播域的扩大会造成广播风暴，也有以下两种解决方法：</p><ul><li>为了避免循环广播，需要生成树协议。</li><li>为了避免广播到不必要的区域，需要VLAN。</li></ul>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/6b82134a4325">计算机网络第3章（数据链路层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第2章（物理层）</title>
    <link href="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/"/>
    <url>/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、物理层的基本概念"><a href="#一、物理层的基本概念" class="headerlink" title="一、物理层的基本概念"></a>一、物理层的基本概念</h1><p>物理层主要考虑如何传输数据比特流。</p><h1 id="二、物理层传输媒体"><a href="#二、物理层传输媒体" class="headerlink" title="二、物理层传输媒体"></a>二、物理层传输媒体</h1><p><strong>传输媒体</strong>也称为传输介质或传输媒介，分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><ol><li>同轴电缆（已被淘汰）</li><li>双绞线（主要用于局域网）</li><li>光纤（主要用于ISP接入服务）<ul><li>多模光纤：允许多条不同角度的光纤同时传输</li><li>单模光纤：如同一根波导，没有反射</li></ul></li><li>电力线（主要用于家庭网络扩展：猫）</li></ol><h2 id="非引导型传输媒体"><a href="#非引导型传输媒体" class="headerlink" title="非引导型传输媒体"></a>非引导型传输媒体</h2><ol><li>无线电波（波长1m-10km）</li><li>微波（波长1mm-1m）</li><li>红外线（已淘汰，只能直线传输）</li><li>可见光（LIFI）</li></ol><h1 id="三、传输方式"><a href="#三、传输方式" class="headerlink" title="三、传输方式"></a>三、传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><strong>串行传输</strong>：数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可<br><strong>并行传输</strong>：一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p><div class="note note-primary">            <p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>          </div><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><strong>同步传输</strong>：以<strong>比特流</strong>的形式传输。字节之间没有间隔。<br><strong>异步传输</strong>：以<strong>字节</strong>为传输单位，字节之间的时间间隔不固定。</p><p>同步传输需要解决时钟问题，即数据的接收方如何判断哪一部分是一个字节：<br>对于同步传输，有两种方式同步时钟：</p><ul><li>外同步：添加独立时钟信号线</li><li>内同步：通过编码信息判断</li></ul><p>异步传输把字节之间断开，根据字节开始和结尾判断即可：</p><ul><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><h2 id="单双工"><a href="#单双工" class="headerlink" title="单双工"></a>单双工</h2><p>信道（<em>channel</em>）：信道一般都是用来表示向某一个方向传送信息的媒体。</p><p>单工：单向传输<br>半双工：双向（不能同时，需要两条信道）<br>双工：双向（同时，需要两条信道）</p><h1 id="四、编码和调制"><a href="#四、编码和调制" class="headerlink" title="四、编码和调制"></a>四、编码和调制</h1><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-acc59055804f0890.webp"></p><blockquote><p>术语：<br><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</p></blockquote><div class="note note-primary">            <p>编码和调制主要解决如何将0，1比特流转化为可以传输的信号形式。<br>码元（code）：对于本章的学习，可以理解为表示一个比特的单元波形。<strong>实际上，根据编码的不同，一个码元可以对应于几个比特，但也可以是几个码元对应于一个比特</strong>。</p><p>基带信号：表示数据传输前的原始信号。</p><p>针对不同的信道（媒介）有不同的方式：</p><ul><li>对于数字信道，其可以清楚的区分电平的高低，因此可以采用<strong>编码</strong>的方式处理原始信号。</li><li>对于模拟信道，一般使用波作为媒介，需要通过控制信号的频率和相位（即<strong>调制</strong>）的方式处理原始信号</li></ul>          </div><blockquote><p>严格来说，传输媒体 ≠ 信道，使用信道复用技术时，一条传输媒体可以包含多个信道。</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>不归零编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-0732d0edc74846b5.webp"><br>缺点：没有时钟同步。<br><strong>归零编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-8aa838a116fdafb4.webp"><br>缺点：每个码元都要归零，数据量太大，编码效率低。<br><strong>曼彻斯特编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-a34a686a9d052e9c.webp"><br>通过跳变方向判断比特位。</p><div class="note note-primary">            <p>相对归零编码，省去了当比特变化为<code>10101010</code>样式时的归零行为，不过对于<code>00000000</code>形式的编码，数据量仍比较大，每次上升后需要在码元间隙下降，如上图的第二个0后面，以便于下一次上升。</p><p>问题：<br>这个码元间隙的下降行为是否导致时钟的误判问题。<br>解释：<br>所谓时钟同步，可以理解为一个打点计时器（？），设备根据打点瞬间电信号的电平判断这个比特位为0还是1，所以若是打点计时器的频率或初始时间与发送端不一致，就会得到失真的信号，这种现象也叫时钟滑移。<br>而曼彻斯特码元间的下降&#x2F;上升行为其实不会被视为下降沿&#x2F;上升沿，因为其实这种编码还是有一个隐藏时钟。对于设备来说，其可以判断接受到的电信号的最短时间间隔，从而判断一个码元的时间长度。（1个码元时间&#x3D;2个最短时间间隔），这样就解决了频率问题。<br>而一个码元单元必然有一个跳变，码元之间不一定有，从而解决了相位问题。</p>          </div><p><strong>差分曼彻斯特编码</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-9a758474e374329a.webp"><br>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li>跳变仅表示时钟</li><li>码元开始处电平是否变换表示数据<br>优点：比曼彻斯特编码的变化少，曼彻斯特编码为了得到正确的跳变方向有时需要在码元结束时置反，即（连续1和连续0时会导致码元间置反），而这里连续0<strong>或</strong>连续1时（具体看规定变化为0还是1），不需要进行置反。变化相对少一些。</li></ul><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。<br>每个基本波形只能表示1比特信息量。</li></ul><h3 id="混合调制"><a href="#混合调制" class="headerlink" title="混合调制"></a>混合调制</h3><ul><li>在编码中两个电位（一个表示时钟一个表示值）的信息即可表示1比特信息。而对于模拟信号，其有更多维度的信息（同上调制的基本方法），因此可以尝试使用一个码元表示多个比特。</li><li>频率就是相位的变化速率，因此两者不可同时调制。</li></ul><p><strong>正交振幅调制QAM</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1cb6de826ba63b70.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-1e2617434d904ce4.webp"></p><ul><li>给出了12个相位（角度），其中有4个角度（45°）有两个振幅，则共有：8 * 1 + 4 * 2 &#x3D; 16种码元。</li><li>故一个码元的信息量为 2^4，可以表示4位bit。</li></ul><h1 id="五、信道的极限容量"><a href="#五、信道的极限容量" class="headerlink" title="五、信道的极限容量"></a>五、信道的极限容量</h1><p>传输信号时会产生各种失真。</p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-b90918937a54faa6.webp"></p><div class="note note-primary">            <p>奈氏准则主要给出一条信道的最高码元传输效率（理论）<br>波特率：码元传输速率<br>比特率&#x3D;波特率 * 每波特携带比特数<br>那么要提高比特率，则要提高每波特携带比特数。</p>          </div><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-57e105e5df793b93.webp"></p><div class="note note-primary">            <p>信噪比：理解起来可以视为信号相对噪音的占比，这个值越大，极限传输速率越高。</p>          </div><div class="note note-info">            <p>奈氏准则主要指出<strong>码元比特量</strong>对传输极限的影响。<br>香农准则主要指出<strong>信噪比</strong>对传输极限的影响。</p>          </div><h1 id="六、信道复用技术"><a href="#六、信道复用技术" class="headerlink" title="六、信道复用技术"></a>六、信道复用技术</h1><h2 id="复用技术类型"><a href="#复用技术类型" class="headerlink" title="复用技术类型"></a>复用技术类型</h2><ul><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽（频率带宽）资源</strong><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-bcb9321a6a8a3d7a.webp"></li><li><strong>时分复用TDM</strong>（<em>Time Division Multiplexing</em>）则是将时间划分为一段段等长的**时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。（可能浪费）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-cb9a20b7ce00d497.webp"></li><li><strong>统计时分复用 STDM</strong> (<em>Statistic TDM</em>)，弥补时分中的浪费，按需分配。<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-7f0b54d1c14702ca.webp"></li><li><strong>波分复用WDM</strong>(<em>Wavelength Division Multiplexing</em>)<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC2%E7%AB%A0%EF%BC%88%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%89/24878825-039cdf67599ebe3b.webp"></li><li><strong>码分复用</strong>（<em>Code Division Multiplexing</em>），常用的名词是<strong>码分多址</strong> CDMA (<em>Code Division Multiple Access</em>)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/792648675640">计算机网络第2章（物理层）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第1章（概述）</title>
    <link href="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <url>/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong>互连网</strong>（<em>internet</em>）：多个网络通过路由器互连起来构成的网络（通用名词，可使用任意协议）<br><strong>因特网</strong>（<em>Internet</em>）：是世界上最大的互连网（专有名词，使用TCP&#x2F;IP协议）<br><strong>ISP</strong>（<em>Internet Service Provider</em>）：因特网服务提供者，如电信、联通、移动。</p><p><strong>端系统之间通信</strong>：主机 A 的某个进程和主机 B 上的另一个进程进行通信。</p><div class="note note-primary">            <p>端对端通讯分为两大类：C&#x2F;S（<em>client-server</em>）和P2P（<em>peer-to-peer</em>）</p>          </div><h1 id="二、交换方式"><a href="#二、交换方式" class="headerlink" title="二、交换方式"></a>二、交换方式</h1><h2 id="1-电路交换（Circuit-Switching）"><a href="#1-电路交换（Circuit-Switching）" class="headerlink" title="1.电路交换（Circuit Switching）"></a>1.电路交换（<em>Circuit Switching</em>）</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-acb87df045723236.webp"></p><blockquote><p>步骤：<br>1.建立连接 2.通话 3.释放连接</p></blockquote><h2 id="2-分组交换（Packet-Switching）"><a href="#2-分组交换（Packet-Switching）" class="headerlink" title="2.分组交换（Packet Switching）"></a>2.分组交换（<em>Packet Switching</em>）</h2><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>称为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方：</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器：</p><ul><li>缓存分组</li><li>转发分组</li></ul><p>接收方：</p><ul><li>接收分组</li><li>还原报文</li></ul><h2 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h2><p>报文交换对报文的大小没有限制，主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h2 id="4-对比"><a href="#4-对比" class="headerlink" title="4.对比"></a>4.对比</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e655a213714d1871.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-c56f91f290cbc92b.webp"></p><h1 id="三、定义与分类"><a href="#三、定义与分类" class="headerlink" title="三、定义与分类"></a>三、定义与分类</h1><h2 id="按覆盖范围"><a href="#按覆盖范围" class="headerlink" title="按覆盖范围"></a>按覆盖范围</h2><ul><li>广域网WAN（<em>Wide Area Network</em>）</li><li>城域网MAN（<em>Metropolitan</em>）</li><li>局域网LAN（<em>Local</em>）</li><li>个域网PAN（<em>Personal</em>）</li></ul><h2 id="按结构"><a href="#按结构" class="headerlink" title="按结构"></a>按结构</h2><ul><li>总线<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-4ed63e74d9ced719.webp"></li><li>星型<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f6a1849bcc443935.webp"></li><li>环形<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ca133aaaf8fe8659.webp"></li><li>网络<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-d0d30cddc7356396.webp"></li></ul><h1 id="四、性能指标"><a href="#四、性能指标" class="headerlink" title="四、性能指标"></a>四、性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ba6c4e627a62c05e.webp"></p><div class="note note-primary">            <p>速率的k一般指1000，数据量的k为1024</p>          </div><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f4b18e0039f4a6c6.webp"></p><div class="note note-primary">            <p>带宽在模拟信号中指频率范围，在计网中指最高<strong>速率</strong>。<br>关联在于，频率越高，速率越高。</p>          </div><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位时间通过某网络的数据量</p><div class="note note-primary">            <p>带宽相当于理论值、吞吐量为真实值。</p>          </div><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延 &#x3D; 发送时延+传播时延+处理时延+排队时延</p><blockquote><p>有时会把排队时延看成<strong>处理时延的一部分</strong><br>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><div class="note note-primary">            <p>m &#x3D; 2 * 10^8</p>          </div><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><div class="note note-primary">            <p>表示链路上有多少个bit正在流动</p>          </div><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p>RTT(<em>Round-Trip Time</em>)</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-62d6da59682ef67f.webp"></p><div class="note note-primary">            <p>信道利用率针对具体信道，网络针对全网络信道，都是对时间的利用统计。</p>          </div><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>一定时间范围内，丢失分组数量与总分组数量的比率</p><h1 id="五、体系结构"><a href="#五、体系结构" class="headerlink" title="五、体系结构"></a>五、体系结构</h1><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b5174af1551d6cee.webp"></p><div class="note note-primary">            <p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。<br>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p>          </div><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6800e214b18c47c3.webp"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="1-发送"><a href="#1-发送" class="headerlink" title="1.发送"></a>1.发送</h3><p>应用层（<strong>HTTP请求报文</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-ac36f7a9544dde9f.webp"><br>传输层（<strong>TCP报文段</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-cc2b73b1736d5809.webp"><br>网络层（<strong>IP数据报</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-dc02183dcf759d9e.webp"><br>数据链路层（<strong>帧</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f8cf8ce4a6bfdb54.webp"><br>物理层（<strong>比特流</strong>）<br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-e7285afa504bce0d.webp"></p><h3 id="2-路由转发"><a href="#2-路由转发" class="headerlink" title="2.路由转发"></a>2.路由转发</h3><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-b9824f4625354b9b.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-09a0b27933c9895e.webp"><br><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-6eace5a882cca26d.webp"><br>再整个封装回去。</p><div class="note note-primary">            <p>路由器主要作用在网络层及以下，主要根据路由表查询端口转发IP数据包。</p>          </div><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>实体：任意可发送或接受信息的硬件或进程</li><li>对等实体：相同层次的实体</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-01d621fd0afde0a2.webp"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合<br><strong>协议三要素：</strong></p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><img src="/2022/12/10/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89/24878825-f9bd7898a7f2dadd.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.337.search-card.all.click&vd_source=7324e975d0c1b4b4719d1194e3649ff8">计算机网络微课堂</a><br><a href="https://www.jianshu.com/p/541d4f0c0f1e">计算机网络第1章（概述）简书笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>计网基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-基础篇</title>
    <link href="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、TCP-x2F-IP网络模型"><a href="#一、TCP-x2F-IP网络模型" class="headerlink" title="一、TCP&#x2F;IP网络模型"></a>一、TCP&#x2F;IP网络模型</h1><p>主要针对TCP&#x2F;IP网络模型。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层</strong>（<em>Application Layer</em>）只专注于提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="传输层"></p><p>传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p><strong>TCP</strong> 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p><strong>UDP</strong> 只负责发送数据包，不保证数据包是否能抵达对方。但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><h3 id="应用层与传输层的交互"><a href="#应用层与传输层的交互" class="headerlink" title="应用层与传输层的交互"></a>应用层与传输层的交互</h3><p>应用需要传输的数据可能会非常大，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/TCP%E6%AE%B5.png" alt="TCP段"></p><p>传输层其实并不负责整个传输过程，它的作用是相对应用层而言的，即它可以帮助应用层实现数据传输。</p><p>到传输层数据到达目标设备时，传输层则要负责把数据包传给应用，但一台设备有多个应用，这时需要使用端口号将应用区分开来。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。传输层报文中携带端口号，因此可以识别数据要发给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>如上所述，传输层其实主要做区分应用，把应用数据下发的作用，真正使数据在互联网上传输的功能在<strong>网络层</strong>（<em>Internet Layer</em>）上。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/112.jpg"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。</p><p>将IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>配合<strong>子网掩码</strong>，可以将一个网络号同时给多个主机使用，子网掩码则用于计算 网络号和主机号。</p><p>如10.100.122.0&#x2F;24后面的<code>/24</code>表示就是 <code>255.255.255.0</code>，将IP地址与子网掩码按位与，得到网络号，与子网掩码的取反按位与，则得到主机号。</p><p>寻找目标地址的过程，就是一个寻找网络-&gt;寻找主机的过程。</p><p><strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网路接口层"><a href="#网路接口层" class="headerlink" title="网路接口层"></a>网路接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="网络接口层"></p><p>网络层实现了信息在互联网上传输的功能，而要将信息传输到互联网，我们还需要经过网络接口层。</p><p>网络接口层的功能主要体现在以太网技术上，即通过局域网把网络包发送到目的地。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务。个人理解是在数据的传输中，数据包会经过很多交换机，交换机会将数据包解包至网络接口层，然后再封装，发送。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>使用 MAC 地址，我们可以标识网络上的设备，实现在以太网、WiFi 这样的底层网络上发送原始数据包。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，TCP&#x2F;IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="tcpip参考模型"></p><p>封装格式：</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.png" alt="封装"></p><div class="note note-info">            <p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>          </div><blockquote><p>应用层负责将应用产生的数据传递给传输层，将从传输层接受到的数据组合，返回给应用。</p><p>传输层负责将从应用层接受到的数据包传递给网络层，这个过程会携带应用端口</p><p>网络层负责将从传输层接受到的数据包发送到网络，这个过程会携带IP地址（网络号+主机号&#x2F;子网掩码）</p><p>网络接口层负责将网络层的数据通过以太网技术的方式发送到数据库</p></blockquote><h1 id="二、浏览器请求过程"><a href="#二、浏览器请求过程" class="headerlink" title="二、浏览器请求过程"></a>二、浏览器请求过程</h1><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/2.webp"></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-解析URL"><a href="#1-解析URL" class="headerlink" title="1.解析URL"></a>1.解析URL</h3><p>浏览器先解析URL地址，然后生成给WEB服务器的信息。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/103.webp"><br>如果省略资源路径，则会访问Web服务根目录的<code>index.html</code>或<code>default.html</code></p><h3 id="2-生成HTTP请求信息"><a href="#2-生成HTTP请求信息" class="headerlink" title="2.生成HTTP请求信息"></a>2.生成HTTP请求信息</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/104.webp"></p><div class="note note-primary">            <p>HTTP报文三要素：</p><ul><li>请求报文：请求行(req)+请求头(head)+请求体(body)</li><li>响应报文：状态行(status)+消息头(head)+消息体(body)</li></ul>          </div><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>消息发送前需要<strong>查询服务器域名对应的IP地址</strong><br>因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>DNS是一种服务器，其专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系。<br>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。<br>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>，这与中文相反。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。即<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code></p><p>所以实际上是 .  –&gt; .com –&gt;server<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/105.webp"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p><p>也就是说，查询域名IP时：</p><ol><li>客户端只会向最近的本地DNS服务器请求ip地址。</li><li>本地DNS服务器若记录了ip地址，则直接返回，若没有记录，则进行以下操作。</li><li>本地DNS向根DNS服务器请求ip地址，根DNS将.com的DNS服务器给本地DNS服务器。</li><li>本地DNS服务器再向.com的DNS（顶级域名服务器）请求ip地址，顶级域名服务器将<a href="http://www.server.com的权威/">www.server.com的权威</a> DNS 服务器给本地DNS服务器。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，然后客户端和目标建立连接。</li></ol><div class="note note-warning">            <p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明目标服务器的位置。</p>          </div><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/106.webp"></p><blockquote><p>DNS 域名解析的过程是一个<strong>只指路不带路</strong>的过程。</p></blockquote><div class="note note-primary">            <p>当然，浏览器、操作系统、hosts文件都有缓存，在这些地方都找不到时才会向本地DNS服务器发请求。</p>          </div><h2 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h2><p>通过DNS获取到IP后，就可以把HTTP的传输工作交给操作系统中的<strong>协议栈</strong>。</p><div class="note note-primary">            <p>注意这里开始进入操作系统层面。</p>          </div><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/107.webp"></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。</p><p>协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code>用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code>用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><p>进入协议栈后，就依靠各层协议一步一步完成数据传输。 </p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>HTTP 是<strong>基于TCP协议</strong>传输的，TCP报文格式如下：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/108.webp" alt="TCP报文"></p><p>理解：</p><ul><li><strong>源端口号</strong>和<strong>目标端口</strong>号：这是与应用层交互的关键识别信息。</li><li>包<strong>序</strong>号，防止乱序</li><li><strong>确认号</strong>，防止丢包</li><li><strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li><strong>窗口大小</strong>：TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，从而实现<strong>拥塞控制</strong>：即控制发送的速度。</li></ul><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>所谓的握手就是使通讯双方维护一个状态机。<br><img src="/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.webp"></p><blockquote><p>SYN指<strong>SYN：同步序列编号</strong>（ Synchronize Sequence Numbers ）<br>ACK指<strong>ACK：确认字符</strong>（Acknowledge character）</p></blockquote><div class="note note-success">            <p>三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>          </div><div class="note note-primary">            <p>TCP 的连接状态查看，在Linux可以通过<code>netstat -napt</code>命令查看。</p>          </div><h3 id="TCP数据分割"><a href="#TCP数据分割" class="headerlink" title="TCP数据分割"></a>TCP数据分割</h3><p>若HTTP请求报文较长，超过了 <code>MSS</code> 的长度则需要拆解。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/111.webp"></p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/112.webp"></p><p>拆分出来的每一块数据都会被放进单独的网络包中，分别加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/113.webp"></p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/114.webp"></p><ul><li>IP包头的<strong>协议号</strong>，要填写为<code>06</code>（十六进制），表示协议为 TCP。</li></ul><h3 id="网卡选择"><a href="#网卡选择" class="headerlink" title="网卡选择"></a>网卡选择</h3><p>如何填写源地址IP？<br>根据<strong>路由表</strong>规则，判断哪个网卡作为源地址。<br>使用 <code>route -n</code> 命令查看当前系统的路由表。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/115.webp"></p><ol><li>将目标IP地址与掩码逐行做 <strong>与运算</strong>，如果等于目的Destination，则匹配成功。</li><li>如果都无法匹配，则匹配最后一行，将IP发送给路由器（<strong>默认网关</strong>）</li></ol><h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/118.webp"></p><p>一般在 TCP&#x2F;IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ：IP协议</li><li><code>0806</code> ：ARP协议</li></ul><p><strong>接收方MAC地址如何填写？</strong><br>ARP协议，通过广播的方式获取以太网中路由器的MAC地址。<br>ARP有缓存空间（几分钟），可以先查询缓存，未命中才广播。</p><h2 id="出口-网卡"><a href="#出口-网卡" class="headerlink" title="出口-网卡"></a>出口-网卡</h2><p><strong>数字信息转换为电信号</strong>。<br>通过网卡（硬件）+网卡驱动程序（软件）一起完成数据的发送。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.webp"></p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。<br>交换机：</p><ol><li>电信号-&gt;数字信号</li><li>MAC帧FCS矫错</li><li>根据MAC帧地址转发MAC帧</li><li>找不到则广播（除源端口）</li><li>只有相应的接受者才会接受MAC帧</li></ol><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/123.webp"></p><p>PS：这里注意<strong>交换机的端口不具有MAC地址</strong>，其只起转发包作用。</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/124.webp"></p><p>路由器工作：</p><ol><li>接受发送给自己的MAC帧</li><li>FCS矫错</li><li>根据帧中IP查找路由表，确定对应的接口</li><li>若找不到则选择默认路由。</li><li>要根据目标IP行的网关列判断发送到目标IP后是否还需要继续转发<ul><li>网关为IP地址，说明还要继续转发（IP聚合）</li><li>网关为空，则说明达到了目标地址</li></ul></li><li>根据ARP协议，使用IP地址查询MAC地址（路由器也有ARP缓存）</li><li>发送</li></ol><p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h2 id="服务端与客户端"><a href="#服务端与客户端" class="headerlink" title="服务端与客户端"></a>服务端与客户端</h2><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/125.webp"></p><h1 id="三、Linux系统如何收发网络包"><a href="#三、Linux系统如何收发网络包" class="headerlink" title="三、Linux系统如何收发网络包"></a>三、Linux系统如何收发网络包</h1><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/OSI%E4%B8%8ETCP.webp"></p><h2 id="Linux-网络协议栈"><a href="#Linux-网络协议栈" class="headerlink" title="Linux 网络协议栈"></a>Linux 网络协议栈</h2><p>封装：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%B0%81%E8%A3%85.webp"><br>以太网中，规定了<strong>最大传输单元</strong>（MTU）是 <code>1500</code> 字节，也就是规定了单次传输的最大 IP 包大小。</p><p>Linux网络栈：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E5%8D%8F%E8%AE%AE%E6%A0%88.webp"></p><ul><li>应用程序需要通过系统调用，来跟 Socket 层进行数据交互；</li><li>Socket 层的下面就是传输层、网络层和网络接口层；</li></ul><h2 id="Linux接受包"><a href="#Linux接受包" class="headerlink" title="Linux接受包"></a>Linux接受包</h2><p>当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>方式：</p><ul><li>触发中断：也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。（网络包过多时中断也太多，过时）</li><li><strong>NAPI 机制</strong>：<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</li></ul><p>硬件中断处理函数会做如下的事情：</p><ul><li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免CPU不停的被中断。</li><li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li></ul><div class="note note-primary">            <ol><li>DMA技术写入<strong>ring buffer</strong>，然后触发<strong>硬件中断请求</strong>。</li><li>CPU在中断表中调用注册好的中断函数：<ul><li>软中断：不直接中断，而是暂时屏蔽中断并发起软中断。</li></ul></li><li>软中断后内核线程ksoftirqd轮询处理数据。</li></ol>          </div><h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<br>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><h3 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h3><p><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.webp"></p><h2 id="Linux-发送包"><a href="#Linux-发送包" class="headerlink" title="Linux 发送包"></a>Linux 发送包</h2><ol><li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的sk_buff内存，<strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</li><li>网络协议栈从 Socket 发送缓冲区中取出sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</li><li>TCP 传输协议发送数据，那么<strong>先拷贝一个新的sk_buff 副本</strong>，这是因为sk_buff后续在调用网络层，最后到达网卡发送完成的时候，这个sk_buff会被释放掉。而TCP协议是支持丢失重传的，在收到对方的ACK之前，这个sk_buff不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</li><li>对 sk_buff 填充 TCP 头。sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</li><li>交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</li><li>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。</li><li>这一些工作准备好后，会触发「<strong>软中断</strong>」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将sk_buff数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</li><li>当发送完成的时候，网卡设备会触发一个<strong>硬中断</strong>来释放内存，主要是释放 sk_buff 内存和清理 RingBuffer 内存。</li></ol><p>通过调整 sk_buff 中 <code>data</code> 的指针，比如：<br><img src="/2022/12/09/%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E7%AF%87/sk_buff.webp"><br>即可实现使用同一个数据结构描述各层的数据。</p><p><strong>发送网络数据的时候，涉及几次内存拷贝操作？</strong></p><ul><li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li><li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</li></ul><div class="note note-primary">            <p>注意这个sk_buff</p>          </div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://xiaolincoding.com/network/#%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%BE%A4%E4%BD%93">小林coding</a></p>]]></content>
    
    
    <categories>
      
      <category>概念整理</category>
      
      <category>计算机网络</category>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概念整理</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
